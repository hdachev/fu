
        struct vec3 { v: i32 };
        struct mat34 { mx: vec3; my: vec3; mo: vec3 };
        fn translate = vec3(0);

        fn mat34(using scale: vec3)
            mat34(
                vec3(v),    // Intent of using was just to destructure the vec3 here.
                vec3(v),
                // translate, Forgot this, compiles without it, got really confused.
                            // It's surprising when usings feed into constructors,
                            //  but i don't like the idea of making them special either.
                            //   Perhaps require argnames when multiple members have same type?
            );

        fn main() mat34(vec3(1)).mo.v;

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

struct vec3_ov2r;
struct mat34_KFOl;

                                #ifndef DEF_vec3_ov2rswbadXk
                                #define DEF_vec3_ov2rswbadXk
struct vec3_ov2r
{
                                // shape_hash:    a48e41798478314f
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_mat34_KFOlaLC01F0
                                #define DEF_mat34_KFOlaLC01F0
struct mat34_KFOl
{
                                // shape_hash:    c76847564dc94b70
                                // non_triv_mask: 0000000000000000
    vec3_ov2r mx;
    vec3_ov2r my;
    vec3_ov2r mo;
    explicit operator bool() const noexcept
    {
        return false
            || mx
            || my
            || mo
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static mat34_KFOl mat34_MbR9(/*1:1*/ const vec3_ov2r& scale)
{
    return mat34_KFOl { vec3_ov2r(scale), vec3_ov2r { scale.v }, vec3_ov2r { scale.v } };
}

int fu_MAIN()
{
    return mat34_MbR9(vec3_ov2r { 1 }).mo.v;
}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 1
========

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };
        fn main() {
            infix fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i); // its hard to defend this -
            _0::template_add(HasInt(1), HasInt(2)).i - 3;       //  the thing above works but this doesn't.
        }                                                       //   given the autoshadowing, we might just want to allow everything.

---- TODO: ----
[2m[0m_0[2m.fu 2:33+1[0m:

[2m      | [0m
[2m    2 | [0m        fn template_add(a, b) a [31;1m+[0m b;
[2m      | [0m

	Bad call to [94;1m+[0m with args ([35;3mstruct[0m [94;1mHasInt[0m, [35;3mstruct[0m [94;1mHasInt[0m): 

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    No body pattern matched.

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mtemplate_add[0m([94;1mHasInt[0m, [94;1mHasInt[0m) at [2m[0m_0[2m.fu 2:12+12[0m
                [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========


        // TODO remove this, currently gets repeatedly
        //  rebuilt & rejected because of -Werror
        pragma emit(`#pragma GCC diagnostic ignored "-Wpragmas"`);
        pragma emit(`#pragma GCC diagnostic ignored "-Winfinite-recursion"`);

        fn infRec(x: i32) {
            if (x > 1)
                return infRec(x - 1);
            else                        <fail infinite recur X:X>
                return infRec(x + 1);   <pass/>
                return x;               </fail>
        }

        fn main() infRec(1);

---- TODO: ----
<fail> mismatch:

    Expected error keyword:
        [31;1mX:X[0m from pattern <fail[31;1m infinite recur X:X[0m>

    ... not present in error message:

COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

#include <fu/never.h>

[[noreturn]] static fu::never infRec_MbR9(int);
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Winfinite-recursion"

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never infRec_MbR9(const int x)
{
    if (x > 1)
        infRec_MbR9((x - 1));
    else
        infRec_MbR9((x + 1));

}

[[noreturn]] fu::never fu_MAIN()
{
    infRec_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

   EXIT code: 5
========

        fn privateTypeWithinRecursion(lt: int[]) {
            fn propagateType(shadow lt: int[]) {
                struct UsedAgain { i: int };

                fn trackUsedAgain_descend(shadow lt: int[]): UsedAgain {
                    fn trackUsedAgain_descend(t: int): UsedAgain {
                        return trackUsedAgain_descend(Lifetime_climbType(t));
                    }

                    for (mut i = 0; i < lt.len; i++) {
                        let u = trackUsedAgain_descend(lt[i]);
                        if (u) return u;
                    }

                    return UsedAgain(lt.len);
                }

                let v = trackUsedAgain_descend(lt);
                return v && propagateType([ v.i ]);
            }

            fn Lifetime_climbType(i: int): i32[] {
                return i > 1 ? [ i / 2 ] : [];
            }

            return propagateType(lt);
        }

        fn main() {
            return privateTypeWithinRecursion([ 1, 2, 3 ]);
        }

---- TODO: ----
[2m[0m_0[2m.fu 8:25+6[0m:

[2m      |                 fn trackUsedAgain_descend(shadow lt: int[]): UsedAgain {[0m
[2m      |                     fn trackUsedAgain_descend(t: int): UsedAgain {[0m
[2m    8 | [0m                        [31;1mreturn[0m trackUsedAgain_descend(Lifetime_climbType(t));
[2m      |                     }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mtrackUsedAgain_descend[0m: return type does not match annotation: expects [35;3mstruct[0m [94;1mUsedAgain[0m, got [35;3mstruct[0m [94;1mUsedAgain[0m

        Solving [35;3mfn[0m [94;1mtrackUsedAgain_descend[0m([35;3mi32[0m) at [2m7:24+22[0m
                [35;3mfn[0m [94;1mtrackUsedAgain_descend[0m([35;3mi32[0m[35;3m[..][0m) at [2m6:20+22[0m
                [35;3mfn[0m [94;1mpropagateType[0m([35;3mi32[0m[35;3m[..][0m) at [2m3:16+13[0m
                [35;3mfn[0m [94;1mprivateTypeWithinRecursion[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:12+26[0m

========

        struct Node  { items: Node[] }
        struct Document { root: Node }

        fn render(doc: Document) {
            mut count = 0;

            fn visit(n: Node) {
                count++;
                n.items.each: |item| visit(item);
            }

            doc.root.items.each: |item| visit(item);
            return count;
        }

        fn main() Document(root: Node(items: [ Node(items: [ Node(), Node() ]), Node() ])).render - 5;

---- TODO: ----
[2m[0m_0[2m.fu 10:25+4[0m:

[2m      |             fn visit(n: Node) {[0m
[2m      |                 count++;[0m
[2m   10 | [0m                n.items.[31;1meach[0m: |item| visit(item);
[2m      |             }[0m
[2m      | [0m

	COMPILER BUG:

	CODEGEN FAIL:

	ensureFnDef: Function without SS_FN_RECUR appears to be recursive.

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopyAfterRecursion(ref root: SolvedNode) {
            fn mutateThenCopy(ref callsite: SolvedNode) {
                callsite.items ~= callsite;

                mut result = root;
                result.items ~= root;
                return result;
            }
<flip>
            fn indirectRecursion(ref node: SolvedNode) {
                ref items = node.items;

                // The root copies made at the end of each bck_node call
                //  would indeed be invalid if they survived,
                //   but they get return-discarded here.
                for (mut i = items.len; i --> 1; )
                    bck_node(items[i]);                         ;; !N_COWRestrict
                                                                ;; PointlessMustSeq
                return items && bck_node(items[0]);
            }
<flip/>
            fn bck_node(ref node: SolvedNode)
                node.items
                    ? indirectRecursion(node)
                    : mutateThenCopy(node);
</flip>
            return bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopyAfterRecursion();
            return 1000 * a.count + b.count - 2004;
        }

---- TODO: ----
[2m[0m_0[2m.fu 17:21+1[0m:

[2m      |             fn bck_node(ref node: SolvedNode)[0m
[2m      |                 node.items[0m
[2m   17 | [0m                    [31;1m?[0m indirectRecursion(node)
[2m      |                     : mutateThenCopy(node);[0m
[2m      | [0m

	if/else: No common supertype: [35;3malways-false[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mSolvedNode[0m[35;3m[][0m <-> [35;3mstruct[0m [94;1mSolvedNode[0m

        Solving [35;3mfn[0m [94;1mbck_node[0m([94;1mSolvedNode[0m) at [2m15:16+8[0m
                [35;3mfn[0m [94;1mmutateThenCopyAfterRecursion[0m([94;1mSolvedNode[0m) at [2m6:12+28[0m

========

        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        return x["hello"] - x["world"] + 1;

---- TODO: ----
[2m[0m_0[2m.fu 5:16+3[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut x: [31;1mMap[0m(string, i32);
[2m      | [0m
[2m      |         x["hello"] = 1;[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        let b = "hello world";
        mut offset = 0;

        fn pop(): string {
            mut a = "";

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a ~= c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;

---- TODO: ----
[2m[0m_0[2m.fu 5:16+3[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut x: [31;1mMap[0m(string, i32);
[2m      | [0m
[2m      |         x["hello"] = 1;[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn solve(root: Node)
        {
            mut _t_bool: Type;

            fn createBool(value: string, type = t_bool)
                return SolvedNode(:value, :type);

            fn solveNode(node: Node)
                return node.kind == "bool"
                    && createBool(:node.value);

            fn t_bool()
                return _t_bool ||= Type("t_bool");

            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct SolvedNode_kmlY;
struct Type_KHQj;
struct Node_IOXy;

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_kmlYnlv7BLc
                                #define DEF_SolvedNode_kmlYnlv7BLc
struct SolvedNode_kmlY
{
                                // shape_hash:    ce8d659d51ba6b49
                                // non_triv_mask: 0000900000010000
    fu::str value;
    Type_KHQj type;
    explicit operator bool() const noexcept
    {
        return false
            || value
            || type
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_IOXyKloqzle
                                #define DEF_Node_IOXyKloqzle
struct Node_IOXy
{
                                // shape_hash:    465ac37e3718e17a
                                // non_triv_mask: 0000800001000000
    fu::str kind;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static const Type_KHQj& t_bool_kGbb(/*1:1*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Type_KHQj { fu::str("t_bool"_fu) });
}

static SolvedNode_kmlY createBool_MbR9(/*3:3*/ fu::vec_range<char> value, /*3:3*/ const Type_KHQj& type)
{
    return SolvedNode_kmlY { fu::str(value), Type_KHQj(type) };
}

static SolvedNode_kmlY solveNode_MbR9(/*3:3*/ const Node_IOXy& node, /*2:2*/ Type_KHQj& _t_bool)
{
    if (node.kind == "bool"_view)
        return createBool_MbR9(node.value, t_bool_kGbb(_t_bool));
    else
    {
        return SolvedNode_kmlY{};
    };
}

static SolvedNode_kmlY solve_MbR9(/*1:1*/ const Node_IOXy& root)
{
    Type_KHQj _t_bool {};
    return solveNode_MbR9(root, _t_bool);
}

int fu_MAIN()
{
    SolvedNode_kmlY s = solve_MbR9(Node_IOXy { fu::str("bool"_fu), fu::str("Hello!"_fu) });
    if ((s.value == "Hello!"_view) && (s.type.canon == "t_bool"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit

========

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn solve(root: Node)
        {
            mut _t_bool: Type;

            fn createBool(value: string, type = t_bool)
                return SolvedNode(:value, :type);

            fn solveNode(node: Node)
                return node.kind == "bool"
                    && createBool(:node.value);
    <alt>
            fn solveNode(canon: string)
                return Type(:canon);

            fn t_bool()
                return _t_bool ||= solveNode("t_bool");
    <alt/>
            fn t_bool()
                return _t_bool ||= Type("t_bool");
    </alt>
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 15:24+10[0m:

[2m      |             fn solveNode(node: Node)[0m
[2m      |                 return node.kind == "bool"[0m
[2m   15 | [0m                    && [31;1mcreateBool[0m(:node.value);
[2m      | [0m
[2m      |             fn solveNode(canon: string)[0m

	Bad call to [94;1mcreateBool[0m with args ([35;3mstring[0m): 

	[35;3mfn[0m [94;1mprep createBool[0m at [2m10:16+10[0m:
[2m   10 | [0m            fn [31;1mcreateBool[0m(value: string, type = t_bool)

	    Declaration cycle, signature not yet available.

	    To fix this, you might need to shuffle functions around
		until every dependency (type annot or arg default expr)
		of [35;3mfn[0m [94;1mprep createBool[0m is declared above it.

	    This borders on a compiler bug, sorry about it,
		we gotta come up with a better solve order algorithm.

        Solving [35;3mfn[0m [94;1msolveNode[0m([94;1mNode[0m) at [2m13:16+9[0m
                [2m...[0m
                [35;3mfn[0m [94;1msolve[0m([94;1mNode[0m) at [2m6:12+5[0m

========

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn createBool(value: string, type = t_bool)
            return SolvedNode(:value, :type);

        fn solveNode(node: Node)
            return node.kind == "bool"
                && createBool(:node.value);

        fn t_bool(implicit ref _t_bool: Type)
            return _t_bool ||= Type("t_bool");

        fn solve(root: Node)
        {
            implicit mut _t_bool: Type;
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct SolvedNode_kmlY;
struct Type_KHQj;
struct Node_IOXy;

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_kmlYnlv7BLc
                                #define DEF_SolvedNode_kmlYnlv7BLc
struct SolvedNode_kmlY
{
                                // shape_hash:    ce8d659d51ba6b49
                                // non_triv_mask: 0000900000010000
    fu::str value;
    Type_KHQj type;
    explicit operator bool() const noexcept
    {
        return false
            || value
            || type
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_IOXyKloqzle
                                #define DEF_Node_IOXyKloqzle
struct Node_IOXy
{
                                // shape_hash:    465ac37e3718e17a
                                // non_triv_mask: 0000800001000000
    fu::str kind;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static const Type_KHQj& t_bool_kGbb(/*1:1*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Type_KHQj { fu::str("t_bool"_fu) });
}

static SolvedNode_kmlY createBool_MbR9(/*3:3*/ fu::vec_range<char> value, /*3:3*/ const Type_KHQj& type)
{
    return SolvedNode_kmlY { fu::str(value), Type_KHQj(type) };
}

static SolvedNode_kmlY solveNode_MbR9(/*3:3*/ const Node_IOXy& node, /*2:2*/ Type_KHQj& _t_bool)
{
    if (node.kind == "bool"_view)
        return createBool_MbR9(node.value, t_bool_kGbb(_t_bool));
    else
    {
        return SolvedNode_kmlY{};
    };
}

static SolvedNode_kmlY solve_MbR9(/*1:1*/ const Node_IOXy& root)
{
    Type_KHQj _t_bool {};
    return solveNode_MbR9(root, _t_bool);
}

int fu_MAIN()
{
    SolvedNode_kmlY s = solve_MbR9(Node_IOXy { fu::str("bool"_fu), fu::str("Hello!"_fu) });
    if ((s.value == "Hello!"_view) && (s.type.canon == "t_bool"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit

========

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn createBool(value: string, type = t_bool)
            return SolvedNode(:value, :type);

        fn solveNode(node: Node)
            return node.kind == "bool"
                && createBool(:node.value);
<alt>
        fn solveNode(canon: string)
            return Type(:canon);

        fn t_bool(implicit ref _t_bool: Type)
            return _t_bool ||= solveNode("t_bool");
<alt/>
        fn t_bool(implicit ref _t_bool: Type)
            return _t_bool ||= Type("t_bool");
</alt>
        fn solve(root: Node)
        {
            implicit mut _t_bool: Type;
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 11:20+10[0m:

[2m      |         fn solveNode(node: Node)[0m
[2m      |             return node.kind == "bool"[0m
[2m   11 | [0m                && [31;1mcreateBool[0m(:node.value);
[2m      | [0m
[2m      |         fn solveNode(canon: string)[0m

	Bad call to [94;1mcreateBool[0m with args ([35;3mstring[0m): 

	[35;3mfn[0m [94;1mprep createBool[0m at [2m6:12+10[0m:
[2m    6 | [0m        fn [31;1mcreateBool[0m(value: string, type = t_bool)

	    Declaration cycle, signature not yet available.

	    To fix this, you might need to shuffle functions around
		until every dependency (type annot or arg default expr)
		of [35;3mfn[0m [94;1mprep createBool[0m is declared above it.

	    This borders on a compiler bug, sorry about it,
		we gotta come up with a better solve order algorithm.

        Solving [35;3mfn[0m [94;1msolveNode[0m([94;1mNode[0m) at [2m9:12+9[0m
                [2m...[0m

========

        struct Layout { atlas_width: u16; atlas_height: u16 }
        enum Size: u8 { x2 = 1; x4 = 2; x8 = 3; x16 = 4; x32 = 5; x64 = 6 }

        fn Layout(
            slot_size:      Size,
            atlas_width   = Size(slot_size.u8 + 2),
            atlas_height  = atlas_width)
        {
            shadow mut slot_size    =  1 << slot_size.min("x32").u16;
            shadow mut atlas_width  = (1 << atlas_width.u16)    .max(slot_size * 2);
            shadow mut atlas_height = (1 << atlas_height.u16)   .max(slot_size * 2);

            return Layout(:atlas_width, :atlas_height);
        }

        let ATLAS_LAYOUT = Layout(slot_size: "x16");

        fn main() ATLAS_LAYOUT.atlas_width == 32 ? 0 : 1;

---- TODO: ----
[2m[0m_0[2m.fu 17:28+6[0m:

[2m      |         }[0m
[2m      | [0m
[2m   17 | [0m        let ATLAS_LAYOUT = [31;1mLayout[0m(slot_size: "x16");
[2m      | [0m
[2m      |         fn main() ATLAS_LAYOUT.atlas_width == 32 ? 0 : 1;[0m

	COMPILER BUG:

	nested(): bad locid

========

        mut m: Map(string, string);
        mut g = 0;

        m["hello"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g;

---- TODO: ----
[2m[0m_0[2m.fu 5:16+3[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut m: [31;1mMap[0m(string, string);
[2m      |         mut g = 0;[0m
[2m      | [0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        mut m: Map(string, string);
        mut g = 0;

        m["_not_hello_"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g - 1;

---- TODO: ----
[2m[0m_0[2m.fu 5:16+3[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut m: [31;1mMap[0m(string, string);
[2m      |         mut g = 0;[0m
[2m      | [0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        fn for(ref n: int, what) for (mut i = 0; i < n; i++) what(i);

        fn main(): i32 {
            mut total = 100;
            total.for: |i| {            
                if (i & 1) return;      
                total--
            };

            return total - 66
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:28+6[0m:

[2m      |             mut total = 100;[0m
[2m      |             total.for: |i| {            [0m
[2m    7 | [0m                if (i & 1) [31;1mreturn[0m;      
[2m      |                 total--[0m
[2m      |             };[0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn for(const ref n: int, what) for (mut i = 0; i < n; i++) what(i);

        fn main(): i32 {
            mut total = 100;
            total.for: |i| {            
                if (i & 1) return;      
                total--
            };

            return total - 66
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:28+6[0m:

[2m      |             mut total = 100;[0m
[2m      |             total.for: |i| {            [0m
[2m    7 | [0m                if (i & 1) [31;1mreturn[0m;      
[2m      |                 total--[0m
[2m      |             };[0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn for(<alt>const </alt>ref n: int, what) for (mut i = 0; i < n; i++) what(i);

        fn main(): i32 {
            mut total = 100;
            total.for: |i| {            <fail main: return type does not match annot i32, got void 7:28+6>
                if (i & 1) return;      <pass/>
                if (i & 1) continue;    </fail>
                total--
            };

            return total - 66
        }

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>


#ifndef fu_NO_fdefs

                                #ifndef DEF___9rLIqHbAe8d
                                #define DEF___9rLIqHbAe8d
inline static void _9rLI(const int i, /*3:3*/ int& total)
{
    if (!(i & 1))
        total--;

}
                                #endif

                                #ifndef DEF_fOr_77OLCkp46C4
                                #define DEF_fOr_77OLCkp46C4
inline static void fOr_77OL(/*7:7*/ const int n, /*7:6*/ int& total)
{
    for (int i = 0; i < n; i++)
        _9rLI(i, total);

}
                                #endif

int fu_MAIN()
{
    int total = 100;
    fOr_77OL(total, total);
    return total - 66;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

   EXIT code: 240
========

        struct Helper { vars: i32[]; };

        fn test(ref _helpers: Helper[], helpers_idx: i32) {
            ref old = _helpers[helpers_idx - 1].vars;
            ref new = _helpers[helpers_idx    ].vars;
            new    ~= old[helpers_idx];
        }

        fn main() {
            mut helpers = [ Helpers([ 1, 2 ]), Helpers([ 4, 8 ]) ];
            test(helpers, 1);
            return helpers[1][2] - 2;
        }

---- TODO: ----
[2m[0m_0[2m.fu 7:23+3[0m:

[2m      |             ref old = _helpers[helpers_idx - 1].vars;[0m
[2m      |             ref new = _helpers[helpers_idx    ].vars;[0m
[2m    7 | [0m            new    ~= [31;1mold[0m[helpers_idx];
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1mold[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1m_helpers[0m at [2m6:31+1[0m:

[2m      |         fn test(ref _helpers: Helper[], helpers_idx: i32) {[0m
[2m      |             ref old = _helpers[helpers_idx - 1].vars;[0m
[2m    6 | [0m            ref new = _helpers[31;1m[[0mhelpers_idx    ].vars;
[2m      |             new    ~= old[helpers_idx];[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m.mutref[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([94;1mHelper[0m[35;3m[..][0m, [35;3mi32[0m) at [2m4:12+4[0m

========


        struct X { items: i32[]; };
        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static
        fn main() popfirst([ X() ]).items.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct X_9ItJ;

                                #ifndef DEF_X_9ItJNGboq8f
                                #define DEF_X_9ItJNGboq8f
struct X_9ItJ
{
                                // shape_hash:    d4e49bc42b21c40b
                                // non_triv_mask: 000a000000000000
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static X_9ItJ popfirst_MbR9(/*1:1*/ fu::view<X_9ItJ> arr)
{
    return X_9ItJ(arr[0]);
}

int fu_MAIN()
{
    return popfirst_MbR9(fu::view<X_9ItJ> {{ X_9ItJ{} }}).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        <alt>
        nocopy
        </alt>
        struct X { items: i32[]; };
        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static
        fn main() popfirst([ X() ]).items.len;

---- TODO: ----
[2m[0m_0[2m.fu 6:38+1[0m:

[2m      | [0m
[2m      |         struct X { items: i32[]; };[0m
[2m    6 | [0m        fn popfirst(mut arr: X[]) arr[31;1m[[0m0]; // mcom_BlockReturn after relax: arr[] adds 'static
[2m      |         fn main() popfirst([ X() ]).items.len;[0m
[2m      | [0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [94;1marr[0m*[32;3m|[0m[32;3mstatic[0m [35;3mstruct[0m [94;1mX[0m

	Cannot move: references a static.

RelaxCopyResize [35;3mfn[0m [94;1mpopfirst[0m([94;1mX[0m[35;3m[..][0m) at [2m6:12+8[0m

========

        fn Swap(ref arr: i32[], x: i32, y: i32)
            swap(arr[x], arr[y]);

        fn main() {
            mut a = [ 1, 2 ];
            a.Swap(0, 1);
            return a[0] - 2 == 0 && a[1] - 1 == 0 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 3:13+4[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            [31;1mswap[0m(arr[x], arr[y]);
[2m      | [0m
[2m      |         fn main() {[0m

	At call to [35;3m__native[0m [94;1m#MayAlias <utility> std::swap[0m, binding for [35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1ma[0m (arg #0) at [2m3:21+1[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            swap(arr[31;1m[[0mx], arr[y]);
[2m      | [0m
[2m      |         fn main() {[0m

	... invalidated by subsequent write to [35;3mmut ref arg[0m [94;1marr[0m upon evaluation of [35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1mb[0m (arg #1) at [2m3:29+1[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            swap(arr[x], arr[31;1m[[0my]);
[2m      | [0m
[2m      |         fn main() {[0m

	At call to [35;3m__native[0m [94;1m.mutref[0m

    BorrowCheck [35;3mfn[0m [94;1mSwap[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m, [35;3mi32[0m) at [2m2:12+4[0m

========

        fn hello(ref arr: i32[], ref item: i32)
            arr ~= ++item;

        fn ret_last(ref arr: i32[])
            arr[arr.len - 1];

        fn concat_self_ret_last(ref arr: i32[])
            ret_last(arr ~= arr)

        fn main() {
            mut arr = [ 1, 2, 3 ];
            hello(arr, concat_self_ret_last(arr));
            return ret_last(arr) - 4;
        }

---- TODO: ----
[2m[0m_0[2m.fu 13:13+5[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            [31;1mhello[0m(arr, concat_self_ret_last(arr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mhello[0m, binding for [35;3mref arg[0m [94;1mhello[0m:[94;1marr[0m (arg #0) at [2m13:19+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            hello([31;1marr[0m, concat_self_ret_last(arr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	... invalidated by subsequent write to [35;3mmut[0m [94;1marr[0m upon evaluation of [35;3mref arg[0m [94;1mhello[0m:[94;1mitem[0m (arg #1) at [2m13:24+20[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            hello(arr, [31;1mconcat_self_ret_last[0m(arr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mconcat_self_ret_last[0m
            via [35;3mfn[0m [94;1mret_last[0m at [2m9:13+8[0m:

[2m      | [0m
[2m      |         fn concat_self_ret_last(ref arr: i32[])[0m
[2m    9 | [0m            [31;1mret_last[0m(arr ~= arr)
[2m      | [0m
[2m      |         fn main() {[0m

            via [35;3m__native[0m [94;1m.mutref[0m at [2m6:16+1[0m:

[2m      | [0m
[2m      |         fn ret_last(ref arr: i32[])[0m
[2m    6 | [0m            arr[31;1m[[0marr.len - 1];
[2m      | [0m
[2m      |         fn concat_self_ret_last(ref arr: i32[])[0m


    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m11:12+4[0m

========

        noinline fn test(ref data: int[]) {
            for (mut i = 0; i < 2; i++)

                if !(i & 1) for (mut j = 0; j < 8; j++)
                                data ~= data;
                else
                    return DONT_DANGLE_ME;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            implicit shadow 
                        ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data)) - 3;
        }

        fn DONT_DANGLE_ME(implicit shadow DONT_DANGLE_ME: int[]) {
            return DONT_DANGLE_ME;
        }

---- <fail> ----
[2m[0m_0[2m.fu 24:24+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   24 | [0m            return sum([31;1mtest[0m(:data)) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             implicit shadow [0m
[2m      |                         ref DONT_DANGLE_ME = data[2 .. 3];[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m is [31;1mimplicit[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        noinline fn test(ref data: int[]) {
            for (mut i = 0; i < 2; i++)

                if (i & 1)
                    return DONT_DANGLE_ME;
                else for (mut j = 0; j < 8; j++)
                    data ~= data;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            implicit shadow 
                        ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data)) - 3;
        }

        fn DONT_DANGLE_ME(implicit shadow DONT_DANGLE_ME: int[]) {
            return DONT_DANGLE_ME;
        }

---- <fail> ----
[2m[0m_0[2m.fu 24:24+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   24 | [0m            return sum([31;1mtest[0m(:data)) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             implicit shadow [0m
[2m      |                         ref DONT_DANGLE_ME = data[2 .. 3];[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m is [31;1mimplicit[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        noinline fn test(ref data: int[]) {
            for (mut i = 0; i < 2; i++)
    <alt>
                if (i & 1)
                    return DONT_DANGLE_ME;
                else for (mut j = 0; j < 8; j++)
                    data ~= data;
    <alt/>
                if !(i & 1) for (mut j = 0; j < 8; j++)
                                data ~= data;
                else
                    return DONT_DANGLE_ME;
    </alt>
            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            implicit shadow <fail at call to test 24:24+4 both alias mut data 14:17+4>
                        ref <pass/>
                        mut </fail>DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data)) - 3;
        }

        fn DONT_DANGLE_ME(implicit shadow DONT_DANGLE_ME: int[]) {
            return DONT_DANGLE_ME;
        }

---- TODO: ----
[2m[0m_0[2m.fu 24:24+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   24 | [0m            return sum([31;1mtest[0m(:data)) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             implicit shadow [0m
[2m      |                         mut DONT_DANGLE_ME = data[2 .. 3];[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m is [31;1mimplicit[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        noinline fn sliceRelaxDanglesView(ref array: i32[], ref view: i32[]) {
            for (mut j = 0; j < 4; j++)
                for (mut i = view.len; i --> 0; )
                    array ~= view[i];

            return view;
        }

        fn main() {
            mut array = [ 1, 1, 1, 1, 1, 1, 1, 1 ];
            sliceRelaxDanglesView(array, array);
            mut sum = 0;
            for (mut i = 0; i < array.len; i++) sum += array[i];
            return sum == 128 ? 0 : 1;
        }

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 1856[0m
[36m  STAT: ARC  Total Count	m_cnt: 4[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::view<int> sliceRelaxDanglesView_GL0m(/*3:1*/ fu::vec_range_mut<int> array, /*3:3*/ fu::vec_range<int> view)
{
    for (int j = 0; j < 4; j++)
        for (int i = view.size(); i-- > 0; )
            array += view[i];
;
    return view;
}

int fu_MAIN()
{
    fu::vec<int> array = fu::vec<int> {{ 1, 1, 1, 1, 1, 1, 1, 1 }};
    sliceRelaxDanglesView_GL0m(array, array);
    int sum = 0;
    for (int i = 0; i < array.size(); i++)
        sum += array[i];

    if (sum == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

   EXIT code: 1
========

        struct SolvedNode                           <alt>
            { items: SolvedNode[]; target: int }    <alt/>
            { target: int; items: SolvedNode[] }    </alt>

        fn assertPathsValidChainTooDeep(ref node: SolvedNode) {
            fn isFieldChain(n: SolvedNode)
                n.items.len == 1 && n.items[0].isFieldChain || n.target;

            return isFieldChain(node);
        }

        fn main() {
            mut v  = SolvedNode([    ], target: 1);
            mut f1 = SolvedNode([  v ], target: 2);
            mut f2 = SolvedNode([ f1 ], target: 3);
            return assertPathsValidChainTooDeep(f2) -= 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 7:48+12[0m:

[2m      |         fn assertPathsValidChainTooDeep(ref node: SolvedNode) {[0m
[2m      |             fn isFieldChain(n: SolvedNode)[0m
[2m    7 | [0m                n.items.len == 1 && n.items[0].[31;1misFieldChain[0m || n.target;
[2m      | [0m
[2m      |             return isFieldChain(node);[0m

	COMPILER BUG:

	assertPathsValid: pathDepth > 64, we're likely stuck in an infinite loop.

========

        nocopy struct Node { items: Node[]; type: Node[] };

        fn append_one(ref items: Node[]) {
            items.push(Node());
            return items;
        }

        fn count(ref type: Node[], ref items: Node[]) {
            mut count = 0;
            fn visit(n: Node) {
                count++;
                n.type.each(.visit);
                n.items.each(.visit);
            }

            type.each(.visit);
            items.each(.visit);
            return count;
        }

        fn process(ref node: Node) {
            return count(node.type, append_one(node.items));
        }

        fn main() {
            mut node = Node( type: [ Node() ], items: [ Node(), Node() ] );
            let count = process(node);
            return count - 5;
        }

---- TODO: ----
[2m[0m_0[2m.fu 13:24+4[0m:

[2m      |             fn visit(n: Node) {[0m
[2m      |                 count++;[0m
[2m   13 | [0m                n.type.[31;1meach[0m(.visit);
[2m      |                 n.items.each(.visit);[0m
[2m      |             }[0m

	COMPILER BUG:

	CODEGEN FAIL:

	ensureFnDef: Function without SS_FN_RECUR appears to be recursive.

========

        nocopy struct AB { a: int; b: int };

        fn main() {
            mut v0 = AB(1, 2);
            mut v1 = v0;
            ref a = v0.a;
            ref b = v1.b;
            a += 10;
            b += a;
            return b - 13;
        }

---- TODO: ----
[2m[0m_0[2m.fu 6:22+2[0m:

[2m      |         fn main() {[0m
[2m      |             mut v0 = AB(1, 2);[0m
[2m    6 | [0m            mut v1 = [31;1mv0[0m;
[2m      |             ref a = v0.a;[0m
[2m      |             ref b = v1.b;[0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [94;1mv0[0m [35;3mstruct[0m [94;1mAB[0m

	Cannot move: [35;3mmut[0m [94;1mv0[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct SolverState  {
            overloads:          string[];
            eph?:               int;
        }

        fn solve(ref ss: SolverState) {
            fn GET(t) ss.overloads[t];
            ref t = ss.eph;
            t.GET = t.GET ~ ", world!";
            return t.GET;
        }

        fn main() {
            mut ss = SolverState(overloads: [ "hello" ] );
            ss.solve();
            return ss.overloads.only.len - 13;
        }

---- TODO: ----
[2m[0m_0[2m.fu 11:20+1[0m:

[2m      |             ref t = ss.eph;[0m
[2m      |             t.GET = t.GET ~ ", world!";[0m
[2m   11 | [0m            return [31;1mt[0m.GET;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1mt[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mss[0m at [2m10:15+3[0m:

[2m      |             fn GET(t) ss.overloads[t];[0m
[2m      |             ref t = ss.eph;[0m
[2m   10 | [0m            t.[31;1mGET[0m = t.GET ~ ", world!";
[2m      |             return t.GET;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mGET[0m
            via [35;3m__native[0m [94;1m.mutref[0m at [2m8:35+1[0m:

[2m      | [0m
[2m      |         fn solve(ref ss: SolverState) {[0m
[2m    8 | [0m            fn GET(t) ss.overloads[31;1m[[0mt];
[2m      |             ref t = ss.eph;[0m
[2m      |             t.GET = t.GET ~ ", world!";[0m


    BorrowCheck [35;3mfn[0m [94;1msolve[0m([94;1mSolverState[0m) at [2m7:12+5[0m

========

        struct TEA { v0: u32; v1: u32 }

        noinline fn r8(using ref _: TEA)
            for (mut i = 0; i < 8; i++)
                v1 += ((v0<<4) + 0xAD90777D)
                    ^ ((v0>>5) + 0x7E95761E);

        struct RenderCache(type T) { tea: TEA; noise: T[] };

        noinline fn renderFrame(ref rc: RenderCache(_))
            simulated_annealing(:rc.noise, :rc.tea);

        noinline fn simulated_annealing(ref noise: _[], ref tea: TEA)
            for (mut iter = noise.len; iter --> 0; ) {
                tea.r8();
                noise.swap(
                    (tea.v0 % noise.len.unsigned).signed,
                    (tea.v1 % noise.len.unsigned).signed);
            }

        fn main() {
            mut rc = RenderCache(int)(TEA(), [ 1, 2, 3, 4 ]);
            rc.renderFrame();
            mut sum = 0;
            rc.noise.each: |v| sum += v;
            return sum - 10;
        }

---- TODO: ----
[2m[0m_0[2m.fu 12:45+2[0m:

[2m      | [0m
[2m      |         noinline fn renderFrame(ref rc: RenderCache(_))[0m
[2m   12 | [0m            simulated_annealing(:rc.noise, :[31;1mrc[0m.tea);
[2m      | [0m
[2m      |         noinline fn simulated_annealing(ref noise: _[], ref tea: TEA)[0m

	COMPILER BUG:

	assertPathsValid: expect_flatCount(1) != flatCount(2)

========

        fn track_last_loop_confusion(mut a: string, mut b: string)
        {
            for (mut i = 0; i < 6; i++) {
                a ~= a; // foil smallstring opti
                b ~= b; //  both are 64 chars long
            }

            ref x = a.len == 64 ? b : a;
            ref y = b.len == 64 ? x : a; // y points to b two refs deep

            mut result = b; // <-- BROKEN MOVE FROM b HERE

            // once
            for (mut i = result.len / 64; i --> 0; ) {
                y ~= y;         // now 128, ensures y not a view
                result ~= y;    // for a total of 192
            }

            return result;
        }

        fn main() {
            mut res = track_last_loop_confusion("a", "b");
            return res.len == 192 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 17:27+1[0m:

[2m      |             for (mut i = result.len / 64; i --> 0; ) {[0m
[2m      |                 y ~= y;         // now 128, ensures y not a view[0m
[2m   17 | [0m                result ~= [31;1my[0m;    // for a total of 192
[2m      |             }[0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +=[0m:[94;1mb[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mx[0m at [2m9:17+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m    9 | [0m            ref [31;1mx[0m = a.len == 64 ? b : a;
[2m      |             ref y = b.len == 64 ? x : a; // y points to b two refs deep[0m
[2m      | [0m

	Both refer to: [35;3mmut arg[0m [94;1ma[0m at [2m2:42+1[0m:

[2m      | [0m
[2m    2 | [0m        fn track_last_loop_confusion(mut [31;1ma[0m: string, mut b: string)
[2m      |         {[0m
[2m      |             for (mut i = 0; i < 6; i++) {[0m


RelaxCopyResize [35;3mfn[0m [94;1mtrack_last_loop_confusion[0m([35;3mstring[0m, [35;3mstring[0m) at [2m2:12+25[0m

========

        fn setupOperators() {
            mut out: struct { P: Map(string, i32) };
            fn binop(op: string) out.P[op] = 7;
            binop(",");
            return out;
        }

        let BINOP = setupOperators();
        let P_COMMA = BINOP.P[","] || throw("Assertion failed.");
        fn main() P_COMMA - 7;

---- TODO: ----
[2m[0m_0[2m.fu 3:34+3[0m:

[2m      | [0m
[2m      |         fn setupOperators() {[0m
[2m    3 | [0m            mut out: struct { P: [31;1mMap[0m(string, i32) };
[2m      |             fn binop(op: string) out.P[op] = 7;[0m
[2m      |             binop(",");[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mtype[0m [94;1msetupOperators[0m
                [35;3mfn[0m [94;1msetupOperators[0m at [2m2:12+14[0m

========

        struct ValueType { modid: i32; };
        struct Type { using vtype: ValueType; };
        struct Target { modid: i32; index: i32; };
        struct Overload { name: string; id: string; };

        fn GET(target: Target): Overload =
            Overload(
                name: "N" ~ target.index,
                  id: "I" ~ target.index);

        fn main() {
            mut specs: Map(string, Target);

            fn setSpec(mangle: string) {
                ref t = specs[mangle] ||= Target;

                // This template should start expanding on GET(target).name,
                //  which should conflict with overload name.
                fn name(shadow target)
                    GET(target) <fail ambig>
                        .name;  <pass/>
                        .id;    </fail>

                return t.name;
            }

            return setSpec("hey").len - 2;
        }

---- TODO: ----
<fail> mismatch:

    Expected error keyword:
        [31;1mambig[0m from pattern <fail[31;1m ambig[0m>

    ... not present in error message:

[2m[0m_0[2m.fu 13:24+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   13 | [0m            mut specs: [31;1mMap[0m(string, Target);
[2m      | [0m
[2m      |             fn setSpec(mangle: string) {[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mstruct[0m [94;1mTarget[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========

        fn setupOperators(P_PREFIX_UNARY) // <- template
        {
            struct BINOP {
                PRECEDENCE:     Map(string, i32);
                RIGHT_TO_LEFT:  Map(i32,   bool);
            };

            mut out: BINOP; // <- no BINOP in scope
            mut precedence = P_PREFIX_UNARY;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT[precedence] = rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE[ops[i]] = precedence;
            }

            binop([ "|>" ]);

            //
            return out;
        }

        let BINOP = setupOperators(-1);

        fn main() {
            let precedence = BINOP.PRECEDENCE["|>"];
            return precedence;
        }

---- TODO: ----
[2m[0m_0[2m.fu 5:33+3[0m:

[2m      |         {[0m
[2m      |             struct BINOP {[0m
[2m    5 | [0m                PRECEDENCE:     [31;1mMap[0m(string, i32);
[2m      |                 RIGHT_TO_LEFT:  Map(i32,   bool);[0m
[2m      |             };[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mtype[0m [94;1mBINOP[0m
                [35;3mfn[0m [94;1msetupOperators[0m([35;3mi32[0m) at [2m2:12+14[0m

========

        struct Context
        {
            fuzzy: Map(string, string);
            files: string[];
        }

        fn resolveFile(
            implicit ref ctx: Context,
            from: string, name: string): string
        {
            let path    = from ~ name;
            let cached  = ctx.fuzzy[path];
            if (cached)
                return cached == "" ? "" : cached;

            fn tryResolve(): string
            {
                let exists = file::size(path) >= 0;
                if (exists)
                    return path;

                return "";
            };

            let resolve = tryResolve();
            ctx.fuzzy[path] = resolve || "";
            return resolve;
        }

        pub fn resolveFile(
            implicit ref ctx: Context,
            path: string): string
        {
            let fuzzy = path.find('');
            if (fuzzy > 0)
            {
                let from = path.slice(0, fuzzy);
                let name = path.slice(fuzzy + 1);
                if (from && name && !name.has(''))
                {
                    let res = resolveFile(:from, :name);
                    if (res)
                        return res;

                    // Tests have the files prepopulated,
                    //  we only pay the cost of lookup when about to fail compile.
                    let prepopulated = from ~ name;
                    if (ctx.files.has(prepopulated))
                        return prepopulated;
                }
            }

            return path;
        }

        fn main() {
            implicit mut ctx: Context;
            return resolveFile("a").len - 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 4:20+3[0m:

[2m      |         struct Context[0m
[2m      |         {[0m
[2m    4 | [0m            fuzzy: [31;1mMap[0m(string, string);
[2m      |             files: string[];[0m
[2m      |         }[0m

	Bad call to [94;1mMap[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mtype[0m [35;3mstring[0m): [94;1mMap[0m is not defined here.

        Solving [35;3mtype[0m [94;1mContext[0m

========

        fn inline_args_and_closures(inline nums: i32[]) {       ;; GNUStmtExpr
            mut sum: i32;
            noinline fn woot(z: i32)                // previously a new woot was emitted
                for (mut i = 0; i < nums.len; i++)  //  with the nums expr inlined,
                    sum += nums[i] & z;             //   now nums doesnt inline inside woot

            for (mut i = 0; i < nums.len; i++) {
                if (i > 0) woot(nums[i] & nums[i - 1]);         ;; PointlessMustSeq
                if (i > 1) woot(nums[i] & nums[i - 2]);
            }

            return sum;
        }

        fn main() {
            mut x = 0;
            let res = inline_args_and_closures([ x++, x++, x++ ]);
            return x == 93 && res == 290 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 9:33+4[0m:

[2m      | [0m
[2m      |             for (mut i = 0; i < nums.len; i++) {[0m
[2m    9 | [0m                if (i > 0) woot([31;1mnums[0m[i] & nums[i - 1]);         // PointlessMustSeq
[2m      |                 if (i > 1) woot(nums[i] & nums[i - 2]);[0m
[2m      |             }[0m

	Inline arguments can only be inlined once.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       ;; N_BckMustSeq
            return (items[0] - 101).i32;
        }

---- TODO: ----
Expected note not listed: [31;1mN_BckMustSeq[0m in:

        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       // N_BckMustSeq
            return (items[0] - 101).i32;
        }


Output is:


        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       // N_BckMustSeq
            return (items[0] - 101).i32;
        }

========

        struct TEA { v0: u32; v1: u32 }

        inline fn r4(using ref _: TEA, ref sum: u32) {
            mut delta: u32 = 0x9e3779b9;
            for (mut i = 0; i < 4; i++) {
                sum += delta;
                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        inline fn u32(tea: TEA): u32 =
            tea.v0 ^ tea.v1;                                    ;; GNUStmtExpr

        fn main() {
            mut tea: TEA;
            mut sum: u32;
            tea.r4(sum);
            let actual = tea.u32;
            return actual == 0x93bfa05 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 4:49+3[0m:

[2m      |         struct TEA { v0: u32; v1: u32 }[0m
[2m      | [0m
[2m    4 | [0m        inline fn r4(using ref _: TEA, ref sum: [31;1mu32[0m) {
[2m      |             mut delta: u32 = 0x9e3779b9;[0m
[2m      |             for (mut i = 0; i < 4; i++) {[0m

	Ambiguous call to [94;1mu32[0m, matches multiple items in scope:

	[35;3minline[0m [94;1mu32[0m at [2m13:19+3[0m:
[2m   13 | [0m        inline fn [31;1mu32[0m(tea: TEA): u32 =

	    [35;3musing[0m [35;3mmut ref arg[0m [94;1m_[0m at [2m4:22+5[0m [2m4:32+1[0m:
[2m    4 | [0m        inline fn r4([31;1musing[0m ref [31;1m_[0m: TEA, ref sum: u32) {

	[35;3mtype[0m [94;1mu32[0m

========

        pub fn pairs(a: Map($K, $V), fn) {
            let k = a.keys;
            let v = a.values;
            for (mut i = 0; i < k.len; i++)
                fn(k[i], v[i]);
        }

        fn main() {
            mut map: Map(i32, i32);
            map[1] = 2;
            map[3] = 4;

            mut sum = 0;
            map.pairs(|k, v| sum += k + v * 100);
            return sum - 604;
        }

---- TODO: ----
[2m[0m_0[2m.fu 2:25+3[0m:

[2m      | [0m
[2m    2 | [0m        pub fn pairs(a: [31;1mMap[0m($K, $V), fn) {
[2m      |             let k = a.keys;[0m
[2m      |             let v = a.values;[0m

	[94;1mMap[0m is not defined here.

========

        struct ScopeSkip {
            min: i32;
            max: i32;
        };

        fn main() {
            let a = 1;
            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.
            mut t: ScopeSkip; t = x.min && [ x.min, a ];
            return a + t.min + t.max;
        }

---- TODO: ----
[2m[0m_0[2m.fu 9:41+1[0m:

[2m      |         fn main() {[0m
[2m      |             let a = 1;[0m
[2m    9 | [0m            mut x: ScopeSkip; x = []; x [31;1m=[0m [ -2, 0 ]; // Inference fail.
[2m      |             mut t: ScopeSkip; t = x.min && [ x.min, a ];[0m
[2m      |             return a + t.min + t.max;[0m

	Bad call to [94;1m=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mScopeSkip[0m, [35;3mi32[0m[35;3m[][0m): 

	[35;3mtemplate[0m [94;1m=[0m at [2m../../../../../[0mprelude[2m 212:12+1[0m:
[2m  212 | [0minfix fn   [31;1m=[0m (mut ref a: <T>,    mut b: T): &mut T = __native;

	    [35;3marg[0m [94;1m=[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstruct[0m [94;1mScopeSkip[0m <-> [35;3mi32[0m[35;3m[][0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn setupOperators(i: i32) {
            <alt>
            struct sB { hey: i32; };
            struct BINOP { i: sB; };
            <alt/>
            fn sB(_: $T) struct { hey: $T; };
            struct BINOP { i: sB(i32); };
            </alt>
            return BINOP([ i ]); // Inference fail.
        }

        fn main() setupOperators(0).i.hey;

---- TODO: ----
[2m[0m_0[2m.fu 7:20+5[0m:

[2m      |             struct BINOP { i: sB(i32); };[0m
[2m      | [0m
[2m    7 | [0m            return [31;1mBINOP[0m([ i ]); // Inference fail.
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1mBINOP[0m with args ([35;3mi32[0m[35;3m[][0m): 

	[35;3mtype[0m [94;1mBINOP[0m at [2m5:13+6[0m:
[2m    5 | [0m            [31;1mstruct[0m BINOP { i: sB(i32); };

	    [35;3marg[0m [94;1mi[0m expects [35;3mstruct[0m [94;1msB[0m([35;3mi32[0m), got [35;3mi32[0m[35;3m[][0m

        Solving [35;3mfn[0m [94;1msetupOperators[0m([35;3mi32[0m) at [2m2:12+14[0m

========

        fn next_mip(ref s: i16) s = s >> 1 || 1;
        fn main() {
            mut v = 3.i16;
            let a = v.next_mip();
            let b = v.next_mip();
            return int(a + b) - 2;
        }

---- TODO: ----
[2m[0m_0[2m.fu 2:44+2[0m:

[2m      | [0m
[2m    2 | [0m        fn next_mip(ref s: i16) s = s >> 1 [31;1m||[0m 1;
[2m      |         fn main() {[0m
[2m      |             mut v = 3.i16;[0m

	Ambiguous ||, incompatible operands in a non-bool context: [35;3mi16[0m || [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mnext_mip[0m([35;3mi16[0m) at [2m2:12+8[0m

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS ? "B " : []) ~ "C";
        fn main() glsl_what.len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef DEF_USE_MIPMAPS
                                #define DEF_USE_MIPMAPS
inline constexpr bool USE_MIPMAPS = false;
                                #endif

#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + (USE_MIPMAPS ? "B "_view : fu::view<char>{})) + "C"_view);

int fu_MAIN()
{
    return glsl_what.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS ? "B " : []) ~ "C";
        fn main() glsl_what.len - 3;

---- TODO: ----
[2m[0m_0[2m.fu 3:30+1[0m:

[2m      | [0m
[2m      |         let USE_MIPMAPS = false;[0m
[2m    3 | [0m        let glsl_what = "A " [31;1m~[0m (USE_MIPMAPS ? "B " : []) ~ "C";
[2m      |         fn main() glsl_what.len - 3;[0m
[2m      | [0m

	Ambiguous call to [94;1m~[0m with args ([35;3malways-true[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");


========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS ? 'B' : []) ~ " C";
        fn main() glsl_what == "A \0 C" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_USE_MIPMAPS
                                #define DEF_USE_MIPMAPS
inline constexpr bool USE_MIPMAPS = false;
                                #endif

#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + (USE_MIPMAPS ? 'B' : char{})) + " C"_view);

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (glsl_what == "A \x00 C"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS ? 'B' : []) ~ " C";
        fn main() glsl_what == "A \0 C" ? 0 : 1;

---- TODO: ----
[2m[0m_0[2m.fu 3:30+1[0m:

[2m      | [0m
[2m      |         let USE_MIPMAPS = false;[0m
[2m    3 | [0m        let glsl_what = "A " [31;1m~[0m (USE_MIPMAPS ? 'B' : []) ~ " C";
[2m      |         fn main() glsl_what == "A \0 C" ? 0 : 1;[0m
[2m      | [0m

	Ambiguous call to [94;1m~[0m with args ([35;3malways-true[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");


========

        <alt>
        inline      <alt/>
        noinline    </alt>
        fn invoke(ref str: int[..], what) {
            what(str);
        }

        <alt>
        inline      <alt/>
        noinline    </alt>
        fn Lifetime_op(ref lt: int[..], what) {
            mut result: int[];
            lt.invoke: |p| {
                result ~= p;                                    ;; PointlessMustSeq
                what(lt);
            }
            return result;
        }

        fn Lifetime_op_join(ref lt: int[..]) {
            return lt.Lifetime_op(|c| {
                mut sum = 0;
                for (mut i = 0; i < c.len; i++) sum += c[i];
                lt.each: |ref x| x += sum;
            });
        }

        fn main() {
            mut lt  = [ 1, 2, 3, 4 ];
            let res = Lifetime_op_join(lt);
            return res == [ 1, 2, 3, 4 ] && lt == [ 11, 12, 13, 14 ] ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 20:23+11[0m:

[2m      | [0m
[2m      |         fn Lifetime_op_join(ref lt: int[..]) {[0m
[2m   20 | [0m            return lt.[31;1mLifetime_op[0m(|c| {
[2m      |                 mut sum = 0;[0m
[2m      |                 for (mut i = 0; i < c.len; i++) sum += c[i];[0m

	At call to [35;3mfn[0m [94;1mLifetime_op[0m, arguments:

	    3:	[35;3minjected implicit ref arg[0m [94;1mLifetime_op[0m:[94;1mLifetime_op_join:lt[0m and
	    1:	[35;3mref arg[0m [94;1mLifetime_op[0m:[94;1mlt[0m

	    both alias:

	    [35;3mmut ref arg[0m [94;1mlt[0m at [2m19:33+2[0m:

[2m      |         }[0m
[2m      | [0m
[2m   19 | [0m        fn Lifetime_op_join(ref [31;1mlt[0m: int[..]) {
[2m      |             return lt.Lifetime_op(|c| {[0m
[2m      |                 mut sum = 0;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mLifetime_op[0m:[94;1mLifetime_op_join:lt[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[..][0m

	    [35;3mref arg[0m [94;1mLifetime_op[0m:[94;1mlt[0m is non-copyable: [35;3mnocopy[0m [35;3mi32[0m[35;3m[..][0m

    BorrowCheck [35;3mfn[0m [94;1mLifetime_op_join[0m([35;3mi32[0m[35;3m[..][0m) at [2m19:12+16[0m

========

        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int A_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int B_MbR9(/*1:1*/ const int x)
{
    return A_MbR9(x);
}

int fu_MAIN()
{
    return A_MbR9(0) + B_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { canon: string }
        struct LocidMap(type T) { _values: T[] };

        fn each(ref map: LocidMap(_), each) // <- This each arg confusingly matches ...
            map._values.each( // ... at this .each callsite, and then fails to compile.
                |ref type, i| // Needs a BETTER ERROR message, doesn't need to work.
                    each(type, i?: map._values.len - 1 - i));

        fn test(var_usage0: LocidMap(Type), ref sum: int)
        {
            mut result: string;
            fn trackVarUsage(i: int, slot: Type) {
                sum     += i;
                result  ~= slot.canon;
            }
                                                    <alt>
            var_usage0.each: |slot: Type, i: int|   <alt/>
            var_usage0.each: |slot,       i: int|   <alt/>
            var_usage0.each: |slot: Type, i     |   <alt/>
            var_usage0.each: |slot,       i     |   <alt/>
            var_usage0.each: |i: int, slot: Type|   <alt/>
            var_usage0.each: |i: int, slot      |   <alt/>
            var_usage0.each: |i,      slot: Type|   <alt/>
            var_usage0.each: |i,      slot      |   </alt>
                if (slot)
                    trackVarUsage(i, slot);
        }

        fn main() {
            mut sum = 0;
            let res = test(:sum, LocidMap([ Type(", World!"), Type("Hello") ]));
            return res == "Hello, World!" && sum == 1 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 19:21+4[0m:

[2m      | [0m
[2m      |             var_usage0.each: |i,      slot      |   [0m
[2m   19 | [0m                if ([31;1mslot[0m)
[2m      |                     trackVarUsage(i, slot);[0m
[2m      |         }[0m

	Bad call to [94;1mslot[0m: 

	[35;3mtemplate[0m [94;1m_[0m at [2m7:17+1[0m:
[2m    7 | [0m                [31;1m|[0mref type, i| // Needs a BETTER ERROR message, doesn't need to work.

	    Wrong number of arguments: expects 2, got 0.

        Solving [35;3mfn[0m [94;1m_[0m([94;1mType[0m[35;3m[..][0m, [35;3m@1J0[0m) at [2m18:30+1[0m
                [35;3mfn[0m [94;1meach[0m([94;1mLocidMap[0m, [35;3m@1G0[0m) at [2m5:12+4[0m
                [35;3mfn[0m [94;1mtest[0m([94;1mLocidMap[0m, [35;3mi32[0m) at [2m10:12+4[0m

========

        struct List(type T) { data: T[] }

        pub import _0;

        fn main() {
            mut list: _1::List(i32);
            return list.data.len;
        }

---- TODO: ----
[2m[0m_2[2m.fu 3:27+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut list: _1::[31;1mList[0m(i32);
[2m      |             return list.data.len;[0m
[2m      |         }[0m

	Bad call to [94;1mList[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): [94;1mList[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========
//file a.fu
        let v = 7;
//file A.fu
        let v = 19;

        fn main() {
            let c = a::v + B::v;
            return c - 26;
        }

---- <fail> ----
Two paths differing only in capitalization were accessed:

	/Users/hdachev/fu/__tests__/A.fu

	/Users/hdachev/fu/__tests__/a.fu

	This creates confusion on case insensitive file systems.
========
//file a.fu
        let v = 7;
//file <fail creates confusion case insensitive file systems>A.fu<pass/>B.fu</fail>
        let v = 19;

        fn main() {
            let c = a::v + B::v;
            return c - 26;
        }

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
a.fu
B.fu
_2.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>


                                #ifndef DEF_v
                                #define DEF_v
inline constexpr int v = 7;
                                #endif

// N_SD_HasStaticInit

                                #ifndef DEF_v
                                #define DEF_v
inline constexpr int v = 19;
                                #endif

// N_SD_HasStaticInit

                                #ifndef DEF_v
                                #define DEF_v
inline constexpr int v = 7;
                                #endif

                                #ifndef DEF_v
                                #define DEF_v
inline constexpr int v = 19;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int c = (v + v);
    return c - 26;
}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 244
========

        struct Hello { hello: int };
        fn what(using ref <fail ambig hello hello using 5:16+5 4:27+5 2:24+5>
                          hello     <pass/>
                          _         </fail><alt>: Hello</alt>, fn)
            fn(hello);

        fn main() {
            mut hello: Hello;
            return hello.what(|v| v);
        }

---- TODO: ----
<fail> mismatch:

    Expected error keyword:
        [31;1mambig[0m from pattern <fail[31;1m ambig hello hello using 5:16+5 4:27+5 2:24+5[0m>

    ... not present in error message:

[2m[0m_0[2m.fu 9:13+6[0m:

[2m      |         fn main() {[0m
[2m      |             mut hello: Hello;[0m
[2m    9 | [0m            [31;1mreturn[0m hello.what(|v| v);
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mstruct[0m [94;1mHello[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        struct RawSet { ints: int[] };
        fn each(using ref _: RawSet, fn) ints.each: fn fn;

        struct LocidSet { raw_set: RawSet };
        fn each(using ref <fail ambig call raw_set field using 9:13+7 7:27+7 5:27+7>
                          raw_set       <pass/>
                                _       </fail> : LocidSet, offset: int, fn)
        {
            raw_set.each: |item| fn(item + offset);
        }

        fn sum(using ref ls: LocidSet, offset: int) {
            mut sum = 0;
            ls.each(:offset): |item| sum += item;
            return sum;
        }

        fn main() {
            mut ls = LocidSet(RawSet([ 1, 2, 3 ]));
            mut sum = ls.sum(10);
            return sum - 36;
        }

---- TODO: ----
<fail> mismatch:

    Expected error keyword:
        [31;1mambig[0m from pattern <fail[31;1m ambig call raw_set field using 9:13+7 7:27+7 5:27+7[0m>

    ... not present in error message:

[2m[0m_0[2m.fu 9:21+4[0m:

[2m      |                           raw_set        : LocidSet, offset: int, fn)[0m
[2m      |         {[0m
[2m    9 | [0m            raw_set.[31;1meach[0m: |item| fn(item + offset);
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1meach[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mLocidSet[0m, [35;3mnocopy[0m [35;3m@1B0[0m): 

	[35;3mtemplate[0m [94;1meach[0m at [2m6:12+4[0m:
[2m    6 | [0m        fn [31;1meach[0m(using ref 

	    Cannot infer missing [35;3mref arg[0m [94;1mraw_set[0m

	[35;3mtemplate[0m [94;1meach[0m at [2m3:12+4[0m:
[2m    3 | [0m        fn [31;1meach[0m(using ref _: RawSet, fn) ints.each: fn fn;

	    [35;3marg[0m [94;1meach[0m:[94;1m_[0m:
	    Incompatible types: expects [35;3mstruct[0m [94;1mRawSet[0m, got [35;3mstruct[0m [94;1mLocidSet[0m

	[35;3mtemplate[0m [94;1meach[0m at [2m../../../../../[0mprelude[2m 858:4+4[0m:
[2m  858 | [0mfn [31;1meach[0m(ref a: <T>[..], fn)

	    [35;3marg[0m [94;1meach[0m:[94;1ma[0m:
	    Not sliceable: [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mLocidSet[0m

        Solving [35;3mfn[0m [94;1meach[0m([94;1mLocidSet[0m, [35;3mi32[0m, [35;3m@190[0m) at [2m6:12+4[0m
                [35;3mfn[0m [94;1msum[0m([94;1mLocidSet[0m, [35;3mi32[0m) at [2m12:12+3[0m

========

        struct vec32  { x: f32; };
        struct conv32 { v: f32; };

        <alt>
        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix
        <alt/>
        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32
        </alt>

        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        fn main() i32 <| (1/vec32(1)).x - 1;

---- TODO: ----
[2m[0m_0[2m.fu 10:28+1[0m:

[2m      | [0m
[2m      |         inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);[0m
[2m   10 | [0m        fn main() i32 <| (1[31;1m/[0mvec32(1)).x - 1;
[2m      | [0m

	Bad call to [94;1m/[0m with args ([35;3mi32[0m, [35;3mstruct[0m [94;1mvec32[0m): 

	[35;3minline[0m [94;1m/[0m at [2m9:19+1[0m:
[2m    9 | [0m        inline fn [31;1m/[0m(a: conv32, b: vec32) vec32(a.v / b.x);

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m expects [35;3mstruct[0m [94;1mconv32[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m/[0m at [2m../../../../../[0mprelude[2m 12:10+1[0m:
[2m   12 | [0minfix fn [31;1m/[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstruct[0m [94;1mvec32[0m <-> [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m10:12+4[0m

========

        struct vec_u  { x: u32; };
        struct vec32  { x: f32; };
        struct vec64  { x: f64; };

        struct conv_u { v: u32; };
        struct conv32 { v: f32; };
        struct conv64 { v: f64; };

        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before
        using inline fn convert(v: f32): conv32 = [ v ];
        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after

        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);

        fn main() i32 <| (1/vec32(1)).x - 1;

---- TODO: ----
[2m[0m_0[2m.fu 18:28+1[0m:

[2m      |         inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);[0m
[2m      | [0m
[2m   18 | [0m        fn main() i32 <| (1[31;1m/[0mvec32(1)).x - 1;
[2m      | [0m

	Bad call to [94;1m/[0m with args ([35;3mi32[0m, [35;3mstruct[0m [94;1mvec32[0m): 

	[35;3minline[0m [94;1m/[0m at [2m16:19+1[0m:
[2m   16 | [0m        inline fn [31;1m/[0m(a: conv64, b: vec64) vec64(a.v / b.x);

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m expects [35;3mstruct[0m [94;1mconv64[0m, got [35;3mi32[0m

	[35;3minline[0m [94;1m/[0m at [2m15:19+1[0m:
[2m   15 | [0m        inline fn [31;1m/[0m(a: conv32, b: vec32) vec32(a.v / b.x);

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m expects [35;3mstruct[0m [94;1mconv32[0m, got [35;3mi32[0m

	[35;3minline[0m [94;1m/[0m at [2m14:19+1[0m:
[2m   14 | [0m        inline fn [31;1m/[0m(a: conv_u, b: vec_u) vec_u(a.v / b.x);

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m expects [35;3mstruct[0m [94;1mconv_u[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m/[0m at [2m../../../../../[0mprelude[2m 12:10+1[0m:
[2m   12 | [0minfix fn [31;1m/[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m/[0m:[94;1ma[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstruct[0m [94;1mvec32[0m <-> [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m18:12+4[0m

========

        struct A { a: i32 };
        struct B { b: i32 };

        // Currently this would have to be named fn A -
        //  because we match by type *name*, instead of
        //   attempting conversions to type A.
        //
        // We want to replace match-by-name by tryConvert.
        //
        using fn A2B(a: A): B = [ a.a + 3 ];

        fn main() A(2).b - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_UWB4 A2B_MbR9(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a + 3) };
}

int fu_MAIN()
{
    return A2B_MbR9(A_EqO7 { 2 }).b - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32 };
        struct B { b: i32 };

        // Currently this would have to be named fn A -
        //  because we match by type *name*, instead of
        //   attempting conversions to type A.
        //
        // We want to replace match-by-name by tryConvert.
        //
        using fn A2B(a: A): B = [ a.a + 3 ];

        fn main() A(2)<alt>.B</alt>.b - 5;

---- TODO: ----
[2m[0m_0[2m.fu 13:24+1[0m:

[2m      |         using fn A2B(a: A): B = [ a.a + 3 ];[0m
[2m      | [0m
[2m   13 | [0m        fn main() A(2).[31;1mB[0m.b - 5;
[2m      | [0m

	Bad call to [94;1mB[0m with args ([35;3mstruct[0m [94;1mA[0m): 

	[35;3mtype[0m [94;1mB[0m at [2m3:9+6[0m:
[2m    3 | [0m        [31;1mstruct[0m B { b: i32 };

	    [35;3marg[0m [94;1mb[0m expects [35;3mi32[0m, got [35;3mstruct[0m [94;1mA[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn Wrap(type T) =
            struct { value!: T };

        infix fn => !<A, B>
            (from: Wrap(A), lax _: Wrap(B)): Into =
                [ Into(from.value) + 4 ];
    <alt>
        fn main() =
            (7.u32 => Wrap(int)).value - 14;
    <alt/>
        fn main() {
            type T = Wrap(int);
            return T(7.u32).value - 14;
        }
    </alt>

---- TODO: ----
[2m[0m_0[2m.fu 11:20+1[0m:

[2m      |         fn main() {[0m
[2m      |             type T = Wrap(int);[0m
[2m   11 | [0m            return [31;1mT[0m(7.u32).value - 14;
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1mT[0m with args ([35;3mu32[0m): 

	[35;3mtype[0m [94;1mWrap[0m at [2m3:13+6[0m:
[2m    3 | [0m            [31;1mstruct[0m { value!: T };

	    ... via [2m10:18+1[0m:
[2m   10 | [0m            type [31;1mT[0m = Wrap(int);

	    [35;3marg[0m [94;1mvalue[0m must be :named explicitly.

	[35;3mtemplate[0m [94;1mWrap[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mWrap[0m(type T) =

	    [35;3marg[0m [94;1mT[0m expects a type, got a value: [35;3mu32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        struct A { x: i32 };
        struct B { using a: A };
        struct C { b: B };
<alt>
        using fn C2B(ref .b) b;                             <alt/>
        using fn C2B(using ref c: C or C) b;                <alt/>
        using fn C2B(using ref c: <T>) case (T -> C) b;     <alt/>
        using fn C2B(using ref c: C, lax unused?: $T) b;    </alt>

        <split/>
<alt>
        using fn generic_ref_x(using ref a: A or A) x;              <alt/>
        using fn generic_ref_x(using ref a: <T>) case (T -> A) x;   <alt/>
        using fn generic_ref_x(using ref a: A, lax unused?: $T) x;  </alt>
<alt>
        using fn val_x(using c: C) generic_ref_x;           <alt/>
        using fn val_x(c: C)     c.generic_ref_x;           <alt/>
        using fn val_x(ref c: C) c.generic_ref_x;           </alt>

        <split/>
        fn main() {
            using mut c: C;
            generic_ref_x++;
            return val_x - 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 17:13+13[0m:

[2m      |         fn main() {[0m
[2m      |             using mut c: C;[0m
[2m   17 | [0m            [31;1mgeneric_ref_x[0m++;
[2m      |             return val_x - 1;[0m
[2m      |         }[0m

	Bad call to [94;1mgeneric_ref_x[0m: 

	[35;3mtemplate[0m [94;1mgeneric_ref_x[0m at [2m10:18+13[0m:
[2m   10 | [0m        using fn [31;1mgeneric_ref_x[0m(using ref a: A, lax unused?: $T) x;  

	    Cannot infer missing [35;3mref arg[0m [94;1ma[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m15:12+4[0m

========

        fn Each !T(ref a: T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i], i?: i);

        <split/>
        fn main() {
            fn sqr(v) v * v;
            let list = [ 1, 2, 3 ];
            mut sum_of_squares = 0;
            list.Each: |.sqr| sum_of_squares += sqr;
            return sum_of_squares - 14;
        }

---- TODO: ----
[2m[0m_0[2m.fu 4:17+2[0m:

[2m      |         fn Each !T(ref a: T[..], fn)[0m
[2m      |             for (mut i = 0; i < a.len; i++)[0m
[2m    4 | [0m                [31;1mfn[0m(a[i], i?: i);
[2m      | [0m
[2m      | [0m

	Bad call to [94;1mfn[0m with args ([35;3mi32[0m, [35;3mmut[0m [35;3mref[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m_[0m at [2m11:24+1[0m:
[2m   11 | [0m            list.Each: [31;1m|[0m.sqr| sum_of_squares += sqr;

	    Cannot match [35;3marg[0m [94;1msqr[0m autocall [94;1msqr[0m: [94;1msqr[0m is not defined here.

        Solving [35;3mfn[0m [94;1mEach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@140[0m) at [2m2:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn Each !T(ref a: T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i], i?: i);

        <split/>
        struct List(type T) { sorted!: T[] }
        fn Each !T(l: List(T), visit)
            l.sorted.Each: fn visit;

        <split/>
        fn main() {
            fn sqr(v) v * v;
            let list: List(int) = [ sorted: [ 1, 2, 3 ] ];
            mut sum_of_squares = 0;
            list.Each: |.sqr| sum_of_squares += sqr;
            return sum_of_squares - 14;
        }

---- TODO: ----
[2m[0m_0[2m.fu 4:17+2[0m:

[2m      |         fn Each !T(ref a: T[..], fn)[0m
[2m      |             for (mut i = 0; i < a.len; i++)[0m
[2m    4 | [0m                [31;1mfn[0m(a[i], i?: i);
[2m      | [0m
[2m      | [0m

	Bad call to [94;1mfn[0m with args ([35;3mi32[0m, [35;3mmut[0m [35;3mref[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m_[0m at [2m16:24+1[0m:
[2m   16 | [0m            list.Each: [31;1m|[0m.sqr| sum_of_squares += sqr;

	    Cannot match [35;3marg[0m [94;1msqr[0m autocall [94;1msqr[0m: [94;1msqr[0m is not defined here.

        Solving [35;3mfn[0m [94;1mEach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@1A0[0m) at [2m2:12+4[0m
                [35;3mfn[0m [94;1mEach[0m([94;1mList[0m, [35;3m@1A0[0m) at [2m8:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========

        struct Node         { value: int; items: Node[] };
        struct OpenBlock    { using node: Node };

        fn closeOpenBlocks(ref open_blocks: OpenBlock[]) {
            for (mut i = open_blocks.len; i --> 1; )
                open_blocks[i - 1].items ~= open_blocks[i];

            open_blocks.shrink(1);
            return open_blocks.only;
        }

        fn main() {
            mut open_blocks = [
                OpenBlock(Node(10)),
                OpenBlock(Node(20)),
                OpenBlock(Node(30)),
            ];

            let n = closeOpenBlocks(open_blocks);

            fn sum(n: Node) {
                mut sum = n.value;
                n.items.each(|item| sum += item.sum());
                return sum;
            }

            return n.sum() == 60 ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 7:42+2[0m:

[2m      |         fn closeOpenBlocks(ref open_blocks: OpenBlock[]) {[0m
[2m      |             for (mut i = open_blocks.len; i --> 1; )[0m
[2m    7 | [0m                open_blocks[i - 1].items [31;1m~=[0m open_blocks[i];
[2m      | [0m
[2m      |             open_blocks.shrink(1);[0m

	Bad call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNode[0m[35;3m[][0m, [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mOpenBlock[0m): 

	[35;3mtemplate[0m [94;1m~=[0m at [2m../../../../../[0mprelude[2m 552:10+2[0m:
[2m  552 | [0minfix fn [31;1m~=[0m(mut ref a: string,   b.str      ) a ~= b;

	    [35;3mref arg[0m [94;1m~=[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mstruct[0m [94;1mNode[0m[35;3m[][0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	    [35;3marg[0m [94;1m<fu/vec/concat_one.h> +=[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstruct[0m [94;1mNode[0m <-> [35;3mstruct[0m [94;1mOpenBlock[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");

	    [35;3marg[0m [94;1m<fu/vec/concat.h> +=[0m:[94;1mb[0m:
	    Not sliceable: [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mOpenBlock[0m

        Solving [35;3mfn[0m [94;1mcloseOpenBlocks[0m([94;1mOpenBlock[0m[35;3m[..][0m) at [2m5:12+15[0m

========

        enum Color { Red = 0; Green; Blue; Yellow; Cyan; Magenta };
        enum ColorFam { Primary = 0; Secondary = 3 };
        fn woot(c: Color or ColorFam) c.int;
        fn main() woot("Yellow") - woot("Secondary");

---- TODO: ----
[2m[0m_0[2m.fu 5:19+4[0m:

[2m      |         enum ColorFam { Primary = 0; Secondary = 3 };[0m
[2m      |         fn woot(c: Color or ColorFam) c.int;[0m
[2m    5 | [0m        fn main() [31;1mwoot[0m("Yellow") - woot("Secondary");
[2m      | [0m

	Bad call to [94;1mwoot[0m with args ([35;3mstring[0m): 

	[35;3mtemplate[0m [94;1mwoot[0m at [2m4:12+4[0m:
[2m    4 | [0m        fn [31;1mwoot[0m(c: Color or ColorFam) c.int;

	    [35;3marg[0m [94;1mwoot[0m:[94;1mc[0m:
	    Incompatible types: expects [35;3menum[0m [94;1mColor[0m, got [35;3mstring[0m
	    Incompatible types: expects [35;3menum[0m [94;1mColorFam[0m, got [35;3mstring[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn count_args!T (
            <alt>
            inline
            </alt>
            v[]: T[]) = v.len;

        fn main() = count_args(
            hello?: "ignore me",
            1, 2, 3,
            world?: "ignore me too")
                == 3 ? 0 : 1;

---- TODO: ----
[2m[0m_0[2m.fu 6:21+10[0m:

[2m      |             v[]: T[]) = v.len;[0m
[2m      | [0m
[2m    6 | [0m        fn main() = [31;1mcount_args[0m(
[2m      |             hello?: "ignore me",[0m
[2m      |             1, 2, 3,[0m

	Bad call to [94;1mcount_args[0m with args ([35;3mstring[0m, [35;3mi32[0m, [35;3mi32[0m, [35;3mi32[0m, [35;3mstring[0m): 

	[35;3mtemplate[0m [94;1mcount_args[0m at [2m2:12+10[0m:
[2m    2 | [0m        fn [31;1mcount_args[0m!T (

	    Optional argument ambiguity:

		Optional :named argument mismatch: no [31;3marg[0m [31;1mhello[0m.

		Cannot distinguish from a typo.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        inline fn parseStuff(x: i32) descend(x);                ;; GNUStmtExpr

        inline fn descend(x: i32) {
            fn inner() x & 1 ? parseStuff(x / 2) : x;
            return inner();
        }

        fn main() parseStuff(5) == 2 ? 0 : 1;

---- TODO: ----
[2m[0m_0[2m.fu 6:20+5[0m:

[2m      |         inline fn descend(x: i32) {[0m
[2m      |             fn inner() x & 1 ? parseStuff(x / 2) : x;[0m
[2m    6 | [0m            return [31;1minner[0m();
[2m      |         }[0m
[2m      | [0m

	COMPILER BUG:

	[35;3mcall[0m([35;3mfn[0m [94;1minner[0m) -> [35;3mi32[0m [35;3mfn[0m [94;1minner[0m: host_args.len (0) != args.len (1):
		2i32
		[35;3mfn[0m [94;1minner[0m at [2m5:16+5[0m:
[2m    5 | [0m            fn [31;1minner[0m() x & 1 ? parseStuff(x / 2) : x;


        Solving [35;3mfn[0m [94;1minner[0m at [2m5:16+5[0m
                [35;3minline[0m [94;1mdescend[0m([35;3mi32[0m) at [2m4:19+7[0m

========

        struct Target { _packed: u32 }
        inline fn globid(t: Target) i32(t._packed);

        fn TRACE_BRACKET(implicit ref TRACE_out: string, inline msg: string) unwrap {
            mut len0: int;
            defer if (TRACE_out.len > len0) {
                // unlike the test above, we'll inline msg twice
                TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");
                TRACE_out ~= "</" ~ msg ~ ">";
            }
        }

        fn TRACE(implicit ref TRACE_out: string, msg: string) TRACE_out ~= msg;

        fn doTrySpecialize(mut target: Target, what) {
            mut mul = 10;
            TRACE_BRACKET("Hello " ~ (target.globid * mul++));
            what();
        }

        fn solve(a: Target, b: Target) {
            doTrySpecialize(a, || {});
            doTrySpecialize(b, || TRACE("World!"));
        }

        fn main() {
            implicit mut TRACE_out = "";
            solve(          <fail wrong number of arguments 29:13+5>
                :TRACE_out, <pass/></fail>
                Target(1), Target(2));
            return TRACE_out == "<Hello 20>World!</Hello 22>" ? 0 : 1;
        }

---- TODO: ----
<fail> mismatch:

    Expected error keyword:
        [31;1mwrong[0m from pattern <fail[31;1m wrong number of arguments 29:13+5[0m>

    ... not present in error message:

[2m[0m_0[2m.fu 10:37+3[0m:

[2m      |                 // unlike the test above, we'll inline msg twice[0m
[2m      |                 TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");[0m
[2m   10 | [0m                TRACE_out ~= "</" ~ [31;1mmsg[0m ~ ">";
[2m      |             }[0m
[2m      |         }[0m

	Inline arguments can only be inlined once.

        Solving [35;3mfn[0m [94;1mdoTrySpecialize[0m([94;1mTarget[0m, [35;3m@1L0[0m) at [2m16:12+15[0m
                [35;3mfn[0m [94;1msolve[0m([94;1mTarget[0m, [94;1mTarget[0m) at [2m22:12+5[0m

========

        nocopy struct NoCopy {};
        struct Generic(type V) { vals: V[] }

        struct SelfRecursive {
            _scope:             NoCopy;
            _conv_cache:        Generic(SelfRecursive);
        };

        fn main() {
            mut v: SelfRecursive;
            v._conv_cache.vals ~= v; // fail
            return v._conv_cache.vals.len;
        }

---- TODO: ----
[2m[0m_0[2m.fu 3:40+1[0m:

[2m      | [0m
[2m      |         nocopy struct NoCopy {};[0m
[2m    3 | [0m        struct Generic(type V) { vals: [31;1mV[0m[] }
[2m      | [0m
[2m      |         struct SelfRecursive {[0m

	COMPILER BUG:

	detectRecursion: no _helpers entry for `SelfRecursive (SS_LAZY, SS_DID_START, SS_TYPE_RECUR)`.

        Solving [35;3mtype[0m [94;1mGeneric[0m
                [35;3mfn[0m [94;1mGeneric[0m([94;1mSelfRecursive[0m) at [2m3:9+6[0m
                [35;3mtype[0m [94;1mSelfRecursive[0m([94;1mNoCopy[0m, [94;1mGeneric[0m)

========

        struct List {
            struct Item { value: int };
            fn newItem(v: int)  Item(value);

            items: Item[];
            fn push(v: int)     items ~= newItem(v);
            fn each(fn)         items.each: fn fn;
        }

        fn main() {
            mut list: List;
            list.push(3);
            list.items ~= List.Item(5);
            mut check = 0;
            list.each: |item: List.Item| check += 11 * item.value;
            return check - 88;
        }

---- TODO: ----
[0m_0[2m.fu 3:20+4[0m:

[2m      | [0m
[2m      |         struct List {[0m
[2m    3 | [0m            struct [31;1mItem[0m { value: int };
[2m      |             fn newItem(v: int)  Item(value);[0m
[2m      | [0m

	Missing semicollon before [31;1mItem[0m.

========

        fn test(x: i32)
        {
            fn mayExitTest() {
                return x & 1 ? { return :test x * x; }          // GNUStmtExpr
                             : x * 2;
            }

            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {
                return y * x;
            }

            return x & 2 ? mayExitTestFromDefarg()
                         : mayExitTestFromDefarg(x * 2);
        }

        fn main() {
            return test(3) == 9 && test(4) == 32 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    if (x & 2)
    {
        const int y = ((x & 1) ? (__extension__ (
        {
            return x * x;
            (void)0;
        }), fu::unreachable) : (x * 2));
        return y * x;
    }
    else
    {
        const int y = (x * 2);
        return y * x;
    };
}

int fu_MAIN()
{
    if ((test_MbR9(3) == 9) && (test_MbR9(4) == 32))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_001(ref m!: S, c!: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn test(ref mc: S) {
            return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c!
        }                                               //  But can be made to work by creating an intermediate copyvar
                                                        //   and move-returning from there.
        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
            let hey = test(mc);
            return hey.len - 10;
        }

---- TODO: ----
[2m[0m_0[2m.fu 10:51+2[0m:

[2m      | [0m
[2m      |         fn test(ref mc: S) {[0m
[2m   10 | [0m            return m_and_c_cant_alias_001(m:mc, c:[31;1mmc[0m);  // Can't return a ref into c!
[2m      |         }                                               //  But can be made to work by creating an intermediate copyvar[0m
[2m      |                                                         //   and move-returning from there.[0m

	At call to [35;3mfn[0m [94;1mm_and_c_cant_alias_001[0m, arguments:

	    2:	[35;3marg[0m [94;1mm_and_c_cant_alias_001[0m:[94;1mc[0m and
	    1:	[35;3mref arg[0m [94;1mm_and_c_cant_alias_001[0m:[94;1mm[0m

	    both alias:

	    [35;3mmut ref arg[0m [94;1mmc[0m at [2m9:21+2[0m:

[2m      |         }[0m
[2m      | [0m
[2m    9 | [0m        fn test(ref [31;1mmc[0m: S) {
[2m      |             return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c![0m
[2m      |         }                                               //  But can be made to work by creating an intermediate copyvar[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3marg[0m [94;1mm_and_c_cant_alias_001[0m:[94;1mc[0m is ref-returned from [35;3mfn[0m [94;1mm_and_c_cant_alias_001[0m

	    [35;3mref arg[0m [94;1mm_and_c_cant_alias_001[0m:[94;1mm[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([94;1mS[0m) at [2m9:12+4[0m

========

        fn ZERO(mut sources: string[], implicit ref output: string) {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                mut idx = 0;
                while ((idx = src.find("X")) > 0) {
                    let sources1 = sources[0 .. i]
                        ~ src.slice(0, idx)
                        ~ src.slice(idx + 1, src.len)
                        ~ sources[i + 1 .. sources.len];

                    ZERO(sources1);
                    src = src[0 .. idx] ~ src[idx + 1 .. src.len];
                }
            }

            output ~= sources.join(",") ~ ";";
        }

        fn ZERO(src: string) {
            return ZERO([ src ]);           ;; ALLOCS 5
        }

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "a,b,c;a,bc;ab,c;abc;" ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 10:34+1[0m:

[2m      |                         ~ src.slice(0, idx)[0m
[2m      |                         ~ src.slice(idx + 1, src.len)[0m
[2m   10 | [0m                        ~ sources[31;1m[[0mi + 1 .. sources.len];
[2m      | [0m
[2m      |                     ZERO(sources1);[0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +[0m:[94;1mb[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1msrc[0m at [2m4:21+3[0m:

[2m      |         fn ZERO(mut sources: string[], implicit ref output: string) {[0m
[2m      |             for (mut i = 0; i < sources.len; i++) {[0m
[2m    4 | [0m                ref [31;1msrc[0m = sources[i];
[2m      |                 mut idx = 0;[0m
[2m      |                 while ((idx = src.find("X")) > 0) {[0m

	Both refer to: [35;3mmut arg[0m [94;1msources[0m at [2m2:21+7[0m:

[2m      | [0m
[2m    2 | [0m        fn ZERO(mut [31;1msources[0m: string[], implicit ref output: string) {
[2m      |             for (mut i = 0; i < sources.len; i++) {[0m
[2m      |                 ref src = sources[i];[0m


RelaxCopyResize [35;3mfn[0m [94;1mZERO[0m([35;3mstring[0m[35;3m[..][0m, [35;3mstring[0m) at [2m2:12+4[0m
                [2m...[0m

========

        struct Empty {};

        fn main() {
            mut e = [ Empty(), Empty() ];
            fn GET(idx: i32) e.len > idx && e[idx];
            return GET(0) == GET(1) ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 5:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1me[0m = [ Empty(), Empty() ];
[2m      |             fn GET(idx: i32) e.len > idx && e[idx];[0m
[2m      |             return GET(0) == GET(1) ? 0 : 1;[0m

	COMPILER BUG:

	CODEGEN FAIL:

	cg: We generate invalid c++ for void[]

========

        struct Module { modid: i32 };
        struct Ephemeral { <alt>broke_when_zst?: i32</alt> };
        struct SolverState { _ephemeral: Ephemeral[] };
        struct Target { modid: i32; globid: i32 };

        fn test(implicit ref module: Module, using ref ss: SolverState, target: Target): Ephemeral {
    <alt>
            fn EPH(shadow target: Target)
                return target.modid == module.modid
                    && _ephemeral[target.globid];

            return EPH(target);
    <alt/>
            using fn EPH(shadow target: Target)
                return target.modid == module.modid
                    && _ephemeral[target.globid];

            return target;
    </alt>
        }

        fn main() {
            implicit mut module = Module(1);
            mut ss = SolverState([ Ephemeral(), Ephemeral(), Ephemeral() ]);
            return test(ss, Target(modid: 1, globid: 2)) == [] ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 19:17+2[0m:

[2m      |         fn main() {[0m
[2m      |             implicit mut module = Module(1);[0m
[2m   19 | [0m            mut [31;1mss[0m = SolverState([ Ephemeral(), Ephemeral(), Ephemeral() ]);
[2m      |             return test(ss, Target(modid: 1, globid: 2)) == [] ? 0 : 1;[0m
[2m      |         }[0m

	COMPILER BUG:

	CODEGEN FAIL:

	cg: We generate invalid c++ for void[]

========

        fn FAIL(implicit fnames: string[], implicit _here: int)
            throw(fnames[_here]);

        fn ensureArgSeq_argsLenMismatch(
            ref overloads: string[], which: int)
        {
            fn strGET(id: string)                   <alt>
                intGET(int(id && id[0]) || FAIL()); <alt/>
                id && intGET(int(id[0]) || FAIL()); </alt>

            fn intGET(target: int) {
                if (target >= overloads.len)
                    throw(overloads ? intGET(0).strGET : "");

                return overloads[target];
            }

            return intGET(which);
        }

        fn main() {
            let implicit _here = 0;
            let implicit fnames = [ "Hello!" ];
            mut overloads = [ "Hello, World!" ];
            return ensureArgSeq_argsLenMismatch(overloads, 0).len - 13;
        }

---- TODO: ----
[2m[0m_0[2m.fu 13:39+6[0m:

[2m      |             fn intGET(target: int) {[0m
[2m      |                 if (target >= overloads.len)[0m
[2m   13 | [0m                    throw(overloads ? [31;1mintGET[0m(0).strGET : "");
[2m      | [0m
[2m      |                 return overloads[target];[0m

	COMPILER BUG:

	Relaxed spec.args.len(2) != original.args.len(4):

		[35;3marg[0m [94;1mtarget[0m, [35;3minjected implicit ref arg[0m [94;1mensureArgSeq_argsLenMismatch:overloads[0m

		[35;3marg[0m [94;1mintGET[0m:[94;1mtarget[0m, [35;3minjected implicit ref arg[0m [94;1mintGET[0m:[94;1mensureArgSeq_argsLenMismatch:overloads[0m, [35;3minjected implicit ref arg[0m [94;1mintGET[0m:[94;1m_here[0m, [35;3minjected implicit ref arg[0m [94;1mintGET[0m:[94;1mfnames[0m

       RelaxMut [35;3mfn[0m [94;1mintGET[0m([35;3mi32[0m, [35;3mstring[0m[35;3m[..][0m) at [2m11:16+6[0m
                [2m...[0m
        Solving [35;3mfn[0m [94;1mensureArgSeq_argsLenMismatch[0m([35;3mstring[0m[35;3m[..][0m, [35;3mi32[0m) at [2m5:12+28[0m

========

        struct Unit { a: string; b: string };

        fn bang(ref str: string)
            str[0 .. str.len] ~= str.starts(with: "H") ? ", " : "!";

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];

                fn  a = u.a;        

                fn  b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            mut units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!"
                && units.map(|u| u.a ~ u.b).join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return u.a;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::vec_range<char> bang_kGbb(/*1:1*/ fu::vec_range_mut<char> str)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((starts_ojop(str, "H"_view) ? ", "_view : "!"_view)), (fu::get_range_mut(str, 0, str.size()) += _0));
}

static const fu::str& b_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    const fu::str* _0;
    return !*(_0 = &(a_kGbb(u))) ? *_0 : u.b;
}

static fu::str& b_MbR9(/*1:1*/ Unit_GNXY& u)
{
    fu::str* _0;
    return !*(_0 = &(a_MbR9(u))) ? *_0 : u.b;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:1*/ fu::vec_range_mut<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*7:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        Unit_GNXY& /*units|static*/ u = units.mutref(i);
        fu::vec_range<char> _0 {};
        fu::str _1 {};
        (_1 = fu::str((!(_0.ptr_reassign(a_kGbb(u))) ? _0 : bang_kGbb(a_MbR9(u)))), aa.push(static_cast<fu::str&&>(_1)));
        fu::vec_range<char> _2 {};
        fu::str _3 {};
        (_3 = fu::str((!(_2.ptr_reassign(b_kGbb(u))) ? _2 : bang_kGbb(b_MbR9(u)))), bb.push(static_cast<fu::str&&>(_3)));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___t1ujMA63jC1
                                #define DEF___t1ujMA63jC1
inline static fu::str _t1uj(/*1:1*/ const Unit_GNXY& u)
{
    return u.a + u.b;
}
                                #endif

                                #ifndef DEF_map_mSFki61wuo2
                                #define DEF_map_mSFki61wuo2
inline fu::vec<fu::str> map_mSFk(/*3:3*/ fu::view<Unit_GNXY> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _t1uj(a[i]);

    return /*NRVO*/ res;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if (((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view) && (join_QbuI(map_mSFk(units)) == "Hello, world!"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_AARMustSeq

========

        struct Unit { a: string; b: string };

        fn bang(ref str: string)
            str[0 .. str.len] ~= str.starts(with: "H") ? ", " : "!";

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];
        <alt>
                ref a = u.a;        <alt/>
                fn  a = u.a;        </alt>
        <alt>
                ref b = a && u.b;   <alt/>
                fn  b = a && u.b;   </alt>

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            mut units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!"
                && units.map(|u| u.a ~ u.b).join() == "Hello, world!" ? 0 : 1;
        }

---- TODO: ----
[2m[0m_0[2m.fu 16:25+1[0m:

[2m      | [0m
[2m      |                 aa.push(a && bang(a));[0m
[2m   16 | [0m                bb.push([31;1mb[0m && bang(b));
[2m      |             }[0m
[2m      |         }[0m

	Cannot access [35;3mmut ref[0m [94;1mb[0m, reference invalidated by write to [35;3mmut ref[0m [94;1mu[0m at [2m15:30+4[0m:

[2m      |                 ref b = a && u.b;   [0m
[2m      | [0m
[2m   15 | [0m                aa.push(a && [31;1mbang[0m(a));
[2m      |                 bb.push(b && bang(b));[0m
[2m      |             }[0m

	At call to [35;3mfn[0m [94;1mbang[0m
            via [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m5:31+2[0m:

[2m      | [0m
[2m      |         fn bang(ref str: string)[0m
[2m    5 | [0m            str[0 .. str.len] [31;1m~=[0m str.starts(with: "H") ? ", " : "!";
[2m      | [0m
[2m      |         fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref aa: string[], ref bb: string[]) {[0m


    BorrowCheck [35;3mfn[0m [94;1mbrokenAssignmentWantsStringGetsSlice[0m([94;1mUnit[0m[35;3m[..][0m, [35;3mstring[0m[35;3m[..][0m, [35;3mstring[0m[35;3m[..][0m) at [2m7:12+36[0m

========

        fn what(arg: int) {
            lax mut prefix = arg & 1        <fail does nothing X:X><pass/>
            return prefix;                  </fail>
        }

        fn main() 0.what;

---- TODO: ----
<fail> does not throw:

        fn what(arg: int) {
            lax mut prefix = arg & 1        
        }

        fn main() 0.what;

========

        fn sum_each(a, b)       // Same as above,
            a.Each + b.Each;    //  but we don't explicitly pass the fn Each in.

        fn hello(x) {
            if (x & 1) {
                fn Each(a) a    ? a * Each(a - 1)   // These get ignored?
                                : 100;              //  sum_each goes and selects the one from _1.

                return sum_each(x, x);
            }
            else {
                fn Each(b) b    ? b * Each(b - 1)
                                : 10000;

                return sum_each(x, x);
            }
        }

        fn Each(c) c & 1    ? c
                            : c / 2 + Each(c / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_1.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

inline static int Each_TIY5(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_TIY5iY6OPd3
                                #define DEF_Each_TIY5iY6OPd3
inline static int Each_TIY5(const int c)
{
    if (c & 1)
        return c;
    else
        return (c / 2) + Each_TIY5((c / 2));

}
                                #endif

                                #ifndef DEF_sum_each_Llp5OxovDe7
                                #define DEF_sum_each_Llp5OxovDe7
inline int sum_each_Llp5(const int a, const int b)
{
    return Each_TIY5(a) + Each_TIY5(b);
}
                                #endif

                                #ifndef DEF_hello_ZK4b1kNXJ4c
                                #define DEF_hello_ZK4b1kNXJ4c
inline int hello_ZK4b(const int x)
{
    if (x & 1)
        return sum_each_Llp5(x, x);
    else
        return sum_each_Llp5(x, x);

}
                                #endif

int fu_MAIN()
{
    return ((hello_ZK4b(1) - (2 * Each_TIY5(100))) + hello_ZK4b(2)) - (2 * Each_TIY5(20000));
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

   EXIT code: 254
========

        fn apply(num: i32, func: fn (i32): i32) = func(num);
        fn main()                               = apply([1], |i| i - 1);

---- TODO: ----
[0m_0[2m.fu 2:42+1[0m:

[2m      | [0m
[2m    2 | [0m        fn apply(num: i32, func: fn (i32)[31;1m:[0m i32) = func(num);
[2m      |         fn main()                               = apply([1], |i| i - 1);[0m
[2m      | [0m

	Expected [35;3mop[0m [94;1m,[0m
	     got [35;3mop[0m [94;1m:[0m

========

        enum Test { A; B = A; C; };
        fn main() Test.C.i32 - 1;

---- TODO: ----
[2m[0m_0[2m.fu 2:28+1[0m:

[2m      | [0m
[2m    2 | [0m        enum Test { A; B = [31;1mA[0m; C; };
[2m      |         fn main() Test.C.i32 - 1;[0m
[2m      | [0m

	Bad call to [94;1mA[0m: [94;1mA[0m is not defined here.

        Solving [35;3mtype[0m [94;1mTest[0m

========

        enum FaceCull { Disabled = 0; CullCW; CullCCW }
        pub fn updateFaceCull(v: FaceCull) v.int;

        fn test(v: int) _0::updateFaceCull(
            v == 1 ? "CullCW"   : v == 2    ? "CullCCW"
                                            : "Disable"); //< should be "Disabled"
        fn main() 0.test;                                 //   gotta suggest a fix

---- TODO: ----
[2m[0m_1[2m.fu 2:29+14[0m:

[2m      | [0m
[2m    2 | [0m        fn test(v: int) _0::[31;1mupdateFaceCull[0m(
[2m      |             v == 1 ? "CullCW"   : v == 2    ? "CullCCW"[0m
[2m      |                                             : "Disable"); //< should be "Disabled"[0m

	Bad call to [94;1mupdateFaceCull[0m with args ([35;3mstring[0m): 

	[35;3mfn[0m [94;1mupdateFaceCull[0m at [2m[0m_0[2m.fu 3:16+14[0m:
[2m    3 | [0m        pub fn [31;1mupdateFaceCull[0m(v: FaceCull) v.int;

	    [35;3marg[0m [94;1mupdateFaceCull[0m:[94;1mv[0m expects [35;3menum[0m [94;1mFaceCull[0m, got [35;3mstring[0m

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        enum Token { KEY_X }

        fn update(ref state: int, tokens: Token[])
            if (tokens.has("KEY_X"))
                state++;

        fn main() {
            mut state = -1;
            state.update([ Token.KEY_X ]);
            return state;
        }

---- TODO: ----
[2m[0m_0[2m.fu 5:24+3[0m:

[2m      | [0m
[2m      |         fn update(ref state: int, tokens: Token[])[0m
[2m    5 | [0m            if (tokens.[31;1mhas[0m("KEY_X"))
[2m      |                 state++;[0m
[2m      | [0m

	Bad call to [94;1mhas[0m with args ([35;3menum[0m [94;1mToken[0m[35;3m[][0m, [35;3mstring[0m): 

	[35;3mtemplate[0m [94;1mhas[0m at [2m../../../../../[0mprelude[2m 319:4+3[0m:
[2m  319 | [0mfn [31;1mhas[0m(a: <T>[..], b: T[..] or T) = a.find(b) >= 0;

	    [35;3marg[0m [94;1mhas[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mToken[0m -> [35;3mbyte[0m
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mToken[0m <-> [35;3mstring[0m

        Solving [35;3mfn[0m [94;1mupdate[0m([35;3mi32[0m, [94;1mToken[0m[35;3m[..][0m) at [2m4:12+6[0m

========

        inline fn add(ref a: i32, ref b: i32) a + b;
        fn main() = add(1, 2) - 3;

---- TODO: ----
[2m[0m_0[2m.fu 3:21+3[0m:

[2m      | [0m
[2m      |         inline fn add(ref a: i32, ref b: i32) a + b;[0m
[2m    3 | [0m        fn main() = [31;1madd[0m(1, 2) - 3;
[2m      | [0m

	Bad call to [94;1madd[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3minline[0m [94;1madd[0m at [2m2:19+3[0m:
[2m    2 | [0m        inline fn [31;1madd[0m(ref a: i32, ref b: i32) a + b;

	    [35;3mref arg[0m [94;1madd[0m:[94;1ma[0m expects a mutref, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        noinline fn add(ref a: i32, ref b: i32) a || b;
        fn main() = add(1, 2) - 1;

---- TODO: ----
[2m[0m_0[2m.fu 3:21+3[0m:

[2m      | [0m
[2m      |         noinline fn add(ref a: i32, ref b: i32) a || b;[0m
[2m    3 | [0m        fn main() = [31;1madd[0m(1, 2) - 1;
[2m      | [0m

	Bad call to [94;1madd[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mfn[0m [94;1madd[0m at [2m2:21+3[0m:
[2m    2 | [0m        noinline fn [31;1madd[0m(ref a: i32, ref b: i32) a || b;

	    [35;3mref arg[0m [94;1madd[0m:[94;1ma[0m expects a mutref, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        noinline fn at(ref a: i32[], i: i32) a[i];
        fn main() = [ 1 ].at(0) - 1;

---- TODO: ----
[2m[0m_0[2m.fu 3:27+2[0m:

[2m      | [0m
[2m      |         noinline fn at(ref a: i32[], i: i32) a[i];[0m
[2m    3 | [0m        fn main() = [ 1 ].[31;1mat[0m(0) - 1;
[2m      | [0m

	Bad call to [94;1mat[0m with args ([35;3mi32[0m[35;3m[][0m, [35;3mi32[0m): 

	[35;3mfn[0m [94;1mat[0m at [2m2:21+2[0m:
[2m    2 | [0m        noinline fn [31;1mat[0m(ref a: i32[], i: i32) a[i];

	    [35;3mref arg[0m [94;1mat[0m:[94;1ma[0m expects a mutref, got [35;3mi32[0m[35;3m[][0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn licm_hoist_var(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++) {
                let must_hoist = pretend_pure(n);
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_hoist_var(2) == 204 ? 0 : 1;

---- TODO: ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>


#ifndef fu_NO_fdefs

static int pretend_pure_MbR9(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int licm_hoist_var_MbR9(const int n)
{
    int res = 0;
    for (int i = 0; i < n; i++)
    {
        const int must_hoist = pretend_pure_MbR9(n);
        res += must_hoist;
    };
    return res;
}

int fu_MAIN()
{
    if (licm_hoist_var_MbR9(2) == 204)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 1
========


        fn main(): i32 {}               

---- <fail> ----
[2m[0m_0[2m.fu 3:12+4[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mmain[0m(): i32 {}               
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========


        fn main(): i32 { return 0; }    

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========


        fn test(): i32 {}               
        fn main() test();

---- <fail> ----
[2m[0m_0[2m.fu 3:12+4[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mtest[0m(): i32 {}               
[2m      |         fn main() test();[0m
[2m      | [0m

	[35;3mfn[0m [94;1mtest[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mtest[0m at [2m3:12+4[0m

========


        fn test(): i32 { return 0; }    
        fn main() test();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

========

        return 1 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 1 - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        return 
                        3 

---- <fail> ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

[36m  STAT: UNIQ Total Bytes	m_cnt: 0[0m
[36m  STAT: UNIQ Total Count	m_cnt: 0[0m
[36m  STAT: ARC  Total Bytes	m_cnt: 0[0m
[36m  STAT: ARC  Total Count	m_cnt: 0[0m

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 3;
}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 3
========

        return 
                        0 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        return 0

            || throw("TESTERR")


---- <fail> ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

libc++abi: terminating due to uncaught exception of type std::runtime_error: TESTERR

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int _0;
    return (_0 = 0) ? _0 : fu::fail(fu::str("TESTERR"_fu));
}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 6
========

        return 0

            || throw("TESTERR")


---- <fail> ----
COMPILER BUG or INCORRECT TESTCASE:

fulib runtime
_0.fu

libc++abi: terminating due to uncaught exception of type std::runtime_error: TESTERR

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] fu::never fu_MAIN()
{
    fu::fail(fu::str("TESTERR"_fu));
}

#endif

int main() { return fu_MAIN(); }

   EXIT code: 6
========

        return 0


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sum_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return sum_MbR9(1, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sum_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return sum_MbR9(1, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sign_MbR9(const int a)
{
    if (a > 0)
        return 1;
    else if (a < 0)
        return -1;
    else
        return 0;

}

int fu_MAIN()
{
    return (sign_MbR9(7) + sign_MbR9(-3)) + sign_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sign_MbR9(const int a)
{
    if (a > 0)
        return 1;
    else
        return -2;

}

int fu_MAIN()
{
    return (sign_MbR9(10) * 2) + sign_MbR9(-5);
}

#endif

int main() { return fu_MAIN(); }

========

        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sign_MbR9(const int a)
{
    if (a > 0)
        return 1;
    else
        return -2;

}

int fu_MAIN()
{
    return (sign_MbR9(10) * 2) + sign_MbR9(-5);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn main() {
            let  i = -1;
            let sb = i.i8;
            let  b = i.u8;

            return sb == -1 && b == 255 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int i = -1;
    const fu::i8 sb = fu::i8(i);
    const fu::u8 b = fu::u8(unsigned(i));
    if ((sb == fu::i8(-1)) && (b == fu::u8(255u)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let sb = (-1).i8;
            let  i =  sb.i32;
            let  u =  sb.u32;

            return i == -1 && u.i32 == 255 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 sb = fu::i8(-1);
    const int i = int(sb);
    const unsigned u = unsigned(fu::u8(sb));
    if ((i == -1) && (int(u) == 255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let b = byte(200);
            let i = b.i32;
            return i == 200 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char b = char(200);
    const int i = int(fu::u8(b));
    if (i == 200)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        mut arr = [ 0 ];
        return arr[0];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0 }};
    return arr[0];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let a = 3;
        mut b = a;
        b++;
        return b - (a + 1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 3;
    int b = a;
    b++;
    return b - (a + 1);
}

#endif

int main() { return fu_MAIN(); }

========

        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int i = 0; i < 10; i++)
        sum++;

    return (sum * 2) - 20;
}

#endif

int main() { return fu_MAIN(); }

========

        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int i = 10; i-- > 0; )
        sum--;

    return (sum * 2) + 20;
}

#endif

int main() { return fu_MAIN(); }

========

        fn decr(ref num: i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int decr_MbR9(/*1:1*/ int& num)
{
    return num--;
}

int fu_MAIN()
{
    int res = 0;
    decr_MbR9(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int decr_MbR9(/*1:1*/ int& res)
{
    return res--;
}

int fu_MAIN()
{
    int res = 0;
    decr_MbR9(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        mut res = 0;
        fn decr(ref num: i32) { num--; } // ret void

        decr(res);
        return res + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void decr_MbR9(/*1:1*/ int& num)
{
    num--;
}

int fu_MAIN()
{
    int res = 0;
    decr_MbR9(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum++;

    return sum - 15;
}

#endif

int main() { return fu_MAIN(); }

========


        let sum = 0;        
        while (sum < 15)
            sum++;

        return sum - 15;

---- <fail> ----
[2m[0m_0[2m.fu 8:16+2[0m:

[2m      |         let sum = 0;        [0m
[2m      |         while (sum < 15)[0m
[2m    8 | [0m            sum[31;1m++[0m;
[2m      | [0m
[2m      |         return sum - 15;[0m

	Bad call to [94;1mpostfix++[0m with args ([35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mpostfix++[0m at [2m../../../../../[0mprelude[2m 21:12+2[0m:
[2m   21 | [0mpostfix fn [31;1m++[0m (mut ref a: <T>) case (T.is::arithmetic): T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mlet[0m [94;1msum[0m at [2m6:13+3[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m        let [31;1msum[0m = 0;        
[2m      |         while (sum < 15)[0m
[2m      |             sum++;[0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========


        let sum = 0;        
        while (sum < 15)
            sum++;

        return sum - 15;

---- <fail> ----
[2m[0m_0[2m.fu 8:16+2[0m:

[2m      |         let sum = 0;        [0m
[2m      |         while (sum < 15)[0m
[2m    8 | [0m            sum[31;1m++[0m;
[2m      | [0m
[2m      |         return sum - 15;[0m

	Bad call to [94;1mpostfix++[0m with args ([35;3malways-false[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mpostfix++[0m at [2m../../../../../[0mprelude[2m 21:12+2[0m:
[2m   21 | [0mpostfix fn [31;1m++[0m (mut ref a: <T>) case (T.is::arithmetic): T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mlet[0m [94;1msum[0m at [2m6:13+3[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m        let [31;1msum[0m = 0;        
[2m      |         while (sum < 15)[0m
[2m      |             sum++;[0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========


        mut sum = 0;        
        while (sum < 15)
            sum++;

        return sum - 15;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum++;

    return sum - 15;
}

#endif

int main() { return fu_MAIN(); }

========

        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum += 2;

    return sum - 16;
}

#endif

int main() { return fu_MAIN(); }

========

        mut i = 5;
        mut sum = 0;
        while (let x = i--) sum += x - i;
        return sum - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 5;
    int sum = 0;
    int x;
    while ((x = i--))
        sum += (x - i);

    return sum - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int named_MbR9(const int a, const int b)
{
    return a - (b * 2);
}

int fu_MAIN()
{
    return named_MbR9(6, 3);
}

#endif

int main() { return fu_MAIN(); }

========

        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int named_MbR9(const int a, const int b)
{
    return a - (b * 2);
}

static int other_MbR9(const int a, const int b)
{
    return named_MbR9(a, b);
}

int fu_MAIN()
{
    return other_MbR9(6, 3);
}

#endif

int main() { return fu_MAIN(); }

========

        fn ret_only_arg(a) a;

        fn main() 0.ret_only_arg;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ret_only_arg_0DCJaE9X1mk
                                #define DEF_ret_only_arg_0DCJaE9X1mk
inline static int ret_only_arg_0DCJ(/*1:1*/ const int a)
{
    return a;
}
                                #endif

int fu_MAIN()
{
    return ret_only_arg_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn ret_only_arg(a) a;
        pub import _0;
        fn main() 0.ret_only_arg;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ret_only_arg_0DCJaE9X1mk
                                #define DEF_ret_only_arg_0DCJaE9X1mk
inline int ret_only_arg_0DCJ(/*1:1*/ const int a)
{
    return a;
}
                                #endif

int fu_MAIN()
{
    return ret_only_arg_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_JmCx;

                                #ifndef DEF_Range_JmCxkAzKfoh
                                #define DEF_Range_JmCxkAzKfoh
struct Range_JmCx
{
                                // shape_hash:    19317a06635e09ac
                                // non_triv_mask: 0000000000000000
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return r.max - r.min;
}

int fu_MAIN()
{
    return size_MbR9(Range_JmCx { 14, 21 }) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_JmCx;

                                #ifndef DEF_Range_JmCxkAzKfoh
                                #define DEF_Range_JmCxkAzKfoh
struct Range_JmCx
{
                                // shape_hash:    19317a06635e09ac
                                // non_triv_mask: 0000000000000000
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Range_JmCx r = Range_JmCx { 1, 2 };
    r.min++;
    return r.max - r.min;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range {
            min: i32;
            max: i32;
        }


        let r =             
            Range(1, 2);

        r.min++;
        return r.max - r.min;

---- <fail> ----
[2m[0m_0[2m.fu 14:14+2[0m:

[2m      |             Range(1, 2);[0m
[2m      | [0m
[2m   14 | [0m        r.min[31;1m++[0m;
[2m      |         return r.max - r.min;[0m
[2m      | [0m

	Bad call to [94;1mpostfix++[0m with args ([35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mpostfix++[0m at [2m../../../../../[0mprelude[2m 21:12+2[0m:
[2m   21 | [0mpostfix fn [31;1m++[0m (mut ref a: <T>) case (T.is::arithmetic): T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mlet[0m [94;1mr[0m at [2m11:13+1[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m        let [31;1mr[0m =             
[2m      |             Range(1, 2);[0m
[2m      | [0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Range {
            min: i32;
            max: i32;
        }


        mut r =             
            Range(1, 2);

        r.min++;
        return r.max - r.min;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_JmCx;

                                #ifndef DEF_Range_JmCxkAzKfoh
                                #define DEF_Range_JmCxkAzKfoh
struct Range_JmCx
{
                                // shape_hash:    19317a06635e09ac
                                // non_triv_mask: 0000000000000000
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Range_JmCx r = Range_JmCx { 1, 2 };
    r.min++;
    return r.max - r.min;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range {
            r_min: i32;
            r_max: i32;
        }

        fn size(using r: Range)
            r_max - r_min;

        return size(Range(14, 21)) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_u5g2;

                                #ifndef DEF_Range_u5g2p5D7IR5
                                #define DEF_Range_u5g2p5D7IR5
struct Range_u5g2
{
                                // shape_hash:    4b035d984b024544
                                // non_triv_mask: 0000000000000000
    int r_min;
    int r_max;
    explicit operator bool() const noexcept
    {
        return false
            || r_min
            || r_max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_MbR9(/*1:1*/ const Range_u5g2& r)
{
    return r.r_max - r.r_min;
}

int fu_MAIN()
{
    return size_MbR9(Range_u5g2 { 14, 21 }) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        struct X {
            a: i32;
        }

        fn test(using x: X, b: i32) a + b;
        fn hey(using x: X) test(-1);

        return X(1).hey;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_ZXez;

                                #ifndef DEF_X_ZXezvyPDUYa
                                #define DEF_X_ZXezvyPDUYa
struct X_ZXez
{
                                // shape_hash:    797b10c98c17bef7
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:3*/ const X_ZXez& x, const int b)
{
    return x.a + b;
}

static int hey_MbR9(/*1:1*/ const X_ZXez& x)
{
    return test_MbR9(x, -1);
}

int fu_MAIN()
{
    return hey_MbR9(X_ZXez { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Player_f9FI;
struct Pos_96bz;

                                #ifndef DEF_Pos_96bzIPMixwk
                                #define DEF_Pos_96bzIPMixwk
struct Pos_96bz
{
                                // shape_hash:    1fa93f363e0a01fe
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Player_f9FIasxqgj7
                                #define DEF_Player_f9FIasxqgj7
struct Player_f9FI
{
                                // shape_hash:    1ea3f5e01dc07255
                                // non_triv_mask: 0000000000000000
    Pos_96bz pos;
    explicit operator bool() const noexcept
    {
        return false
            || pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int dist_MbR9(/*3:3*/ const Player_f9FI& p, /*3:3*/ const Player_f9FI& other)
{
    return p.pos.x - other.pos.x;
}

int fu_MAIN()
{
    const Player_f9FI a = Player_f9FI { Pos_96bz { 10 } };
    const Player_f9FI b = Player_f9FI { Pos_96bz { 4 } };
    return dist_MbR9(a, b) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using left: A, using right: B)

            x + z; 

        fn main() test(A(1, 1), B(-1, -1));

---- <fail> ----
[2m[0m_0[2m.fu 6:13+1[0m:

[2m      |         fn test(using left: A, using right: B)[0m
[2m      | [0m
[2m    6 | [0m            [31;1mx[0m + z; 
[2m      | [0m
[2m      |         fn main() test(A(1, 1), B(-1, -1));[0m

	Ambiguous call to [94;1mx[0m, matches multiple items in scope:

	[35;3mfield[0m [94;1mB[0m:[94;1mx[0m at [2m3:20+1[0m:
[2m    3 | [0m        struct B { [31;1mx[0m: i32; z: i32; };

	    [35;3musing[0m [35;3marg[0m [94;1mright[0m at [2m4:32+5[0m [2m4:38+5[0m:
[2m    4 | [0m        fn test(using left: A, [31;1musing[0m [31;1mright[0m: B)

	[35;3mfield[0m [94;1mA[0m:[94;1mx[0m at [2m2:20+1[0m:
[2m    2 | [0m        struct A { [31;1mx[0m: i32; y: i32; };

	    [35;3musing[0m [35;3marg[0m [94;1mleft[0m at [2m4:17+5[0m [2m4:23+4[0m:
[2m    4 | [0m        fn test([31;1musing[0m [31;1mleft[0m: A, using right: B)


        Solving [35;3mfn[0m [94;1mtest[0m([94;1mA[0m, [94;1mB[0m) at [2m4:12+4[0m

========

        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using left: A, using right: B)

            y + z; 

        fn main() test(A(1, 1), B(-1, -1));

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_zTle;
struct B_NSoi;

                                #ifndef DEF_A_zTlezRiA1U8
                                #define DEF_A_zTlezRiA1U8
struct A_zTle
{
                                // shape_hash:    96db99a4858c4b76
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_B_NSoivOjxmgh
                                #define DEF_B_NSoivOjxmgh
struct B_NSoi
{
                                // shape_hash:    505610edb896519c
                                // non_triv_mask: 0000000000000000
    int x;
    int z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:3*/ const A_zTle& left, /*3:3*/ const B_NSoi& right)
{
    return left.y + right.z;
}

int fu_MAIN()
{
    return test_MbR9(A_zTle { {/*unused non-zst*/}, 1 }, B_NSoi { {/*unused non-zst*/}, -1 });
}

#endif

int main() { return fu_MAIN(); }

========

        struct CurrentFn {
            parent_idx: i32;
            using RoR?: CurrentFn_ResetOnResolve; // not yet populated
        };

        struct CurrentFn_ResetOnResolve {
            ret_count: i32;
        };

        fn test(f: CurrentFn) f.parent_idx - f.ret_count;
        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct CurrentFn_ResetOnResolve_rci0;
struct CurrentFn_cZgb;

                                #ifndef DEF_CurrentFn_ResetOnResolve_rci09LtICOc
                                #define DEF_CurrentFn_ResetOnResolve_rci09LtICOc
struct CurrentFn_ResetOnResolve_rci0
{
                                // shape_hash:    b332e97a0df28459
                                // non_triv_mask: 0000000000000000
    int ret_count;
    explicit operator bool() const noexcept
    {
        return false
            || ret_count
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_cZgboItexP2
                                #define DEF_CurrentFn_cZgboItexP2
struct CurrentFn_cZgb
{
                                // shape_hash:    afed250697f1af02
                                // non_triv_mask: 0000000000000000
    int parent_idx;
    CurrentFn_ResetOnResolve_rci0 RoR;
    explicit operator bool() const noexcept
    {
        return false
            || parent_idx
            || RoR
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const CurrentFn_cZgb& f)
{
    return f.parent_idx - f.RoR.ret_count;
}

int fu_MAIN()
{
    return test_MbR9(CurrentFn_cZgb { 1, CurrentFn_ResetOnResolve_rci0 { 1 } });
}

#endif

int main() { return fu_MAIN(); }

========

        struct HasPredicate {
            true kind   : string;
            items       : i32;
        };

        fn main() {
            let isTrue  = HasPredicate("let", 0);
            let isFalse = HasPredicate("",    1);
            return isTrue && !isFalse ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>

struct HasPredicate_emrR;

                                #ifndef DEF_HasPredicate_emrRWGXm2D8
                                #define DEF_HasPredicate_emrRWGXm2D8
struct HasPredicate_emrR
{
                                // shape_hash:    646fdc99fbdc3846
                                // non_triv_mask: 0400800000000000
    fu::str kind;
    int items;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    HasPredicate_emrR isTrue = HasPredicate_emrR { fu::str("let"_fu), 0 };
    HasPredicate_emrR isFalse = HasPredicate_emrR { fu::str(""_fu), 1 };
    if (isTrue && !isFalse)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct HasPredicate {
            true kind   : string;
            items       : i32;
        };

        fn main() {
            let isTrue  = HasPredicate("let", 0);
            let isFalse = HasPredicate("",    1);
            return isTrue && !isFalse ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>

struct HasPredicate_emrR;

                                #ifndef DEF_HasPredicate_emrRWGXm2D8
                                #define DEF_HasPredicate_emrRWGXm2D8
struct HasPredicate_emrR
{
                                // shape_hash:    646fdc99fbdc3846
                                // non_triv_mask: 0400800000000000
    fu::str kind;
    int items;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    HasPredicate_emrR isTrue = HasPredicate_emrR { fu::str("let"_fu), 0 };
    HasPredicate_emrR isFalse = HasPredicate_emrR { fu::str{}, 1 };
    if (isTrue && !isFalse)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Stuff { name: string };

        fn shadowsStructMember(using stuff: Stuff, other: string) {
            shadow let name = other || name;
            return name;
        }

        fn main() = shadowsStructMember(Stuff("a"), "bb").len - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Stuff_YimI;

                                #ifndef DEF_Stuff_YimIaqkUQQ1
                                #define DEF_Stuff_YimIaqkUQQ1
struct Stuff_YimI
{
                                // shape_hash:    0ff7c840a10b3951
                                // non_triv_mask: 0000800000001000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> shadowsStructMember_kGbb(/*3:3*/ const Stuff_YimI& stuff, /*3:3*/ fu::view<char> other)
{
    fu::view<char> /*stuff|other*/ name = (other ? other : stuff.name);
    return name;
}

int fu_MAIN()
{
    return shadowsStructMember_kGbb(Stuff_YimI { fu::str("a"_fu) }, "bb"_view).size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn call_with_using_and_explicit_arg(x: i32, y: i32) = x + 7*y;
        fn main () {
            using let y = 1;
            return call_with_using_and_explicit_arg(x: 2) - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int call_with_using_and_explicit_arg_MbR9(const int x, const int y)
{
    return x + (7 * y);
}

int fu_MAIN()
{
    const int y = 1;
    return call_with_using_and_explicit_arg_MbR9(2, y) - 9;
}

#endif

int main() { return fu_MAIN(); }

========

        fn call_with_using_explicit_and_trailing(x: i32, y: i32, m: i32) = (x + 7*y) * m;
        fn main () {
            using let x = 1;
            return call_with_using_explicit_and_trailing(y: 2, 3) - 45;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int call_with_using_explicit_and_trailing_MbR9(const int x, const int y, const int m)
{
    return (x + (7 * y)) * m;
}

int fu_MAIN()
{
    const int x = 1;
    return call_with_using_explicit_and_trailing_MbR9(x, 2, 3) - 45;
}

#endif

int main() { return fu_MAIN(); }

========


        trivial
        struct Node { items: Node[]; };

        fn main() {
            mut n: Node;
            return n.items.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+5[0m:

[2m      | [0m
[2m      |         trivial[0m
[2m    4 | [0m        struct Node { [31;1mitems[0m: Node[]; };
[2m      | [0m
[2m      |         fn main() {[0m

	Struct is not [35;3mtrivial[0m because of non-trivial member [94;1mitems[0m

        Solving [35;3mtype[0m [94;1mNode[0m

========


        struct Node { items: Node[]; };

        fn main() {
            mut n: Node;
            return n.items.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Node_zYlo;

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Node_zYlo n {};
    return n.items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct Other { using w: Node };

        struct Node {

            v: Other;          
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 2:30+1[0m:

[2m      | [0m
[2m    2 | [0m        struct Other { using [31;1mw[0m: Node };
[2m      | [0m
[2m      |         struct Node {[0m

	Type [31;1mOther[0m is self-recursive:

		via [35;3mfield[0m [94;1mNode[0m:[94;1mv[0m at [2m6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Other;          
[2m      |         };[0m
[2m      | [0m


        Solving [35;3mtype[0m [94;1mOther[0m

========

        struct Other { using w: Node };

        struct Node {

            v: Node;           
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Node;           
[2m      |         };[0m
[2m      | [0m

	Type [31;1mNode[0m is self-recursive:

		via [35;3mfield[0m [94;1mNode[0m:[94;1mv[0m at [2m6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Node;           
[2m      |         };[0m
[2m      | [0m


        Solving [35;3mtype[0m [94;1mNode[0m
                [35;3mtype[0m [94;1mOther[0m

========

        struct Other { using w: Node };

        struct Node {

            v: i32;            
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Node_0h15;

                                #ifndef DEF_Node_0h15beqscl8
                                #define DEF_Node_0h15beqscl8
struct Node_0h15
{
                                // shape_hash:    a6b1e470da2f9216
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Node_0h15 node {};
    if (node.v)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn sqr(implicit ref b: i32) {
            return b *= b;
        }

        fn main() {
            struct Hey {
                implicit a: i32;
                implicit b: i32;
            };

            using mut hey = Hey(10, 20);
            sqr();
            return hey.a == 10 && hey.b == 400 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_fP8k;

                                #ifndef DEF_Hey_fP8kjX4G6P3
                                #define DEF_Hey_fP8kjX4G6P3
struct Hey_fP8k
{
                                // shape_hash:    9b5b9bb90905b8c2
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int sqr_GL0m(/*1:1*/ int& b)
{
    return (b *= b);
}

int fu_MAIN()
{
    Hey_fP8k hey = Hey_fP8k { 10, 20 };
    sqr_GL0m(hey.b);
    if ((hey.a == 10) && (hey.b == 400))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn sqr(implicit ref b: i32) {
            return b *= b;
        }
        pub import _0;
        fn main() {
            struct Hey {
                implicit a: i32;
                implicit b: i32;
            };

            using mut hey = Hey(10, 20);
            sqr();
            return hey.a == 10 && hey.b == 400 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_fP8k;
int& sqr_MbR9(int&);

                                #ifndef DEF_Hey_fP8kjX4G6P3
                                #define DEF_Hey_fP8kjX4G6P3
struct Hey_fP8k
{
                                // shape_hash:    9b5b9bb90905b8c2
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_fP8k hey = Hey_fP8k { 10, 20 };
    sqr_MbR9(hey.b);
    if ((hey.a == 10) && (hey.b == 400))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int& sqr_MbR9(/*1:1*/ int& b)
{
    return (b *= b);
}

#endif

========

        extern struct hello { v: int }
        fn what(h: hello) h.v;
        fn main() {
            mut s: hello;
            pragma emit(s, " = hello { 10 };");
            return s.v - 10
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct hello;

                                #ifndef DEF_hello_TwIgStSGy2l
                                #define DEF_hello_TwIgStSGy2l
struct hello
{
                                // shape_hash:    76a855343b1b415f
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    hello s {};
    s = hello { 10 };

    return s.v - 10;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32) {

            mut y: x;                   
            y += x;
            return y;
        }

        fn main() test(2) - 4;

---- <fail> ----
[2m[0m_0[2m.fu 4:20+1[0m:

[2m      |         fn test(x: i32) {[0m
[2m      | [0m
[2m    4 | [0m            mut y: [31;1mx[0m;                   
[2m      |             y += x;[0m
[2m      |             return y;[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(x: i32) {

            mut y = x;                  
            y += x;
            return y;
        }

        fn main() test(2) - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    int y = x;
    y += x;
    return y;
}

int fu_MAIN()
{
    return test_MbR9(2) - 4;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hey { v: i32 }

        fn test(x: Hey) {

            mut y: Hey(1);              
            y.v += x.v;
            return y;
        }

        fn main() test(Hey(2)).v - 3;

---- <fail> ----
[2m[0m_0[2m.fu 6:20+3[0m:

[2m      |         fn test(x: Hey) {[0m
[2m      | [0m
[2m    6 | [0m            mut y: [31;1mHey[0m(1);              
[2m      |             y.v += x.v;[0m
[2m      |             return y;[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mfn[0m [94;1mtest[0m([94;1mHey[0m) at [2m4:12+4[0m

========

        struct Hey { v: i32 }

        fn test(x: Hey) {

            mut y = Hey(1);             
            y.v += x.v;
            return y;
        }

        fn main() test(Hey(2)).v - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_18Sg;

                                #ifndef DEF_Hey_18SgkdJlEPl
                                #define DEF_Hey_18SgkdJlEPl
struct Hey_18Sg
{
                                // shape_hash:    9a65e31b3f8ad4ef
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Hey_18Sg test_MbR9(/*1:1*/ const Hey_18Sg& x)
{
    Hey_18Sg y = Hey_18Sg { 1 };
    y.v += x.v;
    return y;
}

int fu_MAIN()
{
    return test_MbR9(Hey_18Sg { 2 }).v - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        type A = int;   
        type A = int;   

        fn main() {
            mut a: A;
            return a;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:20+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    6 | [0m            mut a: [31;1mA[0m;
[2m      |             return a;[0m
[2m      |         }[0m

	Ambiguous call to [94;1mA[0m, matches multiple items in scope:

	[35;3mtype[0m [94;1mA[0m at [2m3:14+1[0m:
[2m    3 | [0m        type [31;1mA[0m = int;   

	[35;3mtype[0m [94;1mA[0m at [2m2:14+1[0m:
[2m    2 | [0m        type [31;1mA[0m = int;   


        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        type A = int;   

        fn main() {
            mut a: A;
            return a;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a {};
    return a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Int { i: int };

        type A = Int;   
        type A = Int;   

        fn main() {
            mut a: A;
            return a.i;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:20+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    8 | [0m            mut a: [31;1mA[0m;
[2m      |             return a.i;[0m
[2m      |         }[0m

	Ambiguous call to [94;1mA[0m, matches multiple items in scope:

	[35;3mtype[0m [94;1mInt[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Int { i: int };

	    ... via [2m5:14+1[0m:
[2m    5 | [0m        type [31;1mA[0m = Int;   

	[35;3mtype[0m [94;1mInt[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Int { i: int };

	    ... via [2m4:14+1[0m:
[2m    4 | [0m        type [31;1mA[0m = Int;   


        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        struct Int { i: int };

        type A = Int;   

        fn main() {
            mut a: A;
            return a.i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Int_2lV0;

                                #ifndef DEF_Int_2lV0557aSvi
                                #define DEF_Int_2lV0557aSvi
struct Int_2lV0
{
                                // shape_hash:    c65205995b225a7d
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Int_2lV0 a {};
    return a.i;
}

#endif

int main() { return fu_MAIN(); }

========

        let x = 3;
        return x / 2 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 3;
    return (x / 2) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn hey(a) a * a;
        fn main = 0.hey;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hey_87TBE9BWG51
                                #define DEF_hey_87TBE9BWG51
inline static int hey_87TB(const int a)
{
    return a * a;
}
                                #endif

int fu_MAIN()
{
    return hey_87TB(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn div3by(a: <T>) 3 / a;
        return div3by(2) - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_div3by_5UDcD28hcx2
                                #define DEF_div3by_5UDcD28hcx2
inline static int div3by_5UDc(const int a)
{
    return 3 / a;
}
                                #endif

int fu_MAIN()
{
    return div3by_5UDc(2) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn div3by(a) 3 / a;
        return div3by(2) - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_div3by_5UDcD28hcx2
                                #define DEF_div3by_5UDcD28hcx2
inline static int div3by_5UDc(const int a)
{
    return 3 / a;
}
                                #endif

int fu_MAIN()
{
    return div3by_5UDc(2) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn add3(a: i32, b = 3) a + b;
        fn main() add3(-3);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int add3_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return add3_MbR9(-3, 3);
}

#endif

int main() { return fu_MAIN(); }

========

        fn add3(a: <T>, b = 3) a + b;
        struct v1 { x: i32; };
        fn +(a: v1, b: i32) v1(a.x + b);
        fn main() add3(2.v1).x - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct v1_klcy;

                                #ifndef DEF_v1_klcyFFp4Cul
                                #define DEF_v1_klcyFFp4Cul
struct v1_klcy
{
                                // shape_hash:    af99f5ea14ee95af
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static v1_klcy operator+(/*3:3*/ const v1_klcy& a, const int b)
{
    return v1_klcy { (a.x + b) };
}

                                #ifndef DEF_add3_APrW6zz6UOc
                                #define DEF_add3_APrW6zz6UOc
inline static v1_klcy add3_APrW(/*3:3*/ const v1_klcy& a, const int b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return add3_APrW(v1_klcy { 2 }, 3).x - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn mul_ab_init(a: <T>, b = 0) a*b;
        fn main() mul_ab_init(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_mul_ab_init_gpoKlAwttR1
                                #define DEF_mul_ab_init_gpoKlAwttR1
inline static int mul_ab_init_gpoK(const int a, const int b)
{
    return a * b;
}
                                #endif

int fu_MAIN()
{
    return mul_ab_init_gpoK(1, 0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn mul_ab_annot_init(a: <T>, b: T = 0) a*b;
        fn main() mul_ab_annot_init(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_mul_ab_annot_init_gpoKlAwttR1
                                #define DEF_mul_ab_annot_init_gpoKlAwttR1
inline static int mul_ab_annot_init_gpoK(const int a, const int b)
{
    return a * b;
}
                                #endif

int fu_MAIN()
{
    return mul_ab_annot_init_gpoK(1, 0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn mul_ab_opt(a: $T, b?: $T) a*b;
        fn main() mul_ab_opt(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_mul_ab_opt_gpoKlAwttR1
                                #define DEF_mul_ab_opt_gpoKlAwttR1
inline static int mul_ab_opt_gpoK(const int a, const int b)
{
    return a * b;
}
                                #endif

int fu_MAIN()
{
    return mul_ab_opt_gpoK(1, 0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn ab(a, b) a + b*2;
        fn main() ab(b: 1, a: -2);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ab_HCvKZjgo9Cf
                                #define DEF_ab_HCvKZjgo9Cf
inline static int ab_HCvK(const int a, const int b)
{
    return a + (b * 2);
}
                                #endif

int fu_MAIN()
{
    return ab_HCvK(-2, 1);
}

#endif

int main() { return fu_MAIN(); }

========

        struct yi32 { y: i32; };
        fn add_s_vy(v, s) s + v.y;
        fn main() add_s_vy(v: yi32(1), -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct yi32_oDNq;

                                #ifndef DEF_yi32_oDNq4W7jIb1
                                #define DEF_yi32_oDNq4W7jIb1
struct yi32_oDNq
{
                                // shape_hash:    eb9a3b6711039dd0
                                // non_triv_mask: 0000000000000000
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_s_vy_uG62ZmOOV5d
                                #define DEF_add_s_vy_uG62ZmOOV5d
inline static int add_s_vy_uG62(/*3:3*/ const yi32_oDNq& v, const int s)
{
    return s + v.y;
}
                                #endif

int fu_MAIN()
{
    return add_s_vy_uG62(yi32_oDNq { 1 }, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        struct xi32 { x: i32; };
        fn add_s_vx(s, v) s + v.x; // <- args reordered
        fn main() add_s_vx(v: xi32(1), -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct xi32_LNSm;

                                #ifndef DEF_xi32_LNSmGEd8Kj3
                                #define DEF_xi32_LNSmGEd8Kj3
struct xi32_LNSm
{
                                // shape_hash:    519ed99063ee6a62
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_s_vx_5wElCw0com7
                                #define DEF_add_s_vx_5wElCw0com7
inline static int add_s_vx_5wEl(const int s, /*3:3*/ const xi32_LNSm& v)
{
    return s + v.x;
}
                                #endif

int fu_MAIN()
{
    return add_s_vx_5wEl(-1, xi32_LNSm { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn ab(a, b = 0, c = 0) a + b*2 + c*3;
        fn main() ab(3, c: -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ab_HbuM6eoLTB9
                                #define DEF_ab_HbuM6eoLTB9
inline static int ab_HbuM(const int a, const int b, const int c)
{
    return (a + (b * 2)) + (c * 3);
}
                                #endif

int fu_MAIN()
{
    return ab_HbuM(3, 0, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn ab(a, b = -1) a + b*2;
        fn main() ab(3.0, -1.5).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ab_2efxcXMGhDk
                                #define DEF_ab_2efxcXMGhDk
inline static double ab_2efx(const double a, const double b)
{
    return a + (b * 2.0);
}
                                #endif

int fu_MAIN()
{
    return int(ab_2efx(3.0, -1.5));
}

#endif

int main() { return fu_MAIN(); }

========

        let NEG_ONE_FIVE = -1.5;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(3, NEG_ONE_FIVE).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_NEG_ONE_FIVE
                                #define DEF_NEG_ONE_FIVE
inline constexpr double NEG_ONE_FIVE = -1.5;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ab_2efxcXMGhDk
                                #define DEF_ab_2efxcXMGhDk
inline static double ab_2efx(const double a, const double b)
{
    return a + (b * 2.0);
}
                                #endif

int fu_MAIN()
{
    return int(ab_2efx(3.0, NEG_ONE_FIVE));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let TWO = 2.0;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(TWO).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_TWO
                                #define DEF_TWO
inline constexpr double TWO = 2.0;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ab_2efxcXMGhDk
                                #define DEF_ab_2efxcXMGhDk
inline static double ab_2efx(const double a, const double b)
{
    return a + (b * 2.0);
}
                                #endif

int fu_MAIN()
{
    return int(ab_2efx(TWO, -1.0));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn self_rec_template(x: $T): $T
            x > 0 ? self_rec_template(x / 2 - 5) : x;

        fn main()
            self_rec_template(7) + 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int self_rec_template_I3xo(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_self_rec_template_I3xo7pY2Azk
                                #define DEF_self_rec_template_I3xo7pY2Azk
inline static int self_rec_template_I3xo(const int x)
{
    if (x > 0)
        return self_rec_template_I3xo(((x / 2) - 5));
    else
        return x;

}
                                #endif

int fu_MAIN()
{
    return self_rec_template_I3xo(7) + 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;
        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;
        fn main() ab_rec(11) + 200;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int ab_rec_uf9l(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_ba_rec_iFRxih0yRm0
                                #define DEF_ba_rec_iFRxih0yRm0
inline static int ba_rec_iFRx(const int a)
{
    if (a)
        return ab_rec_uf9l((a - 7));
    else
        return -200;

}
                                #endif

                                #ifndef DEF_ab_rec_uf9l3XltRkg
                                #define DEF_ab_rec_uf9l3XltRkg
inline static int ab_rec_uf9l(const int a)
{
    if (a)
        return ba_rec_iFRx((a - 2));
    else
        return -100;

}
                                #endif

int fu_MAIN()
{
    return ab_rec_uf9l(11) + 200;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn main() {
            let a = 1;
            fn add1(b) a + b;
            return 2.add1 - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_add1_rmVuigH81of
                                #define DEF_add1_rmVuigH81of
inline static int add1_rmVu(const int b, /*3:3*/ const int a)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    const int a = 1;
    return add1_rmVu(2, a) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        pub fn MAP(a: $T[..], fn) {             // !N_DeadCode
            mut res: typeof( fn($T) )[];
            res.grow_junk(a.len);
            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);
            return res;
        }

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> $U[..]) a.MAP(fn clone);
        default {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };
        pub struct ModuleOutputs { deps: Scope[]; };

        pub fn test(a: ModuleOutputs) {
            let b = a.clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct ModuleOutputs_nkjo;
struct Scope_JhVx;

                                #ifndef DEF_Scope_JhVx2AT0avk
                                #define DEF_Scope_JhVx2AT0avk
struct Scope_JhVx
{
                                // shape_hash:    783b35bfa587ecee
                                // non_triv_mask: 0800000000000000
    int x;
    Scope_JhVx(const Scope_JhVx&) = delete;
    Scope_JhVx(Scope_JhVx&&) = default;
    Scope_JhVx& operator=(const Scope_JhVx&) = delete;
    Scope_JhVx& operator=(Scope_JhVx&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOutputs_nkjo8MEms7e
                                #define DEF_ModuleOutputs_nkjo8MEms7e
struct ModuleOutputs_nkjo
{
                                // shape_hash:    bf8042777b8b774a
                                // non_triv_mask: 0800000010000080
    fu::vec<Scope_JhVx> deps;
    ModuleOutputs_nkjo(const ModuleOutputs_nkjo&) = delete;
    ModuleOutputs_nkjo(ModuleOutputs_nkjo&&) = default;
    ModuleOutputs_nkjo& operator=(const ModuleOutputs_nkjo&) = delete;
    ModuleOutputs_nkjo& operator=(ModuleOutputs_nkjo&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || deps
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_clone_0DCJaE9X1mk
                                #define DEF_clone_0DCJaE9X1mk
inline int clone_0DCJ(/*1:1*/ const int a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_AGqCvzYoZYc
                                #define DEF_clone_AGqCvzYoZYc
inline Scope_JhVx clone_AGqC(/*1:1*/ const Scope_JhVx& a)
{
    /*MOV*/ Scope_JhVx res {};
    res.x = clone_0DCJ(a.x);
    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_MAP_slbwkSQ1TNl
                                #define DEF_MAP_slbwkSQ1TNl
inline fu::vec<Scope_JhVx> MAP_slbw(/*3:3*/ fu::view<Scope_JhVx> a)
{
    /*MOV*/ fu::vec<Scope_JhVx> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = clone_AGqC(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_clone_X1axdijq9zk
                                #define DEF_clone_X1axdijq9zk
inline fu::vec<Scope_JhVx> clone_X1ax(/*1:1*/ fu::view<Scope_JhVx> a)
{
    return MAP_slbw(a);
}
                                #endif

                                #ifndef DEF_clone_k0vf0PAoP9b
                                #define DEF_clone_k0vf0PAoP9b
inline ModuleOutputs_nkjo clone_k0vf(/*1:1*/ const ModuleOutputs_nkjo& a)
{
    /*MOV*/ ModuleOutputs_nkjo res {};
    res.deps = clone_X1ax(a.deps);
    return /*NRVO*/ res;
}
                                #endif

int test_MbR9(/*1:1*/ const ModuleOutputs_nkjo& a)
{
    ModuleOutputs_nkjo b = clone_k0vf(a);
    return a.deps.size() - b.deps.size();
}

int fu_MAIN()
{
    return test_MbR9(ModuleOutputs_nkjo{});
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { a: i32; };
        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;
        fn hey(using x: X) add_uxa_b_inline(-1);
        return X(1).hey;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_ZXez;

                                #ifndef DEF_X_ZXezvyPDUYa
                                #define DEF_X_ZXezvyPDUYa
struct X_ZXez
{
                                // shape_hash:    797b10c98c17bef7
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hey_MbR9(/*1:1*/ const X_ZXez& x)
{
    const int b = -1;
    return x.a + b;
}

int fu_MAIN()
{
    return hey_MbR9(X_ZXez { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { a: i32; };
        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;
        fn hey(using x: X) add_uxa_b_template(-1);
        return X(1).hey;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_ZXez;

                                #ifndef DEF_X_ZXezvyPDUYa
                                #define DEF_X_ZXezvyPDUYa
struct X_ZXez
{
                                // shape_hash:    797b10c98c17bef7
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_uxa_b_template_eNXHqUTDAQ3
                                #define DEF_add_uxa_b_template_eNXHqUTDAQ3
inline static int add_uxa_b_template_eNXH(/*3:3*/ const X_ZXez& x, const int b)
{
    return x.a + b;
}
                                #endif

static int hey_MbR9(/*1:1*/ const X_ZXez& x)
{
    return add_uxa_b_template_eNXH(x, -1);
}

int fu_MAIN()
{
    return hey_MbR9(X_ZXez { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn incr(a) a++;
        fn main() {
            mut a = 1;      
            inrc: || a;     
            return a - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:13+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut a = 1;      [0m
[2m    5 | [0m            [31;1minrc[0m: || a;     
[2m      |             return a - 2;[0m
[2m      |         }[0m

	Bad call to [94;1minrc[0m with args ([35;3mnocopy[0m [35;3m@130[0m): [94;1minrc[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        fn incr(a) a++;
        fn main() {
            mut a = 1;      
            incr: || a;     
            return a - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___3lkYHi5RbTf
                                #define DEF___3lkYHi5RbTf
inline static int& _3lkY(/*1:1*/ int& a)
{
    return a;
}
                                #endif

                                #ifndef DEF_incr_zB7lC2YNcv1
                                #define DEF_incr_zB7lC2YNcv1
inline static int incr_zB7l(/*3:3*/ int& a)
{
    return _3lkY(a)++;
}
                                #endif

int fu_MAIN()
{
    int a = 1;
    incr_zB7l(a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        inline fn inl_lies(x: u32): i32 = x;
        fn main() 0.inl_lies ? 1 : 0;                           // PointlessLocal

---- <fail> ----
[2m[0m_0[2m.fu 2:43+1[0m:

[2m      | [0m
[2m    2 | [0m        inline fn inl_lies(x: u32): i32 = [31;1mx[0m;
[2m      |         fn main() 0.inl_lies ? 1 : 0;                           // PointlessLocal[0m
[2m      | [0m

	[35;3mfn[0m [94;1minl_lies[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mu32[0m

        Solving [35;3mfn[0m [94;1minl_lies[0m([35;3mu32[0m) at [2m2:19+8[0m

========

        inline fn inl_lies(x: u32) = x;
        fn main() 0.inl_lies ? 1 : 0;                           // PointlessLocal

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    unsigned x;
    if ((x = 0u, x))
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn what(ref x: i32, ref y: i32) {

            let z = y;   
            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),
        }                //  we ignore the 'ref' part in type patterns,
                         //   so we only notice later when checking the spec
        fn main() {
            mut a = 1; mut b = 0; what(a, b);
            return a;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:13+4[0m:

[2m      | [0m
[2m      |             let z = y;   [0m
[2m    5 | [0m            [31;1mswap[0m(x, z);  // swap is defined(ref x: $T, ref y: $T),
[2m      |         }                //  we ignore the 'ref' part in type patterns,[0m
[2m      |                          //   so we only notice later when checking the spec[0m

	Bad call to [94;1mswap[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m<fu/vec/view_swap.h> fu::view_swap[0m at [2m../../../../../[0mprelude[2m 504:4+4[0m:
[2m  504 | [0mfn [31;1mswap[0m(mut ref a: <T>[..], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

	    Wrong number of arguments: expects 3, got 2.

	[35;3mtemplate[0m [94;1mswap[0m at [2m../../../../../[0mprelude[2m 216:4+4[0m:
[2m  216 | [0mfn [31;1mswap[0m(mut ref a: <T>, mut ref b: T)

	    [35;3mref arg[0m [94;1mb[0m expects a mutref, got a ref to [35;3mlet[0m [94;1mz[0m at [2m4:17+1[0m:

[2m      |         fn what(ref x: i32, ref y: i32) {[0m
[2m      | [0m
[2m    4 | [0m            let [31;1mz[0m = y;   
[2m      |             swap(x, z);  // swap is defined(ref x: $T, ref y: $T),[0m
[2m      |         }                //  we ignore the 'ref' part in type patterns,[0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mwhat[0m([35;3mi32[0m, [35;3mi32[0m) at [2m2:12+4[0m

========

        fn what(ref x: i32, ref y: i32) {

            ref z = y;   
            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),
        }                //  we ignore the 'ref' part in type patterns,
                         //   so we only notice later when checking the spec
        fn main() {
            mut a = 1; mut b = 0; what(a, b);
            return a;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <utility>


#ifndef fu_NO_fdefs

static void what_MbR9(/*3:1*/ int& x, /*3:2*/ int& y)
{
    std::swap(x, y);
}

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    what_MbR9(a, b);
    return a;
}

#endif

int main() { return fu_MAIN(); }

========

        fn any(a, b) a || b;
        fn main() any(0, []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_any_LtChU7z93Xf
                                #define DEF_any_LtChU7z93Xf
inline static int any_LtCh(/*3:3*/ const int a)
{
    return a ? a : 0;
}
                                #endif

int fu_MAIN()
{
    return any_LtCh(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn both(a, b) a && b;
        fn main() both(1, []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedIfElse

========

        fn either(a, b) a ? a : b;
        fn main() either(0, []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_either_iOuqgqfAxLg
                                #define DEF_either_iOuqgqfAxLg
inline static int either_iOuq(/*3:3*/ const int a)
{
    if (a)
        return a;
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    return either_iOuq(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn both_same_type(_, y) =
            typeof(y) -> $T;

        fn main()   = both_same_type(1.u32, 1.i32) ? 1
                    : both_same_type(1.i32, 1.i32) ? 0
                    : 2;

---- <fail> ----
[2m[0m_0[2m.fu 3:26+1[0m:

[2m      | [0m
[2m      |         fn both_same_type(_, y) =[0m
[2m    3 | [0m            typeof(y) -> [31;1m$[0mT;
[2m      | [0m
[2m      |         fn main()   = both_same_type(1.u32, 1.i32) ? 1[0m

	Bad call to [94;1m$T[0m: [94;1m$T[0m is not defined here.

        Solving [35;3mfn[0m [94;1mboth_same_type[0m([35;3mu32[0m, [35;3mi32[0m) at [2m2:12+14[0m
                [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn both_same_type(_: $T, y) =
            typeof(y) -> $T;

        fn main()   = both_same_type(1.u32, 1.i32) ? 1
                    : both_same_type(1.i32, 1.i32) ? 0
                    : 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn arrof <T>(lax _: T[], type U)
            case (T -> U)   true;
            default         false;

        fn main() {
            mut a: i32[];
            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_arrof_z38fd8Yr2qb
                                #define DEF_arrof_z38fd8Yr2qb
inline static bool arrof_z38f()
{
    return true;
}
                                #endif

                                #ifndef DEF_arrof_bVis2dHNKFj
                                #define DEF_arrof_bVis2dHNKFj
inline static bool arrof_bVis()
{
    return false;
}
                                #endif

int fu_MAIN()
{
    if (arrof_z38f() && !arrof_bVis())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn arrof <T>(lax _: T[], type U)
            case (T -> U)   true;
            default         false;

        fn main() {
            mut a: i32[];
            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        fn main() {
            mut x: i32 = 0;
            return (typeof(x) -> &mut i32).i32 - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(true) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn work(visit) visit(1, 2);
        fn main() work: |_, _| return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn each(ref moot: u32) moot++;

        fn Lifetime_process(lt: string, each) {
            for (mut i = 0; i < lt.len; i++) {
                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude
                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,
                                             // ^^^^ /////   resulting in a new mangle on each go.
                each(climb: fn climb, lt.slice(i, lt.len));
            }
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= " " ~ lt;
                if (let init = lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == " abc ab a b bc b c" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void Lifetime_process_qLeE(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_Qi7yFktRr92
                                #define DEF_climb_Qi7yFktRr92
inline static void climb_Qi7y(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::vec_range_mut<char> result)
{
    Lifetime_process_qLeE(parent, result);
}
                                #endif

                                #ifndef DEF_each_nYDMxdgghJl
                                #define DEF_each_nYDMxdgghJl
inline static void each_nYDM(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += (" "_view + lt);
    fu::view<char> init {};
    if (init.ptr_reassign(fu::get_view(lt, 0, (lt.size() - 1))))
        climb_Qi7y(init, result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_qLeEkLPGzA2
                                #define DEF_Lifetime_process_qLeEkLPGzA2
inline static void Lifetime_process_qLeE(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < lt.size(); i++)
        each_nYDM(fu::get_view(lt, i, lt.size()), result);

}
                                #endif

                                #ifndef DEF_climb_JBq4ftaAxyg
                                #define DEF_climb_JBq4ftaAxyg
inline static void climb_JBq4(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::vec_range_mut<char> result)
{
    Lifetime_process_qLeE(parent, result);
}
                                #endif

                                #ifndef DEF_each_hWUK6aDcmS7
                                #define DEF_each_hWUK6aDcmS7
inline static void each_hWUK(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += (" "_view + lt);
    fu::view<char> init {};
    if (init.ptr_reassign(fu::get_view(lt, 0, (lt.size() - 1))))
        climb_JBq4(init, result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_nVaY4HPVzB2
                                #define DEF_Lifetime_process_nVaY4HPVzB2
inline static void Lifetime_process_nVaY(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < lt.size(); i++)
        each_hWUK(fu::get_view(lt, i, lt.size()), result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_nVaY("abc"_view, result);
    if (result == " abc ab a b bc b c"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        fn each(ref moot: u32) moot++;

        fn Lifetime_process(lt: string, each) {
            for (mut i = 0; i < lt.len; i++) {
                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude
                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,
                                             // ^^^^ /////   resulting in a new mangle on each go.
                each(climb: fn climb, lt.slice(i, lt.len));
            }
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= " " ~ lt;
                if (let init = lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == " abc ab a b bc b c" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void Lifetime_process_qLeE(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_Qi7yFktRr92
                                #define DEF_climb_Qi7yFktRr92
inline static void climb_Qi7y(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::str& result)
{
    Lifetime_process_qLeE(parent, result);
}
                                #endif

                                #ifndef DEF_each_nYDMxdgghJl
                                #define DEF_each_nYDMxdgghJl
inline static void each_nYDM(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += (" "_view + lt);
    fu::view<char> init {};
    if (init.ptr_reassign(fu::get_view(lt, 0, (lt.size() - 1))))
        climb_Qi7y(init, result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_qLeEkLPGzA2
                                #define DEF_Lifetime_process_qLeEkLPGzA2
inline static void Lifetime_process_qLeE(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    for (int i = 0; i < lt.size(); i++)
        each_nYDM(fu::get_view(lt, i, lt.size()), result);

}
                                #endif

                                #ifndef DEF_climb_JBq4ftaAxyg
                                #define DEF_climb_JBq4ftaAxyg
inline static void climb_JBq4(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::str& result)
{
    Lifetime_process_qLeE(parent, result);
}
                                #endif

                                #ifndef DEF_each_hWUK6aDcmS7
                                #define DEF_each_hWUK6aDcmS7
inline static void each_hWUK(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += (" "_view + lt);
    fu::view<char> init {};
    if (init.ptr_reassign(fu::get_view(lt, 0, (lt.size() - 1))))
        climb_JBq4(init, result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_nVaY4HPVzB2
                                #define DEF_Lifetime_process_nVaY4HPVzB2
inline static void Lifetime_process_nVaY(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    for (int i = 0; i < lt.size(); i++)
        each_hWUK(fu::get_view(lt, i, lt.size()), result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_nVaY("abc"_view, result);
    if (result == " abc ab a b bc b c"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        using flags Flags { F_SOME; F_OTHER };

        fn parseInlineDecl(mut flags, flag = F_OTHER) {
            flags |= flag;
            return flags;
        }

        fn parseNoInline(mut flags) {
            return parseInlineDecl(:flags, flag: []);
        }

        fn main() = parseInlineDecl(F_SOME).i32
                  - parseNoInline(F_SOME).i32 * 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Flags_Qpfn;

                                #ifndef DEF_Flags_Qpfn
                                #define DEF_Flags_Qpfn
inline constexpr Flags_Qpfn Flags_Qpfn_F_SOME = Flags_Qpfn(1u);
inline constexpr Flags_Qpfn Flags_Qpfn_F_OTHER = Flags_Qpfn(2u);

inline constexpr Flags_Qpfn MASK_Flags_Qpfn
    = Flags_Qpfn_F_SOME
    | Flags_Qpfn_F_OTHER;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_parseInlineDecl_hbh40YkuT22
                                #define DEF_parseInlineDecl_hbh40YkuT22
inline static Flags_Qpfn parseInlineDecl_hbh4(Flags_Qpfn flags, const Flags_Qpfn flag)
{
    flags |= flag;
    return flags;
}
                                #endif

                                #ifndef DEF_parseNoInline_yBEZGghfDhl
                                #define DEF_parseNoInline_yBEZGghfDhl
inline static Flags_Qpfn parseNoInline_yBEZ(const Flags_Qpfn flags)
{
    return parseInlineDecl_hbh4(flags, Flags_Qpfn{});
}
                                #endif

int fu_MAIN()
{
    return int(parseInlineDecl_hbh4(Flags_Qpfn_F_SOME, Flags_Qpfn_F_OTHER)) - (int(parseNoInline_yBEZ(Flags_Qpfn_F_SOME)) * 3);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range { lo_incl: int; hi_excl: int };

        fn each(using _: Range, each)
            for (mut i = lo_incl; i < hi_excl; i++)
                each(i);

        fn main() {
            mut sum = 0;
            _0::Range(0, 10).each: |i| sum += i;
            return sum - 45 ;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_HSZi;

                                #ifndef DEF_Range_HSZimbINmyi
                                #define DEF_Range_HSZimbINmyi
struct Range_HSZi
{
                                // shape_hash:    32ff2831bb61d18d
                                // non_triv_mask: 0000000000000000
    int lo_incl;
    int hi_excl;
    explicit operator bool() const noexcept
    {
        return false
            || lo_incl
            || hi_excl
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int i, /*3:3*/ int& sum)
{
    return (sum += i);
}
                                #endif

                                #ifndef DEF_each_SZ6FUUwFfhe
                                #define DEF_each_SZ6FUUwFfhe
inline void each_SZ6F(/*7:7*/ const Range_HSZi& _, /*6:6*/ int& sum)
{
    for (int i = _.lo_incl; i < _.hi_excl; i++)
        _5aAg(i, sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    each_SZ6F(Range_HSZi { 0, 10 }, sum);
    return sum - 45;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn hello(mut x: $T[]) {
            x.each: |ref it| it++;
            return x;
        }

        fn main() {
            mut a = [ 1 ];
            let b = hello(a);
            for (mut i = 0; i < min(a.len, b.len); i++)
                return a[i] + b[i] - 3;

 
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:13+3[0m:

[2m      |             mut a = [ 1 ];[0m
[2m      |             let b = hello(a);[0m
[2m   10 | [0m            [31;1mfor[0m (mut i = 0; i < min(a.len, b.len); i++)
[2m      |                 return a[i] + b[i] - 3;[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m is missing a final return statement: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn hello(mut x: i32[]) {
            x.each: |ref it| it++;
            return x;
        }

        fn main() {
            mut a = [ 1 ];
            let b = hello(a);
            for (mut i = 0; i < min(a.len, b.len); i++)
                return a[i] + b[i] - 3;

 
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:13+3[0m:

[2m      |             mut a = [ 1 ];[0m
[2m      |             let b = hello(a);[0m
[2m   10 | [0m            [31;1mfor[0m (mut i = 0; i < min(a.len, b.len); i++)
[2m      |                 return a[i] + b[i] - 3;[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m is missing a final return statement: expects [35;3mi32[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn hello(mut x: $T[]) {
            x.each: |ref it| it++;
            return x;
        }

        fn main() {
            mut a = [ 1 ];
            let b = hello(a);
            for (mut i = 0; i < min(a.len, b.len); i++)
                return a[i] + b[i] - 3;


            return 1;                           
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___4n9IRCewvq2
                                #define DEF___4n9IRCewvq2
inline static int _4n9I(/*1:1*/ int& it)
{
    return it++;
}
                                #endif

                                #ifndef DEF_each_tgC6ZGKd8pc
                                #define DEF_each_tgC6ZGKd8pc
inline void each_tgC6(/*3:3*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        _4n9I(a.mutref(i));

}
                                #endif

                                #ifndef DEF_hello_m9pcyBKLioa
                                #define DEF_hello_m9pcyBKLioa
inline static fu::vec<int> hello_m9pc(/*MOV*/ fu::vec<int>&& x)
{
    each_tgC6(x);
    return x.destructive_move();
}
                                #endif

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(/*3:3*/ const int a, /*3:3*/ const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    fu::vec<int> b = hello_m9pc(fu::vec<int>(a));
    for (int i = 0; i < min_DbqN(a.size(), b.size()); i++)
        return (a[i] + b[i]) - 3;

    return 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn hello(mut x: i32[]) {
            x.each: |ref it| it++;
            return x;
        }

        fn main() {
            mut a = [ 1 ];
            let b = hello(a);
            for (mut i = 0; i < min(a.len, b.len); i++)
                return a[i] + b[i] - 3;


            return 1;                           
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___4n9IRCewvq2
                                #define DEF___4n9IRCewvq2
inline static int _4n9I(/*1:1*/ int& it)
{
    return it++;
}
                                #endif

                                #ifndef DEF_each_tgC6ZGKd8pc
                                #define DEF_each_tgC6ZGKd8pc
inline void each_tgC6(/*3:3*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        _4n9I(a.mutref(i));

}
                                #endif

static fu::vec<int> hello_MbR9(/*MOV*/ fu::vec<int>&& x)
{
    each_tgC6(x);
    return x.destructive_move();
}

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(/*3:3*/ const int a, /*3:3*/ const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    fu::vec<int> b = hello_MbR9(fu::vec<int>(a));
    for (int i = 0; i < min_DbqN(a.size(), b.size()); i++)
        return (a[i] + b[i]) - 3;

    return 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Things(type <T>) { ARR: T[] };


        fn add(ref a.ARR, b.ARR)
            a ~= b;

        fn main() {
            type i32s = _0::Things(i32);
            mut a: i32s;
            mut b: i32s;
            a.add(b);
            return a.ARR.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Things_0LLB;

                                #ifndef DEF_Things_0LLBxvkm1H7
                                #define DEF_Things_0LLBxvkm1H7
struct Things_0LLB
{
                                // shape_hash:    62e937ad37a9d995
                                // non_triv_mask: 0008000004000000
    fu::vec<int> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_SMYnhMb9yw7
                                #define DEF_add_SMYnhMb9yw7
inline static fu::view<int> add_SMYn(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    return (a += b);
}
                                #endif

int fu_MAIN()
{
    Things_0LLB a {};
    Things_0LLB b {};
    add_SMYn(a.ARR, b.ARR);
    return a.ARR.size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Things(type <T>) { ARR: T[] };


        fn add !T(ref a: _0::Things(T), b: _0::Things(T))
            a.ARR ~= b.ARR;

        fn main() {
            type i32s = _0::Things(i32);
            mut a: i32s;
            mut b: i32s;
            a.add(b);
            return a.ARR.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Things_0LLB;

                                #ifndef DEF_Things_0LLBxvkm1H7
                                #define DEF_Things_0LLBxvkm1H7
struct Things_0LLB
{
                                // shape_hash:    62e937ad37a9d995
                                // non_triv_mask: 0008000004000000
    fu::vec<int> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_mOxrqJC1rv3
                                #define DEF_add_mOxrqJC1rv3
inline static fu::view<int> add_mOxr(/*1:1*/ Things_0LLB& a, /*3:3*/ const Things_0LLB& b)
{
    return (a.ARR += b.ARR);
}
                                #endif

int fu_MAIN()
{
    Things_0LLB a {};
    Things_0LLB b {};
    add_mOxr(a, b);
    return a.ARR.size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Things(type T) { ARR: T[] };

        fn add(ref a.ARR, b.ARR)
            a ~= b;


        struct Events(type A, type B) {
            a: _0::Things(A);
            b: _0::Things(B);
        };

        fn Events_merge(ref e0: Events($A, $B), e1: Events($A, $B))
        {
            fn Events_merge(ref a: _0::Things($T), b: _0::Things($T))
                a.add(b);

            for (fieldname i: Events($A, $B))
                Events_merge(e0.i, e1.i);
        }

        fn main() {
            mut e0: _1::Events(i32, u32);
            mut e1: _1::Events(i32, u32);
            for (mut i = 0; i < 3; i++) {
                e0.a.ARR ~= i;
                e1.a.ARR ~= 3 + i;
                if (i & 1) {
                    e0.b.ARR ~= 0xff;
                    e1.b.ARR ~= 0xfe;
                }
            }

            e0.Events_merge(e1);
            return e0.a.ARR == [ 0, 1, 2, 3, 4, 5 ]
                && e0.b.ARR == [ 0xff, 0xfe ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Events_dL1m;
struct Things_0LLB;
struct Things_rsHd;

                                #ifndef DEF_Things_0LLBxvkm1H7
                                #define DEF_Things_0LLBxvkm1H7
struct Things_0LLB
{
                                // shape_hash:    62e937ad37a9d995
                                // non_triv_mask: 0008000004000000
    fu::vec<int> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

                                #ifndef DEF_Things_rsHdbVECvD5
                                #define DEF_Things_rsHdbVECvD5
struct Things_rsHd
{
                                // shape_hash:    7b42eee67df19a14
                                // non_triv_mask: 0000800000000800
    fu::vec<unsigned> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

                                #ifndef DEF_Events_dL1mZpvbDv5
                                #define DEF_Events_dL1mZpvbDv5
struct Events_dL1m
{
                                // shape_hash:    3b7663eec3e3e204
                                // non_triv_mask: 0008800004008800
    Things_0LLB a;
    Things_rsHd b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_SMYnhMb9yw7
                                #define DEF_add_SMYnhMb9yw7
inline fu::view<int> add_SMYn(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    return (a += b);
}
                                #endif

                                #ifndef DEF_Events_merge_NklqNob3Jv1
                                #define DEF_Events_merge_NklqNob3Jv1
inline static fu::view<int> Events_merge_Nklq(/*1:1*/ Things_0LLB& a, /*3:3*/ const Things_0LLB& b)
{
    return add_SMYn(a.ARR, b.ARR);
}
                                #endif

                                #ifndef DEF_add_IpzRLragOE0
                                #define DEF_add_IpzRLragOE0
inline fu::view<unsigned> add_IpzR(/*1:1*/ fu::vec_range_mut<unsigned> a, /*3:3*/ fu::view<unsigned> b)
{
    return (a += b);
}
                                #endif

                                #ifndef DEF_Events_merge_F8r5fvAKoi0
                                #define DEF_Events_merge_F8r5fvAKoi0
inline static fu::view<unsigned> Events_merge_F8r5(/*1:1*/ Things_rsHd& a, /*3:3*/ const Things_rsHd& b)
{
    return add_IpzR(a.ARR, b.ARR);
}
                                #endif

                                #ifndef DEF_Events_merge_65X3CrOQFR0
                                #define DEF_Events_merge_65X3CrOQFR0
inline void Events_merge_65X3(/*1:1*/ Events_dL1m& e0, /*3:3*/ const Events_dL1m& e1)
{
    Events_merge_Nklq(e0.a, e1.a);
    Events_merge_F8r5(e0.b, e1.b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_Rgh3ARpn2a3
                                #define DEF_x3Cx3E_Rgh3ARpn2a3
inline int x3Cx3E_Rgh3(const unsigned a, const unsigned b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_FqmEP9P1tjl
                                #define DEF_x3Cx3E_FqmEP9P1tjl
inline int x3Cx3E_FqmE(/*3:3*/ fu::view<unsigned> a, /*3:3*/ fu::view<unsigned> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_Rgh3(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_VeKWwwhaD6i
                                #define DEF_x3Dx3D_VeKWwwhaD6i
inline bool operator==(/*3:3*/ fu::view<unsigned> a, /*3:3*/ fu::view<unsigned> b)
{
    return !x3Cx3E_FqmE(a, b);
}
                                #endif

int fu_MAIN()
{
    Events_dL1m e0 {};
    Events_dL1m e1 {};
    for (int i = 0; i < 3; i++)
    {
        e0.a.ARR += i;
        e1.a.ARR += (3 + i);
        if (i & 1)
        {
            e0.b.ARR += 0xffu;
            e1.b.ARR += 0xfeu;
        };
    };
    Events_merge_65X3(e0, e1);
    if ((e0.a.ARR == fu::view<int> {{ 0, 1, 2, 3, 4, 5 }}) && (e0.b.ARR == fu::view<unsigned> {{ 0xffu, 0xfeu }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Things(type T) { ARR: T[] };

        fn add(ref a: Things($T), b: Things($T))
            a.ARR ~= b.ARR;


        struct Events(type A, type B) {
            a: _0::Things(A);
            b: _0::Things(B);
        };

        fn Events_merge(ref e0: Events($A, $B), e1: Events($A, $B))
        {
            fn Events_merge(ref a: _0::Things($T), b: _0::Things($T))
                a.add(b);

            for (fieldname i: Events($A, $B))
                Events_merge(e0.i, e1.i);
        }

        fn main() {
            mut e0: _1::Events(i32, u32);
            mut e1: _1::Events(i32, u32);
            for (mut i = 0; i < 3; i++) {
                e0.a.ARR ~= i;
                e1.a.ARR ~= 3 + i;
                if (i & 1) {
                    e0.b.ARR ~= 0xff;
                    e1.b.ARR ~= 0xfe;
                }
            }

            e0.Events_merge(e1);
            return e0.a.ARR == [ 0, 1, 2, 3, 4, 5 ]
                && e0.b.ARR == [ 0xff, 0xfe ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Events_dL1m;
struct Things_0LLB;
struct Things_rsHd;

                                #ifndef DEF_Things_0LLBxvkm1H7
                                #define DEF_Things_0LLBxvkm1H7
struct Things_0LLB
{
                                // shape_hash:    62e937ad37a9d995
                                // non_triv_mask: 0008000004000000
    fu::vec<int> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

                                #ifndef DEF_Things_rsHdbVECvD5
                                #define DEF_Things_rsHdbVECvD5
struct Things_rsHd
{
                                // shape_hash:    7b42eee67df19a14
                                // non_triv_mask: 0000800000000800
    fu::vec<unsigned> ARR;
    explicit operator bool() const noexcept
    {
        return false
            || ARR
        ;
    }
};
                                #endif

                                #ifndef DEF_Events_dL1mZpvbDv5
                                #define DEF_Events_dL1mZpvbDv5
struct Events_dL1m
{
                                // shape_hash:    3b7663eec3e3e204
                                // non_triv_mask: 0008800004008800
    Things_0LLB a;
    Things_rsHd b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_mOxrqJC1rv3
                                #define DEF_add_mOxrqJC1rv3
inline fu::view<int> add_mOxr(/*1:1*/ Things_0LLB& a, /*3:3*/ const Things_0LLB& b)
{
    return (a.ARR += b.ARR);
}
                                #endif

                                #ifndef DEF_Events_merge_rellkt6xMoa
                                #define DEF_Events_merge_rellkt6xMoa
inline static fu::view<int> Events_merge_rell(/*1:1*/ Things_0LLB& a, /*3:3*/ const Things_0LLB& b)
{
    return add_mOxr(a, b);
}
                                #endif

                                #ifndef DEF_add_k7J9TFkDuEj
                                #define DEF_add_k7J9TFkDuEj
inline fu::view<unsigned> add_k7J9(/*1:1*/ Things_rsHd& a, /*3:3*/ const Things_rsHd& b)
{
    return (a.ARR += b.ARR);
}
                                #endif

                                #ifndef DEF_Events_merge_2kCPrkWBoZ7
                                #define DEF_Events_merge_2kCPrkWBoZ7
inline static fu::view<unsigned> Events_merge_2kCP(/*1:1*/ Things_rsHd& a, /*3:3*/ const Things_rsHd& b)
{
    return add_k7J9(a, b);
}
                                #endif

                                #ifndef DEF_Events_merge_97Q9Ib3r2D0
                                #define DEF_Events_merge_97Q9Ib3r2D0
inline void Events_merge_97Q9(/*1:1*/ Events_dL1m& e0, /*3:3*/ const Events_dL1m& e1)
{
    Events_merge_rell(e0.a, e1.a);
    Events_merge_2kCP(e0.b, e1.b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_Rgh3ARpn2a3
                                #define DEF_x3Cx3E_Rgh3ARpn2a3
inline int x3Cx3E_Rgh3(const unsigned a, const unsigned b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_FqmEP9P1tjl
                                #define DEF_x3Cx3E_FqmEP9P1tjl
inline int x3Cx3E_FqmE(/*3:3*/ fu::view<unsigned> a, /*3:3*/ fu::view<unsigned> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_Rgh3(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_VeKWwwhaD6i
                                #define DEF_x3Dx3D_VeKWwwhaD6i
inline bool operator==(/*3:3*/ fu::view<unsigned> a, /*3:3*/ fu::view<unsigned> b)
{
    return !x3Cx3E_FqmE(a, b);
}
                                #endif

int fu_MAIN()
{
    Events_dL1m e0 {};
    Events_dL1m e1 {};
    for (int i = 0; i < 3; i++)
    {
        e0.a.ARR += i;
        e1.a.ARR += (3 + i);
        if (i & 1)
        {
            e0.b.ARR += 0xffu;
            e1.b.ARR += 0xfeu;
        };
    };
    Events_merge_97Q9(e0, e1);
    if ((e0.a.ARR == fu::view<int> {{ 0, 1, 2, 3, 4, 5 }}) && (e0.b.ARR == fu::view<unsigned> {{ 0xffu, 0xfeu }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn reduce(array: <T>[], reducer, mut reduct?: T) {
            for (mut i = array.len; i --> 0; )
                reduct = reducer(array[i], reduct);

            return reduct;
        }

        fn parent_fn(orig: <T>[])
        {
            struct Item { value: T };

            let mapped = orig.map(
                fn child_fn(value: T)
                    Item(:value));

            mut num_items_added = 0;
            infix fn +(a: Item, b: Item) {
                num_items_added++;
                Item(a.value + b.value)
            }

            fn sum(array: <T>[])                
                reduce(array, |a, b| a + b);

            let sum_orig    = sum(orig);
            let sum_mapped  = sum(mapped);

            assert(sum_orig == sum_mapped.value);
            assert(num_items_added == orig.len);
            return sum_mapped;
        }

        fn main() [ 1, 2, -3 ].parent_fn().value;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 23:28+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m   23 | [0m            fn sum(array: <[31;1mT[0m>[])                
[2m      |                 reduce(array, |a, b| a + b);[0m
[2m      | [0m

	A type parameter [94;1mT[0m is already defined.

========

        fn reduce(array: <T>[], reducer, mut reduct?: T) {
            for (mut i = array.len; i --> 0; )
                reduct = reducer(array[i], reduct);

            return reduct;
        }

        fn parent_fn(orig: <T>[])
        {
            struct Item { value: T };

            let mapped = orig.map(
                fn child_fn(value: T)
                    Item(:value));

            mut num_items_added = 0;
            infix fn +(a: Item, b: Item) {
                num_items_added++;
                Item(a.value + b.value)
            }

            fn sum(array: <U>[])                
                reduce(array, |a, b| a + b);

            let sum_orig    = sum(orig);
            let sum_mapped  = sum(mapped);

            assert(sum_orig == sum_mapped.value);
            assert(num_items_added == orig.len);
            return sum_mapped;
        }

        fn main() [ 1, 2, -3 ].parent_fn().value;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/assert.h>

struct Item_v8BK;

                                #ifndef DEF_Item_v8BKUVeVDAd
                                #define DEF_Item_v8BKUVeVDAd
struct Item_v8BK
{
                                // shape_hash:    3907ada9fda9d4e9
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_child_fn_KEL2Agpc7fb
                                #define DEF_child_fn_KEL2Agpc7fb
inline static Item_v8BK child_fn_KEL2(const int value)
{
    return Item_v8BK { value };
}
                                #endif

                                #ifndef DEF_map_eO1YWOPOwBe
                                #define DEF_map_eO1YWOPOwBe
inline fu::vec<Item_v8BK> map_eO1Y(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<Item_v8BK> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = child_fn_KEL2(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF___NN4PnOIxMqb
                                #define DEF___NN4PnOIxMqb
inline static int _NN4P(const int a, const int b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_reduce_Fm2bOZnCYLe
                                #define DEF_reduce_Fm2bOZnCYLe
inline static int reduce_Fm2b(/*7:7*/ fu::view<int> array, int reduct)
{
    for (int i = array.size(); i-- > 0; )
        reduct = _NN4P(array[i], reduct);

    return reduct;
}
                                #endif

                                #ifndef DEF_sum_EUDqyW3ee5a
                                #define DEF_sum_EUDqyW3ee5a
inline static int sum_EUDq(/*1:1*/ fu::view<int> array)
{
    return reduce_Fm2b(array, 0);
}
                                #endif

                                #ifndef DEF_x2B_PkWTB1XpLUd
                                #define DEF_x2B_PkWTB1XpLUd
inline static Item_v8BK x2B_PkWT(/*7:7*/ const Item_v8BK& a, /*7:7*/ const Item_v8BK& b, /*4:4*/ int& num_items_added)
{
    num_items_added++;
    return Item_v8BK { (a.value + b.value) };
}
                                #endif

                                #ifndef DEF___WL8gJ2FfQ7i
                                #define DEF___WL8gJ2FfQ7i
inline static Item_v8BK _WL8g(/*7:7*/ const Item_v8BK& a, /*7:7*/ const Item_v8BK& b, /*4:4*/ int& num_items_added)
{
    return x2B_PkWT(a, b, num_items_added);
}
                                #endif

                                #ifndef DEF_reduce_1ocYbQVKizd
                                #define DEF_reduce_1ocYbQVKizd
inline static Item_v8BK reduce_1ocY(/*F:F*/ fu::view<Item_v8BK> array, Item_v8BK&& reduct, /*A:A*/ int& num_items_added)
{
    for (int i = array.size(); i-- > 0; )
        reduct = _WL8g(array[i], reduct, num_items_added);

    return reduct;
}
                                #endif

                                #ifndef DEF_sum_LxO6kzzPfQ9
                                #define DEF_sum_LxO6kzzPfQ9
inline static Item_v8BK sum_LxO6(/*3:3*/ fu::view<Item_v8BK> array, /*2:2*/ int& num_items_added)
{
    return reduce_1ocY(array, Item_v8BK{}, num_items_added);
}
                                #endif

                                #ifndef DEF_parent_fn_V4ootstw7qa
                                #define DEF_parent_fn_V4ootstw7qa
inline static Item_v8BK parent_fn_V4oo(/*1:1*/ fu::view<int> orig)
{
    fu::vec<Item_v8BK> mapped = map_eO1Y(orig);
    int num_items_added = 0;
    const int sum_orig = sum_EUDq(orig);
    const Item_v8BK sum_mapped = sum_LxO6(mapped, num_items_added);
    fu_ASSERT((sum_orig == sum_mapped.value));
    fu_ASSERT((num_items_added == orig.size()));
    return sum_mapped;
}
                                #endif

int fu_MAIN()
{
    return parent_fn_V4oo(fu::view<int> {{ 1, 2, -3 }}).value;
}

#endif

int main() { return fu_MAIN(); }

========

        struct SocketArrays { v: int };
        struct Sockets(type X) { x: X; using sa?: SocketArrays }

        fn what(ref s) s.v += s.x;
        fn socket_accepted(ref sa: SocketArrays, woot) woot(sa.v);

        fn main() {                             
            mut sockets: Sockets(int) = [ 3 ];  
            sockets.what();
            sockets.socket_accepted: |ref v| v *= 7;
            return sockets.v - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Sockets_iwV6;
struct SocketArrays_Lq6J;

                                #ifndef DEF_SocketArrays_Lq6JjuvdLAb
                                #define DEF_SocketArrays_Lq6JjuvdLAb
struct SocketArrays_Lq6J
{
                                // shape_hash:    bd7366e28cea7078
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_Sockets_iwV6GQvEae1
                                #define DEF_Sockets_iwV6GQvEae1
struct Sockets_iwV6
{
                                // shape_hash:    66304e3199c5f4e0
                                // non_triv_mask: 0000000000000000
    int x;
    SocketArrays_Lq6J sa;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || sa
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_what_DTHnZH05el3
                                #define DEF_what_DTHnZH05el3
inline static int what_DTHn(/*1:1*/ Sockets_iwV6& s)
{
    return (s.sa.v += s.x);
}
                                #endif

                                #ifndef DEF___ZUXc9ffUQn6
                                #define DEF___ZUXc9ffUQn6
inline static int _ZUXc(/*1:1*/ int& v)
{
    return (v *= 7);
}
                                #endif

                                #ifndef DEF_socket_accepted_rdGmqdrlrvk
                                #define DEF_socket_accepted_rdGmqdrlrvk
inline static int socket_accepted_rdGm(/*3:3*/ SocketArrays_Lq6J& sa)
{
    return _ZUXc(sa.v);
}
                                #endif

int fu_MAIN()
{
    Sockets_iwV6 sockets = Sockets_iwV6 { 3, SocketArrays_Lq6J{} };
    what_DTHn(sockets);
    socket_accepted_rdGm(sockets.sa);
    return sockets.sa.v - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct SocketArrays { v: int };
        struct Sockets(type X) { x: X; using sa?: SocketArrays }

        fn what(ref s) s.v += s.x;
        fn socket_accepted(ref sa: SocketArrays, woot) woot(sa.v);

        fn main() {                             
            mut sockets = Sockets(int)(3);      
            sockets.what();
            sockets.socket_accepted: |ref v| v *= 7;
            return sockets.v - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Sockets_iwV6;
struct SocketArrays_Lq6J;

                                #ifndef DEF_SocketArrays_Lq6JjuvdLAb
                                #define DEF_SocketArrays_Lq6JjuvdLAb
struct SocketArrays_Lq6J
{
                                // shape_hash:    bd7366e28cea7078
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_Sockets_iwV6GQvEae1
                                #define DEF_Sockets_iwV6GQvEae1
struct Sockets_iwV6
{
                                // shape_hash:    66304e3199c5f4e0
                                // non_triv_mask: 0000000000000000
    int x;
    SocketArrays_Lq6J sa;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || sa
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_what_DTHnZH05el3
                                #define DEF_what_DTHnZH05el3
inline static int what_DTHn(/*1:1*/ Sockets_iwV6& s)
{
    return (s.sa.v += s.x);
}
                                #endif

                                #ifndef DEF___ZUXc9ffUQn6
                                #define DEF___ZUXc9ffUQn6
inline static int _ZUXc(/*1:1*/ int& v)
{
    return (v *= 7);
}
                                #endif

                                #ifndef DEF_socket_accepted_rdGmqdrlrvk
                                #define DEF_socket_accepted_rdGmqdrlrvk
inline static int socket_accepted_rdGm(/*3:3*/ SocketArrays_Lq6J& sa)
{
    return _ZUXc(sa.v);
}
                                #endif

int fu_MAIN()
{
    Sockets_iwV6 sockets = Sockets_iwV6 { 3, SocketArrays_Lq6J{} };
    what_DTHn(sockets);
    socket_accepted_rdGm(sockets.sa);
    return sockets.sa.v - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        pub fn identity(dont_leak_me) dont_leak_me;

        let dont_leak_me = 1;
        fn main() _0::identity(dont_leak_me * 2) - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_dont_leak_me
                                #define DEF_dont_leak_me
inline constexpr int dont_leak_me = 1;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_identity_0DCJaE9X1mk
                                #define DEF_identity_0DCJaE9X1mk
inline int identity_0DCJ(/*1:1*/ const int dont_leak_me)
{
    return dont_leak_me;
}
                                #endif

int fu_MAIN()
{
    return identity_0DCJ((dont_leak_me * 2)) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;
        let dont_leak_me = 1;
        fn main() inl_id_leak(dont_leak_me * 2) - 2;            // PointlessLocal

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_dont_leak_me
                                #define DEF_dont_leak_me
inline constexpr int dont_leak_me = 1;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int dont_leak_me;
    return (dont_leak_me = (::dont_leak_me * 2), dont_leak_me) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit, N_SD_ExternPrivates

========

        let static = 1;
        fn template(arg) static + arg;
        let arg = 7;                        // <- template shouldn't see this
        let result = template(arg / -4);    // <- when specializing here
        fn main() result;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_arg
                                #define DEF_arg
inline constexpr int arg = 7;
                                #endif

                                #ifndef DEF_static
                                #define DEF_static
inline constexpr int sTatic = 1;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_tEmplate_eHISZJhEVL4
                                #define DEF_tEmplate_eHISZJhEVL4
inline static int tEmplate_eHIS(const int arg)
{
    return sTatic + arg;
}
                                #endif

static const int result = tEmplate_eHIS((arg / -4));

int fu_MAIN()
{
    return result;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn main() {
            let static = 1;
            fn template(arg) static + arg;
            let arg = 7; // same here, except we're in a fn.
            return template(arg / -4);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_tEmplate_rmVuigH81of
                                #define DEF_tEmplate_rmVuigH81of
inline static int tEmplate_rmVu(const int arg, /*3:3*/ const int sTatic)
{
    return sTatic + arg;
}
                                #endif

int fu_MAIN()
{
    const int sTatic = 1;
    const int arg = 7;
    return tEmplate_rmVu((arg / -4), sTatic);
}

#endif

int main() { return fu_MAIN(); }

========

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };

        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);
        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct HasInt_fNav;

                                #ifndef DEF_HasInt_fNavPRSAUQ3
                                #define DEF_HasInt_fNavPRSAUQ3
struct HasInt_fNav
{
                                // shape_hash:    d2edc5bfac022ec2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static HasInt_fNav operator+(/*3:3*/ const HasInt_fNav& a, /*3:3*/ const HasInt_fNav& b)
{
    return HasInt_fNav { (a.i + b.i) };
}

                                #ifndef DEF_template_add_Q5sw2c1xDGb
                                #define DEF_template_add_Q5sw2c1xDGb
inline HasInt_fNav template_add_Q5sw(/*3:3*/ const HasInt_fNav& a, /*3:3*/ const HasInt_fNav& b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return template_add_Q5sw(HasInt_fNav { 1 }, HasInt_fNav { 2 }).i - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };
        pub import _1;
        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);
        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct HasInt_fNav;

                                #ifndef DEF_HasInt_fNavPRSAUQ3
                                #define DEF_HasInt_fNavPRSAUQ3
struct HasInt_fNav
{
                                // shape_hash:    d2edc5bfac022ec2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static HasInt_fNav operator+(/*3:3*/ const HasInt_fNav& a, /*3:3*/ const HasInt_fNav& b)
{
    return HasInt_fNav { (a.i + b.i) };
}

                                #ifndef DEF_template_add_dv8IidYM3kg
                                #define DEF_template_add_dv8IidYM3kg
inline HasInt_fNav template_add_dv8I(/*3:3*/ const HasInt_fNav& a, /*3:3*/ const HasInt_fNav& b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return template_add_dv8I(HasInt_fNav { 1 }, HasInt_fNav { 2 }).i - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            postfix fn [](x: u32, at: u32) x & 1 << (at & 31);
            return 0x7[3].i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static unsigned x5Bx5D_MbR9(const unsigned x, const unsigned at)
{
    return x & (1u << (at & 31u));
}

int fu_MAIN()
{
    return int(x5Bx5D_MbR9(0x7u, 3u));
}

#endif

int main() { return fu_MAIN(); }

========

        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int);

#ifndef fu_NO_fdefs

static int inner_MbR9(const int i)
{
    if (i > 0)
        return outer_MbR9((i - 1));
    else
        return 0;

}

static int outer_MbR9(const int i)
{
    return 2 * inner_MbR9(i);
}

int fu_MAIN()
{
    return outer_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn test(one: i32) {
            let zero = one - 1;
            let two  = one * 2;


            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int inner_MbR9(const int i, /*F:F*/ const int one, /*F:F*/ const int zero, /*F:F*/ const int two)
{
    if (i > zero)
        return outer_MbR9((i - one), one, zero, two);
    else
        return zero;

}

static int outer_MbR9(const int i, /*F:F*/ const int one, /*F:F*/ const int zero, /*F:F*/ const int two)
{
    return two * inner_MbR9(i, one, zero, two);
}

static int test_MbR9(const int one)
{
    const int zero = (one - 1);
    const int two = (one * 2);
    return outer_MbR9(one, one, zero, two) + ((two - one) * 17);
}

int fu_MAIN()
{
    return test_MbR9(1) - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn test(one: i32) {
            let zero = one - 1;
            let two  = one * 2;


            inline 
            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int outer_MbR9(const int i, /*F:F*/ const int one, /*F:F*/ const int zero, /*F:F*/ const int two)
{
    return two * ((i > zero) ? outer_MbR9((i - one), one, zero, two) : zero);
}

static int test_MbR9(const int one)
{
    const int zero = (one - 1);
    const int two = (one * 2);
    return outer_MbR9(one, one, zero, two) + ((two - one) * 17);
}

int fu_MAIN()
{
    return test_MbR9(1) - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_MbR9(const int i, /*3:3*/ const int x)
{
    return outer_MbR9((i - 1), x);
}

static int outer_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_MbR9(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_MbR9(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn inner_noret(i: i32)
            outer_noret(i - 1);

        fn outer_noret(implicit x: i32, i: i32)
            i > 0   ? inner_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_noret(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_noret_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_noret_MbR9(const int i, /*3:3*/ const int x)
{
    return outer_noret_MbR9((i - 1), x);
}

static int outer_noret_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_noret_MbR9(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_noret_MbR9(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        inline fn inner_inl(i: i32): i32
            outer_inl(i - 1);

        fn outer_inl(implicit x: i32, i: i32): i32
            i > 0   ? inner_inl(i)
                    : x + i;

        let implicit x = 7;
        return outer_inl(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_inl_MbR9(int, int);

#ifndef fu_NO_fdefs

static int outer_inl_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return outer_inl_MbR9((i - 1), x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_inl_MbR9(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn inner_templ(i): i32
            outer_templ(i - 1);

        fn outer_templ(implicit x: i32, i): i32
            i > 0   ? inner_templ(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int outer_templ_4pWy(int, int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_inner_templ_rAtreM46Blk
                                #define DEF_inner_templ_rAtreM46Blk
inline static int inner_templ_rAtr(const int i, /*3:3*/ const int x)
{
    return outer_templ_4pWy((i - 1), x);
}
                                #endif

                                #ifndef DEF_outer_templ_4pWyqWBLLs0
                                #define DEF_outer_templ_4pWyqWBLLs0
inline static int outer_templ_4pWy(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_templ_rAtr(i, x);
    else
        return x + i;

}
                                #endif

int fu_MAIN()
{
    const int x = 7;
    return outer_templ_4pWy(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn inner_templ_noret(i)
            outer_templ_noret(i - 1);

        fn outer_templ_noret(implicit x: i32, i)
            i > 0   ? inner_templ_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ_noret(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int outer_templ_noret_4pWy(int, int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_inner_templ_noret_rAtreM46Blk
                                #define DEF_inner_templ_noret_rAtreM46Blk
inline static int inner_templ_noret_rAtr(const int i, /*3:3*/ const int x)
{
    return outer_templ_noret_4pWy((i - 1), x);
}
                                #endif

                                #ifndef DEF_outer_templ_noret_4pWyqWBLLs0
                                #define DEF_outer_templ_noret_4pWyqWBLLs0
inline static int outer_templ_noret_4pWy(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_templ_noret_rAtr(i, x);
    else
        return x + i;

}
                                #endif

int fu_MAIN()
{
    const int x = 7;
    return outer_templ_noret_4pWy(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_MbR9(const int i, /*3:3*/ const int x)
{
    return outer_MbR9((i - (2 * x)), x);
}

static int outer_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_MbR9(i, x);
    else
        return 2 * i;

}

int fu_MAIN()
{
    const int x = 3;
    return outer_MbR9(6, x);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn has_implicit(implicit i: i32, add: i32): i32
            i + add;

        inline fn injects_implicit_while_inlined(): i32
            has_implicit(1); // broken by no ss.declash

        fn main() {
            let implicit i = 2;
            return injects_implicit_while_inlined() - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int has_implicit_MbR9(const int add, /*3:3*/ const int i)
{
    return i + add;
}

int fu_MAIN()
{
    const int i = 2;
    return has_implicit_MbR9(1, i) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        inline fn outer_inl(i: i32): i32
            i > 0   ? inner_inl(i)
                    : 2 * i;

        fn inner_inl(implicit x: i32, i: i32): i32
            outer_inl(i - 2 * x); // broken by no ss.declash

        let implicit x = 3;
        return outer_inl(6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int inner_inl_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_inl_MbR9(const int i, /*3:3*/ const int x)
{
    const int i_1 = (i - (2 * x));
    if (i_1 > 0)
        return inner_inl_MbR9(i_1, x);
    else
        return 2 * i_1;

}

int fu_MAIN()
{
    const int x = 3;
    const int i = 6;
    if (i > 0)
        return inner_inl_MbR9(i, x);
    else
        return 2 * i;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn outer_templ(i): i32
            i > 0   ? inner_templ(i)
                    : 2 * i;

        fn inner_templ(implicit x: i32, i): i32
            outer_templ(i - 2 * x);

        let implicit x = 3;
        return outer_templ(6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int outer_templ_iQCq(int, int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_inner_templ_MFa7aCmH9cf
                                #define DEF_inner_templ_MFa7aCmH9cf
inline static int inner_templ_MFa7(const int i, /*3:3*/ const int x)
{
    return outer_templ_iQCq((i - (2 * x)), x);
}
                                #endif

                                #ifndef DEF_outer_templ_iQCq7Neg4Uh
                                #define DEF_outer_templ_iQCq7Neg4Uh
inline static int outer_templ_iQCq(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_templ_MFa7(i, x);
    else
        return 2 * i;

}
                                #endif

int fu_MAIN()
{
    const int x = 3;
    return outer_templ_iQCq(6, x);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        fn inner(i: i32): i32
            outer(i - 1);

        let implicit x = 7;
        return outer(1) - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_MbR9(const int i, /*3:3*/ const int x)
{
    return outer_MbR9((i - 1), x);
}

static int outer_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_MbR9(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_MbR9(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn outer(implicit x: i32, i: i32)
            i > 0   ? inner(i)
                    : x + i;

        fn noret(i: i32) = outer(i);

        fn template(i) = i & 1 ? outer(i) : noret(i);

        fn inner(i: i32): i32
            template(i - 1);

        fn main() {
            let implicit x = 7;
            return outer(1) - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int);

#ifndef fu_NO_fdefs

static int noret_MbR9(const int i, /*3:3*/ const int x)
{
    return outer_MbR9(i, x);
}

                                #ifndef DEF_tEmplate_PgGlLappEA0
                                #define DEF_tEmplate_PgGlLappEA0
inline static int tEmplate_PgGl(const int i, /*3:3*/ const int x)
{
    if (i & 1)
        return outer_MbR9(i, x);
    else
        return noret_MbR9(i, x);

}
                                #endif

static int inner_MbR9(const int i, /*3:3*/ const int x)
{
    return tEmplate_PgGl((i - 1), x);
}

static int outer_MbR9(const int i, /*3:3*/ const int x)
{
    if (i > 0)
        return inner_MbR9(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_MbR9(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_1(call_self = false): i32
            = !call_self ? returns_x : calls_self_1 * 2;

        let implicit x = 7;
        return calls_self_1(true) - 14;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int calls_self_1_MbR9(bool, int);

#ifndef fu_NO_fdefs

static int returns_x_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int calls_self_1_MbR9(const bool call_self, /*3:3*/ const int x)
{
    if (!call_self)
        return returns_x_MbR9(x);
    else
        return calls_self_1_MbR9(false, x) * 2;

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_1_MbR9(true, x) - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_2(call_self = false): i32
            = call_self ? calls_self_2 * 3 : returns_x;

        let implicit x = 7;
        return calls_self_2(true) - 21;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int calls_self_2_MbR9(bool, int);

#ifndef fu_NO_fdefs

static int returns_x_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int calls_self_2_MbR9(const bool call_self, /*3:3*/ const int x)
{
    if (call_self)
        return calls_self_2_MbR9(false, x) * 3;
    else
        return returns_x_MbR9(x);

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_2_MbR9(true, x) - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_3(call_self = false): i32
        {
            let add = 1; // <- this wasnt visible
            fn do_call_self(mul: i32 = 0)
                = calls_self_3 * mul + add;

            return call_self ? do_call_self(4) : returns_x;
        }

        let implicit x = 7;
        return calls_self_3(true) - 29;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int calls_self_3_MbR9(bool, int);

#ifndef fu_NO_fdefs

static int do_call_self_MbR9(const int mul, /*7:7*/ const int add, /*7:7*/ const int x)
{
    return (calls_self_3_MbR9(false, x) * mul) + add;
}

static int returns_x_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int calls_self_3_MbR9(const bool call_self, /*3:3*/ const int x)
{
    const int add = 1;
    if (call_self)
        return do_call_self_MbR9(4, add, x);
    else
        return returns_x_MbR9(x);

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_3_MbR9(true, x) - 29;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn noret_x(implicit x: i32) x;

        fn templ_calls_self_2(call_self): i32
            = call_self ? templ_calls_self_2(false) * 3 : noret_x;

        fn main() {
            let implicit x = 7;
            return templ_calls_self_2(true) - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int templ_calls_self_2_hAnp(bool, int);

#ifndef fu_NO_fdefs

static int noret_x_MbR9(/*1:1*/ const int x)
{
    return x;
}

                                #ifndef DEF_templ_calls_self_2_hAnpK9S7YR4
                                #define DEF_templ_calls_self_2_hAnpK9S7YR4
inline static int templ_calls_self_2_hAnp(const bool call_self, /*3:3*/ const int x)
{
    if (call_self)
        return templ_calls_self_2_hAnp(false, x) * 3;
    else
        return noret_x_MbR9(x);

}
                                #endif

int fu_MAIN()
{
    const int x = 7;
    return templ_calls_self_2_hAnp(true, x) - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_JmCx;

                                #ifndef DEF_Range_JmCxkAzKfoh
                                #define DEF_Range_JmCxkAzKfoh
struct Range_JmCx
{
                                // shape_hash:    19317a06635e09ac
                                // non_triv_mask: 0000000000000000
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return r.max - r.min;
}

static int test_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return size_MbR9(r);
}

int fu_MAIN()
{
    const Range_JmCx r = Range_JmCx { 14, 21 };
    return test_MbR9(r) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Range_JmCx;

                                #ifndef DEF_Range_JmCxkAzKfoh
                                #define DEF_Range_JmCxkAzKfoh
struct Range_JmCx
{
                                // shape_hash:    19317a06635e09ac
                                // non_triv_mask: 0000000000000000
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return r.max - r.min;
}

static int inner_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return size_MbR9(r);
}

static int outer_MbR9(/*1:1*/ const Range_JmCx& r)
{
    return inner_MbR9(r);
}

int fu_MAIN()
{
    const Range_JmCx r = Range_JmCx { 14, 21 };
    return outer_MbR9(r) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let a = 1;
            let b = 2;
            let c = 3;

            fn depth1(x: i32) {
                fn depth2(y: i32) {
                    return sibling1(x + y + b);
                }

                return depth2(x + a);
            }

            fn sibling1(z: i32): i32 {
                return z + c;
            }

            return depth1(0) - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sibling1_MbR9(const int z, /*3:3*/ const int c)
{
    return z + c;
}

static int depth2_MbR9(const int y, /*F:F*/ const int x, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return sibling1_MbR9(((x + y) + b), c);
}

static int depth1_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return depth2_MbR9((x + a), x, b, c);
}

int fu_MAIN()
{
    const int a = 1;
    const int b = 2;
    const int c = 3;
    return depth1_MbR9(0, a, b, c) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn goto0(x): i32 = x ? goto0(x / 2) : 0;
        fn main() goto0(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int goto0_LJEw(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_goto0_LJEwsNTb6Qh
                                #define DEF_goto0_LJEwsNTb6Qh
inline static int goto0_LJEw(const int x)
{
    if (x)
        return goto0_LJEw((x / 2));
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    return goto0_LJEw(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn goto0(x) x ? goto0(x / 2) : 0;
        fn main() goto0(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int goto0_LJEw(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_goto0_LJEwsNTb6Qh
                                #define DEF_goto0_LJEwsNTb6Qh
inline static int goto0_LJEw(const int x)
{
    if (x)
        return goto0_LJEw((x / 2));
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    return goto0_LJEw(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above
        fn main() goto0(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int goto0_xyBg(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_goto0_xyBgptwkD1h
                                #define DEF_goto0_xyBgptwkD1h
inline static int goto0_xyBg(const int x)
{
    if (x)
        return goto0_xyBg((x / 2));
    else
        return x;

}
                                #endif

int fu_MAIN()
{
    return goto0_xyBg(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]
        fn main() goto0(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int goto0_kDdq(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_goto0_kDdq8YPFUug
                                #define DEF_goto0_kDdq8YPFUug
inline static int goto0_kDdq(const int x)
{
    if (x)
        return goto0_kDdq((x / 2));
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    return goto0_kDdq(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn ref_a(ref a: i32) a;

        fn main() {
            mut a: i32;
            ref r = ref_a(a);
            r++;
            return a - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int& ref_a_MbR9(/*1:1*/ int& a)
{
    return a;
}

int fu_MAIN()
{
    int a {};
    int& /*a*/ r = ref_a_MbR9(a);
    r++;
    return a - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ref_a_or_ref_b(ref a: i32, ref b: i32)
            a || b;

        fn main() {
            mut a: i32;
            mut b: i32;
            ref a_or_b = ref_a_or_ref_b(a, b);
            a_or_b++;
            return b - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int& ref_a_or_ref_b_MbR9(/*3:3*/ int& a, /*3:3*/ int& b)
{
    return a ? a : b;
}

int fu_MAIN()
{
    int a {};
    int b {};
    int& /*b|a*/ a_or_b = ref_a_or_ref_b_MbR9(a, b);
    a_or_b++;
    return b - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn impl(implicit ref _impl: i32) _impl;
        fn arg_or_impl(ref arg: i32) arg || impl;
        fn main() {
            implicit mut _impl: i32;
            mut arg: i32;
            ref ref = arg_or_impl(arg);
            return arg - ref;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int impl_kGbb(/*1:1*/ const int _impl)
{
    return _impl;
}

static int arg_or_impl_kGbb(/*3:3*/ const int arg, /*3:3*/ const int _impl)
{
    return arg ? arg : impl_kGbb(_impl);
}

int fu_MAIN()
{
    const int _impl {};
    const int arg {};
    const int /*arg|_impl*/ ref = arg_or_impl_kGbb(arg, _impl);
    return arg - ref;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {
            if (x == 0) return a;
            if (x == 1) return b;
            return hello(b, a, x / 17);
        }

        fn main() {
            mut a = [1, 2, 3];
            mut b = [4, 5, 6];
            hello(a, b, 397)[1] *= 5;
            return b[1] - 25;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

static fu::view_mut<int> hello_kGbb(fu::vec_range_mut<int>, fu::vec_range_mut<int>, int);

#ifndef fu_NO_fdefs

static fu::view_mut<int> hello_kGbb(/*7:7*/ fu::vec_range_mut<int> a, /*7:7*/ fu::vec_range_mut<int> b, const int x)
{
    if (x == 0)
        return a;
    else if (x == 1)
        return b;
    else
        return hello_kGbb(b, a, (x / 17));

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1, 2, 3 }};
    fu::vec<int> b = fu::vec<int> {{ 4, 5, 6 }};
    hello_kGbb(a, b, 397).mutref(1) *= 5;
    return b[1] - 25;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                ZERO( --x ); // Same as below but without the unused 'y' thing,
                sum += x;    //  everything works because the call to ZERO isnt really unconditional,
            }                //   and if it were, then the never return would actually be correct.
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
void ZERO_MbR9(int, int&);

#ifndef fu_NO_fdefs

void ZERO_MbR9(int x, /*3:2*/ int& sum)
{
    while (x)
    {
        ZERO_MbR9(--x, sum);
        sum += x;
    };
}

int fu_MAIN()
{
    int sum = 0;
    ZERO_MbR9(4, sum);
    return sum - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_UnusedImplicit, N_UnusedCall

========

        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                let y = x / 2;
                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,
                ZERO(   y ); //  meaning y remains unused here on first solve.
                sum += x;
            }
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
void ZERO_MbR9(int, int&);

#ifndef fu_NO_fdefs

void ZERO_MbR9(int x, /*3:2*/ int& sum)
{
    while (x)
    {
        const int y = (x / 2);
        ZERO_MbR9(--x, sum);
        ZERO_MbR9(y, sum);
        sum += x;
    };
}

int fu_MAIN()
{
    int sum = 0;
    ZERO_MbR9(4, sum);
    return sum - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_UnusedImplicit, N_UnusedCall, N_UnusedLet

========

        struct Node {
            items: Node[];
        }

        fn solve(root: Node)
        {
            fn solveBlock(node: Node) {
                let items = solveNodes(node.items);
                return solveBlock(items);                       // ConstCast
            }

            fn solveBlock(items: i32[]) {
                if (!Lifetime_allowsMutrefReturn(items))
                    throw("Nope!");

                return items;
            }

            fn solveNode(node: Node, implicit ref next: i32) {
                if (!node.items)
                    return [ next++ ];

                let implicit CTX = node.items.len; // <- this shows up as an closure-arg with an outdated revision
                return solveBlock(node);
            }

            fn Lifetime_each(items, visit)
                for (mut i = items.len; i --> 0; )
                    visit(items[i]);

            fn Lifetime_allowsMutrefReturn(items: i32[]) {
                Lifetime_each(:items, visit: |item, implicit CTX: i32| {
                    if (item == CTX)
                        return false;
                });

                return true;
            }

            fn solveNodes(nodes: Node[]) {
                mut result: i32[];
                for (mut i = 0; i < nodes.len; i++)
                    result ~= solveNode(nodes[i]);

                return result;
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut next = 0;

            let solve = solve(Node([
                Node([ Node ]),
                Node(),
            ]));

            return solve.len - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Node_zYlo;
static fu::vec<int> solveNode_MbR9(const Node_zYlo&, int&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> solveNodes_MbR9(/*3:3*/ fu::view<Node_zYlo> nodes, /*2:2*/ int& next)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < nodes.size(); i++)
        result += solveNode_MbR9(nodes[i], next);

    return /*NRVO*/ result;
}

static bool Lifetime_allowsMutrefReturn_MbR9(/*3:3*/ fu::view<int> items, /*3:3*/ const int CTX)
{
    for (int i = items.size(); i-- > 0; )
    {
        const int /*items|static*/ item = items[i];
        if (item == CTX)
            return false;

    };
    return true;
}

static fu::vec_range<int> solveBlock_kGbb(/*3:3*/ fu::vec_range<int> items, /*3:3*/ const int CTX)
{
    if (!Lifetime_allowsMutrefReturn_MbR9(items, CTX))
        fu::fail(fu::str("Nope!"_fu));
    else
        return items;

}

static fu::vec<int> solveBlock_MbR9(/*7:7*/ const Node_zYlo& node, /*7:7*/ const int CTX, /*6:4*/ int& next)
{
    /*MOV*/ fu::vec<int> items = solveNodes_MbR9(node.items, next);
    return solveBlock_kGbb(items, CTX).const_cast_mut().destructive_move();
}

static fu::vec<int> solveNode_MbR9(/*3:3*/ const Node_zYlo& node, /*2:2*/ int& next)
{
    if (!node.items)
    {
        return fu::vec<int> {{ next++ }};
    }
    else
    {
        const int CTX = node.items.size();
        return solveBlock_MbR9(node, CTX, next);
    };
}

static fu::vec<int> solve_MbR9(/*3:3*/ const Node_zYlo& root, /*2:2*/ int& next)
{
    return solveNode_MbR9(root, next);
}

int fu_MAIN()
{
    int next = 0;
    fu::vec<int> solve = solve_MbR9(Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{} }} }, Node_zYlo{} }} }, next);
    return solve.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_UnusedCall, N_UnusedLet

========

        fn woot(implicit x: i32) = x;

        fn main() {


            return woot() - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:20+4[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            return [31;1mwoot[0m() - 2;
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mx[0m: [35;3mi32[0m in scope, needed to call [35;3mfn[0m [94;1mwoot[0m:

            because of [35;3mimplicit arg[0m [94;1mx[0m at [2m2:26+1[0m:

[2m      | [0m
[2m    2 | [0m        fn woot(implicit [31;1mx[0m: i32) = x;
[2m      | [0m
[2m      |         fn main() {[0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn woot(implicit x: i32) = x;

        fn main() {

            let implicit x = 2;

            return woot() - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int woot_MbR9(/*1:1*/ const int x)
{
    return x;
}

int fu_MAIN()
{
    const int x = 2;
    return woot_MbR9(x) - 2;
}

#endif

int main() { return fu_MAIN(); }

========


        fn woot(implicit y: i32) = y;


        fn hey() {
            let implicit x = 2;
            return woot() - 2;
        }

        let here = hey();
        fn main() = here;

---- <fail> ----
[2m[0m_0[2m.fu 11:20+3[0m:

[2m      |         }[0m
[2m      | [0m
[2m   11 | [0m        let here = [31;1mhey[0m();
[2m      |         fn main() = here;[0m
[2m      | [0m

	No implicit [31;1my[0m: [35;3mi32[0m in scope, needed to call [35;3mfn[0m [94;1mhey[0m:

            because of call to [35;3mfn[0m [94;1mwoot[0m at [2m8:20+4[0m:

[2m      |         fn hey() {[0m
[2m      |             let implicit x = 2;[0m
[2m    8 | [0m            return [31;1mwoot[0m() - 2;
[2m      |         }[0m
[2m      | [0m

            because of [35;3mimplicit arg[0m [94;1my[0m at [2m3:26+1[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn woot(implicit [31;1my[0m: i32) = y;
[2m      | [0m
[2m      | [0m


========


        fn woot(implicit x: i32) = x;


        fn hey() {
            let implicit x = 2;
            return woot() - 2;
        }

        let here = hey();
        fn main() = here;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int woot_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int hey_MbR9()
{
    const int x = 2;
    return woot_MbR9(x) - 2;
}

static const int here = hey_MbR9();

int fu_MAIN()
{
    return here;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn main() {
            mut x = +1;
            mut y: typeof(x) = -x;
            return x + y;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = +1;
    const int y = -x;
    return x + y;
}

#endif

int main() { return fu_MAIN(); }

========

        // N_UnusedImplicit
        fn dont_inject_my_implicit_args(implicit unused_implicit_arg: i32) {
            return unused_implicit_arg;
        }

        fn not_extern() {
            mut x: typeof(dont_inject_my_implicit_args) = 2;
            return x;
        }

        fn not_extern(mut x: typeof(dont_inject_my_implicit_args)) {
            return x;
        }

        fn main() {
            return not_extern() + not_extern(-2);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int not_extern_MbR9()
{
    const int x = 2;
    return x;
}

static int not_extern_kGbb(const int x)
{
    return x;
}

int fu_MAIN()
{
    return not_extern_MbR9() + not_extern_kGbb(-2);
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit

========

        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {

            x *= 3;             
        }

        fn main() {
            mut x = 7;
            implicit forgot_to_use = 3;
            mustwarn_unused_implicit(x);
            return x == forgot_to_use * 7 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 2:46+13[0m:

[2m      | [0m
[2m    2 | [0m        fn mustwarn_unused_implicit(implicit [31;1mforgot_to_use[0m: i32, ref x: i32) {
[2m      | [0m
[2m      |             x *= 3;             [0m

	Unused variable: [35;3mimplicit arg[0m [94;1mforgot_to_use[0m. Make it [35;3mlax[0m if this is intentional.

========

        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {

            x *= forgot_to_use; 
        }

        fn main() {
            mut x = 7;
            implicit forgot_to_use = 3;
            mustwarn_unused_implicit(x);
            return x == forgot_to_use * 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void mustwarn_unused_implicit_MbR9(/*3:3*/ int& x, /*3:3*/ const int forgot_to_use)
{
    x *= forgot_to_use;
}

int fu_MAIN()
{
    int x = 7;
    const int forgot_to_use = 3;
    mustwarn_unused_implicit_MbR9(x, forgot_to_use);
    if (x == (forgot_to_use * 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn log_append(implicit ref log_out: string, str: string)
            log_out ~= str;

        let VERBOSE = false;                                    // !DEV_DontFoldLiterals

        fn verbose(implicit ref log_events: i32, inline stuff: string)
        {
            if (VERBOSE) log_append(stuff);
            log_events++;
        }

        fn main() {

            implicit     mut log_out: string; 

            implicit mut log_events: i32;
            verbose("Hello!");
            verbose("World!");

            return log_events == 2 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 15:30+7[0m:

[2m      |         fn main() {[0m
[2m      | [0m
[2m   15 | [0m            implicit     mut [31;1mlog_out[0m: string; 
[2m      | [0m
[2m      |             implicit mut log_events: i32;[0m

	Unused variable: [35;3mimplicit[0m [94;1mlog_out[0m. Make it [35;3mlax[0m if this is intentional.

========

        fn log_append(implicit ref log_out: string, str: string)
            log_out ~= str;

        let VERBOSE = false;                                    // !DEV_DontFoldLiterals

        fn verbose(implicit ref log_events: i32, inline stuff: string)
        {
            if (VERBOSE) log_append(stuff);
            log_events++;
        }

        fn main() {

            implicit lax mut log_out: string; 

            implicit mut log_events: i32;
            verbose("Hello!");
            verbose("World!");

            return log_events == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int log_events {};
    log_events++;
    log_events++;
    if (log_events == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet, N_SD_HasStaticInit

========

        struct NeverImported { x: i32 };
        fn wrap(x: i32) NeverImported(x * 10);

        fn rec(y: i32)
            if (y < 0)  return _0::wrap(rec(y + 7).x);
            else        return _0::wrap(y);

        fn main() rec(-2).x - 500;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NeverImported_AdlE;
static NeverImported_AdlE rec_LtD7(int);
NeverImported_AdlE wrap_MbR9(int);

                                #ifndef DEF_NeverImported_AdlEu9aqnHc
                                #define DEF_NeverImported_AdlEu9aqnHc
struct NeverImported_AdlE
{
                                // shape_hash:    e90abc86a1babe39
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NeverImported_AdlE rec_LtD7(const int y)
{
    if (y < 0)
        return wrap_MbR9(rec_LtD7((y + 7)).x);
    else
        return wrap_MbR9(y);

}

int fu_MAIN()
{
    return rec_LtD7(-2).x - 500;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode
struct NeverImported_AdlE;

                                #ifndef DEF_NeverImported_AdlEu9aqnHc
                                #define DEF_NeverImported_AdlEu9aqnHc
struct NeverImported_AdlE
{
                                // shape_hash:    e90abc86a1babe39
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

NeverImported_AdlE wrap_MbR9(const int x)
{
    return NeverImported_AdlE { (x * 10) };
}

#endif

========

        fn wantsImplicit(implicit ref x: i32) = x++;

        fn main() {
  
            return _0::wantsImplicit();
        }

---- <fail> ----
[2m[0m_1[2m.fu 4:24+13[0m:

[2m      |         fn main() {[0m
[2m      |   [0m
[2m    4 | [0m            return _0::[31;1mwantsImplicit[0m();
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mx[0m: [35;3mmut[0m [35;3mref[0m [35;3mi32[0m in scope, needed to call [35;3mfn[0m [94;1mwantsImplicit[0m:

            because of [35;3mimplicit mut ref arg[0m [94;1mx[0m at [2m[0m_0[2m.fu 2:39+1[0m:

[2m      | [0m
[2m    2 | [0m        fn wantsImplicit(implicit ref [31;1mx[0m: i32) = x++;
[2m      | [0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn wantsImplicit(implicit ref x: i32) = x++;

        fn main() {

            implicit mut x: i32 = 0;            
            return _0::wantsImplicit();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int wantsImplicit_MbR9(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;
    return wantsImplicit_MbR9(x);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int wantsImplicit_MbR9(/*1:1*/ int& x)
{
    return x++;
}

#endif

========

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;

        import _0;
        import _2;
        fn solvePrelude(d: i32) {

            return cleanID(d) + 5;
        }

        let CTX_PRELUDE =
            solvePrelude(7);

        fn main() =
            CTX_PRELUDE - 17;

---- <fail> ----
[2m[0m_3[2m.fu 10:13+12[0m:

[2m      | [0m
[2m      |         let CTX_PRELUDE =[0m
[2m   10 | [0m            [31;1msolvePrelude[0m(7);
[2m      | [0m
[2m      |         fn main() =[0m

	No implicit [31;1ma[0m: [35;3mstruct[0m [94;1mTokenIdx[0m in scope, needed to call [35;3mfn[0m [94;1msolvePrelude[0m:

            because of call to [35;3mfn[0m [94;1mcleanID[0m at [2m6:20+7[0m:

[2m      |         fn solvePrelude(d: i32) {[0m
[2m      | [0m
[2m    6 | [0m            return [31;1mcleanID[0m(d) + 5;
[2m      |         }[0m
[2m      | [0m

            because of call to [35;3mfn[0m [94;1mfail[0m at [2m[0m_2[2m.fu 4:13+4[0m:

[2m      |         import _1;[0m
[2m      |         fn cleanID(c: i32) =[0m
[2m    4 | [0m            [31;1mfail[0m(c) + 3;
[2m      | [0m

            because of [35;3mimplicit arg[0m [94;1ma[0m at [2m[0m_1[2m.fu 3:26+1[0m:

[2m      | [0m
[2m      |         import _0;[0m
[2m    3 | [0m        fn fail(implicit [31;1ma[0m: TokenIdx, b: i32) =
[2m      |             a.id + b;[0m
[2m      | [0m


========

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;

        import _0;
        import _2;
        fn solvePrelude(d: i32) {

            let implicit a: TokenIdx = TokenIdx(2);                 
            return cleanID(d) + 5;
        }

        let CTX_PRELUDE =
            solvePrelude(7);

        fn main() =
            CTX_PRELUDE - 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct TokenIdx_rs5V;
int cleanID_WLF9(int, const TokenIdx_rs5V&);

                                #ifndef DEF_TokenIdx_rs5VEhi6MF0
                                #define DEF_TokenIdx_rs5VEhi6MF0
struct TokenIdx_rs5V
{
                                // shape_hash:    f0f04fec53429d70
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int solvePrelude_IdlH(const int d)
{
    const TokenIdx_rs5V a = TokenIdx_rs5V { 2 };
    return cleanID_WLF9(d, a) + 5;
}

static const int CTX_PRELUDE = solvePrelude_IdlH(7);

int fu_MAIN()
{
    return CTX_PRELUDE - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit
struct TokenIdx_rs5V;
int fail_LtD7(int, const TokenIdx_rs5V&);

                                #ifndef DEF_TokenIdx_rs5VEhi6MF0
                                #define DEF_TokenIdx_rs5VEhi6MF0
struct TokenIdx_rs5V
{
                                // shape_hash:    f0f04fec53429d70
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int cleanID_WLF9(const int c, /*3:3*/ const TokenIdx_rs5V& a)
{
    return fail_LtD7(c, a) + 3;
}

#endif
struct TokenIdx_rs5V;

                                #ifndef DEF_TokenIdx_rs5VEhi6MF0
                                #define DEF_TokenIdx_rs5VEhi6MF0
struct TokenIdx_rs5V
{
                                // shape_hash:    f0f04fec53429d70
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fail_LtD7(const int b, /*3:3*/ const TokenIdx_rs5V& a)
{
    return a.id + b;
}

#endif

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    let climb = fn visit;                               

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void visit_5o7n(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_D3yBRDyrCYc
                                #define DEF_each_D3yBRDyrCYc
inline static void each_D3yB(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        visit_5o7n(init, result);

}
                                #endif

                                #ifndef DEF_visit_5o7nyPPSIbk
                                #define DEF_visit_5o7nyPPSIbk
inline static void visit_5o7n(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < chars.size(); i++)
        each_D3yB(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_KsFCMuqhXS4
                                #define DEF_Lifetime_process_KsFCMuqhXS4
inline static void Lifetime_process_KsFC(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    visit_5o7n(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_KsFC("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    let climb = fn visit;                               

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void visit_5o7n(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_D3yBRDyrCYc
                                #define DEF_each_D3yBRDyrCYc
inline static void each_D3yB(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        visit_5o7n(init, result);

}
                                #endif

                                #ifndef DEF_visit_5o7nyPPSIbk
                                #define DEF_visit_5o7nyPPSIbk
inline static void visit_5o7n(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        each_D3yB(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_KsFCMuqhXS4
                                #define DEF_Lifetime_process_KsFCMuqhXS4
inline static void Lifetime_process_KsFC(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    visit_5o7n(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_KsFC("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent: string) visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void visit_did7(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_9Iy5F0MPqk5
                                #define DEF_climb_9Iy5F0MPqk5
inline static void climb_9Iy5(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::vec_range_mut<char> result)
{
    visit_did7(parent, result);
}
                                #endif

                                #ifndef DEF_each_m371QK1RkB0
                                #define DEF_each_m371QK1RkB0
inline static void each_m371(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        climb_9Iy5(init, result);

}
                                #endif

                                #ifndef DEF_visit_did7UOcwvYh
                                #define DEF_visit_did7UOcwvYh
inline static void visit_did7(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < chars.size(); i++)
        each_m371(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_Y1yqpwKMoJ6
                                #define DEF_Lifetime_process_Y1yqpwKMoJ6
inline static void Lifetime_process_Y1yq(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    visit_did7(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_Y1yq("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent: string) visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void visit_did7(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_9Iy5F0MPqk5
                                #define DEF_climb_9Iy5F0MPqk5
inline static void climb_9Iy5(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::str& result)
{
    visit_did7(parent, result);
}
                                #endif

                                #ifndef DEF_each_m371QK1RkB0
                                #define DEF_each_m371QK1RkB0
inline static void each_m371(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        climb_9Iy5(init, result);

}
                                #endif

                                #ifndef DEF_visit_did7UOcwvYh
                                #define DEF_visit_did7UOcwvYh
inline static void visit_did7(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        each_m371(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_Y1yqpwKMoJ6
                                #define DEF_Lifetime_process_Y1yqpwKMoJ6
inline static void Lifetime_process_Y1yq(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    visit_did7(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_Y1yq("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent: string)   visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void visit_4EmS(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_tXCf3ZC5K91
                                #define DEF_each_tXCf3ZC5K91
inline static void each_tXCf(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
    {
        fu::view<char> /*init*/ parent = init;
        visit_4EmS(parent, result);
    };
}
                                #endif

                                #ifndef DEF_visit_4EmSIK8MePj
                                #define DEF_visit_4EmSIK8MePj
inline static void visit_4EmS(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < chars.size(); i++)
        each_tXCf(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_VbdeZuS1pj3
                                #define DEF_Lifetime_process_VbdeZuS1pj3
inline static void Lifetime_process_Vbde(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    visit_4EmS(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_Vbde("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent: string)   visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void visit_4EmS(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_tXCf3ZC5K91
                                #define DEF_each_tXCf3ZC5K91
inline static void each_tXCf(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
    {
        fu::view<char> /*init*/ parent = init;
        visit_4EmS(parent, result);
    };
}
                                #endif

                                #ifndef DEF_visit_4EmSIK8MePj
                                #define DEF_visit_4EmSIK8MePj
inline static void visit_4EmS(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        each_tXCf(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_VbdeZuS1pj3
                                #define DEF_Lifetime_process_VbdeZuS1pj3
inline static void Lifetime_process_Vbde(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    visit_4EmS(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_Vbde("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent)         visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void visit_did7(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_9Iy5F0MPqk5
                                #define DEF_climb_9Iy5F0MPqk5
inline static void climb_9Iy5(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::vec_range_mut<char> result)
{
    visit_did7(parent, result);
}
                                #endif

                                #ifndef DEF_each_m371QK1RkB0
                                #define DEF_each_m371QK1RkB0
inline static void each_m371(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        climb_9Iy5(init, result);

}
                                #endif

                                #ifndef DEF_visit_did7UOcwvYh
                                #define DEF_visit_did7UOcwvYh
inline static void visit_did7(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < chars.size(); i++)
        each_m371(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_Y1yqpwKMoJ6
                                #define DEF_Lifetime_process_Y1yqpwKMoJ6
inline static void Lifetime_process_Y1yq(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    visit_did7(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_Y1yq("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent)         visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void visit_did7(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_climb_9Iy5F0MPqk5
                                #define DEF_climb_9Iy5F0MPqk5
inline static void climb_9Iy5(/*3:3*/ fu::view<char> parent, /*2:2*/ fu::str& result)
{
    visit_did7(parent, result);
}
                                #endif

                                #ifndef DEF_each_m371QK1RkB0
                                #define DEF_each_m371QK1RkB0
inline static void each_m371(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
        climb_9Iy5(init, result);

}
                                #endif

                                #ifndef DEF_visit_did7UOcwvYh
                                #define DEF_visit_did7UOcwvYh
inline static void visit_did7(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        each_m371(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_Y1yqpwKMoJ6
                                #define DEF_Lifetime_process_Y1yqpwKMoJ6
inline static void Lifetime_process_Y1yq(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    visit_did7(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_Y1yq("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent)           visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

inline static void visit_4EmS(fu::view<char>, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_tXCf3ZC5K91
                                #define DEF_each_tXCf3ZC5K91
inline static void each_tXCf(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
    {
        fu::view<char> /*init*/ parent = init;
        visit_4EmS(parent, result);
    };
}
                                #endif

                                #ifndef DEF_visit_4EmSIK8MePj
                                #define DEF_visit_4EmSIK8MePj
inline static void visit_4EmS(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < chars.size(); i++)
        each_tXCf(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_VbdeZuS1pj3
                                #define DEF_Lifetime_process_VbdeZuS1pj3
inline static void Lifetime_process_Vbde(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::vec_range_mut<char> result)
{
    visit_4EmS(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = fu::str(""_fu);
    Lifetime_process_Vbde("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent)           visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

inline static void visit_4EmS(fu::view<char>, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_tXCf3ZC5K91
                                #define DEF_each_tXCf3ZC5K91
inline static void each_tXCf(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    result += lt;
    fu::view<char> init {};
    if (init.ptr_reassign((!lt ? lt : fu::get_view(lt, 0, (lt.size() - 1)))))
    {
        fu::view<char> /*init*/ parent = init;
        visit_4EmS(parent, result);
    };
}
                                #endif

                                #ifndef DEF_visit_4EmSIK8MePj
                                #define DEF_visit_4EmSIK8MePj
inline static void visit_4EmS(/*3:3*/ fu::view<char> chars, /*2:2*/ fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        each_tXCf(fu::get_view(chars, i, chars.size()), result);

}
                                #endif

                                #ifndef DEF_Lifetime_process_VbdeZuS1pj3
                                #define DEF_Lifetime_process_VbdeZuS1pj3
inline static void Lifetime_process_Vbde(/*7:7*/ fu::view<char> lt, /*6:6*/ fu::str& result)
{
    visit_4EmS(lt, result);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result {};
    Lifetime_process_Vbde("abc"_view, result);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse, N_UnusedLet

========

        struct Helper { id: i32; type: string };

        fn main() {
            mut helpers = [
                Helper(13, "This is a long string, shouldn't fit in small string opti."),
            ];

            fn solveNode(

                ref 
                type: string) {
                helpers && helpers.pop();
                return type;
            }

            mut fallback: string;
            fn lookup(id: i32) {
                helpers.each: |ref h| if (h.id == id) return h.type;
                return fallback;
            }

            mut str = solveNode(lookup(13));
            str ~= str;
            return helpers.len * 1000 + str.len - 116;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:23+9[0m:

[2m      |             }[0m
[2m      | [0m
[2m   23 | [0m            mut str = [31;1msolveNode[0m(lookup(13));
[2m      |             str ~= str;[0m
[2m      |             return helpers.len * 1000 + str.len - 116;[0m

	At call to [35;3mfn[0m [94;1msolveNode[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1msolveNode[0m:[94;1mmain:helpers[0m and
	    1:	[35;3mref arg[0m [94;1msolveNode[0m:[94;1mtype[0m

	    both alias:

	    [35;3mmut[0m [94;1mhelpers[0m at [2m5:17+7[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mhelpers[0m = [
[2m      |                 Helper(13, "This is a long string, shouldn't fit in small string opti."),[0m
[2m      |             ];[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1msolveNode[0m:[94;1mmain:helpers[0m is [31;1mimplicit[0m

	    [35;3mref arg[0m [94;1msolveNode[0m:[94;1mtype[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct Helper { id: i32; type: string };

        fn main() {
            mut helpers = [
                Helper(13, "This is a long string, shouldn't fit in small string opti."),
            ];

            fn solveNode(

                mut 
                type: string) {
                helpers && helpers.pop();
                return type;
            }

            mut fallback: string;
            fn lookup(id: i32) {
                helpers.each: |ref h| if (h.id == id) return h.type;
                return fallback;
            }

            mut str = solveNode(lookup(13));
            str ~= str;
            return helpers.len * 1000 + str.len - 116;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(464) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Helper_FE01;

                                #ifndef DEF_Helper_FE01eGZXyei
                                #define DEF_Helper_FE01eGZXyei
struct Helper_FE01
{
                                // shape_hash:    130a0ec9178a464d
                                // non_triv_mask: 0000800000002000
    int id;
    fu::str type;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || type
        ;
    }
};
                                #endif

                                #ifndef STR_oXVaaEPM7pe
                                #define STR_oXVaaEPM7pe
static const fu::str str_oXVaaEPM7pe fu_INIT_PRIORITY(1001) { "This is a long string, shouldn't fit in small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& lookup_kGbb(const int id, /*7:7*/ fu::view<Helper_FE01> helpers, /*7:7*/ const fu::str& fallback)
{
    for (int i = 0; i < helpers.size(); i++)
    {
        const Helper_FE01& /*helpers|static*/ h = helpers[i];
        if (h.id == id)
            return h.type;

    };
    return fallback;
}

static fu::str solveNode_MbR9(/*MOV*/ fu::str&& type, /*3:2*/ fu::vec_range_mut<Helper_FE01> helpers)
{
    if (helpers)
        helpers.pop();

    return type.destructive_move();
}

int fu_MAIN()
{
    fu::vec<Helper_FE01> helpers = fu::vec<Helper_FE01> {{ Helper_FE01 { 13, fu::str(str_oXVaaEPM7pe) } }};
    fu::str fallback {};
    fu::str str = solveNode_MbR9(fu::str(lookup_kGbb(13, helpers, fallback)), helpers);
    str += fu::str(/*bck:vi 0*/ str);
    return ((helpers.size() * 1000) + str.size()) - 116;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Helper { id: i32; type: string };

        fn main() {
            mut helpers = [
                Helper(13, "This is a long string, shouldn't fit in small string opti."),
            ];

            fn solveNode(

                mut 
                type: string) {
                helpers && helpers.pop();
                return type;
            }

            mut fallback: string;
            fn lookup(id: i32) {
                helpers.each: |ref h| if (h.id == id) return h.type;
                return fallback;
            }

            mut str = solveNode(lookup(13));
            str ~= str;
            return helpers.len * 1000 + str.len - 116;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(464) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Helper_FE01;

                                #ifndef DEF_Helper_FE01eGZXyei
                                #define DEF_Helper_FE01eGZXyei
struct Helper_FE01
{
                                // shape_hash:    130a0ec9178a464d
                                // non_triv_mask: 0000800000002000
    int id;
    fu::str type;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || type
        ;
    }
};
                                #endif

                                #ifndef STR_oXVaaEPM7pe
                                #define STR_oXVaaEPM7pe
static const fu::str str_oXVaaEPM7pe fu_INIT_PRIORITY(1001) { "This is a long string, shouldn't fit in small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& lookup_kGbb(const int id, /*7:7*/ fu::view<Helper_FE01> helpers, /*7:7*/ const fu::str& fallback)
{
    for (int i = 0; i < helpers.size(); i++)
    {
        const Helper_FE01& /*helpers|static*/ h = helpers[i];
        if (h.id == id)
            return h.type;

    };
    return fallback;
}

static fu::str solveNode_MbR9(/*MOV*/ fu::str&& type, /*3:2*/ fu::vec<Helper_FE01>& helpers)
{
    if (helpers)
        helpers.pop();

    return type.destructive_move();
}

int fu_MAIN()
{
    fu::vec<Helper_FE01> helpers = fu::vec<Helper_FE01> {{ Helper_FE01 { 13, fu::str(str_oXVaaEPM7pe) } }};
    fu::str fallback {};
    fu::str str = solveNode_MbR9(fu::str(lookup_kGbb(13, helpers, fallback)), helpers);
    str += fu::str(/*bck:vi 0*/ str);
    return ((helpers.size() * 1000) + str.size()) - 116;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here

                val type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 28:24+9[0m:

[2m      |                 let h       = Scope_lookupLabel(node.value);[0m
[2m      |                 let n_expr  = node.items && node.items[0];[0m
[2m   28 | [0m                return [31;1msolveNode[0m(n_expr, type: h.ret_actual);
[2m      |             }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1msolveNode[0m, arguments:

	    3:	[35;3minjected implicit ref arg[0m [94;1msolveNode[0m:[94;1m_helpers[0m and
	    2:	[35;3marg[0m [94;1msolveNode[0m:[94;1mtype[0m

	    both alias:

	    [35;3minjected implicit mut ref arg[0m [94;1m_helpers[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1msolveNode[0m:[94;1m_helpers[0m is [31;1mimplicit[0m

	    [35;3marg[0m [94;1msolveNode[0m:[94;1mtype[0m is ref-returned from [35;3mfn[0m [94;1msolveNode[0m

    BorrowCheck [35;3mfn[0m [94;1msolveJump[0m([94;1mNode[0m, [94;1mHelpers[0m[35;3m[..][0m) at [2m25:16+9[0m
        Solving [35;3mfn[0m [94;1mtest[0m([94;1mNode[0m, [94;1mHelpers[0m[35;3m[..][0m) at [2m10:12+4[0m

========

        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here

                mut

                val type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Helpers_DBUf;
struct Type_KHQj;
enum Kind_okcz: fu::u8;
struct Node_o9cQ;
static Type_KHQj solveNode_MbR9(const Node_o9cQ&, Type_KHQj&&, fu::vec_range_mut<Helpers_DBUf>);

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_DBUfXvgvgXf
                                #define DEF_Helpers_DBUfXvgvgXf
struct Helpers_DBUf
{
                                // shape_hash:    5dc061748ea29d9b
                                // non_triv_mask: 0000920000000000
    fu::str id;
    Type_KHQj ret_actual;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || ret_actual
        ;
    }
};
                                #endif

                                #ifndef DEF_Kind_okcz
                                #define DEF_Kind_okcz
enum Kind_okcz: fu::u8
{
    Kind_okcz_return = 1u,
    Kind_okcz_expr = 2u,
};
                                #endif

                                #ifndef DEF_Node_o9cQ2pU3Wm9
                                #define DEF_Node_o9cQ2pU3Wm9
struct Node_o9cQ
{
                                // shape_hash:    650416a0a05332d6
                                // non_triv_mask: 0000840000000000
    Kind_okcz kind;
    fu::str value;
    fu::vec<Node_o9cQ> items;
    Node_o9cQ(const Node_o9cQ&) = default;
    Node_o9cQ(Node_o9cQ&&) = default;
    Node_o9cQ& operator=(Node_o9cQ&&) = default;
    Node_o9cQ& operator=(const Node_o9cQ& selfrec) { return *this = Node_o9cQ(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static const Helpers_DBUf& Scope_lookupLabel_MbR9(/*3:3*/ fu::view<char> id, /*3:3*/ fu::view<Helpers_DBUf> _helpers)
{
    for (int i = 0; i < _helpers.size(); i++)
    {
        const Helpers_DBUf& /*_helpers|static*/ item = _helpers[i];
        if (item.id == id)
            return item;

    };
    fu::fail((("No label '"_view + id) + "' in scope."_view));
}

static Type_KHQj solveJump_MbR9(/*3:3*/ const Node_o9cQ& node, /*3:3*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    const Helpers_DBUf& /*_helpers|static*/ h = Scope_lookupLabel_MbR9(node.value, _helpers);
    const Node_o9cQ& /*node|zeroes|static*/ n_expr = (node.items ? node.items[0] : (*(Node_o9cQ*)fu::NIL));
    return solveNode_MbR9(n_expr, Type_KHQj(h.ret_actual), _helpers);
}

static void Scope_pop_MbR9(/*1:1*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    if (_helpers)
        _helpers.pop();

}

static Type_KHQj solveNode_MbR9(/*7:7*/ const Node_o9cQ& node, /*MOV*/ Type_KHQj&& type, /*5:5*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    if (node.kind == Kind_okcz_return)
        return solveJump_MbR9(node, _helpers);
    else
    {
        Scope_pop_MbR9(_helpers);
        return static_cast<Type_KHQj&&>(type);
    };
}

static Type_KHQj test_MbR9(/*3:3*/ const Node_o9cQ& root, fu::vec<Helpers_DBUf>&& _helpers)
{
    return solveNode_MbR9(root, Type_KHQj{}, _helpers);
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<Helpers_DBUf> _helpers = fu::vec<Helpers_DBUf> {{ Helpers_DBUf { fu::str("hello"_fu), Type_KHQj { fu::str("Hello"_fu) } }, Helpers_DBUf { fu::str("world"_fu), Type_KHQj { fu::str("World"_fu) } } }};
    Type_KHQj res = test_MbR9(Node_o9cQ { Kind_okcz_return, fu::str("world"_fu), fu::vec<Node_o9cQ> {{ Node_o9cQ { Kind_okcz_expr, fu::str("hello"_fu), fu::vec<Node_o9cQ>{} } }} }, _helpers.destructive_move());
    if (res.canon == "World"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here

                mut

                val type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Helpers_DBUf;
struct Type_KHQj;
enum Kind_okcz: fu::u8;
struct Node_o9cQ;
static Type_KHQj solveNode_MbR9(const Node_o9cQ&, Type_KHQj&&, fu::vec_range_mut<Helpers_DBUf>);

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_DBUfXvgvgXf
                                #define DEF_Helpers_DBUfXvgvgXf
struct Helpers_DBUf
{
                                // shape_hash:    5dc061748ea29d9b
                                // non_triv_mask: 0000920000000000
    fu::str id;
    Type_KHQj ret_actual;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || ret_actual
        ;
    }
};
                                #endif

                                #ifndef DEF_Kind_okcz
                                #define DEF_Kind_okcz
enum Kind_okcz: fu::u8
{
    Kind_okcz_return = 1u,
    Kind_okcz_expr = 2u,
};
                                #endif

                                #ifndef DEF_Node_o9cQ2pU3Wm9
                                #define DEF_Node_o9cQ2pU3Wm9
struct Node_o9cQ
{
                                // shape_hash:    650416a0a05332d6
                                // non_triv_mask: 0000840000000000
    Kind_okcz kind;
    fu::str value;
    fu::vec<Node_o9cQ> items;
    Node_o9cQ(const Node_o9cQ&) = default;
    Node_o9cQ(Node_o9cQ&&) = default;
    Node_o9cQ& operator=(Node_o9cQ&&) = default;
    Node_o9cQ& operator=(const Node_o9cQ& selfrec) { return *this = Node_o9cQ(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static const Helpers_DBUf& Scope_lookupLabel_MbR9(/*3:3*/ fu::view<char> id, /*3:3*/ fu::view<Helpers_DBUf> _helpers)
{
    for (int i = 0; i < _helpers.size(); i++)
    {
        const Helpers_DBUf& /*_helpers|static*/ item = _helpers[i];
        if (item.id == id)
            return item;

    };
    fu::fail((("No label '"_view + id) + "' in scope."_view));
}

static Type_KHQj solveJump_MbR9(/*3:3*/ const Node_o9cQ& node, /*3:3*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    const Helpers_DBUf& /*_helpers|static*/ h = Scope_lookupLabel_MbR9(node.value, _helpers);
    const Node_o9cQ& /*node|zeroes|static*/ n_expr = (node.items ? node.items[0] : (*(Node_o9cQ*)fu::NIL));
    return solveNode_MbR9(n_expr, Type_KHQj(h.ret_actual), _helpers);
}

static void Scope_pop_MbR9(/*1:1*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    if (_helpers)
        _helpers.pop();

}

static Type_KHQj solveNode_MbR9(/*7:7*/ const Node_o9cQ& node, /*MOV*/ Type_KHQj&& type, /*5:5*/ fu::vec_range_mut<Helpers_DBUf> _helpers)
{
    if (node.kind == Kind_okcz_return)
        return solveJump_MbR9(node, _helpers);
    else
    {
        Scope_pop_MbR9(_helpers);
        return static_cast<Type_KHQj&&>(type);
    };
}

static Type_KHQj test_MbR9(/*3:3*/ const Node_o9cQ& root, fu::vec<Helpers_DBUf>&& _helpers)
{
    return solveNode_MbR9(root, Type_KHQj{}, _helpers);
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<Helpers_DBUf> _helpers = fu::vec<Helpers_DBUf> {{ Helpers_DBUf { fu::str("hello"_fu), Type_KHQj { fu::str("Hello"_fu) } }, Helpers_DBUf { fu::str("world"_fu), Type_KHQj { fu::str("World"_fu) } } }};
    Type_KHQj res = test_MbR9(Node_o9cQ { Kind_okcz_return, fu::str("world"_fu), fu::vec<Node_o9cQ> {{ Node_o9cQ { Kind_okcz_expr, fu::str("hello"_fu), fu::vec<Node_o9cQ>{} } }} }, static_cast<fu::vec<Helpers_DBUf>&&>(_helpers));
    if (res.canon == "World"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Node { target: int; items?: Node[] }

        noinline fn revSpecFewerArgs(overloads: Node[], args: int[][], root: Node)
        {
            fn cgNode(n: Node) {
                mut src = "";
                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: int) {
                mut src = cgNode(overloads[target]);

                fn foreach(arg: int)
                    src ~= cgNode(overloads[arg]);

                shadow let args = args[target];
                for (mut i = 0; i < args.len; i++)
                    foreach(args[i]);

                return src;
            }

            return cgNode(root);
        }

        fn main() {
            return revSpecFewerArgs(
                [ Node() ], [ [] => int[] ], Node()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Node_LZ9s;
static fu::str cgNode_MbR9(const Node_LZ9s&, fu::view<Node_LZ9s>, fu::view<fu::vec<int>>);

                                #ifndef DEF_Node_LZ9sXfZwCP5
                                #define DEF_Node_LZ9sXfZwCP5
struct Node_LZ9s
{
                                // shape_hash:    9426cca71aa9fe34
                                // non_triv_mask: 0022000000000000
    int target;
    fu::vec<Node_LZ9s> items;
    Node_LZ9s(const Node_LZ9s&) = default;
    Node_LZ9s(Node_LZ9s&&) = default;
    Node_LZ9s& operator=(Node_LZ9s&&) = default;
    Node_LZ9s& operator=(const Node_LZ9s& selfrec) { return *this = Node_LZ9s(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> foreach_GL0m(const int arg, /*F:F*/ fu::vec_range_mut<char> src, /*F:F*/ fu::view<Node_LZ9s> overloads, /*F:F*/ fu::view<fu::vec<int>> args)
{
    return (src += cgNode_MbR9(overloads[arg], overloads, args));
}

static fu::str cgFn_MbR9(const int target, /*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args)
{
    /*MOV*/ fu::str src = cgNode_MbR9(overloads[target], overloads, args);
    fu::view<int> /*args|static*/ args_1 = args[target];
    for (int i = 0; i < args_1.size(); i++)
        foreach_GL0m(args_1[i], src, overloads, args);

    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const Node_LZ9s& n, /*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args)
{
    /*MOV*/ fu::str src = fu::str(""_fu);
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, args);

    return /*NRVO*/ src;
}

static fu::str revSpecFewerArgs_MbR9(/*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args, /*7:7*/ const Node_LZ9s& root)
{
    return cgNode_MbR9(root, overloads, args);
}

int fu_MAIN()
{
    return revSpecFewerArgs_MbR9(fu::view<Node_LZ9s> {{ Node_LZ9s{} }}, fu::view<fu::vec<int>> {{ fu::vec<int>{} }}, Node_LZ9s{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Node { target: int; items?: Node[] }

        noinline fn revSpecFewerArgs(overloads: Node[], args: int[][], root: Node)
        {
            fn cgNode(n: Node) {
                mut src = "";
                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: int) {
                mut src = cgNode(overloads[target]);

                fn foreach(arg: int)
                    src ~= cgNode(overloads[arg]);

                shadow let args = args[target];
                for (mut i = 0; i < args.len; i++)
                    foreach(args[i]);

                return src;
            }

            return cgNode(root);
        }

        fn main() {
            return revSpecFewerArgs(
                [ Node() ], [ [] => int[] ], Node()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Node_LZ9s;
static fu::str cgNode_MbR9(const Node_LZ9s&, fu::view<Node_LZ9s>, fu::view<fu::vec<int>>);

                                #ifndef DEF_Node_LZ9sXfZwCP5
                                #define DEF_Node_LZ9sXfZwCP5
struct Node_LZ9s
{
                                // shape_hash:    9426cca71aa9fe34
                                // non_triv_mask: 0022000000000000
    int target;
    fu::vec<Node_LZ9s> items;
    Node_LZ9s(const Node_LZ9s&) = default;
    Node_LZ9s(Node_LZ9s&&) = default;
    Node_LZ9s& operator=(Node_LZ9s&&) = default;
    Node_LZ9s& operator=(const Node_LZ9s& selfrec) { return *this = Node_LZ9s(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> foreach_GL0m(const int arg, /*F:F*/ fu::str& src, /*F:F*/ fu::view<Node_LZ9s> overloads, /*F:F*/ fu::view<fu::vec<int>> args)
{
    return (src += cgNode_MbR9(overloads[arg], overloads, args));
}

static fu::str cgFn_MbR9(const int target, /*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args)
{
    /*MOV*/ fu::str src = cgNode_MbR9(overloads[target], overloads, args);
    fu::view<int> /*args|static*/ args_1 = args[target];
    for (int i = 0; i < args_1.size(); i++)
        foreach_GL0m(args_1[i], src, overloads, args);

    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const Node_LZ9s& n, /*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args)
{
    /*MOV*/ fu::str src {};
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, args);

    return /*NRVO*/ src;
}

static fu::str revSpecFewerArgs_MbR9(/*7:7*/ fu::view<Node_LZ9s> overloads, /*7:7*/ fu::view<fu::vec<int>> args, /*7:7*/ const Node_LZ9s& root)
{
    return cgNode_MbR9(root, overloads, args);
}

int fu_MAIN()
{
    return revSpecFewerArgs_MbR9(fu::view<Node_LZ9s> {{ Node_LZ9s{} }}, fu::view<fu::vec<int>> {{ fu::vec<int>{} }}, Node_LZ9s{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    src ~= binding(args[i]);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    fu::view<Argument_Rraz> /*extended|static*/ args = EXT_MbR9(target, extended).args;
    for (int i = 0; i < args.size(); i++)
        src += binding_kGbb(args[i], overloads, extended);

    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = fu::str(""_fu);
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, extended);

    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_NonTrivAutoCopy, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    src ~= binding(args[i]);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    fu::view<Argument_Rraz> /*extended|static*/ args = EXT_MbR9(target, extended).args;
    for (int i = 0; i < args.size(); i++)
        src += binding_kGbb(args[i], overloads, extended);

    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src {};
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, extended);

    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                target.args.each: |host_arg|
                    src ~= binding(host_arg);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

                                #ifndef DEF___4kscBZLHL38
                                #define DEF___4kscBZLHL38
inline static fu::view<char> _4ksc(/*F:F*/ const Argument_Rraz& host_arg, /*F:F*/ fu::vec_range_mut<char> src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += binding_kGbb(host_arg, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_u7nbVP20sj1
                                #define DEF_each_u7nbVP20sj1
inline void each_u7nb(/*F1:F1*/ fu::vec_range<Argument_Rraz> a, /*7:6*/ fu::vec_range_mut<char> src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _4ksc(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    each_u7nb(EXT_MbR9(target, extended).args, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = fu::str(""_fu);
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, extended);

    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                for (mut i = 0; i < n.items.len; i++)
                    src ~= cgFn(n.items[i].target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                target.args.each: |host_arg|
                    src ~= binding(host_arg);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

                                #ifndef DEF___4kscBZLHL38
                                #define DEF___4kscBZLHL38
inline static fu::view<char> _4ksc(/*F:F*/ const Argument_Rraz& host_arg, /*F:F*/ fu::str& src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += binding_kGbb(host_arg, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_u7nbVP20sj1
                                #define DEF_each_u7nbVP20sj1
inline void each_u7nb(/*F1:F1*/ fu::vec_range<Argument_Rraz> a, /*7:6*/ fu::str& src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _4ksc(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    each_u7nb(EXT_MbR9(target, extended).args, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src {};
    for (int i = 0; i < n.items.size(); i++)
        src += cgFn_MbR9(n.items[i].target, overloads, extended);

    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                n.items.each: |member|
                    src ~= cgFn(member.target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    src ~= binding(args[i]);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    fu::view<Argument_Rraz> /*extended|static*/ args = EXT_MbR9(target, extended).args;
    for (int i = 0; i < args.size(); i++)
        src += binding_kGbb(args[i], overloads, extended);

    return /*NRVO*/ src;
}

                                #ifndef DEF___JDvk6PekLo6
                                #define DEF___JDvk6PekLo6
inline static fu::view<char> _JDvk(/*F:F*/ const SolvedNode_Uezn& member, /*F:F*/ fu::vec_range_mut<char> src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += cgFn_MbR9(member.target, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_4uiPikrCeod
                                #define DEF_each_4uiPikrCeod
inline void each_4uiP(/*F1:F1*/ fu::vec_range<SolvedNode_Uezn> a, /*7:6*/ fu::vec_range_mut<char> src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _JDvk(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = fu::str(""_fu);
    each_4uiP(n.items, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                n.items.each: |member|
                    src ~= cgFn(member.target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    src ~= binding(args[i]);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    fu::view<Argument_Rraz> /*extended|static*/ args = EXT_MbR9(target, extended).args;
    for (int i = 0; i < args.size(); i++)
        src += binding_kGbb(args[i], overloads, extended);

    return /*NRVO*/ src;
}

                                #ifndef DEF___JDvk6PekLo6
                                #define DEF___JDvk6PekLo6
inline static fu::view<char> _JDvk(/*F:F*/ const SolvedNode_Uezn& member, /*F:F*/ fu::str& src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += cgFn_MbR9(member.target, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_4uiPikrCeod
                                #define DEF_each_4uiPikrCeod
inline void each_4uiP(/*F1:F1*/ fu::vec_range<SolvedNode_Uezn> a, /*7:6*/ fu::str& src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _JDvk(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src {};
    each_4uiP(n.items, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                n.items.each: |member|
                    src ~= cgFn(member.target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                target.args.each: |host_arg|
                    src ~= binding(host_arg);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

                                #ifndef DEF___4kscBZLHL38
                                #define DEF___4kscBZLHL38
inline static fu::view<char> _4ksc(/*F:F*/ const Argument_Rraz& host_arg, /*F:F*/ fu::vec_range_mut<char> src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += binding_kGbb(host_arg, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_u7nbVP20sj1
                                #define DEF_each_u7nbVP20sj1
inline void each_u7nb(/*F1:F1*/ fu::vec_range<Argument_Rraz> a, /*7:6*/ fu::vec_range_mut<char> src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _4ksc(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    each_u7nb(EXT_MbR9(target, extended).args, src, overloads, extended);
    return /*NRVO*/ src;
}

                                #ifndef DEF___JDvk6PekLo6
                                #define DEF___JDvk6PekLo6
inline static fu::view<char> _JDvk(/*F:F*/ const SolvedNode_Uezn& member, /*F:F*/ fu::vec_range_mut<char> src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += cgFn_MbR9(member.target, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_4uiPikrCeod
                                #define DEF_each_4uiPikrCeod
inline void each_4uiP(/*F1:F1*/ fu::vec_range<SolvedNode_Uezn> a, /*7:6*/ fu::vec_range_mut<char> src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _JDvk(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = fu::str(""_fu);
    each_4uiP(n.items, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";

                n.items.each: |member|
                    src ~= cgFn(member.target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);

                target.args.each: |host_arg|
                    src ~= binding(host_arg);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_MZF4;
struct SolvedNode_Uezn;
struct Target_9DUs;
struct Extended_C6lg;
struct Argument_Rraz;
static fu::str cgNode_MbR9(const SolvedNode_Uezn&, fu::view<Overload_MZF4>, fu::view<Extended_C6lg>);

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_UeznCuO5Wv1
                                #define DEF_SolvedNode_UeznCuO5Wv1
struct SolvedNode_Uezn
{
                                // shape_hash:    016752654bfb5a11
                                // non_triv_mask: 0000100000000001
    Target_9DUs target;
    fu::vec<SolvedNode_Uezn> items;
    SolvedNode_Uezn(const SolvedNode_Uezn&) = default;
    SolvedNode_Uezn(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(SolvedNode_Uezn&&) = default;
    SolvedNode_Uezn& operator=(const SolvedNode_Uezn& selfrec) { return *this = SolvedNode_Uezn(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_MZF4a8lBoC8
                                #define DEF_Overload_MZF4a8lBoC8
struct Overload_MZF4
{
                                // shape_hash:    ad0f28a02a4f4646
                                // non_triv_mask: 0000104000000001
    SolvedNode_Uezn solved;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_C6lg5jAABvg
                                #define DEF_Extended_C6lg5jAABvg
struct Extended_C6lg
{
                                // shape_hash:    e5c1389def2bc40c
                                // non_triv_mask: 0000000c00000000
    fu::vec<Argument_Rraz> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_RrazqVgQ9bi
                                #define DEF_Argument_RrazqVgQ9bi
struct Argument_Rraz
{
                                // shape_hash:    f482f41c183e0c3d
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_MZF4& GET_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Overload_MZF4> overloads)
{
    return overloads[target.globid];
}

static const Extended_C6lg& EXT_MbR9(/*3:3*/ const Target_9DUs& target, /*3:3*/ fu::view<Extended_C6lg> extended)
{
    return extended[target.globid];
}

static fu::str binding_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
}

static fu::str binding_kGbb(/*7:7*/ const Argument_Rraz& arg, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    return binding_MbR9(arg.target, overloads, extended);
}

                                #ifndef DEF___4kscBZLHL38
                                #define DEF___4kscBZLHL38
inline static fu::view<char> _4ksc(/*F:F*/ const Argument_Rraz& host_arg, /*F:F*/ fu::str& src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += binding_kGbb(host_arg, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_u7nbVP20sj1
                                #define DEF_each_u7nbVP20sj1
inline void each_u7nb(/*F1:F1*/ fu::vec_range<Argument_Rraz> a, /*7:6*/ fu::str& src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _4ksc(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgFn_MbR9(/*7:7*/ const Target_9DUs& target, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src = cgNode_MbR9(GET_MbR9(target, overloads).solved, overloads, extended);
    each_u7nb(EXT_MbR9(target, extended).args, src, overloads, extended);
    return /*NRVO*/ src;
}

                                #ifndef DEF___JDvk6PekLo6
                                #define DEF___JDvk6PekLo6
inline static fu::view<char> _JDvk(/*F:F*/ const SolvedNode_Uezn& member, /*F:F*/ fu::str& src, /*F:F*/ fu::view<Overload_MZF4> overloads, /*F:F*/ fu::view<Extended_C6lg> extended)
{
    return (src += cgFn_MbR9(member.target, overloads, extended));
}
                                #endif

                                #ifndef DEF_each_4uiPikrCeod
                                #define DEF_each_4uiPikrCeod
inline void each_4uiP(/*F1:F1*/ fu::vec_range<SolvedNode_Uezn> a, /*7:6*/ fu::str& src, /*F1:F1*/ fu::view<Overload_MZF4> overloads, /*F1:F1*/ fu::view<Extended_C6lg> extended)
{
    for (int i = 0; i < a.size(); i++)
        _JDvk(a[i], src, overloads, extended);

}
                                #endif

static fu::str cgNode_MbR9(/*7:7*/ const SolvedNode_Uezn& n, /*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended)
{
    /*MOV*/ fu::str src {};
    each_4uiP(n.items, src, overloads, extended);
    return /*NRVO*/ src;
}

static fu::str lazySolveStartDetectRecursionBug_MbR9(/*7:7*/ fu::view<Overload_MZF4> overloads, /*7:7*/ fu::view<Extended_C6lg> extended, /*7:7*/ const SolvedNode_Uezn& root)
{
    return cgNode_MbR9(root, overloads, extended);
}

int fu_MAIN()
{
    return lazySolveStartDetectRecursionBug_MbR9(fu::view<Overload_MZF4> {{ Overload_MZF4{} }}, fu::view<Extended_C6lg> {{ Extended_C6lg{} }}, SolvedNode_Uezn{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_DeadCall, N_DeadLet, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Hello { x: i32 };
        implicit ref hello: Hello;
        fn woot() = hello.x++;


        fn main() {
            shadow implicit mut hello = Hello(1);
            return woot() * 10 + hello.x - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_3JDd;

                                #ifndef DEF_Hello_3JDdswUlXca
                                #define DEF_Hello_3JDdswUlXca
struct Hello_3JDd
{
                                // shape_hash:    d5730f3a48019e67
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int woot_MbR9(/*1:1*/ Hello_3JDd& hello)
{
    return hello.x++;
}

int fu_MAIN()
{
    Hello_3JDd hello = Hello_3JDd { 1 };
    int _0;
    return (_0 = (woot_MbR9(hello) * 10), (_0 + hello.x)) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        struct Hello { x: i32 };
        implicit ref hello: Hello;
        fn woot() = hello.x++;

        pub import _0;
        fn main() {
            shadow implicit mut hello = Hello(1);
            return woot() * 10 + hello.x - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_3JDd;
int woot_MbR9(Hello_3JDd&);

                                #ifndef DEF_Hello_3JDdswUlXca
                                #define DEF_Hello_3JDdswUlXca
struct Hello_3JDd
{
                                // shape_hash:    d5730f3a48019e67
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hello_3JDd hello = Hello_3JDd { 1 };
    int _0;
    return (_0 = (woot_MbR9(hello) * 10), (_0 + hello.x)) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq
struct Hello_3JDd;

                                #ifndef DEF_Hello_3JDdswUlXca
                                #define DEF_Hello_3JDdswUlXca
struct Hello_3JDd
{
                                // shape_hash:    d5730f3a48019e67
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int woot_MbR9(/*1:1*/ Hello_3JDd& hello)
{
    return hello.x++;
}

#endif

========

        struct World { x: i32 };
        struct Hello {   world: World;
        };

        fn woot(implicit ref world: World) = world.x++;


        fn main() {
            using mut hello = Hello(World(1));
            return woot() * 10 + hello.world.x - 12;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:20+4[0m:

[2m      |         fn main() {[0m
[2m      |             using mut hello = Hello(World(1));[0m
[2m   11 | [0m            return [31;1mwoot[0m() * 10 + hello.world.x - 12;
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mworld[0m: [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWorld[0m in scope, needed to call [35;3mfn[0m [94;1mwoot[0m:

            because of [35;3mimplicit mut ref arg[0m [94;1mworld[0m at [2m6:30+5[0m:

[2m      |         };[0m
[2m      | [0m
[2m    6 | [0m        fn woot(implicit ref [31;1mworld[0m: World) = world.x++;
[2m      | [0m
[2m      | [0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        struct World { x: i32 };
        struct Hello {   world: World;
        };

        fn woot(implicit ref world: World) = world.x++;

        pub import _0;
        fn main() {
            using mut hello = Hello(World(1));
            return woot() * 10 + hello.world.x - 12;
        }

---- <fail> ----
[2m[0m_1[2m.fu 4:20+4[0m:

[2m      |         fn main() {[0m
[2m      |             using mut hello = Hello(World(1));[0m
[2m    4 | [0m            return [31;1mwoot[0m() * 10 + hello.world.x - 12;
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mworld[0m: [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWorld[0m in scope, needed to call [35;3mfn[0m [94;1mwoot[0m:

            because of [35;3mimplicit mut ref arg[0m [94;1mworld[0m at [2m[0m_0[2m.fu 6:30+5[0m:

[2m      |         };[0m
[2m      | [0m
[2m    6 | [0m        fn woot(implicit ref [31;1mworld[0m: World) = world.x++;
[2m      | [0m
[2m      | [0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        struct World { x: i32 };
        struct Hello {  
            implicit     world: World;
        };

        fn woot(implicit ref world: World) = world.x++;


        fn main() {
            using mut hello = Hello(World(1));
            return woot() * 10 + hello.world.x - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_aqdd;
struct World_QFTi;

                                #ifndef DEF_World_QFTiKZbrREi
                                #define DEF_World_QFTiKZbrREi
struct World_QFTi
{
                                // shape_hash:    eeae755720a6559d
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Hello_aqddD0yptc2
                                #define DEF_Hello_aqddD0yptc2
struct Hello_aqdd
{
                                // shape_hash:    293f5fe0e2483a91
                                // non_triv_mask: 0000000000000000
    World_QFTi world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int woot_MbR9(/*1:1*/ World_QFTi& world)
{
    return world.x++;
}

int fu_MAIN()
{
    Hello_aqdd hello = Hello_aqdd { World_QFTi { 1 } };
    int _0;
    return (_0 = (woot_MbR9(hello.world) * 10), (_0 + hello.world.x)) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        struct World { x: i32 };
        struct Hello {  
            implicit     world: World;
        };

        fn woot(implicit ref world: World) = world.x++;

        pub import _0;
        fn main() {
            using mut hello = Hello(World(1));
            return woot() * 10 + hello.world.x - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_aqdd;
struct World_QFTi;
int woot_MbR9(World_QFTi&);

                                #ifndef DEF_World_QFTiKZbrREi
                                #define DEF_World_QFTiKZbrREi
struct World_QFTi
{
                                // shape_hash:    eeae755720a6559d
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Hello_aqddD0yptc2
                                #define DEF_Hello_aqddD0yptc2
struct Hello_aqdd
{
                                // shape_hash:    293f5fe0e2483a91
                                // non_triv_mask: 0000000000000000
    World_QFTi world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hello_aqdd hello = Hello_aqdd { World_QFTi { 1 } };
    int _0;
    return (_0 = (woot_MbR9(hello.world) * 10), (_0 + hello.world.x)) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq
struct World_QFTi;

                                #ifndef DEF_World_QFTiKZbrREi
                                #define DEF_World_QFTiKZbrREi
struct World_QFTi
{
                                // shape_hash:    eeae755720a6559d
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int woot_MbR9(/*1:1*/ World_QFTi& world)
{
    return world.x++;
}

#endif

========

        nocopy struct EventLoop { loop_fd: int };
        pub fn ipv4_listen(implicit ref event_loop: EventLoop)
            event_loop.loop_fd++;

        pub fn EventLoop(loop_start!) {

            let implicit  event_loop = {
                mut loop_fd: int;
                EventLoop(loop_fd)
            };

            loop_start();
            return event_loop;
        }

        fn main() {
            let event_loop = EventLoop(loop_start: || { ipv4_listen() });
            return event_loop.loop_fd - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 13:13+10[0m:

[2m      |             };[0m
[2m      | [0m
[2m   13 | [0m            [31;1mloop_start[0m();
[2m      |             return event_loop;[0m
[2m      |         }[0m

	[35;3minjected implicit mut ref arg[0m [94;1mevent_loop[0m type mismatch: expects a mutref, got a ref to [35;3mimplicit[0m [94;1mevent_loop[0m at [2m8:27+10[0m:

[2m      |         pub fn EventLoop(loop_start!) {[0m
[2m      | [0m
[2m    8 | [0m            let implicit  [31;1mevent_loop[0m = {
[2m      |                 mut loop_fd: int;[0m
[2m      |                 EventLoop(loop_fd)[0m

	    ... which is not mutable.

	Needed to call [35;3mfn[0m [94;1mloop_start[0m:

            because of call to [35;3mfn[0m [94;1mipv4_listen[0m at [2m18:57+11[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   18 | [0m            let event_loop = EventLoop(loop_start: || { [31;1mipv4_listen[0m() });
[2m      |             return event_loop.loop_fd - 1;[0m
[2m      |         }[0m

            because of [35;3mimplicit mut ref arg[0m [94;1mevent_loop[0m at [2m3:41+10[0m:

[2m      | [0m
[2m      |         nocopy struct EventLoop { loop_fd: int };[0m
[2m    3 | [0m        pub fn ipv4_listen(implicit ref [31;1mevent_loop[0m: EventLoop)
[2m      |             event_loop.loop_fd++;[0m
[2m      | [0m


        Solving [35;3mfn[0m [94;1mEventLoop[0m([35;3m@180[0m) at [2m6:16+9[0m
                [35;3mfn[0m [94;1mmain[0m at [2m17:12+4[0m

========

        nocopy struct EventLoop { loop_fd: int };
        pub fn ipv4_listen(implicit ref event_loop: EventLoop)
            event_loop.loop_fd++;

        pub fn EventLoop(loop_start!) {

            implicit mut  event_loop = {
                mut loop_fd: int;
                EventLoop(loop_fd)
            };

            loop_start();
            return event_loop;
        }

        fn main() {
            let event_loop = EventLoop(loop_start: || { ipv4_listen() });
            return event_loop.loop_fd - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct EventLoop_94lA;

                                #ifndef DEF_EventLoop_94lAVixiNQk
                                #define DEF_EventLoop_94lAVixiNQk
struct EventLoop_94lA
{
                                // shape_hash:    5c01ca6c587eed2f
                                // non_triv_mask: 0200000000000000
    int loop_fd;
    EventLoop_94lA(const EventLoop_94lA&) = delete;
    EventLoop_94lA(EventLoop_94lA&&) = default;
    EventLoop_94lA& operator=(const EventLoop_94lA&) = delete;
    EventLoop_94lA& operator=(EventLoop_94lA&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || loop_fd
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int ipv4_listen_MbR9(/*1:1*/ EventLoop_94lA& event_loop)
{
    return event_loop.loop_fd++;
}

                                #ifndef DEF_loop_start_V02cxqa4KX2
                                #define DEF_loop_start_V02cxqa4KX2
inline static int loop_start_V02c(/*1:1*/ EventLoop_94lA& event_loop)
{
    return ipv4_listen_MbR9(event_loop);
}
                                #endif

                                #ifndef DEF_EventLoop_GIbzyl0oryl
                                #define DEF_EventLoop_GIbzyl0oryl
inline EventLoop_94lA EventLoop_GIbz()
{
    int loop_fd;
    /*MOV*/ EventLoop_94lA event_loop = (loop_fd = {}, EventLoop_94lA { loop_fd });
    loop_start_V02c(event_loop);
    return /*NRVO*/ event_loop;
}
                                #endif

int fu_MAIN()
{
    EventLoop_94lA event_loop = EventLoop_GIbz();
    return event_loop.loop_fd - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { items?: Node[] }

        nothrow fn count(tree: Node) {
            mut count = 0;
            fn visit(node: Node) {
                count++;                                
                if (count > 1) throw("What! Throws.");  

                node.items.each(fn visit);
            }

            visit(tree);
            return count;
        }

        fn main() Node(items: [ Node(), Node() ]).count - 3;

---- <fail> ----
[2m[0m_0[2m.fu 4:9+7[0m:

[2m      |         struct Node { items?: Node[] }[0m
[2m      | [0m
[2m    4 | [0m        [31;1mnothrow[0m fn count(tree: Node) {
[2m      |             mut count = 0;[0m
[2m      |             fn visit(node: Node) {[0m

	[35;3mfn[0m [94;1mcount[0m is not nothrow, throws here:

            via [35;3mfn[0m [94;1mvisit[0m at [2m13:13+5[0m:

[2m      |             }[0m
[2m      | [0m
[2m   13 | [0m            [31;1mvisit[0m(tree);
[2m      |             return count;[0m
[2m      |         }[0m

            via [35;3m__native[0m [94;1m<fu/never.h> fu::fail[0m at [2m8:32+5[0m:

[2m      |             fn visit(node: Node) {[0m
[2m      |                 count++;                                [0m
[2m    8 | [0m                if (count > 1) [31;1mthrow[0m("What! Throws.");  
[2m      | [0m
[2m      |                 node.items.each(fn visit);[0m


========

        struct Node { items?: Node[] }

        nothrow fn count(tree: Node) {
            mut count = 0;
            fn visit(node: Node) {
                count++;                                

                node.items.each(fn visit);
            }

            visit(tree);
            return count;
        }

        fn main() Node(items: [ Node(), Node() ]).count - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Node_zYlo;
static void visit_MbR9(const Node_zYlo&, int&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_each_dReIGSfnaga
                                #define DEF_each_dReIGSfnaga
inline void each_dReI(/*7:7*/ fu::view<Node_zYlo> a, /*6:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        visit_MbR9(a[i], count);

}
                                #endif

static void visit_MbR9(/*3:3*/ const Node_zYlo& node, /*2:2*/ int& count)
{
    count++;
    each_dReI(node.items, count);
}

static int count_MbR9(/*1:1*/ const Node_zYlo& tree)
{
    int count = 0;
    visit_MbR9(tree, count);
    return count;
}

int fu_MAIN()
{
    return count_MbR9(Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} }) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_UnusedCall

========

        let x = 1;

        fn test(): &i32
            x;

        return test - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const int x)
{
    return x;
}

int fu_MAIN()
{
    const int x = 1;
    return test_MbR9(x) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        let a = 1;
        let x: &i32 = a;

        return a - x;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    return a - a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_68jG;

                                #ifndef DEF_Test_68jGtUaG1jd
                                #define DEF_Test_68jGtUaG1jd
struct Test_68jG
{
                                // shape_hash:    24b0cd36b2a5efa9
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const Test_68jG test = Test_68jG { a };
    return test.x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    int b = a;
    b++;
    const int /*a*/ c = (a = b);
    return a - c;
}

#endif

int main() { return fu_MAIN(); }

========

        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view<int> view)
{
    int sum = 0;
    for (int i = 0; i < view.size(); i++)
        sum += view[i];

    return sum - 15;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
    arr.push(5);
    return test_MbR9(arr);
}

#endif

int main() { return fu_MAIN(); }

========

        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view<int> view)
{
    int sum = 0;
    for (int i = 0; i < view.size(); i++)
        sum += view[i];

    return sum - 15;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3, 4 }};
    arr.push(5);
    return test_MbR9(arr);
}

#endif

int main() { return fu_MAIN(); }

========

        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 5;
    fu::vec<int> arr = fu::vec<int> {{ -5 }};
    arr.push(x);
    return arr[0] + arr[1];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        let x = [ named: 0 ]; 
        return x[0];

---- <fail> ----
[2m[0m_0[2m.fu 6:17+1[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m        let x = [31;1m[[0m named: 0 ]; 
[2m      |         return x[0];[0m
[2m      | [0m

	TODO: solveArrlit: tryMatch by [ argnames: ... ] without function name.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========


        let x = [        0 ]; 
        return x[0];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> {{ 0 }};
    return x[0];
}

#endif

int main() { return fu_MAIN(); }

========

        mut other: i32[][];
        mut arr:   i32[][];
        for (mut i = 4; i --> 0; )
        {
            arr.resize(i);

            // fill up with non small vecs so we can check alloc counts
            for (shadow mut i = 0; i < arr.len; i++)
                arr[i] ||= [ i, i, i, i, i, i, i, i ]; // defeat small vec

            // now this convers the "Last chance to do nothing" opti -
            //  noop resize a shared vec.
            other = arr;
            arr.resize(other.len || i);
        }
        return other.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(672) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::vec<int>> other {};
    fu::vec<fu::vec<int>> arr {};
    for (int i = 4; i-- > 0; )
    {
        arr.resize(i);
        for (int i_1 = 0; i_1 < arr.size(); i_1++)
        {
            fu::vec_range_mut<int> /*arr|static*/ a = arr.mutref(i_1);
            if (!(a))
            {
                a = fu::vec<int> {{ i_1, i_1, i_1, i_1, i_1, i_1, i_1, i_1 }};
            };
        };
        other = arr;
        int _0;
        arr.resize(((_0 = other.size()) ? _0 : i));
    };
    return other.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn grow_if_oob(ref a: $T[], i: int) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }


        struct Token { str: string };
        fn add_at(ref tok2d: Token[][], i: int, str: string)
            tok2d.grow_if_oob(i) ~= Token(str);


        fn main() {
            mut tok2d: Token[][];
            tok2d.add_at(1, ", ");
            tok2d.add_at(3, "Worl");
            tok2d.add_at(0, "Hello");
            tok2d.add_at(3, "!");
            let res = tok2d.map(.map(.str).join("d")).join();
            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>

struct Token_VUfV;

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1001) { ", "_fu };
                                #endif

                                #ifndef STR_1T5bZDWSjs8
                                #define STR_1T5bZDWSjs8
static const fu::str str_1T5bZDWSjs8 fu_INIT_PRIORITY(1001) { "Worl"_fu };
                                #endif

                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1001) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_QjlI4DdrXxd
                                #define DEF_grow_if_oob_QjlI4DdrXxd
inline static fu::vec_range_mut<Token_VUfV> grow_if_oob_QjlI(/*3:3*/ fu::vec_range_mut<fu::vec<Token_VUfV>> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static fu::vec_range<Token_VUfV> add_at_kGbb(/*7:7*/ fu::vec_range_mut<fu::vec<Token_VUfV>> tok2d, const int i, /*7:7*/ fu::vec_range<char> str)
{
    Token_VUfV _0 {};
    return (_0 = Token_VUfV { fu::str(str) }, (grow_if_oob_QjlI(tok2d, i) += static_cast<Token_VUfV&&>(_0)));
}

                                #ifndef DEF___IkQUhZ92mPb
                                #define DEF___IkQUhZ92mPb
inline static const fu::str& _IkQU(/*1:1*/ const Token_VUfV& _)
{
    return _.str;
}
                                #endif

                                #ifndef DEF_map_YBIZDqHyLv3
                                #define DEF_map_YBIZDqHyLv3
inline fu::vec<fu::str> map_YBIZ(/*3:3*/ fu::view<Token_VUfV> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_IkQU(a[i]));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___96R9oR6NSMl
                                #define DEF___96R9oR6NSMl
inline static fu::str _96R9(/*1:1*/ fu::view<Token_VUfV> _)
{
    return join_yqDb(map_YBIZ(_), "d"_view);
}
                                #endif

                                #ifndef DEF_map_6xM9V7DM37g
                                #define DEF_map_6xM9V7DM37g
inline fu::vec<fu::str> map_6xM9(/*3:3*/ fu::view<fu::vec<Token_VUfV>> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _96R9(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<Token_VUfV>> tok2d {};
    add_at_kGbb(tok2d, 1, str_OGhgmtYJxj2);
    add_at_kGbb(tok2d, 3, str_1T5bZDWSjs8);
    add_at_kGbb(tok2d, 0, str_5Dh86r8K971);
    add_at_kGbb(tok2d, 3, str_5TEYhFzaE10);
    fu::str res = join_QbuI(map_6xM9(tok2d));
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: $T[], i: int) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }


        struct Token { str: string };
        fn add_at(ref tok2d: Token[][], i: int, str: string)
            tok2d.grow_if_oob(i) ~= Token(str);

        pub import _0;
        fn main() {
            mut tok2d: Token[][];
            tok2d.add_at(1, ", ");
            tok2d.add_at(3, "Worl");
            tok2d.add_at(0, "Hello");
            tok2d.add_at(3, "!");
            let res = tok2d.map(.map(.str).join("d")).join();
            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>

struct Token_VUfV;
fu::vec_range_mut<Token_VUfV> add_at_MbR9(fu::vec_range_mut<fu::vec<Token_VUfV>>, int, fu::vec_range<char>);

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1002) { ", "_fu };
                                #endif

                                #ifndef STR_1T5bZDWSjs8
                                #define STR_1T5bZDWSjs8
static const fu::str str_1T5bZDWSjs8 fu_INIT_PRIORITY(1002) { "Worl"_fu };
                                #endif

                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1002) { "Hello"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1002) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___IkQUhZ92mPb
                                #define DEF___IkQUhZ92mPb
inline static const fu::str& _IkQU(/*1:1*/ const Token_VUfV& _)
{
    return _.str;
}
                                #endif

                                #ifndef DEF_map_YBIZDqHyLv3
                                #define DEF_map_YBIZDqHyLv3
inline fu::vec<fu::str> map_YBIZ(/*3:3*/ fu::view<Token_VUfV> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_IkQU(a[i]));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___96R9oR6NSMl
                                #define DEF___96R9oR6NSMl
inline static fu::str _96R9(/*1:1*/ fu::view<Token_VUfV> _)
{
    return join_yqDb(map_YBIZ(_), "d"_view);
}
                                #endif

                                #ifndef DEF_map_6xM9V7DM37g
                                #define DEF_map_6xM9V7DM37g
inline fu::vec<fu::str> map_6xM9(/*3:3*/ fu::view<fu::vec<Token_VUfV>> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _96R9(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<Token_VUfV>> tok2d {};
    add_at_MbR9(tok2d, 1, str_OGhgmtYJxj2);
    add_at_MbR9(tok2d, 3, str_1T5bZDWSjs8);
    add_at_MbR9(tok2d, 0, str_5Dh86r8K971);
    add_at_MbR9(tok2d, 3, str_5TEYhFzaE10);
    fu::str res = join_QbuI(map_6xM9(tok2d));
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Token_VUfV;

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_QjlI4DdrXxd
                                #define DEF_grow_if_oob_QjlI4DdrXxd
inline fu::vec_range_mut<Token_VUfV> grow_if_oob_QjlI(/*3:3*/ fu::vec_range_mut<fu::vec<Token_VUfV>> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

fu::vec_range_mut<Token_VUfV> add_at_MbR9(/*7:7*/ fu::vec_range_mut<fu::vec<Token_VUfV>> tok2d, const int i, /*7:7*/ fu::vec_range<char> str)
{
    Token_VUfV _0 {};
    return (_0 = Token_VUfV { fu::str(str) }, (grow_if_oob_QjlI(tok2d, i) += static_cast<Token_VUfV&&>(_0)));
}

#endif

// N_NonTrivAutoCopy, N_AARMustSeq

========

        fn grow_if_oob(ref a: $T[], i: int) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        pub import _0;
        struct Token { str: string };
        fn add_at(ref tok2d: Token[][], i: int, str: string)
            tok2d.grow_if_oob(i) ~= Token(str);


        fn main() {
            mut tok2d: Token[][];
            tok2d.add_at(1, ", ");
            tok2d.add_at(3, "Worl");
            tok2d.add_at(0, "Hello");
            tok2d.add_at(3, "!");
            let res = tok2d.map(.map(.str).join("d")).join();
            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>

struct Token_VUfV;

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1002) { ", "_fu };
                                #endif

                                #ifndef STR_1T5bZDWSjs8
                                #define STR_1T5bZDWSjs8
static const fu::str str_1T5bZDWSjs8 fu_INIT_PRIORITY(1002) { "Worl"_fu };
                                #endif

                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1002) { "Hello"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1002) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_QjlI4DdrXxd
                                #define DEF_grow_if_oob_QjlI4DdrXxd
inline fu::vec_range_mut<Token_VUfV> grow_if_oob_QjlI(/*3:3*/ fu::vec_range_mut<fu::vec<Token_VUfV>> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static fu::vec_range<Token_VUfV> add_at_TXGC(/*7:7*/ fu::vec_range_mut<fu::vec<Token_VUfV>> tok2d, const int i, /*7:7*/ fu::vec_range<char> str)
{
    Token_VUfV _0 {};
    return (_0 = Token_VUfV { fu::str(str) }, (grow_if_oob_QjlI(tok2d, i) += static_cast<Token_VUfV&&>(_0)));
}

                                #ifndef DEF___IkQUhZ92mPb
                                #define DEF___IkQUhZ92mPb
inline static const fu::str& _IkQU(/*1:1*/ const Token_VUfV& _)
{
    return _.str;
}
                                #endif

                                #ifndef DEF_map_YBIZDqHyLv3
                                #define DEF_map_YBIZDqHyLv3
inline fu::vec<fu::str> map_YBIZ(/*3:3*/ fu::view<Token_VUfV> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_IkQU(a[i]));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___96R9oR6NSMl
                                #define DEF___96R9oR6NSMl
inline static fu::str _96R9(/*1:1*/ fu::view<Token_VUfV> _)
{
    return join_yqDb(map_YBIZ(_), "d"_view);
}
                                #endif

                                #ifndef DEF_map_6xM9V7DM37g
                                #define DEF_map_6xM9V7DM37g
inline fu::vec<fu::str> map_6xM9(/*3:3*/ fu::view<fu::vec<Token_VUfV>> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _96R9(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<Token_VUfV>> tok2d {};
    add_at_TXGC(tok2d, 1, str_OGhgmtYJxj2);
    add_at_TXGC(tok2d, 3, str_1T5bZDWSjs8);
    add_at_TXGC(tok2d, 0, str_5Dh86r8K971);
    add_at_TXGC(tok2d, 3, str_5TEYhFzaE10);
    fu::str res = join_QbuI(map_6xM9(tok2d));
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: $T[], i: int) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        pub import _0;
        struct Token { str: string };
        fn add_at(ref tok2d: Token[][], i: int, str: string)
            tok2d.grow_if_oob(i) ~= Token(str);

        pub import _1;
        fn main() {
            mut tok2d: Token[][];
            tok2d.add_at(1, ", ");
            tok2d.add_at(3, "Worl");
            tok2d.add_at(0, "Hello");
            tok2d.add_at(3, "!");
            let res = tok2d.map(.map(.str).join("d")).join();
            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>

struct Token_VUfV;
fu::vec_range_mut<Token_VUfV> add_at_LtD7(fu::vec_range_mut<fu::vec<Token_VUfV>>, int, fu::vec_range<char>);

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1003) { ", "_fu };
                                #endif

                                #ifndef STR_1T5bZDWSjs8
                                #define STR_1T5bZDWSjs8
static const fu::str str_1T5bZDWSjs8 fu_INIT_PRIORITY(1003) { "Worl"_fu };
                                #endif

                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1003) { "Hello"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1003) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___IkQUhZ92mPb
                                #define DEF___IkQUhZ92mPb
inline static const fu::str& _IkQU(/*1:1*/ const Token_VUfV& _)
{
    return _.str;
}
                                #endif

                                #ifndef DEF_map_YBIZDqHyLv3
                                #define DEF_map_YBIZDqHyLv3
inline fu::vec<fu::str> map_YBIZ(/*3:3*/ fu::view<Token_VUfV> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_IkQU(a[i]));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___96R9oR6NSMl
                                #define DEF___96R9oR6NSMl
inline static fu::str _96R9(/*1:1*/ fu::view<Token_VUfV> _)
{
    return join_yqDb(map_YBIZ(_), "d"_view);
}
                                #endif

                                #ifndef DEF_map_6xM9V7DM37g
                                #define DEF_map_6xM9V7DM37g
inline fu::vec<fu::str> map_6xM9(/*3:3*/ fu::view<fu::vec<Token_VUfV>> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _96R9(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<Token_VUfV>> tok2d {};
    add_at_LtD7(tok2d, 1, str_OGhgmtYJxj2);
    add_at_LtD7(tok2d, 3, str_1T5bZDWSjs8);
    add_at_LtD7(tok2d, 0, str_5Dh86r8K971);
    add_at_LtD7(tok2d, 3, str_5TEYhFzaE10);
    fu::str res = join_QbuI(map_6xM9(tok2d));
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Token_VUfV;

                                #ifndef DEF_Token_VUfVcziruch
                                #define DEF_Token_VUfVcziruch
struct Token_VUfV
{
                                // shape_hash:    d914695934b2b58c
                                // non_triv_mask: 0000800200000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_QjlI4DdrXxd
                                #define DEF_grow_if_oob_QjlI4DdrXxd
inline fu::vec_range_mut<Token_VUfV> grow_if_oob_QjlI(/*3:3*/ fu::vec_range_mut<fu::vec<Token_VUfV>> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

fu::vec_range_mut<Token_VUfV> add_at_LtD7(/*7:7*/ fu::vec_range_mut<fu::vec<Token_VUfV>> tok2d, const int i, /*7:7*/ fu::vec_range<char> str)
{
    Token_VUfV _0 {};
    return (_0 = Token_VUfV { fu::str(str) }, (grow_if_oob_QjlI(tok2d, i) += static_cast<Token_VUfV&&>(_0)));
}

#endif

// N_NonTrivAutoCopy, N_AARMustSeq

========

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            mut b = [ 1, 2, 3 ];
            swap(a, b);
            return a.len + b.len * 10 - 73;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> b = fu::vec<int> {{ 1, 2, 3 }};
    a.swap(b);
    return (a.size() + (b.size() * 10)) - 73;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn swap_indirect(          
            ref a: i32[..], ref b: i32[..]) 
                swap(a, b);

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            mut b = [ 1, 2, 3 ];
            swap_indirect(a, b);
            return a.len + b.len * 10 - 73;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+4[0m:

[2m      |         noinline fn swap_indirect(          [0m
[2m      |             ref a: i32[..], ref b: i32[..]) [0m
[2m    4 | [0m                [31;1mswap[0m(a, b);
[2m      | [0m
[2m      |         fn main() {[0m

	Bad call to [94;1mswap[0m with args ([35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[..][0m, [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[..][0m): 

	[35;3mtemplate[0m [94;1m<fu/vec/view_swap.h> fu::view_swap[0m at [2m../../../../../[0mprelude[2m 504:4+4[0m:
[2m  504 | [0mfn [31;1mswap[0m(mut ref a: <T>[..], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

	    Wrong number of arguments: expects 3, got 2.

	[35;3mtemplate[0m [94;1mswap[0m at [2m../../../../../[0mprelude[2m 216:4+4[0m:
[2m  216 | [0mfn [31;1mswap[0m(mut ref a: <T>, mut ref b: T)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mswap_indirect[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m2:21+13[0m

========

        noinline fn swap_indirect(          
            ref a: i32[],   ref b: i32[])   
                swap(a, b);

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            mut b = [ 1, 2, 3 ];
            swap_indirect(a, b);
            return a.len + b.len * 10 - 73;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void swap_indirect_MbR9(/*1:1*/ fu::vec_range_mut<int> a, /*2:2*/ fu::vec_range_mut<int> b)
{
    a.swap(b);
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> b = fu::vec<int> {{ 1, 2, 3 }};
    swap_indirect_MbR9(a, b);
    return (a.size() + (b.size() * 10)) - 73;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn swap_indirect(          
            ref a: i32[..])                 
        {
            mut b = [ 1, 2, 3 ];            
            swap(b, a);                     
            return b;
        }

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            let b = swap_indirect(a);
            return a.len + b.len * 10 - 73;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:13+4[0m:

[2m      |         {[0m
[2m      |             mut b = [ 1, 2, 3 ];            [0m
[2m    6 | [0m            [31;1mswap[0m(b, a);                     
[2m      |             return b;[0m
[2m      |         }[0m

	Bad call to [94;1mswap[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[][0m, [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[..][0m): 

	[35;3mtemplate[0m [94;1m<fu/vec/view_swap.h> fu::view_swap[0m at [2m../../../../../[0mprelude[2m 504:4+4[0m:
[2m  504 | [0mfn [31;1mswap[0m(mut ref a: <T>[..], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

	    Wrong number of arguments: expects 3, got 2.

	[35;3mtemplate[0m [94;1mswap[0m at [2m../../../../../[0mprelude[2m 216:4+4[0m:
[2m  216 | [0mfn [31;1mswap[0m(mut ref a: <T>, mut ref b: T)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mswap_indirect[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+13[0m

========

        noinline fn swap_indirect(          
            ref a: i32[..])                 
        {
            mut b = [ 1, 2, 3 ];            
            swap(a, b);                     
            return b;
        }

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            let b = swap_indirect(a);
            return a.len + b.len * 10 - 73;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:13+4[0m:

[2m      |         {[0m
[2m      |             mut b = [ 1, 2, 3 ];            [0m
[2m    6 | [0m            [31;1mswap[0m(a, b);                     
[2m      |             return b;[0m
[2m      |         }[0m

	Bad call to [94;1mswap[0m with args ([35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[..][0m, [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[][0m): 

	[35;3mtemplate[0m [94;1m<fu/vec/view_swap.h> fu::view_swap[0m at [2m../../../../../[0mprelude[2m 504:4+4[0m:
[2m  504 | [0mfn [31;1mswap[0m(mut ref a: <T>[..], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

	    Wrong number of arguments: expects 3, got 2.

	[35;3mtemplate[0m [94;1mswap[0m at [2m../../../../../[0mprelude[2m 216:4+4[0m:
[2m  216 | [0mfn [31;1mswap[0m(mut ref a: <T>, mut ref b: T)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mswap_indirect[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+13[0m

========

        noinline fn swap_indirect(          
            ref a: i32[])                   
        {
            mut b = [ 1, 2, 3 ];            
            swap(b, a);                     
            return b;
        }

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            let b = swap_indirect(a);
            return a.len + b.len * 10 - 73;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec<int> swap_indirect_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    /*MOV*/ fu::vec<int> b = fu::vec<int> {{ 1, 2, 3 }};
    b.swap(a);
    return /*NRVO*/ b;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> b = swap_indirect_MbR9(a);
    return (a.size() + (b.size() * 10)) - 73;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn swap_indirect(          
            ref a: i32[])                   
        {
            mut b = [ 1, 2, 3 ];            
            swap(a, b);                     
            return b;
        }

        fn main() {
            mut a = [ 4, 5, 6, 7, 8, 9, 10 ];
            let b = swap_indirect(a);
            return a.len + b.len * 10 - 73;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec<int> swap_indirect_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    /*MOV*/ fu::vec<int> b = fu::vec<int> {{ 1, 2, 3 }};
    a.swap(b);
    return /*NRVO*/ b;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> b = swap_indirect_MbR9(a);
    return (a.size() + (b.size() * 10)) - 73;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NC { items: NC[] };

        fn main() {
            mut whats = [ NC([ NC(), NC(), NC(), NC() ]), NC([ NC(), NC() ]), NC([ NC() ]), NC([ NC(), NC(), NC() ]) ];
            whats.sort(|a, b| a.items.len - b.items.len < 0);
            mut res = 0;
            for (mut i = 0; i < whats.len; i++) res = res * 10 + whats[i].items.len;
            return res == 1234 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(640) uniq_count(5) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>

struct NC_BA7N;

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = delete;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N&) = delete;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___BC56JBoSTki
                                #define DEF___BC56JBoSTki
inline static bool _BC56(/*3:3*/ const NC_BA7N& a, /*3:3*/ const NC_BA7N& b)
{
    return (a.items.size() - b.items.size()) < 0;
}
                                #endif

                                #ifndef DEF_sort_x2RvnmdY6R7
                                #define DEF_sort_x2RvnmdY6R7
inline static void sort_x2Rv(/*1:1*/ fu::vec_range_mut<NC_BA7N> a)
{
    NC_BA7N l {};
    NC_BA7N r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _BC56(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_JNW02nRWg67
                                #define DEF_sort_JNW02nRWg67
inline void sort_JNW0(/*3:3*/ fu::vec_range_mut<NC_BA7N> a)
{
    sort_x2Rv(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<NC_BA7N> whats = fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N{}, NC_BA7N{}, NC_BA7N{} }} }, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N{} }} }, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N{}, NC_BA7N{} }} } }};
    sort_JNW0(whats);
    int res = 0;
    for (int i = 0; i < whats.size(); i++)
        res = ((res * 10) + whats[i].items.size());

    if (res == 1234)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

          // ALLOCS 3/336

        struct NC { items: NC[] }

        fn takesInlineArg(mut a: NC[], inline b: NC[]) {
            a.splice(a.len / 2, 0, b);
            return a;
        }

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = default;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N& selfrec) { return *this = NC_BA7N(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> a {};
    fu::view<NC_BA7N> /*a*/ woot = (a = fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }}, a.splice((a.size() / 2), 0, fu::view<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }}), a);
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

          // ALLOCS 3/336

        struct NC { items: NC[] }

        fn takesInlineArg(mut a: NC[], inline b: NC[]) a ~= b;

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = default;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N& selfrec) { return *this = NC_BA7N(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> a {};
    fu::view<NC_BA7N> /*a*/ woot = (a = fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }}, (a += fu::view<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }}));
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

          // ALLOCS 3/336

        struct NC { items: NC[] }

        fn takesInlineArg(inline a: NC[], inline b: NC[]) a ~ b;

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = default;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N& selfrec) { return *this = NC_BA7N(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> woot = (fu::view<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }} + fu::view<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }});
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

           // ALLOCS 4/512
        nocopy

        struct NC { items: NC[] }

        fn takesInlineArg(mut a: NC[], inline b: NC[]) {
            a.splice(a.len / 2, 0, b);
            return a;
        }

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = delete;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N&) = delete;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> a {};
    fu::view<NC_BA7N> /*a*/ woot = (a = fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }}, a.splice((a.size() / 2), 0, fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }}), a);
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

           // ALLOCS 4/512
        nocopy

        struct NC { items: NC[] }

        fn takesInlineArg(mut a: NC[], inline b: NC[]) a ~= b;

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = delete;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N&) = delete;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> a {};
    fu::view<NC_BA7N> /*a*/ woot = (a = fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }}, (a += fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }}));
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

           // ALLOCS 4/512
        nocopy

        struct NC { items: NC[] }

        fn takesInlineArg(inline a: NC[], inline b: NC[]) a ~ b;

        fn count(items: NC[]) {
            mut count = items.len;
            items.each: |x| count += x.items.count;
            return count;
        }

        fn main() {
            let woot = takesInlineArg([ NC([ NC() ]), NC() ], [ NC(), NC([ NC() ]) ]);
            let count = woot.count;
            return count - 6;
        }

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct NC_BA7N;
static int count_MbR9(fu::view<NC_BA7N>);

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = delete;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N&) = delete;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___dPWBdsoO9yf
                                #define DEF___dPWBdsoO9yf
inline static int _dPWB(/*3:3*/ const NC_BA7N& x, /*3:3*/ int& count)
{
    return (count += count_MbR9(x.items));
}
                                #endif

                                #ifndef DEF_each_DjnL7Jnn0H6
                                #define DEF_each_DjnL7Jnn0H6
inline void each_DjnL(/*7:7*/ fu::view<NC_BA7N> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _dPWB(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<NC_BA7N> items)
{
    int count = items.size();
    each_DjnL(items, count);
    return count;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> woot = (fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }} + fu::vec<NC_BA7N> {{ NC_BA7N{}, NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} } }});
    const int count = count_MbR9(woot);
    return count - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        fn main() {
            mut arr = [ 1, 2, 3 ];
            let cpy = arr.map(|ref v| v++);
            mut sum_arr = 0; arr.each: |v| sum_arr += v;
            mut sum_cpy = 0; cpy.each: |v| sum_cpy += v;        // DuplicateFunctions
            return sum_arr == 9 && sum_cpy == 6 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___4n9IRCewvq2
                                #define DEF___4n9IRCewvq2
inline static int _4n9I(/*1:1*/ int& v)
{
    return v++;
}
                                #endif

                                #ifndef DEF_map_E33qIcPJZZj
                                #define DEF_map_E33qIcPJZZj
inline fu::vec<int> map_E33q(/*3:3*/ fu::view_mut<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _4n9I(a.mutref(i));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int v, /*3:3*/ int& sum_arr)
{
    return (sum_arr += v);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum_arr)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum_arr);

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3 }};
    fu::vec<int> cpy = map_E33q(arr);
    int sum_arr = 0;
    each_LBIs(arr, sum_arr);
    int sum_cpy = 0;
    each_LBIs(cpy, sum_cpy);
    if ((sum_arr == 9) && (sum_cpy == 6))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        nocopy struct NC { v: int };

        fn main() {
            mut v: NC[];    assert(v.len == 0);
            v ~= NC(0);     assert(v.len == 1);
            v ~= NC(1);     assert(v.len == 2);
            v ~= NC(2);     assert(v.len == 3);
            v ~= NC(3);     assert(v.len == 4);
            v ~= NC(4);     assert(v.len == 5);
            v ~= NC(5);     assert(v.len == 6);
            v ~= NC(6);     assert(v.len == 7);
            v ~= NC(7);     assert(v.len == 8);
            v ~= NC(8);     assert(v.len == 9);
            v ~= NC(9);     assert(v.len == 10);
            mut sum = 0;
            for (mut i = 0; i < v.len; i++) sum += v[i].v;
            return sum - 45 + v.len * 101 - 1010;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/assert.h>
#include <fu/vec/concat_one.h>

struct NC_a7dG;

                                #ifndef DEF_NC_a7dGBzYbTga
                                #define DEF_NC_a7dGBzYbTga
struct NC_a7dG
{
                                // shape_hash:    01c6e3a040636a77
                                // non_triv_mask: 0000100000000000
    int v;
    NC_a7dG(const NC_a7dG&) = delete;
    NC_a7dG(NC_a7dG&&) = default;
    NC_a7dG& operator=(const NC_a7dG&) = delete;
    NC_a7dG& operator=(NC_a7dG&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<NC_a7dG> v {};
    fu_ASSERT((v.size() == 0));
    v += NC_a7dG { 0 };
    fu_ASSERT((v.size() == 1));
    v += NC_a7dG { 1 };
    fu_ASSERT((v.size() == 2));
    v += NC_a7dG { 2 };
    fu_ASSERT((v.size() == 3));
    v += NC_a7dG { 3 };
    fu_ASSERT((v.size() == 4));
    v += NC_a7dG { 4 };
    fu_ASSERT((v.size() == 5));
    v += NC_a7dG { 5 };
    fu_ASSERT((v.size() == 6));
    v += NC_a7dG { 6 };
    fu_ASSERT((v.size() == 7));
    v += NC_a7dG { 7 };
    fu_ASSERT((v.size() == 8));
    v += NC_a7dG { 8 };
    fu_ASSERT((v.size() == 9));
    v += NC_a7dG { 9 };
    fu_ASSERT((v.size() == 10));
    int sum = 0;
    for (int i = 0; i < v.size(); i++)
        sum += v[i].v;

    return ((sum - 45) + (v.size() * 101)) - 1010;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        nocopy struct NC { v: int };

        fn generate(n: int) {
            mut v: NC[];
            for (mut i = 0; i < n; i++) v ~= NC(i);
            return v;
        }

        fn test(n: int) {

            mut a = generate(n);
            mut b = a;
            b.reverse();

            return b;
        }

        fn main() 7.test.len - 7;

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_swap.h>
#include <fu/vec/concat_one.h>

struct NC_a7dG;

                                #ifndef DEF_NC_a7dGBzYbTga
                                #define DEF_NC_a7dGBzYbTga
struct NC_a7dG
{
                                // shape_hash:    01c6e3a040636a77
                                // non_triv_mask: 0000100000000000
    int v;
    NC_a7dG(const NC_a7dG&) = delete;
    NC_a7dG(NC_a7dG&&) = default;
    NC_a7dG& operator=(const NC_a7dG&) = delete;
    NC_a7dG& operator=(NC_a7dG&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<NC_a7dG> generate_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> v {};
    for (int i = 0; i < n; i++)
    {
        v += NC_a7dG { i };
    };
    return /*NRVO*/ v;
}

                                #ifndef DEF_reverse_IodTQeFDKRj
                                #define DEF_reverse_IodTQeFDKRj
inline void reverse_IodT(/*1:1*/ fu::view_mut<NC_a7dG> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

static fu::vec<NC_a7dG> test_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> a = generate_MbR9(n);
    /*MOV*/ fu::vec<NC_a7dG> b = static_cast<fu::vec<NC_a7dG>&&>(a);
    reverse_IodT(b);
    return /*NRVO*/ b;
}

int fu_MAIN()
{
    return test_MbR9(7).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NC { v: int };

        fn generate(n: int) {
            mut v: NC[];
            for (mut i = 0; i < n; i++) v ~= NC(i);
            return v;
        }

        fn test(n: int) {

            mut a = generate(n);
            let b = a;

            return b;
        }

        fn main() 7.test.len - 7;

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NC_a7dG;

                                #ifndef DEF_NC_a7dGBzYbTga
                                #define DEF_NC_a7dGBzYbTga
struct NC_a7dG
{
                                // shape_hash:    01c6e3a040636a77
                                // non_triv_mask: 0000100000000000
    int v;
    NC_a7dG(const NC_a7dG&) = delete;
    NC_a7dG(NC_a7dG&&) = default;
    NC_a7dG& operator=(const NC_a7dG&) = delete;
    NC_a7dG& operator=(NC_a7dG&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<NC_a7dG> generate_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> v {};
    for (int i = 0; i < n; i++)
    {
        v += NC_a7dG { i };
    };
    return /*NRVO*/ v;
}

static fu::vec<NC_a7dG> test_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> a = generate_MbR9(n);
    /*MOV*/ fu::vec<NC_a7dG>& /*a*/ b = a;
    return static_cast<fu::vec<NC_a7dG>&&>(b);
}

int fu_MAIN()
{
    return test_MbR9(7).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NC { v: int };

        fn generate(n: int) {
            mut v: NC[];
            for (mut i = 0; i < n; i++) v ~= NC(i);
            return v;
        }

        fn test(n: int) {

            let a = generate(n);
            let b = a;

            return b;
        }

        fn main() 7.test.len - 7;

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NC_a7dG;

                                #ifndef DEF_NC_a7dGBzYbTga
                                #define DEF_NC_a7dGBzYbTga
struct NC_a7dG
{
                                // shape_hash:    01c6e3a040636a77
                                // non_triv_mask: 0000100000000000
    int v;
    NC_a7dG(const NC_a7dG&) = delete;
    NC_a7dG(NC_a7dG&&) = default;
    NC_a7dG& operator=(const NC_a7dG&) = delete;
    NC_a7dG& operator=(NC_a7dG&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<NC_a7dG> generate_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> v {};
    for (int i = 0; i < n; i++)
    {
        v += NC_a7dG { i };
    };
    return /*NRVO*/ v;
}

static fu::vec<NC_a7dG> test_MbR9(const int n)
{
    /*MOV*/ fu::vec<NC_a7dG> a = generate_MbR9(n);
    return /*NRVO*/ a;
}

int fu_MAIN()
{
    return test_MbR9(7).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zero    = nums[nums.len / 2];
            let allOnes = indirect_copy(nums);


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 8:41+4[0m:

[2m      | [0m
[2m      |             ref zero    = nums[nums.len / 2];[0m
[2m    8 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m24:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   24 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zero    = nums[nums.len / 2];
            let allOnes = nums;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 8:27+4[0m:

[2m      | [0m
[2m      |             ref zero    = nums[nums.len / 2];[0m
[2m    8 | [0m            let allOnes = [31;1mnums[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let allOnes = nums;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = indirect_copy(nums);
            ref zero    = nums[nums.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = indirect_copy_MbR9(nums);
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = nums;
            ref zero    = nums[nums.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = fu::vec<int>(nums);
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        let immovable: i32[] = [ 1, 2, 3 ];

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            ref zero    = nums[nums.len / 2];
            let woot    = OPAQUE && nums;


            let allOnes = indirect_copy(OPAQUE && woot);

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 15:48+2[0m:

[2m      | [0m
[2m      | [0m
[2m   15 | [0m            let allOnes = indirect_copy(OPAQUE [31;1m&&[0m woot);
[2m      | [0m
[2m      |             zero = 0;[0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m30:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   30 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m11:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let woot    = OPAQUE && nums;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m5:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        let immovable: i32[] = [ 1, 2, 3 ];

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            ref zero    = nums[nums.len / 2];
            let woot    = OPAQUE && nums;


            let allOnes = OPAQUE ? woot : immovable;

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 15:34+1[0m:

[2m      | [0m
[2m      | [0m
[2m   15 | [0m            let allOnes = OPAQUE [31;1m?[0m woot : immovable;
[2m      | [0m
[2m      |             zero = 0;[0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m11:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let woot    = OPAQUE && nums;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m5:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        let immovable: i32[] = [ 1, 2, 3 ];

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            let woot    = OPAQUE && nums;
            ref zero    = nums[nums.len / 2];


            let allOnes = indirect_copy(OPAQUE && woot);

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    fu::vec<int> woot = fu::vec<int>((OPAQUE ? nums : (*(fu::vec<int>*)fu::NIL)));
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    fu::vec<int> allOnes = indirect_copy_MbR9((OPAQUE ? woot : (*(fu::vec<int>*)fu::NIL)));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        let immovable: i32[] = [ 1, 2, 3 ];

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            let woot    = OPAQUE && nums;
            ref zero    = nums[nums.len / 2];


            let allOnes = OPAQUE ? woot : immovable;

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static const fu::vec<int> immovable fu_INIT_PRIORITY(1001) = fu::vec<int> {{ 1, 2, 3 }};

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    fu::vec<int> woot = fu::vec<int>((OPAQUE ? nums : (*(fu::vec<int>*)fu::NIL)));
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    fu::view<int> /*woot|static*/ allOnes = (OPAQUE ? woot : immovable);
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            let allOnes = indirect_copy(nums);
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 11:41+4[0m:

[2m      | [0m
[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m   11 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m28:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   28 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            let allOnes = nums;
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 11:27+4[0m:

[2m      | [0m
[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m   11 | [0m            let allOnes = [31;1mnums[0m;
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             let allOnes = nums;[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;
            let allOnes = indirect_copy(nums);


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 12:41+4[0m:

[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m   12 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m28:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   28 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      |             let allOnes = indirect_copy(nums);[0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;
            let allOnes = nums;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 12:27+4[0m:

[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m   12 | [0m            let allOnes = [31;1mnums[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      |             let allOnes = nums;[0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            let allOnes = indirect_copy(nums);
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    int other = 0;
    fu::vec<int> allOnes = indirect_copy_MbR9(nums);
    int& /*nums|static*/ woot = nums.mutref((nums.size() / 2));
    int& /*woot|other*/ zero = (OPAQUE ? woot : other);
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            let allOnes = nums;
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    int other = 0;
    fu::vec<int> allOnes = fu::vec<int>(nums);
    int& /*nums|static*/ woot = nums.mutref((nums.size() / 2));
    int& /*woot|other*/ zero = (OPAQUE ? woot : other);
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    return cow_after_ref_MbR9(allOnes, zero);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_indirect_MbR9(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    return cow_after_ref_MbR9(allOnes, zero);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_indirect_MbR9(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_MbR9(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_MbR9(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    return cow_after_ref_MbR9(zero, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_indirect_MbR9(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    return cow_after_ref_MbR9(zero, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_indirect_MbR9(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_MbR9(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_MbR9(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zeroes  = nums[10..20];
            let allOnes = indirect_copy(nums);


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 8:41+4[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[10..20];[0m
[2m    8 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m30:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   30 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzeroes[0m at [2m7:17+6[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzeroes[0m  = nums[10..20];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zeroes  = nums[10..20];
            let allOnes = nums;


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 8:27+4[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[10..20];[0m
[2m    8 | [0m            let allOnes = [31;1mnums[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzeroes[0m at [2m7:17+6[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzeroes[0m  = nums[10..20];
[2m      |             let allOnes = nums;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = indirect_copy(nums);
            ref zeroes  = nums[10..20];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = indirect_copy_MbR9(nums);
    fu::view_mut<int> /*nums*/ zeroes = fu::get_view_mut(nums, 10, 20);
    for (int i_1 = 0; i_1 < zeroes.size(); i_1++)
        zeroes.mutref(i_1) = 0;

    int o = 0;
    for (int i_2 = 0; i_2 < allOnes.size(); i_2++)
    {
        if (allOnes[i_2] == 1)
            o++;

    };
    int z = 0;
    for (int i_3 = 0; i_3 < zeroes.size(); i_3++)
    {
        if (!zeroes[i_3])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = nums;
            ref zeroes  = nums[10..20];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = fu::vec<int>(nums);
    fu::view_mut<int> /*nums*/ zeroes = fu::get_view_mut(nums, 10, 20);
    for (int i_1 = 0; i_1 < zeroes.size(); i_1++)
        zeroes.mutref(i_1) = 0;

    int o = 0;
    for (int i_2 = 0; i_2 < allOnes.size(); i_2++)
    {
        if (allOnes[i_2] == 1)
            o++;

    };
    int z = 0;
    for (int i_3 = 0; i_3 < zeroes.size(); i_3++)
    {
        if (!zeroes[i_3])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: i32[..]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: i32[..])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10..20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    return cow_after_ref_MbR9(allOnes, zeroes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_indirect_MbR9(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: i32[..]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: i32[..])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10..20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    return cow_after_ref_MbR9(allOnes, zeroes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_indirect_MbR9(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: i32[..]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: i32[..])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10..20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_MbR9(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: i32[..]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: i32[..])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10..20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ fu::view<int> allOnes, /*2:2*/ fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_MbR9(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zeroes: i32[..], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: i32[..], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10..20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    return cow_after_ref_MbR9(zeroes, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_indirect_MbR9(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zeroes: i32[..], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: i32[..], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10..20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    return cow_after_ref_MbR9(zeroes, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_indirect_MbR9(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zeroes: i32[..], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: i32[..], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10..20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_MbR9(nums), cow_after_ref_MbR9(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========


        noinline fn cow_after_ref_indirect(ref zeroes: i32[..], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: i32[..], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10..20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1344) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ fu::view_mut<int> zeroes, /*3:3*/ fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(/*bck:pra 1*/ nums), cow_after_ref_MbR9(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn test(ref nums: i32[][])
        {

            ref zeroes  = nums[nums.len / 2];
            mut allOnes = indirect_copy(nums[nums.len / 2]);


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 6:45+1[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[nums.len / 2];[0m
[2m    6 | [0m            mut allOnes = indirect_copy(nums[31;1m[[0mnums.len / 2]);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m36:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   36 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzeroes[0m at [2m5:17+6[0m:

[2m      |         {[0m
[2m      | [0m
[2m    5 | [0m            ref [31;1mzeroes[0m  = nums[nums.len / 2];
[2m      |             mut allOnes = indirect_copy(nums[nums.len / 2]);[0m
[2m      | [0m

	Both refer to: [35;3mmut ref arg[0m [94;1mnums[0m at [2m2:21+4[0m:

[2m      | [0m
[2m    2 | [0m        fn test(ref [31;1mnums[0m: i32[][])
[2m      |         {[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[][0m[35;3m[..][0m) at [2m2:12+4[0m

========

        fn test(ref nums: i32[][])
        {

            ref zeroes  = nums[nums.len / 2];
            mut allOnes = nums[nums.len / 2];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 6:31+1[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[nums.len / 2];[0m
[2m    6 | [0m            mut allOnes = nums[31;1m[[0mnums.len / 2];
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzeroes[0m at [2m5:17+6[0m:

[2m      |         {[0m
[2m      | [0m
[2m    5 | [0m            ref [31;1mzeroes[0m  = nums[nums.len / 2];
[2m      |             mut allOnes = nums[nums.len / 2];[0m
[2m      | [0m

	Both refer to: [35;3mmut ref arg[0m [94;1mnums[0m at [2m2:21+4[0m:

[2m      | [0m
[2m    2 | [0m        fn test(ref [31;1mnums[0m: i32[][])
[2m      |         {[0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[][0m[35;3m[..][0m) at [2m2:12+4[0m

========

        fn test(ref nums: i32[][])
        {

            mut allOnes = indirect_copy(nums[nums.len / 2]);
            ref zeroes  = nums[nums.len / 2];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(672) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_MbR9(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int test_MbR9(/*1:1*/ fu::view_mut<fu::vec<int>> nums)
{
    fu::vec<int> allOnes = indirect_copy_MbR9(nums[(nums.size() / 2)]);
    fu::view_mut<int> /*nums|static*/ zeroes = nums.mutref((nums.size() / 2));
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((o == 10) && (z == 10))
        return 0;
    else
        return 10;

}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> nums {};
    for (int i = 0; i < 4; i++)
    {
        nums += fu::vec<int> {{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }};
    };
    return test_MbR9(nums);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(ref nums: i32[][])
        {

            mut allOnes = nums[nums.len / 2];
            ref zeroes  = nums[nums.len / 2];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(672) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view_mut<fu::vec<int>> nums)
{
    fu::vec<int> allOnes = fu::vec<int>(nums[(nums.size() / 2)]);
    fu::view_mut<int> /*nums|static*/ zeroes = nums.mutref((nums.size() / 2));
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((o == 10) && (z == 10))
        return 0;
    else
        return 10;

}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> nums {};
    for (int i = 0; i < 4; i++)
    {
        nums += fu::vec<int> {{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }};
    };
    return test_MbR9(nums);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            ref zero    = orig.ones[orig.ones.len / 2];
            let all     = indirect_copy(orig);


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 15:41+4[0m:

[2m      | [0m
[2m      |             ref zero    = orig.ones[orig.ones.len / 2];[0m
[2m   15 | [0m            let all     = indirect_copy([31;1morig[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1mtv[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m via [35;3mfn[0m [94;1mindirect_copy[0m at [2m34:27+13[0m:

[2m      | [0m
[2m      |         noinline fn indirect_copy(tv: TwoVecs)[0m
[2m   34 | [0m            TwoVecs(ones: [31;1mindirect_copy[0m(tv.ones),
[2m      |                     twos: indirect_copy(tv.twos));[0m
[2m      | [0m

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m40:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   40 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   14 | [0m            ref [31;1mzero[0m    = orig.ones[orig.ones.len / 2];
[2m      |             let all     = indirect_copy(orig);[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1morig[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    7 | [0m            mut [31;1morig[0m: TwoVecs;
[2m      |             for (mut i = 0; i < 100; i++) {[0m
[2m      |                 orig.ones ~= 1;[0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            ref zero    = orig.ones[orig.ones.len / 2];
            let all     = orig;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 15:27+4[0m:

[2m      | [0m
[2m      |             ref zero    = orig.ones[orig.ones.len / 2];[0m
[2m   15 | [0m            let all     = [31;1morig[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mzero[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   14 | [0m            ref [31;1mzero[0m    = orig.ones[orig.ones.len / 2];
[2m      |             let all     = orig;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1morig[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    7 | [0m            mut [31;1morig[0m: TwoVecs;
[2m      |             for (mut i = 0; i < 100; i++) {[0m
[2m      |                 orig.ones ~= 1;[0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            let all     = indirect_copy(orig);
            ref zero    = orig.ones[orig.ones.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_kGbb(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static TwoVecs_sRjl indirect_copy_MbR9(/*1:1*/ const TwoVecs_sRjl& tv)
{
    return TwoVecs_sRjl { indirect_copy_kGbb(tv.ones), indirect_copy_kGbb(tv.twos) };
}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl all = indirect_copy_MbR9(orig);
    int& /*orig|static*/ zero = orig.ones.mutref((orig.ones.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < all.ones.size(); i_1++)
    {
        if (all.ones[i_1] == 1)
            o++;

    };
    int t = 0;
    for (int i_2 = 0; i_2 < all.twos.size(); i_2++)
    {
        if (all.twos[i_2] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            let all     = orig;
            ref zero    = orig.ones[orig.ones.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl all = orig;
    int& /*orig|static*/ zero = orig.ones.mutref((orig.ones.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < all.ones.size(); i_1++)
    {
        if (all.ones[i_1] == 1)
            o++;

    };
    int t = 0;
    for (int i_2 = 0; i_2 < all.twos.size(); i_2++)
    {
        if (all.twos[i_2] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_kGbb(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static TwoVecs_sRjl indirect_copy_MbR9(/*1:1*/ const TwoVecs_sRjl& tv)
{
    return TwoVecs_sRjl { indirect_copy_kGbb(tv.ones), indirect_copy_kGbb(tv.twos) };
}

static int cow_after_ref_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    return cow_after_ref_MbR9(all, zero);
}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = indirect_copy_MbR9(orig), cow_after_ref_indirect_MbR9(static_cast<TwoVecs_sRjl&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    return cow_after_ref_MbR9(all, zero);
}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = TwoVecs_sRjl(/*bck:pra 1*/ orig), cow_after_ref_indirect_MbR9(static_cast<TwoVecs_sRjl&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_kGbb(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static TwoVecs_sRjl indirect_copy_MbR9(/*1:1*/ const TwoVecs_sRjl& tv)
{
    return TwoVecs_sRjl { indirect_copy_kGbb(tv.ones), indirect_copy_kGbb(tv.twos) };
}

static int cow_after_ref_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = indirect_copy_MbR9(orig), cow_after_ref_MbR9(static_cast<TwoVecs_sRjl&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*3:3*/ const TwoVecs_sRjl& all, /*2:2*/ int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = TwoVecs_sRjl(/*bck:pra 1*/ orig), cow_after_ref_MbR9(static_cast<TwoVecs_sRjl&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_kGbb(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static TwoVecs_sRjl indirect_copy_MbR9(/*1:1*/ const TwoVecs_sRjl& tv)
{
    return TwoVecs_sRjl { indirect_copy_kGbb(tv.ones), indirect_copy_kGbb(tv.twos) };
}

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    return cow_after_ref_MbR9(zero, all);
}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = indirect_copy_MbR9(orig), cow_after_ref_indirect_MbR9(orig.ones.mutref((orig.ones.size() / 2)), static_cast<TwoVecs_sRjl&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    return cow_after_ref_MbR9(zero, all);
}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = TwoVecs_sRjl(/*bck:pra 1*/ orig), cow_after_ref_indirect_MbR9(orig.ones.mutref((orig.ones.size() / 2)), static_cast<TwoVecs_sRjl&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_kGbb(/*1:1*/ fu::vec_range<int> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static TwoVecs_sRjl indirect_copy_MbR9(/*1:1*/ const TwoVecs_sRjl& tv)
{
    return TwoVecs_sRjl { indirect_copy_kGbb(tv.ones), indirect_copy_kGbb(tv.twos) };
}

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = indirect_copy_MbR9(orig), cow_after_ref_MbR9(orig.ones.mutref((orig.ones.size() / 2)), static_cast<TwoVecs_sRjl&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2192) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct TwoVecs_sRjl;

                                #ifndef DEF_TwoVecs_sRjlw4Q46Kg
                                #define DEF_TwoVecs_sRjlw4Q46Kg
struct TwoVecs_sRjl
{
                                // shape_hash:    61f46369df7a503c
                                // non_triv_mask: 0008040000000000
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_MbR9(/*1:1*/ int& zero, /*3:3*/ const TwoVecs_sRjl& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    TwoVecs_sRjl orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    TwoVecs_sRjl _0 {};
    return (_0 = TwoVecs_sRjl(/*bck:pra 1*/ orig), cow_after_ref_MbR9(orig.ones.mutref((orig.ones.size() / 2)), static_cast<TwoVecs_sRjl&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            ref x = arr[0];
            mut barr = indirect_copy(arr);


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 20:38+3[0m:

[2m      | [0m
[2m      |             ref x = arr[0];[0m
[2m   20 | [0m            mut barr = indirect_copy([31;1marr[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1mindirect_copy[0m:[94;1marr[0m to [35;3mfn[0m [94;1mindirect_copy[0m is indirectly copied from:

            in [35;3mfn[0m [94;1mindirect_copy[0m at [2m31:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..][0m
[2m   31 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mx[0m at [2m19:17+1[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref [31;1mx[0m = arr[0];
[2m      |             mut barr = indirect_copy(arr);[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1marr[0m at [2m16:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m15:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            ref x = arr[0];
            mut barr = arr;


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 20:24+3[0m:

[2m      | [0m
[2m      |             ref x = arr[0];[0m
[2m   20 | [0m            mut barr = [31;1marr[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mx[0m at [2m19:17+1[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref [31;1mx[0m = arr[0];
[2m      |             mut barr = arr;[0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1marr[0m at [2m16:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m15:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            mut barr = indirect_copy(arr);
            ref x = arr[0];


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> indirect_copy_MbR9(/*1:1*/ fu::vec_range<fu::vec<int>> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<fu::vec<int>>(arr);

}

static void test_MbR9(/*3:3*/ fu::vec_range_mut<fu::vec<int>> barr, /*3:2*/ fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> {{ 0 }};
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_7whlMBFhUG5
                                #define DEF_x3Cx3E_7whlMBFhUG5
inline int x3Cx3E_7whl(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_2Y4m(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_64VgszJXODa
                                #define DEF_x3Dx3D_64VgszJXODa
inline bool operator==(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_7whl(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7 }}, fu::vec<int> {{ 8, 9, 10, 11, 12, 13, 14, 15 }} }};
    fu::vec<fu::vec<int>> barr = indirect_copy_MbR9(arr);
    fu::view_mut<int> /*arr|static*/ x = arr.mutref(0);
    test_MbR9(barr, x);
    if (barr == fu::view<fu::vec<int>> {{ fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}, fu::vec<int> {{ 9, 10, 11, 12, 13, 14, 15, 16 }}, fu::vec<int> {{ 0 }} }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            mut barr = arr;
            ref x = arr[0];


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(896) arc_count(8) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*3:3*/ fu::vec_range_mut<fu::vec<int>> barr, /*3:2*/ fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> {{ 0 }};
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_7whlMBFhUG5
                                #define DEF_x3Cx3E_7whlMBFhUG5
inline int x3Cx3E_7whl(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_2Y4m(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_64VgszJXODa
                                #define DEF_x3Dx3D_64VgszJXODa
inline bool operator==(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_7whl(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7 }}, fu::vec<int> {{ 8, 9, 10, 11, 12, 13, 14, 15 }} }};
    fu::vec<fu::vec<int>> barr = fu::vec<fu::vec<int>>(arr);
    fu::view_mut<int> /*arr|static*/ x = arr.mutref(0);
    test_MbR9(barr, x);
    if (barr == fu::view<fu::vec<int>> {{ fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}, fu::vec<int> {{ 9, 10, 11, 12, 13, 14, 15, 16 }}, fu::vec<int> {{ 0 }} }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = indirect_copy(b);
            ref x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mouter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m27:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = b;
            ref x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mouter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m27:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            ref x = a[0];
            mut barr = indirect_copy(b);


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mouter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m27:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            ref x = a[0];
            mut barr = b;


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- <fail> ----
[2m[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mouter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mouter[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mouter[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m27:12+4[0m

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = indirect_copy(b);
            mut x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1008) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> indirect_copy_MbR9(/*1:1*/ fu::vec_range<fu::vec<int>> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<fu::vec<int>>(arr);

}

static void test_MbR9(/*3:3*/ fu::vec_range_mut<fu::vec<int>> barr, /*3:2*/ fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> {{ 0 }};
}

static fu::vec<fu::vec<int>> outer_MbR9(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::vec_range<fu::vec<int>> b)
{
    /*MOV*/ fu::vec<fu::vec<int>> barr = indirect_copy_MbR9(b);
    fu::vec<int> x = fu::vec<int>(a[0]);
    test_MbR9(barr, x);
    return /*NRVO*/ barr;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_7whlMBFhUG5
                                #define DEF_x3Cx3E_7whlMBFhUG5
inline int x3Cx3E_7whl(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_2Y4m(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_64VgszJXODa
                                #define DEF_x3Dx3D_64VgszJXODa
inline bool operator==(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_7whl(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7 }}, fu::vec<int> {{ 8, 9, 10, 11, 12, 13, 14, 15 }} }};
    fu::vec<fu::vec<int>> barr = outer_MbR9(arr, arr);
    if (barr == fu::view<fu::vec<int>> {{ fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}, fu::vec<int> {{ 9, 10, 11, 12, 13, 14, 15, 16 }}, fu::vec<int> {{ 0 }} }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = b;
            mut x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1008) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*3:3*/ fu::vec_range_mut<fu::vec<int>> barr, /*3:2*/ fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> {{ 0 }};
}

static fu::vec<fu::vec<int>> outer_MbR9(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::vec_range<fu::vec<int>> b)
{
    /*MOV*/ fu::vec<fu::vec<int>> barr = fu::vec<fu::vec<int>>(b);
    fu::vec<int> x = fu::vec<int>(a[0]);
    test_MbR9(barr, x);
    return /*NRVO*/ barr;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_7whlMBFhUG5
                                #define DEF_x3Cx3E_7whlMBFhUG5
inline int x3Cx3E_7whl(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_2Y4m(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_64VgszJXODa
                                #define DEF_x3Dx3D_64VgszJXODa
inline bool operator==(/*3:3*/ fu::view<fu::vec<int>> a, /*3:3*/ fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_7whl(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7 }}, fu::vec<int> {{ 8, 9, 10, 11, 12, 13, 14, 15 }} }};
    fu::vec<fu::vec<int>> barr = outer_MbR9(arr, arr);
    if (barr == fu::view<fu::vec<int>> {{ fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}, fu::vec<int> {{ 9, 10, 11, 12, 13, 14, 15, 16 }}, fu::vec<int> {{ 0 }} }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Ephemeral {
            id:             i32;
            scope_skip?:    Ephemeral[];
        };

        struct SolverState {
            _scope_skip:    Ephemeral[];
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint
            eph.scope_skip = indirect_copy(s._scope_skip);
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.len - 3;
        }

        noinline fn indirect_copy!<T>(arr: T[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolverState_7Xhy;
struct Ephemeral_H5FT;

                                #ifndef DEF_SolverState_7XhyFVsBrn8
                                #define DEF_SolverState_7XhyFVsBrn8
struct SolverState_7Xhy
{
                                // shape_hash:    57b0ede5522e5916
                                // non_triv_mask: 0000000200000201
    fu::vec<Ephemeral_H5FT> _scope_skip;
    fu::vec<Ephemeral_H5FT> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_Ephemeral_H5FTF8XIwxh
                                #define DEF_Ephemeral_H5FTF8XIwxh
struct Ephemeral_H5FT
{
                                // shape_hash:    d90d904bb07ee4cc
                                // non_triv_mask: 0000000200000001
    int id;
    fu::vec<Ephemeral_H5FT> scope_skip;
    Ephemeral_H5FT(const Ephemeral_H5FT&) = default;
    Ephemeral_H5FT(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(const Ephemeral_H5FT& selfrec) { return *this = Ephemeral_H5FT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_indirect_copy_VxZCCneKjHf
                                #define DEF_indirect_copy_VxZCCneKjHf
inline static fu::vec<Ephemeral_H5FT> indirect_copy_VxZC(/*1:1*/ fu::vec_range<Ephemeral_H5FT> arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<Ephemeral_H5FT>(arr);

}
                                #endif

static const Ephemeral_H5FT& snap_kGbb(const int i, /*3:3*/ SolverState_7Xhy& s)
{
    Ephemeral_H5FT& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = indirect_copy_VxZC(s._scope_skip);
    return eph;
}

int fu_MAIN()
{
    SolverState_7Xhy s = SolverState_7Xhy { fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 1, fu::vec<Ephemeral_H5FT>{} }, Ephemeral_H5FT { 2, fu::vec<Ephemeral_H5FT>{} }, Ephemeral_H5FT { 3, fu::vec<Ephemeral_H5FT>{} } }}, fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 4, fu::vec<Ephemeral_H5FT>{} } }} };
    return snap_kGbb(0, s).scope_skip.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Ephemeral {
            id:             i32;
            scope_skip?:    Ephemeral[];
        };

        struct SolverState {
            _scope_skip:    Ephemeral[];
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint
            eph.scope_skip = s._scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.len - 3;
        }

        noinline fn indirect_copy!<T>(arr: T[])
            arr.len & 1
                ? arr[.. arr.len / 2] ~ arr[arr.len / 2 ..]
                : arr; // <- we take this branch

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct SolverState_7Xhy;
struct Ephemeral_H5FT;

                                #ifndef DEF_SolverState_7XhyFVsBrn8
                                #define DEF_SolverState_7XhyFVsBrn8
struct SolverState_7Xhy
{
                                // shape_hash:    57b0ede5522e5916
                                // non_triv_mask: 0000000200000201
    fu::vec<Ephemeral_H5FT> _scope_skip;
    fu::vec<Ephemeral_H5FT> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_Ephemeral_H5FTF8XIwxh
                                #define DEF_Ephemeral_H5FTF8XIwxh
struct Ephemeral_H5FT
{
                                // shape_hash:    d90d904bb07ee4cc
                                // non_triv_mask: 0000000200000001
    int id;
    fu::vec<Ephemeral_H5FT> scope_skip;
    Ephemeral_H5FT(const Ephemeral_H5FT&) = default;
    Ephemeral_H5FT(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(const Ephemeral_H5FT& selfrec) { return *this = Ephemeral_H5FT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Ephemeral_H5FT& snap_kGbb(const int i, /*3:3*/ SolverState_7Xhy& s)
{
    Ephemeral_H5FT& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = s._scope_skip;
    return eph;
}

int fu_MAIN()
{
    SolverState_7Xhy s = SolverState_7Xhy { fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 1, fu::vec<Ephemeral_H5FT>{} }, Ephemeral_H5FT { 2, fu::vec<Ephemeral_H5FT>{} }, Ephemeral_H5FT { 3, fu::vec<Ephemeral_H5FT>{} } }}, fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 4, fu::vec<Ephemeral_H5FT>{} } }} };
    return snap_kGbb(0, s).scope_skip.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        // This one unrelated to COW but variation of test above.

        struct ScopeSkip { // When first, we complain about recursive types
            left:           Ephemeral[];
            right:          Ephemeral[];
        };

        struct Ephemeral { // When first, we cg declarations in the wrong order
            id:             i32;
            scope_skip?:    ScopeSkip;
        };


        struct SolverState {
            _scope_skip:    ScopeSkip;
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            mut scope_skip  = s._scope_skip;
            ref eph         = s._ephs[i];
            eph.scope_skip  = scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: ScopeSkip(
                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                    [ Ephemeral(4), Ephemeral(5) ]
                ),
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.left.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(464) arc_count(3) ] ----
#include <fu/vec.h>

struct SolverState_f8CB;
struct ScopeSkip_jABu;
struct Ephemeral_ygp8;

                                #ifndef DEF_ScopeSkip_jABuk1yRIY0
                                #define DEF_ScopeSkip_jABuk1yRIY0
struct ScopeSkip_jABu
{
                                // shape_hash:    f843fdce087686b0
                                // non_triv_mask: 0008020004000000
    fu::vec<Ephemeral_ygp8> left;
    fu::vec<Ephemeral_ygp8> right;
    ScopeSkip_jABu(const ScopeSkip_jABu&) = default;
    ScopeSkip_jABu(ScopeSkip_jABu&&) = default;
    ScopeSkip_jABu& operator=(ScopeSkip_jABu&&) = default;
    ScopeSkip_jABu& operator=(const ScopeSkip_jABu& selfrec) { return *this = ScopeSkip_jABu(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_f8CBsnyTPKc
                                #define DEF_SolverState_f8CBsnyTPKc
struct SolverState_f8CB
{
                                // shape_hash:    f49d2be3e2902949
                                // non_triv_mask: 0008020004000000
    ScopeSkip_jABu _scope_skip;
    fu::vec<Ephemeral_ygp8> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_Ephemeral_ygp8qrnZ7pg
                                #define DEF_Ephemeral_ygp8qrnZ7pg
struct Ephemeral_ygp8
{
                                // shape_hash:    6a97edcb39d251fb
                                // non_triv_mask: 0008020004000000
    int id;
    ScopeSkip_jABu scope_skip;
    Ephemeral_ygp8(const Ephemeral_ygp8&) = default;
    Ephemeral_ygp8(Ephemeral_ygp8&&) = default;
    Ephemeral_ygp8& operator=(Ephemeral_ygp8&&) = default;
    Ephemeral_ygp8& operator=(const Ephemeral_ygp8& selfrec) { return *this = Ephemeral_ygp8(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Ephemeral_ygp8& snap_kGbb(const int i, /*3:3*/ SolverState_f8CB& s)
{
    const ScopeSkip_jABu& /*s*/ scope_skip = s._scope_skip;
    Ephemeral_ygp8& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = scope_skip;
    return eph;
}

int fu_MAIN()
{
    SolverState_f8CB s = SolverState_f8CB { ScopeSkip_jABu { fu::vec<Ephemeral_ygp8> {{ Ephemeral_ygp8 { 1, ScopeSkip_jABu{} }, Ephemeral_ygp8 { 2, ScopeSkip_jABu{} }, Ephemeral_ygp8 { 3, ScopeSkip_jABu{} } }}, fu::vec<Ephemeral_ygp8> {{ Ephemeral_ygp8 { 4, ScopeSkip_jABu{} }, Ephemeral_ygp8 { 5, ScopeSkip_jABu{} } }} }, fu::vec<Ephemeral_ygp8> {{ Ephemeral_ygp8 { 4, ScopeSkip_jABu{} } }} };
    return snap_kGbb(0, s).scope_skip.left.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        // This one unrelated to COW but variation of test above.

        struct Ephemeral { // When first, we cg declarations in the wrong order
            id:             i32;
            scope_skip?:    ScopeSkip;
        };

        struct ScopeSkip { // When first, we complain about recursive types
            left:           Ephemeral[];
            right:          Ephemeral[];
        };


        struct SolverState {
            _scope_skip:    ScopeSkip;
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            mut scope_skip  = s._scope_skip;
            ref eph         = s._ephs[i];
            eph.scope_skip  = scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: ScopeSkip(
                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                    [ Ephemeral(4), Ephemeral(5) ]
                ),
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.left.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(464) arc_count(3) ] ----
#include <fu/vec.h>

struct SolverState_V7to;
struct ScopeSkip_MngI;
struct Ephemeral_H5FT;

                                #ifndef DEF_ScopeSkip_MngIAd8flE0
                                #define DEF_ScopeSkip_MngIAd8flE0
struct ScopeSkip_MngI
{
                                // shape_hash:    2cca1fb58f634970
                                // non_triv_mask: 4000000200000001
    fu::vec<Ephemeral_H5FT> left;
    fu::vec<Ephemeral_H5FT> right;
    ScopeSkip_MngI(const ScopeSkip_MngI&) = default;
    ScopeSkip_MngI(ScopeSkip_MngI&&) = default;
    ScopeSkip_MngI& operator=(ScopeSkip_MngI&&) = default;
    ScopeSkip_MngI& operator=(const ScopeSkip_MngI& selfrec) { return *this = ScopeSkip_MngI(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_V7to6WVLl1e
                                #define DEF_SolverState_V7to6WVLl1e
struct SolverState_V7to
{
                                // shape_hash:    f7fa6489b2c0253a
                                // non_triv_mask: 4000000200000009
    ScopeSkip_MngI _scope_skip;
    fu::vec<Ephemeral_H5FT> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_Ephemeral_H5FTF8XIwxh
                                #define DEF_Ephemeral_H5FTF8XIwxh
struct Ephemeral_H5FT
{
                                // shape_hash:    d90d904bb07ee4cc
                                // non_triv_mask: 4000000200000001
    int id;
    ScopeSkip_MngI scope_skip;
    Ephemeral_H5FT(const Ephemeral_H5FT&) = default;
    Ephemeral_H5FT(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(Ephemeral_H5FT&&) = default;
    Ephemeral_H5FT& operator=(const Ephemeral_H5FT& selfrec) { return *this = Ephemeral_H5FT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Ephemeral_H5FT& snap_kGbb(const int i, /*3:3*/ SolverState_V7to& s)
{
    const ScopeSkip_MngI& /*s*/ scope_skip = s._scope_skip;
    Ephemeral_H5FT& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = scope_skip;
    return eph;
}

int fu_MAIN()
{
    SolverState_V7to s = SolverState_V7to { ScopeSkip_MngI { fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 1, ScopeSkip_MngI{} }, Ephemeral_H5FT { 2, ScopeSkip_MngI{} }, Ephemeral_H5FT { 3, ScopeSkip_MngI{} } }}, fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 4, ScopeSkip_MngI{} }, Ephemeral_H5FT { 5, ScopeSkip_MngI{} } }} }, fu::vec<Ephemeral_H5FT> {{ Ephemeral_H5FT { 4, ScopeSkip_MngI{} } }} };
    return snap_kGbb(0, s).scope_skip.left.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Node { items: Node[] };

        fn unwrap_all(ref nodes: Node[]) {
            for (mut i = 0; i < nodes.len; i++) {
                ref n = nodes[i];
                if (n.items)        // cannotCOW false pos
                    n = n.items[0]; //  copy(n.items[0]) <- ref n
            }                       //   via parent nodes
        }

        fn count(nodes: Node[]) {
            mut N = nodes.len;
            for (mut i = 0; i < nodes.len; i++)
                N += nodes[i].items.count;
            return N;
        }

        fn main() {
            mut nodes = [ Node([ Node() ]) ];
            nodes.unwrap_all();
            return nodes.count - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Node_zYlo;
static int count_MbR9(fu::view<Node_zYlo>);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void unwrap_all_MbR9(/*1:1*/ fu::view_mut<Node_zYlo> nodes)
{
    for (int i = 0; i < nodes.size(); i++)
    {
        Node_zYlo& /*nodes|static*/ n = nodes.mutref(i);
        if (n.items)
            n = n.items[0];

    };
}

static int count_MbR9(/*1:1*/ fu::view<Node_zYlo> nodes)
{
    int N = nodes.size();
    for (int i = 0; i < nodes.size(); i++)
        N += count_MbR9(nodes[i].items);

    return N;
}

int fu_MAIN()
{
    fu::vec<Node_zYlo> nodes = fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{} }} } }};
    unwrap_all_MbR9(nodes);
    return count_MbR9(nodes) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall

========

        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {
            ref either = (a || b)[0];

            if (either.len & 1 == 0)
                either ~= 1;
            else
                b = a;

        }

        fn arr(n: i32) {
            mut arr: i32[];
            for (mut i = 1; i <= n; i++) arr ~= i;
            return arr;
        }

        fn check(arr: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum;
        }

        fn check(arr: i32[][]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);
            return sum;
        }

        fn main() {
            mut a = [ arr( 8), arr( 9) ];
            mut b = [ arr(10), arr(11) ];

            conditionalCopyOrWrite(:a, :b);

            return check(a) == 3600 + 45 + 100
                && check(b) == 5500 + 66
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(672) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> arr_MbR9(const int n)
{
    /*MOV*/ fu::vec<int> arr {};
    for (int i = 1; (i <= n); i++)
        arr += i;

    return /*NRVO*/ arr;
}

static void conditionalCopyOrWrite_MbR9(/*3:1*/ fu::vec_range_mut<fu::vec<int>> a, /*2:2*/ fu::vec_range_mut<fu::vec<int>> b)
{
    fu::vec_range_mut<int> /*a|b|static*/ either = (a ? a : b).mutref(0);
    if ((either.size() & 1) == 0)
        either += 1;
    else
        b = a;

}

static int check_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

static int check_kGbb(/*1:1*/ fu::view<fu::vec<int>> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum = ((sum * 100) + check_MbR9(arr[i]));

    return sum;
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> {{ arr_MbR9(8), arr_MbR9(9) }};
    fu::vec<fu::vec<int>> b = fu::vec<fu::vec<int>> {{ arr_MbR9(10), arr_MbR9(11) }};
    conditionalCopyOrWrite_MbR9(a, b);
    if ((check_kGbb(a) == ((3600 + 45) + 100)) && (check_kGbb(b) == (5500 + 66)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {
            ref either = (a || b)[0];

            if (either.len & 1)
                b = a;              // <- no issue here
            else                    //  either only written to
                either ~= 1;        //   if copy never created.

        }

        fn arr(n: i32) {
            mut arr: i32[];
            for (mut i = 1; i <= n; i++) arr ~= i;
            return arr;
        }

        fn check(arr: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum;
        }

        fn check(arr: i32[][]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);
            return sum;
        }

        fn main() {
            mut a = [ arr( 8), arr( 9) ];
            mut b = [ arr(10), arr(11) ];

            conditionalCopyOrWrite(:a, :b);

            return check(a) == 3600 + 45 + 100
                && check(b) == 5500 + 66
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(672) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> arr_MbR9(const int n)
{
    /*MOV*/ fu::vec<int> arr {};
    for (int i = 1; (i <= n); i++)
        arr += i;

    return /*NRVO*/ arr;
}

static void conditionalCopyOrWrite_MbR9(/*3:1*/ fu::vec_range_mut<fu::vec<int>> a, /*2:2*/ fu::vec_range_mut<fu::vec<int>> b)
{
    fu::vec_range_mut<int> /*a|b|static*/ either = (a ? a : b).mutref(0);
    if (either.size() & 1)
        b = a;
    else
        either += 1;

}

static int check_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

static int check_kGbb(/*1:1*/ fu::view<fu::vec<int>> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum = ((sum * 100) + check_MbR9(arr[i]));

    return sum;
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> {{ arr_MbR9(8), arr_MbR9(9) }};
    fu::vec<fu::vec<int>> b = fu::vec<fu::vec<int>> {{ arr_MbR9(10), arr_MbR9(11) }};
    conditionalCopyOrWrite_MbR9(a, b);
    if ((check_kGbb(a) == ((3600 + 45) + 100)) && (check_kGbb(b) == (5500 + 66)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            result.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateThenCopy(a, a);
            return 1000 * a.count + b.count - 2004;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD mutateThenCopy_MbR9(/*3:1*/ SolvedNode_9NmD& callsite, /*3:3*/ const SolvedNode_9NmD& root)
{
    callsite.items += SolvedNode_9NmD(callsite);
    /*MOV*/ SolvedNode_9NmD result = root;
    result.items += SolvedNode_9NmD(root);
    return /*NRVO*/ result;
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

int fu_MAIN()
{
    SolvedNode_9NmD a {};
    SolvedNode_9NmD b = mutateThenCopy_MbR9(a, a);
    return ((1000 * count_MbR9(a)) + count_MbR9(b)) - 2004;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                result.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopy();
            return 1000 * a.count + b.count - 2004;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD copyRoot_MbR9(/*1:1*/ const SolvedNode_9NmD& root)
{
    /*MOV*/ SolvedNode_9NmD result = root;
    result.items += SolvedNode_9NmD(root);
    return /*NRVO*/ result;
}

static SolvedNode_9NmD bck_call_MbR9(/*3:1*/ SolvedNode_9NmD& callsite, /*3:3*/ const SolvedNode_9NmD& root)
{
    callsite.items += SolvedNode_9NmD(callsite);
    return copyRoot_MbR9(root);
}

static SolvedNode_9NmD mutateThenCopy_MbR9(/*1:1*/ SolvedNode_9NmD& root)
{
    return bck_call_MbR9(root, root);
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

int fu_MAIN()
{
    SolvedNode_9NmD a {};
    SolvedNode_9NmD b = mutateThenCopy_MbR9(a);
    return ((1000 * count_MbR9(a)) + count_MbR9(b)) - 2004;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            root.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateCopyMutate(a, a);
            return 1000 * a.count + b.count - 4002;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD mutateCopyMutate_MbR9(/*3:1*/ SolvedNode_9NmD& callsite, /*3:2*/ SolvedNode_9NmD& root)
{
    callsite.items += SolvedNode_9NmD(callsite);
    /*MOV*/ SolvedNode_9NmD result = root;
    root.items += SolvedNode_9NmD(root);
    return /*NRVO*/ result;
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

int fu_MAIN()
{
    SolvedNode_9NmD a {};
    SolvedNode_9NmD b = mutateCopyMutate_MbR9(a, a);
    return ((1000 * count_MbR9(a)) + count_MbR9(b)) - 4002;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk, N_COWRestrict

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                root.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateCopyMutate();
            return 1000 * a.count + b.count - 4002;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD copyRoot_MbR9(/*1:1*/ SolvedNode_9NmD& root)
{
    /*MOV*/ SolvedNode_9NmD result = root;
    root.items += SolvedNode_9NmD(root);
    return /*NRVO*/ result;
}

static SolvedNode_9NmD bck_call_MbR9(/*3:1*/ SolvedNode_9NmD& callsite, /*3:2*/ SolvedNode_9NmD& root)
{
    callsite.items += SolvedNode_9NmD(callsite);
    return copyRoot_MbR9(root);
}

static SolvedNode_9NmD mutateCopyMutate_MbR9(/*1:1*/ SolvedNode_9NmD& root)
{
    return bck_call_MbR9(root, root);
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

int fu_MAIN()
{
    SolvedNode_9NmD a {};
    SolvedNode_9NmD b = mutateCopyMutate_MbR9(a);
    return ((1000 * count_MbR9(a)) + count_MbR9(b)) - 4002;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk, N_COWRestrict

========

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            ref  items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i == 0) items[i].items ~= escape;
                else        escape = root;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

---- <fail> ----
[2m[0m_0[2m.fu 27:46+4[0m:

[2m      | [0m
[2m      |             mut root = Node([ Node, Node ]);[0m
[2m   27 | [0m            obtuseEscapeOnNextLoopIter(root, [31;1mroot[0m);
[2m      | [0m
[2m      |             // Now root should be:[0m

	At call to [35;3mfn[0m [94;1mobtuseEscapeOnNextLoopIter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mroot[0m and
	    1:	[35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mnode[0m

	    both alias:

	    [35;3mmut[0m [94;1mroot[0m at [2m26:17+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   26 | [0m            mut [31;1mroot[0m = Node([ Node, Node ]);
[2m      |             obtuseEscapeOnNextLoopIter(root, root);[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mroot[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mnode[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            ref  items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i)      escape = root;
                else        items[i].items ~= escape;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

---- <fail> ----
[2m[0m_0[2m.fu 27:46+4[0m:

[2m      | [0m
[2m      |             mut root = Node([ Node, Node ]);[0m
[2m   27 | [0m            obtuseEscapeOnNextLoopIter(root, [31;1mroot[0m);
[2m      | [0m
[2m      |             // Now root should be:[0m

	At call to [35;3mfn[0m [94;1mobtuseEscapeOnNextLoopIter[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mroot[0m and
	    1:	[35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mnode[0m

	    both alias:

	    [35;3mmut[0m [94;1mroot[0m at [2m26:17+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   26 | [0m            mut [31;1mroot[0m = Node([ Node, Node ]);
[2m      |             obtuseEscapeOnNextLoopIter(root, root);[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mroot[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mobtuseEscapeOnNextLoopIter[0m:[94;1mnode[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            fn   items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i == 0) items[i].items ~= escape;
                else        escape = root;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Node_zYlo;
static int count_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Node_zYlo> items_haRm(/*1:1*/ const Node_zYlo& node)
{
    return node.items;
}

static fu::view_mut<Node_zYlo> items_GL0m(/*1:1*/ Node_zYlo& node)
{
    return node.items;
}

static void obtuseEscapeOnNextLoopIter_MbR9(/*3:1*/ Node_zYlo& node, /*3:3*/ const Node_zYlo& root)
{
    Node_zYlo escape {};
    for (int i = items_haRm(node).size(); i-- > 0; )
    {
        if (i == 0)
            items_GL0m(node).mutref(i).items += Node_zYlo(escape);
        else
            escape = root;

    };
}

                                #ifndef DEF___ApEe3EovLQ4
                                #define DEF___ApEe3EovLQ4
inline static int _ApEe(/*3:3*/ const Node_zYlo& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_TwFbhZnX9jh
                                #define DEF_each_TwFbhZnX9jh
inline void each_TwFb(/*7:7*/ fu::view<Node_zYlo> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _ApEe(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const Node_zYlo& node)
{
    int c = 1;
    each_TwFb(node.items, c);
    return c;
}

int fu_MAIN()
{
    Node_zYlo root = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} };
    obtuseEscapeOnNextLoopIter_MbR9(root, root);
    return count_MbR9(root) - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk, N_COWRestrict

========

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            fn   items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i)      escape = root;
                else        items[i].items ~= escape;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Node_zYlo;
static int count_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Node_zYlo> items_haRm(/*1:1*/ const Node_zYlo& node)
{
    return node.items;
}

static fu::view_mut<Node_zYlo> items_GL0m(/*1:1*/ Node_zYlo& node)
{
    return node.items;
}

static void obtuseEscapeOnNextLoopIter_MbR9(/*3:1*/ Node_zYlo& node, /*3:3*/ const Node_zYlo& root)
{
    Node_zYlo escape {};
    for (int i = items_haRm(node).size(); i-- > 0; )
    {
        if (i)
            escape = root;
        else
            items_GL0m(node).mutref(i).items += Node_zYlo(escape);

    };
}

                                #ifndef DEF___ApEe3EovLQ4
                                #define DEF___ApEe3EovLQ4
inline static int _ApEe(/*3:3*/ const Node_zYlo& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_TwFbhZnX9jh
                                #define DEF_each_TwFbhZnX9jh
inline void each_TwFb(/*7:7*/ fu::view<Node_zYlo> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _ApEe(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const Node_zYlo& node)
{
    int c = 1;
    each_TwFb(node.items, c);
    return c;
}

int fu_MAIN()
{
    Node_zYlo root = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} };
    obtuseEscapeOnNextLoopIter_MbR9(root, root);
    return count_MbR9(root) - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_AARSoftRisk, N_COWRestrict

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {
            if (a.items.len & 1) {
                ref items = a.items;
                for (mut i = 0; i < items.len; i++)
                    cowAfterConditionalWithLoop(items[i], b);
            }

            a.items ~= b;
        }

        fn main() {
            mut x = SolvedNode([ SolvedNode ]);

            ref y = x;  
            cowAfterConditionalWithLoop(x, y);                  // N_COWRestrict

            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            return x.count == 6 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:44+1[0m:

[2m      | [0m
[2m      |             ref y = x;  [0m
[2m   20 | [0m            cowAfterConditionalWithLoop(x, [31;1my[0m);                  // N_COWRestrict
[2m      | [0m
[2m      |             fn count(node: SolvedNode) {[0m

	At call to [35;3mfn[0m [94;1mcowAfterConditionalWithLoop[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mcowAfterConditionalWithLoop[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mcowAfterConditionalWithLoop[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mx[0m at [2m17:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mx[0m = SolvedNode([ SolvedNode ]);
[2m      | [0m
[2m      |             ref y = x;  [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mcowAfterConditionalWithLoop[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mcowAfterConditionalWithLoop[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {
            if (a.items.len & 1) {
                ref items = a.items;
                for (mut i = 0; i < items.len; i++)
                    cowAfterConditionalWithLoop(items[i], b);
            }

            a.items ~= b;
        }

        fn main() {
            mut x = SolvedNode([ SolvedNode ]);

            mut y = x;  
            cowAfterConditionalWithLoop(x, y);                  // N_COWRestrict

            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            return x.count == 6 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static void cowAfterConditionalWithLoop_MbR9(SolvedNode_9NmD&, const SolvedNode_9NmD&);
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void cowAfterConditionalWithLoop_MbR9(/*1:1*/ SolvedNode_9NmD& a, /*3:3*/ const SolvedNode_9NmD& b)
{
    if (a.items.size() & 1)
    {
        fu::view_mut<SolvedNode_9NmD> /*a*/ items = a.items;
        for (int i = 0; i < items.size(); i++)
            cowAfterConditionalWithLoop_MbR9(items.mutref(i), b);

    };
    a.items += SolvedNode_9NmD(b);
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

int fu_MAIN()
{
    SolvedNode_9NmD x = SolvedNode_9NmD { fu::vec<SolvedNode_9NmD> {{ SolvedNode_9NmD{} }} };
    SolvedNode_9NmD y = x;
    cowAfterConditionalWithLoop_MbR9(x, y);
    if (count_MbR9(x) == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_COWRestrict

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)
        {
            fn fail(reason: string)
                reason.len & 1 && throw("odd: " ~ reason)
                               || throw(reason);

            fn bck_node(ref node: SolvedNode) {
                ref items = node.items;
                for (mut i = 0; i < items.len; i++) {
                    ref item = items[i];
                    bck_node(item);

                    if (item.items.len > 1) {
                        escape = root;

                        if (escape.items.len > 3)        // !DEV_DontFoldLiterals
                            fail("#" ~ escape.items.len);
                    }
                }

                node.items ~= node;
            }

            bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut escape: SolvedNode;
            mut a = SolvedNode([ SolvedNode ]);
            a.copiesRootBeforeThrow(:escape);

            let C0 = a.count;
            if (C0 != 6)            return 1;

            try {
                a.copiesRootBeforeThrow(:escape);
            }
            catch (e) {
                a.items ~= SolvedNode(); // escape !== a
                let C1 = a.count;
                let C2 = escape.count;
                if (C1 != 11)           return 2;
                if (C2 != 10)           return 3;
                else if (e != "#2")     return 4;
                else                    return 0;
            }

            return 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 29:13+8[0m:

[2m      |             }[0m
[2m      | [0m
[2m   29 | [0m            [31;1mbck_node[0m(root);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mbck_node[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mbck_node[0m:[94;1mcopiesRootBeforeThrow:root[0m and
	    1:	[35;3mref arg[0m [94;1mbck_node[0m:[94;1mnode[0m

	    both alias:

	    [35;3mmut ref arg[0m [94;1mroot[0m at [2m6:38+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m    6 | [0m        fn copiesRootBeforeThrow(ref [31;1mroot[0m: SolvedNode, ref escape: SolvedNode)
[2m      |         {[0m
[2m      |             fn fail(reason: string)[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mbck_node[0m:[94;1mcopiesRootBeforeThrow:root[0m is [31;1mimplicit[0m

	    [35;3mref arg[0m [94;1mbck_node[0m:[94;1mnode[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mcopiesRootBeforeThrow[0m([94;1mSolvedNode[0m, [94;1mSolvedNode[0m) at [2m6:12+21[0m

========

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)
        {
            fn fail(reason: string)
                reason.len & 1 && throw("odd: " ~ reason)
                               || throw(reason);

            fn bck_node(ref node: SolvedNode) {
                ref items = node.items;
                for (mut i = 0; i < items.len; i++) {
                    ref item = items[i];
                    bck_node(item);

                    if (item.items.len > 1) {
                        escape = root;

                        if (true)                        // !DEV_DontFoldLiterals
                            fail("#" ~ escape.items.len);
                    }
                }

                node.items ~= node;
            }

            bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut escape: SolvedNode;
            mut a = SolvedNode([ SolvedNode ]);
            a.copiesRootBeforeThrow(:escape);

            let C0 = a.count;
            if (C0 != 6)            return 1;

            try {
                a.copiesRootBeforeThrow(:escape);
            }
            catch (e) {
                a.items ~= SolvedNode(); // escape !== a
                let C1 = a.count;
                let C2 = escape.count;
                if (C1 != 11)           return 2;
                if (C2 != 10)           return 3;
                else if (e != "#2")     return 4;
                else                    return 0;
            }

            return 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(784) arc_count(7) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct SolvedNode_9NmD;
static void bck_node_MbR9(SolvedNode_9NmD&, const SolvedNode_9NmD&, SolvedNode_9NmD&);
static int count_MbR9(const SolvedNode_9NmD&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_MbR9(/*1:1*/ fu::vec_range<char> reason)
{
    if (reason.size() & 1)
        fu::fail(("odd: "_view + reason));
    else
        fu::fail(fu::str(reason));

}

static void bck_node_MbR9(/*7:1*/ SolvedNode_9NmD& node, /*7:7*/ const SolvedNode_9NmD& root, /*6:4*/ SolvedNode_9NmD& escape)
{
    fu::view_mut<SolvedNode_9NmD> /*node*/ items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        SolvedNode_9NmD& /*items|static*/ item = items.mutref(i);
        bck_node_MbR9(item, root, escape);
        if (item.items.size() > 1)
        {
            escape = root;
            fail_MbR9(x7E_rA00("#"_view, fu::i64dec(escape.items.size())));
        };
    };
    node.items += SolvedNode_9NmD(node);
}

static void copiesRootBeforeThrow_MbR9(/*3:1*/ SolvedNode_9NmD& root, /*2:2*/ SolvedNode_9NmD& escape)
{
    bck_node_MbR9(root, root, escape);
}

                                #ifndef DEF___T8BFiYeUbB3
                                #define DEF___T8BFiYeUbB3
inline static int _T8BF(/*3:3*/ const SolvedNode_9NmD& item, /*3:3*/ int& c)
{
    return (c += count_MbR9(item));
}
                                #endif

                                #ifndef DEF_each_SFdv1BozLAe
                                #define DEF_each_SFdv1BozLAe
inline void each_SFdv(/*7:7*/ fu::view<SolvedNode_9NmD> a, /*7:6*/ int& c)
{
    for (int i = 0; i < a.size(); i++)
        _T8BF(a[i], c);

}
                                #endif

static int count_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int c = 1;
    each_SFdv(node.items, c);
    return c;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    SolvedNode_9NmD escape {};
    SolvedNode_9NmD a = SolvedNode_9NmD { fu::vec<SolvedNode_9NmD> {{ SolvedNode_9NmD{} }} };
    copiesRootBeforeThrow_MbR9(a, escape);
    const int C0 = count_MbR9(a);
    if (C0 != 6)
        return 1;
    else
    {

        try
        {
            copiesRootBeforeThrow_MbR9(a, escape);
        }
        catch (const std::exception& o_0)
        {
            fu::str e = fu::to_str(o_0.what());

        {
            a.items += SolvedNode_9NmD{};
            const int C1 = count_MbR9(a);
            const int C2 = count_MbR9(escape);
            if (C1 != 11)
                return 2;
            else if (C2 != 10)
                return 3;
            else if (e != "#2"_view)
                return 4;
            else
                return 0;

        }
        }
;
        return 5;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_UnusedLet, N_AARSoftRisk, N_COWRestrict

========

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            mut ret = a;

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            ref  bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 21:56+1[0m:

[2m      |             ref  bytes = a.ints.view(of: byte);[0m
[2m      | [0m
[2m   21 | [0m            let b = copyInts_then_mutateBytes(:bytes, :[31;1ma[0m);
[2m      | [0m
[2m      |             mut sum = 0;[0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mbytes[0m at [2m19:18+5[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref  [31;1mbytes[0m = a.ints.view(of: byte);
[2m      | [0m
[2m      |             let b = copyInts_then_mutateBytes(:bytes, :a);[0m

	Both refer to: [35;3mmut[0m [94;1ma[0m at [2m16:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1ma[0m = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m15:12+4[0m

========

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            mut ret = a;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            ref  bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 21:56+1[0m:

[2m      |             ref  bytes = a.ints.view(of: byte);[0m
[2m      | [0m
[2m   21 | [0m            let b = copyInts_then_mutateBytes(:bytes, :[31;1ma[0m);
[2m      | [0m
[2m      |             mut sum = 0;[0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mbytes[0m at [2m19:18+5[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref  [31;1mbytes[0m = a.ints.view(of: byte);
[2m      | [0m
[2m      |             let b = copyInts_then_mutateBytes(:bytes, :a);[0m

	Both refer to: [35;3mmut[0m [94;1ma[0m at [2m16:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1ma[0m = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m15:12+4[0m

========

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            mut ret = a;

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            fn   bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct A_EPBj;

                                #ifndef DEF_A_EPBj5Db3hU7
                                #define DEF_A_EPBj5Db3hU7
struct A_EPBj
{
                                // shape_hash:    e2eae91573dfa1c5
                                // non_triv_mask: 0008000000040000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view_mut<char> bytes_MbR9(/*1:1*/ A_EPBj& a)
{
    return fu::view_of_mut<char>(a.ints);
}

static A_EPBj copyInts_then_mutateBytes_MbR9(/*1:1*/ fu::view_mut<char> bytes, /*3:3*/ const A_EPBj& a)
{
    /*MOV*/ A_EPBj ret = a;
    for (int i = 0; i < bytes.size(); i++)
        bytes.mutref(i) = char(0);

    ret.ints.pop();
    return /*NRVO*/ ret;
}

int fu_MAIN()
{
    A_EPBj a = A_EPBj { fu::vec<int> {{ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 }} };
    A_EPBj _0 {};
    A_EPBj b = (_0 = A_EPBj(/*bck:pra 1*/ a), copyInts_then_mutateBytes_MbR9(bytes_MbR9(a), static_cast<A_EPBj&&>(_0)));
    int sum = 0;
    for (int i = 0; i < b.ints.size(); i++)
        sum += b.ints[i];

    return sum - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq, N_COWRestrict

========

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            mut ret = a;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            fn   bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct A_EPBj;

                                #ifndef DEF_A_EPBj5Db3hU7
                                #define DEF_A_EPBj5Db3hU7
struct A_EPBj
{
                                // shape_hash:    e2eae91573dfa1c5
                                // non_triv_mask: 0008000000040000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view_mut<char> bytes_MbR9(/*1:1*/ A_EPBj& a)
{
    return fu::view_of_mut<char>(a.ints);
}

static A_EPBj copyInts_then_mutateBytes_MbR9(/*1:1*/ fu::view_mut<char> bytes, /*3:3*/ const A_EPBj& a)
{
    for (int i = 0; i < bytes.size(); i++)
        bytes.mutref(i) = char(0);

    /*MOV*/ A_EPBj ret = a;
    ret.ints.pop();
    return /*NRVO*/ ret;
}

int fu_MAIN()
{
    A_EPBj a = A_EPBj { fu::vec<int> {{ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 }} };
    A_EPBj _0 {};
    A_EPBj b = (_0 = A_EPBj(/*bck:pra 1*/ a), copyInts_then_mutateBytes_MbR9(bytes_MbR9(a), static_cast<A_EPBj&&>(_0)));
    int sum = 0;
    for (int i = 0; i < b.ints.size(); i++)
        sum += b.ints[i];

    return sum - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

========

        struct Wrapper { str: string };

        fn validateCOW_falsePos_with_typeMayPointInto_disabled(
            ref _scope: Wrapper[])
        {
            fn findFirstSet() {
                _scope.each: |wrapper|
                    if (wrapper.str)
                        return wrapper.str;

                return "None";
            }

            fn wrapper_cannotPointInto_String(h: int) {
                ref wrapper = _scope[h];
                wrapper.str = findFirstSet();
            }

            for (mut i = 0; i < _scope.len; i++)
                wrapper_cannotPointInto_String(i);
        }

        fn main() {
            mut _scope = [ Wrapper() ];
            validateCOW_falsePos_with_typeMayPointInto_disabled(_scope);
            return _scope.len == 1 && _scope[0].str.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Wrapper_Bbm8;

                                #ifndef DEF_Wrapper_Bbm8ja0tNpj
                                #define DEF_Wrapper_Bbm8ja0tNpj
struct Wrapper_Bbm8
{
                                // shape_hash:    7514c5acf29b622e
                                // non_triv_mask: 0000880000000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_tf6g7LwvTed
                                #define STR_tf6g7LwvTed
static const fu::str str_tf6g7LwvTed fu_INIT_PRIORITY(1001) { "None"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> findFirstSet_MbR9(/*1:1*/ fu::view<Wrapper_Bbm8> _scope)
{
    for (int i = 0; i < _scope.size(); i++)
    {
        const Wrapper_Bbm8& /*_scope|static*/ wrapper = _scope[i];
        if (wrapper.str)
            return wrapper.str;

    };
    return str_tf6g7LwvTed;
}

static void wrapper_cannotPointInto_String_MbR9(const int h, /*3:3*/ fu::view_mut<Wrapper_Bbm8> _scope)
{
    Wrapper_Bbm8& /*_scope|static*/ wrapper = _scope.mutref(h);
    wrapper.str = findFirstSet_MbR9(_scope);
}

static void validateCOW_falsePos_with_typeMayPointInto_disabled_MbR9(/*1:1*/ fu::view_mut<Wrapper_Bbm8> _scope)
{
    for (int i = 0; i < _scope.size(); i++)
        wrapper_cannotPointInto_String_MbR9(i, _scope);

}

int fu_MAIN()
{
    fu::vec<Wrapper_Bbm8> _scope = fu::vec<Wrapper_Bbm8> {{ Wrapper_Bbm8{} }};
    validateCOW_falsePos_with_typeMayPointInto_disabled_MbR9(_scope);
    if (_scope.size() == 1)
        return _scope[0].str.size() - 4;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Wrapper { str: string };

        fn validateCOW_falsePos_with_typeMayPointInto_disabled(
            ref _scope: Wrapper[])
        {
            fn findFirstSet() {
                _scope.each: |wrapper|
                    if (wrapper.str)
                        return wrapper.str;

                return "None";
            }

            fn wrapper_cannotPointInto_String(h: int) {
                ref wrapper = _scope[h];
                wrapper.str = findFirstSet();
            }

            for (mut i = 0; i < _scope.len; i++)
                wrapper_cannotPointInto_String(i);
        }

        fn main() {
            mut _scope = [ Wrapper() ];
            validateCOW_falsePos_with_typeMayPointInto_disabled(_scope);
            return _scope.len == 1 && _scope[0].str.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>

struct Wrapper_Bbm8;

                                #ifndef DEF_Wrapper_Bbm8ja0tNpj
                                #define DEF_Wrapper_Bbm8ja0tNpj
struct Wrapper_Bbm8
{
                                // shape_hash:    7514c5acf29b622e
                                // non_triv_mask: 0000880000000000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

                                #ifndef STR_tf6g7LwvTed
                                #define STR_tf6g7LwvTed
static const fu::str str_tf6g7LwvTed fu_INIT_PRIORITY(1001) { "None"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& findFirstSet_MbR9(/*1:1*/ fu::view<Wrapper_Bbm8> _scope)
{
    for (int i = 0; i < _scope.size(); i++)
    {
        const Wrapper_Bbm8& /*_scope|static*/ wrapper = _scope[i];
        if (wrapper.str)
            return wrapper.str;

    };
    return str_tf6g7LwvTed;
}

static void wrapper_cannotPointInto_String_MbR9(const int h, /*3:3*/ fu::view_mut<Wrapper_Bbm8> _scope)
{
    Wrapper_Bbm8& /*_scope|static*/ wrapper = _scope.mutref(h);
    wrapper.str = findFirstSet_MbR9(_scope);
}

static void validateCOW_falsePos_with_typeMayPointInto_disabled_MbR9(/*1:1*/ fu::view_mut<Wrapper_Bbm8> _scope)
{
    for (int i = 0; i < _scope.size(); i++)
        wrapper_cannotPointInto_String_MbR9(i, _scope);

}

int fu_MAIN()
{
    fu::vec<Wrapper_Bbm8> _scope = fu::vec<Wrapper_Bbm8> {{ Wrapper_Bbm8{} }};
    validateCOW_falsePos_with_typeMayPointInto_disabled_MbR9(_scope);
    if (_scope.size() == 1)
        return _scope[0].str.size() - 4;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy: int[][];
            copy.splice(0, 0, data);


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:31+4[0m:

[2m      | [0m
[2m      |             mut copy: int[][];[0m
[2m   10 | [0m            copy.splice(0, 0, [31;1mdata[0m);
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m.splice[0m:[94;1mb[0m to [35;3m__native[0m [94;1m.splice[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy: int[][];
            copy ~= [ 0, 0, 0, 0 ];
            copy ~= data;


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:21+4[0m:

[2m      |             mut copy: int[][];[0m
[2m      |             copy ~= [ 0, 0, 0, 0 ];[0m
[2m   11 | [0m            copy ~= [31;1mdata[0m;
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +=[0m:[94;1mb[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy: int[][];
            copy ~= data[.. data.len / 2];
            copy ~= data[data.len / 2 ..];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:25+1[0m:

[2m      |             mut copy: int[][];[0m
[2m      |             copy ~= data[.. data.len / 2];[0m
[2m   11 | [0m            copy ~= data[31;1m[[0mdata.len / 2 ..];
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +=[0m:[94;1mb[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy = data[.. 1] ~ data[1 ..];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:28+1[0m:

[2m      | [0m
[2m      | [0m
[2m    9 | [0m            mut copy = data[31;1m[[0m.. 1] ~ data[1 ..];
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +[0m:[94;1ma[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy = data ~ [ [ 0, 0, 0, 0 ] ];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:24+4[0m:

[2m      | [0m
[2m      | [0m
[2m    9 | [0m            mut copy = [31;1mdata[0m ~ [ [ 0, 0, 0, 0 ] ];
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat.h> +[0m:[94;1ma[0m to [35;3m__native[0m [94;1m<fu/vec/concat.h> +[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy = data ~ [ 0, 0, 0, 0 ];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:24+4[0m:

[2m      | [0m
[2m      | [0m
[2m    9 | [0m            mut copy = [31;1mdata[0m ~ [ 0, 0, 0, 0 ];
[2m      | [0m
[2m      | [0m

	[35;3marg[0m [94;1m<fu/vec/concat_one.h> +[0m:[94;1ma[0m to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m is indirectly copied from:

	... but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            ref  item = data[0][1];


            mut copy = data;


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:24+4[0m:

[2m      | [0m
[2m      | [0m
[2m    9 | [0m            mut copy = [31;1mdata[0m;
[2m      | [0m
[2m      | [0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;3mmut ref[0m [94;1mitem[0m at [2m6:18+4[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m            ref  [31;1mitem[0m = data[0][1];
[2m      | [0m
[2m      | [0m

	Both refer to: [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy: int[][];
            copy.splice(0, 0, data);


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy {};
    copy.splice(0, 0, data);
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy: int[][];
            copy ~= [ 0, 0, 0, 0 ];
            copy ~= data;


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy {};
    copy += fu::vec<int> {{ 0, 0, 0, 0 }};
    copy += data;
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy: int[][];
            copy ~= data[.. data.len / 2];
            copy ~= data[data.len / 2 ..];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy {};
    copy += fu::get_view_start0(data, (data.size() / 2));
    copy += fu::get_view(data, (data.size() / 2));
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy = data[.. 1] ~ data[1 ..];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy = (fu::get_view_start0(data, 1) + fu::get_view(data, 1));
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy = data ~ [ [ 0, 0, 0, 0 ] ];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy = (data + fu::view<fu::vec<int>> {{ fu::vec<int> {{ 0, 0, 0, 0 }} }});
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy = data ~ [ 0, 0, 0, 0 ];


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::vec<fu::vec<int>> copy = (data + fu::vec<int> {{ 0, 0, 0, 0 }});
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut data: int[][] = [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ] ];


            mut  item = data[0][1];


            mut copy = data;


            item += 1000;

            mut sum = 0;
            copy.each: .each(|x| sum += x);
            return item == 1001 && sum == 190 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

                                #ifndef DEF___mRhHBthW2fb
                                #define DEF___mRhHBthW2fb
inline static void _mRhH(/*3:3*/ fu::view<int> _, /*3:2*/ int& sum)
{
    each_LBIs(_, sum);
}
                                #endif

                                #ifndef DEF_each_ImUVtWqnxK1
                                #define DEF_each_ImUVtWqnxK1
inline void each_ImUV(/*7:7*/ fu::view<fu::vec<int>> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _mRhH(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> data = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }}, fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }};
    int item = data[0][1];
    fu::view<fu::vec<int>> /*data*/ copy = data;
    item += 1000;
    int sum = 0;
    each_ImUV(copy, sum);
    if ((item == 1001) && (sum == 190))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.push(5);
        if ((arr0[1] + arr0[4] - arr0[5]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.push(5);
        if ((arr1[1] + arr1[4] - arr1[5]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.push(5);
        if ((arr2[1] + arr2[4] - arr2[5]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.push(5);
        if (((arr0[1] + arr0[4]) - arr0[5]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.push(5);
        if (((arr1[1] + arr1[4]) - arr1[5]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.push(5);
        if (((orig[1] + orig[4]) - orig[5]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(5, 5);
        if ((arr0[1] + arr0[4] - arr0[5]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(5, 5);
        if ((arr1[1] + arr1[4] - arr1[5]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(5, 5);
        if ((arr2[1] + arr2[4] - arr2[5]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.insert(5, 5);
        if (((arr0[1] + arr0[4]) - arr0[5]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.insert(5, 5);
        if (((arr1[1] + arr1[4]) - arr1[5]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(5, 5);
        if (((orig[1] + orig[4]) - orig[5]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.pop();
        if ((arr0[1] + arr0[3] - arr0.len) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.pop();
        if ((arr1[1] + arr1[3] - arr1.len) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.pop();
        if ((arr2[1] + arr2[3] - arr2.len) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.pop();
        if (((arr0[1] + arr0[3]) - arr0.size()) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.pop();
        if (((arr1[1] + arr1[3]) - arr1.size()) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.pop();
        if (((orig[1] + orig[3]) - orig.size()) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.splice(4, 1);
        if ((arr0[1] + arr0[3] - arr0.len) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.splice(4, 1);
        if ((arr1[1] + arr1[3] - arr1.len) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.splice(4, 1);
        if ((arr2[1] + arr2[3] - arr2.len) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.splice(4, 1);
        if (((arr0[1] + arr0[3]) - arr0.size()) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.splice(4, 1);
        if (((arr1[1] + arr1[3]) - arr1.size()) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.splice(4, 1);
        if (((orig[1] + orig[3]) - orig.size()) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.unshift(5);
        if ((arr0[2] + arr0[5] - arr0[0]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.unshift(5);
        if ((arr1[2] + arr1[5] - arr1[0]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.unshift(5);
        if ((arr2[2] + arr2[5] - arr2[0]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.unshift(5);
        if (((arr0[2] + arr0[5]) - arr0[0]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.unshift(5);
        if (((arr1[2] + arr1[5]) - arr1[0]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.unshift(5);
        if (((orig[2] + orig[5]) - orig[0]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(0, 5);
        if ((arr0[2] + arr0[5] - arr0[0]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(0, 5);
        if ((arr1[2] + arr1[5] - arr1[0]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(0, 5);
        if ((arr2[2] + arr2[5] - arr2[0]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.insert(0, 5);
        if (((arr0[2] + arr0[5]) - arr0[0]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.insert(0, 5);
        if (((arr1[2] + arr1[5]) - arr1[0]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(0, 5);
        if (((orig[2] + orig[5]) - orig[0]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.shift();
        if ((arr0[0] + arr0[2] - arr0[3]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.shift();
        if ((arr1[0] + arr1[2] - arr1[3]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.shift();
        if ((arr2[0] + arr2[2] - arr2[3]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.shift();
        if (((arr0[0] + arr0[2]) - arr0[3]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.shift();
        if (((arr1[0] + arr1[2]) - arr1[3]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.shift();
        if (((orig[0] + orig[2]) - orig[3]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(1, 5);
        if ((arr0[2] + arr0[5] - arr0[1]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(1, 5);
        if ((arr1[2] + arr1[5] - arr1[1]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(1, 5);
        if ((arr2[2] + arr2[5] - arr2[1]) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 4 }};
        arr0.insert(1, 5);
        if (((arr0[2] + arr0[5]) - arr0[1]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 4 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.insert(1, 5);
        if (((arr1[2] + arr1[5]) - arr1[1]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(1, 5);
        if (((orig[2] + orig[5]) - orig[1]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


    {
        mut arr0 = [0,1,2,3,100];
        arr0.splice(1, 3);
        if ((arr0.len + arr0[0] + arr0[1] - 102) != 0) return 13;
    }

    mut orig = [0,1,2,3,100];

    {
        mut arr1 = orig;
        arr1.splice(1, 3);
        if ((arr1.len + arr1[0] + arr1[1] - 102) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.splice(1, 3);
        if ((arr2.len + arr2[0] + arr2[1] - 102) != 0) return 23;
    }

    return 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> {{ 0, 1, 2, 3, 100 }};
        arr0.splice(1, 3);
        if ((((arr0.size() + arr0[0]) + arr0[1]) - 102) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> {{ 0, 1, 2, 3, 100 }};

    {
        fu::vec<int> arr1 = fu::vec<int>(orig);
        arr1.splice(1, 3);
        if ((((arr1.size() + arr1[0]) + arr1[1]) - 102) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.splice(1, 3);
        if ((((orig.size() + orig[0]) + orig[1]) - 102) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        let OPERATORS = [ "+", "-", "*", "/" ];

        fn main()
            OPERATORS[2] == "*" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<fu::str> OPERATORS fu_INIT_PRIORITY(1001) = fu::vec<fu::str> {{ fu::str("+"_fu), fu::str("-"_fu), fu::str("*"_fu), fu::str("/"_fu) }};

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (OPERATORS[2] == "*"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct X_QZxx;
struct Y_6ak8;

                                #ifndef DEF_Y_6ak8CabLsm9
                                #define DEF_Y_6ak8CabLsm9
struct Y_6ak8
{
                                // shape_hash:    2eede1d214a7c0d6
                                // non_triv_mask: 0000000000000000
    bool b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_X_QZxxKwl0imd
                                #define DEF_X_QZxxKwl0imd
struct X_QZxx
{
                                // shape_hash:    69eb5a894cb4b9b9
                                // non_triv_mask: 0000040800000000
    fu::vec<Y_6ak8> y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<X_QZxx> x {};
    x.push(X_QZxx { fu::vec<Y_6ak8> {{ Y_6ak8 { true } }} });
    return (x.size() + (x[0].y.size() * 2)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct SelfRec { x: SelfRec[]; };
        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SelfRec_IItR;

                                #ifndef DEF_SelfRec_IItRIgj2uXe
                                #define DEF_SelfRec_IItRIgj2uXe
struct SelfRec_IItR
{
                                // shape_hash:    0205b3e92ffdd3ea
                                // non_triv_mask: 1000000010000000
    fu::vec<SelfRec_IItR> x;
    SelfRec_IItR(const SelfRec_IItR&) = default;
    SelfRec_IItR(SelfRec_IItR&&) = default;
    SelfRec_IItR& operator=(SelfRec_IItR&&) = default;
    SelfRec_IItR& operator=(const SelfRec_IItR& selfrec) { return *this = SelfRec_IItR(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return SelfRec_IItR { fu::vec<SelfRec_IItR> {{ SelfRec_IItR{} }} }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct ABRec { x: BARec[]; };
        struct BARec { x: ABRec[]; };
        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct BARec_uamQ;
struct ABRec_LA1K;

                                #ifndef DEF_ABRec_LA1KMTmVgRa
                                #define DEF_ABRec_LA1KMTmVgRa
struct ABRec_LA1K
{
                                // shape_hash:    b9fe8b5dd6bfb7e7
                                // non_triv_mask: 4100008000000000
    fu::vec<BARec_uamQ> x;
    ABRec_LA1K(const ABRec_LA1K&) = default;
    ABRec_LA1K(ABRec_LA1K&&) = default;
    ABRec_LA1K& operator=(ABRec_LA1K&&) = default;
    ABRec_LA1K& operator=(const ABRec_LA1K& selfrec) { return *this = ABRec_LA1K(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_BARec_uamQMivUhke
                                #define DEF_BARec_uamQMivUhke
struct BARec_uamQ
{
                                // shape_hash:    2cc0647a093d0e6a
                                // non_triv_mask: 4100008000000000
    fu::vec<ABRec_LA1K> x;
    BARec_uamQ(const BARec_uamQ&) = default;
    BARec_uamQ(BARec_uamQ&&) = default;
    BARec_uamQ& operator=(BARec_uamQ&&) = default;
    BARec_uamQ& operator=(const BARec_uamQ& selfrec) { return *this = BARec_uamQ(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return ABRec_LA1K { fu::vec<BARec_uamQ> {{ BARec_uamQ{} }} }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen

========

        struct ABRec { x: BARec[]; y: ABBARec[]; };
        struct BARec { x: ABRec[]; y: ABBARec[]; };
        struct ABBARec { x: ABRec[]; y: BARec[]; };
        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct BARec_Ub09;
struct ABRec_Dcv8;
struct ABBARec_rlSP;

                                #ifndef DEF_ABRec_Dcv8y0z59k5
                                #define DEF_ABRec_Dcv8y0z59k5
struct ABRec_Dcv8
{
                                // shape_hash:    ba9721f66ded50e3
                                // non_triv_mask: 0000021000812040
    fu::vec<BARec_Ub09> x;
    fu::vec<ABBARec_rlSP> y;
    ABRec_Dcv8(const ABRec_Dcv8&) = default;
    ABRec_Dcv8(ABRec_Dcv8&&) = default;
    ABRec_Dcv8& operator=(ABRec_Dcv8&&) = default;
    ABRec_Dcv8& operator=(const ABRec_Dcv8& selfrec) { return *this = ABRec_Dcv8(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_BARec_Ub09ojRlQEj
                                #define DEF_BARec_Ub09ojRlQEj
struct BARec_Ub09
{
                                // shape_hash:    a7be5a88cac5af4e
                                // non_triv_mask: 0000021000812040
    fu::vec<ABRec_Dcv8> x;
    fu::vec<ABBARec_rlSP> y;
    BARec_Ub09(const BARec_Ub09&) = default;
    BARec_Ub09(BARec_Ub09&&) = default;
    BARec_Ub09& operator=(BARec_Ub09&&) = default;
    BARec_Ub09& operator=(const BARec_Ub09& selfrec) { return *this = BARec_Ub09(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_ABBARec_rlSPiJ9EXt7
                                #define DEF_ABBARec_rlSPiJ9EXt7
struct ABBARec_rlSP
{
                                // shape_hash:    132b324bb6289275
                                // non_triv_mask: 0000021000812040
    fu::vec<ABRec_Dcv8> x;
    fu::vec<BARec_Ub09> y;
    ABBARec_rlSP(const ABBARec_rlSP&) = default;
    ABBARec_rlSP(ABBARec_rlSP&&) = default;
    ABBARec_rlSP& operator=(ABBARec_rlSP&&) = default;
    ABBARec_rlSP& operator=(const ABBARec_rlSP& selfrec) { return *this = ABBARec_rlSP(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return ABRec_Dcv8 { fu::vec<BARec_Ub09> {{ BARec_Ub09{} }}, {/*unused non-zst*/} }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_TypeReopen, N_UnusedArrlit

========

        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 7, 1, 5, 3, 99, -13 }};
    sort_DsMx(a);
    return ((a[0] + a[1]) + a[3]) + a[4];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::view<int> /*a*/ b = fu::get_view(a, 1, 3);
    return b.size() - b[1];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::view<int> /*a*/ b = fu::get_view(a, 1);
    return b.size() - b[2];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn collectDedupes(mut vals) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

                                #ifndef DEF_collectDedupes_1whv1zIAnv9
                                #define DEF_collectDedupes_1whv1zIAnv9
inline static int collectDedupes_1whv(fu::vec<int>&& vals)
{
    sort_DsMx(vals);
    return vals[0];
}
                                #endif

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> {{ 1, 0 }};
    return collectDedupes_1whv(vals.destructive_move());
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn collectDedupes(mut vals) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

                                #ifndef DEF_collectDedupes_1whv1zIAnv9
                                #define DEF_collectDedupes_1whv1zIAnv9
inline static int collectDedupes_1whv(fu::vec<int>&& vals)
{
    sort_DsMx(vals);
    return vals[0];
}
                                #endif

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> {{ 1, 0 }};
    return collectDedupes_1whv(static_cast<fu::vec<int>&&>(vals));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn collectDedupes(mut vals: i32[]) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

static int collectDedupes_MbR9(fu::vec<int>&& vals)
{
    sort_DsMx(vals);
    return vals[0];
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> {{ 1, 0 }};
    return collectDedupes_MbR9(vals.destructive_move());
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn collectDedupes(mut vals: i32[]) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

static int collectDedupes_MbR9(fu::vec<int>&& vals)
{
    sort_DsMx(vals);
    return vals[0];
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> {{ 1, 0 }};
    return collectDedupes_MbR9(static_cast<fu::vec<int>&&>(vals));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn sort01(ref arr: $T[..]) {
            mut tmp: $T;
            if (arr[0] > arr[1]) {
                swap(arr[0], tmp);
                swap(arr[1], tmp);
            }
        }

        fn collectDedupes(mut vals) {
            vals.sort01();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <utility>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sort01_8glNRV39alc
                                #define DEF_sort01_8glNRV39alc
inline static void sort01_8glN(/*1:1*/ fu::view_mut<int> arr)
{
    int tmp {};
    if (arr[0] > arr[1])
    {
        std::swap(arr.mutref(0), tmp);
        std::swap(arr.mutref(1), tmp);
    };
}
                                #endif

                                #ifndef DEF_collectDedupes_tRiMUIi9Vee
                                #define DEF_collectDedupes_tRiMUIi9Vee
inline static int collectDedupes_tRiM(fu::vec<int>&& vals)
{
    sort01_8glN(vals);
    return vals[0];
}
                                #endif

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> {{ 1, 0 }};
    return collectDedupes_tRiM(vals.destructive_move());
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        mut str = "hello ";
        str ~= "world";

        return str.len - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str str = fu::str("hello "_fu);
    str += "world"_view;
    return str.size() - 11;
}

#endif

int main() { return fu_MAIN(); }

========

        let str = "hello " ~ "world";

        return str.starts(with: "hel")
             ? str  .ends(with: "rld")
             ? str.len - 11
             : 171
             : 173;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_ends_OW45P9GlDid
                                #define DEF_ends_OW45P9GlDid
inline bool ends_OW45(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

int fu_MAIN()
{
    fu::str str = ("hello "_view + "world"_view);
    if (starts_ojop(str, "hel"_view))
    {
        if (ends_OW45(str, "rld"_view))
            return str.size() - 11;
        else
            return 171;

    }
    else
        return 173;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let str = "a" ~ 1710010;

        return str == "a1710010"
             ? 0 : 101;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str = x7E_rA00("a"_view, fu::i64dec(1710010));
    if (str == "a1710010"_view)
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

========

        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ str = "hello world"_view;
    fu::str cpy = fu::str(""_fu);
    for (int i = 0; i < str.size(); i++)
        cpy += str[i];

    return (cpy.size() - 11) + ((cpy == str) ? 0 : 1);
}

#endif

int main() { return fu_MAIN(); }

========

        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ str = "hello world"_view;
    fu::str cpy {};
    for (int i = 0; i < str.size(); i++)
        cpy += str[i];

    return (cpy.size() - 11) + ((cpy == str) ? 0 : 1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn xorshift(mut x: u8)  { x ^= x <<  5; x ^= x >>  3; x ^= x <<  7 }
        fn xorshift(mut x: u16) { x ^= x <<  3; x ^= x >>  5; x ^= x << 11 }
        fn xorshift(mut x: u32) { x ^= x << 13; x ^= x >> 17; x ^= x <<  5 }
        fn xorshift(mut x: u64) { x ^= x << 13; x ^= x >>  7; x ^= x << 17 }

        fn main() {                                             // DuplicateFunctions
            mut rnd_state = 1.u32;
            fn rnd() {
                rnd_state = xorshift(rnd_state);
                return rnd_state + 0;
            }

            fn check(a: string, b: string, expect: int, next = -1)
            {
                let a0 = a.find(b);
                assert(a0 == expect);

                if (expect >= 0) {
                    let a1 = a.find(b, start: expect + b.len);
                    assert(a1 == next);
                }

                if (!b) return;

                if (b.len < 256) {
                    mut aa = "";
                    mut bb = "";
                    for (mut i = 0; i < a.len; i++) aa ~= [ a[i], a[i] ];
                    for (mut i = 0; i < b.len; i++) bb ~= [ b[i], b[i] ];

                    check(aa, bb, expect < 0 ? -1 : expect * 2,
                                    next < 0 ? -1 :   next * 2);
                }

                if (!b.has('x')) {
                    let bi = b.len && (rnd % b.len.u32).int;
                    check(a, b[.. bi] ~ 'x' ~ b[bi ..], -1, -1);

                    if (b.len >= 2 && expect >= 0 && next < 0) {
                        let bmid = b.len - 2;
                        let ai = expect + 1 + (bmid && rnd % bmid.u32).int;
                        check(a[.. ai] ~ 'c' ~ a[ai ..], b, -1, -1);
                    }

                    fn check(type as!<T>) {
                        shadow let rnd = rnd;
                        fn randomize(v: byte) xorshift(v.T + rnd.T);
                        shadow let a = a.map(.randomize);
                        shadow let b = b.map(.randomize);

                        shadow let a0 = a.find(b);
                        assert(a0 == expect);

                        if (expect >= 0) {
                            shadow let a1 = a.find(b, start: expect + b.len);
                            assert(a1 == next);
                        }
                    }

                    check(as: u8); check(as: u16); check(as: u32); check(as: u64);

                    if (expect >= 0 && !(b.len & 1) && !(a.has('n')))
                    {
                        check(a ~ 'n', b, expect, next);
                        check('n' ~ a, b, expect + 1, next < 0 ? next : next + 1);

                        if (!b.has('n') && a.len)
                        {
                            let replace = b[int(rnd % b.len.u32)];
                            shadow let a = a.replace(all: replace, with: 'n');
                            shadow let b = b.replace(all: replace, with: 'n');

                            {
                                shadow let expect = expect < 0 ? expect : expect - 1;
                                shadow let next   = next   < 0 ? next   : next   - 1;

                                if (expect >= 0 || next < 0)
                                    check(a[1 ..], b, expect, next);
                            }

                            check(a[.. a.len - 1], b, expect < a.len - b.len ? expect : -1
                                                    , next   < a.len - b.len ? next   : -1);
                        }
                    }
                }
            }

            check("hello world", "", 0, 0);
            check("hello world", "h", 0);
            check("hello world", " ", 5);
            check("hello world", "d", 10);
            check("hello world", "hello", 0);
            check("hello world", "helllo", -1);
            check("hello world", "ello ", 1);
            check("hello world", "lllo ", -1);
            check("hello world", "lllo ", -1);
            check("hello world", "wrld", -1);
            check("hello world", "world ", -1);
            check("hello world", "worldd", -1);
            check("hello world", "hh", -1);
            check("hello world", "dd", -1);
            check("hello world", "ll", 2);
            check("hello world", " w", 5);
            check("hello world", "o ", 4);
            check("hello world", "world", 6);
            check("hello world", "hello world", 0);
            check("hello world", "eello world", -1);
            check("hello world", " hello world", -1);
            check("hello world", "hello world ", -1);
            check("hellohellohello", "hello", 0, 5);
            check("hellhellohello", "hello", 4, 9);
            check("hellhellhello", "hello", 8);
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(152650928) arc_count(130709) ] ----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/assert.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

static void check_MbR9(fu::vec_range<char>, fu::vec_range<char>, int, int, unsigned&);

                                #ifndef STR_83mA2Eo17Zf
                                #define STR_83mA2Eo17Zf
static const fu::str str_83mA2Eo17Zf fu_INIT_PRIORITY(1001) { "hello world"_fu };
                                #endif

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

                                #ifndef STR_gWBQGF7fAGj
                                #define STR_gWBQGF7fAGj
static const fu::str str_gWBQGF7fAGj fu_INIT_PRIORITY(1001) { "h"_fu };
                                #endif

                                #ifndef STR_Cebu50MstTd
                                #define STR_Cebu50MstTd
static const fu::str str_Cebu50MstTd fu_INIT_PRIORITY(1001) { " "_fu };
                                #endif

                                #ifndef STR_yXdmW9I62jj
                                #define STR_yXdmW9I62jj
static const fu::str str_yXdmW9I62jj fu_INIT_PRIORITY(1001) { "d"_fu };
                                #endif

                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

                                #ifndef STR_yElO8d6IRa5
                                #define STR_yElO8d6IRa5
static const fu::str str_yElO8d6IRa5 fu_INIT_PRIORITY(1001) { "helllo"_fu };
                                #endif

                                #ifndef STR_8ErWFytUuS3
                                #define STR_8ErWFytUuS3
static const fu::str str_8ErWFytUuS3 fu_INIT_PRIORITY(1001) { "ello "_fu };
                                #endif

                                #ifndef STR_RqGpT9eVZYa
                                #define STR_RqGpT9eVZYa
static const fu::str str_RqGpT9eVZYa fu_INIT_PRIORITY(1001) { "lllo "_fu };
                                #endif

                                #ifndef STR_LW2kMQ5B3zk
                                #define STR_LW2kMQ5B3zk
static const fu::str str_LW2kMQ5B3zk fu_INIT_PRIORITY(1001) { "wrld"_fu };
                                #endif

                                #ifndef STR_sytNjoQDjnb
                                #define STR_sytNjoQDjnb
static const fu::str str_sytNjoQDjnb fu_INIT_PRIORITY(1001) { "world "_fu };
                                #endif

                                #ifndef STR_oCXfB89qlT4
                                #define STR_oCXfB89qlT4
static const fu::str str_oCXfB89qlT4 fu_INIT_PRIORITY(1001) { "worldd"_fu };
                                #endif

                                #ifndef STR_SwsZerknvx3
                                #define STR_SwsZerknvx3
static const fu::str str_SwsZerknvx3 fu_INIT_PRIORITY(1001) { "hh"_fu };
                                #endif

                                #ifndef STR_wkkM60XKj5j
                                #define STR_wkkM60XKj5j
static const fu::str str_wkkM60XKj5j fu_INIT_PRIORITY(1001) { "dd"_fu };
                                #endif

                                #ifndef STR_MjsKQ7HraF9
                                #define STR_MjsKQ7HraF9
static const fu::str str_MjsKQ7HraF9 fu_INIT_PRIORITY(1001) { "ll"_fu };
                                #endif

                                #ifndef STR_tbhpNFtSnI0
                                #define STR_tbhpNFtSnI0
static const fu::str str_tbhpNFtSnI0 fu_INIT_PRIORITY(1001) { " w"_fu };
                                #endif

                                #ifndef STR_ytL5Dq7RG8j
                                #define STR_ytL5Dq7RG8j
static const fu::str str_ytL5Dq7RG8j fu_INIT_PRIORITY(1001) { "o "_fu };
                                #endif

                                #ifndef STR_9VaFzJwl1w6
                                #define STR_9VaFzJwl1w6
static const fu::str str_9VaFzJwl1w6 fu_INIT_PRIORITY(1001) { "world"_fu };
                                #endif

                                #ifndef STR_KEX9B4sOGX3
                                #define STR_KEX9B4sOGX3
static const fu::str str_KEX9B4sOGX3 fu_INIT_PRIORITY(1001) { "eello world"_fu };
                                #endif

                                #ifndef STR_pw860sfqCJc
                                #define STR_pw860sfqCJc
static const fu::str str_pw860sfqCJc fu_INIT_PRIORITY(1001) { " hello world"_fu };
                                #endif

                                #ifndef STR_wJtIo2Ln5qg
                                #define STR_wJtIo2Ln5qg
static const fu::str str_wJtIo2Ln5qg fu_INIT_PRIORITY(1001) { "hello world "_fu };
                                #endif

                                #ifndef STR_h7GzxRvwDX5
                                #define STR_h7GzxRvwDX5
static const fu::str str_h7GzxRvwDX5 fu_INIT_PRIORITY(1001) { "hellohellohello"_fu };
                                #endif

                                #ifndef STR_e7bxHeyMVOe
                                #define STR_e7bxHeyMVOe
static const fu::str str_e7bxHeyMVOe fu_INIT_PRIORITY(1001) { "hellhellohello"_fu };
                                #endif

                                #ifndef STR_0inx36NHGV3
                                #define STR_0inx36NHGV3
static const fu::str str_0inx36NHGV3 fu_INIT_PRIORITY(1001) { "hellhellhello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_has_Mnu2KTFEuhg
                                #define DEF_has_Mnu2KTFEuhg
inline bool has_Mnu2(/*3:3*/ fu::view<char> a, const char b)
{
    return (find_ZKsG(a, b) >= 0);
}
                                #endif

static unsigned xorshift_GL0m(unsigned x)
{
    x ^= (x << 13u);
    x ^= (x >> 17u);
    return (x ^= (x << 5u));
}

static unsigned rnd_MbR9(/*1:1*/ unsigned& rnd_state)
{
    rnd_state = xorshift_GL0m(rnd_state);
    return rnd_state + 0u;
}

static fu::u8 xorshift_MbR9(fu::u8 x)
{
    x ^= fu::u8((x << fu::u8(5u)));
    x ^= fu::u8((x >> fu::u8(3u)));
    return (x ^= fu::u8((x << fu::u8(7u))));
}

                                #ifndef DEF_randomize_SSjCncN4ID4
                                #define DEF_randomize_SSjCncN4ID4
inline static fu::u8 randomize_SSjC(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_MbR9(fu::u8((fu::u8(fu::u8(v)) + fu::u8(rnd))));
}
                                #endif

                                #ifndef DEF___9h0uv3Xo3a8
                                #define DEF___9h0uv3Xo3a8
inline static fu::u8 _9h0u(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_SSjC(_, rnd);
}
                                #endif

                                #ifndef DEF_map_VO78KjbqzNc
                                #define DEF_map_VO78KjbqzNc
inline fu::vec<fu::u8> map_VO78(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<fu::u8> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _9h0u(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_EI16C93KOvh
                                #define DEF_find_EI16C93KOvh
inline int find_EI16(/*F:F*/ fu::view<fu::u8> haystack, const fu::u8 needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_1wPVwxovZw4
                                #define DEF_find_1wPVwxovZw4
inline int find_1wPV(/*F:F*/ fu::view<fu::u8> haystack, /*F:F*/ fu::view<fu::u8> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_EI16(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const fu::u8 /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_PwKwurq8LKa
                                #define DEF_find_PwKwurq8LKa
inline int find_PwKw(/*F:F*/ fu::view<fu::u8> haystack, /*F:F*/ fu::view<fu::u8> needle, const int start)
{
    fu::view<fu::u8> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_1wPV(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_We9aJqmBZIk
                                #define DEF_check_We9aJqmBZIk
inline static void check_We9a(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<fu::u8> a_1 = map_VO78(a, rnd);
    fu::vec<fu::u8> b_1 = map_VO78(b, rnd);
    const int a0 = find_1wPV(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_PwKw(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

static uint16_t xorshift_kGbb(uint16_t x)
{
    x ^= uint16_t((x << uint16_t(3u)));
    x ^= uint16_t((x >> uint16_t(5u)));
    return (x ^= uint16_t((x << uint16_t(11u))));
}

                                #ifndef DEF_randomize_YsBauywabYe
                                #define DEF_randomize_YsBauywabYe
inline static uint16_t randomize_YsBa(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_kGbb(uint16_t((uint16_t(fu::u8(v)) + uint16_t(rnd))));
}
                                #endif

                                #ifndef DEF___qDdMbfpLiRh
                                #define DEF___qDdMbfpLiRh
inline static uint16_t _qDdM(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_YsBa(_, rnd);
}
                                #endif

                                #ifndef DEF_map_t1oHuRTV8S8
                                #define DEF_map_t1oHuRTV8S8
inline fu::vec<uint16_t> map_t1oH(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<uint16_t> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _qDdM(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_Sr0smREgDNd
                                #define DEF_find_Sr0smREgDNd
inline int find_Sr0s(/*F:F*/ fu::view<uint16_t> haystack, const uint16_t needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_GDD81PNIbNk
                                #define DEF_find_GDD81PNIbNk
inline int find_GDD8(/*F:F*/ fu::view<uint16_t> haystack, /*F:F*/ fu::view<uint16_t> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_Sr0s(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const uint16_t /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_rwxvdhhnPIf
                                #define DEF_find_rwxvdhhnPIf
inline int find_rwxv(/*F:F*/ fu::view<uint16_t> haystack, /*F:F*/ fu::view<uint16_t> needle, const int start)
{
    fu::view<uint16_t> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_GDD8(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_bCSYcgJD8sa
                                #define DEF_check_bCSYcgJD8sa
inline static void check_bCSY(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<uint16_t> a_1 = map_t1oH(a, rnd);
    fu::vec<uint16_t> b_1 = map_t1oH(b, rnd);
    const int a0 = find_GDD8(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_rwxv(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

                                #ifndef DEF_randomize_xZR4VuYp827
                                #define DEF_randomize_xZR4VuYp827
inline static unsigned randomize_xZR4(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_GL0m((unsigned(fu::u8(v)) + unsigned(rnd)));
}
                                #endif

                                #ifndef DEF___XdUUPJyn85d
                                #define DEF___XdUUPJyn85d
inline static unsigned _XdUU(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_xZR4(_, rnd);
}
                                #endif

                                #ifndef DEF_map_7b35IOFGx16
                                #define DEF_map_7b35IOFGx16
inline fu::vec<unsigned> map_7b35(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<unsigned> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _XdUU(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_KQybDbV0L3l
                                #define DEF_find_KQybDbV0L3l
inline int find_KQyb(/*F:F*/ fu::view<unsigned> haystack, const unsigned needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_EDD5lTAoNll
                                #define DEF_find_EDD5lTAoNll
inline int find_EDD5(/*F:F*/ fu::view<unsigned> haystack, /*F:F*/ fu::view<unsigned> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_KQyb(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const unsigned /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_VHCH23wNfhe
                                #define DEF_find_VHCH23wNfhe
inline int find_VHCH(/*F:F*/ fu::view<unsigned> haystack, /*F:F*/ fu::view<unsigned> needle, const int start)
{
    fu::view<unsigned> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_EDD5(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_HEmkFgngAWh
                                #define DEF_check_HEmkFgngAWh
inline static void check_HEmk(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<unsigned> a_1 = map_7b35(a, rnd);
    fu::vec<unsigned> b_1 = map_7b35(b, rnd);
    const int a0 = find_EDD5(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_VHCH(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

static uint64_t xorshift_haRm(uint64_t x)
{
    x ^= (x << 13ull);
    x ^= (x >> 7ull);
    return (x ^= (x << 17ull));
}

                                #ifndef DEF_randomize_TZWXZT6aVh6
                                #define DEF_randomize_TZWXZT6aVh6
inline static uint64_t randomize_TZWX(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_haRm((uint64_t(fu::u8(v)) + uint64_t(rnd)));
}
                                #endif

                                #ifndef DEF___oNhbiqB3hh0
                                #define DEF___oNhbiqB3hh0
inline static uint64_t _oNhb(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_TZWX(_, rnd);
}
                                #endif

                                #ifndef DEF_map_u6kI1wcMaFb
                                #define DEF_map_u6kI1wcMaFb
inline fu::vec<uint64_t> map_u6kI(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<uint64_t> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _oNhb(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_Uv2e1viqfzl
                                #define DEF_find_Uv2e1viqfzl
inline int find_Uv2e(/*F:F*/ fu::view<uint64_t> haystack, const uint64_t needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_AdjULDRCER4
                                #define DEF_find_AdjULDRCER4
inline int find_AdjU(/*F:F*/ fu::view<uint64_t> haystack, /*F:F*/ fu::view<uint64_t> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_Uv2e(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const uint64_t /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_npx4fG8O7m2
                                #define DEF_find_npx4fG8O7m2
inline int find_npx4(/*F:F*/ fu::view<uint64_t> haystack, /*F:F*/ fu::view<uint64_t> needle, const int start)
{
    fu::view<uint64_t> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_AdjU(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_xOpZhSPoT4e
                                #define DEF_check_xOpZhSPoT4e
inline static void check_xOpZ(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<uint64_t> a_1 = map_u6kI(a, rnd);
    fu::vec<uint64_t> b_1 = map_u6kI(b, rnd);
    const int a0 = find_AdjU(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_npx4(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_EC32FyABXS6
                                #define DEF_replace_EC32FyABXS6
inline fu::str replace_EC32(/*7:7*/ fu::vec_range<char> str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        if (N)
        {
            while (((next = find_rkz0(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!first)
                        result += with;
                    else if (last_1)
                        return fu::str(str);

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

static void check_MbR9(/*F1:F1*/ fu::vec_range<char> a, /*F1:F1*/ fu::vec_range<char> b, const int expect, const int next, /*01:01*/ unsigned& rnd_state)
{
    const int a0 = find_7SLc(a, b);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_BNNw(a, b, (expect + b.size()));
        fu_ASSERT((a1 == next));
    };
    if (!(!b))
    {
        if (b.size() < 256)
        {
            fu::str aa = fu::str(""_fu);
            fu::str bb = fu::str(""_fu);
            for (int i = 0; i < a.size(); i++)
            {
                aa += fu::view<char> {{ a[i], a[i] }};
            };
            for (int i_1 = 0; i_1 < b.size(); i_1++)
            {
                bb += fu::view<char> {{ b[i_1], b[i_1] }};
            };
            check_MbR9(aa, bb, ((expect < 0) ? -1 : (expect * 2)), ((next < 0) ? -1 : (next * 2)), rnd_state);
        };
        if (!has_Mnu2(b, 'x'))
        {
            const int bi = (b.size() ? int((rnd_MbR9(rnd_state) % unsigned(b.size()))) : 0);
            check_MbR9(a, ((fu::get_view_start0(b, bi) + 'x') + fu::get_view(b, bi)), -1, -1, rnd_state);
            if ((b.size() >= 2) && (expect >= 0) && (next < 0))
            {
                const int bmid = (b.size() - 2);
                const int ai = ((expect + 1) + int((bmid ? (rnd_MbR9(rnd_state) % unsigned(bmid)) : 0u)));
                check_MbR9(((fu::get_view_start0(a, ai) + 'c') + fu::get_view(a, ai)), b, -1, -1, rnd_state);
            };
            check_We9a(a, b, expect, next, rnd_state);
            check_bCSY(a, b, expect, next, rnd_state);
            check_HEmk(a, b, expect, next, rnd_state);
            check_xOpZ(a, b, expect, next, rnd_state);
            if ((expect >= 0) && !(b.size() & 1) && !has_Mnu2(a, 'n'))
            {
                check_MbR9((a + 'n'), b, expect, next, rnd_state);
                check_MbR9(('n' + a), b, (expect + 1), ((next < 0) ? next : (next + 1)), rnd_state);
                if (!has_Mnu2(b, 'n') && a.size())
                {
                    const char /*b|static*/ replace = b[int((rnd_MbR9(rnd_state) % unsigned(b.size())))];
                    fu::str a_1 = replace_EC32(a, replace, 'n');
                    fu::str b_1 = replace_EC32(b, replace, 'n');

                    {
                        const int expect_1 = ((expect < 0) ? expect : (expect - 1));
                        const int next_1 = ((next < 0) ? next : (next - 1));
                        if ((expect_1 >= 0) || (next_1 < 0))
                            check_MbR9(fu::get_range(a_1, 1), b_1, expect_1, next_1, rnd_state);

                    };
                    check_MbR9(fu::get_range_start0(a_1, (a_1.size() - 1)), b_1, ((expect < (a_1.size() - b_1.size())) ? expect : -1), ((next < (a_1.size() - b_1.size())) ? next : -1), rnd_state);
                };
            };
        };
    };
}

int fu_MAIN()
{
    unsigned rnd_state = unsigned(1);
    check_MbR9(str_83mA2Eo17Zf, str_00000000000, 0, 0, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_gWBQGF7fAGj, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_Cebu50MstTd, 5, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_yXdmW9I62jj, 10, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_LCCnJta4Qr3, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_yElO8d6IRa5, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_8ErWFytUuS3, 1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_RqGpT9eVZYa, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_RqGpT9eVZYa, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_LW2kMQ5B3zk, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_sytNjoQDjnb, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_oCXfB89qlT4, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_SwsZerknvx3, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_wkkM60XKj5j, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_MjsKQ7HraF9, 2, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_tbhpNFtSnI0, 5, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_ytL5Dq7RG8j, 4, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_9VaFzJwl1w6, 6, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_83mA2Eo17Zf, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_KEX9B4sOGX3, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_pw860sfqCJc, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_wJtIo2Ln5qg, -1, -1, rnd_state);
    check_MbR9(str_h7GzxRvwDX5, str_LCCnJta4Qr3, 0, 5, rnd_state);
    check_MbR9(str_e7bxHeyMVOe, str_LCCnJta4Qr3, 4, 9, rnd_state);
    check_MbR9(str_0inx36NHGV3, str_LCCnJta4Qr3, 8, -1, rnd_state);
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedLet

========

        fn xorshift(mut x: u8)  { x ^= x <<  5; x ^= x >>  3; x ^= x <<  7 }
        fn xorshift(mut x: u16) { x ^= x <<  3; x ^= x >>  5; x ^= x << 11 }
        fn xorshift(mut x: u32) { x ^= x << 13; x ^= x >> 17; x ^= x <<  5 }
        fn xorshift(mut x: u64) { x ^= x << 13; x ^= x >>  7; x ^= x << 17 }

        fn main() {                                             // DuplicateFunctions
            mut rnd_state = 1.u32;
            fn rnd() {
                rnd_state = xorshift(rnd_state);
                return rnd_state + 0;
            }

            fn check(a: string, b: string, expect: int, next = -1)
            {
                let a0 = a.find(b);
                assert(a0 == expect);

                if (expect >= 0) {
                    let a1 = a.find(b, start: expect + b.len);
                    assert(a1 == next);
                }

                if (!b) return;

                if (b.len < 256) {
                    mut aa = "";
                    mut bb = "";
                    for (mut i = 0; i < a.len; i++) aa ~= [ a[i], a[i] ];
                    for (mut i = 0; i < b.len; i++) bb ~= [ b[i], b[i] ];

                    check(aa, bb, expect < 0 ? -1 : expect * 2,
                                    next < 0 ? -1 :   next * 2);
                }

                if (!b.has('x')) {
                    let bi = b.len && (rnd % b.len.u32).int;
                    check(a, b[.. bi] ~ 'x' ~ b[bi ..], -1, -1);

                    if (b.len >= 2 && expect >= 0 && next < 0) {
                        let bmid = b.len - 2;
                        let ai = expect + 1 + (bmid && rnd % bmid.u32).int;
                        check(a[.. ai] ~ 'c' ~ a[ai ..], b, -1, -1);
                    }

                    fn check(type as!<T>) {
                        shadow let rnd = rnd;
                        fn randomize(v: byte) xorshift(v.T + rnd.T);
                        shadow let a = a.map(.randomize);
                        shadow let b = b.map(.randomize);

                        shadow let a0 = a.find(b);
                        assert(a0 == expect);

                        if (expect >= 0) {
                            shadow let a1 = a.find(b, start: expect + b.len);
                            assert(a1 == next);
                        }
                    }

                    check(as: u8); check(as: u16); check(as: u32); check(as: u64);

                    if (expect >= 0 && !(b.len & 1) && !(a.has('n')))
                    {
                        check(a ~ 'n', b, expect, next);
                        check('n' ~ a, b, expect + 1, next < 0 ? next : next + 1);

                        if (!b.has('n') && a.len)
                        {
                            let replace = b[int(rnd % b.len.u32)];
                            shadow let a = a.replace(all: replace, with: 'n');
                            shadow let b = b.replace(all: replace, with: 'n');

                            {
                                shadow let expect = expect < 0 ? expect : expect - 1;
                                shadow let next   = next   < 0 ? next   : next   - 1;

                                if (expect >= 0 || next < 0)
                                    check(a[1 ..], b, expect, next);
                            }

                            check(a[.. a.len - 1], b, expect < a.len - b.len ? expect : -1
                                                    , next   < a.len - b.len ? next   : -1);
                        }
                    }
                }
            }

            check("hello world", "", 0, 0);
            check("hello world", "h", 0);
            check("hello world", " ", 5);
            check("hello world", "d", 10);
            check("hello world", "hello", 0);
            check("hello world", "helllo", -1);
            check("hello world", "ello ", 1);
            check("hello world", "lllo ", -1);
            check("hello world", "lllo ", -1);
            check("hello world", "wrld", -1);
            check("hello world", "world ", -1);
            check("hello world", "worldd", -1);
            check("hello world", "hh", -1);
            check("hello world", "dd", -1);
            check("hello world", "ll", 2);
            check("hello world", " w", 5);
            check("hello world", "o ", 4);
            check("hello world", "world", 6);
            check("hello world", "hello world", 0);
            check("hello world", "eello world", -1);
            check("hello world", " hello world", -1);
            check("hello world", "hello world ", -1);
            check("hellohellohello", "hello", 0, 5);
            check("hellhellohello", "hello", 4, 9);
            check("hellhellhello", "hello", 8);
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(152650928) arc_count(130709) ] ----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/assert.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

static void check_MbR9(fu::vec_range<char>, fu::vec_range<char>, int, int, unsigned&);

                                #ifndef STR_83mA2Eo17Zf
                                #define STR_83mA2Eo17Zf
static const fu::str str_83mA2Eo17Zf fu_INIT_PRIORITY(1001) { "hello world"_fu };
                                #endif

                                #ifndef STR_gWBQGF7fAGj
                                #define STR_gWBQGF7fAGj
static const fu::str str_gWBQGF7fAGj fu_INIT_PRIORITY(1001) { "h"_fu };
                                #endif

                                #ifndef STR_Cebu50MstTd
                                #define STR_Cebu50MstTd
static const fu::str str_Cebu50MstTd fu_INIT_PRIORITY(1001) { " "_fu };
                                #endif

                                #ifndef STR_yXdmW9I62jj
                                #define STR_yXdmW9I62jj
static const fu::str str_yXdmW9I62jj fu_INIT_PRIORITY(1001) { "d"_fu };
                                #endif

                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

                                #ifndef STR_yElO8d6IRa5
                                #define STR_yElO8d6IRa5
static const fu::str str_yElO8d6IRa5 fu_INIT_PRIORITY(1001) { "helllo"_fu };
                                #endif

                                #ifndef STR_8ErWFytUuS3
                                #define STR_8ErWFytUuS3
static const fu::str str_8ErWFytUuS3 fu_INIT_PRIORITY(1001) { "ello "_fu };
                                #endif

                                #ifndef STR_RqGpT9eVZYa
                                #define STR_RqGpT9eVZYa
static const fu::str str_RqGpT9eVZYa fu_INIT_PRIORITY(1001) { "lllo "_fu };
                                #endif

                                #ifndef STR_LW2kMQ5B3zk
                                #define STR_LW2kMQ5B3zk
static const fu::str str_LW2kMQ5B3zk fu_INIT_PRIORITY(1001) { "wrld"_fu };
                                #endif

                                #ifndef STR_sytNjoQDjnb
                                #define STR_sytNjoQDjnb
static const fu::str str_sytNjoQDjnb fu_INIT_PRIORITY(1001) { "world "_fu };
                                #endif

                                #ifndef STR_oCXfB89qlT4
                                #define STR_oCXfB89qlT4
static const fu::str str_oCXfB89qlT4 fu_INIT_PRIORITY(1001) { "worldd"_fu };
                                #endif

                                #ifndef STR_SwsZerknvx3
                                #define STR_SwsZerknvx3
static const fu::str str_SwsZerknvx3 fu_INIT_PRIORITY(1001) { "hh"_fu };
                                #endif

                                #ifndef STR_wkkM60XKj5j
                                #define STR_wkkM60XKj5j
static const fu::str str_wkkM60XKj5j fu_INIT_PRIORITY(1001) { "dd"_fu };
                                #endif

                                #ifndef STR_MjsKQ7HraF9
                                #define STR_MjsKQ7HraF9
static const fu::str str_MjsKQ7HraF9 fu_INIT_PRIORITY(1001) { "ll"_fu };
                                #endif

                                #ifndef STR_tbhpNFtSnI0
                                #define STR_tbhpNFtSnI0
static const fu::str str_tbhpNFtSnI0 fu_INIT_PRIORITY(1001) { " w"_fu };
                                #endif

                                #ifndef STR_ytL5Dq7RG8j
                                #define STR_ytL5Dq7RG8j
static const fu::str str_ytL5Dq7RG8j fu_INIT_PRIORITY(1001) { "o "_fu };
                                #endif

                                #ifndef STR_9VaFzJwl1w6
                                #define STR_9VaFzJwl1w6
static const fu::str str_9VaFzJwl1w6 fu_INIT_PRIORITY(1001) { "world"_fu };
                                #endif

                                #ifndef STR_KEX9B4sOGX3
                                #define STR_KEX9B4sOGX3
static const fu::str str_KEX9B4sOGX3 fu_INIT_PRIORITY(1001) { "eello world"_fu };
                                #endif

                                #ifndef STR_pw860sfqCJc
                                #define STR_pw860sfqCJc
static const fu::str str_pw860sfqCJc fu_INIT_PRIORITY(1001) { " hello world"_fu };
                                #endif

                                #ifndef STR_wJtIo2Ln5qg
                                #define STR_wJtIo2Ln5qg
static const fu::str str_wJtIo2Ln5qg fu_INIT_PRIORITY(1001) { "hello world "_fu };
                                #endif

                                #ifndef STR_h7GzxRvwDX5
                                #define STR_h7GzxRvwDX5
static const fu::str str_h7GzxRvwDX5 fu_INIT_PRIORITY(1001) { "hellohellohello"_fu };
                                #endif

                                #ifndef STR_e7bxHeyMVOe
                                #define STR_e7bxHeyMVOe
static const fu::str str_e7bxHeyMVOe fu_INIT_PRIORITY(1001) { "hellhellohello"_fu };
                                #endif

                                #ifndef STR_0inx36NHGV3
                                #define STR_0inx36NHGV3
static const fu::str str_0inx36NHGV3 fu_INIT_PRIORITY(1001) { "hellhellhello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_has_Mnu2KTFEuhg
                                #define DEF_has_Mnu2KTFEuhg
inline bool has_Mnu2(/*3:3*/ fu::view<char> a, const char b)
{
    return (find_ZKsG(a, b) >= 0);
}
                                #endif

static unsigned xorshift_GL0m(unsigned x)
{
    x ^= (x << 13u);
    x ^= (x >> 17u);
    return (x ^= (x << 5u));
}

static unsigned rnd_MbR9(/*1:1*/ unsigned& rnd_state)
{
    rnd_state = xorshift_GL0m(rnd_state);
    return rnd_state + 0u;
}

static fu::u8 xorshift_MbR9(fu::u8 x)
{
    x ^= fu::u8((x << fu::u8(5u)));
    x ^= fu::u8((x >> fu::u8(3u)));
    return (x ^= fu::u8((x << fu::u8(7u))));
}

                                #ifndef DEF_randomize_SSjCncN4ID4
                                #define DEF_randomize_SSjCncN4ID4
inline static fu::u8 randomize_SSjC(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_MbR9(fu::u8((fu::u8(fu::u8(v)) + fu::u8(rnd))));
}
                                #endif

                                #ifndef DEF___9h0uv3Xo3a8
                                #define DEF___9h0uv3Xo3a8
inline static fu::u8 _9h0u(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_SSjC(_, rnd);
}
                                #endif

                                #ifndef DEF_map_VO78KjbqzNc
                                #define DEF_map_VO78KjbqzNc
inline fu::vec<fu::u8> map_VO78(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<fu::u8> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _9h0u(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_EI16C93KOvh
                                #define DEF_find_EI16C93KOvh
inline int find_EI16(/*F:F*/ fu::view<fu::u8> haystack, const fu::u8 needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_1wPVwxovZw4
                                #define DEF_find_1wPVwxovZw4
inline int find_1wPV(/*F:F*/ fu::view<fu::u8> haystack, /*F:F*/ fu::view<fu::u8> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_EI16(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const fu::u8 /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_PwKwurq8LKa
                                #define DEF_find_PwKwurq8LKa
inline int find_PwKw(/*F:F*/ fu::view<fu::u8> haystack, /*F:F*/ fu::view<fu::u8> needle, const int start)
{
    fu::view<fu::u8> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_1wPV(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_We9aJqmBZIk
                                #define DEF_check_We9aJqmBZIk
inline static void check_We9a(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<fu::u8> a_1 = map_VO78(a, rnd);
    fu::vec<fu::u8> b_1 = map_VO78(b, rnd);
    const int a0 = find_1wPV(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_PwKw(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

static uint16_t xorshift_kGbb(uint16_t x)
{
    x ^= uint16_t((x << uint16_t(3u)));
    x ^= uint16_t((x >> uint16_t(5u)));
    return (x ^= uint16_t((x << uint16_t(11u))));
}

                                #ifndef DEF_randomize_YsBauywabYe
                                #define DEF_randomize_YsBauywabYe
inline static uint16_t randomize_YsBa(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_kGbb(uint16_t((uint16_t(fu::u8(v)) + uint16_t(rnd))));
}
                                #endif

                                #ifndef DEF___qDdMbfpLiRh
                                #define DEF___qDdMbfpLiRh
inline static uint16_t _qDdM(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_YsBa(_, rnd);
}
                                #endif

                                #ifndef DEF_map_t1oHuRTV8S8
                                #define DEF_map_t1oHuRTV8S8
inline fu::vec<uint16_t> map_t1oH(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<uint16_t> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _qDdM(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_Sr0smREgDNd
                                #define DEF_find_Sr0smREgDNd
inline int find_Sr0s(/*F:F*/ fu::view<uint16_t> haystack, const uint16_t needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_GDD81PNIbNk
                                #define DEF_find_GDD81PNIbNk
inline int find_GDD8(/*F:F*/ fu::view<uint16_t> haystack, /*F:F*/ fu::view<uint16_t> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_Sr0s(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const uint16_t /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_rwxvdhhnPIf
                                #define DEF_find_rwxvdhhnPIf
inline int find_rwxv(/*F:F*/ fu::view<uint16_t> haystack, /*F:F*/ fu::view<uint16_t> needle, const int start)
{
    fu::view<uint16_t> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_GDD8(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_bCSYcgJD8sa
                                #define DEF_check_bCSYcgJD8sa
inline static void check_bCSY(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<uint16_t> a_1 = map_t1oH(a, rnd);
    fu::vec<uint16_t> b_1 = map_t1oH(b, rnd);
    const int a0 = find_GDD8(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_rwxv(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

                                #ifndef DEF_randomize_xZR4VuYp827
                                #define DEF_randomize_xZR4VuYp827
inline static unsigned randomize_xZR4(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_GL0m((unsigned(fu::u8(v)) + unsigned(rnd)));
}
                                #endif

                                #ifndef DEF___XdUUPJyn85d
                                #define DEF___XdUUPJyn85d
inline static unsigned _XdUU(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_xZR4(_, rnd);
}
                                #endif

                                #ifndef DEF_map_7b35IOFGx16
                                #define DEF_map_7b35IOFGx16
inline fu::vec<unsigned> map_7b35(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<unsigned> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _XdUU(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_KQybDbV0L3l
                                #define DEF_find_KQybDbV0L3l
inline int find_KQyb(/*F:F*/ fu::view<unsigned> haystack, const unsigned needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_EDD5lTAoNll
                                #define DEF_find_EDD5lTAoNll
inline int find_EDD5(/*F:F*/ fu::view<unsigned> haystack, /*F:F*/ fu::view<unsigned> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_KQyb(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const unsigned /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_VHCH23wNfhe
                                #define DEF_find_VHCH23wNfhe
inline int find_VHCH(/*F:F*/ fu::view<unsigned> haystack, /*F:F*/ fu::view<unsigned> needle, const int start)
{
    fu::view<unsigned> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_EDD5(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_HEmkFgngAWh
                                #define DEF_check_HEmkFgngAWh
inline static void check_HEmk(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<unsigned> a_1 = map_7b35(a, rnd);
    fu::vec<unsigned> b_1 = map_7b35(b, rnd);
    const int a0 = find_EDD5(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_VHCH(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

static uint64_t xorshift_haRm(uint64_t x)
{
    x ^= (x << 13ull);
    x ^= (x >> 7ull);
    return (x ^= (x << 17ull));
}

                                #ifndef DEF_randomize_TZWXZT6aVh6
                                #define DEF_randomize_TZWXZT6aVh6
inline static uint64_t randomize_TZWX(const char v, /*3:3*/ const unsigned rnd)
{
    return xorshift_haRm((uint64_t(fu::u8(v)) + uint64_t(rnd)));
}
                                #endif

                                #ifndef DEF___oNhbiqB3hh0
                                #define DEF___oNhbiqB3hh0
inline static uint64_t _oNhb(/*3:3*/ const char _, /*3:3*/ const unsigned rnd)
{
    return randomize_TZWX(_, rnd);
}
                                #endif

                                #ifndef DEF_map_u6kI1wcMaFb
                                #define DEF_map_u6kI1wcMaFb
inline fu::vec<uint64_t> map_u6kI(/*7:7*/ fu::view<char> a, /*7:7*/ const unsigned rnd)
{
    /*MOV*/ fu::vec<uint64_t> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _oNhb(a[i], rnd);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_find_Uv2e1viqfzl
                                #define DEF_find_Uv2e1viqfzl
inline int find_Uv2e(/*F:F*/ fu::view<uint64_t> haystack, const uint64_t needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_AdjULDRCER4
                                #define DEF_find_AdjULDRCER4
inline int find_AdjU(/*F:F*/ fu::view<uint64_t> haystack, /*F:F*/ fu::view<uint64_t> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_Uv2e(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const uint64_t /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_npx4fG8O7m2
                                #define DEF_find_npx4fG8O7m2
inline int find_npx4(/*F:F*/ fu::view<uint64_t> haystack, /*F:F*/ fu::view<uint64_t> needle, const int start)
{
    fu::view<uint64_t> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_AdjU(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_check_xOpZhSPoT4e
                                #define DEF_check_xOpZhSPoT4e
inline static void check_xOpZ(/*F3:F3*/ fu::view<char> a, /*F3:F3*/ fu::view<char> b, /*F3:F3*/ const int expect, /*F3:F3*/ const int next, /*F3:12*/ unsigned& rnd_state)
{
    const unsigned rnd = rnd_MbR9(rnd_state);
    fu::vec<uint64_t> a_1 = map_u6kI(a, rnd);
    fu::vec<uint64_t> b_1 = map_u6kI(b, rnd);
    const int a0 = find_AdjU(a_1, b_1);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_npx4(a_1, b_1, (expect + b_1.size()));
        fu_ASSERT((a1 == next));
    };
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_nuahYODApY2
                                #define DEF_replace_nuahYODApY2
inline fu::str replace_nuah(/*7:7*/ fu::vec_range<char> str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_rkz0(str, all, last)) >= 0))
        {

            {
                fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

static void check_MbR9(/*F1:F1*/ fu::vec_range<char> a, /*F1:F1*/ fu::vec_range<char> b, const int expect, const int next, /*01:01*/ unsigned& rnd_state)
{
    const int a0 = find_7SLc(a, b);
    fu_ASSERT((a0 == expect));
    if ((expect >= 0))
    {
        const int a1 = find_BNNw(a, b, (expect + b.size()));
        fu_ASSERT((a1 == next));
    };
    if (!(!b))
    {
        if (b.size() < 256)
        {
            fu::str aa {};
            fu::str bb {};
            for (int i = 0; i < a.size(); i++)
            {
                aa += fu::view<char> {{ a[i], a[i] }};
            };
            for (int i_1 = 0; i_1 < b.size(); i_1++)
            {
                bb += fu::view<char> {{ b[i_1], b[i_1] }};
            };
            check_MbR9(aa, bb, ((expect < 0) ? -1 : (expect * 2)), ((next < 0) ? -1 : (next * 2)), rnd_state);
        };
        if (!has_Mnu2(b, 'x'))
        {
            const int bi = (b.size() ? int((rnd_MbR9(rnd_state) % unsigned(b.size()))) : 0);
            check_MbR9(a, ((fu::get_view_start0(b, bi) + 'x') + fu::get_view(b, bi)), -1, -1, rnd_state);
            if ((b.size() >= 2) && (expect >= 0) && (next < 0))
            {
                const int bmid = (b.size() - 2);
                const int ai = ((expect + 1) + int((bmid ? (rnd_MbR9(rnd_state) % unsigned(bmid)) : 0u)));
                check_MbR9(((fu::get_view_start0(a, ai) + 'c') + fu::get_view(a, ai)), b, -1, -1, rnd_state);
            };
            check_We9a(a, b, expect, next, rnd_state);
            check_bCSY(a, b, expect, next, rnd_state);
            check_HEmk(a, b, expect, next, rnd_state);
            check_xOpZ(a, b, expect, next, rnd_state);
            if ((expect >= 0) && !(b.size() & 1) && !has_Mnu2(a, 'n'))
            {
                check_MbR9((a + 'n'), b, expect, next, rnd_state);
                check_MbR9(('n' + a), b, (expect + 1), ((next < 0) ? next : (next + 1)), rnd_state);
                if (!has_Mnu2(b, 'n') && a.size())
                {
                    const char /*b|static*/ replace = b[int((rnd_MbR9(rnd_state) % unsigned(b.size())))];
                    fu::str a_1 = replace_nuah(a, replace, 'n');
                    fu::str b_1 = replace_nuah(b, replace, 'n');

                    {
                        const int expect_1 = ((expect < 0) ? expect : (expect - 1));
                        const int next_1 = ((next < 0) ? next : (next - 1));
                        if ((expect_1 >= 0) || (next_1 < 0))
                            check_MbR9(fu::get_range(a_1, 1), b_1, expect_1, next_1, rnd_state);

                    };
                    check_MbR9(fu::get_range_start0(a_1, (a_1.size() - 1)), b_1, ((expect < (a_1.size() - b_1.size())) ? expect : -1), ((next < (a_1.size() - b_1.size())) ? next : -1), rnd_state);
                };
            };
        };
    };
}

int fu_MAIN()
{
    unsigned rnd_state = unsigned(1);
    check_MbR9(str_83mA2Eo17Zf, (*(fu::str*)fu::NIL), 0, 0, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_gWBQGF7fAGj, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_Cebu50MstTd, 5, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_yXdmW9I62jj, 10, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_LCCnJta4Qr3, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_yElO8d6IRa5, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_8ErWFytUuS3, 1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_RqGpT9eVZYa, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_RqGpT9eVZYa, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_LW2kMQ5B3zk, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_sytNjoQDjnb, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_oCXfB89qlT4, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_SwsZerknvx3, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_wkkM60XKj5j, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_MjsKQ7HraF9, 2, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_tbhpNFtSnI0, 5, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_ytL5Dq7RG8j, 4, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_9VaFzJwl1w6, 6, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_83mA2Eo17Zf, 0, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_KEX9B4sOGX3, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_pw860sfqCJc, -1, -1, rnd_state);
    check_MbR9(str_83mA2Eo17Zf, str_wJtIo2Ln5qg, -1, -1, rnd_state);
    check_MbR9(str_h7GzxRvwDX5, str_LCCnJta4Qr3, 0, 5, rnd_state);
    check_MbR9(str_e7bxHeyMVOe, str_LCCnJta4Qr3, 4, 9, rnd_state);
    check_MbR9(str_0inx36NHGV3, str_LCCnJta4Qr3, 8, -1, rnd_state);
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedLet

========

        return "hello world".find("world")
             - 2 * [1, 7, 13, 14, 19].find(14);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_cnEOb0yQcL9
                                #define DEF_find_cnEOb0yQcL9
inline int find_cnEO(/*F:F*/ fu::view<int> haystack, const int needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

int fu_MAIN()
{
    return find_7SLc("hello world"_view, "world"_view) - (2 * find_cnEO(fu::view<int> {{ 1, 7, 13, 14, 19 }}, 14));
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        return ("hello world".has("world") ? 1 : 0)
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_has_YIf6pzpE4yj
                                #define DEF_has_YIf6pzpE4yj
inline bool has_YIf6(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (find_7SLc(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_find_cnEOb0yQcL9
                                #define DEF_find_cnEOb0yQcL9
inline int find_cnEO(/*F:F*/ fu::view<int> haystack, const int needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_b66pz2alRJ0
                                #define DEF_has_b66pz2alRJ0
inline bool has_b66p(/*3:3*/ fu::view<int> a, const int b)
{
    return (find_cnEO(a, b) >= 0);
}
                                #endif

int fu_MAIN()
{
    return ((has_YIf6("hello world"_view, "world"_view) ? 1 : 0) + (has_b66p(fu::view<int> {{ 1, 14, 96, 2 }}, 14) ? 2 : 0)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        let hw = "hello world!";
        let a = hw.slice(6, 6 + 5);
        let b = hw[6 .. 6 + 5];
        return a == b && a == "world" ? a.len - 5 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ hw = "hello world!"_view;
    fu::view<char> /*hw*/ a = fu::get_view(hw, 6, (6 + 5));
    fu::view<char> /*hw*/ b = fu::get_view(hw, 6, (6 + 5));
    if ((a == b) && (a == "world"_view))
        return a.size() - 5;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2160) arc_count(17) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_fXECfiJok71
                                #define STR_fXECfiJok71
static const fu::str str_fXECfiJok71 fu_INIT_PRIORITY(1001) { "  hey you duders "_fu };
                                #endif

                                #ifndef STR_kBmK82rXdVd
                                #define STR_kBmK82rXdVd
static const fu::str str_kBmK82rXdVd fu_INIT_PRIORITY(1001) { "  hey you  duders "_fu };
                                #endif

                                #ifndef STR_lUv4OYQOD6a
                                #define STR_lUv4OYQOD6a
static const fu::str str_lUv4OYQOD6a fu_INIT_PRIORITY(1001) { "  hey you  duders  "_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static int test_MbR9(/*1:1*/ fu::vec_range<char> item)
{
    if (item == join_yqDb(split_t3LL(item, " "_view), " "_view))
        return 0;
    else
        return item.size();

}

int fu_MAIN()
{
    fu::vec<fu::str> tests = fu::vec<fu::str> {{ fu::str(""_fu), fu::str(" "_fu), fu::str("  "_fu), fu::str("hey you duders"_fu), fu::str(" hey you duders"_fu), fu::str("hey you duders "_fu), fu::str(str_fXECfiJok71), fu::str(str_kBmK82rXdVd), fu::str(str_lUv4OYQOD6a) }};
    int sum = 0;
    for (int i = 0; i < tests.size(); i++)
        sum += test_MbR9(tests[i]);

    return sum;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2160) arc_count(17) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_fXECfiJok71
                                #define STR_fXECfiJok71
static const fu::str str_fXECfiJok71 fu_INIT_PRIORITY(1001) { "  hey you duders "_fu };
                                #endif

                                #ifndef STR_kBmK82rXdVd
                                #define STR_kBmK82rXdVd
static const fu::str str_kBmK82rXdVd fu_INIT_PRIORITY(1001) { "  hey you  duders "_fu };
                                #endif

                                #ifndef STR_lUv4OYQOD6a
                                #define STR_lUv4OYQOD6a
static const fu::str str_lUv4OYQOD6a fu_INIT_PRIORITY(1001) { "  hey you  duders  "_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static int test_MbR9(/*1:1*/ fu::vec_range<char> item)
{
    if (item == join_yqDb(split_t3LL(item, " "_view), " "_view))
        return 0;
    else
        return item.size();

}

int fu_MAIN()
{
    fu::vec<fu::str> tests = fu::vec<fu::str> {{ fu::str{}, fu::str(" "_fu), fu::str("  "_fu), fu::str("hey you duders"_fu), fu::str(" hey you duders"_fu), fu::str("hey you duders "_fu), fu::str(str_fXECfiJok71), fu::str(str_kBmK82rXdVd), fu::str(str_lUv4OYQOD6a) }};
    int sum = 0;
    for (int i = 0; i < tests.size(); i++)
        sum += test_MbR9(tests[i]);

    return sum;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            let sj = "heelloo"  .split("ee").join("e")
                                .split('o').join("o!")
                                .split("he").join();            // DuplicateFunctions

            return sj == "llo!o!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_dg0vxXJcQvk
                                #define STR_dg0vxXJcQvk
static const fu::str str_dg0vxXJcQvk fu_INIT_PRIORITY(1001) { "heelloo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_split_Df39Wj9MElc
                                #define DEF_split_Df39Wj9MElc
inline void split_Df39(/*F:F*/ fu::vec_range<char> str, const char sep, /*E:E*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = 1;
    if (N)
    {
        while (((next = find_rkz0(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_0cpnrwNwKMe
                                #define DEF_split_0cpnrwNwKMe
inline fu::vec<fu::str> split_0cpn(/*3:3*/ fu::vec_range<char> str, const char sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_Df39(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str sj = join_QbuI(split_t3LL(join_yqDb(split_0cpn(join_yqDb(split_t3LL(str_dg0vxXJcQvk, "ee"_view), "e"_view), 'o'), "o!"_view), "he"_view));
    if (sj == "llo!o!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            let sj = "heelloo"  .split("ee").join("e")
                                .split('o').join("o!")
                                .split("he").join();            // DuplicateFunctions

            return sj == "llo!o!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_dg0vxXJcQvk
                                #define STR_dg0vxXJcQvk
static const fu::str str_dg0vxXJcQvk fu_INIT_PRIORITY(1001) { "heelloo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_split_kfES3Koo5I5
                                #define DEF_split_kfES3Koo5I5
inline void split_kfES(/*F:F*/ fu::vec_range<char> str, const char sep, /*E:E*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = 1;
    while (((next = find_rkz0(str, sep, last)) >= 0))
    {
        _eQwy(fu::get_range(str, last, next), result);
        last = (next + N);
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_Gbk9Z7dwor4
                                #define DEF_split_Gbk9Z7dwor4
inline fu::vec<fu::str> split_Gbk9(/*3:3*/ fu::vec_range<char> str, const char sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_kfES(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str sj = join_QbuI(split_t3LL(join_yqDb(split_Gbk9(join_yqDb(split_t3LL(str_dg0vxXJcQvk, "ee"_view), "e"_view), 'o'), "o!"_view), "he"_view));
    if (sj == "llo!o!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() '\e'.i32 - 27
             ||   '\0'.i32
             || '\x11'.i32 - 17
             || '\xaA'.i32 - 170;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int _0;
    return (_0 = (int(fu::u8('\x1B')) - 27)) ? _0 : (_0 = int(fu::u8('\x00'))) ? _0 : (_0 = (int(fu::u8('\x11')) - 17)) ? _0 : (int(fu::u8('\xAA')) - 170);
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()     // '
            'c
            '       
                .i32 - 99;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()     // '[0m
[2m    3 | [0m            [31;1m'c[0m
[2m      |             '       [0m
[2m      |                 .i32 - 99;[0m

	Unterminated char literal.

========

        fn main()   
            'c      
                .i32 - 99;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m'c[0m      
[2m      |                 .i32 - 99;[0m
[2m      | [0m

	Unterminated char literal.

========

        fn main()   
            'c'     
                .i32 - 99;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8('c')) - 99;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()   
            'cb'    
                .i32 - 99;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+4[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m'cb'[0m    
[2m      |                 .i32 - 99;[0m
[2m      | [0m

	Invalid char literal, not single byte: 2 bytes long.

========

        fn main()     // "
            "c
            "       
                [0].i32 - 99;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()     // "[0m
[2m    3 | [0m            [31;1m"c[0m
[2m      |             "       [0m
[2m      |                 [0].i32 - 99;[0m

	Unterminated double-quote string literal.

	Use backticks around multiline strings.

========

        fn main()   
            "c      
                [0].i32 - 99;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m"c[0m      
[2m      |                 [0].i32 - 99;[0m
[2m      | [0m

	Unterminated double-quote string literal.

	Use backticks around multiline strings.

========

        fn main()   
            `c
            `      
                [0].i32 - 99;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8("c\n            "_view[0])) - 99;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()                           
            "\u{ffffff}".u32               
            ;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:14+10[0m:

[2m      | [0m
[2m      |         fn main()                           [0m
[2m    3 | [0m            "[31;1m\u{ffffff}[0m".u32               
[2m      |             ;[0m
[2m      | [0m

	Invalid \u-escape: bad code point.

========

        fn main()                           
            "\u{042e}" == "Ю"  ? 0 : 1     
            ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if ("\xD0\xAE"_view == "\xD0\xAE"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut hello = "hello";
            mut olleh = hello;
            olleh.reverse();
            return olleh == "olleh" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec_range<char> /*static*/ hello = str_LCCnJta4Qr3;
    fu::str olleh = fu::str(hello);
    reverse_LDrI(olleh);
    if (olleh == "olleh"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn main() {
            mut hello = "hello";
            mut olleh = hello;
            olleh.reverse();
            return olleh == "olleh" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    const fu::str& /*static*/ hello = str_LCCnJta4Qr3;
    fu::str olleh = fu::str(hello);
    reverse_LDrI(olleh);
    if (olleh == "olleh"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn main()
            "hello".replace(all: "h", with: "H") == "Hello" &&
            "hello".replace(all: 'e', with: 'E') == "hEllo" &&
            "hello".replace(all: "l", with: 'L') == "heLLo" &&
            "hello".replace(all: 'o', with: "O") == "hellO" &&
            "hello".replace(all: "l", with:  []) == "heo"
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_3t3M6Hz181f
                                #define DEF_replace_3t3M6Hz181f
inline fu::str replace_3t3M(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all, /*7:7*/ fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!first)
                        result += with;
                    else if (last_1)
                        return fu::str(str);

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_EC32FyABXS6
                                #define DEF_replace_EC32FyABXS6
inline fu::str replace_EC32(/*7:7*/ fu::vec_range<char> str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        if (N)
        {
            while (((next = find_rkz0(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!first)
                        result += with;
                    else if (last_1)
                        return fu::str(str);

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_rjNqUXArCx7
                                #define DEF_replace_rjNqUXArCx7
inline fu::str replace_rjNq(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!first)
                        result += with;
                    else if (last_1)
                        return fu::str(str);

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_gYxGVHecHX1
                                #define DEF_replace_gYxGVHecHX1
inline fu::str replace_gYxG(/*7:7*/ fu::vec_range<char> str, const char all, /*7:7*/ fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        if (N)
        {
            while (((next = find_rkz0(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!first)
                        result += with;
                    else if (last_1)
                        return fu::str(str);

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!first)
                result += with;
            else if (last_1)
                return fu::str(str);

            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_dWkiFcVkwHk
                                #define DEF_replace_dWkiFcVkwHk
inline fu::str replace_dWki(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    const bool last_1 = false;
                    if (!(!first))
                    {
                        if (last_1)
                            return fu::str(str);

                    };
                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            const bool first = false;
            const bool last_1 = true;
            if (!(!first))
            {
                if (last_1)
                    return fu::str(str);

            };
            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last_1 = true;
            if (!(!first))
            {
                if (last_1)
                    return fu::str(str);

            };
            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    if ((replace_3t3M(str_LCCnJta4Qr3, "h"_view, "H"_view) == "Hello"_view) && (replace_EC32(str_LCCnJta4Qr3, 'e', 'E') == "hEllo"_view) && (replace_rjNq(str_LCCnJta4Qr3, "l"_view, 'L') == "heLLo"_view) && (replace_gYxG(str_LCCnJta4Qr3, 'o', "O"_view) == "hellO"_view) && (replace_dWki(str_LCCnJta4Qr3, "l"_view) == "heo"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        fn main()
            "hello".replace(all: "h", with: "H") == "Hello" &&
            "hello".replace(all: 'e', with: 'E') == "hEllo" &&
            "hello".replace(all: "l", with: 'L') == "heLLo" &&
            "hello".replace(all: 'o', with: "O") == "hellO" &&
            "hello".replace(all: "l", with:  []) == "heo"
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_4fXW2QLS6G4
                                #define DEF_replace_4fXW2QLS6G4
inline fu::str replace_4fXW(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all, /*7:7*/ fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_nuahYODApY2
                                #define DEF_replace_nuahYODApY2
inline fu::str replace_nuah(/*7:7*/ fu::vec_range<char> str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_rkz0(str, all, last)) >= 0))
        {

            {
                fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_R4RBiTkclda
                                #define DEF_replace_R4RBiTkclda
inline fu::str replace_R4RB(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_hjXfxcOXzya
                                #define DEF_replace_hjXfxcOXzya
inline fu::str replace_hjXf(/*7:7*/ fu::vec_range<char> str, const char all, /*7:7*/ fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_rkz0(str, all, last)) >= 0))
        {

            {
                fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_HNgR9jATQ52
                                #define DEF_replace_HNgR9jATQ52
inline fu::str replace_HNgR(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_BNNw(str, all, last)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last, next);
                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last);
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    if ((replace_4fXW(str_LCCnJta4Qr3, "h"_view, "H"_view) == "Hello"_view) && (replace_nuah(str_LCCnJta4Qr3, 'e', 'E') == "hEllo"_view) && (replace_R4RB(str_LCCnJta4Qr3, "l"_view, 'L') == "heLLo"_view) && (replace_hjXf(str_LCCnJta4Qr3, 'o', "O"_view) == "hellO"_view) && (replace_HNgR(str_LCCnJta4Qr3, "l"_view) == "heo"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedIfElse, N_UnusedLet

========

        fn cnct(a: string, b: string) a ~ b;

        fn main()
            cnct( 
                a: "hello, "`world!
` 
            ).len - 14;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:29+9[0m:

[2m      |         fn main()[0m
[2m      |             cnct( [0m
[2m    6 | [0m                a: "hello, "[31;1m`world![0m
[2m      | ` [0m
[2m      |             ).len - 14;[0m

	Missing comma before [31;1mworld!
[0m.

========

        fn cnct(a: string, b: string) a ~ b;

        fn main()
            cnct( 
                a: "hello, ", `world!
` 
            ).len - 14;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str cnct_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}

int fu_MAIN()
{
    return cnct_MbR9("hello, "_view, "world!\n"_view).size() - 14;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() ("" ~ "").len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return (""_view + ""_view).size();
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() ("" ~ "").len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return (fu::view<char>{} + fu::view<char>{}).size();
}

#endif

int main() { return fu_MAIN(); }

========

        let empty_str = "";

        fn main() = _0::empty_str.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ empty_str;
int fu_MAIN()
{
    return empty_str.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ empty_str fu_INIT_PRIORITY(1001) = str_00000000000;
#endif

// N_SD_HasStaticInit

========

        let empty_str = "";

        fn main() = _0::empty_str.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*zeroes*/ empty_str;
int fu_MAIN()
{
    return empty_str.ref.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/default.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*zeroes*/ empty_str fu_INIT_PRIORITY(1001) = (*(fu::str*)fu::NIL);
#endif

// N_SD_HasStaticInit

========

        let empty_str = "";
        let empty_str_ref = empty_str;

        fn main() = _0::empty_str_ref.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ empty_str_ref;
int fu_MAIN()
{
    return empty_str_ref.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ empty_str fu_INIT_PRIORITY(1001) = str_00000000000;
extern const fu::vec_range<char> /*static*/ empty_str_ref fu_INIT_PRIORITY(1001) = empty_str;
#endif

// N_SD_HasStaticInit

========

        let empty_str = "";
        let empty_str_ref = empty_str;

        fn main() = _0::empty_str_ref.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ empty_str_ref;
int fu_MAIN()
{
    return empty_str_ref.ref.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/default.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*zeroes*/ empty_str fu_INIT_PRIORITY(1001) = (*(fu::str*)fu::NIL);
extern const fu::static_ref<fu::str> /*static*/ empty_str_ref fu_INIT_PRIORITY(1001) = empty_str.ref;
#endif

// N_SD_HasStaticInit

========

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_str_ref = non_empty_str;

        fn main() = _0::non_empty_str_ref.len - 65;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ non_empty_str_ref;
int fu_MAIN()
{
    return non_empty_str_ref.size() - 65;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_VZWzuPWGH2l
                                #define STR_VZWzuPWGH2l
static const fu::str str_VZWzuPWGH2l fu_INIT_PRIORITY(1001) { "This is a non-empty string that's too long for small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ non_empty_str fu_INIT_PRIORITY(1001) = str_VZWzuPWGH2l;
extern const fu::vec_range<char> /*static*/ non_empty_str_ref fu_INIT_PRIORITY(1001) = non_empty_str;
#endif

// N_SD_HasStaticInit

========

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_str_ref = non_empty_str;

        fn main() = _0::non_empty_str_ref.len - 65;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ non_empty_str_ref;
int fu_MAIN()
{
    return non_empty_str_ref.ref.size() - 65;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


                                #ifndef STR_VZWzuPWGH2l
                                #define STR_VZWzuPWGH2l
static const fu::str str_VZWzuPWGH2l fu_INIT_PRIORITY(1001) { "This is a non-empty string that's too long for small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ non_empty_str fu_INIT_PRIORITY(1001) = str_VZWzuPWGH2l;
extern const fu::static_ref<fu::str> /*static*/ non_empty_str_ref fu_INIT_PRIORITY(1001) = non_empty_str.ref;
#endif

// N_SD_HasStaticInit

========

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_slice = non_empty_str[5..];

        fn main() = _0::non_empty_slice.len - 60;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ non_empty_slice;
int fu_MAIN()
{
    return non_empty_slice.size() - 60;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_VZWzuPWGH2l
                                #define STR_VZWzuPWGH2l
static const fu::str str_VZWzuPWGH2l fu_INIT_PRIORITY(1001) { "This is a non-empty string that's too long for small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ non_empty_str fu_INIT_PRIORITY(1001) = str_VZWzuPWGH2l;
extern const fu::vec_range<char> /*static*/ non_empty_slice fu_INIT_PRIORITY(1001) = fu::get_range(non_empty_str, 5);
#endif

// N_SD_HasStaticInit

========

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_slice = non_empty_str[5..];

        fn main() = _0::non_empty_slice.len - 60;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ non_empty_slice;
int fu_MAIN()
{
    return non_empty_slice.size() - 60;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


                                #ifndef STR_VZWzuPWGH2l
                                #define STR_VZWzuPWGH2l
static const fu::str str_VZWzuPWGH2l fu_INIT_PRIORITY(1001) { "This is a non-empty string that's too long for small string opti."_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ non_empty_str fu_INIT_PRIORITY(1001) = str_VZWzuPWGH2l;
extern const fu::vec_range<char> /*static*/ non_empty_slice fu_INIT_PRIORITY(1001) = fu::get_range(non_empty_str.ref, 5);
#endif

// N_SD_HasStaticInit

========

        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
        {
            let a0 = mem::ALLOC_STAT_COUNT();
            strA.slice(0, 26) == "0123456789abcdef0123456789" || throw("bad slice");

            let a1 = mem::ALLOC_STAT_COUNT();
            a0 == a1 || throw("did alloc");

            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----

========

        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_6WaiHt9JPzf
                                #define STR_6WaiHt9JPzf
static const fu::str str_6WaiHt9JPzf fu_INIT_PRIORITY(1001) { "0123456789abcdef0123456789ABCDEF"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ strA fu_INIT_PRIORITY(1001) = str_6WaiHt9JPzf;

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (fu::get_view(strA, 26, 32) == "ABCDEF"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


                                #ifndef STR_6WaiHt9JPzf
                                #define STR_6WaiHt9JPzf
static const fu::str str_6WaiHt9JPzf fu_INIT_PRIORITY(1001) { "0123456789abcdef0123456789ABCDEF"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ strA fu_INIT_PRIORITY(1001) = str_6WaiHt9JPzf;

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (fu::get_view(strA.ref, 26, 32) == "ABCDEF"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        struct NotAString { hey: string };
        fn main() {
            mut a = "Hello";
            mut b = NotAString("World!");

            return a < b ? 0 : 1;         
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:22+1[0m:

[2m      |             mut b = NotAString("World!");[0m
[2m      | [0m
[2m    7 | [0m            return a [31;1m<[0m b ? 0 : 1;         
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1m<[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstring[0m, [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNotAString[0m): 

	[35;3mtemplate[0m [94;1m<[0m at [2m../../../../../[0mprelude[2m 841:11+1[0m:
[2m  841 | [0minfix fn  [31;1m<[0m(a: <T>[..], b: T[..]) case (T -> byte) = a <> b < 0;

	    [35;3marg[0m [94;1m<[0m:[94;1mb[0m:
	    Not sliceable: [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNotAString[0m

	[35;3mtemplate[0m [94;1m<[0m at [2m../../../../../[0mprelude[2m 34:10+1[0m:
[2m   34 | [0minfix fn [31;1m<[0m  (a: <T>, b: T) case (T.is::primitive): bool __native;

	    [35;3marg[0m [94;1m<[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstring[0m <-> [35;3mstruct[0m [94;1mNotAString[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        struct NotAString { hey: string };
        fn main() {
            mut a = "Hello";
            mut b = NotAString("World!");

            return a < b.hey ? 0 : 1;     
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct NotAString_Iu78;

                                #ifndef DEF_NotAString_Iu78QUhHOK7
                                #define DEF_NotAString_Iu78QUhHOK7
struct NotAString_Iu78
{
                                // shape_hash:    c4549712fa7245a5
                                // non_triv_mask: 0001800000000000
    fu::str hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3C_AKgS2zBMRzl
                                #define DEF_x3C_AKgS2zBMRzl
inline bool operator<(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return x3Cx3E_j5CR(a, b) < 0;
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ a = "Hello"_view;
    NotAString_Iu78 b = NotAString_Iu78 { fu::str("World!"_fu) };
    if (a < b.hey)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn Zero(sources: string[])
            sources;

        fn ZeroSame(alts: string[][])
            alts.map(.Zero);

        fn ZeroSame(alts: string[])
            ZeroSame(alts.map(|x| [ x ]));

        fn main() {
            let result =
                ZeroSame([ "Hello", "World" ])
                    .map(|inner| inner.join("#"))
                        .join(", ") ~ "!";

            return result == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___GqAhC8wSZ87
                                #define DEF___GqAhC8wSZ87
inline static fu::vec<fu::str> _GqAh(/*1:1*/ fu::vec_range<char> x)
{
    return fu::vec<fu::str> {{ fu::str(x) }};
}
                                #endif

                                #ifndef DEF_map_n1nWlIHtrea
                                #define DEF_map_n1nWlIHtrea
inline fu::vec<fu::vec<fu::str>> map_n1nW(/*3:3*/ fu::view<fu::str> a)
{
    /*MOV*/ fu::vec<fu::vec<fu::str>> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _GqAh(a[i]);

    return /*NRVO*/ res;
}
                                #endif

static fu::vec_range<fu::str> Zero_MbR9(/*1:1*/ fu::vec_range<fu::str> sources)
{
    return sources;
}

                                #ifndef DEF___q5V5hIDbLK2
                                #define DEF___q5V5hIDbLK2
inline static fu::vec_range<fu::str> _q5V5(/*1:1*/ fu::vec_range<fu::str> _)
{
    return Zero_MbR9(_);
}
                                #endif

                                #ifndef DEF_map_4tgFYMPZNge
                                #define DEF_map_4tgFYMPZNge
inline fu::vec<fu::vec<fu::str>> map_4tgF(/*3:3*/ fu::view<fu::vec<fu::str>> a)
{
    /*MOV*/ fu::vec<fu::vec<fu::str>> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::vec<fu::str>(_q5V5(a[i]));

    return /*NRVO*/ res;
}
                                #endif

static fu::vec<fu::vec<fu::str>> ZeroSame_MbR9(/*1:1*/ fu::view<fu::vec<fu::str>> alts)
{
    return map_4tgF(alts);
}

static fu::vec<fu::vec<fu::str>> ZeroSame_kGbb(/*1:1*/ fu::view<fu::str> alts)
{
    return ZeroSame_MbR9(map_n1nW(alts));
}

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF___Mg10XP9Woek
                                #define DEF___Mg10XP9Woek
inline static fu::str _Mg10(/*1:1*/ fu::view<fu::str> inner)
{
    return join_yqDb(inner, "#"_view);
}
                                #endif

                                #ifndef DEF_map_9geu7qSNnU3
                                #define DEF_map_9geu7qSNnU3
inline fu::vec<fu::str> map_9geu(/*3:3*/ fu::view<fu::vec<fu::str>> a)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _Mg10(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = (join_yqDb(map_9geu(ZeroSame_kGbb(fu::view<fu::str> {{ fu::str("Hello"_fu), fu::str("World"_fu) }})), ", "_view) + "!"_view);
    if (result == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            let data = "kung--fury";
            mut what = 1;
            mut res = "";
            data.split("--"): |part| what *= (res ~= part).len;
            return what == 32 && res == "kungfury" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___fOrC5gbzqsi
                                #define DEF___fOrC5gbzqsi
inline static int _fOrC(/*7:7*/ fu::view<char> part, /*7:6*/ int& what, /*6:4*/ fu::vec_range_mut<char> res)
{
    return (what *= (res += part).size());
}
                                #endif

                                #ifndef DEF_split_K96ToDA0upb
                                #define DEF_split_K96ToDA0upb
inline void split_K96T(/*F1:F1*/ fu::view<char> str, /*F1:F1*/ fu::view<char> sep, /*C1:C*/ int& what, /*C1:41*/ fu::vec_range_mut<char> res)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _fOrC(fu::get_view(str, last, next), what, res);
            last = (next + N);
        };
    };
    if (last)
        _fOrC(fu::get_view(str, last), what, res);
    else
        _fOrC(str, what, res);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ data = "kung--fury"_view;
    int what = 1;
    fu::str res = fu::str(""_fu);
    split_K96T(data, "--"_view, what, res);
    if ((what == 32) && (res == "kungfury"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            let data = "kung--fury";
            mut what = 1;
            mut res = "";
            data.split("--"): |part| what *= (res ~= part).len;
            return what == 32 && res == "kungfury" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___fOrC5gbzqsi
                                #define DEF___fOrC5gbzqsi
inline static int _fOrC(/*7:7*/ fu::view<char> part, /*7:6*/ int& what, /*6:4*/ fu::str& res)
{
    return (what *= (res += part).size());
}
                                #endif

                                #ifndef DEF_split_K96ToDA0upb
                                #define DEF_split_K96ToDA0upb
inline void split_K96T(/*F1:F1*/ fu::view<char> str, /*F1:F1*/ fu::view<char> sep, /*C1:C*/ int& what, /*C1:41*/ fu::str& res)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _fOrC(fu::get_view(str, last, next), what, res);
            last = (next + N);
        };
    };
    if (last)
        _fOrC(fu::get_view(str, last), what, res);
    else
        _fOrC(str, what, res);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ data = "kung--fury"_view;
    int what = 1;
    fu::str res {};
    split_K96T(data, "--"_view, what, res);
    if ((what == 32) && (res == "kungfury"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_COWRestrict

========

        fn Append(inline a: string,  b: string) a ~ b;
        fn main() {
            let res = Append(
                Append("12345678901234567890", "12345678901234567890"),
                "12345678901234567890"); // ALLOCS 1

            return res.len == 60 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> b {};
    fu::view<char> b_1 {};
    fu::str res = (b.ptr_reassign("12345678901234567890"_view), ((b_1.ptr_reassign("12345678901234567890"_view), ("12345678901234567890"_view + b_1)) + b));
    if (res.size() == 60)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn Append(inline a: string, inline b: string) a ~ b;
        fn main() {
            let res = Append(
                Append("12345678901234567890", "12345678901234567890"),
                "12345678901234567890"); // ALLOCS 1

            return res.len == 60 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str res = (("12345678901234567890"_view + "12345678901234567890"_view) + "12345678901234567890"_view);
    if (res.size() == 60)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a = 1, b = 2) a + b;
        return test() - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_MbR9(1, 2) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a = 1, b = 2) a + b;
        return test(b: -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_MbR9(1, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a = 1, b = 2) a + b;
        return test(-2);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_MbR9(-2, 2);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Test_ikd8 t = Test_ikd8 { 1, 0 };
    return (t.a - 1) + (t.b * 7);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.b;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Test_ikd8 t = Test_ikd8 { {/*unused non-zst*/}, 0 };
    return t.b;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a?: i32; b?: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Test_ikd8 t = Test_ikd8 { 1, 0 };
    return (t.a - 1) + (t.b * 7);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a?: i32; b?: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Test_ikd8 t = Test_ikd8 { 0, 1 };
    return (t.b - 1) + (t.a * 7);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { x?: i32; };
        fn hey() Test();
        return hey.x;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_68jG;

                                #ifndef DEF_Test_68jGtUaG1jd
                                #define DEF_Test_68jGtUaG1jd
struct Test_68jG
{
                                // shape_hash:    24b0cd36b2a5efa9
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_68jG hey_MbR9()
{
    return Test_68jG{};
}

int fu_MAIN()
{
    return hey_MbR9().x;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { x?: i32; };
        fn hey(y: i32 = 0)
            y   ? Test(1)
                : Test();

        return hey.x;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_68jG;

                                #ifndef DEF_Test_68jGtUaG1jd
                                #define DEF_Test_68jGtUaG1jd
struct Test_68jG
{
                                // shape_hash:    24b0cd36b2a5efa9
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_68jG hey_MbR9(const int y)
{
    if (y)
    {
        return Test_68jG { 1 };
    }
    else
    {
        return Test_68jG{};
    };
}

int fu_MAIN()
{
    return hey_MbR9(0).x;
}

#endif

int main() { return fu_MAIN(); }

========


        fn test(a = "hello") a.len;     
        fn main() test(-1);

---- <fail> ----
[2m[0m_0[2m.fu 4:19+4[0m:

[2m      | [0m
[2m      |         fn test(a = "hello") a.len;     [0m
[2m    4 | [0m        fn main() [31;1mtest[0m(-1);
[2m      | [0m

	Bad call to [94;1mtest[0m with args ([35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m3:12+4[0m:
[2m    3 | [0m        fn [31;1mtest[0m(a = "hello") a.len;     

	    [35;3marg[0m [94;1mtest[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========


        fn test(a = "hello") a.len;     
        fn main() test(-1);

---- <fail> ----
[2m[0m_0[2m.fu 4:19+4[0m:

[2m      | [0m
[2m      |         fn test(a = "hello") a.len;     [0m
[2m    4 | [0m        fn main() [31;1mtest[0m(-1);
[2m      | [0m

	Bad call to [94;1mtest[0m with args ([35;3malways-true[0m [35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m3:12+4[0m:
[2m    3 | [0m        fn [31;1mtest[0m(a = "hello") a.len;     

	    [35;3marg[0m [94;1mtest[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========


        fn test(a = 0) a + 1;           
        fn main() test(-1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a)
{
    return a + 1;
}

int fu_MAIN()
{
    return test_MbR9(-1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a = 3, b = a * 2) a + b;
        fn main() test + test(a: -1) * 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    int __def_arg_ref;
    int _0;
    int __def_arg_ref_1;
    int _1;
    return (_0 = (__def_arg_ref = 3), test_MbR9(_0, (__def_arg_ref * 2))) + ((_1 = (__def_arg_ref_1 = -1), test_MbR9(_1, (__def_arg_ref_1 * 2))) * 3);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        fn test(a = 3, b = a * a) a + b;
        fn main() test + test(a: 5) - 42;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    int __def_arg_ref;
    int _0;
    int __def_arg_ref_1;
    int _1;
    return ((_0 = (__def_arg_ref = 3), test_MbR9(_0, (__def_arg_ref * __def_arg_ref))) + (_1 = (__def_arg_ref_1 = 5), test_MbR9(_1, (__def_arg_ref_1 * __def_arg_ref_1)))) - 42;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        fn woot(ref a: i32, ref b: i32) {
            ref c = a || b;                                         
            fn arg_defaulted_to_closure(ref x = c, y = x *= 2) y;   

            arg_defaulted_to_closure( );
            arg_defaulted_to_closure(a);
            arg_defaulted_to_closure(b);
        }

        fn main() {
            mut a = 1;
            mut b = 1;
            woot(a, b);
            return a == 4 && b == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void woot_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    int& /*a|b*/ c = (a ? a : b);
    c *= 2;
    a *= 2;
    b *= 2;
}

int fu_MAIN()
{
    int a = 1;
    int b = 1;
    woot_MbR9(a, b);
    if ((a == 4) && (b == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_UnusedCall

========

        fn woot(ref a: i32, ref b: i32) {
            ref c = a || b;                                         
            fn arg_defaulted_to_closure(ref x = c)     x *= 2;      

            arg_defaulted_to_closure( );
            arg_defaulted_to_closure(a);
            arg_defaulted_to_closure(b);
        }

        fn main() {
            mut a = 1;
            mut b = 1;
            woot(a, b);
            return a == 4 && b == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int arg_defaulted_to_closure_GL0m(/*1:1*/ int& x)
{
    return (x *= 2);
}

static void woot_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    int& /*a|b*/ c = (a ? a : b);
    arg_defaulted_to_closure_GL0m(c);
    arg_defaulted_to_closure_GL0m(a);
    arg_defaulted_to_closure_GL0m(b);
}

int fu_MAIN()
{
    int a = 1;
    int b = 1;
    woot_MbR9(a, b);
    if ((a == 4) && (b == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedImplicit

========

        fn test(ref a: i32, mut incr: i32) {
            fn woot(ref x, ref b = a) { // 'a' closes over here!
                if (x & 1) {
                    x /= 2;
                    return test(x, b);
                }
                return b += x;
            }

            return woot(incr);
        }

        fn main() {
            mut x = 10;
            return test(x, 5) == 12 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int test_MbR9(int&, int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_woot_9wtAi5e0mmf
                                #define DEF_woot_9wtAi5e0mmf
inline static int woot_9wtA(/*3:1*/ int& x, /*3:3*/ int& b)
{
    if (x & 1)
    {
        x /= 2;
        return test_MbR9(x, b);
    }
    else
        return (b += x);

}
                                #endif

static int test_MbR9(/*3:1*/ int& a, int incr)
{
    return woot_9wtA(incr, a);
}

int fu_MAIN()
{
    int x = 10;
    if (test_MbR9(x, 5) == 12)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        fn test(ref a: i32, mut incr: i32) {
            fn woot(ref x, ref b = a) { // 'a' closes over here!
                if (x & 1) {
                    x /= 2;
                    return test(x, b);
                }
                return b += x;
            }

            return woot(incr, a);
        }

        fn main() {
            mut x = 10;
            return test(x, 5) == 12 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int test_MbR9(int&, int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_woot_9wtAi5e0mmf
                                #define DEF_woot_9wtAi5e0mmf
inline static int woot_9wtA(/*3:1*/ int& x, /*3:3*/ int& b)
{
    if (x & 1)
    {
        x /= 2;
        return test_MbR9(x, b);
    }
    else
        return (b += x);

}
                                #endif

static int test_MbR9(/*3:1*/ int& a, int incr)
{
    return woot_9wtA(incr, a);
}

int fu_MAIN()
{
    int x = 10;
    if (test_MbR9(x, 5) == 12)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        struct Arg { name: string };
        fn main() {
            let arg = Arg(id: "hey");
            return arg.name.len - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+3[0m:

[2m      |         struct Arg { name: string };[0m
[2m      |         fn main() {[0m
[2m    4 | [0m            let arg = [31;1mArg[0m(id: "hey");
[2m      |             return arg.name.len - 3;[0m
[2m      |         }[0m

	Bad call to [94;1mArg[0m with args ([35;3mstring[0m): 

	[35;3mtype[0m [94;1mArg[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Arg { name: string };

	    Named :argument mismatch: no [31;3marg[0m [31;1mid[0m.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        struct Arg { name: string };
        fn main() {
            let arg = Arg(id: "hey");
            return arg.name.len - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+3[0m:

[2m      |         struct Arg { name: string };[0m
[2m      |         fn main() {[0m
[2m    4 | [0m            let arg = [31;1mArg[0m(id: "hey");
[2m      |             return arg.name.len - 3;[0m
[2m      |         }[0m

	Bad call to [94;1mArg[0m with args ([35;3malways-true[0m [35;3mstring[0m): 

	[35;3mtype[0m [94;1mArg[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Arg { name: string };

	    Named :argument mismatch: no [31;3marg[0m [31;1mid[0m.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        struct Arg { name: string };
        fn main() {
            let arg = Arg(name: "hey");
            return arg.name.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>

struct Arg_r2FL;

                                #ifndef DEF_Arg_r2FLXNVwCqe
                                #define DEF_Arg_r2FLXNVwCqe
struct Arg_r2FL
{
                                // shape_hash:    395cb76ada16118a
                                // non_triv_mask: 0000800000000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Arg_r2FL arg = Arg_r2FL { fu::str("hey"_fu) };
    return arg.name.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int uses_implicit_MbR9(/*1:1*/ int& sum)
{
    return sum++;
}

int fu_MAIN()
{
    int sum = 3;
    int hello;
    int defaulted_argument;
    const int res = (hello = sum, defaulted_argument = uses_implicit_MbR9(sum), (hello * defaulted_argument));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }
        pub import _0;
        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int uses_implicit_MbR9(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int hello;
    int defaulted_argument;
    const int res = (hello = sum, defaulted_argument = uses_implicit_MbR9(sum), (hello * defaulted_argument));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int uses_implicit_MbR9(/*1:1*/ int& sum)
{
    return sum++;
}

#endif

========

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        pub import _0;
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int uses_implicit_MbR9(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int hello;
    int defaulted_argument;
    const int res = (hello = sum, defaulted_argument = uses_implicit_MbR9(sum), (hello * defaulted_argument));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int uses_implicit_MbR9(/*1:1*/ int& sum)
{
    return sum++;
}

#endif

========

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        pub import _0;
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }
        pub import _1;
        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int uses_implicit_MbR9(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int hello;
    int defaulted_argument;
    const int res = (hello = sum, defaulted_argument = uses_implicit_MbR9(sum), (hello * defaulted_argument));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int uses_implicit_MbR9(/*1:1*/ int& sum)
{
    return sum++;
}

#endif

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;
            return a == 4 && res == 12 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    int* x;
    int _0;
    const int res = (_0 = (x = &((z ? z : a)), (*x)++), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };
            return a == 4 && res == 9 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    int _0;
    int* x;
    const int res = (_0 = a, (_0 * (x = &((z ? z : a)), (*x)++)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;
            return ooe_block_arg(:z, :a);
        }

        fn ooe_block_arg(ref z: i32, ref a: i32) {

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;
            return a == 4 && res == 12 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int ooe_block_arg_MbR9(/*3:1*/ int& z, /*3:3*/ int& a)
{
    int* x;
    int _0;
    const int res = (_0 = (x = &((z ? z : a)), (*x)++), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    return ooe_block_arg_MbR9(z, a);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;
            return ooe_block_arg(:z, :a);
        }

        fn ooe_block_arg(ref z: i32, ref a: i32) {

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };
            return a == 4 && res == 9 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int ooe_block_arg_MbR9(/*3:1*/ int& z, /*3:3*/ int& a)
{
    int _0;
    int* x;
    const int res = (_0 = a, (_0 * (x = &((z ? z : a)), (*x)++)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    return ooe_block_arg_MbR9(z, a);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            return ooe_block_arg(z: 0, a: 3);
        }

        fn ooe_block_arg(mut z: i32, mut a: i32) {

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;
            return a == 4 && res == 12 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int ooe_block_arg_MbR9(int z, int a)
{
    int* x;
    int _0;
    const int res = (_0 = (x = &((z ? z : a)), (*x)++), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return ooe_block_arg_MbR9(0, 3);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            return ooe_block_arg(z: 0, a: 3);
        }

        fn ooe_block_arg(mut z: i32, mut a: i32) {

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };
            return a == 4 && res == 9 ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int ooe_block_arg_MbR9(int z, int a)
{
    int _0;
    int* x;
    const int res = (_0 = a, (_0 * (x = &((z ? z : a)), (*x)++)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return ooe_block_arg_MbR9(0, 3);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello) {
                let res = hello * { ref x = z || a; x++ };
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ooe_closure_fKX6Vt92tdh
                                #define DEF_ooe_closure_fKX6Vt92tdh
inline static int ooe_closure_fKX6(/*7:7*/ int& hello, /*7:6*/ int& a, /*7:6*/ int& z)
{
    int _0;
    int* x;
    const int res = (_0 = hello, (_0 * (x = &((z ? z : a)), (*x)++)));
    hello += 10;
    return res;
}
                                #endif

static int test_MbR9(/*3:1*/ int& a, /*3:2*/ int& z)
{
    const int res = ooe_closure_fKX6(a, a, z);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = hello * { ref x = z || a; x++ };
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int ooe_closure_MbR9(/*7:7*/ int& hello, /*7:6*/ int& a, /*7:6*/ int& z)
{
    int _0;
    int* x;
    const int res = (_0 = hello, (_0 * (x = &((z ? z : a)), (*x)++)));
    hello += 10;
    return res;
}

static int test_MbR9(/*3:1*/ int& a, /*3:2*/ int& z)
{
    const int res = ooe_closure_MbR9(a, a, z);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello) {
                let res = hello * { ref x = z || a; x++ };
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:3*/ int& a, /*3:2*/ int& z)
{
    int res_1;
    int _0;
    int* x;
    const int /*res*/ res = (res_1 = (_0 = a, (_0 * (x = &((z ? z : a)), (*x)++))), (a += 10), res_1);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = hello * { ref x = z || a; x++ };
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:3*/ int& a, /*3:2*/ int& z)
{
    int res_1;
    int _0;
    int* x;
    const int /*res*/ res = (res_1 = (_0 = a, (_0 * (x = &((z ? z : a)), (*x)++))), (a += 10), res_1);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello) {
                let res = mul({ ref x = z || a; x++ }, hello);
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int mul_MbR9(const int a, const int b)
{
    return a * b;
}

                                #ifndef DEF_ooe_closure_KDdgKSPL9Pk
                                #define DEF_ooe_closure_KDdgKSPL9Pk
inline static int ooe_closure_KDdg(/*7:7*/ int& hello, /*7:6*/ int& a, /*7:6*/ int& z)
{
    int* x;
    int _0;
    const int res = (_0 = (x = &((z ? z : a)), (*x)++), mul_MbR9(_0, hello));
    hello += 10;
    return res;
}
                                #endif

static int test_MbR9(/*3:1*/ int& a, /*3:2*/ int& z)
{
    const int res = ooe_closure_KDdg(a, a, z);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = mul({ ref x = z || a; x++ }, hello);
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int mul_MbR9(const int a, const int b)
{
    return a * b;
}

static int ooe_closure_MbR9(/*7:7*/ int& hello, /*7:6*/ int& a, /*7:6*/ int& z)
{
    int* x;
    int _0;
    const int res = (_0 = (x = &((z ? z : a)), (*x)++), mul_MbR9(_0, hello));
    hello += 10;
    return res;
}

static int test_MbR9(/*3:1*/ int& a, /*3:2*/ int& z)
{
    const int res = ooe_closure_MbR9(a, a, z);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello) {
                let res = mul({ ref x = z || a; x++ }, hello);
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int mul_MbR9(const int a, const int b)
{
    return a * b;
}

static int test_MbR9(/*3:3*/ int& a, /*3:2*/ int& z)
{
    int res_1;
    int* x;
    int _0;
    const int /*res*/ res = (res_1 = (_0 = (x = &((z ? z : a)), (*x)++), mul_MbR9(_0, a)), (a += 10), res_1);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = mul({ ref x = z || a; x++ }, hello);
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int mul_MbR9(const int a, const int b)
{
    return a * b;
}

static int test_MbR9(/*3:3*/ int& a, /*3:2*/ int& z)
{
    int res_1;
    int* x;
    int _0;
    const int /*res*/ res = (res_1 = (_0 = (x = &((z ? z : a)), (*x)++), mul_MbR9(_0, a)), (a += 10), res_1);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_MbR9(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        inline fn uses_implicit_inside() {
            inline fn uses_implicit(implicit ref sum: i32) {
                return sum++;
            }

            return uses_implicit;
        }


        // N_BckMustSeq         
        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int inline_implicit_from_defarg_MbR9(const int hello, const int defaulted_argument)
{
    return hello * defaulted_argument;
}

int fu_MAIN()
{
    int sum = 3;
    int _0;
    const int res = (_0 = sum, inline_implicit_from_defarg_MbR9(_0, sum++));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_BckMustSeq

========

        inline fn uses_implicit_inside() {
            inline fn uses_implicit(implicit ref sum: i32) {
                return sum++;
            }

            return uses_implicit;
        }


        inline                  
        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int hello;
    int defaulted_argument;
    const int res = (hello = sum, defaulted_argument = sum++, (hello * defaulted_argument));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        inline fn uses_implicit(implicit ref sum: i32) = sum++;
        inline fn uses_implicit_inside() = uses_implicit;


        // N_BckMustSeq         
        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)
            hello * defaulted_argument;

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(hello: sum);
            return sum == 4 && res == 12 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int inline_implicit_from_defarg_MbR9(const int defaulted_argument, const int hello)
{
    return hello * defaulted_argument;
}

int fu_MAIN()
{
    int sum = 3;
    int _0;
    const int res = (_0 = sum++, inline_implicit_from_defarg_MbR9(_0, sum));
    if ((sum == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_BckMustSeq

========

        inline fn uses_implicit(implicit ref sum: i32) = sum++;
        inline fn uses_implicit_inside() = uses_implicit;


        inline                  
        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)
            hello * defaulted_argument;

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(hello: sum);
            return sum == 4 && res == 12 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int defaulted_argument;
    int hello;
    const int res = (defaulted_argument = sum++, hello = sum, (hello * defaulted_argument));
    if ((sum == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            struct Type { canon: string };

            mut _lookups: int;
            mut _t_bool: Type;

            fn t_bool() {
                return _t_bool ||= Scope_lookupType("bool");
            }

            fn Scope_lookupType(canon: string) {
                _lookups++;
                return Type(:canon);
            }

            fn check(a, b = t_bool) {
                return a.canon.len + b.canon.len;
            }

            return check(t_bool) + _lookups - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Type_KHQj;

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef STR_1cD5td1eMvl
                                #define STR_1cD5td1eMvl
static const fu::str str_1cD5td1eMvl fu_INIT_PRIORITY(1001) { "bool"_fu };
                                #endif

#ifndef fu_NO_fdefs

static Type_KHQj Scope_lookupType_MbR9(/*3:3*/ fu::vec_range<char> canon, /*2:2*/ int& _lookups)
{
    _lookups++;
    return Type_KHQj { fu::str(canon) };
}

static const Type_KHQj& t_bool_kGbb(/*3:1*/ int& _lookups, /*3:3*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_MbR9(str_1cD5td1eMvl, _lookups));
}

static const Type_KHQj& t_bool_GL0m(/*3:1*/ int& _lookups, /*3:3*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_MbR9(str_1cD5td1eMvl, _lookups));
}

                                #ifndef DEF_check_bWwDY7JMxg8
                                #define DEF_check_bWwDY7JMxg8
inline static int check_bWwD(/*3:3*/ const Type_KHQj& a, /*3:3*/ const Type_KHQj& b)
{
    return a.canon.size() + b.canon.size();
}
                                #endif

int fu_MAIN()
{
    int _lookups {};
    Type_KHQj _t_bool {};
    Type_KHQj _0 {};
    int _1;
    return (_1 = (_0 = Type_KHQj(/*bck:pra 2*/ t_bool_kGbb(_lookups, _t_bool)), check_bWwD(static_cast<Type_KHQj&&>(_0), t_bool_GL0m(_lookups, _t_bool))), (_1 + _lookups)) - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn main() {
            struct Type { canon: string };

            mut _lookups: int;
            mut _t_bool: Type;

            fn t_bool() {
                return _t_bool ||= Scope_lookupType("bool");
            }

            fn Scope_lookupType(canon: string) {
                _lookups++;
                return Type(:canon);
            }

            fn check(a: Type, b = t_bool) {
                return a.canon.len + b.canon.len;
            }

            return check(t_bool) + _lookups - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Type_KHQj;

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef STR_1cD5td1eMvl
                                #define STR_1cD5td1eMvl
static const fu::str str_1cD5td1eMvl fu_INIT_PRIORITY(1001) { "bool"_fu };
                                #endif

#ifndef fu_NO_fdefs

static Type_KHQj Scope_lookupType_MbR9(/*3:3*/ fu::vec_range<char> canon, /*2:2*/ int& _lookups)
{
    _lookups++;
    return Type_KHQj { fu::str(canon) };
}

static const Type_KHQj& t_bool_kGbb(/*3:1*/ int& _lookups, /*3:3*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_MbR9(str_1cD5td1eMvl, _lookups));
}

static const Type_KHQj& t_bool_GL0m(/*3:1*/ int& _lookups, /*3:3*/ Type_KHQj& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_MbR9(str_1cD5td1eMvl, _lookups));
}

static int check_MbR9(/*3:3*/ const Type_KHQj& a, /*3:3*/ const Type_KHQj& b)
{
    return a.canon.size() + b.canon.size();
}

int fu_MAIN()
{
    int _lookups {};
    Type_KHQj _t_bool {};
    Type_KHQj _0 {};
    int _1;
    return (_1 = (_0 = Type_KHQj(/*bck:pra 2*/ t_bool_kGbb(_lookups, _t_bool)), check_MbR9(static_cast<Type_KHQj&&>(_0), t_bool_GL0m(_lookups, _t_bool))), (_1 + _lookups)) - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_BckMustSeq

========

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;
            woot(hello: |one| res += one);
            woot(world: |two| res += two);
            return res - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_5aAgpq5aUK5
                                #define DEF_hello_5aAgpq5aUK5
inline static int hello_5aAg(const int one, /*3:3*/ int& res)
{
    return (res += one);
}
                                #endif

                                #ifndef DEF_woot_vAnwI5wjki5
                                #define DEF_woot_vAnwI5wjki5
inline static void woot_vAnw(/*7:7*/ int& res)
{
    hello_5aAg(1, res);
}
                                #endif

                                #ifndef DEF_world_5aAgpq5aUK5
                                #define DEF_world_5aAgpq5aUK5
inline static int world_5aAg(const int two, /*3:3*/ int& res)
{
    return (res += two);
}
                                #endif

                                #ifndef DEF_woot_avUlrmoaSp1
                                #define DEF_woot_avUlrmoaSp1
inline static void woot_avUl(/*7:7*/ int& res)
{
    world_5aAg(2, res);
}
                                #endif

int fu_MAIN()
{
    int res = 0;
    woot_vAnw(res);
    woot_avUl(res);
    return res - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;

            woot(hello: |one| res += one, hello: |one| res += one); 
            return res - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:13+4[0m:

[2m      |             mut res = 0;[0m
[2m      | [0m
[2m   10 | [0m            [31;1mwoot[0m(hello: |one| res += one, hello: |one| res += one); 
[2m      |             return res - 3;[0m
[2m      |         }[0m

	Bad call to [94;1mwoot[0m with args ([35;3mnocopy[0m [35;3m@130[0m, [35;3mnocopy[0m [35;3m@140[0m): 

	[35;3mtemplate[0m [94;1mwoot[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mwoot[0m(hello!?, world!?) {

	    Duplicate :named arguments: [31;3marg[0m [31;1mhello[0m explicitly provided 2 times.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;

            woot(hello: |one| res += one, world: |two| res += two); 
            return res - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_5aAgpq5aUK5
                                #define DEF_hello_5aAgpq5aUK5
inline static int hello_5aAg(const int one, /*3:3*/ int& res)
{
    return (res += one);
}
                                #endif

                                #ifndef DEF_world_5aAgpq5aUK5
                                #define DEF_world_5aAgpq5aUK5
inline static int world_5aAg(const int two, /*3:3*/ int& res)
{
    return (res += two);
}
                                #endif

                                #ifndef DEF_woot_VkZUWh6hgHd
                                #define DEF_woot_VkZUWh6hgHd
inline static void woot_VkZU(/*7:7*/ int& res)
{
    hello_5aAg(1, res);
    world_5aAg(2, res);
}
                                #endif

int fu_MAIN()
{
    int res = 0;
    woot_VkZU(res);
    return res - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Node { bullet?: byte; pointer: int }

        fn skipNonTrailingDefaultedStructField() {
            mut bullet = byte();        
            return Node(:bullet);       
        }

        fn main() skipNonTrailingDefaultedStructField.pointer;

---- <fail> ----
[2m[0m_0[2m.fu 6:20+4[0m:

[2m      |         fn skipNonTrailingDefaultedStructField() {[0m
[2m      |             mut bullet = byte();        [0m
[2m    6 | [0m            return [31;1mNode[0m(:bullet);       
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1mNode[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mbyte[0m): 

	[35;3mtype[0m [94;1mNode[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Node { bullet?: byte; pointer: int }

	    Missing required argument: [35;3marg[0m [94;1mpointer[0m

        Solving [35;3mfn[0m [94;1mskipNonTrailingDefaultedStructField[0m at [2m4:12+35[0m

========

        struct Node { bullet?: byte; pointer: int }

        fn skipNonTrailingDefaultedStructField() {
            mut bullet = byte();        
            return Node([], :bullet);   
        }

        fn main() skipNonTrailingDefaultedStructField.pointer;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Node_GOOy;

                                #ifndef DEF_Node_GOOyEyn2aEh
                                #define DEF_Node_GOOyEyn2aEh
struct Node_GOOy
{
                                // shape_hash:    ef89e70dd45fd8dc
                                // non_triv_mask: 0000000000000000
    char bullet;
    int pointer;
    explicit operator bool() const noexcept
    {
        return false
            || bullet
            || pointer
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Node_GOOy skipNonTrailingDefaultedStructField_MbR9()
{
    const char bullet {};
    return Node_GOOy { bullet, 0 };
}

int fu_MAIN()
{
    return skipNonTrailingDefaultedStructField_MbR9().pointer;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            fn approx_p(a: f32, b = a)
                2 * f32.PI * sqrt(0.5 * (a * a + b * b));

            assert(approx_p(10) == approx_p(10, 10));
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cmath>
#include <math.h>
#include <fu/assert.h>


#ifndef fu_NO_fdefs

static float approx_p_MbR9(const float a, const float b)
{
    return (2.0f * static_cast<float>(M_PI)) * std::sqrt((0.5f * ((a * a) + (b * b))));
}

int fu_MAIN()
{
    float __def_arg_ref;
    float _0;
    fu_ASSERT(((_0 = (__def_arg_ref = 10.0f), approx_p_MbR9(_0, __def_arg_ref)) == approx_p_MbR9(10.0f, 10.0f)));
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        let s = 7;
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int s = 7;
    if (s)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let s = 7;
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let s = 0;
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int s = 0;
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        let s = 0;
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let s = "hello";
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ s = "hello"_view;
    if (s)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let s = "hello";
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let s = "";
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ s = ""_view;
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        let s = "";
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let s = [ 4 ];
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> s = fu::vec<int> {{ 4 }};
    if (s)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let s = [ 4 ];
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedArrlit, N_UnusedLet

========

        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> s = fu::vec<int> {{ 4 }};
    s.pop();
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct S_ra9A;

                                #ifndef DEF_S_ra9ARHSCQs6
                                #define DEF_S_ra9ARHSCQs6
struct S_ra9A
{
                                // shape_hash:    bf43fbd9c0e2e4b4
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const S_ra9A s = S_ra9A { 1 };
    if (s)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct S_ra9A;

                                #ifndef DEF_S_ra9ARHSCQs6
                                #define DEF_S_ra9ARHSCQs6
struct S_ra9A
{
                                // shape_hash:    bf43fbd9c0e2e4b4
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const S_ra9A s {};
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        mut sum = 0;
        :OUTER for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    // Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int y = 1; y < 10; y++)
    { {
        sum += (y * 10);
        for (int x = 1; x < 10; x++)
        {
            sum += x;
            if (y == 1)
                goto BL_2;
            else if (x == 2)
                goto LL_1;

        };
      } BL_2:;
    } LL_1:;

    return sum - 34;
}

#endif

int main() { return fu_MAIN(); }

========

        fn for_fn(mut i: i32, n: i32, visit)
            for (; i < n; i++)
                visit(i);

        mut sum = 0;
        :OUTER for_fn(1, 10): |y| // same as above but via helper fn
        {
            sum += y * 10; // 10, 20
            for_fn(1, 10): |x|
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    // Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;

    { {
        int i = 1;
        const int n = 10;
        for (; i < n; i++)
        { {
            const int /*i*/ y = i;
            sum += (y * 10);
            int i_1 = 1;
            const int n_1 = 10;
            for (; i_1 < n_1; i_1++)
            {
                const int /*i_1*/ x = i_1;
                sum += x;
                if (y == 1)
                    goto BL_3;
                else if (x == 2)
                    goto BL_1;

            };
          } BL_3:;
        };
      } BL_1:;
    };
    return sum - 34;
}

#endif

int main() { return fu_MAIN(); }

========

        fn twice(what)
            for (mut i = 0; i < 2; i++)
                what(i);

        mut x = 0;
        :TWICE twice: |i| {
            x += i;
            if (!x++) continue :TWICE;
        }

        return x - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___Epmqu7ab17f
                                #define DEF___Epmqu7ab17f
inline static void _Epmq(const int i, /*3:3*/ int& x)
{
    x += i;
    x++;
}
                                #endif

                                #ifndef DEF_twice_Qb3W5nsVUki
                                #define DEF_twice_Qb3W5nsVUki
inline static void twice_Qb3W(/*3:3*/ int& x)
{
    for (int i = 0; i < 2; i++)
        _Epmq(i, x);

}
                                #endif

int fu_MAIN()
{
    int x = 0;
    twice_Qb3W(x);
    return x - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedIfElse

========

        fn twice(what)
            for (mut i = 0; i < 2; i++)
                what(i);

        mut x = 0;
        :TWICE twice: |i: int| {
            x += i;
            if (!x++) continue :TWICE;
        }

        return x - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___Epmqu7ab17f
                                #define DEF___Epmqu7ab17f
inline static void _Epmq(const int i, /*3:3*/ int& x)
{
    x += i;
    x++;
}
                                #endif

                                #ifndef DEF_twice_Qb3W5nsVUki
                                #define DEF_twice_Qb3W5nsVUki
inline static void twice_Qb3W(/*3:3*/ int& x)
{
    for (int i = 0; i < 2; i++)
        _Epmq(i, x);

}
                                #endif

int fu_MAIN()
{
    int x = 0;
    twice_Qb3W(x);
    return x - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedIfElse

========

        mut sum = 0;
        :OUTER for (mut x = 0;; x++) {
            for (mut y = 0; y < x; y++) {
                if (y & 1 && !(x & 1))
                    continue :OUTER;                            // Goto

                sum += x;
            }

            sum += x * 1000 + 100;
            if (x > 1)                                          // EXPECT break;
                break; // anon
        }

        // x=0:           + 0100
        // x=1: 1         + 1100
        // x=2: 2
        // x=3: 3 + 3 + 3 + 3100 break
        return sum - 4312;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int x = 0; ; x++)
    { {
        for (int y = 0; y < x; y++)
        {
            if ((y & 1) && !(x & 1))
                goto BL_2;
            else
                sum += x;

        };
        sum += ((x * 1000) + 100);
        if (x > 1)
            break;

      } BL_2:;
    };
    return sum - 4312;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref sum: i32) {
            :FIRST {
                if (sum & 1)
                    break:
                        FIRST;
                sum++;
            }
            :SECOND {
                if (sum & 1)
                    break:

                        FIRST;      
                sum++;

                if (sum & 2)
                    break:
                        SECOND;
                sum++;
            }
        }

        fn main() {
            mut sum = 0;
            test(sum);
            return sum - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:21+5[0m:

[2m      |             :SECOND {[0m
[2m      |                 if (sum & 1)[0m
[2m   11 | [0m                    [31;1mbreak[0m:
[2m      | [0m
[2m      |                         FIRST;      [0m

	No label [31;1mFIRST[0m in scope.

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(ref sum: i32) {
            :FIRST {
                if (sum & 1)
                    break:
                        FIRST;
                sum++;
            }
            :SECOND {
                if (sum & 1)
                    break:

                        SECOND;     
                sum++;

                if (sum & 2)
                    break:
                        SECOND;
                sum++;
            }
        }

        fn main() {
            mut sum = 0;
            test(sum);
            return sum - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ int& sum)
{
    if (!(sum & 1))
        sum++;

    if (!(sum & 1))
    {
        sum++;
        if (!(sum & 2))
            sum++;

    };
}

int fu_MAIN()
{
    int sum = 0;
    test_MbR9(sum);
    return sum - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        lax let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::view<char> /*y|x*/ w = (x ? x : y);
    if (w == "hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        lax let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    if (x == "hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::view<char> /*y|x*/ w = (!x ? x : y);
    if (w == "world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ y = "world"_view;
    if (y == "world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let x = "hello";
        lax let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::view<char> _0 {};
    fu::view<char> /*y|x|zeroes*/ w = ((_0.ptr_reassign((3 ? x : fu::view<char>{}))) ? _0 : y);
    if (w == "hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        lax let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    if (x == "hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y;

        return w == "world" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::vec<int> arr {};
    fu::view<char> _0 {};
    fu::view<char> /*y|x|zeroes*/ w = ((_0.ptr_reassign((arr ? x : fu::view<char>{}))) ? _0 : y);
    if (w == "world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::vec<int> arr {};
    fu::view<char> _0 {};
    fu::view<char> /*y|x|zeroes*/ w = ((_0.ptr_reassign((arr ? x : fu::view<char>{}))) ? _0 : y ? y : fu::fail(fu::str("Nope."_fu)));
    if (w == "world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ x = "hello"_view;
    fu::view<char> /*static*/ y = "world"_view;
    fu::vec<int> arr {};
    fu::view<char> _0 {};
    fu::view<char> /*y|x|zeroes*/ w = ((_0.ptr_reassign((arr ? x : fu::view<char>{}))) ? _0 : y);
    if (w == "world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn what(a: i32) {
            a == 2 || a & 1 || throw("what1");
            a  > 1 && a & 1 && throw("what2");
            a  > 0 && a & 3 || throw("what3");
            return a + 4;
        }
        fn main() 1.what - 2.what + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int what_MbR9(const int a)
{
    if ((a == 2) || (a & 1))
    {
        if ((a > 1) && (a & 1))
            fu::fail(fu::str("what2"_fu));
        else if ((a > 0) && (a & 3))
            return a + 4;
        else
            fu::fail(fu::str("what3"_fu));

    }
    else
        fu::fail(fu::str("what1"_fu));

}

int fu_MAIN()
{
    return (what_MbR9(1) - what_MbR9(2)) + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn gen(len: i32) {
            mut res: i32[];
            for (mut i = 0; i < len; i++) res ~= i;
            return res;
        }
        fn test(len: i32) {
            let x = [-5, +5];
            let y = len.gen && x;
            return x[y.len / 2];
        }
        fn main() 0.test + 1.test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> gen_MbR9(const int len)
{
    /*MOV*/ fu::vec<int> res {};
    for (int i = 0; i < len; i++)
        res += i;

    return /*NRVO*/ res;
}

static int test_MbR9(const int len)
{
    fu::vec<int> x = fu::vec<int> {{ -5, +5 }};
    fu::view<int> /*x|zeroes*/ y = (gen_MbR9(len) ? x : fu::view<int>{});
    return x[(y.size() / 2)];
}

int fu_MAIN()
{
    return test_MbR9(0) + test_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;

        fn test(ref init: string, ref annot: string)
            init.is_mutref && annot ||
            init.is_never  && annot || throw("noreturn");

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot).len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static bool is_mutref_MbR9(/*1:1*/ fu::view<char> t)
{
    return t.size() == 6;
}

static bool is_never_MbR9(/*1:1*/ fu::view<char> t)
{
    return t.size() == 5;
}

static fu::view<char> test_kGbb(/*3:3*/ fu::view<char> init, /*3:3*/ fu::view<char> annot)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((is_mutref_MbR9(init) ? annot : fu::view<char>{}))) ? _0 : (_0.ptr_reassign((is_never_MbR9(init) ? annot : fu::view<char>{}))) ? _0 : fu::fail(fu::str("noreturn"_fu));
}

int fu_MAIN()
{
    fu::view<char> /*static*/ annot = "hey!"_view;
    fu::view<char> /*static*/ init = "woot!"_view;
    return test_kGbb(init, annot).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(mut init: string) {
            init.len && init || throw("noreturn");
            return init.len;
        }

        fn main() test("woot!") - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view<char> init)
{
    if (init.size() && init)
        return init.size();
    else
        fu::fail(fu::str("noreturn"_fu));

}

int fu_MAIN()
{
    return test_MbR9("woot!"_view) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;
        let F_ARG = 1;

        fn test(ref init: string, ref annot: string, mut flags: i32) {
            init.is_mutref  || init.is_never  && annot
                            || !init && flags & F_ARG
                            || throw("noreturn");
            return flags;
        }

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot, 0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


                                #ifndef DEF_F_ARG
                                #define DEF_F_ARG
inline constexpr int F_ARG = 1;
                                #endif

#ifndef fu_NO_fdefs

static bool is_mutref_MbR9(/*1:1*/ fu::view<char> t)
{
    return t.size() == 6;
}

static bool is_never_MbR9(/*1:1*/ fu::view<char> t)
{
    return t.size() == 5;
}

static int test_MbR9(/*7:7*/ fu::view<char> init, /*7:7*/ fu::view<char> annot, const int flags)
{
    if (is_mutref_MbR9(init) || (is_never_MbR9(init) && annot) || (!init && (flags & F_ARG)))
        return flags;
    else
        fu::fail(fu::str("noreturn"_fu));

}

int fu_MAIN()
{
    fu::view<char> /*static*/ annot = "hey!"_view;
    fu::view<char> /*static*/ init = "woot!"_view;
    return test_MbR9(init, annot, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn a(a)  a ?  a : [];   // ifs used cons-type to seed alt-type
        fn b(b) !b ? [] : b;    //  which works for 'a', but not for 'b'.
        fn main() 1.a - 1.b;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_a_4OsUpBs45vb
                                #define DEF_a_4OsUpBs45vb
inline static int a_4OsU(/*1:1*/ const int a)
{
    if (a)
        return a;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_b_OdUjUmnnb21
                                #define DEF_b_OdUjUmnnb21
inline static int b_OdUj(/*1:1*/ const int b)
{
    if (!b)
        return 0;
    else
        return b;

}
                                #endif

int fu_MAIN()
{
    return a_4OsU(1) - b_OdUj(1);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { i: i32 };
        fn is_mutref (t: Type) !!(t.i & 3);
        fn is_ref    (t: Type) !!(t.i & 1);
        fn clear_refs(t: Type) Type(t.i &~ 3);

        fn tryClearRefs(t: Type, mutref?: bool): Type =     // type-hints vs type-assertions:
            (mutref ? t.is_mutref : t.is_ref)               //  solveBlocks used within '&&' and '?'
                && clear_refs(t);                           //   so the '?' complained 'bool' doesnt assign to 'Type'

        fn main() {
            let a = tryClearRefs(Type(6), true);
            let b = tryClearRefs(Type(6), false);
            return a.i + b.i - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_ybuf;

                                #ifndef DEF_Type_ybufcqpknV3
                                #define DEF_Type_ybufcqpknV3
struct Type_ybuf
{
                                // shape_hash:    c84f6f3947ac8bd2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool is_mutref_MbR9(/*1:1*/ const Type_ybuf& t)
{
    return !!(t.i & 3);
}

static bool is_ref_MbR9(/*1:1*/ const Type_ybuf& t)
{
    return !!(t.i & 1);
}

static Type_ybuf clear_refs_MbR9(/*1:1*/ const Type_ybuf& t)
{
    return Type_ybuf { (t.i & ~3) };
}

static Type_ybuf tryClearRefs_MbR9(/*3:3*/ const Type_ybuf& t, const bool mutref)
{
    if ((mutref ? is_mutref_MbR9(t) : is_ref_MbR9(t)))
        return clear_refs_MbR9(t);
    else
    {
        return Type_ybuf{};
    };
}

int fu_MAIN()
{
    const Type_ybuf a = tryClearRefs_MbR9(Type_ybuf { 6 }, true);
    const Type_ybuf b = tryClearRefs_MbR9(Type_ybuf { 6 }, false);
    return (a.i + b.i) - 4;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ambig_or(x: i32, y: f32)
            "Hello: " ~
       // So it happened that at some point I had an 'a || b'
                    (x || y)                         //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.

        fn main() {
            mut res = ambig_or(1, 2);
            return res == "Hello: 1" ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:24+2[0m:

[2m      |             "Hello: " ~[0m
[2m      |        // So it happened that at some point I had an 'a || b'[0m
[2m    5 | [0m                    (x [31;1m||[0m y)                         //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
[2m      |                 ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.[0m
[2m      | [0m

	Ambiguous ||, incompatible operands in a non-bool context: [35;3mi32[0m || [35;3mf32[0m

        Solving [35;3mfn[0m [94;1mambig_or[0m([35;3mi32[0m, [35;3mf32[0m) at [2m2:12+8[0m

========

        fn ambig_or(x: i32, y: f32)
            "Hello: " ~
       //  where a and b were of the same type used in string concat like this,
                    (x || y.i32)                     //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.

        fn main() {
            mut res = ambig_or(1, 2);
            return res == "Hello: 1" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str ambig_or_MbR9(const int x, const float y)
{
    return x7E_rA00("Hello: "_view, fu::i64dec((x ? x : int(y))));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = ambig_or_MbR9(1, 2.0f);
    if (res == "Hello: 1"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn unambig_or(b: bool, i: i32, f: f32)        // But currently the thinking is that so long as one operand is a bool
            i || f || b;                              //  the whole thing should weaken to (!!a || !!b) instead of erroring out.

        fn main() = unambig_or(false, 0, 0).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static bool unambig_or_MbR9(const bool b, const int i, const float f)
{
    return i || f || b;
}

int fu_MAIN()
{
    return int(unambig_or_MbR9(false, 0, 0.0f));
}

#endif

int main() { return fu_MAIN(); }

========

        fn unambig_or(b: bool, i: i32, f: f32)  
            b || i || f;                              //  the whole thing should weaken to (!!a || !!b) instead of erroring out.

        fn main() = unambig_or(false, 0, 0).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static bool unambig_or_MbR9(const bool b, const int i, const float f)
{
    return b || i || f;
}

int fu_MAIN()
{
    return int(unambig_or_MbR9(false, 0, 0.0f));
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { items: Node[] };

        fn isFieldChain(arg: Node) {
            if (arg.items.len > 1)
                return false;

            return !arg.items || isFieldChain(arg.items[0]);
        }

        fn main() {
            let empty       = Node();
            let chain       = Node([ Node ]);
            let not_chain   = Node([ Node, Node ]);

            return empty.isFieldChain
                && chain.isFieldChain
                && !not_chain.isFieldChain ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct Node_zYlo;
static bool isFieldChain_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool isFieldChain_MbR9(/*1:1*/ const Node_zYlo& arg)
{
    if (arg.items.size() > 1)
        return false;
    else
        return !arg.items || isFieldChain_MbR9(arg.items[0]);

}

int fu_MAIN()
{
    Node_zYlo empty {};
    Node_zYlo chain = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{} }} };
    Node_zYlo not_chain = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} };
    if (isFieldChain_MbR9(empty) && isFieldChain_MbR9(chain) && !isFieldChain_MbR9(not_chain))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

========

        fn underconcat(dedupe: string, sighash: string)
            dedupe && sighash
                ? dedupe ~ '_' ~ sighash
                : dedupe || sighash;

        fn main() {
            let a   = underconcat("a", "");
            let b   = underconcat("", "b");
            let c   = underconcat("", "");
            let ab  = underconcat("a", "b");

            let res = a ~ "," ~ b ~ "," ~ c ~ "," ~ ab;
            return res == "a,b,,a_b" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_ujDub247BYe
                                #define STR_ujDub247BYe
static const fu::str str_ujDub247BYe fu_INIT_PRIORITY(1001) { "a"_fu };
                                #endif

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

                                #ifndef STR_GURXpaBTk07
                                #define STR_GURXpaBTk07
static const fu::str str_GURXpaBTk07 fu_INIT_PRIORITY(1001) { "b"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str underconcat_MbR9(/*3:3*/ fu::vec_range<char> dedupe, /*3:3*/ fu::vec_range<char> sighash)
{
    if (dedupe && sighash)
        return (dedupe + '_') + sighash;
    else
        return fu::str((dedupe ? dedupe : sighash));

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str a = underconcat_MbR9(str_ujDub247BYe, str_00000000000);
    fu::str b = underconcat_MbR9(str_00000000000, str_GURXpaBTk07);
    fu::str c = underconcat_MbR9(str_00000000000, str_00000000000);
    fu::str ab = underconcat_MbR9(str_ujDub247BYe, str_GURXpaBTk07);
    fu::str res = ((((((a + ","_view) + b) + ","_view) + c) + ","_view) + ab);
    if (res == "a,b,,a_b"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn underconcat(dedupe: string, sighash: string)
            dedupe && sighash
                ? dedupe ~ '_' ~ sighash
                : dedupe || sighash;

        fn main() {
            let a   = underconcat("a", "");
            let b   = underconcat("", "b");
            let c   = underconcat("", "");
            let ab  = underconcat("a", "b");

            let res = a ~ "," ~ b ~ "," ~ c ~ "," ~ ab;
            return res == "a,b,,a_b" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_ujDub247BYe
                                #define STR_ujDub247BYe
static const fu::str str_ujDub247BYe fu_INIT_PRIORITY(1001) { "a"_fu };
                                #endif

                                #ifndef STR_GURXpaBTk07
                                #define STR_GURXpaBTk07
static const fu::str str_GURXpaBTk07 fu_INIT_PRIORITY(1001) { "b"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str underconcat_MbR9(/*3:3*/ fu::vec_range<char> dedupe, /*3:3*/ fu::vec_range<char> sighash)
{
    if (dedupe && sighash)
        return (dedupe + '_') + sighash;
    else
        return fu::str((dedupe ? dedupe : sighash));

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str a = underconcat_MbR9(str_ujDub247BYe, (*(fu::str*)fu::NIL));
    fu::str b = underconcat_MbR9((*(fu::str*)fu::NIL), str_GURXpaBTk07);
    fu::str c = underconcat_MbR9((*(fu::str*)fu::NIL), (*(fu::str*)fu::NIL));
    fu::str ab = underconcat_MbR9(str_ujDub247BYe, str_GURXpaBTk07);
    fu::str res = ((((((a + ","_view) + b) + ","_view) + c) + ","_view) + ab);
    if (res == "a,b,,a_b"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========


        inline                  
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x;
    int x_1;
    if ((x = 2, (x ? fu::vec<int> {{ x, x }} : fu::vec<int>{})) && !(x_1 = 0, (x_1 ? fu::vec<int> {{ x_1, x_1 }} : fu::vec<int>{})))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        inline                  
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x;
    if ((x = 2, fu::vec<int> {{ x, x }}) && !fu::vec<int>{})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========


        noinline                
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_twiceUnlessEmpty_uQXAnEqNO22
                                #define DEF_twiceUnlessEmpty_uQXAnEqNO22
inline static fu::vec<int> twiceUnlessEmpty_uQXA(const int x)
{
    if (x)
    {
        return fu::vec<int> {{ x, x }};
    }
    else
    {
        return fu::vec<int>{};
    };
}
                                #endif

int fu_MAIN()
{
    if (twiceUnlessEmpty_uQXA(2) && !twiceUnlessEmpty_uQXA(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(ref str) {
            str ~= "world";
  
        }

        fn main() {
            mut str = "hello, ";
            if (!hello(str)) str ~= "!";
            return str.len - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:17+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut str = "hello, ";[0m
[2m    9 | [0m            if ([31;1m![0mhello(str)) str ~= "!";
[2m      |             return str.len - 13;[0m
[2m      |         }[0m

	Condition is an always-empty [35;3mnocopy[0m [35;3mvoid[0m, returned from [35;3mfn[0m [94;1mhello[0m at [2m2:12+5[0m:

[2m      | [0m
[2m    2 | [0m        fn [31;1mhello[0m(ref str) {
[2m      |             str ~= "world";[0m
[2m      |   [0m


	If this is expected, use [94;1m!=[0m [35;3m[][0m to suppress this warning.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        fn hello(ref str) {
            str ~= "world";

            return str.len & 1;                     
        }

        fn main() {
            mut str = "hello, ";
            if (!hello(str)) str ~= "!";
            return str.len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_QrKMRcUOqHg
                                #define DEF_hello_QrKMRcUOqHg
inline static int hello_QrKM(/*1:1*/ fu::vec_range_mut<char> str)
{
    str += "world"_view;
    return str.size() & 1;
}
                                #endif

int fu_MAIN()
{
    fu::str str = fu::str("hello, "_fu);
    if (!hello_QrKM(str))
        str += "!"_view;

    return str.size() - 13;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32) {

            if (x > 1) let y = 20;      

            return x + y;
        }

        fn main() test(7) - 27;

---- <fail> ----
[2m[0m_0[2m.fu 6:24+1[0m:

[2m      |             if (x > 1) let y = 20;      [0m
[2m      | [0m
[2m    6 | [0m            return x + [31;1my[0m;
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1my[0m: [94;1my[0m is not defined here.

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(x: i32) {

            let y = x > 1 && 20;        

            return x + y;
        }

        fn main() test(7) - 27;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    const int y = ((x > 1) ? 20 : 0);
    return x + y;
}

int fu_MAIN()
{
    return test_MbR9(7) - 27;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32) {

            if (x > 1)
            let y = 20;                 

            return x + y;
        }

        fn main() test(7) - 27;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:13+3[0m:

[2m      | [0m
[2m      |             if (x > 1)[0m
[2m    5 | [0m            [31;1mlet[0m y = 20;                 
[2m      | [0m
[2m      |             return x + y;[0m

	Misleading indent at [31;1mlet[0m: expected more than 13, got 13.

========

        using flags State: u8 { ReadEOF; WriteEOF; WantsRead; WantsWrite }

        fn mustClose(state: State)
            !!(state & ReadEOF
                ? state & WriteEOF || !(state & WantsWrite)
                : state & WantsRead);

        fn main() = State().mustClose.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 State_Ph5I;

                                #ifndef DEF_State_Ph5I
                                #define DEF_State_Ph5I
inline constexpr State_Ph5I State_Ph5I_ReadEOF = State_Ph5I(1u);
inline constexpr State_Ph5I State_Ph5I_WriteEOF = State_Ph5I(2u);
inline constexpr State_Ph5I State_Ph5I_WantsRead = State_Ph5I(4u);
inline constexpr State_Ph5I State_Ph5I_WantsWrite = State_Ph5I(8u);

inline constexpr State_Ph5I MASK_State_Ph5I
    = State_Ph5I_ReadEOF
    | State_Ph5I_WriteEOF
    | State_Ph5I_WantsRead
    | State_Ph5I_WantsWrite;
                                #endif

#ifndef fu_NO_fdefs

static bool mustClose_MbR9(const State_Ph5I state)
{
    return !!(State_Ph5I((state & State_Ph5I_ReadEOF)) ? (State_Ph5I((state & State_Ph5I_WriteEOF)) || !State_Ph5I((state & State_Ph5I_WantsWrite))) : !!(State_Ph5I((state & State_Ph5I_WantsRead))));
}

int fu_MAIN()
{
    return int(mustClose_MbR9(State_Ph5I{}));
}

#endif

int main() { return fu_MAIN(); }

========

        struct State { v: u8 };

        let ReadEOF     = State(1);
        let WriteEOF    = State(2);
        let WantsRead   = State(4);
        let WantsWrite  = State(8);

        infix fn &(a: State, b: State) State(a.v & b.v);

        fn mustClose(state: State)
            !!(state & ReadEOF
                ? state & WriteEOF || !(state & WantsWrite)
                : state & WantsRead);

        fn main() = State().mustClose.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/init_priority.h>

struct State_iO0W;

                                #ifndef DEF_State_iO0WjE0jBjj
                                #define DEF_State_iO0WjE0jBjj
struct State_iO0W
{
                                // shape_hash:    e0e4bd428cabcf0e
                                // non_triv_mask: 0000000000000000
    fu::u8 v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const State_iO0W ReadEOF fu_INIT_PRIORITY(1001) = State_iO0W { fu::u8(1u) };

static State_iO0W operator&(/*3:3*/ const State_iO0W& a, /*3:3*/ const State_iO0W& b)
{
    return State_iO0W { fu::u8((a.v & b.v)) };
}

static const State_iO0W WriteEOF fu_INIT_PRIORITY(1001) = State_iO0W { fu::u8(2u) };

static const State_iO0W WantsWrite fu_INIT_PRIORITY(1001) = State_iO0W { fu::u8(8u) };

static const State_iO0W WantsRead fu_INIT_PRIORITY(1001) = State_iO0W { fu::u8(4u) };

static bool mustClose_MbR9(/*1:1*/ const State_iO0W& state)
{
    return !!((state & ReadEOF) ? ((state & WriteEOF) || !(state & WantsWrite)) : !!((state & WantsRead)));
}

int fu_MAIN()
{
    return int(mustClose_MbR9(State_iO0W{}));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn main() {
            mut match: int;

            fn and_brokenInference(my_int): int {
                return my_int > 0
                    && { indir_rec_inner(my_int.uint); true }
                    && match;
            }

            fn indir_rec_inner(my_uint: uint) {
                match = my_uint > 0 && and_brokenInference(my_uint - 1);
            }

            fn indir_rec(my_uint: uint) {
                indir_rec_inner(my_uint);
            }

            return and_brokenInference(3);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static void indir_rec_inner_MbR9(unsigned, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_and_brokenInference_DUeH0O9fH19
                                #define DEF_and_brokenInference_DUeH0O9fH19
inline static int and_brokenInference_DUeH(const unsigned my_int, /*3:3*/ int& match)
{
    if ((my_int > 0u) && (indir_rec_inner_MbR9(unsigned(my_int), match), true))
        return match;
    else
        return 0;

}
                                #endif

static void indir_rec_inner_MbR9(const unsigned my_uint, /*3:3*/ int& match)
{
    match = ((my_uint > 0u) ? and_brokenInference_DUeH((my_uint - 1u), match) : 0);
}

                                #ifndef DEF_and_brokenInference_eF4aZFBeUA5
                                #define DEF_and_brokenInference_eF4aZFBeUA5
inline static int and_brokenInference_eF4a(const int my_int, /*3:3*/ int& match)
{
    if ((my_int > 0) && (indir_rec_inner_MbR9(unsigned(my_int), match), true))
        return match;
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    int match {};
    return and_brokenInference_eF4a(3, match);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_UnusedImplicit

========

        fn main() {
            mut match: int;

            fn and_brokenInference(my_int): int {
                return my_int > 0
                    && { indir_rec_inner(my_int.uint); true }
                    && match;
            }

            fn indir_rec_inner(my_uint: uint) {
                match = my_uint > 0 && and_brokenInference(my_uint - 1);
            }

            fn indir_rec(my_uint: uint) {
                indir_rec_inner(my_uint);
            }

            return and_brokenInference(3);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static void indir_rec_inner_MbR9(unsigned, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_and_brokenInference_MYn6ErWX43f
                                #define DEF_and_brokenInference_MYn6ErWX43f
inline static int and_brokenInference_MYn6(const unsigned my_int, /*3:3*/ int& match)
{
    if (my_int > 0u)
    {
        indir_rec_inner_MbR9(unsigned(my_int), match);
        return match;
    }
    else
        return 0;

}
                                #endif

static void indir_rec_inner_MbR9(const unsigned my_uint, /*3:3*/ int& match)
{
    match = ((my_uint > 0u) ? and_brokenInference_MYn6((my_uint - 1u), match) : 0);
}

                                #ifndef DEF_and_brokenInference_D5OTxLyiuv8
                                #define DEF_and_brokenInference_D5OTxLyiuv8
inline static int and_brokenInference_D5OT(const int my_int, /*3:3*/ int& match)
{
    if (my_int > 0)
    {
        indir_rec_inner_MbR9(unsigned(my_int), match);
        return match;
    }
    else
        return 0;

}
                                #endif

int fu_MAIN()
{
    int match {};
    return and_brokenInference_D5OT(3, match);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_UnusedImplicit

========

        nocopy struct NC { items: NC[]; }

        noinline fn silly_ctz(x: u32) {
            for (mut i: u32 = 0; i < 32; i++)
                if (x & (1 << i))
                    return i.int;

            return 32;
        }

        inline fn max_probes(index: NC[])
            index.len && index[0] && silly_ctz(index.len.uint).int

        noinline fn either(a: NC[], b: NC[]) a || b;            // ConstCast
        fn main() max_probes(either([], [ NC([ NC() ]), NC() ])) - 1;

---- [ status(0) uniq_bytes(256) uniq_count(2) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct NC_BA7N;

                                #ifndef DEF_NC_BA7NDIBJz38
                                #define DEF_NC_BA7NDIBJz38
struct NC_BA7N
{
                                // shape_hash:    12805fbcfa25add5
                                // non_triv_mask: 0000000020002000
    fu::vec<NC_BA7N> items;
    NC_BA7N(const NC_BA7N&) = delete;
    NC_BA7N(NC_BA7N&&) = default;
    NC_BA7N& operator=(const NC_BA7N&) = delete;
    NC_BA7N& operator=(NC_BA7N&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<NC_BA7N> either_MbR9(/*3:3*/ fu::vec_range<NC_BA7N> a, /*3:3*/ fu::vec_range<NC_BA7N> b)
{
    return a ? a : b;
}

static int silly_ctz_MbR9(const unsigned x)
{
    for (unsigned i = 0u; i < 32u; i++)
    {
        if (x & (1u << i))
            return int(i);

    };
    return 32;
}

int fu_MAIN()
{
    fu::vec<NC_BA7N> index {};
    return (index = either_MbR9((*(fu::vec<NC_BA7N>*)fu::NIL), fu::vec<NC_BA7N> {{ NC_BA7N { fu::vec<NC_BA7N> {{ NC_BA7N{} }} }, NC_BA7N{} }}).const_cast_mut().destructive_move_or_default(), ((index.size() && index[0]) ? int(silly_ctz_MbR9(unsigned(index.size()))) : 0)) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        fn grow_if_oob(ref a: _[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn init !T(ref a: T[], i: i32, mut v: T) {
            (a.grow_if_oob(i) && { return false; }) = v;        // GNUStmtExpr
            return true;
        }

        fn main() {
            mut hello = [ 1, 2, 3 ];
            let a = hello.init(2, 30);
            let b = hello.init(3, 40);
            mut sum = 0;
            for (mut i = 0; i < hello.len; i++) sum += hello[i];
            return !a && b && sum == 46 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/never.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_2Giz4sIWyKi
                                #define DEF_grow_if_oob_2Giz4sIWyKi
inline static int& grow_if_oob_2Giz(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_init_Zy53m1h0Ib1
                                #define DEF_init_Zy53m1h0Ib1
inline static bool init_Zy53(/*7:7*/ fu::vec_range_mut<int> a, const int i, const int v)
{
    int* _0;
    (!*(_0 = &(grow_if_oob_2Giz(a, i))) ? *_0 : (__extension__ (
    {
        return false;
        (void)0;
    }), fu::unreachable)) = v;
    return true;
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> hello = fu::vec<int> {{ 1, 2, 3 }};
    const bool a = init_Zy53(hello, 2, 30);
    const bool b = init_Zy53(hello, 3, 40);
    int sum = 0;
    for (int i = 0; i < hello.size(); i++)
        sum += hello[i];

    if (!a && b && (sum == 46))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn either(a: string, b: string) // dont copy before either branch taken
            a || "Hello, " ~ b ~ "!";   // EXPECT return a ? fu::str(a) :

        import _0;
        fn main() either(either("", "World"), "") == "Hello, World!" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>

fu::str either_MbR9(fu::vec_range<char>, fu::view<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (either_MbR9(either_MbR9((*(fu::str*)fu::NIL), "World"_view), fu::view<char>{}) == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

fu::str either_MbR9(/*3:3*/ fu::vec_range<char> a, /*3:3*/ fu::view<char> b)
{
    return a ? fu::str(a) : (("Hello, "_view + b) + "!"_view);
}

#endif

// N_NonTrivAutoCopy

========

        mut i = 7;
        i ||= 11;
        return i - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 7;
    if (!(i))
        i = 11;

    return i - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        mut i = 0;
        i ||= 11;
        return i - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 0;
    if (!(i))
        i = 11;

    return i - 11;
}

#endif

int main() { return fu_MAIN(); }

========

        mut a = 1;
        mut b = 0;
        a ||= ++b;
        return  b;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    if (!(a))
        a = ++b;

    return b;
}

#endif

int main() { return fu_MAIN(); }

========

        mut CHANGE = false;
        CHANGE ||= true;
        return CHANGE.i32 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    bool CHANGE = false;
    if (!(CHANGE))
        CHANGE = true;

    return int(CHANGE) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn and_incr(ref x: i32, v: i32)
            x &&= x + v;

        fn main() {
            mut x: i32 = 0;
            and_incr(x, 10);
            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int and_incr_GL0m(/*3:3*/ int& x, const int v)
{
    return !x ? x : (x = (x + v));
}

int fu_MAIN()
{
    int x = 0;
    and_incr_GL0m(x, 10);
    return x;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Test { x: i32; }
        fn test(ref t: Test) t.x++;
        mut t = Test();

        t.test;             
        return t.x - 1;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:9+1[0m:

[2m      |         mut t = Test();[0m
[2m      | [0m
[2m    9 | [0m        [31;1mt[0m.test;             
[2m      |         return t.x - 1;[0m
[2m      | [0m

	Orphaned call without parentheses, add () to imply a useful side effect.

========

        struct Test { x: i32; }
        fn test(ref t: Test) t.x++;
        mut t = Test();

        t.test();           
        return t.x - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_68jG;

                                #ifndef DEF_Test_68jGtUaG1jd
                                #define DEF_Test_68jGtUaG1jd
struct Test_68jG
{
                                // shape_hash:    24b0cd36b2a5efa9
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ Test_68jG& t)
{
    return t.x++;
}

int fu_MAIN()
{
    Test_68jG t {};
    test_MbR9(t);
    return t.x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        {
            {
                return 0;
            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        {

        {
            return 0;
        }

        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:9+1[0m:

[2m      |         {[0m
[2m      | [0m
[2m    7 | [0m        [31;1m{[0m
[2m      |             return 0;[0m
[2m      |         }[0m

	Inconsistent indent at `{`: expected more than 9, got 9. Block starts on line 5.

========

        {

            {
                return 0;
            }

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        {
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        {
            return 0;

       }


---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:1+1[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m[31;1m}[0m
[2m      | [0m

	Inconsistent indent at closing `}`: expected 8, got 7. Block starts on line 5.

========

        {
            return 0;

        }


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        {
            return 0;

         }


---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:1+1[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m[31;1m}[0m
[2m      | [0m

	Inconsistent indent at closing `}`: expected 8, got 9. Block starts on line 5.

========

        let y = [ 1 ];              // TODO fu::slate<1, int> y
        let 
            z = [ 2 ];              // TODO fu::slate<1, int> z

        return y[0] - 1

---- <fail> ----
[2m[0m_0[2m.fu 7:13+1[0m:

[2m      |         let y = [ 1 ];              // TODO fu::slate<1, int> y[0m
[2m      |         let [0m
[2m    7 | [0m            [31;1mz[0m = [ 2 ];              // TODO fu::slate<1, int> z
[2m      | [0m
[2m      |         return y[0] - 1[0m

	Unused variable: [35;3mlet[0m [94;1mz[0m. Make it [35;3mlax[0m if this is intentional.

========

        let y = [ 1 ];              // TODO fu::slate<1, int> y
        let lax
            z = [ 2 ];              // TODO fu::slate<1, int> z

        return y[0] - 1

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> y = fu::vec<int> {{ 1 }};
    return y[0] - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedArrlit, N_UnusedLet

========

        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,

            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;

---- <fail> ----
[2m[0m_0[2m.fu 5:13+1[0m:

[2m      |         fn hello(a: string,[0m
[2m      | [0m
[2m    5 | [0m            [31;1mb[0m: string)
[2m      |                 a && fail(a) ? b : a;[0m
[2m      | [0m

	Unused variable: [35;3marg[0m [94;1mb[0m. Make it [35;3mlax[0m if this is intentional.

========

        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,
lax
            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never fail_MbR9(/*1:1*/ fu::view<char> a)
{
    fu::fail(("hey: "_view + a));
}

static fu::view<char> hello_kGbb(/*3:3*/ fu::view<char> a)
{
    if (a)
        fail_MbR9(a);
    else
        return a;

}

int fu_MAIN()
{
    return hello_kGbb(""_view).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,
lax
            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never fail_MbR9(/*1:1*/ fu::view<char> a)
{
    fu::fail(("hey: "_view + a));
}

static fu::view<char> hello_kGbb(/*3:3*/ fu::view<char> a)
{
    if (a)
        fail_MbR9(a);
    else
        return a;

}

int fu_MAIN()
{
    return hello_kGbb(fu::view<char>{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn incr(ref x: i32) x++;
        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {
            return a.incr

            +

                b.incr;
        }

        fn main() {
            mut a = 0; mut b = 0;
            lints_ambig_expr_indent(a, b);
            return a - b;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:23+1[0m:

[2m      |             +[0m
[2m      | [0m
[2m    8 | [0m                b.incr[31;1m;[0m
[2m      |         }[0m
[2m      | [0m

	Ambiguous indent at `+`: expected more than 13, got 13

========

        fn incr(ref x: i32) x++;
        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {
            return a.incr

              +

                b.incr;
        }

        fn main() {
            mut a = 0; mut b = 0;
            lints_ambig_expr_indent(a, b);
            return a - b;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int incr_MbR9(/*1:1*/ int& x)
{
    return x++;
}

static int lints_ambig_expr_indent_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    int _0;
    return (_0 = incr_MbR9(a), (_0 + incr_MbR9(b)));
}

int fu_MAIN()
{
    int a = 0;
    int b = 0;
    lints_ambig_expr_indent_MbR9(a, b);
    return a - b;
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

========

        fn lints_ambig_jump_semis(mut x: i32) {

            return
            x;

        }

        fn main() 0.lints_ambig_jump_semis;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:13+1[0m:

[2m      | [0m
[2m      |             return[0m
[2m    5 | [0m            [31;1mx[0m;
[2m      | [0m
[2m      |         }[0m

	Ambiguous indent at `x`: expected more than 13, got 13

========

        fn lints_ambig_jump_semis(mut x: i32) {

            return x;

        }

        fn main() 0.lints_ambig_jump_semis;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int lints_ambig_jump_semis_MbR9(const int x)
{
    return x;
}

int fu_MAIN()
{
    return lints_ambig_jump_semis_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || 
                              a = A(incr(a));     //  this was an honest mistake.

        fn main() { mut v = 0; return A(v) - 1; }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:45+1[0m:

[2m      |         fn incr(ref a: i32) ++a;[0m
[2m      |         fn A(ref a: i32) a || [0m
[2m    4 | [0m                              a = A(incr(a))[31;1m;[0m     //  this was an honest mistake.
[2m      | [0m
[2m      |         fn main() { mut v = 0; return A(v) - 1; }[0m

	Unparenthesized `or` on the left side of an `=`.

========

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a ||  // Lint should complain here,
                             (a = A(incr(a)));    //  this was an honest mistake.

        fn main() { mut v = 0; return A(v) - 1; }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int A_kGbb(int&);

#ifndef fu_NO_fdefs

static int& incr_MbR9(/*1:1*/ int& a)
{
    return ++a;
}

static int A_kGbb(/*1:1*/ int& a)
{
    return a ? a : (a = A_kGbb(incr_MbR9(a)));
}

int fu_MAIN()
{
    int v = 0;
    return A_kGbb(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        fn test(is_mutref: bool, args: i32[], ref sum: i32) {

            if (is_mutref)
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];

            else
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 2)
                        sum += args[i];
        }

        fn main() {
            mut sum = 0;
            test(true , [ 1,  2,  3  ], sum);
            test(false, [ 11, 22, 33 ], sum);
            return sum - 1 - 3 - 11 - 22;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:17+3[0m:

[2m      | [0m
[2m      |             else[0m
[2m   10 | [0m                [31;1mfor[0m (mut i = 0; i < args.len; i++)
[2m      |                     if (args[i] & 2)[0m
[2m      |                         sum += args[i];[0m

	Inconsistent indent at `else`: expected 21, got 13. `if` starts on line 6.

========

        fn test(is_mutref: bool, args: i32[], ref sum: i32) {

            if (is_mutref) {
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];
            }

            else
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 2)
                        sum += args[i];
        }

        fn main() {
            mut sum = 0;
            test(true , [ 1,  2,  3  ], sum);
            test(false, [ 11, 22, 33 ], sum);
            return sum - 1 - 3 - 11 - 22;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_MbR9(const bool is_mutref, /*7:7*/ fu::view<int> args, /*5:5*/ int& sum)
{
    if (is_mutref)
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (args[i] & 1)
                sum += args[i];

        };
    }
    else
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (args[i] & 2)
                sum += args[i];

        };
    };
}

int fu_MAIN()
{
    int sum = 0;
    test_MbR9(true, fu::view<int> {{ 1, 2, 3 }}, sum);
    test_MbR9(false, fu::view<int> {{ 11, 22, 33 }}, sum);
    return (((sum - 1) - 3) - 11) - 22;
}

#endif

int main() { return fu_MAIN(); }

========

        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()   
            -1.0    
                .abs;

        fn main() test ? 0 : 7;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 22:18+3[0m:

[2m      |         fn test()   [0m
[2m      |             -1.0    [0m
[2m   22 | [0m                .[31;1mabs[0m;
[2m      | [0m
[2m      |         fn main() test ? 0 : 7;[0m

	Here the unary -/+ separates from the numeric literal, and wraps around the whole expression. Please parenthesize explicitly to make this obvious.

========

        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()   
            (-1.0)  
                .abs;

        fn main() test ? 0 : 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cmath>


#ifndef fu_NO_fdefs

static double test_MbR9()
{
    return std::fabs(-1.0);
}

int fu_MAIN()
{
    if (test_MbR9())
        return 0;
    else
        return 7;

}

#endif

int main() { return fu_MAIN(); }

========

        fn id(x) = x;
        fn main() {
            return id(
                0 +

               0  
            );
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:16+1[0m:

[2m      |                 0 +[0m
[2m      | [0m
[2m    7 | [0m               [31;1m0[0m  
[2m      |             );[0m
[2m      |         }[0m

	Ambiguous indent at `0`: expected more than 17, got 16

========

        fn id(x) = x;
        fn main() {
            return id(
                0 +

                0 
            );
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_id_0DCJaE9X1mk
                                #define DEF_id_0DCJaE9X1mk
inline static int id_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

int fu_MAIN()
{
    return id_0DCJ((0 + 0));
}

#endif

int main() { return fu_MAIN(); }

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |
                    _?|
                {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |
                    _?| {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |_?|
                {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |_?| {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {

            doStuff(stuff: ||
                {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {

            doStuff(stuff: || {

                    return 0;
                });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        nodiscard primitive Errcode: i32;

        fn try_incr(implicit ref x: i32): Errcode {
            if (++x > 0) return 10;
            return 0;
        }

        fn main() {
            implicit mut x = -1;

            try_incr();
            try_incr();
            return x - 1;

        }

---- <fail> ----
[2m[0m_0[2m.fu 13:13+8[0m:

[2m      | [0m
[2m      |             try_incr();[0m
[2m   13 | [0m            [31;1mtry_incr[0m();
[2m      |             return x - 1;[0m
[2m      | [0m

	Return value of [35;3mfn[0m [94;1mtry_incr[0m: [31;1mnodiscard[0m [35;3mprimitive[0m [94;1mErrcode[0m is getting discarded here.

       RelaxMut [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        nodiscard primitive Errcode: i32;

        fn try_incr(implicit ref x: i32): Errcode {
            if (++x > 0) return 10;
            return 0;
        }

        fn main() {
            implicit mut x = -1;

            shadow let err = try_incr() || try_incr();
            return err.i32 + x - 11;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int Errcode_iLqf;

                                #ifndef DEF_Errcode_iLqf
                                #define DEF_Errcode_iLqf
                                #endif

#ifndef fu_NO_fdefs

static Errcode_iLqf try_incr_MbR9(/*1:1*/ int& x)
{
    if (++x > 0)
        return 10;
    else
        return 0;

}

int fu_MAIN()
{
    int x = -1;
    Errcode_iLqf _0;
    const Errcode_iLqf err = ((_0 = try_incr_MbR9(x)) ? _0 : try_incr_MbR9(x));
    return (int(err) + x) - 11;
}

#endif

int main() { return fu_MAIN(); }

========

        using flags Flags { F_LAMBDA; F_IMPLICIT }
        fn precedenceWhitespace(NICEERR_missingReturn: bool)
        {

            return NICEERR_missingReturn && F_IMPLICIT      
                 | F_LAMBDA;
        }

        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:18+1[0m:

[2m      | [0m
[2m      |             return NICEERR_missingReturn && F_IMPLICIT      [0m
[2m    7 | [0m                 [31;1m|[0m F_LAMBDA;
[2m      |         }[0m
[2m      | [0m

	Misleading whitespace: misrepresents operator precedence.

	Please parenthesize this expression to disambiguate,
		indent the stronger operator further to the right,
		or put the weaker operator on a new line.

========

        using flags Flags { F_LAMBDA; F_IMPLICIT }
        fn precedenceWhitespace(NICEERR_missingReturn: bool)
        {

            return (NICEERR_missingReturn && F_IMPLICIT)    
                 | F_LAMBDA;
        }

        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Flags_Qpfn;

                                #ifndef DEF_Flags_Qpfn
                                #define DEF_Flags_Qpfn
inline constexpr Flags_Qpfn Flags_Qpfn_F_LAMBDA = Flags_Qpfn(1u);
inline constexpr Flags_Qpfn Flags_Qpfn_F_IMPLICIT = Flags_Qpfn(2u);

inline constexpr Flags_Qpfn MASK_Flags_Qpfn
    = Flags_Qpfn_F_LAMBDA
    | Flags_Qpfn_F_IMPLICIT;
                                #endif

#ifndef fu_NO_fdefs

static Flags_Qpfn precedenceWhitespace_MbR9(const bool NICEERR_missingReturn)
{
    return (NICEERR_missingReturn ? Flags_Qpfn_F_IMPLICIT : Flags_Qpfn{}) | Flags_Qpfn_F_LAMBDA;
}

int fu_MAIN()
{
    if (precedenceWhitespace_MbR9(false) == Flags_Qpfn_F_LAMBDA)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using flags Flags { F_LAMBDA; F_IMPLICIT }
        fn precedenceWhitespace(NICEERR_missingReturn: bool)
        {
            return F_LAMBDA

                 | NICEERR_missingReturn && F_IMPLICIT;     
        }

        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:18+1[0m:

[2m      |             return F_LAMBDA[0m
[2m      | [0m
[2m    7 | [0m                 [31;1m|[0m NICEERR_missingReturn && F_IMPLICIT;     
[2m      |         }[0m
[2m      | [0m

	Misleading whitespace: misrepresents operator precedence.

	Please parenthesize this expression to disambiguate,
		indent the stronger operator further to the right,
		or put the weaker operator on a new line.

========

        using flags Flags { F_LAMBDA; F_IMPLICIT }
        fn precedenceWhitespace(NICEERR_missingReturn: bool)
        {
            return F_LAMBDA

                 | (NICEERR_missingReturn && F_IMPLICIT);   
        }

        fn main() precedenceWhitespace(false) == F_LAMBDA ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Flags_Qpfn;

                                #ifndef DEF_Flags_Qpfn
                                #define DEF_Flags_Qpfn
inline constexpr Flags_Qpfn Flags_Qpfn_F_LAMBDA = Flags_Qpfn(1u);
inline constexpr Flags_Qpfn Flags_Qpfn_F_IMPLICIT = Flags_Qpfn(2u);

inline constexpr Flags_Qpfn MASK_Flags_Qpfn
    = Flags_Qpfn_F_LAMBDA
    | Flags_Qpfn_F_IMPLICIT;
                                #endif

#ifndef fu_NO_fdefs

static Flags_Qpfn precedenceWhitespace_MbR9(const bool NICEERR_missingReturn)
{
    return Flags_Qpfn_F_LAMBDA | (NICEERR_missingReturn ? Flags_Qpfn_F_IMPLICIT : Flags_Qpfn{});
}

int fu_MAIN()
{
    if (precedenceWhitespace_MbR9(false) == Flags_Qpfn_F_LAMBDA)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main()              
                    6-3 * 2     ;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:25+1[0m:

[2m      | [0m
[2m      |         fn main()              [0m
[2m    3 | [0m                    6-3 [31;1m*[0m 2     ;
[2m      | [0m

	Misleading whitespace: misrepresents operator precedence.

	Please parenthesize this expression to disambiguate.

========

        fn main()              
                    6-(3 * 2)   ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 6 - (3 * 2);
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut x = 5;
            for (mut i = 10; i --> 0; ) {   
                if (x = i) {                
                    x += i;
                    break;
                }
            }

            return x - 10;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:23+1[0m:

[2m      |             mut x = 5;[0m
[2m      |             for (mut i = 10; i --> 0; ) {   [0m
[2m    5 | [0m                if (x [31;1m=[0m i) {                
[2m      |                     x += i;[0m
[2m      |                     break;[0m

	Unparenthesized assignment used as a condition.

========

        fn main() {
            mut x = 5;
            for (mut i = 10; i --> 0; ) {   
                if (x == i) {               
                    x += i;
                    break;
                }
            }

            return x - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 5;
    for (int i = 10; i-- > 0; )
    {
        if (x == i)
        {
            x += i;
            break;
        };
    };
    return x - 10;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut total = 100;
            for (mut i = 0; i < total; i++) {
                if (i & 1) continue;
                total-- // no semi
            }

            return total - 66
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int total = 100;
    for (int i = 0; i < total; i++)
    {
        if (!(i & 1))
            total--;

    };
    return total - 66;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut total = 100;
            for (mut i = 0; i < total; i++) {
                if (i & 1) continue;
                if (i & 3) continue i;
                total--; // no semi
            }

            return total - 80
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:28+8[0m:

[2m      |             for (mut i = 0; i < total; i++) {[0m
[2m      |                 if (i & 1) continue;[0m
[2m    6 | [0m                if (i & 3) [31;1mcontinue[0m i;
[2m      |                 total--; // no semi[0m
[2m      |             }[0m

	Bad jump expression: expects [35;3mvoid[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut total = 100;
            for (mut i = 0; i < total; i++) {
                if (i & 1) continue;
                if (i & 3) continue ;
                total--; // no semi
            }

            return total - 80
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int total = 100;
    for (int i = 0; i < total; i++)
    {
        if (!(i & 1))
        {
            if (!(i & 3))
                total--;

        };
    };
    return total - 80;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut total = 100;
            fn iteration(i: int) {
                if (i & 1) return;
                total-- //fail subseq return no common supertype void i32 6:22+2><pass/>;</fail>
            }

            for (mut i = 0; i < total; i++) iteration(i);
            return total - 66
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void iteration_MbR9(const int i, /*3:3*/ int& total)
{
    if (!(i & 1))
        total--;

}

int fu_MAIN()
{
    int total = 100;
    for (int i = 0; i < total; i++)
        iteration_MbR9(i, total);

    return total - 66;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn test(ref a: i32, ref b: i32) {
            return (++a) + 10 * (++b);                          // N_AARMustSeq
        }

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            ref y = x;
            let z = test(x, y);

            return x == 2 && z == 21 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    int _0;
    return (_0 = ++a, (_0 + (10 * ++b)));
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_MbR9(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        noinline fn test(ref a: i32, ref b: i32) {
            return (++a) + 10 * (++b);                          // N_AARMustSeq
        }

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            let z = test(x, x);

            return x == 2 && z == 21 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    int _0;
    return (_0 = ++a, (_0 + (10 * ++b)));
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_MbR9(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        noinline fn test_inner(ref a: i32, ref b: i32)
            (++a) + 10 * (++b);                                 // N_AARMustSeq

        noinline fn test_outer(ref a: i32, ref b: i32)
            test_inner(a, b);

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            ref y = x;
            let z = test_outer(x, y);

            return x == 2 && z == 21 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_inner_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    int _0;
    return (_0 = ++a, (_0 + (10 * ++b)));
}

static int test_outer_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    return test_inner_MbR9(a, b);
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_outer_MbR9(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        noinline fn test_inner(ref a: i32, ref b: i32)
            (++a) + 10 * (++b);                                 // N_AARMustSeq

        noinline fn test_outer(ref a: i32, ref b: i32)
            test_inner(a, b);

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            let z = test_outer(x, x);

            return x == 2 && z == 21 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_inner_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    int _0;
    return (_0 = ++a, (_0 + (10 * ++b)));
}

static int test_outer_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    return test_inner_MbR9(a, b);
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_outer_MbR9(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) {

                a ~= 1; // Invalidates 'b'.

            }
            b++;
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:13+1[0m:

[2m      | [0m
[2m      |             }[0m
[2m    9 | [0m            [31;1mb[0m++;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mb[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m6:19+2[0m:

[2m      |             if (a.len & 1) {[0m
[2m      | [0m
[2m    6 | [0m                a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      | [0m
[2m      |             }[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) {

                b++;

            }
            b++;
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::view_mut<int> a)
{
    int& /*a|static*/ b = a.mutref(0);
    if (a.size() & 1)
        b++;

    b++;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    test_MbR9(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        nocopy struct nci32 { i: i32; };

        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;
        fn main() {
            mut x = nci32(0);

            ref y = x;                        

            return test(x, y);
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:28+1[0m:

[2m      |             ref y = x;                        [0m
[2m      | [0m
[2m   10 | [0m            return test(x, [31;1my[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3marg[0m [94;1mtest[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mx[0m at [2m6:17+1[0m:

[2m      |         noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;[0m
[2m      |         fn main() {[0m
[2m    6 | [0m            mut [31;1mx[0m = nci32(0);
[2m      | [0m
[2m      |             ref y = x;                        [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3marg[0m [94;1mtest[0m:[94;1mb[0m is non-copyable: [35;3mnocopy[0m [35;3mstruct[0m [94;1mnci32[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mnci32[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        nocopy struct nci32 { i: i32; };

        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;
        fn main() {
            mut x = nci32(0);

            let y = nci32(0);                 

            return test(x, y);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct nci32_XRQi;

                                #ifndef DEF_nci32_XRQiQ7BgxD4
                                #define DEF_nci32_XRQiQ7BgxD4
struct nci32_XRQi
{
                                // shape_hash:    1f13c45830c94063
                                // non_triv_mask: 0000000000002000
    int i;
    nci32_XRQi(const nci32_XRQi&) = delete;
    nci32_XRQi(nci32_XRQi&&) = default;
    nci32_XRQi& operator=(const nci32_XRQi&) = delete;
    nci32_XRQi& operator=(nci32_XRQi&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ nci32_XRQi& a, /*3:3*/ const nci32_XRQi& b)
{
    int _0;
    return (_0 = a.i++) ? _0 : b.i;
}

int fu_MAIN()
{
    nci32_XRQi x = nci32_XRQi { 0 };
    nci32_XRQi y = nci32_XRQi { 0 };
    return test_MbR9(x, y);
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) { // Lets be extra sure here.

                a ~= 1; // Invalidates 'b'.
                b++;

            }
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:17+1[0m:

[2m      | [0m
[2m      |                 a ~= 1; // Invalidates 'b'.[0m
[2m    7 | [0m                [31;1mb[0m++;
[2m      | [0m
[2m      |             }[0m

	Cannot access [35;3mmut ref[0m [94;1mb[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m6:19+2[0m:

[2m      |             if (a.len & 1) { // Lets be extra sure here.[0m
[2m      | [0m
[2m    6 | [0m                a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      |                 b++;[0m
[2m      | [0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) { // Lets be extra sure here.

                b++;
                a ~= 1;

            }
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    int& /*a|static*/ b = a.mutref(0);
    if (a.size() & 1)
    {
        b++;
        a += 1;
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    test_MbR9(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                b++; // Same thing but reordered as a loop.
                if (a.len & 3) {

                    a ~= 1; // Invalidates 'b'.

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 105;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:23+2[0m:

[2m      |                 if (a.len & 3) {[0m
[2m      | [0m
[2m    9 | [0m                    a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      | [0m
[2m      |                 }[0m

	Write to [35;3mmut ref arg[0m [94;1ma[0m at call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m invalidates the use of [35;3mmut ref[0m [94;1mb[0m at [2m6:17+1[0m:

[2m      |             for (mut i = 2; i --> 0; )[0m
[2m      |             {[0m
[2m    6 | [0m                [31;1mb[0m++; // Same thing but reordered as a loop.
[2m      |                 if (a.len & 3) {[0m
[2m      | [0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                b++; // Same thing but reordered as a loop.
                if (a.len & 3) {

                    b++;

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 105;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    int& /*a|static*/ b = a.mutref(0);
    for (int i = 2; i-- > 0; )
    {
        b++;
        if (a.size() & 3)
            b++;

    };
    a += 100;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    test_MbR9(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 105;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                if (i & 1) {
                    b += 2; // Same thing but reordered as a loop.
                }
                else {

                    a ~= 1; // Invalidates 'b', same as a above, but now in an if/else -

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 106;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:23+2[0m:

[2m      |                 else {[0m
[2m      | [0m
[2m   11 | [0m                    a [31;1m~=[0m 1; // Invalidates 'b', same as a above, but now in an if/else -
[2m      | [0m
[2m      |                 }[0m

	Write to [35;3mmut ref arg[0m [94;1ma[0m at call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m invalidates the use of [35;3mmut ref[0m [94;1mb[0m at [2m7:21+1[0m:

[2m      |             {[0m
[2m      |                 if (i & 1) {[0m
[2m    7 | [0m                    [31;1mb[0m += 2; // Same thing but reordered as a loop.
[2m      |                 }[0m
[2m      |                 else {[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                if (i & 1) {
                    b += 2; // Same thing but reordered as a loop.
                }
                else {
 //  got the used-in-a-loop stuff wrong when switching to cant_invalidate.
                    b += 3;

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 106;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    int& /*a|static*/ b = a.mutref(0);
    for (int i = 2; i-- > 0; )
    {
        if (i & 1)
            b += 2;
        else
            b += 3;

    };
    a += 100;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    test_MbR9(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 106;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        // both args alias, but there's no risk of inval.
        noinline fn incr_a_or_b(ref a: i32, ref b: i32)
            (a || b)++;

        fn main() {
            mut Z = 0;
            mut A = 1;
            mut B = 0;

            incr_a_or_b(Z, B); // incr B, now 1
            incr_a_or_b(A, B); // incr A, now 2
            incr_a_or_b(B, B); // incr _target, now 2 // alias!

            return (100*A + B) - 202;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int incr_a_or_b_MbR9(/*3:3*/ int& a, /*3:3*/ int& b)
{
    return (a ? a : b)++;
}

int fu_MAIN()
{
    int Z = 0;
    int A = 1;
    int B = 0;
    incr_a_or_b_MbR9(Z, B);
    incr_a_or_b_MbR9(A, B);
    incr_a_or_b_MbR9(B, B);
    return ((100 * A) + B) - 202;
}

#endif

int main() { return fu_MAIN(); }

========

        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            ref c = a || b;
            return ++++c - 3; // double mutation of a union
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct V_XHsD;

                                #ifndef DEF_V_XHsDY6p70C8
                                #define DEF_V_XHsDY6p70C8
struct V_XHsD
{
                                // shape_hash:    d94d6041ad6f1546
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    V_XHsD A = V_XHsD { 1 };
    int& /*A*/ a = A.v;
    int& /*A*/ b = A.v;
    int& /*b|a*/ c = (a ? a : b);
    return ++++c - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            return ++++(a || b) - 3; // same, without a helper var
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct V_XHsD;

                                #ifndef DEF_V_XHsDY6p70C8
                                #define DEF_V_XHsDY6p70C8
struct V_XHsD
{
                                // shape_hash:    d94d6041ad6f1546
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    V_XHsD A = V_XHsD { 1 };
    int& /*A*/ a = A.v;
    int& /*A*/ b = A.v;
    return ++++(a ? a : b) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct V { v: i32; w?: i32; ww?: i32; };

        fn main() {
            mut A: V = [ 1 ];
            mut B: V = [ 1 ];


            ref aa = A.v || A.w; 

            ref bb = B.v || B.w;
            ++++bb;

            ref a = A.v || A.ww;
            ref b = B.v || B.ww;

            ref c = a || b;
            ++++c;

            return aa - 3; // same, without a helper var
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:20+2[0m:

[2m      |             ++++c;[0m
[2m      | [0m
[2m   20 | [0m            return [31;1maa[0m - 3; // same, without a helper var
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1maa[0m, reference invalidated by write to [35;3mmut ref[0m [94;1mc[0m at [2m18:15+2[0m:

[2m      | [0m
[2m      |             ref c = a || b;[0m
[2m   18 | [0m            ++[31;1m++[0mc;
[2m      | [0m
[2m      |             return aa - 3; // same, without a helper var[0m

	At call to [35;3m__native[0m [94;1m++[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct V { v: i32; w?: i32; ww?: i32; };

        fn main() {
            mut A: V = [ 1 ];
            mut B: V = [ 1 ];


            fn  aa = A.v || A.w; 

            ref bb = B.v || B.w;
            ++++bb;

            ref a = A.v || A.ww;
            ref b = B.v || B.ww;

            ref c = a || b;
            ++++c;

            return aa - 3; // same, without a helper var
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct V_EcIG;

                                #ifndef DEF_V_EcIGumW5Ccl
                                #define DEF_V_EcIGumW5Ccl
struct V_EcIG
{
                                // shape_hash:    099d26f9bc448f6f
                                // non_triv_mask: 0000000000000000
    int v;
    int w;
    int ww;
    explicit operator bool() const noexcept
    {
        return false
            || v
            || w
            || ww
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int aa_kGbb(/*1:1*/ const V_EcIG& A)
{
    return A.v ? A.v : A.w;
}

int fu_MAIN()
{
    V_EcIG A = V_EcIG { 1, 0, 0 };
    V_EcIG B = V_EcIG { 1, 0, 0 };
    int& /*B*/ bb = (B.v ? B.v : B.w);
    ++++bb;
    int& /*A*/ a = (A.v ? A.v : A.ww);
    int& /*B*/ b = (B.v ? B.v : B.ww);
    int& /*b|a*/ c = (a ? a : b);
    ++++c;
    return aa_kGbb(A) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        // a can alias b
        // c can alias d
        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd(ab, cd, ab, cd); 

            return ab - cd;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:27+2[0m:

[2m      | [0m
[2m      | [0m
[2m   16 | [0m            ab_cd(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab - cd;[0m

	At call to [35;3mfn[0m [94;1mab_cd[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mab_cd[0m:[94;1mc[0m and
	    1:	[35;3mref arg[0m [94;1mab_cd[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mab[0m at [2m12:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   12 | [0m            mut [31;1mab[0m = 0;
[2m      |             mut cd = 0;[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mab_cd[0m:[94;1mc[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mab_cd[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m11:12+4[0m

========

        // a can alias b
        // c can alias d
        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd(ab, ab, cd, cd); 

            return ab - cd;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void ab_cd_MbR9(/*3:3*/ int& a, /*3:3*/ int& b, /*F:F*/ int& c, /*F:F*/ int& d)
{
    int& /*a|b*/ ab = (a ? a : b);
    int& /*c|d*/ cd = (c ? c : d);
    ++++ab;
    ++++cd;
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    ab_cd_MbR9(ab, ab, cd, cd);
    return ab - cd;
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { i: i32; j: i32; };
        // a can alias b
        // c can alias d
        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {
            ref ab = a || b;
            defer {
                ref abi = j ? ab.j : ab.i;
                ++++abi;
            }
            ref cd = c || d;
            ref cdi = j ? cd.j : cd.i;
            ++++cdi;
        }

        fn main() {
            mut ab = X(0, 0);
            mut cd = X(0, 0);


            ab_cd_defer(ab, cd, ab, cd); 

            return ab.i - cd.i;
        }

---- <fail> ----
[2m[0m_0[2m.fu 21:33+2[0m:

[2m      | [0m
[2m      | [0m
[2m   21 | [0m            ab_cd_defer(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab.i - cd.i;[0m

	At call to [35;3mfn[0m [94;1mab_cd_defer[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mab_cd_defer[0m:[94;1mc[0m and
	    1:	[35;3mref arg[0m [94;1mab_cd_defer[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mab[0m at [2m17:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mab[0m = X(0, 0);
[2m      |             mut cd = X(0, 0);[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mab_cd_defer[0m:[94;1mc[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mab_cd_defer[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        struct X { i: i32; j: i32; };
        // a can alias b
        // c can alias d
        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {
            ref ab = a || b;
            defer {
                ref abi = j ? ab.j : ab.i;
                ++++abi;
            }
            ref cd = c || d;
            ref cdi = j ? cd.j : cd.i;
            ++++cdi;
        }

        fn main() {
            mut ab = X(0, 0);
            mut cd = X(0, 0);


            ab_cd_defer(ab, ab, cd, cd); 

            return ab.i - cd.i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct X_xKbK;

                                #ifndef DEF_X_xKbKEsOSHV1
                                #define DEF_X_xKbKEsOSHV1
struct X_xKbK
{
                                // shape_hash:    1861940e3972d761
                                // non_triv_mask: 0000000000000000
    int i;
    int j;
    explicit operator bool() const noexcept
    {
        return false
            || i
            || j
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void ab_cd_defer_MbR9(/*F1:F1*/ X_xKbK& a, /*F1:F1*/ X_xKbK& b, /*C1:C1*/ X_xKbK& c, /*C1:C1*/ X_xKbK& d, const bool j)
{
    X_xKbK& /*a|b*/ ab = (a ? a : b);
    fu_DEFER(
    {
        int& /*ab*/ abi = (j ? ab.j : ab.i);
        ++++abi;
    });
    X_xKbK& /*c|d*/ cd = (c ? c : d);
    int& /*cd*/ cdi = (j ? cd.j : cd.i);
    ++++cdi;
}

int fu_MAIN()
{
    X_xKbK ab = X_xKbK { 0, 0 };
    X_xKbK cd = X_xKbK { 0, 0 };
    ab_cd_defer_MbR9(ab, ab, cd, cd, false);
    return ab.i - cd.i;
}

#endif

int main() { return fu_MAIN(); }

========

        // a can alias b
        // c can alias d
        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)
            ab_cd_inner(a, b, c, d);

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd_outer(ab, cd, ab, cd); 

            return ab - cd;
        }

---- <fail> ----
[2m[0m_0[2m.fu 19:33+2[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ab_cd_outer(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab - cd;[0m

	At call to [35;3mfn[0m [94;1mab_cd_outer[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mab_cd_outer[0m:[94;1mc[0m and
	    1:	[35;3mref arg[0m [94;1mab_cd_outer[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mab[0m at [2m15:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   15 | [0m            mut [31;1mab[0m = 0;
[2m      |             mut cd = 0;[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mab_cd_outer[0m:[94;1mc[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mab_cd_outer[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m14:12+4[0m

========

        // a can alias b
        // c can alias d
        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)
            ab_cd_inner(a, b, c, d);

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd_outer(ab, ab, cd, cd); 

            return ab - cd;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void ab_cd_inner_MbR9(/*3:3*/ int& a, /*3:3*/ int& b, /*F:F*/ int& c, /*F:F*/ int& d)
{
    int& /*a|b*/ ab = (a ? a : b);
    int& /*c|d*/ cd = (c ? c : d);
    ++++ab;
    ++++cd;
}

static void ab_cd_outer_MbR9(/*3:3*/ int& a, /*3:3*/ int& b, /*F:C*/ int& c, /*F:C*/ int& d)
{
    ab_cd_inner_MbR9(a, b, c, d);
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    ab_cd_outer_MbR9(ab, ab, cd, cd);
    return ab - cd;
}

#endif

int main() { return fu_MAIN(); }

========

        // a can alias b
        // c can alias d
        // e can alias f
        // g can alias h
        noinline fn abcd_efgh(
            ref a: i32, ref b: i32, ref c: i32, ref d: i32,
            ref e: i32, ref f: i32, ref g: i32, ref h: i32)
        {
            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;
            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;
            ++++abcd; ++++ab; ++++cd;
            ++++efgh; ++++ef; ++++gh;
        }

        fn main() {
            mut ab = 0; mut cd = 0;
            mut ef = 0; mut gh = 0;


            abcd_efgh(ab, ab, cd, gh, ef, ef, cd, gh); 

            return (ab + cd) - (ef + gh);
        }

---- <fail> ----
[2m[0m_0[2m.fu 21:47+2[0m:

[2m      | [0m
[2m      | [0m
[2m   21 | [0m            abcd_efgh(ab, ab, cd, gh, ef, ef, [31;1mcd[0m, gh); 
[2m      | [0m
[2m      |             return (ab + cd) - (ef + gh);[0m

	At call to [35;3mfn[0m [94;1mabcd_efgh[0m, arguments:

	    7:	[35;3mref arg[0m [94;1mabcd_efgh[0m:[94;1mg[0m and
	    3:	[35;3mref arg[0m [94;1mabcd_efgh[0m:[94;1mc[0m

	    both alias:

	    [35;3mmut[0m [94;1mcd[0m at [2m17:29+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut ab = 0; mut [31;1mcd[0m = 0;
[2m      |             mut ef = 0; mut gh = 0;[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mabcd_efgh[0m:[94;1mg[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mabcd_efgh[0m:[94;1mc[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        // a can alias b
        // c can alias d
        // e can alias f
        // g can alias h
        noinline fn abcd_efgh(
            ref a: i32, ref b: i32, ref c: i32, ref d: i32,
            ref e: i32, ref f: i32, ref g: i32, ref h: i32)
        {
            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;
            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;
            ++++abcd; ++++ab; ++++cd;
            ++++efgh; ++++ef; ++++gh;
        }

        fn main() {
            mut ab = 0; mut cd = 0;
            mut ef = 0; mut gh = 0;


            abcd_efgh(ab, ab, cd, cd, ef, ef, gh, gh); 

            return (ab + cd) - (ef + gh);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void abcd_efgh_MbR9(/*3:3*/ int& a, /*3:3*/ int& b, /*C:C*/ int& c, /*C:C*/ int& d, /*F3:F3*/ int& e, /*F3:F3*/ int& f, /*FC:FC*/ int& g, /*FC:FC*/ int& h)
{
    int& /*a|b*/ ab = (a ? a : b);
    int& /*c|d*/ cd = (c ? c : d);
    int& /*cd|ab*/ abcd = (ab ? ab : cd);
    int& /*e|f*/ ef = (e ? e : f);
    int& /*g|h*/ gh = (g ? g : h);
    int& /*gh|ef*/ efgh = (ef ? ef : gh);
    ++++abcd;
    ++++ab;
    ++++cd;
    ++++efgh;
    ++++ef;
    ++++gh;
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    int ef = 0;
    int gh = 0;
    abcd_efgh_MbR9(ab, ab, cd, cd, ef, ef, gh, gh);
    return (ab + cd) - (ef + gh);
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {
            ref x = a || b; ++x;
            ref y = b || a; ++y;                                // N_AARSoftRisk
        }

        fn main() {
            mut a = 0;


            ref b = a;
            incr_a_or_b_and_b_or_a(a, b);


            return a - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void incr_a_or_b_and_b_or_a_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    int& /*a|b*/ x = (a ? a : b);
    ++x;
    int& /*a|b*/ y = (b ? b : a);
    ++y;
}

int fu_MAIN()
{
    int a = 0;
    incr_a_or_b_and_b_or_a_MbR9(a, a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

========

        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {
            ref x = a || b; ++x;
            ref y = b || a; ++y;                                // N_AARSoftRisk
        }

        fn main() {
            mut a = 0;


            incr_a_or_b_and_b_or_a(a, a);


            return a - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void incr_a_or_b_and_b_or_a_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    int& /*a|b*/ x = (a ? a : b);
    ++x;
    int& /*a|b*/ y = (b ? b : a);
    ++y;
}

int fu_MAIN()
{
    int a = 0;
    incr_a_or_b_and_b_or_a_MbR9(a, a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

========

        // same as below -
        //  but using a helper variable
        //   which provides a "name" for the outcome of a|b.
        noinline fn incr_a_or_b_by2_via_x(ref a: i32, ref b: i32) {
            ref x = a || b;
            ++++x;
        }

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2_via_x(Z, B); // incr B, now 2
            incr_a_or_b_by2_via_x(A, B); // incr A, now 4
            incr_a_or_b_by2_via_x(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void incr_a_or_b_by2_via_x_MbR9(/*3:3*/ int& a, /*3:3*/ int& b)
{
    int& /*a|b*/ x = (a ? a : b);
    ++++x;
}

int fu_MAIN()
{
    int Z = 0;
    int A = 2;
    int B = 0;
    incr_a_or_b_by2_via_x_MbR9(Z, B);
    incr_a_or_b_by2_via_x_MbR9(A, B);
    incr_a_or_b_by2_via_x_MbR9(B, B);
    return ((100 * A) + B) - 404;
}

#endif

int main() { return fu_MAIN(); }

========

        // same as above -
        //  but notice we increment twice, which breaks current setup.
        noinline fn incr_a_or_b_by2(ref a: i32, ref b: i32)
            ++++(a || b);

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2(Z, B); // incr B, now 2
            incr_a_or_b_by2(A, B); // incr A, now 4
            incr_a_or_b_by2(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int incr_a_or_b_by2_GL0m(/*3:3*/ int& a, /*3:3*/ int& b)
{
    return ++++(a ? a : b);
}

int fu_MAIN()
{
    int Z = 0;
    int A = 2;
    int B = 0;
    incr_a_or_b_by2_GL0m(Z, B);
    incr_a_or_b_by2_GL0m(A, B);
    incr_a_or_b_by2_GL0m(B, B);
    return ((100 * A) + B) - 404;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn alias(ref arr: i32[], ref item: i32) {
            arr ~= 1;
            return item;
        }

        fn main() {
            mut a = [ 0 ];

            ref c = alias(a, a[0]);

            return c++;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:21+5[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = [31;1malias[0m(a, a[0]);
[2m      | [0m
[2m      |             return c++;[0m

	At call to [35;3mfn[0m [94;1malias[0m, binding for [35;3mref arg[0m [94;1malias[0m:[94;1marr[0m (arg #0) at [2m10:27+1[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = alias([31;1ma[0m, a[0]);
[2m      | [0m
[2m      |             return c++;[0m

	... invalidated by subsequent write to [35;3mmut[0m [94;1ma[0m upon evaluation of [35;3mref arg[0m [94;1malias[0m:[94;1mitem[0m (arg #1) at [2m10:31+1[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = alias(a, a[31;1m[[0m0]);
[2m      | [0m
[2m      |             return c++;[0m

	At call to [35;3m__native[0m [94;1m.mutref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        noinline fn alias(ref arr: i32[], ref item: i32) {
            arr ~= 1;
            return item;
        }

        fn main() {
            mut a = [ 0 ];

            mut b = [ 0 ];
            ref c = alias(a, b[0]);

            return c++;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& alias_MbR9(/*3:1*/ fu::vec_range_mut<int> arr, /*3:3*/ int& item)
{
    arr += 1;
    return item;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::vec<int> b = fu::vec<int> {{ 0 }};
    int& /*b|static*/ c = alias_MbR9(a, b.mutref(0));
    return c++;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            ref cc = bb || aa;     // Mustn't compile.
            return cc;
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- <fail> ----
[2m[0m_0[2m.fu 7:28+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    7 | [0m            ref cc = bb || [31;1maa[0m;     // Mustn't compile.
[2m      |             return cc;[0m
[2m      |         }[0m

	Cannot access [35;3mmut ref[0m [94;1maa[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m6:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    6 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             ref cc = bb || aa;     // Mustn't compile.[0m
[2m      |             return cc;[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            ref cc = bb || aa;     // Mustn't compile.
            return cc;
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int aa_kGbb(/*1:1*/ fu::view<int> a)
{
    return a[0];
}

static int test_kGbb(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    const int /*b|static*/ bb = b[0];
    a += 1;
    const int /*bb|a|static*/ cc = (bb ? bb : aa_kGbb(a));
    return cc;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::vec<int> b = fu::vec<int> {{ 0 }};
    return test_kGbb(a, b);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return bb || aa;       // Same as above, but no explicit binding.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- <fail> ----
[2m[0m_0[2m.fu 7:26+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    7 | [0m            return bb || [31;1maa[0m;       // Same as above, but no explicit binding.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1maa[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m6:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    6 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return bb || aa;       // Same as above, but no explicit binding.[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m2:21+4[0m

========

        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return bb || aa;       // Same as above, but no explicit binding.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int aa_kGbb(/*1:1*/ fu::view<int> a)
{
    return a[0];
}

static int test_kGbb(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    const int /*b|static*/ bb = b[0];
    a += 1;
    return bb ? bb : aa_kGbb(a);
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::vec<int> b = fu::vec<int> {{ 0 }};
    return test_kGbb(a, b);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn noop(x) x;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return noop(bb || aa); // Same as above, but bound at callsite.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- <fail> ----
[2m[0m_0[2m.fu 8:31+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    8 | [0m            return noop(bb || [31;1maa[0m); // Same as above, but bound at callsite.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1maa[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m7:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    7 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return noop(bb || aa); // Same as above, but bound at callsite.[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m3:21+4[0m

========

        noinline fn noop(x) x;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return noop(bb || aa); // Same as above, but bound at callsite.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int aa_kGbb(/*1:1*/ fu::view<int> a)
{
    return a[0];
}

                                #ifndef DEF_noop_0DCJaE9X1mk
                                #define DEF_noop_0DCJaE9X1mk
inline static int noop_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

static int test_MbR9(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    const int /*b|static*/ bb = b[0];
    a += 1;
    return noop_0DCJ((bb ? bb : aa_kGbb(a)));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::vec<int> b = fu::vec<int> {{ 0 }};
    return test_MbR9(a, b);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn either(a, b) a || b;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return either(bb, aa); // For completeness.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- <fail> ----
[2m[0m_0[2m.fu 8:31+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    8 | [0m            return either(bb, [31;1maa[0m); // For completeness.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1maa[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1ma[0m at [2m7:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    7 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return either(bb, aa); // For completeness.[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m3:21+4[0m

========

        noinline fn either(a, b) a || b;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn aa()  a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return either(bb, aa); // For completeness.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int aa_kGbb(/*1:1*/ fu::view<int> a)
{
    return a[0];
}

                                #ifndef DEF_either_PagCOgmFbZj
                                #define DEF_either_PagCOgmFbZj
inline static int either_PagC(/*3:3*/ const int a, /*3:3*/ const int b)
{
    return a ? a : b;
}
                                #endif

static int test_MbR9(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    const int /*b|static*/ bb = b[0];
    a += 1;
    return either_PagC(bb, aa_kGbb(a));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::vec<int> b = fu::vec<int> {{ 0 }};
    return test_MbR9(a, b);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn what(ref cond: i32, ref cons: i32)
            cond && (cons += 1);

        fn main() {
            mut x = 1;
            return what(x, x) - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int what_kGbb(/*3:3*/ const int cond, /*3:3*/ int& cons)
{
    return !cond ? cond : (cons += 1);
}

int fu_MAIN()
{
    int x = 1;
    return what_kGbb(x, x) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Target {
            overload: i32[];
            extended: i32[];
        };

        noinline fn which(ref t: Target, i: i32) i & 1
            ? t.overload
            : t.extended;

        fn test(ref target: Target) {
            ref overload = target.which(target.overload.len);
            ref extended = target.which(target.overload.len + 1);

            mut change = false;
            if (overload) {
                for (mut i = 0; i < overload.len; i++) {
                    let a = overload[i];
                    let b = extended[i];
                    if (a != b) {
                        change = true;
                        break;
                    }
                }
            }

            if (change) {
                extended[0] = 3;

                shadow ref overload = target.which(target.overload.len);
                overload[0] = 5; // Said write to overload invalidates ext on next loop iter.
            }
        }

        fn main() {
            mut target = Target([ 0 ], [ 1 ]);
            target.test();
            return target.overload[0] * 10 + target.extended[0] * 100 - 350;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Target_mH3X;

                                #ifndef DEF_Target_mH3Xa3ceKJl
                                #define DEF_Target_mH3Xa3ceKJl
struct Target_mH3X
{
                                // shape_hash:    4f6f0c0b7d8a13df
                                // non_triv_mask: 0008000000000100
    fu::vec<int> overload;
    fu::vec<int> extended;
    explicit operator bool() const noexcept
    {
        return false
            || overload
            || extended
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<int> which_haRm(/*3:3*/ const Target_mH3X& t, const int i)
{
    if (i & 1)
        return t.overload;
    else
        return t.extended;

}

static fu::view_mut<int> which_GL0m(/*3:3*/ Target_mH3X& t, const int i)
{
    if (i & 1)
        return t.overload;
    else
        return t.extended;

}

static void test_MbR9(/*1:1*/ Target_mH3X& target)
{
    fu::view<int> /*target*/ overload = which_haRm(target, target.overload.size());
    fu::view_mut<int> /*target*/ extended = which_GL0m(target, (target.overload.size() + 1));
    bool change = false;
    if (overload)
    {
        for (int i = 0; i < overload.size(); i++)
        {
            const int /*overload|static*/ a = overload[i];
            const int /*extended|static*/ b = extended[i];
            if (a != b)
            {
                change = true;
                break;
            };
        };
    };
    if (change)
    {
        extended.mutref(0) = 3;
        fu::view_mut<int> /*target*/ overload_1 = which_GL0m(target, target.overload.size());
        overload_1.mutref(0) = 5;
    };
}

int fu_MAIN()
{
    Target_mH3X target = Target_mH3X { fu::vec<int> {{ 0 }}, fu::vec<int> {{ 1 }} };
    test_MbR9(target);
    return ((target.overload[0] * 10) + (target.extended[0] * 100)) - 350;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);


            ref a = ab.b;
            ref b = ab.b;

            test(a, b);

            return ab.b - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:21+1[0m:

[2m      |             ref b = ab.b;[0m
[2m      | [0m
[2m   16 | [0m            test(a, [31;1mb[0m);
[2m      | [0m
[2m      |             return ab.b - 5;[0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mab[0m at [2m10:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   10 | [0m            mut [31;1mab[0m = AB(1, 2);
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);


            ref a = ab.a;
            ref b = ab.a;

            test(a, b);

            return ab.b - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:21+1[0m:

[2m      |             ref b = ab.a;[0m
[2m      | [0m
[2m   16 | [0m            test(a, [31;1mb[0m);
[2m      | [0m
[2m      |             return ab.b - 5;[0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mab[0m at [2m10:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   10 | [0m            mut [31;1mab[0m = AB(1, 2);
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);


            test(ab.a, ab.b);


            return ab.b - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    a += b;
    b += a;
}

int fu_MAIN()
{
    AB_kiW0 ab = AB_kiW0 { 1, 2 };
    test_MbR9(ab.a, ab.b);
    return ab.b - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);


            ref a = ab.a;
            test(a, ab.b);


            return ab.b - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    a += b;
    b += a;
}

int fu_MAIN()
{
    AB_kiW0 ab = AB_kiW0 { 1, 2 };
    int& /*ab*/ a = ab.a;
    test_MbR9(a, ab.b);
    return ab.b - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);


            ref a = ab.a;
            ref b = ab.b;
            test(a, b);


            return ab.b - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*3:1*/ int& a, /*3:3*/ int& b)
{
    a += b;
    b += a;
}

int fu_MAIN()
{
    AB_kiW0 ab = AB_kiW0 { 1, 2 };
    int& /*ab*/ a = ab.a;
    int& /*ab*/ b = ab.b;
    test_MbR9(a, b);
    return ab.b - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn outer() {
            mut sum = 0;
            mut x = 1;
            for (;;) {      // bck complained that the write to 'x' at the end
                let v = x;  //  invalidates use of 'v' on next loop iter here, which is not true
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return sum;
                }

                x = v * 2;
            }
        }

        fn main() outer - 42;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int outer_MbR9()
{
    int sum = 0;
    int x = 1;
    for (; ; )
    {
        const int /*x*/ v = x;
        for (int i = 0; i < 10; i++)
        {
            sum += v;
            if (sum > 40)
                return sum;

        };
        x = (v * 2);
    };
}

int fu_MAIN()
{
    return outer_MbR9() - 42;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn append_self(ref a: i32[]) {
            let b = a;
            a ~= b; // b narrowed down to a slice which is non-copyable
                    //  but it (unfortunately) wanted to copy to a temp.
        }

        fn main() {
            mut arr = [1, 2];
            arr.append_self();
            return arr[2] + arr[3] - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void append_self_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    fu::vec<int> b = fu::vec<int>(a);
    a += b;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2 }};
    append_self_MbR9(arr);
    return (arr[2] + arr[3]) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


        pure 
        struct X { x: i32 };
        fn main() X(0).x;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:9+4[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        [31;1mpure[0m 
[2m      |         struct X { x: i32 };[0m
[2m      |         fn main() X(0).x;[0m

	Invalid annotation: not a [35;3mfn[0m declaration.

========


        struct X { x: i32 };
        fn main() X(0).x;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_GlLV;

                                #ifndef DEF_X_GlLVSBH0iih
                                #define DEF_X_GlLVSBH0iih
struct X_GlLV
{
                                // shape_hash:    4bfe9f2a4961279c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return X_GlLV { 0 }.x;
}

#endif

int main() { return fu_MAIN(); }

========

        fn but_is_it_pure(ref x: i32) {

            return x++; 
        }
        pure noinline fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:9+4[0m [2m6:38+1[0m:

[2m      |             return x++; [0m
[2m      |         }[0m
[2m    6 | [0m        [31;1mpure[0m noinline fn pure_fn(ref [31;1ma[0m: i32, ref b: i32) {
[2m      |             ref x = a || b;[0m
[2m      |             return but_is_it_pure(x);[0m

	[35;3mfn[0m [94;1mpure_fn[0m is not pure, writes to [35;3mmut ref arg[0m [94;1ma[0m:

            via [35;3mfn[0m [94;1mbut_is_it_pure[0m at [2m8:20+14[0m:

[2m      |         pure noinline fn pure_fn(ref a: i32, ref b: i32) {[0m
[2m      |             ref x = a || b;[0m
[2m    8 | [0m            return [31;1mbut_is_it_pure[0m(x);
[2m      |         }[0m
[2m      |         fn main() {[0m

            via [35;3m__native[0m [94;1mpostfix++[0m at [2m4:21+2[0m:

[2m      |         fn but_is_it_pure(ref x: i32) {[0m
[2m      | [0m
[2m    4 | [0m            return x[31;1m++[0m; 
[2m      |         }[0m
[2m      |         pure noinline fn pure_fn(ref a: i32, ref b: i32) {[0m


       RelaxMut [35;3mfn[0m [94;1mpure_fn[0m([35;3mi32[0m, [35;3mi32[0m) at [2m6:26+7[0m

========

        fn but_is_it_pure(ref x: i32) {

            return x++; 
        }
        pure   inline fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:9+4[0m [2m6:50+1[0m:

[2m      |             return x++; [0m
[2m      |         }[0m
[2m    6 | [0m        [31;1mpure[0m   inline fn pure_fn(ref a: i32, ref [31;1mb[0m: i32) {
[2m      |             ref x = a || b;[0m
[2m      |             return but_is_it_pure(x);[0m

	[35;3minline[0m [94;1mpure_fn[0m is not pure, writes to [35;3mmut ref[0m [94;1mpure_fn:b[0m:

            via [35;3mfn[0m [94;1mbut_is_it_pure[0m at [2m8:20+14[0m:

[2m      |         pure   inline fn pure_fn(ref a: i32, ref b: i32) {[0m
[2m      |             ref x = a || b;[0m
[2m    8 | [0m            return [31;1mbut_is_it_pure[0m(x);
[2m      |         }[0m
[2m      |         fn main() {[0m

            via [35;3m__native[0m [94;1mpostfix++[0m at [2m4:21+2[0m:

[2m      |         fn but_is_it_pure(ref x: i32) {[0m
[2m      | [0m
[2m    4 | [0m            return x[31;1m++[0m; 
[2m      |         }[0m
[2m      |         pure   inline fn pure_fn(ref a: i32, ref b: i32) {[0m


       RelaxMut [35;3mfn[0m [94;1mmain[0m at [2m10:12+4[0m

========

        fn but_is_it_pure(ref x: i32) {

            return x;   
        }
        pure noinline fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int but_is_it_pure_kGbb(/*1:1*/ const int x)
{
    return x;
}

static int pure_fn_kGbb(/*3:3*/ const int a, /*3:3*/ const int b)
{
    const int /*a|b*/ x = (a ? a : b);
    return but_is_it_pure_kGbb(x);
}

int fu_MAIN()
{
    const int x = 0;
    const int y = 0;
    return pure_fn_kGbb(x, y);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn but_is_it_pure(ref x: i32) {

            return x;   
        }
        pure   inline fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int but_is_it_pure_kGbb(/*1:1*/ const int x)
{
    return x;
}

int fu_MAIN()
{
    const int x = 0;
    const int y = 0;
    const int /*x*/ a = x;
    const int /*y*/ b = y;
    const int /*b|a*/ x_1 = (a ? a : b);
    return but_is_it_pure_kGbb(x_1);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Map { index: int[]; data: int[] }

        pure fn Verify(ref map: Map) {
            mut count = 0
            for (mut i = 0; i < map.index.len; i++) {

                ref data_pos = map.index[i]
                while (data_pos > 0 && data_pos <= map.data.len) {
                    data_pos = map.data[data_pos - 1]
                    count++
                }
            }

            return count
        }

        fn main() { mut m: Map; m.Verify }

---- <fail> ----
[2m[0m_0[2m.fu 4:9+4[0m [2m4:28+3[0m:

[2m      |         struct Map { index: int[]; data: int[] }[0m
[2m      | [0m
[2m    4 | [0m        [31;1mpure[0m fn Verify(ref [31;1mmap[0m: Map) {
[2m      |             mut count = 0[0m
[2m      |             for (mut i = 0; i < map.index.len; i++) {[0m

	[35;3mfn[0m [94;1mVerify[0m is not pure, writes to [35;3mmut ref arg[0m [94;1mmap[0m:

            via [35;3m__native[0m [94;1m=[0m at [2m10:30+1[0m:

[2m      |                 ref data_pos = map.index[i][0m
[2m      |                 while (data_pos > 0 && data_pos <= map.data.len) {[0m
[2m   10 | [0m                    data_pos [31;1m=[0m map.data[data_pos - 1]
[2m      |                     count++[0m
[2m      |                 }[0m


       RelaxMut [35;3mfn[0m [94;1mVerify[0m([94;1mMap[0m) at [2m4:17+6[0m

========

        struct Map { index: int[]; data: int[] }

        pure fn Verify(ref map: Map) {
            mut count = 0
            for (mut i = 0; i < map.index.len; i++) {

                mut data_pos = map.index[i]
                while (data_pos > 0 && data_pos <= map.data.len) {
                    data_pos = map.data[data_pos - 1]
                    count++
                }
            }

            return count
        }

        fn main() { mut m: Map; m.Verify }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Map_fMh5;

                                #ifndef DEF_Map_fMh5bMpOri0
                                #define DEF_Map_fMh5bMpOri0
struct Map_fMh5
{
                                // shape_hash:    bb0b8ce677147730
                                // non_triv_mask: 0008000000000080
    fu::vec<int> index;
    fu::vec<int> data;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Verify_MbR9(/*1:1*/ const Map_fMh5& map)
{
    int count = 0;
    for (int i = 0; i < map.index.size(); i++)
    {
        int data_pos = map.index[i];
        while ((data_pos > 0) && (data_pos <= map.data.size()))
        {
            data_pos = map.data[(data_pos - 1)];
            count++;
        };
    };
    return count;
}

int fu_MAIN()
{
    Map_fMh5 m {};
    return Verify_MbR9(m);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn inner(ref x: i32, n: i32) {
            return outer(x, n);
        }

        noinline fn report_write_here(ref x: i32, n: i32) {

            return x += n;                             
        }

        noinline fn outer(ref x: i32, n: i32) {
            if (n & 3) {
                if (n & 2)
                    return inner(x, n / 2);
                else
                    return report_write_here(x, n);
            }
            else {
                return inner(x, n + 1);
            }
        }

        pure fn not_pure(ref x: i32, n: i32) {
            return outer(x, n);
        }

        fn main() {
            mut x = 0;
            return not_pure(x, 0) == 1 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:9+4[0m [2m23:30+1[0m:

[2m      |         }[0m
[2m      | [0m
[2m   23 | [0m        [31;1mpure[0m fn not_pure(ref [31;1mx[0m: i32, n: i32) {
[2m      |             return outer(x, n);[0m
[2m      |         }[0m

	[35;3mfn[0m [94;1mnot_pure[0m is not pure, writes to [35;3mmut ref arg[0m [94;1mx[0m:

            via [35;3mfn[0m [94;1mouter[0m at [2m24:20+5[0m:

[2m      | [0m
[2m      |         pure fn not_pure(ref x: i32, n: i32) {[0m
[2m   24 | [0m            return [31;1mouter[0m(x, n);
[2m      |         }[0m
[2m      | [0m

            via [35;3mfn[0m [94;1mreport_write_here[0m at [2m16:28+17[0m:

[2m      |                     return inner(x, n / 2);[0m
[2m      |                 else[0m
[2m   16 | [0m                    return [31;1mreport_write_here[0m(x, n);
[2m      |             }[0m
[2m      |             else {[0m

            via [35;3m__native[0m [94;1m+=[0m at [2m8:22+2[0m:

[2m      |         noinline fn report_write_here(ref x: i32, n: i32) {[0m
[2m      | [0m
[2m    8 | [0m            return x [31;1m+=[0m n;                             
[2m      |         }[0m
[2m      | [0m


       RelaxMut [35;3mfn[0m [94;1mnot_pure[0m([35;3mi32[0m, [35;3mi32[0m) at [2m23:17+8[0m

========

        noinline fn inner(ref x: i32, n: i32) {
            return outer(x, n);
        }

        noinline fn report_write_here(ref x: i32, n: i32) {

            return x + n;                              
        }

        noinline fn outer(ref x: i32, n: i32) {
            if (n & 3) {
                if (n & 2)
                    return inner(x, n / 2);
                else
                    return report_write_here(x, n);
            }
            else {
                return inner(x, n + 1);
            }
        }

        pure fn not_pure(ref x: i32, n: i32) {
            return outer(x, n);
        }

        fn main() {
            mut x = 0;
            return not_pure(x, 0) == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int outer_MbR9(int, int);

#ifndef fu_NO_fdefs

static int inner_MbR9(/*3:3*/ const int x, const int n)
{
    return outer_MbR9(x, n);
}

static int report_write_here_MbR9(/*3:3*/ const int x, const int n)
{
    return x + n;
}

static int outer_MbR9(/*3:3*/ const int x, const int n)
{
    if (n & 3)
    {
        if (n & 2)
            return inner_MbR9(x, (n / 2));
        else
            return report_write_here_MbR9(x, n);

    }
    else
        return inner_MbR9(x, (n + 1));

}

static int not_pure_MbR9(/*3:3*/ const int x, const int n)
{
    return outer_MbR9(x, n);
}

int fu_MAIN()
{
    const int x = 0;
    if (not_pure_MbR9(x, 0) == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info ? i : [];
                }

                return reason;
            }

            return fail.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_w1za(reason, fu::i64dec((info ? i : 0)));
    };
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_MbR9(fu::str(""_fu), _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info ? i : [];
                }

                return reason;
            }

            return fail.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_w1za(reason, fu::i64dec((info ? i : 0)));
    };
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_MbR9(fu::str{}, _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info && i;
                }

                return reason;
            }

            return fail.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_w1za(reason, fu::i64dec((info ? i : 0)));
    };
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_MbR9(fu::str(""_fu), _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info && i;
                }

                return reason;
            }

            return fail.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_w1za(reason, fu::i64dec((info ? i : 0)));
    };
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_MbR9(fu::str{}, _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info ? ("" ~ info) : [];
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_rA00(""_view, fu::i64dec(info)) : fu::str{});
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> {{ 101 }};
    return fail_MbR9(fu::str(""_fu), _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info ? ("" ~ info) : [];
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_rA00(fu::view<char>{}, fu::i64dec(info)) : fu::str{});
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> {{ 101 }};
    return fail_MbR9(fu::str{}, _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && ("" ~ info);
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_rA00(""_view, fu::i64dec(info)) : fu::str{});
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> {{ 101 }};
    return fail_MbR9(fu::str(""_fu), _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && ("" ~ info);
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_rA00(fu::view<char>{}, fu::i64dec(info)) : fu::str{});
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> {{ 101 }};
    return fail_MbR9(fu::str{}, _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_H(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_H(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(960) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Helpers_kmA1;

                                #ifndef DEF_Helpers_kmA1eyAmOc8
                                #define DEF_Helpers_kmA1eyAmOc8
struct Helpers_kmA1
{
                                // shape_hash:    0911798e2d2869f5
                                // non_triv_mask: 0008100000000000
    fu::vec<int> row;
    explicit operator bool() const noexcept
    {
        return false
            || row
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void solveNode_H_MbR9(/*7:7*/ const Helpers_kmA1& h, /*6:2*/ fu::vec_range_mut<Helpers_kmA1> _helpers, /*6:4*/ int& N)
{
    while (N % h.row[(h.row.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static int solveJump_MbR9(/*7:5*/ fu::vec_range_mut<Helpers_kmA1> _helpers, /*7:6*/ int& N, /*7:7*/ const int row)
{
    solveNode_H_MbR9(Helpers_kmA1(/*bck:vi 1*/ _helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_MbR9(/*7:5*/ fu::vec_range_mut<Helpers_kmA1> _helpers, int N, const int row)
{
    return solveJump_MbR9(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<Helpers_kmA1> _helpers = fu::vec<Helpers_kmA1> {{ Helpers_kmA1 { fu::vec<int> {{ 1, 2, 3, 4, 5 }} } }};
    return test_MbR9(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_HH_inner(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveNode_HH(h: Helpers) {
                return solveNode_HH_inner(h);
            }

            fn solveJump() {
                solveNode_HH(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(960) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Helpers_kmA1;

                                #ifndef DEF_Helpers_kmA1eyAmOc8
                                #define DEF_Helpers_kmA1eyAmOc8
struct Helpers_kmA1
{
                                // shape_hash:    0911798e2d2869f5
                                // non_triv_mask: 0008100000000000
    fu::vec<int> row;
    explicit operator bool() const noexcept
    {
        return false
            || row
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void solveNode_HH_inner_MbR9(/*7:7*/ const Helpers_kmA1& h, /*6:2*/ fu::vec_range_mut<Helpers_kmA1> _helpers, /*6:4*/ int& N)
{
    while (N % h.row[(h.row.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static void solveNode_HH_MbR9(/*7:7*/ const Helpers_kmA1& h, /*6:2*/ fu::vec_range_mut<Helpers_kmA1> _helpers, /*6:4*/ int& N)
{
    solveNode_HH_inner_MbR9(h, _helpers, N);
}

static int solveJump_MbR9(/*7:5*/ fu::vec_range_mut<Helpers_kmA1> _helpers, /*7:6*/ int& N, /*7:7*/ const int row)
{
    solveNode_HH_MbR9(Helpers_kmA1(/*bck:vi 1*/ _helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_MbR9(/*7:5*/ fu::vec_range_mut<Helpers_kmA1> _helpers, int N, const int row)
{
    return solveJump_MbR9(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<Helpers_kmA1> _helpers = fu::vec<Helpers_kmA1> {{ Helpers_kmA1 { fu::vec<int> {{ 1, 2, 3, 4, 5 }} } }};
    return test_MbR9(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn test(ref _helpers: i32[][], mut N: i32, row: i32)
        {
            fn solveNode_a(h: i32[]) {
                while (N % h[h.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_a(_helpers[row]); // We've relaxed to a view, which bck can't copy
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [[ 1, 2, 3, 4, 5 ]];
            return test(_helpers, row: 0, N: 4)
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(960) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void solveNode_a_MbR9(/*7:7*/ fu::view<int> h, /*6:2*/ fu::vec_range_mut<fu::vec<int>> _helpers, /*6:4*/ int& N)
{
    while (N % h[(h.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static int solveJump_MbR9(/*7:5*/ fu::vec_range_mut<fu::vec<int>> _helpers, /*7:6*/ int& N, /*7:7*/ const int row)
{
    solveNode_a_MbR9(fu::vec<int>(/*bck:vi 1*/ _helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_MbR9(/*7:5*/ fu::vec_range_mut<fu::vec<int>> _helpers, int N, const int row)
{
    return solveJump_MbR9(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> _helpers = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 1, 2, 3, 4, 5 }} }};
    return test_MbR9(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(ref args: Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //

            ref  badref = args[0];

            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }       // oct2021: now latest issue here is that
                //  this gets bcked AFTER jump lifetimes are unwound
                //   and it all looks as if everything's fine (lt badref == lt args).

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:20+6[0m:

[2m      | [0m
[2m      |             args = [ Arg(11) ]; // INVALIDATE badref.[0m
[2m   14 | [0m            return [31;1mbadref[0m;
[2m      |         }       // oct2021: now latest issue here is that[0m
[2m      |                 //  this gets bcked AFTER jump lifetimes are unwound[0m

	Cannot access [35;3mmut ref[0m [94;1mbadref[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1margs[0m at [2m13:18+1[0m:

[2m      |             ref  badref = args[0];[0m
[2m      | [0m
[2m   13 | [0m            args [31;1m=[0m [ Arg(11) ]; // INVALIDATE badref.
[2m      |             return badref;[0m
[2m      |         }       // oct2021: now latest issue here is that[0m

	At call to [35;3m__native[0m [94;1m=[0m

    BorrowCheck [35;3mfn[0m [94;1mmutargs[0m([94;1mArg[0m[35;3m[..][0m) at [2m5:12+7[0m

========

        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(ref args: Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //

            mut  badref = args[0];

            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }       // oct2021: now latest issue here is that
                //  this gets bcked AFTER jump lifetimes are unwound
                //   and it all looks as if everything's fine (lt badref == lt args).

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Arg_dyAv;

                                #ifndef DEF_Arg_dyAv3vKYb3h
                                #define DEF_Arg_dyAv3vKYb3h
struct Arg_dyAv
{
                                // shape_hash:    1b741b3c8320c96c
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Arg_dyAv mutargs_MbR9(/*1:1*/ fu::vec_range_mut<Arg_dyAv> args)
{
    const Arg_dyAv badref = args[0];
    args = fu::vec<Arg_dyAv> {{ Arg_dyAv { 11 } }};
    return badref;
}

int fu_MAIN()
{
    fu::vec<Arg_dyAv> args = fu::vec<Arg_dyAv> {{ Arg_dyAv { 7 } }};
    return mutargs_MbR9(args).i - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg)
            i[i.len - 1] * 4;

        fn mutargs(ref args: Arg[]) {

            ref  badref = args[0];

            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            return witharg(badref);
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

---- <fail> ----
[2m[0m_0[2m.fu 12:28+6[0m:

[2m      | [0m
[2m      |             args = [ Arg([ 11 ]) ]; // INVALIDATE badref.[0m
[2m   12 | [0m            return witharg([31;1mbadref[0m);
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1mbadref[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1margs[0m at [2m11:18+1[0m:

[2m      |             ref  badref = args[0];[0m
[2m      | [0m
[2m   11 | [0m            args [31;1m=[0m [ Arg([ 11 ]) ]; // INVALIDATE badref.
[2m      |             return witharg(badref);[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m=[0m

    BorrowCheck [35;3mfn[0m [94;1mmutargs[0m([94;1mArg[0m[35;3m[..][0m) at [2m7:12+7[0m

========

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg)
            i[i.len - 1] * 4;

        fn mutargs(ref args: Arg[]) {

            let  badref = args[0];

            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            return witharg(badref);
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Arg_qtsg;

                                #ifndef DEF_Arg_qtsgSAtwby4
                                #define DEF_Arg_qtsgSAtwby4
struct Arg_qtsg
{
                                // shape_hash:    038d293369643053
                                // non_triv_mask: 0008000000001000
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int witharg_MbR9(/*1:1*/ const Arg_qtsg& a)
{
    return a.i[(a.i.size() - 1)] * 4;
}

static int mutargs_MbR9(/*1:1*/ fu::vec_range_mut<Arg_qtsg> args)
{
    Arg_qtsg badref = args[0];
    args = fu::vec<Arg_qtsg> {{ Arg_qtsg { fu::vec<int> {{ 11 }} } }};
    return witharg_MbR9(badref);
}

int fu_MAIN()
{
    fu::vec<Arg_qtsg> args = fu::vec<Arg_qtsg> {{ Arg_qtsg { fu::vec<int> {{ 7 }} } }};
    return mutargs_MbR9(args) - 28;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg, x: i32)
            i[i.len - 1] * x;

        fn mutargs(ref args: Arg[]) {

            ref  badref = args[0];

            for (mut i = 0;; i++) {
                let ret = witharg(badref, i * 4);
                if (ret)
                    return ret;

                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            }
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:22+1[0m:

[2m      |                     return ret;[0m
[2m      | [0m
[2m   16 | [0m                args [31;1m=[0m [ Arg([ 11 ]) ]; // INVALIDATE badref.
[2m      |             }[0m
[2m      |         }[0m

	Write to [35;3mmut ref arg[0m [94;1margs[0m at call to [35;3m__native[0m [94;1m=[0m invalidates the use of [35;3mconst ref[0m [94;1mbadref[0m at [2m12:35+6[0m:

[2m      | [0m
[2m      |             for (mut i = 0;; i++) {[0m
[2m   12 | [0m                let ret = witharg([31;1mbadref[0m, i * 4);
[2m      |                 if (ret)[0m
[2m      |                     return ret;[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mmutargs[0m([94;1mArg[0m[35;3m[..][0m) at [2m7:12+7[0m

========

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg, x: i32)
            i[i.len - 1] * x;

        fn mutargs(ref args: Arg[]) {

            let  badref = args[0];

            for (mut i = 0;; i++) {
                let ret = witharg(badref, i * 4);
                if (ret)
                    return ret;

                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            }
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Arg_qtsg;

                                #ifndef DEF_Arg_qtsgSAtwby4
                                #define DEF_Arg_qtsgSAtwby4
struct Arg_qtsg
{
                                // shape_hash:    038d293369643053
                                // non_triv_mask: 0008000000001000
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int witharg_MbR9(/*3:3*/ const Arg_qtsg& a, const int x)
{
    return a.i[(a.i.size() - 1)] * x;
}

static int mutargs_MbR9(/*1:1*/ fu::vec_range_mut<Arg_qtsg> args)
{
    Arg_qtsg badref = args[0];
    for (int i = 0; ; i++)
    {
        const int ret = witharg_MbR9(badref, (i * 4));
        if (ret)
            return ret;
        else
        {
            args = fu::vec<Arg_qtsg> {{ Arg_qtsg { fu::vec<int> {{ 11 }} } }};
        };
    };
}

int fu_MAIN()
{
    fu::vec<Arg_qtsg> args = fu::vec<Arg_qtsg> {{ Arg_qtsg { fu::vec<int> {{ 7 }} } }};
    return mutargs_MbR9(args) - 28;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(ref woot: i32[], x: i32, y: i32) {
            ref b = woot[y];
            ref a = woot[x]; // the 'shadow ref' below ...
            if (a == 1) {


                a += 1;
            }
            else {
                b += 1; // ... and this should ignore cond write above.
            }
        }

        fn main() {
            mut x = [ -1, +1 ];
            test(x, 0, 1);
            return x[1] - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:17+1[0m:

[2m      |             }[0m
[2m      |             else {[0m
[2m   11 | [0m                [31;1mb[0m += 1; // ... and this should ignore cond write above.
[2m      |             }[0m
[2m      |         }[0m

	Cannot access [35;3mmut ref[0m [94;1mb[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mwoot[0m at [2m4:25+1[0m:

[2m      |         fn test(ref woot: i32[], x: i32, y: i32) {[0m
[2m      |             ref b = woot[y];[0m
[2m    4 | [0m            ref a = woot[31;1m[[0mx]; // the 'shadow ref' below ...
[2m      |             if (a == 1) {[0m
[2m      | [0m

	At call to [35;3m__native[0m [94;1m.mutref[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m, [35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(ref woot: i32[], x: i32, y: i32) {
            ref b = woot[y];
            ref a = woot[x]; // the 'shadow ref' below ...
            if (a == 1) {

                shadow ref a = woot[x]; // ... should relax 'ref a' above to a let ...

                a += 1;
            }
            else {
                b += 1; // ... and this should ignore cond write above.
            }
        }

        fn main() {
            mut x = [ -1, +1 ];
            test(x, 0, 1);
            return x[1] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*7:7*/ fu::view_mut<int> woot, const int x, const int y)
{
    int& /*woot|static*/ b = woot.mutref(y);
    const int /*woot|static*/ a = woot[x];
    if (a == 1)
    {
        int& /*woot|static*/ a_1 = woot.mutref(x);
        a_1 += 1;
    }
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> {{ -1, +1 }};
    test_MbR9(x, 0, 1);
    return x[1] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref a: i32[], ref b: i32[]) {

            if (a[0] == 1)

                a ~= 1;
            else
                b ~= 1;
        }

        fn main() {
            mut x = [ 1 ];
            test(x, x);
            return x.len - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*3:3*/ fu::vec_range_mut<int> a, /*3:3*/ fu::vec_range_mut<int> b)
{
    if (a[0] == 1)
        a += 1;
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> {{ 1 }};
    test_MbR9(x, x);
    return x.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref a: i32[], ref b: i32[]) {

            if (a[0]++ == 1)                                    // N_AARSoftRisk

                a ~= 1;
            else
                b ~= 1;
        }

        fn main() {
            mut x = [ 1 ];
            test(x, x);
            return x.len - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*3:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::vec_range_mut<int> b)
{
    if (a.mutref(0)++ == 1)
        a += 1;
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> {{ 1 }};
    test_MbR9(x, x);
    return x.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w: Woot) {
            ref x = w.x;

            ref y = w.x; 
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w = Woot([ 1, 2, 3, 4, 5, 6, 7 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            test(w);
            return w.x.len - 25;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:13+1[0m:

[2m      |             ref y = w.x; [0m
[2m      |             y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let[0m
[2m    9 | [0m            [31;1mx[0m ~= y;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mx[0m, reference invalidated by write to [35;3mmut ref[0m [94;1my[0m at [2m8:15+2[0m:

[2m      | [0m
[2m      |             ref y = w.x; [0m
[2m    8 | [0m            y [31;1m~=[0m y; // <- DONT RESOLVE BY COPY! ref can relax to let
[2m      |             x ~= y;[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([94;1mWoot[0m) at [2m4:12+4[0m

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w: Woot) {
            ref x = w.x;

            ref y = w.y; 
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w = Woot([ 1, 2, 3, 4, 5, 6, 7 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            test(w);
            return w.x.len - 25;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct Woot_Y6cy;

                                #ifndef DEF_Woot_Y6cy1104wF8
                                #define DEF_Woot_Y6cy1104wF8
struct Woot_Y6cy
{
                                // shape_hash:    0c2d6c4a4360bf46
                                // non_triv_mask: 1008000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    Woot_Y6cy(const Woot_Y6cy&) = delete;
    Woot_Y6cy(Woot_Y6cy&&) = default;
    Woot_Y6cy& operator=(const Woot_Y6cy&) = delete;
    Woot_Y6cy& operator=(Woot_Y6cy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ Woot_Y6cy& w)
{
    fu::vec<int>& /*w*/ x = w.x;
    fu::vec<int>& /*w*/ y = w.y;
    y += fu::vec<int>(/*bck:vi 0*/ y);
    x += y;
}

int fu_MAIN()
{
    Woot_Y6cy w = Woot_Y6cy { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7 }}, fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }} };
    test_MbR9(w);
    return w.x.size() - 25;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;

            ref y = w1.x; 
            y ~= y;
            x ~= x; // <- This is the only diff wrt test below, x ~= x vs x ~= y.
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut w: Woot;[0m
[2m   14 | [0m            test(w, [31;1mw[0m);
[2m      |             return w.x.len;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mw1[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mw0[0m

	    both alias:

	    [35;3mmut[0m [94;1mw[0m at [2m13:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   13 | [0m            mut [31;1mw[0m: Woot;
[2m      |             test(w, w);[0m
[2m      |             return w.x.len;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mw1[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWoot[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mw0[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWoot[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;

            ref y = w1.y; 
            y ~= y;
            x ~= x; // <- This is the only diff wrt test below, x ~= x vs x ~= y.
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct Woot_Y6cy;

                                #ifndef DEF_Woot_Y6cy1104wF8
                                #define DEF_Woot_Y6cy1104wF8
struct Woot_Y6cy
{
                                // shape_hash:    0c2d6c4a4360bf46
                                // non_triv_mask: 1008000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    Woot_Y6cy(const Woot_Y6cy&) = delete;
    Woot_Y6cy(Woot_Y6cy&&) = default;
    Woot_Y6cy& operator=(const Woot_Y6cy&) = delete;
    Woot_Y6cy& operator=(Woot_Y6cy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*3:3*/ Woot_Y6cy& w0, /*2:2*/ Woot_Y6cy& w1)
{
    fu::vec<int>& /*w0*/ x = w0.x;
    fu::vec<int>& /*w1*/ y = w1.y;
    y += fu::vec<int>(/*bck:vi 0*/ y);
    x += fu::vec<int>(/*bck:vi 0*/ x);
}

int fu_MAIN()
{
    Woot_Y6cy w {};
    test_MbR9(w, w);
    return w.x.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;

            ref y = w1.x;  // <- doesnt realize w0.x can't alias w1.y
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut w: Woot;[0m
[2m   14 | [0m            test(w, [31;1mw[0m);
[2m      |             return w.x.len;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mw1[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mw0[0m

	    both alias:

	    [35;3mmut[0m [94;1mw[0m at [2m13:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   13 | [0m            mut [31;1mw[0m: Woot;
[2m      |             test(w, w);[0m
[2m      |             return w.x.len;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mw1[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWoot[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mw0[0m is non-copyable: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mWoot[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========

        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;

            ref y = w1.y;  // <- doesnt realize w0.x can't alias w1.y
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct Woot_Y6cy;

                                #ifndef DEF_Woot_Y6cy1104wF8
                                #define DEF_Woot_Y6cy1104wF8
struct Woot_Y6cy
{
                                // shape_hash:    0c2d6c4a4360bf46
                                // non_triv_mask: 1008000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    Woot_Y6cy(const Woot_Y6cy&) = delete;
    Woot_Y6cy(Woot_Y6cy&&) = default;
    Woot_Y6cy& operator=(const Woot_Y6cy&) = delete;
    Woot_Y6cy& operator=(Woot_Y6cy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ Woot_Y6cy& w0, /*2:2*/ Woot_Y6cy& w1)
{
    fu::vec<int>& /*w0*/ x = w0.x;
    fu::vec<int>& /*w1*/ y = w1.y;
    y += fu::vec<int>(/*bck:vi 0*/ y);
    x += y;
}

int fu_MAIN()
{
    Woot_Y6cy w {};
    test_MbR9(w, w);
    return w.x.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn indexIntoImplicit(j: i32, implicit strings: string[]) strings[j];

        fn selfRecurBeforeImplicitDep(x: i32)
        {
            // On second solve we're talking about a region, but the argnode is gone.
            fn T(i: i32) selfRecurBeforeImplicitDep(i / 2);
            if (x > 1) return T(x);
            return indexIntoImplicit(x);
        }

        fn main() {
            let implicit strings = [ "a", "b" ];
            return selfRecurBeforeImplicitDep(2) == "b" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

static fu::vec_range<char> selfRecurBeforeImplicitDep_MbR9(int, fu::view<fu::str>);

#ifndef fu_NO_fdefs

static fu::vec_range<char> T_MbR9(const int i, /*3:3*/ fu::view<fu::str> strings)
{
    return selfRecurBeforeImplicitDep_MbR9((i / 2), strings);
}

static fu::vec_range<char> indexIntoImplicit_MbR9(const int j, /*3:3*/ fu::view<fu::str> strings)
{
    return strings[j];
}

static fu::vec_range<char> selfRecurBeforeImplicitDep_MbR9(const int x, /*3:3*/ fu::view<fu::str> strings)
{
    if (x > 1)
        return T_MbR9(x, strings);
    else
        return indexIntoImplicit_MbR9(x, strings);

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> strings = fu::vec<fu::str> {{ fu::str("a"_fu), fu::str("b"_fu) }};
    if (selfRecurBeforeImplicitDep_MbR9(2, strings) == "b"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========


        nocopy                 
        struct Type       { canon: string; };
        struct SolvedNode {  type: Type;   };

        fn solved(type: Type, implicit ref out: SolvedNode[]) {
            out.grow(out.len * 100 + 1);

            ref tail = out[out.len - 1];
            tail.type.canon = type.canon;
            return tail;
        }

        fn createMap(a: Type, b: Type): Type {
            return Type(a.canon ~ b.canon);
        }

        fn evalTypeAnnot(nodes: string[]): SolvedNode
        {
            fn T(i: i32)
                evalTypeAnnot([ nodes[i] ]).type;

            // Each T() call should invalidate the results from previous T() calls -
            //  so this shouldn't compile if Type is nocopy.
            if (nodes.len > 1)
                return solved(createMap(T(0), T(1)));

            return solved(Type(nodes[0]));
        }

        fn main() {
            implicit mut out: SolvedNode[];
            let annot = evalTypeAnnot([ "a", "b" ]);
            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 27:31+9[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved([31;1mcreateMap[0m(T(0), T(1)));
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	At call to [35;3mfn[0m [94;1mcreateMap[0m, binding for [35;3marg[0m [94;1mcreateMap[0m:[94;1ma[0m (arg #0) at [2m27:41+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved(createMap([31;1mT[0m(0), T(1)));
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	... invalidated by subsequent write to [35;3minjected implicit mut ref arg[0m [94;1mout[0m upon evaluation of [35;3marg[0m [94;1mcreateMap[0m:[94;1mb[0m (arg #1) at [2m27:47+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved(createMap(T(0), [31;1mT[0m(1)));
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	At call to [35;3mfn[0m [94;1mT[0m
            via [35;3mfn[0m [94;1mevalTypeAnnot[0m at [2m22:17+13[0m:

[2m      |         {[0m
[2m      |             fn T(i: i32)[0m
[2m   22 | [0m                [31;1mevalTypeAnnot[0m([ nodes[i] ]).type;
[2m      | [0m
[2m      |             // Each T() call should invalidate the results from previous T() calls -[0m

            via [35;3mfn[0m [94;1msolved[0m at [2m27:24+6[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return [31;1msolved[0m(createMap(T(0), T(1)));
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

            via [35;3m__native[0m [94;1m.grow[0m at [2m8:17+4[0m:

[2m      | [0m
[2m      |         fn solved(type: Type, implicit ref out: SolvedNode[]) {[0m
[2m    8 | [0m            out.[31;1mgrow[0m(out.len * 100 + 1);
[2m      | [0m
[2m      |             ref tail = out[out.len - 1];[0m


    BorrowCheck [35;3mfn[0m [94;1mevalTypeAnnot[0m([35;3mstring[0m[35;3m[..][0m, [94;1mSolvedNode[0m[35;3m[][0m) at [2m19:12+13[0m
                [2m...[0m

========


        struct Type       { canon: string; };
        struct SolvedNode {  type: Type;   };

        fn solved(type: Type, implicit ref out: SolvedNode[]) {
            out.grow(out.len * 100 + 1);

            ref tail = out[out.len - 1];
            tail.type.canon = type.canon;
            return tail;
        }

        fn createMap(a: Type, b: Type): Type {
            return Type(a.canon ~ b.canon);
        }

        fn evalTypeAnnot(nodes: string[]): SolvedNode
        {
            fn T(i: i32)
                evalTypeAnnot([ nodes[i] ]).type;

            // Each T() call should invalidate the results from previous T() calls -
            //  so this shouldn't compile if Type is nocopy.
            if (nodes.len > 1)
                return solved(createMap(T(0), T(1)));

            return solved(Type(nodes[0]));
        }

        fn main() {
            implicit mut out: SolvedNode[];
            let annot = evalTypeAnnot([ "a", "b" ]);
            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(264272) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_eNoB;
struct Type_KHQj;
static const Type_KHQj& T_kGbb(int, fu::view<fu::str>, fu::vec_range_mut<SolvedNode_eNoB>);

                                #ifndef DEF_Type_KHQjOZN2ya7
                                #define DEF_Type_KHQjOZN2ya7
struct Type_KHQj
{
                                // shape_hash:    094c9ebec00e3835
                                // non_triv_mask: 0000900000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_eNoBS6A3lh9
                                #define DEF_SolvedNode_eNoBS6A3lh9
struct SolvedNode_eNoB
{
                                // shape_hash:    44bb6d8e409061c6
                                // non_triv_mask: 0100900000000000
    Type_KHQj type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Type_KHQj createMap_MbR9(/*3:3*/ const Type_KHQj& a, /*3:3*/ const Type_KHQj& b)
{
    return Type_KHQj { (a.canon + b.canon) };
}

static SolvedNode_eNoB& solved_MbR9(/*3:3*/ const Type_KHQj& type, /*2:2*/ fu::vec_range_mut<SolvedNode_eNoB> out)
{
    out.grow(((out.size() * 100) + 1));
    SolvedNode_eNoB& /*out|static*/ tail = out.mutref((out.size() - 1));
    tail.type.canon = type.canon;
    return tail;
}

static SolvedNode_eNoB& evalTypeAnnot_MbR9(/*3:3*/ fu::view<fu::str> nodes, /*2:2*/ fu::vec_range_mut<SolvedNode_eNoB> out)
{
    if (nodes.size() > 1)
    {
        Type_KHQj _0 {};
        Type_KHQj _1 {};
        return (_1 = (_0 = Type_KHQj(/*bck:pra -2*/ T_kGbb(0, nodes, out)), createMap_MbR9(static_cast<Type_KHQj&&>(_0), T_kGbb(1, nodes, out))), solved_MbR9(static_cast<Type_KHQj&&>(_1), out));
    }
    else
    {
        return solved_MbR9(Type_KHQj { fu::str(nodes[0]) }, out);
    };
}

static const Type_KHQj& T_kGbb(const int i, /*7:7*/ fu::view<fu::str> nodes, /*7:7*/ fu::vec_range_mut<SolvedNode_eNoB> out)
{
    return evalTypeAnnot_MbR9(fu::view<fu::str> {{ fu::str(nodes[i]) }}, out).type;
}

static const SolvedNode_eNoB& solved_kGbb(/*3:3*/ const Type_KHQj& type, /*2:2*/ fu::vec_range_mut<SolvedNode_eNoB> out)
{
    out.grow(((out.size() * 100) + 1));
    SolvedNode_eNoB& /*out|static*/ tail = out.mutref((out.size() - 1));
    tail.type.canon = type.canon;
    return tail;
}

static const SolvedNode_eNoB& evalTypeAnnot_kGbb(/*3:3*/ fu::view<fu::str> nodes, /*2:2*/ fu::vec_range_mut<SolvedNode_eNoB> out)
{
    if (nodes.size() > 1)
    {
        Type_KHQj _0 {};
        Type_KHQj _1 {};
        return (_1 = (_0 = Type_KHQj(/*bck:pra -2*/ T_kGbb(0, nodes, out)), createMap_MbR9(static_cast<Type_KHQj&&>(_0), T_kGbb(1, nodes, out))), solved_kGbb(static_cast<Type_KHQj&&>(_1), out));
    }
    else
    {
        return solved_kGbb(Type_KHQj { fu::str(nodes[0]) }, out);
    };
}

int fu_MAIN()
{
    fu::vec<SolvedNode_eNoB> out {};
    const SolvedNode_eNoB& /*out|static*/ annot = evalTypeAnnot_kGbb(fu::view<fu::str> {{ fu::str("a"_fu), fu::str("b"_fu) }}, out);
    if ((out.size() == 10101) && (annot.type.canon.size() == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn main() {
            mut x = 0;
            let s = ++x + ++x;
            return s - 3; // Not 4! one arg must invalidate
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;
    int _0;
    const int s = (_0 = ++x, (_0 + ++x));
    return s - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========


        nocopy 
        struct X { x: i32; }
        fn sum(a: X, b: X) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn main() {
            mut x: X;
            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:20+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return [31;1msum[0m(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1msum[0m, binding for [35;3marg[0m [94;1msum[0m:[94;1ma[0m (arg #0) at [2m14:26+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return sum(x.[31;1mincr[0m, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;3mmut[0m [94;1mx[0m upon evaluation of [35;3marg[0m [94;1msum[0m:[94;1mb[0m (arg #1) at [2m14:34+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return sum(x.incr, x.[31;1mincr[0m) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mincr[0m
            via [35;3m__native[0m [94;1mpostfix++[0m at [2m8:16+2[0m:

[2m      | [0m
[2m      |         fn incr(ref x: X) {[0m
[2m    8 | [0m            x.x[31;1m++[0m;
[2m      |             return x;[0m
[2m      |         }[0m


    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========


        struct X { x: i32; }
        fn sum(a: X, b: X) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn main() {
            mut x: X;
            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_GlLV;

                                #ifndef DEF_X_GlLVSBH0iih
                                #define DEF_X_GlLVSBH0iih
struct X_GlLV
{
                                // shape_hash:    4bfe9f2a4961279c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const X_GlLV& incr_kGbb(/*1:1*/ X_GlLV& x)
{
    x.x++;
    return x;
}

static int sum_MbR9(/*3:3*/ const X_GlLV& a, /*3:3*/ const X_GlLV& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    X_GlLV x {};
    X_GlLV _0;
    return (_0 = X_GlLV(/*bck:pra 1*/ incr_kGbb(x)), sum_MbR9(static_cast<X_GlLV&&>(_0), incr_kGbb(x))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========


        nocopy 
        struct X { x: i32; }
        struct Y { y: X;   }

        fn x(y: Y) y.y.x;
        fn sum(a, b) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn incr(ref y: Y) {
            y.y.x++;
            return y;
        }

        fn main() {
            mut x: Y;
            ref y = x.y;
            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:20+3[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return [31;1msum[0m(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1msum[0m, binding for [35;3marg[0m [94;1msum[0m:[94;1ma[0m (arg #0) at [2m23:26+4[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return sum(y.[31;1mincr[0m, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;3mmut[0m [94;1mx[0m upon evaluation of [35;3marg[0m [94;1msum[0m:[94;1mb[0m (arg #1) at [2m23:34+4[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return sum(y.incr, x.[31;1mincr[0m) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mincr[0m
            via [35;3m__native[0m [94;1mpostfix++[0m at [2m16:18+2[0m:

[2m      | [0m
[2m      |         fn incr(ref y: Y) {[0m
[2m   16 | [0m            y.y.x[31;1m++[0m;
[2m      |             return y;[0m
[2m      |         }[0m


    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m20:12+4[0m

========


        struct X { x: i32; }
        struct Y { y: X;   }

        fn x(y: Y) y.y.x;
        fn sum(a, b) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn incr(ref y: Y) {
            y.y.x++;
            return y;
        }

        fn main() {
            mut x: Y;
            ref y = x.y;
            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Y_DiKb;
struct X_GlLV;

                                #ifndef DEF_X_GlLVSBH0iih
                                #define DEF_X_GlLVSBH0iih
struct X_GlLV
{
                                // shape_hash:    4bfe9f2a4961279c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Y_DiKbwtxUnpb
                                #define DEF_Y_DiKbwtxUnpb
struct Y_DiKb
{
                                // shape_hash:    387860527b394e48
                                // non_triv_mask: 0000000000000000
    X_GlLV y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const X_GlLV& incr_haRm(/*1:1*/ X_GlLV& x)
{
    x.x++;
    return x;
}

static const Y_DiKb& incr_GL0m(/*1:1*/ Y_DiKb& y)
{
    y.y.x++;
    return y;
}

static int x_MbR9(/*1:1*/ const Y_DiKb& y)
{
    return y.y.x;
}

                                #ifndef DEF_sum_5MTWcwATxFe
                                #define DEF_sum_5MTWcwATxFe
inline static int sum_5MTW(/*3:3*/ const X_GlLV& a, /*3:3*/ const Y_DiKb& b)
{
    return a.x + x_MbR9(b);
}
                                #endif

int fu_MAIN()
{
    Y_DiKb x {};
    X_GlLV& /*x*/ y = x.y;
    X_GlLV _0;
    return (_0 = X_GlLV(/*bck:pra 1*/ incr_haRm(y)), sum_5MTW(static_cast<X_GlLV&&>(_0), incr_GL0m(x))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========


        nocopy 
        struct X { x: i32; };

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn +=(a: X, b: X) {
            // Notice, this is not a real +=,
            //  just checking the order of eval here.
            return a.x + b.x;
        }

        fn test(ref x: X, ref y: X) {
            ref xy = y || x;
            return x.incr += xy.incr; // <- xy invalidated by x.incr
        }

        fn main() {
            mut x: X;
            mut y: X;
            return test(x, y) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 19:27+2[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.incr [31;1m+=[0m xy.incr; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1m+=[0m, binding for [35;3marg[0m [94;1m+=[0m:[94;1mb[0m (arg #1) at [2m19:33+4[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.incr += xy.[31;1mincr[0m; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;3mmut ref arg[0m [94;1mx[0m upon evaluation of [35;3marg[0m [94;1m+=[0m:[94;1ma[0m (arg #0) at [2m19:22+4[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.[31;1mincr[0m += xy.incr; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mincr[0m
            via [35;3m__native[0m [94;1mpostfix++[0m at [2m7:16+2[0m:

[2m      | [0m
[2m      |         fn incr(ref x: X) {[0m
[2m    7 | [0m            x.x[31;1m++[0m;
[2m      |             return x;[0m
[2m      |         }[0m


    BorrowCheck [35;3mfn[0m [94;1mtest[0m([94;1mX[0m, [94;1mX[0m) at [2m17:12+4[0m

========


        struct X { x: i32; };

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn +=(a: X, b: X) {
            // Notice, this is not a real +=,
            //  just checking the order of eval here.
            return a.x + b.x;
        }

        fn test(ref x: X, ref y: X) {
            ref xy = y || x;
            return x.incr += xy.incr; // <- xy invalidated by x.incr
        }

        fn main() {
            mut x: X;
            mut y: X;
            return test(x, y) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_GlLV;

                                #ifndef DEF_X_GlLVSBH0iih
                                #define DEF_X_GlLVSBH0iih
struct X_GlLV
{
                                // shape_hash:    4bfe9f2a4961279c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const X_GlLV& incr_kGbb(/*1:1*/ X_GlLV& x)
{
    x.x++;
    return x;
}

static int operator+=(/*3:3*/ const X_GlLV& a, /*3:3*/ const X_GlLV& b)
{
    return a.x + b.x;
}

static int test_MbR9(/*3:3*/ X_GlLV& x, /*3:2*/ X_GlLV& y)
{
    X_GlLV& /*x|y*/ xy = (y ? y : x);
    return (incr_kGbb(x) += X_GlLV(/*bck:pra -1*/ incr_kGbb(xy)));
}

int fu_MAIN()
{
    X_GlLV x {};
    X_GlLV y {};
    return test_MbR9(x, y) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct AB { a: i32[][]; b: i32[][]; };

        fn problematic_moves(mut ab: AB) {
            ref ra = ab.a;
            return ra.len & 1 ? ra[0] : ab.b[0];
        }

        fn main() {
            mut ab = AB(
                [[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]],
                [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]);

            mut pick = ab.problematic_moves;
            return pick[9] - ab.a[0][9];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct AB_yZJb;

                                #ifndef DEF_AB_yZJbXlqjcx4
                                #define DEF_AB_yZJbXlqjcx4
struct AB_yZJb
{
                                // shape_hash:    4578f02d37bc3d43
                                // non_triv_mask: 0008030000000000
    fu::vec<fu::vec<int>> a;
    fu::vec<fu::vec<int>> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> problematic_moves_MbR9(/*1:1*/ const AB_yZJb& ab)
{
    fu::view<fu::vec<int>> /*ab*/ ra = ab.a;
    if (ra.size() & 1)
        return fu::vec<int>(ra[0]);
    else
        return fu::vec<int>(ab.b[0]);

}

int fu_MAIN()
{
    AB_yZJb ab = AB_yZJb { fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }} }}, fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }} }} };
    fu::vec<int> pick = problematic_moves_MbR9(ab);
    return pick[9] - ab.a[0][9];
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========


        nocopy 
        struct NC { x: i32; y: i32 };

        fn wants_val(mut a: NC) {
            a.x++;
            a.y++;
            return a;
        }

        fn incr_by(mut a: NC, b: NC) {
            a.x += b.x;
            a.y += b.y;
            return a;
        }

        fn main() {
            mut v = NC(-1, -1);
            mut w = wants_val(v);
            return (w || v).x + 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:31+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut v = NC(-1, -1);[0m
[2m   20 | [0m            mut w = wants_val([31;1mv[0m);
[2m      |             return (w || v).x + 1;[0m
[2m      |         }[0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [94;1mv[0m [35;3mstruct[0m [94;1mNC[0m

	Cannot move: [35;3mlet[0m [94;1mv[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m18:12+4[0m

========


        struct NC { x: i32; y: i32 };

        fn wants_val(mut a: NC) {
            a.x++;
            a.y++;
            return a;
        }

        fn incr_by(mut a: NC, b: NC) {
            a.x += b.x;
            a.y += b.y;
            return a;
        }

        fn main() {
            mut v = NC(-1, -1);
            mut w = wants_val(v);
            return (w || v).x + 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NC_Et5k;

                                #ifndef DEF_NC_Et5khnyRVhh
                                #define DEF_NC_Et5khnyRVhh
struct NC_Et5k
{
                                // shape_hash:    2d826882988e069c
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NC_Et5k wants_val_MbR9(NC_Et5k&& a)
{
    a.x++;
    a.y++;
    return a;
}

int fu_MAIN()
{
    const NC_Et5k v = NC_Et5k { -1, -1 };
    const NC_Et5k w = wants_val_MbR9(NC_Et5k(v));
    return (w ? w : v).x + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct SolvedNode {
            items: SolvedNode[];
        };

        fn test(mut a: SolvedNode, mut b: SolvedNode) {

            ref n = a.items ? a : b;

            return n;
        }

        fn main() test([], []).items.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct SolvedNode_9NmD;

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = delete;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD&) = delete;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD test_MbR9(/*MOV*/ SolvedNode_9NmD&& a, /*MOV*/ SolvedNode_9NmD&& b)
{
    /*MOV*/ SolvedNode_9NmD& /*a|b*/ n = (a.items ? a : b);
    return static_cast<SolvedNode_9NmD&&>(n);
}

int fu_MAIN()
{
    return test_MbR9(SolvedNode_9NmD{}, SolvedNode_9NmD{}).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        nocopy struct SolvedNode {
            items: SolvedNode[];
        };

        fn test(mut a: SolvedNode, mut b: SolvedNode) {

            ref n = a || b;

            return n;
        }

        fn main() test([], []).items.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct SolvedNode_9NmD;

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = delete;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD&) = delete;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD test_MbR9(/*MOV*/ SolvedNode_9NmD&& a, /*MOV*/ SolvedNode_9NmD&& b)
{
    /*MOV*/ SolvedNode_9NmD& /*a|b*/ n = (a ? a : b);
    return static_cast<SolvedNode_9NmD&&>(n);
}

int fu_MAIN()
{
    return test_MbR9(SolvedNode_9NmD{}, SolvedNode_9NmD{}).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========


        nocopy            
        struct SolvedNode { len: i32; }

        fn createBlock(mut last: SolvedNode) {
            let tail     = last || last;
            let unwrap   = tail || tail;
            last.len--;
            return unwrap;
        }

        fn main() {
            return createBlock([]).len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:20+6[0m:

[2m      |             let unwrap   = tail || tail;[0m
[2m      |             last.len--;[0m
[2m   10 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1munwrap[0m, reference invalidated by write to [35;3mmut arg[0m [94;1mlast[0m at [2m9:21+2[0m:

[2m      |             let tail     = last || last;[0m
[2m      |             let unwrap   = tail || tail;[0m
[2m    9 | [0m            last.len[31;1m--[0m;
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1mpostfix--[0m

    BorrowCheck [35;3mfn[0m [94;1mcreateBlock[0m([94;1mSolvedNode[0m) at [2m6:12+11[0m

========


        struct SolvedNode { len: i32; }

        fn createBlock(mut last: SolvedNode) {
            let tail     = last || last;
            let unwrap   = tail || tail;
            last.len--;
            return unwrap;
        }

        fn main() {
            return createBlock([]).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct SolvedNode_ilZN;

                                #ifndef DEF_SolvedNode_ilZNfJyVJdk
                                #define DEF_SolvedNode_ilZNfJyVJdk
struct SolvedNode_ilZN
{
                                // shape_hash:    4e07182d2c5a88be
                                // non_triv_mask: 0000000000000000
    int len;
    explicit operator bool() const noexcept
    {
        return false
            || len
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_ilZN createBlock_MbR9(SolvedNode_ilZN&& last)
{
    const SolvedNode_ilZN& /*last*/ tail = (last ? last : last);
    const SolvedNode_ilZN unwrap = (tail ? tail : tail);
    last.len--;
    return unwrap;
}

int fu_MAIN()
{
    return createBlock_MbR9(SolvedNode_ilZN{}).len;
}

#endif

int main() { return fu_MAIN(); }

========


        nocopy            
        struct SolvedNode { items: SolvedNode[] };

        fn popAndOr(ref node: SolvedNode) {
            let N = node.items.len;

            let pop = node.items[N - 1];
            if (N > 2) {
                node.items.pop();
            }
            else {
                let head = node.items[0];
                node = head;
            }

            return pop;
        }

        fn main() {
            mut a = SolvedNode([ SolvedNode, SolvedNode ]);
            let b = a.popAndOr();
            return a.items.len + b.items.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:20+3[0m:

[2m      |             }[0m
[2m      | [0m
[2m   18 | [0m            return [31;1mpop[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1mpop[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mnode[0m at [2m15:22+1[0m:

[2m      |             else {[0m
[2m      |                 let head = node.items[0];[0m
[2m   15 | [0m                node [31;1m=[0m head;
[2m      |             }[0m
[2m      | [0m

	At call to [35;3m__native[0m [94;1m=[0m

    BorrowCheck [35;3mfn[0m [94;1mpopAndOr[0m([94;1mSolvedNode[0m) at [2m6:12+8[0m

========


        struct SolvedNode { items: SolvedNode[] };

        fn popAndOr(ref node: SolvedNode) {
            let N = node.items.len;

            let pop = node.items[N - 1];
            if (N > 2) {
                node.items.pop();
            }
            else {
                let head = node.items[0];
                node = head;
            }

            return pop;
        }

        fn main() {
            mut a = SolvedNode([ SolvedNode, SolvedNode ]);
            let b = a.popAndOr();
            return a.items.len + b.items.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SolvedNode_9NmD;

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_9NmD popAndOr_MbR9(/*1:1*/ SolvedNode_9NmD& node)
{
    const int N = node.items.size();
    /*MOV*/ SolvedNode_9NmD pop = node.items[(N - 1)];
    if (N > 2)
        node.items.pop();
    else
    {
        const SolvedNode_9NmD& /*node|static*/ head = node.items[0];
        node = head;
    };
    return /*NRVO*/ pop;
}

int fu_MAIN()
{
    SolvedNode_9NmD a = SolvedNode_9NmD { fu::vec<SolvedNode_9NmD> {{ SolvedNode_9NmD{}, SolvedNode_9NmD{} }} };
    SolvedNode_9NmD b = popAndOr_MbR9(a);
    return a.items.size() + b.items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========


        nocopy            
        struct Items {
            len: i32;
        }

        struct SolvedNode {
            items: Items;
        }

        struct Nodes {
            last: SolvedNode;
        }

        fn pop(ref n: Nodes) {
            n.last.items.len--;
        }

        fn createBlock(mut items: Nodes) {
            let tail = items.last;
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock(Nodes(SolvedNode([]))).len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 24:20+6[0m:

[2m      |             let unwrap = tail.items;[0m
[2m      |             items.pop();[0m
[2m   24 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1munwrap[0m, reference invalidated by write to [35;3mmut arg[0m [94;1mitems[0m at [2m23:19+3[0m:

[2m      |             let tail = items.last;[0m
[2m      |             let unwrap = tail.items;[0m
[2m   23 | [0m            items.[31;1mpop[0m();
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mpop[0m
            via [35;3m__native[0m [94;1mpostfix--[0m at [2m17:29+2[0m:

[2m      | [0m
[2m      |         fn pop(ref n: Nodes) {[0m
[2m   17 | [0m            n.last.items.len[31;1m--[0m;
[2m      |         }[0m
[2m      | [0m


    BorrowCheck [35;3mfn[0m [94;1mcreateBlock[0m([94;1mNodes[0m) at [2m20:12+11[0m

========


        struct Items {
            len: i32;
        }

        struct SolvedNode {
            items: Items;
        }

        struct Nodes {
            last: SolvedNode;
        }

        fn pop(ref n: Nodes) {
            n.last.items.len--;
        }

        fn createBlock(mut items: Nodes) {
            let tail = items.last;
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock(Nodes(SolvedNode([]))).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Items_Mmjr;
struct SolvedNode_xNjH;
struct Nodes_DgJK;

                                #ifndef DEF_Items_Mmjrci2K5W0
                                #define DEF_Items_Mmjrci2K5W0
struct Items_Mmjr
{
                                // shape_hash:    8f31f6d2a0fd9ea0
                                // non_triv_mask: 0000000000000000
    int len;
    explicit operator bool() const noexcept
    {
        return false
            || len
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_xNjHLPGOska
                                #define DEF_SolvedNode_xNjHLPGOska
struct SolvedNode_xNjH
{
                                // shape_hash:    307967b220022587
                                // non_triv_mask: 0000000000000000
    Items_Mmjr items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Nodes_DgJKsq3VNpc
                                #define DEF_Nodes_DgJKsq3VNpc
struct Nodes_DgJK
{
                                // shape_hash:    b0ac91630ca8e909
                                // non_triv_mask: 0000000000000000
    SolvedNode_xNjH last;
    explicit operator bool() const noexcept
    {
        return false
            || last
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void pop_MbR9(/*1:1*/ Nodes_DgJK& n)
{
    n.last.items.len--;
}

static Items_Mmjr createBlock_MbR9(Nodes_DgJK&& items)
{
    const SolvedNode_xNjH& /*items*/ tail = items.last;
    const Items_Mmjr unwrap = tail.items;
    pop_MbR9(items);
    return unwrap;
}

int fu_MAIN()
{
    return createBlock_MbR9(Nodes_DgJK { SolvedNode_xNjH { Items_Mmjr{} } }).len;
}

#endif

int main() { return fu_MAIN(); }

========


        nocopy            
        struct SolvedNode {
            items: SolvedNode[];
        };

        // Reducing the thing below.
        fn createBlock(mut items: SolvedNode[]) {
            let tail = items[items.len - 1];
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock([ SolvedNode ]).len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 13:20+6[0m:

[2m      |             let unwrap = tail.items;[0m
[2m      |             items.pop();[0m
[2m   13 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1munwrap[0m, reference invalidated by write to [35;3mmut arg[0m [94;1mitems[0m at [2m12:19+3[0m:

[2m      |             let tail = items[items.len - 1];[0m
[2m      |             let unwrap = tail.items;[0m
[2m   12 | [0m            items.[31;1mpop[0m();
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;3m__native[0m [94;1m.pop()[0m

    BorrowCheck [35;3mfn[0m [94;1mcreateBlock[0m([94;1mSolvedNode[0m[35;3m[..][0m) at [2m9:12+11[0m

========


        struct SolvedNode {
            items: SolvedNode[];
        };

        // Reducing the thing below.
        fn createBlock(mut items: SolvedNode[]) {
            let tail = items[items.len - 1];
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock([ SolvedNode ]).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SolvedNode_9NmD;

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<SolvedNode_9NmD> createBlock_MbR9(fu::vec<SolvedNode_9NmD>&& items)
{
    const SolvedNode_9NmD& /*items|static*/ tail = items[(items.size() - 1)];
    /*MOV*/ fu::vec<SolvedNode_9NmD> unwrap = fu::vec<SolvedNode_9NmD>(tail.items);
    items.pop();
    return /*NRVO*/ unwrap;
}

int fu_MAIN()
{
    return createBlock_MbR9(fu::vec<SolvedNode_9NmD> {{ SolvedNode_9NmD{} }}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========


        nocopy            
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as below but mut.
        fn createBlock(mut items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items;
                items.pop();
                return unwrap;
            }

            return [];
        }

        fn main() {
            return createBlock([]).len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:24+6[0m:

[2m      |                 let unwrap = tail.items;[0m
[2m      |                 items.pop();[0m
[2m   18 | [0m                return [31;1munwrap[0m;
[2m      |             }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1munwrap[0m, reference invalidated by write to [35;3mmut arg[0m [94;1mitems[0m at [2m17:23+3[0m:

[2m      | [0m
[2m      |                 let unwrap = tail.items;[0m
[2m   17 | [0m                items.[31;1mpop[0m();
[2m      |                 return unwrap;[0m
[2m      |             }[0m

	At call to [35;3m__native[0m [94;1m.pop()[0m

    BorrowCheck [35;3mfn[0m [94;1mcreateBlock[0m([94;1mSolvedNode[0m[35;3m[..][0m) at [2m10:12+11[0m

========


        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as below but mut.
        fn createBlock(mut items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items;
                items.pop();
                return unwrap;
            }

            return [];
        }

        fn main() {
            return createBlock([]).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct SolvedNode_5stV;

                                #ifndef DEF_SolvedNode_5stVMen67Wd
                                #define DEF_SolvedNode_5stVMen67Wd
struct SolvedNode_5stV
{
                                // shape_hash:    976388198633652a
                                // non_triv_mask: 0000820000000020
    fu::str kind;
    fu::vec<SolvedNode_5stV> items;
    SolvedNode_5stV(const SolvedNode_5stV&) = default;
    SolvedNode_5stV(SolvedNode_5stV&&) = default;
    SolvedNode_5stV& operator=(SolvedNode_5stV&&) = default;
    SolvedNode_5stV& operator=(const SolvedNode_5stV& selfrec) { return *this = SolvedNode_5stV(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

static fu::vec<SolvedNode_5stV> createBlock_MbR9(fu::vec<SolvedNode_5stV>&& items)
{
    if (items.size())
    {
        for (; ; )
        {
            const SolvedNode_5stV& /*items|static*/ tail = items[(items.size() - 1)];
            if (tail.kind != "block"_view)
                break;
            else
            {
                /*MOV*/ fu::vec<SolvedNode_5stV> unwrap = fu::vec<SolvedNode_5stV>(tail.items);
                items.pop();
                return /*NRVO*/ unwrap;
            };
        };
    };
    return fu::vec<SolvedNode_5stV>{};
}

int fu_MAIN()
{
    return createBlock_MbR9(fu::vec<SolvedNode_5stV>{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========


        nocopy            
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as above but ref.
        fn createBlock(ref items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1];
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items; // unwrap needs to copy here
                items.pop(); ////////////// <- nuked here, but ignored!
                return unwrap;
            }

            return [];
        }

        fn main() {
            mut items: SolvedNode[];
            return createBlock(items).len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:24+6[0m:

[2m      |                 let unwrap = tail.items; // unwrap needs to copy here[0m
[2m      |                 items.pop(); ////////////// <- nuked here, but ignored![0m
[2m   18 | [0m                return [31;1munwrap[0m;
[2m      |             }[0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1munwrap[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mitems[0m at [2m17:23+3[0m:

[2m      | [0m
[2m      |                 let unwrap = tail.items; // unwrap needs to copy here[0m
[2m   17 | [0m                items.[31;1mpop[0m(); ////////////// <- nuked here, but ignored!
[2m      |                 return unwrap;[0m
[2m      |             }[0m

	At call to [35;3m__native[0m [94;1m.pop()[0m

    BorrowCheck [35;3mfn[0m [94;1mcreateBlock[0m([94;1mSolvedNode[0m[35;3m[..][0m) at [2m10:12+11[0m

========


        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as above but ref.
        fn createBlock(ref items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1];
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items; // unwrap needs to copy here
                items.pop(); ////////////// <- nuked here, but ignored!
                return unwrap;
            }

            return [];
        }

        fn main() {
            mut items: SolvedNode[];
            return createBlock(items).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct SolvedNode_5stV;

                                #ifndef DEF_SolvedNode_5stVMen67Wd
                                #define DEF_SolvedNode_5stVMen67Wd
struct SolvedNode_5stV
{
                                // shape_hash:    976388198633652a
                                // non_triv_mask: 0000820000000020
    fu::str kind;
    fu::vec<SolvedNode_5stV> items;
    SolvedNode_5stV(const SolvedNode_5stV&) = default;
    SolvedNode_5stV(SolvedNode_5stV&&) = default;
    SolvedNode_5stV& operator=(SolvedNode_5stV&&) = default;
    SolvedNode_5stV& operator=(const SolvedNode_5stV& selfrec) { return *this = SolvedNode_5stV(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

static fu::vec<SolvedNode_5stV> createBlock_MbR9(/*1:1*/ fu::vec_range_mut<SolvedNode_5stV> items)
{
    if (items.size())
    {
        for (; ; )
        {
            const SolvedNode_5stV& /*items|static*/ tail = items[(items.size() - 1)];
            if (tail.kind != "block"_view)
                break;
            else
            {
                /*MOV*/ fu::vec<SolvedNode_5stV> unwrap = fu::vec<SolvedNode_5stV>(tail.items);
                items.pop();
                return /*NRVO*/ unwrap;
            };
        };
    };
    return fu::vec<SolvedNode_5stV>{};
}

int fu_MAIN()
{
    fu::vec<SolvedNode_5stV> items {};
    return createBlock_MbR9(items).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(ref a: i32[]) = a.swap(0, 1);

        fn main() {
            mut nums = [1, 2];
            nums.test();
            return nums.len == 2 && nums[0] == 2 && nums[1] == 1
                 ? 0
                 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_swap.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::view_mut<int> a)
{
    fu::view_swap(a, 0, 1);
}

int fu_MAIN()
{
    fu::vec<int> nums = fu::vec<int> {{ 1, 2 }};
    test_MbR9(nums);
    if ((nums.size() == 2) && (nums[0] == 2) && (nums[1] == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref arg: i32[]) {
            let encloses_unchanged = arg;

            fn closure()
                for (mut i = 0; i < arg.len; i++)
                    arg[i] += encloses_unchanged[i];

            closure();
            if (arg.len & 1)
                closure();
        }

        fn main() {
            mut a = [ 3 ];
            test(a);
            return a[0] - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void closure_MbR9(/*3:1*/ fu::view_mut<int> arg, /*3:3*/ fu::view<int> encloses_unchanged)
{
    for (int i = 0; i < arg.size(); i++)
        arg.mutref(i) += encloses_unchanged[i];

}

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> arg)
{
    fu::vec<int> encloses_unchanged = fu::vec<int>(arg);
    closure_MbR9(arg, encloses_unchanged);
    if (arg.size() & 1)
        closure_MbR9(arg, encloses_unchanged);

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 3 }};
    test_MbR9(a);
    return a[0] - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        inline fn must_not_return_ref_or_view(ref x: i32[][]) {
            let y = x[100];
            x.shrink(y.len);
            return y;
        }

        fn main() {
            mut arr: i32[][];
            arr.grow(101);
            arr[100] = [ 7 ]
            return arr.must_not_return_ref_or_view()[0] - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2032) arc_count(1) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr {};
    arr.grow(101);
    arr.mutref(100) = fu::vec<int> {{ 7 }};
    fu::vec<int> y {};
    return (y = fu::vec<int>(arr[100]), arr.shrink(y.size()), y)[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct HasVec { x: i32[] };
        inline fn Last(x: i32[]) x[x.len - 1];


        fn will_return_value(ref x: HasVec) {
            let bck_will_cpy = x;

            let vec0 = bck_will_cpy.x;
            if (bck_will_cpy.x.len & 1)
                return vec0;

            x.x ~= x.x.len;
            let vec1 = bck_will_cpy.x;
            return vec1;
        }

        fn main() {
            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            return will_return_value(x).Last/*9*/ - x.x.Last/*10*/ + 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct HasVec_iBUp;

                                #ifndef DEF_HasVec_iBUpMssJApi
                                #define DEF_HasVec_iBUpMssJApi
struct HasVec_iBUp
{
                                // shape_hash:    026c5a30a0e0776d
                                // non_triv_mask: 0008000010000000
    fu::vec<int> x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> will_return_value_MbR9(/*1:1*/ HasVec_iBUp& x)
{
    /*MOV*/ HasVec_iBUp bck_will_cpy = x;
    /*MOV*/ fu::vec<int>& /*bck_will_cpy*/ vec0 = bck_will_cpy.x;
    if (bck_will_cpy.x.size() & 1)
        return static_cast<fu::vec<int>&&>(vec0);
    else
    {
        x.x += x.x.size();
        /*MOV*/ fu::vec<int>& /*bck_will_cpy*/ vec1 = bck_will_cpy.x;
        return static_cast<fu::vec<int>&&>(vec1);
    };
}

int fu_MAIN()
{
    HasVec_iBUp x = HasVec_iBUp { fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }} };
    fu::vec<int> x_1 {};
    int _0;
    fu::view<int> x_2 {};
    return (_0 = (x_1 = will_return_value_MbR9(x), x_1[(x_1.size() - 1)]), (_0 - (x_2.ptr_reassign(x.x), x_2[(x_2.size() - 1)]))) + 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

========

        struct HasVec { x: i32[] };
        inline fn Last(x: i32[]) x[x.len - 1];


        inline                                                  // PointlessLocal

        fn will_return_value(ref x: HasVec) {
            let bck_will_cpy = x;

            let vec0 = bck_will_cpy.x;
            if (bck_will_cpy.x.len & 1)
                return vec0;

            x.x ~= x.x.len;
            let vec1 = bck_will_cpy.x;
            return vec1;
        }

        fn main() {
            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            return will_return_value(x).Last/*9*/ - x.x.Last/*10*/ + 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct HasVec_iBUp;

                                #ifndef DEF_HasVec_iBUpMssJApi
                                #define DEF_HasVec_iBUpMssJApi
struct HasVec_iBUp
{
                                // shape_hash:    026c5a30a0e0776d
                                // non_triv_mask: 0008000010000000
    fu::vec<int> x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    HasVec_iBUp x = HasVec_iBUp { fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }} };
    fu::view<int> x_1 {};
    fu::view<int> vec1 {};
    fu::view<int> vec0 {};
    HasVec_iBUp bck_will_cpy {};
    int _0;
    fu::view<int> x_2 {};
    return (_0 = (x_1.ptr_reassign((bck_will_cpy = x, vec0.ptr_reassign(bck_will_cpy.x), ((bck_will_cpy.x.size() & 1) ? vec0 : ((x.x += x.x.size()), vec1.ptr_reassign(bck_will_cpy.x), vec1)))), x_1[(x_1.size() - 1)]), (_0 - (x_2.ptr_reassign(x.x), x_2[(x_2.size() - 1)]))) + 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

========

        fn PASS_borrowCheck_incr_a_ret_b(ref a: i32, ref b: i32) {
            a++;        // we're done writing to a before
            return b;   //  EXTRA DRAMA: we dont cg const refs for primitives right now
        }

        fn main() {
            mut x = 5;
            PASS_borrowCheck_incr_a_ret_b(x, x);
            return x - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int PASS_borrowCheck_incr_a_ret_b_GL0m(/*3:1*/ int& a, /*3:3*/ const int b)
{
    a++;
    return b;
}

int fu_MAIN()
{
    int x = 5;
    PASS_borrowCheck_incr_a_ret_b_GL0m(x, x);
    return x - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========

        fn PASS_borrowCheck_reduct(ref a: i32, ref b: i32[])
        {
            // If this were (ref!b a, ref b):
            //
            // When a points into b:
            //  - a++ read ok, write ok
            //   - b read ok, write ok + invalidates a
            //    - a not usable from here on
            //
            // The point is we should be able to deduce this automatically,
            //  if nothing a-related is used after b gets used for the first time,
            //   then we're fine if b aliases a ...
            //
            // ... EXCEPT that's if b doesn't acceptTempCopies -
            //  meaning it's either F_IMPLICIT or F_REF -
            //   otherwise there's ambiguity.
            //
            a++;
            b ~= 10;
        }

        fn main() {
            mut arr = [ 9 ];
            PASS_borrowCheck_reduct(arr[0], arr);
            return arr[0] - arr[1];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void PASS_borrowCheck_reduct_MbR9(/*3:1*/ int& a, /*3:3*/ fu::vec_range_mut<int> b)
{
    a++;
    b += 10;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 9 }};
    int* _0;
    (_0 = &(arr.mutref(0)), PASS_borrowCheck_reduct_MbR9(*_0, arr));
    return arr[0] - arr[1];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq, N_AARSoftRisk

========

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        fn PASS_borrowCheck(ref root: Node) {
            mut n: i32;
            fn count(id: i32)
                traverse(root): |i|
                    if (i.id == id)
                        n++;

            fn check(ref node: Node) {
                if (node.items)
                    for (mut i = 0; i < node.items.len; i++)
                        check(node.items[i]);                   // PointlessMustSeq
                else
                    count(node.id++);
            }

            check(root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_q67g;
static void check_MbR9(Node_q67g&, const Node_q67g&, int&);
inline static void traverse_blAj(const Node_q67g&, int, int&);

                                #ifndef DEF_Node_q67gRnXnyP6
                                #define DEF_Node_q67gRnXnyP6
struct Node_q67g
{
                                // shape_hash:    ad5d7d2c7bd229f4
                                // non_triv_mask: 0000004000002000
    int id;
    fu::vec<Node_q67g> items;
    Node_q67g(const Node_q67g&) = default;
    Node_q67g(Node_q67g&&) = default;
    Node_q67g& operator=(Node_q67g&&) = default;
    Node_q67g& operator=(const Node_q67g& selfrec) { return *this = Node_q67g(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___gFZCSSwstAc
                                #define DEF___gFZCSSwstAc
inline static void _gFZC(/*7:7*/ const Node_q67g& i, /*7:7*/ const int id, /*7:7*/ int& n)
{
    if (i.id == id)
        n++;

}
                                #endif

                                #ifndef DEF_traverse_blAjlpmONDc
                                #define DEF_traverse_blAjlpmONDc
inline static void traverse_blAj(/*F:F*/ const Node_q67g& node, /*F:F*/ const int id, /*E:A*/ int& n)
{
    _gFZC(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_blAj(node.items[i], id, n);

}
                                #endif

static void count_MbR9(const int id, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    traverse_blAj(root, id, n);
}

static void check_MbR9(/*7:1*/ Node_q67g& node, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_MbR9(node.items.mutref(i), root, n);

    else
        count_MbR9(node.id++, root, n);

}

static int PASS_borrowCheck_MbR9(/*1:1*/ Node_q67g& root)
{
    int n {};
    check_MbR9(root, root, n);
    return n;
}

int fu_MAIN()
{
    Node_q67g tree = Node_q67g { 0, fu::vec<Node_q67g> {{ Node_q67g { 2, fu::vec<Node_q67g>{} }, Node_q67g { 2, fu::vec<Node_q67g>{} } }} };
    return PASS_borrowCheck_MbR9(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq, N_AARSoftRisk

========

        fn check(implicit root: i32[], node: i32[])
            root.len - node.len;

        fn PASS_borrowCheck(        
                     root: i32[])   
                check(root);

        fn main()
            [ 1, 2, 3 ].PASS_borrowCheck();

---- <fail> ----
[2m[0m_0[2m.fu 10:25+16[0m:

[2m      | [0m
[2m      |         fn main()[0m
[2m   10 | [0m            [ 1, 2, 3 ].[31;1mPASS_borrowCheck[0m();
[2m      | [0m

	No implicit [31;1mroot[0m: [35;3mnocopy[0m [35;3mi32[0m[35;3m[..][0m in scope, needed to call [35;3mfn[0m [94;1mPASS_borrowCheck[0m:

            because of call to [35;3mfn[0m [94;1mcheck[0m at [2m7:17+5[0m:

[2m      |         fn PASS_borrowCheck(        [0m
[2m      |                      root: i32[])   [0m
[2m    7 | [0m                [31;1mcheck[0m(root);
[2m      | [0m
[2m      |         fn main()[0m

            because of [35;3mimplicit arg[0m [94;1mroot[0m at [2m2:27+4[0m:

[2m      | [0m
[2m    2 | [0m        fn check(implicit [31;1mroot[0m: i32[], node: i32[])
[2m      |             root.len - node.len;[0m
[2m      | [0m

        Possible candidate in [35;3mfn[0m [94;1mPASS_borrowCheck[0m: [31;1mNOT implicit [0m[35;3marg[0m [94;1mroot[0m at [2m6:22+4[0m:

[2m      | [0m
[2m      |         fn PASS_borrowCheck(        [0m
[2m    6 | [0m                     [31;1mroot[0m: i32[])   
[2m      |                 check(root);[0m
[2m      | [0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        fn check(implicit root: i32[], node: i32[])
            root.len - node.len;

        fn PASS_borrowCheck(        
            implicit root: i32[])   
                check(root);

        fn main()
            [ 1, 2, 3 ].PASS_borrowCheck();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int check_MbR9(/*3:3*/ fu::view<int> node, /*3:3*/ fu::view<int> root)
{
    return root.size() - node.size();
}

static int PASS_borrowCheck_MbR9(/*1:1*/ fu::view<int> root)
{
    return check_MbR9(root, root);
}

int fu_MAIN()
{
    return PASS_borrowCheck_MbR9(fu::view<int> {{ 1, 2, 3 }});
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but not a closure.
        fn count(id: i32, implicit root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        fn check(ref node: Node) {
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(node.items[i]);                   // PointlessMustSeq
            else
                count(node.id++);
        }

        fn PASS_borrowCheck(implicit ref root: Node) {
            implicit mut n: i32;
            check(root); // <- Usage intersection failure: Node & Node
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_q67g;
static void check_MbR9(Node_q67g&, int&, const Node_q67g&);
inline static void traverse_blAj(const Node_q67g&, int, int&);

                                #ifndef DEF_Node_q67gRnXnyP6
                                #define DEF_Node_q67gRnXnyP6
struct Node_q67g
{
                                // shape_hash:    ad5d7d2c7bd229f4
                                // non_triv_mask: 0000004000002000
    int id;
    fu::vec<Node_q67g> items;
    Node_q67g(const Node_q67g&) = default;
    Node_q67g(Node_q67g&&) = default;
    Node_q67g& operator=(Node_q67g&&) = default;
    Node_q67g& operator=(const Node_q67g& selfrec) { return *this = Node_q67g(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___gFZCSSwstAc
                                #define DEF___gFZCSSwstAc
inline static void _gFZC(/*7:7*/ const Node_q67g& i, /*7:7*/ const int id, /*7:7*/ int& n)
{
    if (i.id == id)
        n++;

}
                                #endif

                                #ifndef DEF_traverse_blAjlpmONDc
                                #define DEF_traverse_blAjlpmONDc
inline static void traverse_blAj(/*F:F*/ const Node_q67g& node, /*F:F*/ const int id, /*E:A*/ int& n)
{
    _gFZC(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_blAj(node.items[i], id, n);

}
                                #endif

static void count_MbR9(const int id, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    traverse_blAj(root, id, n);
}

static void check_MbR9(/*7:1*/ Node_q67g& node, /*2:2*/ int& n, /*7:7*/ const Node_q67g& root)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_MbR9(node.items.mutref(i), n, root);

    else
        count_MbR9(node.id++, root, n);

}

static int PASS_borrowCheck_MbR9(/*1:1*/ Node_q67g& root)
{
    int n {};
    check_MbR9(root, n, root);
    return n;
}

int fu_MAIN()
{
    Node_q67g tree = Node_q67g { 0, fu::vec<Node_q67g> {{ Node_q67g { 2, fu::vec<Node_q67g>{} }, Node_q67g { 2, fu::vec<Node_q67g>{} } }} };
    return PASS_borrowCheck_MbR9(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq, N_AARSoftRisk

========

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but no implicits.
        fn count(id: i32, ref root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        // AAR: check(ref node, ref root) accepted,
        //       but (ref root, ref node) rejected.

        fn check(ref node: Node, ref root: Node) { 
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(:root, node.items[i]);                // PointlessMustSeq
            else
                count(:root, node.id++);
        }

        fn PASS_borrowCheck(ref root: Node) {
            implicit mut n: i32;
            check(:root, root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_q67g;
static void check_MbR9(Node_q67g&, const Node_q67g&, int&);
inline static void traverse_blAj(const Node_q67g&, int, int&);

                                #ifndef DEF_Node_q67gRnXnyP6
                                #define DEF_Node_q67gRnXnyP6
struct Node_q67g
{
                                // shape_hash:    ad5d7d2c7bd229f4
                                // non_triv_mask: 0000004000002000
    int id;
    fu::vec<Node_q67g> items;
    Node_q67g(const Node_q67g&) = default;
    Node_q67g(Node_q67g&&) = default;
    Node_q67g& operator=(Node_q67g&&) = default;
    Node_q67g& operator=(const Node_q67g& selfrec) { return *this = Node_q67g(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___gFZCSSwstAc
                                #define DEF___gFZCSSwstAc
inline static void _gFZC(/*7:7*/ const Node_q67g& i, /*7:7*/ const int id, /*7:7*/ int& n)
{
    if (i.id == id)
        n++;

}
                                #endif

                                #ifndef DEF_traverse_blAjlpmONDc
                                #define DEF_traverse_blAjlpmONDc
inline static void traverse_blAj(/*F:F*/ const Node_q67g& node, /*F:F*/ const int id, /*E:A*/ int& n)
{
    _gFZC(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_blAj(node.items[i], id, n);

}
                                #endif

static void count_MbR9(const int id, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    traverse_blAj(root, id, n);
}

static void check_MbR9(/*7:1*/ Node_q67g& node, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_MbR9(node.items.mutref(i), root, n);

    else
        count_MbR9(node.id++, root, n);

}

static int PASS_borrowCheck_MbR9(/*1:1*/ Node_q67g& root)
{
    int n {};
    check_MbR9(root, root, n);
    return n;
}

int fu_MAIN()
{
    Node_q67g tree = Node_q67g { 0, fu::vec<Node_q67g> {{ Node_q67g { 2, fu::vec<Node_q67g>{} }, Node_q67g { 2, fu::vec<Node_q67g>{} } }} };
    return PASS_borrowCheck_MbR9(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq, N_AARSoftRisk

========

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but no implicits.
        fn count(id: i32, ref root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        // AAR: check(ref node, ref root) accepted,
        //       but (ref root, ref node) rejected.

        fn check(ref root: Node, ref node: Node) { 
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(:root, node.items[i]);                // PointlessMustSeq
            else
                count(:root, node.id++);
        }

        fn PASS_borrowCheck(ref root: Node) {
            implicit mut n: i32;
            check(:root, root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_q67g;
static void check_MbR9(const Node_q67g&, Node_q67g&, int&);
inline static void traverse_blAj(const Node_q67g&, int, int&);

                                #ifndef DEF_Node_q67gRnXnyP6
                                #define DEF_Node_q67gRnXnyP6
struct Node_q67g
{
                                // shape_hash:    ad5d7d2c7bd229f4
                                // non_triv_mask: 0000004000002000
    int id;
    fu::vec<Node_q67g> items;
    Node_q67g(const Node_q67g&) = default;
    Node_q67g(Node_q67g&&) = default;
    Node_q67g& operator=(Node_q67g&&) = default;
    Node_q67g& operator=(const Node_q67g& selfrec) { return *this = Node_q67g(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___gFZCSSwstAc
                                #define DEF___gFZCSSwstAc
inline static void _gFZC(/*7:7*/ const Node_q67g& i, /*7:7*/ const int id, /*7:7*/ int& n)
{
    if (i.id == id)
        n++;

}
                                #endif

                                #ifndef DEF_traverse_blAjlpmONDc
                                #define DEF_traverse_blAjlpmONDc
inline static void traverse_blAj(/*F:F*/ const Node_q67g& node, /*F:F*/ const int id, /*E:A*/ int& n)
{
    _gFZC(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_blAj(node.items[i], id, n);

}
                                #endif

static void count_MbR9(const int id, /*7:7*/ const Node_q67g& root, /*4:4*/ int& n)
{
    traverse_blAj(root, id, n);
}

static void check_MbR9(/*7:7*/ const Node_q67g& root, /*7:2*/ Node_q67g& node, /*4:4*/ int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_MbR9(root, node.items.mutref(i), n);

    else
        count_MbR9(node.id++, root, n);

}

static int PASS_borrowCheck_MbR9(/*1:1*/ Node_q67g& root)
{
    int n {};
    check_MbR9(root, root, n);
    return n;
}

int fu_MAIN()
{
    Node_q67g tree = Node_q67g { 0, fu::vec<Node_q67g> {{ Node_q67g { 2, fu::vec<Node_q67g>{} }, Node_q67g { 2, fu::vec<Node_q67g>{} } }} };
    return PASS_borrowCheck_MbR9(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq, N_AARSoftRisk

========

        pub fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn grow_if_oob_to_len_from_self(ref arr: i32[], idx: i32)
            arr.grow_if_oob(arr[idx]); // i was F_REF for some reason

        fn main() {
            mut arr = [3];
            arr.grow_if_oob_to_len_from_self(0) = 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_2Giz4sIWyKi
                                #define DEF_grow_if_oob_2Giz4sIWyKi
inline int& grow_if_oob_2Giz(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

int& grow_if_oob_to_len_from_self_MbR9(/*3:3*/ fu::vec_range_mut<int> arr, const int idx)
{
    return grow_if_oob_2Giz(arr, arr[idx]);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 3 }};
    grow_if_oob_to_len_from_self_MbR9(arr, 0) = 2;
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_ExternPrivates

========

        fn used_in_a_loop__invalidated__by_new_var(
            ref arr: i32[], ref barr: i32[], ref carr: i32[])
        {
            ref head = arr[arr.len - 1];
            for (mut i = 0; i < arr.len; i++) {
                head += arr.len;
                let head_cpy = head + 0;
                ref barrcarr = barr || carr;
                barrcarr.resize(head_cpy);
            }
        }

        fn main() {
            mut arr = [ 1 ];


            ref barr = arr; 

            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);
            return barr.len == 2 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:58+4[0m:

[2m      |             ref barr = arr; [0m
[2m      | [0m
[2m   20 | [0m            used_in_a_loop__invalidated__by_new_var(arr, [31;1mbarr[0m, barr);
[2m      |             return barr.len == 2 ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mused_in_a_loop__invalidated__by_new_var[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mused_in_a_loop__invalidated__by_new_var[0m:[94;1mbarr[0m and
	    1:	[35;3mref arg[0m [94;1mused_in_a_loop__invalidated__by_new_var[0m:[94;1marr[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m15:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   15 | [0m            mut [31;1marr[0m = [ 1 ];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mused_in_a_loop__invalidated__by_new_var[0m:[94;1mbarr[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mused_in_a_loop__invalidated__by_new_var[0m:[94;1marr[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m14:12+4[0m

========

        fn used_in_a_loop__invalidated__by_new_var(
            ref arr: i32[], ref barr: i32[], ref carr: i32[])
        {
            ref head = arr[arr.len - 1];
            for (mut i = 0; i < arr.len; i++) {
                head += arr.len;
                let head_cpy = head + 0;
                ref barrcarr = barr || carr;
                barrcarr.resize(head_cpy);
            }
        }

        fn main() {
            mut arr = [ 1 ];


            mut barr = arr; 

            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);
            return barr.len == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void used_in_a_loop__invalidated__by_new_var_MbR9(/*7:1*/ fu::view_mut<int> arr, /*6:2*/ fu::vec_range_mut<int> barr, /*6:4*/ fu::vec_range_mut<int> carr)
{
    int& /*arr|static*/ head = arr.mutref((arr.size() - 1));
    for (int i = 0; i < arr.size(); i++)
    {
        head += arr.size();
        const int head_cpy = (head + 0);
        fu::vec_range_mut<int> /*barr|carr*/ barrcarr = (barr ? barr : carr);
        barrcarr.resize(head_cpy);
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    fu::vec<int> barr = fu::vec<int>(arr);
    used_in_a_loop__invalidated__by_new_var_MbR9(arr, barr, barr);
    if (barr.size() == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_AARSoftRisk

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];


            ref x = brr[0];                              // PointlessMustSeq

            return two_writes_in_an_arg(arr, brr, x);
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:51+1[0m:

[2m      |             ref x = brr[0];                              // PointlessMustSeq[0m
[2m      | [0m
[2m   20 | [0m            return two_writes_in_an_arg(arr, brr, [31;1mx[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtwo_writes_in_an_arg[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m and
	    2:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 0, 1, 2, 3 ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m = [ 0, 2, 4, 6 ];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];


            mut x = 0;                                   // PointlessMustSeq

            return two_writes_in_an_arg(arr, brr, x);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_kGbb(/*3:3*/ const int what, /*3:3*/ int& to)
{
    return (to = what);
}

static int two_writes_in_an_arg_kGbb(/*7:3*/ fu::vec_range_mut<int> arr, /*7:3*/ fu::vec_range_mut<int> brr, /*7:7*/ int& x)
{
    return assign_kGbb((x ? grow_if_oob_kGbb(arr, 10) : grow_if_oob_kGbb(brr, 10)), x);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::vec<int> brr = fu::vec<int> {{ 0, 2, 4, 6 }};
    int x = 0;
    return two_writes_in_an_arg_kGbb(arr, brr, x);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       
            mut zero = 0;
            mut empty: i32[];               


            ref x = brr[0];                              // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- <fail> ----
[2m[0m_0[2m.fu 25:58+8[0m:

[2m      |             ref opaque_brr  = brr.len > arr.len ? empty : brr;[0m
[2m      | [0m
[2m   25 | [0m            return two_writes_in_an_arg(arr, opaque_brr, [31;1mopaque_x[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtwo_writes_in_an_arg[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m and
	    2:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {                         [0m
[2m      |             mut arr = [ 0, 1, 2, 3 ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m = [ 0, 2, 4, 6 ];       
[2m      |             mut zero = 0;[0m
[2m      |             mut empty: i32[];               [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut zero = 0;
            mut empty: i32[];               
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       


            ref x = brr[0];                              // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- <fail> ----
[2m[0m_0[2m.fu 25:58+8[0m:

[2m      |             ref opaque_brr  = brr.len > arr.len ? empty : brr;[0m
[2m      | [0m
[2m   25 | [0m            return two_writes_in_an_arg(arr, opaque_brr, [31;1mopaque_x[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtwo_writes_in_an_arg[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m and
	    2:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m17:17+3[0m:

[2m      |             mut empty: i32[];               [0m
[2m      |             mut arr = [ 0, 1, 2, 3 ];[0m
[2m   17 | [0m            mut [31;1mbrr[0m = [ 0, 2, 4, 6 ];       
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mbrr[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       
            mut zero = 0;
            mut empty: i32[];               


            mut x = 0;                                   // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_kGbb(/*3:3*/ const int what, /*3:3*/ int& to)
{
    return (to = what);
}

static int two_writes_in_an_arg_kGbb(/*7:3*/ fu::vec_range_mut<int> arr, /*7:3*/ fu::vec_range_mut<int> brr, /*7:7*/ int& x)
{
    return assign_kGbb((x ? grow_if_oob_kGbb(arr, 10) : grow_if_oob_kGbb(brr, 10)), x);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::vec<int> brr = fu::vec<int> {{ 0, 2, 4, 6 }};
    int zero = 0;
    fu::vec<int> empty {};
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec_range_mut<int> /*empty|brr*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_kGbb(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       
            mut zero = 0;
            mut empty: i32[];               


            mut x = 0;                                   // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_kGbb(/*3:3*/ const int what, /*3:3*/ int& to)
{
    return (to = what);
}

static int two_writes_in_an_arg_kGbb(/*7:3*/ fu::vec_range_mut<int> arr, /*7:3*/ fu::vec_range_mut<int> brr, /*7:7*/ int& x)
{
    return assign_kGbb((x ? grow_if_oob_kGbb(arr, 10) : grow_if_oob_kGbb(brr, 10)), x);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::vec<int> brr = fu::vec<int> {{ 0, 2, 4, 6 }};
    int zero = 0;
    fu::vec<int> empty {};
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec<int>& /*empty|brr*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_kGbb(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut zero = 0;
            mut empty: i32[];               
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       


            mut x = 0;                                   // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_kGbb(/*3:3*/ const int what, /*3:3*/ int& to)
{
    return (to = what);
}

static int two_writes_in_an_arg_kGbb(/*7:3*/ fu::vec_range_mut<int> arr, /*7:3*/ fu::vec_range_mut<int> brr, /*7:7*/ int& x)
{
    return assign_kGbb((x ? grow_if_oob_kGbb(arr, 10) : grow_if_oob_kGbb(brr, 10)), x);
}

int fu_MAIN()
{
    int zero = 0;
    fu::vec<int> empty {};
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::vec<int> brr = fu::vec<int> {{ 0, 2, 4, 6 }};
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec_range_mut<int> /*brr|empty*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_kGbb(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut zero = 0;
            mut empty: i32[];               
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       


            mut x = 0;                                   // PointlessMustSeq

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_kGbb(/*3:3*/ const int what, /*3:3*/ int& to)
{
    return (to = what);
}

static int two_writes_in_an_arg_kGbb(/*7:3*/ fu::vec_range_mut<int> arr, /*7:3*/ fu::vec_range_mut<int> brr, /*7:7*/ int& x)
{
    return assign_kGbb((x ? grow_if_oob_kGbb(arr, 10) : grow_if_oob_kGbb(brr, 10)), x);
}

int fu_MAIN()
{
    int zero = 0;
    fu::vec<int> empty {};
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3 }};
    fu::vec<int> brr = fu::vec<int> {{ 0, 2, 4, 6 }};
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec<int>& /*brr|empty*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_kGbb(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        struct Node { items: Node[] };

        fn main() {
            mut root = Node([
                Node([ Node, Node ])
            ]);


            swap(root.items[0], root);   // this is fine

            return root.items.len - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:33+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            swap(root.items[0], [31;1mroot[0m);   // this is fine
[2m      | [0m
[2m      |             return root.items.len - 2;[0m

	At call to [35;3m__native[0m [94;1m#MayAlias <utility> std::swap[0m, arguments:

	    2:	[35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mroot[0m at [2m5:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mroot[0m = Node([
[2m      |                 Node([ Node, Node ])[0m
[2m      |             ]);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1m#MayAlias <utility> std::swap[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct Node { items: Node[] };

        fn main() {
            mut root = Node([
                Node([ Node, Node ])
            ]);

 // write to root invalidates root.items[0]
            root = root.items[0];        // this is fine

            return root.items.len - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct Node_zYlo;

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Node_zYlo root = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} } }} };
    root = root.items[0];
    return root.items.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref to: i32, ref what: i32) to = what;

        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])
            assign( to: x,  what: arr.grow_if_oob(10)           // !N_BckMustSeq
                               || brr.grow_if_oob(10));         // !N_MoveMustSeq

        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {
            two_writes_in_an_arg(

                    x || arr[0],                         // PointlessMustSeq
                    :arr, :brr);

            return x;
        }

        fn main() {
            mut arr = [ 0 ];
            mut brr = [ 0 ];
            mut x   = 0;

            return test(:x, :arr, :brr);
        }

---- <fail> ----
[2m[0m_0[2m.fu 17:22+3[0m:

[2m      | [0m
[2m      |                     x || arr[0],                         // PointlessMustSeq[0m
[2m   17 | [0m                    :[31;1marr[0m, :brr);
[2m      | [0m
[2m      |             return x;[0m

	At call to [35;3mfn[0m [94;1mtwo_writes_in_an_arg[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1marr[0m and
	    1:	[35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m

	    both alias:

	    [35;3mmut ref arg[0m [94;1marr[0m at [2m13:33+3[0m:

[2m      |                                || brr.grow_if_oob(10));         // !N_MoveMustSeq[0m
[2m      | [0m
[2m   13 | [0m        fn test(ref x: i32, ref [31;1marr[0m: i32[], ref brr: i32[]) {
[2m      |             two_writes_in_an_arg([0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1marr[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtwo_writes_in_an_arg[0m:[94;1mx[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m, [35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m[35;3m[..][0m) at [2m13:12+4[0m

========

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref to: i32, ref what: i32) to = what;

        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])
            assign( to: x,  what: arr.grow_if_oob(10)           // !N_BckMustSeq
                               || brr.grow_if_oob(10));         // !N_MoveMustSeq

        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {
            two_writes_in_an_arg(

                    x,                                   // PointlessMustSeq
                    :arr, :brr);

            return x;
        }

        fn main() {
            mut arr = [ 0 ];
            mut brr = [ 0 ];
            mut x   = 0;

            return test(:x, :arr, :brr);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int grow_if_oob_kGbb(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}

static int assign_GL0m(/*3:3*/ int& to, /*3:3*/ const int what)
{
    return (to = what);
}

static int two_writes_in_an_arg_GL0m(/*7:7*/ int& x, /*7:2*/ fu::vec_range_mut<int> arr, /*7:6*/ fu::vec_range_mut<int> brr)
{
    int _0;
    return assign_GL0m(x, ((_0 = grow_if_oob_kGbb(arr, 10)) ? _0 : grow_if_oob_kGbb(brr, 10)));
}

static int test_kGbb(/*7:1*/ int& x, /*7:2*/ fu::vec_range_mut<int> arr, /*7:4*/ fu::vec_range_mut<int> brr)
{
    two_writes_in_an_arg_GL0m(x, arr, brr);
    return x;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0 }};
    fu::vec<int> brr = fu::vec<int> {{ 0 }};
    int x = 0;
    return test_kGbb(x, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];


            ref item = brr[0]; 

            return writes_to_two_args(:item, :arr, :brr);
        }

---- <fail> ----
[2m[0m_0[2m.fu 15:53+3[0m:

[2m      |             ref item = brr[0]; [0m
[2m      | [0m
[2m   15 | [0m            return writes_to_two_args(:item, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mwrites_to_two_args[0m, arguments:

	    3:	[35;3mref arg[0m [94;1mwrites_to_two_args[0m:[94;1mbrr[0m and
	    1:	[35;3mref arg[0m [94;1mwrites_to_two_args[0m:[94;1mitem[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m10:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   10 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mwrites_to_two_args[0m:[94;1mbrr[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mwrites_to_two_args[0m:[94;1mitem[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];


            mut item = brr[0]; 

            return writes_to_two_args(:item, :arr, :brr);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(496) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int writes_to_two_args_kGbb(/*7:7*/ int& item, /*7:6*/ fu::vec_range_mut<int> arr, /*7:6*/ fu::vec_range_mut<int> brr)
{
    fu::vec_range_mut<int> /*arr|brr*/ arrbrr = (arr ? arr : brr);
    arrbrr.resize((100 + arrbrr.size()));
    return (item += arrbrr.size());
}

int fu_MAIN()
{
    fu::vec<int> arr {};
    fu::vec<int> brr = fu::vec<int> {{ -101 }};
    int item = brr[0];
    return writes_to_two_args_kGbb(item, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            ref item = left || right;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            ref right = brr[0]; 

            return reads_from_two_args(:left, :right, :arr, :brr);
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:62+3[0m:

[2m      |             ref right = brr[0]; [0m
[2m      | [0m
[2m   18 | [0m            return reads_from_two_args(:left, :right, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mreads_from_two_args[0m, arguments:

	    4:	[35;3mref arg[0m [94;1mreads_from_two_args[0m:[94;1mbrr[0m and
	    2:	[35;3mref arg[0m [94;1mreads_from_two_args[0m:[94;1mright[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m11:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   11 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      |             mut left = 0;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mreads_from_two_args[0m:[94;1mbrr[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mreads_from_two_args[0m:[94;1mright[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            ref item = left || right;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            mut right = brr[0]; 

            return reads_from_two_args(:left, :right, :arr, :brr);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(496) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int reads_from_two_args_kGbb(/*F:F*/ int& left, /*F:F*/ int& right, /*C:C*/ fu::vec_range_mut<int> arr, /*C:C*/ fu::vec_range_mut<int> brr)
{
    fu::vec_range_mut<int> /*arr|brr*/ arrbrr = (arr ? arr : brr);
    int& /*left|right*/ item = (left ? left : right);
    arrbrr.resize((100 + arrbrr.size()));
    return (item += arrbrr.size());
}

int fu_MAIN()
{
    fu::vec<int> arr {};
    fu::vec<int> brr = fu::vec<int> {{ -101 }};
    int left = 0;
    int right = brr[0];
    return reads_from_two_args_kGbb(left, right, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn grow(ref arr: i32[], by!n: i32) {
            arr.resize(arr.len + n);
            return arr;
        }

        fn incr__ltr_oee(ref what: i32, by: i32)
            what += by;

        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])
            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            ref right = brr[0]; 

            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);
        }

---- <fail> ----
[2m[0m_0[2m.fu 22:75+3[0m:

[2m      |             ref right = brr[0]; [0m
[2m      | [0m
[2m   22 | [0m            return reads_from_two_args__single_expr(:left, :right, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mreads_from_two_args__single_expr[0m, arguments:

	    4:	[35;3mref arg[0m [94;1mreads_from_two_args__single_expr[0m:[94;1mbrr[0m and
	    2:	[35;3mref arg[0m [94;1mreads_from_two_args__single_expr[0m:[94;1mright[0m

	    both alias:

	    [35;3mmut[0m [94;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      |             mut left = 0;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mreads_from_two_args__single_expr[0m:[94;1mbrr[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mreads_from_two_args__single_expr[0m:[94;1mright[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn grow(ref arr: i32[], by!n: i32) {
            arr.resize(arr.len + n);
            return arr;
        }

        fn incr__ltr_oee(ref what: i32, by: i32)
            what += by;

        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])
            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            mut right = brr[0]; 

            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(496) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::view<int> grow_GL0m(/*3:3*/ fu::vec_range_mut<int> arr, const int n)
{
    arr.resize((arr.size() + n));
    return arr;
}

static int incr__ltr_oee_kGbb(/*3:3*/ int& what, const int by)
{
    return (what += by);
}

static int reads_from_two_args__single_expr_kGbb(/*F:F*/ int& left, /*F:F*/ int& right, /*F:C*/ fu::vec_range_mut<int> arr, /*F:C*/ fu::vec_range_mut<int> brr)
{
    int _0;
    return (_0 = grow_GL0m((arr ? arr : brr), 100).size(), incr__ltr_oee_kGbb((left ? left : right), _0));
}

int fu_MAIN()
{
    fu::vec<int> arr {};
    fu::vec<int> brr = fu::vec<int> {{ -101 }};
    int left = 0;
    int right = brr[0];
    return reads_from_two_args__single_expr_kGbb(left, right, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                /* no explicit val */   
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *  2)                ;

            return sum - 110;
        }

---- <fail> ----
[2m[0m_0[2m.fu 19:17+5[0m:

[2m      |             }[0m
[2m      | [0m
[2m   19 | [0m            arr.[31;1mveach[0m: |ref i| sum +=   
[2m      |                 (i *  2)                ;[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mveach[0m, arguments:

	    3:	[35;3minjected implicit ref arg[0m [94;1mveach[0m:[94;1mmain:arr[0m and
	    1:	[35;3marg[0m [94;1mveach[0m:[94;1mview[0m

	    both alias:

	    [35;3mmut[0m [94;1marr[0m at [2m3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1marr[0m = [ 1,1,1,1,1,10,10,10,10,10 ];
[2m      |             mut sum = 0;[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mveach[0m:[94;1mmain:arr[0m is [31;1mimplicit[0m

	    [35;3marg[0m [94;1mveach[0m:[94;1mview[0m needs an explicit [35;3mref[0m or [35;3mval[0m for disambiguation:

		- Use [35;3mref[0m if you want [35;3marg[0m [94;1mview[0m to reflect changes made to the aliased injected arg.

		- Use [35;3mval[0m if you want [35;3marg[0m [94;1mview[0m to remain constant throughout [35;3mfn[0m [94;1mveach[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                /* no explicit val */   
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                ;

            return sum - 110;
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:20+2[0m:

[2m      | [0m
[2m      |             arr.veach: |ref i| sum +=   [0m
[2m   20 | [0m                (i [31;1m*=[0m 2)                ;
[2m      | [0m
[2m      |             return sum - 110;[0m

	Bad call to [94;1m*=[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m*=[0m at [2m../../../../../[0mprelude[2m 26:10+2[0m:
[2m   26 | [0minfix fn [31;1m*=[0m (mut ref a: <T>, b: T) case (T.is::arithmetic): &mut T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mconst ref arg[0m [94;1mi[0m at [2m19:29+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m   19 | [0m            arr.veach: |ref [31;1mi[0m| sum +=   
[2m      |                 (i *= 2)                ;[0m
[2m      | [0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1m_[0m([35;3mi32[0m) at [2m19:24+1[0m
                [35;3mfn[0m [94;1mveach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@130[0m) at [2m9:16+5[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                /* no explicit val */   
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                ;

            return sum - 110;
        }

---- <fail> ----
[2m[0m_0[2m.fu 20:20+2[0m:

[2m      | [0m
[2m      |             arr.veach: |ref i| sum +=   [0m
[2m   20 | [0m                (i [31;1m*=[0m 2)                ;
[2m      | [0m
[2m      |             return sum - 110;[0m

	Bad call to [94;1m*=[0m with args ([35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m*=[0m at [2m../../../../../[0mprelude[2m 26:10+2[0m:
[2m   26 | [0minfix fn [31;1m*=[0m (mut ref a: <T>, b: T) case (T.is::arithmetic): &mut T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mconst ref arg[0m [94;1mi[0m at [2m19:29+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m   19 | [0m            arr.veach: |ref [31;1mi[0m| sum +=   
[2m      |                 (i *= 2)                ;[0m
[2m      | [0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1m_[0m([35;3mi32[0m) at [2m19:24+1[0m
                [35;3mfn[0m [94;1mveach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@130[0m) at [2m9:16+5[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                mut                     
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *  2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(130896) arc_count(11) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___M59v8SC5US5
                                #define DEF___M59v8SC5US5
inline static int _M59v(/*3:3*/ const int i, /*3:3*/ int& sum)
{
    return (sum += (i * 2));
}
                                #endif

                                #ifndef DEF_veach_kxYLn6ZqXTc
                                #define DEF_veach_kxYLn6ZqXTc
inline static void veach_kxYL(/*F:F*/ fu::view<int> view, /*E:6*/ fu::vec_range_mut<int> arr, /*E:A*/ int& sum)
{
    for (int i = 0; i < view.size(); i++)
    {
        _M59v(view[i], sum);
        arr += fu::vec<int>(/*bck:vi 0*/ arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_kxYL(fu::vec<int>(/*bck:vi 2*/ arr), arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                mut                     
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *  2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(130896) arc_count(11) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___M59v8SC5US5
                                #define DEF___M59v8SC5US5
inline static int _M59v(/*3:3*/ const int i, /*3:3*/ int& sum)
{
    return (sum += (i * 2));
}
                                #endif

                                #ifndef DEF_veach_kxYLn6ZqXTc
                                #define DEF_veach_kxYLn6ZqXTc
inline static void veach_kxYL(/*F:F*/ fu::view<int> view, /*E:6*/ fu::vec<int>& arr, /*E:A*/ int& sum)
{
    for (int i = 0; i < view.size(); i++)
    {
        _M59v(view[i], sum);
        arr += fu::vec<int>(/*bck:vi 0*/ arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_kxYL(fu::vec<int>(/*bck:vi 2*/ arr), arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                mut                     
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(131008) arc_count(12) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___FhdSPjNle1a
                                #define DEF___FhdSPjNle1a
inline static int _FhdS(/*3:1*/ int& i, /*3:3*/ int& sum)
{
    return (sum += (i *= 2));
}
                                #endif

                                #ifndef DEF_veach_oaUQkIXzFi6
                                #define DEF_veach_oaUQkIXzFi6
inline static void veach_oaUQ(fu::vec<int>&& view, /*F:6*/ fu::vec_range_mut<int> arr, /*E:A*/ int& sum)
{
    for (int i = 0; i < view.size(); i++)
    {
        _FhdS(view.mutref(i), sum);
        arr += fu::vec<int>(/*bck:vi 0*/ arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_oaUQ(fu::vec<int>(arr), arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(                   
                mut                     
                    view, fn)
            {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(131008) arc_count(12) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___FhdSPjNle1a
                                #define DEF___FhdSPjNle1a
inline static int _FhdS(/*3:1*/ int& i, /*3:3*/ int& sum)
{
    return (sum += (i *= 2));
}
                                #endif

                                #ifndef DEF_veach_oaUQkIXzFi6
                                #define DEF_veach_oaUQkIXzFi6
inline static void veach_oaUQ(fu::vec<int>&& view, /*F:6*/ fu::vec<int>& arr, /*E:A*/ int& sum)
{
    for (int i = 0; i < view.size(); i++)
    {
        _FhdS(view.mutref(i), sum);
        arr += fu::vec<int>(/*bck:vi 0*/ arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_oaUQ(fu::vec<int>(arr), arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(ref view, fn) {
                for (mut i = view.len; i --> 0; ) {
                    fn(view[i]);
                    arr ~= arr.map(|x| x * 1); // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *  2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(196160) arc_count(20) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___M59v8SC5US5
                                #define DEF___M59v8SC5US5
inline static int _M59v(/*3:3*/ const int i, /*3:3*/ int& sum)
{
    return (sum += (i * 2));
}
                                #endif

                                #ifndef DEF___BgUQGYTzuol
                                #define DEF___BgUQGYTzuol
inline static int _BgUQ(const int x)
{
    return x * 1;
}
                                #endif

                                #ifndef DEF_map_Y6yEPIJqise
                                #define DEF_map_Y6yEPIJqise
inline fu::vec<int> map_Y6yE(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _BgUQ(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_veach_jYsuUwuLt7k
                                #define DEF_veach_jYsuUwuLt7k
inline static void veach_jYsu(/*F:F*/ fu::vec_range<int> view, /*F:6*/ fu::vec_range_mut<int> arr, /*F:A*/ int& sum)
{
    for (int i = view.size(); i-- > 0; )
    {
        _M59v(view[i], sum);
        arr += map_Y6yE(arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_jYsu(arr, arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(ref view, fn) {
                for (mut i = view.len; i --> 0; ) {
                    fn(view[i]);
                    arr ~= arr.map(|x| x * 1); // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *  2)                ;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(196160) arc_count(20) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___M59v8SC5US5
                                #define DEF___M59v8SC5US5
inline static int _M59v(/*3:3*/ const int i, /*3:3*/ int& sum)
{
    return (sum += (i * 2));
}
                                #endif

                                #ifndef DEF___BgUQGYTzuol
                                #define DEF___BgUQGYTzuol
inline static int _BgUQ(const int x)
{
    return x * 1;
}
                                #endif

                                #ifndef DEF_map_Y6yEPIJqise
                                #define DEF_map_Y6yEPIJqise
inline fu::vec<int> map_Y6yE(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _BgUQ(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_veach_jYsuUwuLt7k
                                #define DEF_veach_jYsuUwuLt7k
inline static void veach_jYsu(/*F:F*/ fu::vec_range<int> view, /*F:6*/ fu::vec<int>& arr, /*F:A*/ int& sum)
{
    for (int i = view.size(); i-- > 0; )
    {
        _M59v(view[i], sum);
        arr += map_Y6yE(arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_jYsu(arr, arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(ref view, fn) {
                for (mut i = view.len; i --> 0; ) {
                    fn(view[i]);
                    arr ~= arr.map(|x| x * 1); // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                // PointlessMustSeq
;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(196160) arc_count(20) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___FhdSPjNle1a
                                #define DEF___FhdSPjNle1a
inline static int _FhdS(/*3:1*/ int& i, /*3:3*/ int& sum)
{
    return (sum += (i *= 2));
}
                                #endif

                                #ifndef DEF___BgUQGYTzuol
                                #define DEF___BgUQGYTzuol
inline static int _BgUQ(const int x)
{
    return x * 1;
}
                                #endif

                                #ifndef DEF_map_Y6yEPIJqise
                                #define DEF_map_Y6yEPIJqise
inline fu::vec<int> map_Y6yE(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _BgUQ(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_veach_9min1bDsT4c
                                #define DEF_veach_9min1bDsT4c
inline static void veach_9min(/*F:3*/ fu::vec_range_mut<int> view, /*F:6*/ fu::vec_range_mut<int> arr, /*E:A*/ int& sum)
{
    for (int i = view.size(); i-- > 0; )
    {
        _FhdS(view.mutref(i), sum);
        arr += map_Y6yE(arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_9min(arr, arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

========

        fn main() {
            mut arr = [ 1,1,1,1,1,10,10,10,10,10 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(ref view, fn) {
                for (mut i = view.len; i --> 0; ) {
                    fn(view[i]);
                    arr ~= arr.map(|x| x * 1); // Relocate arr.
                }
            }

            arr.veach: |ref i| sum +=   
                (i *= 2)                // PointlessMustSeq
;

            return sum - 110;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(196160) arc_count(20) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___FhdSPjNle1a
                                #define DEF___FhdSPjNle1a
inline static int _FhdS(/*3:1*/ int& i, /*3:3*/ int& sum)
{
    return (sum += (i *= 2));
}
                                #endif

                                #ifndef DEF___BgUQGYTzuol
                                #define DEF___BgUQGYTzuol
inline static int _BgUQ(const int x)
{
    return x * 1;
}
                                #endif

                                #ifndef DEF_map_Y6yEPIJqise
                                #define DEF_map_Y6yEPIJqise
inline fu::vec<int> map_Y6yE(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _BgUQ(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_veach_9min1bDsT4c
                                #define DEF_veach_9min1bDsT4c
inline static void veach_9min(/*F:3*/ fu::vec_range_mut<int> view, /*F:6*/ fu::vec<int>& arr, /*E:A*/ int& sum)
{
    for (int i = view.size(); i-- > 0; )
    {
        _FhdS(view.mutref(i), sum);
        arr += map_Y6yE(arr);
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 1, 1, 1, 1, 10, 10, 10, 10, 10 }};
    int sum = 0;
    veach_9min(arr, arr, sum);
    return sum - 110;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

========

        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }

        import _0;

        fn ensureParsed(fname: string) {
            let module = getModule(fname);
            if (!module.in)
                return getFile(fname).len

                    || module.in.len;


            return module.in.len;
        }

        fn main() {
            implicit mut ctx: Context;
            return ensureParsed("a") - 4;
        }

---- <fail> ----
[2m[0m_1[2m.fu 9:24+6[0m:

[2m      |                 return getFile(fname).len[0m
[2m      | [0m
[2m    9 | [0m                    || [31;1mmodule[0m.in.len;
[2m      | [0m
[2m      | [0m

	Cannot access [35;3mlet[0m [94;1mmodule[0m, reference invalidated by write to [35;3minjected implicit mut ref arg[0m [94;1mctx[0m at [2m7:24+7[0m:

[2m      |             let module = getModule(fname);[0m
[2m      |             if (!module.in)[0m
[2m    7 | [0m                return [31;1mgetFile[0m(fname).len
[2m      | [0m
[2m      |                     || module.in.len;[0m

	At call to [35;3mfn[0m [94;1mgetFile[0m
            via [35;3m__native[0m [94;1m.mutref[0m at [2m[0m_0[2m.fu 14:39+1[0m:

[2m      |             for (mut i = 0; i < ctx.modules.len; i++)[0m
[2m      |                 if (ctx.modules[i].fname == fname)[0m
[2m   14 | [0m                    return ctx.modules[31;1m[[0mi].in;
[2m      | [0m
[2m      |             ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');[0m


    BorrowCheck [35;3mfn[0m [94;1mensureParsed[0m([35;3mstring[0m) at [2m4:12+12[0m

========

        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }

        import _0;

        fn ensureParsed(fname: string) {
            let module = getModule(fname);
            if (!module.in)
                return getFile(fname).len

                    || throw(fname);


            return module.in.len;
        }

        fn main() {
            implicit mut ctx: Context;
            return ensureParsed("a") - 4;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Context_bbKU;
struct Module_NKGv;
const Module_NKGv& getModule_MbR9(fu::view<char>, const Context_bbKU&);
fu::str& getFile_MbR9(fu::vec_range<char>, Context_bbKU&);

                                #ifndef DEF_Context_bbKUnpd5s04
                                #define DEF_Context_bbKUnpd5s04
struct Context_bbKU
{
                                // shape_hash:    db206b0da32fcae2
                                // non_triv_mask: 0000820400000002
    fu::vec<Module_NKGv> modules;
    Context_bbKU(const Context_bbKU&) = delete;
    Context_bbKU(Context_bbKU&&) = default;
    Context_bbKU& operator=(const Context_bbKU&) = delete;
    Context_bbKU& operator=(Context_bbKU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_NKGvh4oQfS4
                                #define DEF_Module_NKGvh4oQfS4
struct Module_NKGv
{
                                // shape_hash:    595e03778de78c83
                                // non_triv_mask: 0000820000000000
    fu::str in;
    fu::str fname;
    Module_NKGv(const Module_NKGv&) = delete;
    Module_NKGv(Module_NKGv&&) = default;
    Module_NKGv& operator=(const Module_NKGv&) = delete;
    Module_NKGv& operator=(Module_NKGv&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || in
            || fname
        ;
    }
};
                                #endif

                                #ifndef STR_ujDub247BYe
                                #define STR_ujDub247BYe
static const fu::str str_ujDub247BYe fu_INIT_PRIORITY(1002) { "a"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int ensureParsed_LtD7(/*3:3*/ fu::vec_range<char> fname, /*2:2*/ Context_bbKU& ctx)
{
    const Module_NKGv& /*ctx|zeroes|static*/ module = getModule_MbR9(fname, ctx);
    if (!module.in)
    {
        int _0;
        return (_0 = getFile_MbR9(fname, ctx).size()) ? _0 : fu::fail(fu::str(fname));
    }
    else
        return module.in.size();

}

int fu_MAIN()
{
    Context_bbKU ctx {};
    return ensureParsed_LtD7(str_ujDub247BYe, ctx) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Context_bbKU;
struct Module_NKGv;

                                #ifndef DEF_Context_bbKUnpd5s04
                                #define DEF_Context_bbKUnpd5s04
struct Context_bbKU
{
                                // shape_hash:    db206b0da32fcae2
                                // non_triv_mask: 0000820400000002
    fu::vec<Module_NKGv> modules;
    Context_bbKU(const Context_bbKU&) = delete;
    Context_bbKU(Context_bbKU&&) = default;
    Context_bbKU& operator=(const Context_bbKU&) = delete;
    Context_bbKU& operator=(Context_bbKU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_NKGvh4oQfS4
                                #define DEF_Module_NKGvh4oQfS4
struct Module_NKGv
{
                                // shape_hash:    595e03778de78c83
                                // non_triv_mask: 0000820000000000
    fu::str in;
    fu::str fname;
    Module_NKGv(const Module_NKGv&) = delete;
    Module_NKGv(Module_NKGv&&) = default;
    Module_NKGv& operator=(const Module_NKGv&) = delete;
    Module_NKGv& operator=(Module_NKGv&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || in
            || fname
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

fu::str& getFile_MbR9(/*3:3*/ fu::vec_range<char> fname, /*3:3*/ Context_bbKU& ctx)
{
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        if (ctx.modules[i].fname == fname)
            return ctx.modules.mutref(i).in;

    };
    ctx.modules += Module_NKGv { (((fname + '\n') + fname) + '\n'), fu::str(fname) };
    return ctx.modules.mutref((ctx.modules.size() - 1)).in;
}

const Module_NKGv& getModule_MbR9(/*3:3*/ fu::view<char> fname, /*3:3*/ const Context_bbKU& ctx)
{
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    };
    return (*(Module_NKGv*)fu::NIL);
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec

========

        nocopy struct NCThing {
            items: i32[];
        };

        fn mut_in_loop_before_break(ref thing: NCThing) {
            mut sum = 0;

            ref items = thing.items;
            for (mut i = 0; i < items.len; i++)
            {
                sum += items[i];
                if (sum > 10)
                {
                    thing = NCThing();

                    if (sum > 20)                                    // !DEV_DontFoldLiterals
                        break;
                }

                items[i] *= 2;
            }

            return sum;
        }

        fn main() {
            mut thing = NCThing([ 10 ]);
            return mut_in_loop_before_break(thing)
                 + mut_in_loop_before_break(thing)
                 - 30
                 + thing.items.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 15:27+1[0m:

[2m      |                 if (sum > 10)[0m
[2m      |                 {[0m
[2m   15 | [0m                    thing [31;1m=[0m NCThing();
[2m      | [0m
[2m      |                     if (sum > 20)                                    // !DEV_DontFoldLiterals[0m

	Write to [35;3mmut ref arg[0m [94;1mthing[0m at call to [35;3m__native[0m [94;1m=[0m invalidates the use of [35;3mmut ref[0m [94;1mitems[0m at [2m10:33+5[0m:

[2m      | [0m
[2m      |             ref items = thing.items;[0m
[2m   10 | [0m            for (mut i = 0; i < [31;1mitems[0m.len; i++)
[2m      |             {[0m
[2m      |                 sum += items[i];[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mmut_in_loop_before_break[0m([94;1mNCThing[0m) at [2m6:12+24[0m

========

        nocopy struct NCThing {
            items: i32[];
        };

        fn mut_in_loop_before_break(ref thing: NCThing) {
            mut sum = 0;

            ref items = thing.items;
            for (mut i = 0; i < items.len; i++)
            {
                sum += items[i];
                if (sum > 10)
                {
                    thing = NCThing();

                    if (true)                                        // !DEV_DontFoldLiterals
                        break;
                }

                items[i] *= 2;
            }

            return sum;
        }

        fn main() {
            mut thing = NCThing([ 10 ]);
            return mut_in_loop_before_break(thing)
                 + mut_in_loop_before_break(thing)
                 - 30
                 + thing.items.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct NCThing_GTVB;

                                #ifndef DEF_NCThing_GTVBQ70i4ob
                                #define DEF_NCThing_GTVBQ70i4ob
struct NCThing_GTVB
{
                                // shape_hash:    898b2dcbe5345a48
                                // non_triv_mask: 0008001000000000
    fu::vec<int> items;
    NCThing_GTVB(const NCThing_GTVB&) = delete;
    NCThing_GTVB(NCThing_GTVB&&) = default;
    NCThing_GTVB& operator=(const NCThing_GTVB&) = delete;
    NCThing_GTVB& operator=(NCThing_GTVB&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int mut_in_loop_before_break_MbR9(/*1:1*/ NCThing_GTVB& thing)
{
    int sum = 0;
    fu::view_mut<int> /*thing*/ items = thing.items;
    for (int i = 0; i < items.size(); i++)
    {
        sum += items[i];
        if (sum > 10)
        {
            thing = NCThing_GTVB{};
            break;
        }
        else
            items.mutref(i) *= 2;

    };
    return sum;
}

int fu_MAIN()
{
    NCThing_GTVB thing = NCThing_GTVB { fu::vec<int> {{ 10 }} };
    int _0;
    int _1;
    return (_1 = ((_0 = mut_in_loop_before_break_MbR9(thing), (_0 + mut_in_loop_before_break_MbR9(thing))) - 30), (_1 + thing.items.size()));
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_BckMustSeq

========

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            ref x = xy.x;                                   

            pragma emit(`
                `xy`.x++;
            `);

            return x - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 13:20+1[0m:

[2m      |             `);[0m
[2m      | [0m
[2m   13 | [0m            return [31;1mx[0m - 1;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1mx[0m, reference invalidated by write to [35;3mmut[0m [94;1mxy[0m at [2m10:18+2[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m   10 | [0m                `[31;1mxy[0m`.x++;
[2m      |             `);[0m
[2m      | [0m

	via pragma [94;1memit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            fn  x = xy.x;                                   

            pragma emit(`
                `xy`.x++;
            `);

            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int x_kGbb(/*1:1*/ const XY_tqAU& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    XY_tqAU xy {};

                xy.x++;

    return x_kGbb(xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            ref x = xy.x;                  

            while (!x)
                pragma emit(`
                    `xy`.x++;
                `);

            return xy.x - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:22+2[0m:

[2m      |             while (!x)[0m
[2m      |                 pragma emit(`[0m
[2m   11 | [0m                    `[31;1mxy[0m`.x++;
[2m      |                 `);[0m
[2m      | [0m

	Write to [35;3mmut[0m [94;1mxy[0m invalidates the use of [35;3mconst ref[0m [94;1mx[0m at [2m9:21+1[0m:

[2m      |             ref x = xy.x;                  [0m
[2m      | [0m
[2m    9 | [0m            while (![31;1mx[0m)
[2m      |                 pragma emit(`[0m
[2m      |                     `xy`.x++;[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            fn  x = xy.x;                  

            while (!x)
                pragma emit(`
                    `xy`.x++;
                `);

            return xy.x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int x_GL0m(/*1:1*/ const XY_tqAU& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    XY_tqAU xy {};
    while (!x_GL0m(xy))
    {

                    xy.x++;

    };
    return xy.x - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct XY { x: i32; y: i32 };

        fn bckErr_fromPragmaEmit(ref xy: XY) {
            pragma emit(`
                `xy`.x++;
            `);
        }

        fn main() {
            mut xy: XY;

            ref x = xy.x;        

            bckErr_fromPragmaEmit(xy);
            return x - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:20+1[0m:

[2m      | [0m
[2m      |             bckErr_fromPragmaEmit(xy);[0m
[2m   16 | [0m            return [31;1mx[0m - 1;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mconst ref[0m [94;1mx[0m, reference invalidated by write to [35;3mmut[0m [94;1mxy[0m at [2m15:13+21[0m:

[2m      |             ref x = xy.x;        [0m
[2m      | [0m
[2m   15 | [0m            [31;1mbckErr_fromPragmaEmit[0m(xy);
[2m      |             return x - 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mbckErr_fromPragmaEmit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m10:12+4[0m

========

        struct XY { x: i32; y: i32 };

        fn bckErr_fromPragmaEmit(ref xy: XY) {
            pragma emit(`
                `xy`.x++;
            `);
        }

        fn main() {
            mut xy: XY;

            fn  x = xy.x;        

            bckErr_fromPragmaEmit(xy);
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void bckErr_fromPragmaEmit_MbR9(/*1:1*/ XY_tqAU& xy)
{

                xy.x++;

}

static int x_kGbb(/*1:1*/ const XY_tqAU& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    XY_tqAU xy {};
    bckErr_fromPragmaEmit_MbR9(xy);
    return x_kGbb(xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct XY { x: i32; y: i32 };

        fn test(ref xy: XY, ref zw: XY) {

            ref x = xy.x;                                   

            pragma emit(`
                `xy || zw`.x++;
            `);

            return x;
        }

        fn main() {
            mut xy: XY;
            return test(xy, xy) - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 12:20+1[0m:

[2m      |             `);[0m
[2m      | [0m
[2m   12 | [0m            return [31;1mx[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mx[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mxy[0m at [2m9:21+2[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m    9 | [0m                `xy [31;1m||[0m zw`.x++;
[2m      |             `);[0m
[2m      | [0m

	via pragma [94;1memit[0m

    BorrowCheck [35;3mfn[0m [94;1mtest[0m([94;1mXY[0m, [94;1mXY[0m) at [2m4:12+4[0m

========

        struct XY { x: i32; y: i32 };

        fn test(ref xy: XY, ref zw: XY) {

            fn  x = xy.x;                                   

            pragma emit(`
                `xy || zw`.x++;
            `);

            return x;
        }

        fn main() {
            mut xy: XY;
            return test(xy, xy) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int x_kGbb(/*1:1*/ const XY_tqAU& xy)
{
    return xy.x;
}

static int test_kGbb(/*3:3*/ XY_tqAU& xy, /*3:2*/ XY_tqAU& zw)
{

                (xy ? xy : zw).x++;

    return x_kGbb(xy);
}

int fu_MAIN()
{
    XY_tqAU xy {};
    return test_kGbb(xy, xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========

        struct Ext { ext: Ext[] };

        fn EXT(implicit ext: Ext[], a: i32) ext[a];

        fn EXT_insert(implicit ref ext: Ext[], a: i32) {
            ext.insert(a, Ext());
            return ext[a];
        }

        fn solveTypedef(a: i32, b: i32) EXT_insert(a) = EXT(b);

        fn main() {
            implicit mut ext = [ Ext([ Ext, Ext ]) ];

            for (mut i = 0; i < 128; i++)
                solveTypedef(0, 0);

            return ext[0].ext.len == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(8080) arc_count(7) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Ext_zAXg;

                                #ifndef DEF_Ext_zAXgx5NezN6
                                #define DEF_Ext_zAXgx5NezN6
struct Ext_zAXg
{
                                // shape_hash:    7f992244f17a23f4
                                // non_triv_mask: 0100000000000800
    fu::vec<Ext_zAXg> ext;
    Ext_zAXg(const Ext_zAXg&) = default;
    Ext_zAXg(Ext_zAXg&&) = default;
    Ext_zAXg& operator=(Ext_zAXg&&) = default;
    Ext_zAXg& operator=(const Ext_zAXg& selfrec) { return *this = Ext_zAXg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || ext
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Ext_zAXg& EXT_MbR9(const int a, /*3:3*/ fu::view<Ext_zAXg> ext)
{
    return ext[a];
}

static Ext_zAXg& EXT_insert_MbR9(const int a, /*3:3*/ fu::vec_range_mut<Ext_zAXg> ext)
{
    ext.insert(a, Ext_zAXg{});
    return ext.mutref(a);
}

static const Ext_zAXg& solveTypedef_kGbb(const int a, const int b, /*7:7*/ fu::vec_range_mut<Ext_zAXg> ext)
{
    return (EXT_insert_MbR9(a, ext) = Ext_zAXg(EXT_MbR9(b, ext)));
}

int fu_MAIN()
{
    fu::vec<Ext_zAXg> ext = fu::vec<Ext_zAXg> {{ Ext_zAXg { fu::vec<Ext_zAXg> {{ Ext_zAXg{}, Ext_zAXg{} }} } }};
    for (int i = 0; i < 128; i++)
        solveTypedef_kGbb(0, 0, ext);

    if (ext[0].ext.size() == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn ints(implicit ref _ints: i32[]) _ints;
        fn sum (implicit ref _sum:  i32)   _sum;

        // while trying to sort implicit args i noticed tests didnt catch
        //  args getting reordered but AAR masks not updating
        //   this tries to reproduce the same thing
        fn flippedInjectedArgsWithBrokenAARMasks()
            if (sum) // the point of this is to inject _sum before _ints
                for (mut i = ints.len; i --> 0; )
                    ints.push(sum);

        fn main() {
            implicit mut _ints: i32[] = [ 0 ];

            implicit ref _sum = _ints[0];


            flippedInjectedArgsWithBrokenAARMasks();
            return ints[0];
        }

---- <fail> ----
[2m[0m_0[2m.fu 19:13+37[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            [31;1mflippedInjectedArgsWithBrokenAARMasks[0m();
[2m      |             return ints[0];[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mflippedInjectedArgsWithBrokenAARMasks[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mflippedInjectedArgsWithBrokenAARMasks[0m:[94;1m_ints[0m and
	    1:	[35;3minjected implicit ref arg[0m [94;1mflippedInjectedArgsWithBrokenAARMasks[0m:[94;1m_sum[0m

	    both alias:

	    [35;3mimplicit mut[0m [94;1m_ints[0m at [2m14:26+5[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            implicit mut [31;1m_ints[0m: i32[] = [ 0 ];
[2m      | [0m
[2m      |             implicit ref _sum = _ints[0];[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mflippedInjectedArgsWithBrokenAARMasks[0m:[94;1m_ints[0m is [31;1mimplicit[0m

	    [35;3minjected implicit ref arg[0m [94;1mflippedInjectedArgsWithBrokenAARMasks[0m:[94;1m_sum[0m is [31;1mimplicit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn ints(implicit ref _ints: i32[]) _ints;
        fn sum (implicit ref _sum:  i32)   _sum;

        // while trying to sort implicit args i noticed tests didnt catch
        //  args getting reordered but AAR masks not updating
        //   this tries to reproduce the same thing
        fn flippedInjectedArgsWithBrokenAARMasks()
            if (sum) // the point of this is to inject _sum before _ints
                for (mut i = ints.len; i --> 0; )
                    ints.push(sum);

        fn main() {
            implicit mut _ints: i32[] = [ 0 ];

            implicit mut _sum = 0;


            flippedInjectedArgsWithBrokenAARMasks();
            return ints[0];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int sum_GL0m(/*1:1*/ const int _sum)
{
    return _sum;
}

static fu::view<int> ints_GL0m(/*1:1*/ fu::view<int> _ints)
{
    return _ints;
}

static int sum_kGbb(/*1:1*/ const int _sum)
{
    return _sum;
}

static fu::vec_range_mut<int> ints_MbR9(/*1:1*/ fu::vec_range_mut<int> _ints)
{
    return _ints;
}

static void flippedInjectedArgsWithBrokenAARMasks_MbR9(/*3:3*/ const int _sum, /*3:2*/ fu::vec_range_mut<int> _ints)
{
    if (sum_GL0m(_sum))
        for (int i = ints_GL0m(_ints).size(); i-- > 0; )
            ints_MbR9(_ints).push(sum_kGbb(_sum));
;
}

int fu_MAIN()
{
    fu::vec<int> _ints = fu::vec<int> {{ 0 }};
    const int _sum = 0;
    flippedInjectedArgsWithBrokenAARMasks_MbR9(_sum, _ints);
    return ints_GL0m(_ints)[0];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Node {
            nodes: Node[];
        };

        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {
            for (mut i = 0; i < 100; i++)
                willPush.nodes ~= pushWhat;
        }

        noinline fn clear_and_return_ref_to_self(ref node: Node) {
            node.nodes.clear();
            return node;
        }

        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {
            return append_a_onto_b_100_times(
                // indexes inside, should crash
                willPush.nodes[0],
                // empties the nodes
                clear_and_return_ref_to_self(willEmpty));
        }

        fn main() {
            mut willEmpty: Node = [[ Node() ]];


            crash_if_b_refs_into_a(willEmpty, willEmpty);


            return willEmpty.nodes.len == 0 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 28:47+9[0m:

[2m      | [0m
[2m      | [0m
[2m   28 | [0m            crash_if_b_refs_into_a(willEmpty, [31;1mwillEmpty[0m);
[2m      | [0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mcrash_if_b_refs_into_a[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mcrash_if_b_refs_into_a[0m:[94;1mwillPush[0m and
	    1:	[35;3mref arg[0m [94;1mcrash_if_b_refs_into_a[0m:[94;1mwillEmpty[0m

	    both alias:

	    [35;3mmut[0m [94;1mwillEmpty[0m at [2m25:17+9[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   25 | [0m            mut [31;1mwillEmpty[0m: Node = [[ Node() ]];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mcrash_if_b_refs_into_a[0m:[94;1mwillPush[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mcrash_if_b_refs_into_a[0m:[94;1mwillEmpty[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m24:12+4[0m

========

        struct Node {
            nodes: Node[];
        };

        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {
            for (mut i = 0; i < 100; i++)
                willPush.nodes ~= pushWhat;
        }

        noinline fn clear_and_return_ref_to_self(ref node: Node) {
            node.nodes.clear();
            return node;
        }

        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {
            return append_a_onto_b_100_times(
                // indexes inside, should crash
                willPush.nodes[0],
                // empties the nodes
                clear_and_return_ref_to_self(willEmpty));
        }

        fn main() {
            mut willEmpty: Node = [[ Node() ]];


            mut willPush = willEmpty;
            crash_if_b_refs_into_a(willEmpty, willPush);


            return willEmpty.nodes.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(4000) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct Node_DjxN;

                                #ifndef DEF_Node_DjxNXRoJmS1
                                #define DEF_Node_DjxNXRoJmS1
struct Node_DjxN
{
                                // shape_hash:    d4c39a2aa877cd51
                                // non_triv_mask: 0002000000000200
    fu::vec<Node_DjxN> nodes;
    Node_DjxN(const Node_DjxN&) = default;
    Node_DjxN(Node_DjxN&&) = default;
    Node_DjxN& operator=(Node_DjxN&&) = default;
    Node_DjxN& operator=(const Node_DjxN& selfrec) { return *this = Node_DjxN(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Node_DjxN& clear_and_return_ref_to_self_kGbb(/*1:1*/ Node_DjxN& node)
{
    node.nodes.clear();
    return node;
}

static void append_a_onto_b_100_times_MbR9(/*3:1*/ Node_DjxN& willPush, /*3:3*/ const Node_DjxN& pushWhat)
{
    for (int i = 0; i < 100; i++)
        willPush.nodes += Node_DjxN(pushWhat);

}

static void crash_if_b_refs_into_a_MbR9(/*3:1*/ Node_DjxN& willEmpty, /*2:2*/ Node_DjxN& willPush)
{
    const Node_DjxN* _0;
    (_0 = &(clear_and_return_ref_to_self_kGbb(willEmpty)), append_a_onto_b_100_times_MbR9(willPush.nodes.mutref(0), *_0));
}

int fu_MAIN()
{
    Node_DjxN willEmpty = Node_DjxN { fu::vec<Node_DjxN> {{ Node_DjxN{} }} };
    Node_DjxN willPush = willEmpty;
    crash_if_b_refs_into_a_MbR9(willEmpty, willPush);
    if (willEmpty.nodes.size() == 0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq, N_COWRestrict

========

        struct Node { nodes: Node[] };

        noinline fn soft_risk_inner(ref a: Node, ref b: Node)
            for (mut i = 0; i < 100; i++)
                a.nodes ~= b;

        noinline fn soft_risk_outer(ref a: Node, ref b: Node)
            soft_risk_inner(a, b.nodes[0]);

        fn main() {
            mut root = Node([ Node ]);


            soft_risk_outer(root, root);    

            return root.nodes.len == 101 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 15:35+4[0m:

[2m      | [0m
[2m      | [0m
[2m   15 | [0m            soft_risk_outer(root, [31;1mroot[0m);    
[2m      | [0m
[2m      |             return root.nodes.len == 101 ? 0 : 1;[0m

	At call to [35;3mfn[0m [94;1msoft_risk_outer[0m, arguments:

	    2:	[35;3mref arg[0m [94;1msoft_risk_outer[0m:[94;1mb[0m and
	    1:	[35;3mref arg[0m [94;1msoft_risk_outer[0m:[94;1ma[0m

	    both alias:

	    [35;3mmut[0m [94;1mroot[0m at [2m12:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   12 | [0m            mut [31;1mroot[0m = Node([ Node ]);
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1msoft_risk_outer[0m:[94;1mb[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1msoft_risk_outer[0m:[94;1ma[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m11:12+4[0m

========

        struct Node { nodes: Node[] };

        noinline fn soft_risk_inner(ref a: Node, ref b: Node)
            for (mut i = 0; i < 100; i++)
                a.nodes ~= b;

        noinline fn soft_risk_outer(ref a: Node, ref b: Node)
            soft_risk_inner(a, b.nodes[0]);

        fn main() {
            mut root = Node([ Node ]);


            mut cpy = root;
            soft_risk_outer(root, cpy);     

            return root.nodes.len == 101 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(4000) arc_count(6) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct Node_DjxN;

                                #ifndef DEF_Node_DjxNXRoJmS1
                                #define DEF_Node_DjxNXRoJmS1
struct Node_DjxN
{
                                // shape_hash:    d4c39a2aa877cd51
                                // non_triv_mask: 0002000000000200
    fu::vec<Node_DjxN> nodes;
    Node_DjxN(const Node_DjxN&) = default;
    Node_DjxN(Node_DjxN&&) = default;
    Node_DjxN& operator=(Node_DjxN&&) = default;
    Node_DjxN& operator=(const Node_DjxN& selfrec) { return *this = Node_DjxN(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void soft_risk_inner_MbR9(/*3:1*/ Node_DjxN& a, /*3:3*/ const Node_DjxN& b)
{
    for (int i = 0; i < 100; i++)
        a.nodes += Node_DjxN(b);

}

static void soft_risk_outer_MbR9(/*1:1*/ Node_DjxN& a, /*3:3*/ const Node_DjxN& b)
{
    soft_risk_inner_MbR9(a, b.nodes[0]);
}

int fu_MAIN()
{
    Node_DjxN root = Node_DjxN { fu::vec<Node_DjxN> {{ Node_DjxN{} }} };
    Node_DjxN cpy = root;
    soft_risk_outer_MbR9(root, cpy);
    if (root.nodes.size() == 101)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct ScopeItem { k: string; v: i32 };

        fn dequalify_andGetScope(ref id: string, implicit locals: ScopeItem[], implicit globals: ScopeItem[]) {
            if (id.ends(with: "g")) {
                id.pop();
                return globals;
            }

            return locals;
        }

        fn solveAddrOfFn(mut id: string) {
            fn visitScope(items: ScopeItem[]) {
                items.each: |item|
                    if (item.k == id)
                        return item.v;

                return -1;
            }

            // on gcc visitScope:id bound to a slice before mutation
            return visitScope(dequalify_andGetScope(id));       // N_BckMustSeq
        }

        fn main() {
            let implicit locals  = [ ScopeItem("a", 1), ScopeItem("b", 2), ScopeItem("c", 3) ];
            let implicit globals = [ ScopeItem("a", 10), ScopeItem("b", 20), ScopeItem("c", 30) ];
            let result = solveAddrOfFn("a") + solveAddrOfFn("bg");
            return result == 21 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct ScopeItem_Jnaj;

                                #ifndef DEF_ScopeItem_JnajlFw2PXj
                                #define DEF_ScopeItem_JnajlFw2PXj
struct ScopeItem_Jnaj
{
                                // shape_hash:    f7c64f54f6e1b88e
                                // non_triv_mask: 0000800000000008
    fu::str k;
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_ends_OW45P9GlDid
                                #define DEF_ends_OW45P9GlDid
inline bool ends_OW45(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

static fu::view<ScopeItem_Jnaj> dequalify_andGetScope_kGbb(/*7:3*/ fu::vec_range_mut<char> id, /*7:7*/ fu::view<ScopeItem_Jnaj> locals, /*7:7*/ fu::vec_range<ScopeItem_Jnaj> globals)
{
    if (ends_OW45(id, "g"_view))
    {
        id.pop();
        return globals;
    }
    else
        return locals;

}

static int visitScope_MbR9(/*3:3*/ fu::view<ScopeItem_Jnaj> items, /*3:3*/ fu::view<char> id)
{
    for (int i = 0; i < items.size(); i++)
    {
        const ScopeItem_Jnaj& /*items|static*/ item = items[i];
        if (item.k == id)
            return item.v;

    };
    return -1;
}

static int solveAddrOfFn_MbR9(fu::str&& id, /*7:7*/ fu::view<ScopeItem_Jnaj> locals, /*7:7*/ fu::vec_range<ScopeItem_Jnaj> globals)
{
    fu::view<ScopeItem_Jnaj> _0 {};
    return (_0.ptr_reassign(dequalify_andGetScope_kGbb(id, locals, globals)), visitScope_MbR9(_0, id));
}

int fu_MAIN()
{
    fu::vec<ScopeItem_Jnaj> locals = fu::vec<ScopeItem_Jnaj> {{ ScopeItem_Jnaj { fu::str("a"_fu), 1 }, ScopeItem_Jnaj { fu::str("b"_fu), 2 }, ScopeItem_Jnaj { fu::str("c"_fu), 3 } }};
    fu::vec<ScopeItem_Jnaj> globals = fu::vec<ScopeItem_Jnaj> {{ ScopeItem_Jnaj { fu::str("a"_fu), 10 }, ScopeItem_Jnaj { fu::str("b"_fu), 20 }, ScopeItem_Jnaj { fu::str("c"_fu), 30 } }};
    const int result = (solveAddrOfFn_MbR9(fu::str("a"_fu), locals, globals) + solveAddrOfFn_MbR9(fu::str("bg"_fu), locals, globals));
    if (result == 21)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========

        fn cmp_ooe(mut stuff: i32[], ref needSort: bool) {
            mut result: i32[] = [];
            mut last = -1;
            for (mut i = 0; i < stuff.len; i++) {
                let t = stuff[i];
                if !(t & 1) continue;
                if (last > (last = t)) needSort = true;
                result ~= t;
            }

            if (needSort) result.sort();
            return result;
        }

        fn checksum(stuff: i32[]) {
            mut result = 0;
            for (mut i = 0; i < stuff.len; i++) {
                result *= stuff[i];
                result += stuff[i];
            }
            return result;
        }

        fn main() {
            mut needSort = false;
            let aa = checksum(cmp_ooe([1, 2, 3, 4, 5], :needSort));
            let bb = !needSort
                  && checksum(cmp_ooe([7, 4, 3, 2, 1], :needSort));

            return needSort ? aa * 100 + bb - 3549 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___4R272s5d0ui
                                #define DEF___4R272s5d0ui
inline static bool _4R27(const int l, const int r)
{
    return x3Cx3E_odNT(l, r) < 0;
}
                                #endif

                                #ifndef DEF_sort_5CKC5ctRtxg
                                #define DEF_sort_5CKC5ctRtxg
inline static void sort_5CKC(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _4R27(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_DsMxGE4CSfj
                                #define DEF_sort_DsMxGE4CSfj
inline void sort_DsMx(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_5CKC(a);
}
                                #endif

static fu::vec<int> cmp_ooe_MbR9(/*3:3*/ fu::view<int> stuff, /*2:2*/ bool& needSort)
{
    /*MOV*/ fu::vec<int> result {};
    int last = -1;
    for (int i = 0; i < stuff.size(); i++)
    {
        const int /*stuff|static*/ t = stuff[i];
        if (!(!(t & 1)))
        {
            int _0;
            if ((_0 = last, (_0 > (last = t))))
                needSort = true;

            result += t;
        };
    };
    if (needSort)
        sort_DsMx(result);

    return /*NRVO*/ result;
}

static int checksum_MbR9(/*1:1*/ fu::view<int> stuff)
{
    int result = 0;
    for (int i = 0; i < stuff.size(); i++)
    {
        result *= stuff[i];
        result += stuff[i];
    };
    return result;
}

int fu_MAIN()
{
    bool needSort = false;
    const int aa = checksum_MbR9(cmp_ooe_MbR9(fu::view<int> {{ 1, 2, 3, 4, 5 }}, needSort));
    const int bb = (!needSort ? checksum_MbR9(cmp_ooe_MbR9(fu::view<int> {{ 7, 4, 3, 2, 1 }}, needSort)) : 0);
    if (needSort)
        return ((aa * 100) + bb) - 3549;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========

        fn clearAndReturn(ref a: i32[]) {
            a.clear();
            return a;
        }


        fn refOOE(b: i32[], ref a: i32[]) 
            a ~= b;

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
            refOOE(a: clearAndReturn(ints), b: ints);
            return ints.len - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec_range_mut<int> clearAndReturn_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    a.clear();
    return a;
}

static fu::view<int> refOOE_GL0m(/*3:3*/ fu::view<int> b, /*2:2*/ fu::vec_range_mut<int> a)
{
    return (a += b);
}

int fu_MAIN()
{
    fu::vec<int> ints = fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> _0 {};
    (_0 = fu::vec<int>(/*bck:pra 1*/ ints), refOOE_GL0m(static_cast<fu::vec<int>&&>(_0), clearAndReturn_MbR9(ints)));
    return ints.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn clearAndReturn(ref a: i32[]) {
            a.clear();
            return a;
        }


        fn refOOE(ref a: i32[], b: i32[]) 
            a ~= b;

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
            refOOE(a: clearAndReturn(ints), b: ints);
            return ints.len - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec_range_mut<int> clearAndReturn_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    a.clear();
    return a;
}

static fu::view<int> refOOE_GL0m(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    return (a += b);
}

int fu_MAIN()
{
    fu::vec<int> ints = fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }};
    fu::vec<int> _0 {};
    (_0 = fu::vec<int>(/*bck:pra 1*/ ints), refOOE_GL0m(clearAndReturn_MbR9(ints), static_cast<fu::vec<int>&&>(_0)));
    return ints.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, val slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                nodes = nodes.map(|lax n| Node(zero));


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Node_TXsI;
struct Type_UW1G;
inline int x3Cx3E_DHze(const Type_UW1G&, const Type_UW1G&);

                                #ifndef DEF_Type_UW1GqnGPECb
                                #define DEF_Type_UW1GqnGPECb
struct Type_UW1G
{
                                // shape_hash:    8bdba7c21dae2678
                                // non_triv_mask: 8000000000000010
    fu::vec<Type_UW1G> nontriv;
    Type_UW1G(const Type_UW1G&) = default;
    Type_UW1G(Type_UW1G&&) = default;
    Type_UW1G& operator=(Type_UW1G&&) = default;
    Type_UW1G& operator=(const Type_UW1G& selfrec) { return *this = Type_UW1G(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_TXsI1DZiWJ8
                                #define DEF_Node_TXsI1DZiWJ8
struct Node_TXsI
{
                                // shape_hash:    10be10edbe0cfc56
                                // non_triv_mask: a000000000000010
    Type_UW1G type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_UW1G one fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{} }} };

static const Type_UW1G two fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{}, Type_UW1G{} }} };

static const Type_UW1G zero fu_INIT_PRIORITY(1001) {};

                                #ifndef DEF___dOrmUrWWjUk
                                #define DEF___dOrmUrWWjUk
inline static Node_TXsI _dOrm()
{
    return Node_TXsI { Type_UW1G(zero) };
}
                                #endif

                                #ifndef DEF_map_ppIC5ANrC9a
                                #define DEF_map_ppIC5ANrC9a
inline fu::vec<Node_TXsI> map_ppIC(/*3:3*/ fu::view<Node_TXsI> a)
{
    /*MOV*/ fu::vec<Node_TXsI> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _dOrm();

    return /*NRVO*/ res;
}
                                #endif

static void propagateType_MbR9(/*7:7*/ const Node_TXsI& node, /*7:7*/ const Type_UW1G& slot, /*5:5*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    const Type_UW1G& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    nodes = map_ppIC(nodes);
    nodes += Node_TXsI { Type_UW1G(slot_1) };
}

static void solve_MbR9(/*1:1*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const Node_TXsI& /*nodes|static*/ node = nodes[i];
        propagateType_MbR9(node, Type_UW1G(/*bck:vi 2*/ node.type), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_JfC9WhxQSX3
                                #define DEF_x3Cx3E_JfC9WhxQSX3
inline int x3Cx3E_JfC9(/*3:3*/ fu::view<Type_UW1G> a, /*3:3*/ fu::view<Type_UW1G> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_DHze(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_DHzeBXr3l39
                                #define DEF_x3Cx3E_DHzeBXr3l39
inline int x3Cx3E_DHze(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_JfC9(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_pDf9BNAbkg1
                                #define DEF_x3Dx3D_pDf9BNAbkg1
inline bool operator==(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    return !x3Cx3E_DHze(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Node_TXsI> nodes = fu::vec<Node_TXsI> {{ Node_TXsI { Type_UW1G(one) } }};
    solve_MbR9(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

========

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, val slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                nodes = nodes.map(|lax n| Node(zero));


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type.nontriv.len == 0 ? zero : node.type
                    //              missing copy around ^^^^^^^^^
                    //      alt-1: wrong result, alt-2: segfault
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Node_TXsI;
struct Type_UW1G;
inline int x3Cx3E_DHze(const Type_UW1G&, const Type_UW1G&);

                                #ifndef DEF_Type_UW1GqnGPECb
                                #define DEF_Type_UW1GqnGPECb
struct Type_UW1G
{
                                // shape_hash:    8bdba7c21dae2678
                                // non_triv_mask: 8000000000000010
    fu::vec<Type_UW1G> nontriv;
    Type_UW1G(const Type_UW1G&) = default;
    Type_UW1G(Type_UW1G&&) = default;
    Type_UW1G& operator=(Type_UW1G&&) = default;
    Type_UW1G& operator=(const Type_UW1G& selfrec) { return *this = Type_UW1G(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_TXsI1DZiWJ8
                                #define DEF_Node_TXsI1DZiWJ8
struct Node_TXsI
{
                                // shape_hash:    10be10edbe0cfc56
                                // non_triv_mask: a000000000000010
    Type_UW1G type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_UW1G one fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{} }} };

static const Type_UW1G zero fu_INIT_PRIORITY(1001) {};

static const Type_UW1G two fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{}, Type_UW1G{} }} };

                                #ifndef DEF___dOrmUrWWjUk
                                #define DEF___dOrmUrWWjUk
inline static Node_TXsI _dOrm()
{
    return Node_TXsI { Type_UW1G(zero) };
}
                                #endif

                                #ifndef DEF_map_ppIC5ANrC9a
                                #define DEF_map_ppIC5ANrC9a
inline fu::vec<Node_TXsI> map_ppIC(/*3:3*/ fu::view<Node_TXsI> a)
{
    /*MOV*/ fu::vec<Node_TXsI> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _dOrm();

    return /*NRVO*/ res;
}
                                #endif

static void propagateType_MbR9(/*7:7*/ const Node_TXsI& node, /*7:7*/ const Type_UW1G& slot, /*5:5*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    const Type_UW1G& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    nodes = map_ppIC(nodes);
    nodes += Node_TXsI { Type_UW1G(slot_1) };
}

static void solve_MbR9(/*1:1*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const Node_TXsI& /*nodes|static*/ node = nodes[i];
        propagateType_MbR9(node, Type_UW1G(/*bck:vi 2*/ ((node.type.nontriv.size() == 0) ? zero : node.type)), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_JfC9WhxQSX3
                                #define DEF_x3Cx3E_JfC9WhxQSX3
inline int x3Cx3E_JfC9(/*3:3*/ fu::view<Type_UW1G> a, /*3:3*/ fu::view<Type_UW1G> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_DHze(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_DHzeBXr3l39
                                #define DEF_x3Cx3E_DHzeBXr3l39
inline int x3Cx3E_DHze(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_JfC9(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_pDf9BNAbkg1
                                #define DEF_x3Dx3D_pDf9BNAbkg1
inline bool operator==(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    return !x3Cx3E_DHze(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Node_TXsI> nodes = fu::vec<Node_TXsI> {{ Node_TXsI { Type_UW1G(one) } }};
    solve_MbR9(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

========

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, val slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                for (mut i = 0; i < nodes.len; i++)
                    nodes[i].type = zero;


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Node_TXsI;
struct Type_UW1G;
inline int x3Cx3E_DHze(const Type_UW1G&, const Type_UW1G&);

                                #ifndef DEF_Type_UW1GqnGPECb
                                #define DEF_Type_UW1GqnGPECb
struct Type_UW1G
{
                                // shape_hash:    8bdba7c21dae2678
                                // non_triv_mask: 8000000000000010
    fu::vec<Type_UW1G> nontriv;
    Type_UW1G(const Type_UW1G&) = default;
    Type_UW1G(Type_UW1G&&) = default;
    Type_UW1G& operator=(Type_UW1G&&) = default;
    Type_UW1G& operator=(const Type_UW1G& selfrec) { return *this = Type_UW1G(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_TXsI1DZiWJ8
                                #define DEF_Node_TXsI1DZiWJ8
struct Node_TXsI
{
                                // shape_hash:    10be10edbe0cfc56
                                // non_triv_mask: a000000000000010
    Type_UW1G type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_UW1G one fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{} }} };

static const Type_UW1G two fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{}, Type_UW1G{} }} };

static const Type_UW1G zero fu_INIT_PRIORITY(1001) {};

static void propagateType_MbR9(/*7:7*/ const Node_TXsI& node, /*7:7*/ const Type_UW1G& slot, /*5:5*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    const Type_UW1G& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    for (int i = 0; i < nodes.size(); i++)
        nodes.mutref(i).type = Type_UW1G(zero);

    nodes += Node_TXsI { Type_UW1G(slot_1) };
}

static void solve_MbR9(/*1:1*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const Node_TXsI& /*nodes|static*/ node = nodes[i];
        propagateType_MbR9(node, Type_UW1G(/*bck:vi 2*/ node.type), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_JfC9WhxQSX3
                                #define DEF_x3Cx3E_JfC9WhxQSX3
inline int x3Cx3E_JfC9(/*3:3*/ fu::view<Type_UW1G> a, /*3:3*/ fu::view<Type_UW1G> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_DHze(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_DHzeBXr3l39
                                #define DEF_x3Cx3E_DHzeBXr3l39
inline int x3Cx3E_DHze(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_JfC9(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_pDf9BNAbkg1
                                #define DEF_x3Dx3D_pDf9BNAbkg1
inline bool operator==(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    return !x3Cx3E_DHze(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Node_TXsI> nodes = fu::vec<Node_TXsI> {{ Node_TXsI { Type_UW1G(one) } }};
    solve_MbR9(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

========

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, val slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                for (mut i = 0; i < nodes.len; i++)
                    nodes[i].type = zero;


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type.nontriv.len == 0 ? zero : node.type
                    //              missing copy around ^^^^^^^^^
                    //      alt-1: wrong result, alt-2: segfault
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Node_TXsI;
struct Type_UW1G;
inline int x3Cx3E_DHze(const Type_UW1G&, const Type_UW1G&);

                                #ifndef DEF_Type_UW1GqnGPECb
                                #define DEF_Type_UW1GqnGPECb
struct Type_UW1G
{
                                // shape_hash:    8bdba7c21dae2678
                                // non_triv_mask: 8000000000000010
    fu::vec<Type_UW1G> nontriv;
    Type_UW1G(const Type_UW1G&) = default;
    Type_UW1G(Type_UW1G&&) = default;
    Type_UW1G& operator=(Type_UW1G&&) = default;
    Type_UW1G& operator=(const Type_UW1G& selfrec) { return *this = Type_UW1G(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_TXsI1DZiWJ8
                                #define DEF_Node_TXsI1DZiWJ8
struct Node_TXsI
{
                                // shape_hash:    10be10edbe0cfc56
                                // non_triv_mask: a000000000000010
    Type_UW1G type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_UW1G one fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{} }} };

static const Type_UW1G zero fu_INIT_PRIORITY(1001) {};

static const Type_UW1G two fu_INIT_PRIORITY(1001) = Type_UW1G { fu::vec<Type_UW1G> {{ Type_UW1G{}, Type_UW1G{} }} };

static void propagateType_MbR9(/*7:7*/ const Node_TXsI& node, /*7:7*/ const Type_UW1G& slot, /*5:5*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    const Type_UW1G& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    for (int i = 0; i < nodes.size(); i++)
        nodes.mutref(i).type = Type_UW1G(zero);

    nodes += Node_TXsI { Type_UW1G(slot_1) };
}

static void solve_MbR9(/*1:1*/ fu::vec_range_mut<Node_TXsI> nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const Node_TXsI& /*nodes|static*/ node = nodes[i];
        propagateType_MbR9(node, Type_UW1G(/*bck:vi 2*/ ((node.type.nontriv.size() == 0) ? zero : node.type)), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_JfC9WhxQSX3
                                #define DEF_x3Cx3E_JfC9WhxQSX3
inline int x3Cx3E_JfC9(/*3:3*/ fu::view<Type_UW1G> a, /*3:3*/ fu::view<Type_UW1G> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_DHze(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_DHzeBXr3l39
                                #define DEF_x3Cx3E_DHzeBXr3l39
inline int x3Cx3E_DHze(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_JfC9(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_pDf9BNAbkg1
                                #define DEF_x3Dx3D_pDf9BNAbkg1
inline bool operator==(/*3:3*/ const Type_UW1G& a, /*3:3*/ const Type_UW1G& b)
{
    return !x3Cx3E_DHze(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Node_TXsI> nodes = fu::vec<Node_TXsI> {{ Node_TXsI { Type_UW1G(one) } }};
    solve_MbR9(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

========

        nocopy struct NC { x: i32 };

        noinline fn add(a: i32, b: i32)
            a + b;

        noinline fn test(a: NC, ref b: NC)
            add(10 * a.x, ++b.x);                               // N_AARMustSeq

        fn main() {
            mut nc = NC(1);
            return test(nc, nc) - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NC_LH9S;

                                #ifndef DEF_NC_LH9S8EhoR6f
                                #define DEF_NC_LH9S8EhoR6f
struct NC_LH9S
{
                                // shape_hash:    dcaffc623d4d000b
                                // non_triv_mask: 0002000000000000
    int x;
    NC_LH9S(const NC_LH9S&) = delete;
    NC_LH9S(NC_LH9S&&) = default;
    NC_LH9S& operator=(const NC_LH9S&) = delete;
    NC_LH9S& operator=(NC_LH9S&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int add_MbR9(const int a, const int b)
{
    return a + b;
}

static int test_MbR9(/*3:3*/ const NC_LH9S& a, /*3:3*/ NC_LH9S& b)
{
    int _0;
    return (_0 = (10 * a.x), add_MbR9(_0, ++b.x));
}

int fu_MAIN()
{
    NC_LH9S nc = NC_LH9S { 1 };
    return test_MbR9(nc, nc) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

========

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_nested_loop_after_break(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {
                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        // write followed by inner-loop break -
                        //  not on the same path as the use of first below ...
                        n.children ~= Node(i);


                        break;                                              
                    }

                    // ... which will be used again on next outer-loop iter.
                    first.value += sum;
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_nested_loop_after_break(n);
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:21+5[0m:

[2m      | [0m
[2m      |                     // ... which will be used again on next outer-loop iter.[0m
[2m   23 | [0m                    [31;1mfirst[0m.value += sum;
[2m      |                 }[0m
[2m      |             }[0m

	Cannot access [35;3mmut ref[0m [94;1mfirst[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1mn[0m at [2m16:36+2[0m:

[2m      |                         // write followed by inner-loop break -[0m
[2m      |                         //  not on the same path as the use of first below ...[0m
[2m   16 | [0m                        n.children [31;1m~=[0m Node(i);
[2m      | [0m
[2m      | [0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mused_in_a_nested_loop_after_break[0m([94;1mNode[0m) at [2m4:21+33[0m

========

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_nested_loop_after_break(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {
                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        // write followed by inner-loop break -
                        //  not on the same path as the use of first below ...
                        n.children ~= Node(i);


                        return sum;                                         
                    }

                    // ... which will be used again on next outer-loop iter.
                    first.value += sum;
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_nested_loop_after_break(n);
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct Node_nS3r;

                                #ifndef DEF_Node_nS3romn7adc
                                #define DEF_Node_nS3romn7adc
struct Node_nS3r
{
                                // shape_hash:    f53822a852c8e3e8
                                // non_triv_mask: 0000002800000000
    int value;
    fu::vec<Node_nS3r> children;
    Node_nS3r(const Node_nS3r&) = default;
    Node_nS3r(Node_nS3r&&) = default;
    Node_nS3r& operator=(Node_nS3r&&) = default;
    Node_nS3r& operator=(const Node_nS3r& selfrec) { return *this = Node_nS3r(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || children
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int used_in_a_nested_loop_after_break_MbR9(/*1:1*/ Node_nS3r& n)
{
    Node_nS3r& /*n|static*/ first = n.children.mutref(0);
    int sum = 0;
    for (int i = 0; i < n.children.size(); i++)
    {
        for (int i_1 = 0; i_1 < n.children.size(); i_1++)
        {
            sum += n.children[i_1].value;
            if (sum & 1)
            {
                n.children += Node_nS3r { i_1, fu::vec<Node_nS3r>{} };
                return sum;
            }
            else
                first.value += sum;

        };
    };
    return sum;
}

int fu_MAIN()
{
    Node_nS3r n = Node_nS3r { {/*unused non-zst*/}, fu::vec<Node_nS3r> {{ Node_nS3r { 2, fu::vec<Node_nS3r>{} }, Node_nS3r { 1, fu::vec<Node_nS3r>{} } }} };
    const int sum = used_in_a_nested_loop_after_break_MbR9(n);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_preceding_nested_loop(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {

                for (shadow mut i = 0; i < n.children.len; i++)
                    first.children ~= Node(i);

                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        n.children ~= Node(i);


                        break;          
                    }
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_preceding_nested_loop(n);
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:36+2[0m:

[2m      | [0m
[2m      |                     if (sum & 1) {[0m
[2m   18 | [0m                        n.children [31;1m~=[0m Node(i);
[2m      | [0m
[2m      | [0m

	Write to [35;3mmut ref arg[0m [94;1mn[0m at call to [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m invalidates the use of [35;3mmut ref[0m [94;1mfirst[0m at [2m12:21+5[0m:

[2m      | [0m
[2m      |                 for (shadow mut i = 0; i < n.children.len; i++)[0m
[2m   12 | [0m                    [31;1mfirst[0m.children ~= Node(i);
[2m      | [0m
[2m      |                 for (shadow mut i = 0; i < n.children.len; i++) {[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mused_in_a_preceding_nested_loop[0m([94;1mNode[0m) at [2m4:21+31[0m

========

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_preceding_nested_loop(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {

                for (shadow mut i = 0; i < n.children.len; i++)
                    first.children ~= Node(i);

                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        n.children ~= Node(i);


                        return sum;     
                    }
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_preceding_nested_loop(n);
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct Node_nS3r;

                                #ifndef DEF_Node_nS3romn7adc
                                #define DEF_Node_nS3romn7adc
struct Node_nS3r
{
                                // shape_hash:    f53822a852c8e3e8
                                // non_triv_mask: 0000002800000000
    int value;
    fu::vec<Node_nS3r> children;
    Node_nS3r(const Node_nS3r&) = default;
    Node_nS3r(Node_nS3r&&) = default;
    Node_nS3r& operator=(Node_nS3r&&) = default;
    Node_nS3r& operator=(const Node_nS3r& selfrec) { return *this = Node_nS3r(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || children
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int used_in_a_preceding_nested_loop_MbR9(/*1:1*/ Node_nS3r& n)
{
    Node_nS3r& /*n|static*/ first = n.children.mutref(0);
    int sum = 0;
    for (int i = 0; i < n.children.size(); i++)
    {
        for (int i_1 = 0; i_1 < n.children.size(); i_1++)
        {
            first.children += Node_nS3r { i_1, fu::vec<Node_nS3r>{} };
        };
        for (int i_2 = 0; i_2 < n.children.size(); i_2++)
        {
            sum += n.children[i_2].value;
            if (sum & 1)
            {
                n.children += Node_nS3r { i_2, fu::vec<Node_nS3r>{} };
                return sum;
            };
        };
    };
    return sum;
}

int fu_MAIN()
{
    Node_nS3r n = Node_nS3r { {/*unused non-zst*/}, fu::vec<Node_nS3r> {{ Node_nS3r { 2, fu::vec<Node_nS3r>{} }, Node_nS3r { 1, fu::vec<Node_nS3r>{} } }} };
    const int sum = used_in_a_preceding_nested_loop_MbR9(n);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        noinline fn used_after_break_from_block(ref arr: i32[])
        {

            ref  first = arr[0];

            :BLOCK {
                if (first & 2) {
                    if (first & 1) {
                        arr.clear();
                        break :BLOCK;                           // Goto
                    }

                    first++;
                }
            }

            return first;
        }

        fn main() {
            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];
            return used_after_break_from_block(arr) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:20+5[0m:

[2m      |             }[0m
[2m      | [0m
[2m   18 | [0m            return [31;1mfirst[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mfirst[0m, reference invalidated by write to [35;3mmut ref arg[0m [94;1marr[0m at [2m10:29+5[0m:

[2m      |                 if (first & 2) {[0m
[2m      |                     if (first & 1) {[0m
[2m   10 | [0m                        arr.[31;1mclear[0m();
[2m      |                         break :BLOCK;                           // Goto[0m
[2m      |                     }[0m

	At call to [35;3m__native[0m [94;1m.clear()[0m

    BorrowCheck [35;3mfn[0m [94;1mused_after_break_from_block[0m([35;3mi32[0m[35;3m[..][0m) at [2m2:21+27[0m

========

        noinline fn used_after_break_from_block(ref arr: i32[])
        {

            mut  first = arr[0];

            :BLOCK {
                if (first & 2) {
                    if (first & 1) {
                        arr.clear();
                        break :BLOCK;                           // Goto
                    }

                    first++;
                }
            }

            return first;
        }

        fn main() {
            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];
            return used_after_break_from_block(arr) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int used_after_break_from_block_MbR9(/*1:1*/ fu::vec_range_mut<int> arr)
{
    int first = arr[0];

    { {
        if (first & 2)
        {
            if (first & 1)
            {
                arr.clear();
                goto BL_1;
            }
            else
                first++;

        };
      } BL_1:;
    };
    return first;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 }};
    return used_after_break_from_block_MbR9(arr) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Last(ref arr: i32[])
            arr[arr.len - 1];

        fn Push(ref arr: i32[]) {
            arr.push([]);
            return arr.Last;
        }

        fn Assign(ref b: i32, ref into: i32)
            into = ++b;

        fn main() {
            mut arr = [ 1, 2, 3 ];


            ref  b = arr.Last;

            for (mut i = 0; i < 10; i++) {
                mut tmp: i32;
                Assign(tmp = b, into: Push(arr));
            }

            return arr.Last - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 21:39+4[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut tmp: i32;[0m
[2m   21 | [0m                Assign(tmp = b, into: [31;1mPush[0m(arr));
[2m      |             }[0m
[2m      | [0m

	Write to [35;3mmut[0m [94;1marr[0m at call to [35;3mfn[0m [94;1mPush[0m invalidates the use of [35;3mconst ref[0m [94;1mb[0m at [2m21:30+1[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut tmp: i32;[0m
[2m   21 | [0m                Assign(tmp = [31;1mb[0m, into: Push(arr));
[2m      |             }[0m
[2m      | [0m

	... on next loop iteration.

	Written
            via [35;3m__native[0m [94;1m.push[0m at [2m6:17+4[0m:

[2m      | [0m
[2m      |         fn Push(ref arr: i32[]) {[0m
[2m    6 | [0m            arr.[31;1mpush[0m([]);
[2m      |             return arr.Last;[0m
[2m      |         }[0m


    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        fn Last(ref arr: i32[])
            arr[arr.len - 1];

        fn Push(ref arr: i32[]) {
            arr.push([]);
            return arr.Last;
        }

        fn Assign(ref b: i32, ref into: i32)
            into = ++b;

        fn main() {
            mut arr = [ 1, 2, 3 ];


            fn   b = arr.Last;

            for (mut i = 0; i < 10; i++) {
                mut tmp: i32;
                Assign(tmp = b, into: Push(arr));
            }

            return arr.Last - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int Last_kGbb(/*1:1*/ fu::view<int> arr)
{
    return arr[(arr.size() - 1)];
}

static int b_kGbb(/*1:1*/ fu::view<int> arr)
{
    return Last_kGbb(arr);
}

static int& Last_MbR9(/*1:1*/ fu::view_mut<int> arr)
{
    return arr.mutref((arr.size() - 1));
}

static int& Push_MbR9(/*1:1*/ fu::vec_range_mut<int> arr)
{
    arr.push(0);
    return Last_MbR9(arr);
}

static int Assign_GL0m(/*3:1*/ int& b, /*3:3*/ int& into)
{
    return (into = ++b);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3 }};
    for (int i = 0; i < 10; i++)
    {
        int tmp {};
        int* _0;
        (_0 = &((tmp = b_kGbb(arr))), Assign_GL0m(*_0, Push_MbR9(arr)));
    };
    return Last_kGbb(arr) - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========

        fn main() {
            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];

            ref  item4 = arr[4];

            mut out = 7;

            pragma emit(`
                `arr` = {};
                `out` = `item4`;
            `);

            return out * 2 - 8;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:26+5[0m:

[2m      |             pragma emit(`[0m
[2m      |                 `arr` = {};[0m
[2m   11 | [0m                `out` = `[31;1mitem4[0m`;
[2m      |             `);[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mitem4[0m, reference invalidated by write to [35;3mmut[0m [94;1marr[0m at [2m10:18+3[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m   10 | [0m                `[31;1marr[0m` = {};
[2m      |                 `out` = `item4`;[0m
[2m      |             `);[0m

	via pragma [94;1memit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];

            let  item4 = arr[4];

            mut out = 7;

            pragma emit(`
                `arr` = {};
                `out` = `item4`;
            `);

            return out * 2 - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }};
    const int /*arr|static*/ item4 = arr[4];
    int out = 7;

                arr = {};
                out = item4;

    return (out * 2) - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct A { ints: i32[] };
        struct B { a0: A; a1: A };

        noinline fn either(ref a: B) a.a0 || a.a1;

        fn main() {
            mut b0 = B( A([ 1, 2, 3, 4, 5, 6, 7, 8 ]),
                        A([ 9, 10, 11, 12, 13, 14, 15, 16 ]));

            let b1 = b0;

            ref a0 = either(b0);
            a0.ints.clear();
            a0.ints ~= 1;

            return    1 * b0.a0.ints.len +   10 * b0.a1.ints.len
                 +  100 * b1.a0.ints.len + 1000 * b1.a1.ints.len
                 - 8881;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct B_Jeqk;
struct A_EPBj;

                                #ifndef DEF_A_EPBj5Db3hU7
                                #define DEF_A_EPBj5Db3hU7
struct A_EPBj
{
                                // shape_hash:    e2eae91573dfa1c5
                                // non_triv_mask: 0008000000040000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_B_Jeqk693OPb0
                                #define DEF_B_Jeqk693OPb0
struct B_Jeqk
{
                                // shape_hash:    95ddaec86d639320
                                // non_triv_mask: 0008002000040000
    A_EPBj a0;
    A_EPBj a1;
    explicit operator bool() const noexcept
    {
        return false
            || a0
            || a1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static A_EPBj& either_MbR9(/*1:1*/ B_Jeqk& a)
{
    return a.a0 ? a.a0 : a.a1;
}

int fu_MAIN()
{
    B_Jeqk b0 = B_Jeqk { A_EPBj { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }} }, A_EPBj { fu::vec<int> {{ 9, 10, 11, 12, 13, 14, 15, 16 }} } };
    B_Jeqk b1 = b0;
    A_EPBj& /*b0*/ a0 = either_MbR9(b0);
    a0.ints.clear();
    a0.ints += 1;
    return ((((1 * b0.a0.ints.size()) + (10 * b0.a1.ints.size())) + (100 * b1.a0.ints.size())) + (1000 * b1.a1.ints.size())) - 8881;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || throw("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct TokenIdx_frKi;
inline static void visit_HYoU(fu::vec_range<char>, fu::vec_range_mut<char>, TokenIdx_frKi&);

                                #ifndef DEF_TokenIdx_frKiGYQwZde
                                #define DEF_TokenIdx_frKiGYQwZde
struct TokenIdx_frKi
{
                                // shape_hash:    1e1657080f102b5a
                                // non_triv_mask: 0000000000000000
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef STR_o8uKE12imx9
                                #define STR_o8uKE12imx9
static const fu::str str_o8uKE12imx9 fu_INIT_PRIORITY(1001) { "abc"_fu };
                                #endif

                                #ifndef STR_JmtqAEDv4j8
                                #define STR_JmtqAEDv4j8
static const fu::str str_JmtqAEDv4j8 fu_INIT_PRIORITY(1001) { "here-1"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*3:3*/ fu::vec_range<char> reason, /*3:3*/ const TokenIdx_frKi& _here)
{
    fu::fail(fu::str((_here ? reason : (*(fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_MbR9(/*7:7*/ fu::vec_range<char> reason, /*7:7*/ fu::view<char> backtrack, /*6:6*/ TokenIdx_frKi& _here)
{
    if (backtrack)
    {
        _here = TokenIdx_frKi{};
    };
    FAIL_MbR9(reason, _here);
}

static fu::str climbWhat_MbR9(/*MOV*/ fu::str&& str, /*3:3*/ TokenIdx_frKi& _here)
{
    if (str)
    {
        str.pop();
        return str.destructive_move();
    }
    else
    {
        fail_MbR9(str_JmtqAEDv4j8, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_MbR9(/*1:1*/ fu::view<char> lt)
{
    return !!lt;
}

                                #ifndef DEF_visit_HYoUSEklpX4
                                #define DEF_visit_HYoUSEklpX4
inline static void visit_HYoU(/*7:7*/ fu::vec_range<char> chars, /*6:2*/ fu::vec_range_mut<char> result, /*6:4*/ TokenIdx_frKi& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            fu::vec_range<char> /*chars*/ lt = fu::get_range(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_MbR9(fu::str(lt), _here);
            if (opaque_bool_check_MbR9(init))
            {
                fu::vec_range<char> /*init*/ parent = init;
                visit_HYoU(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            fu::fail(fu::str("here-0"_fu));

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_sh4uwdDwcOh
                                #define DEF_Lifetime_process_sh4uwdDwcOh
inline static void Lifetime_process_sh4u(/*F:F*/ fu::vec_range<char> lt, /*E:6*/ fu::vec_range_mut<char> result, /*E:A*/ TokenIdx_frKi& _here)
{
    visit_HYoU(lt, result, _here);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_frKi _here {};
    fu::str result = fu::str(""_fu);
    Lifetime_process_sh4u(str_o8uKE12imx9, result, _here);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || throw("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct TokenIdx_frKi;
inline static void visit_HYoU(fu::vec_range<char>, fu::str&, TokenIdx_frKi&);

                                #ifndef DEF_TokenIdx_frKiGYQwZde
                                #define DEF_TokenIdx_frKiGYQwZde
struct TokenIdx_frKi
{
                                // shape_hash:    1e1657080f102b5a
                                // non_triv_mask: 0000000000000000
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef STR_o8uKE12imx9
                                #define STR_o8uKE12imx9
static const fu::str str_o8uKE12imx9 fu_INIT_PRIORITY(1001) { "abc"_fu };
                                #endif

                                #ifndef STR_JmtqAEDv4j8
                                #define STR_JmtqAEDv4j8
static const fu::str str_JmtqAEDv4j8 fu_INIT_PRIORITY(1001) { "here-1"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*3:3*/ fu::vec_range<char> reason, /*3:3*/ const TokenIdx_frKi& _here)
{
    fu::fail(fu::str((_here ? reason : (*(fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_MbR9(/*7:7*/ fu::vec_range<char> reason, /*7:7*/ fu::view<char> backtrack, /*6:6*/ TokenIdx_frKi& _here)
{
    if (backtrack)
    {
        _here = TokenIdx_frKi{};
    };
    FAIL_MbR9(reason, _here);
}

static fu::str climbWhat_MbR9(/*MOV*/ fu::str&& str, /*3:3*/ TokenIdx_frKi& _here)
{
    if (str)
    {
        str.pop();
        return str.destructive_move();
    }
    else
    {
        fail_MbR9(str_JmtqAEDv4j8, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_MbR9(/*1:1*/ fu::view<char> lt)
{
    return !!lt;
}

                                #ifndef DEF_visit_HYoUSEklpX4
                                #define DEF_visit_HYoUSEklpX4
inline static void visit_HYoU(/*7:7*/ fu::vec_range<char> chars, /*6:2*/ fu::str& result, /*6:4*/ TokenIdx_frKi& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            fu::vec_range<char> /*chars*/ lt = fu::get_range(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_MbR9(fu::str(lt), _here);
            if (opaque_bool_check_MbR9(init))
            {
                fu::vec_range<char> /*init*/ parent = init;
                visit_HYoU(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            fu::fail(fu::str("here-0"_fu));

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_sh4uwdDwcOh
                                #define DEF_Lifetime_process_sh4uwdDwcOh
inline static void Lifetime_process_sh4u(/*F:F*/ fu::vec_range<char> lt, /*E:6*/ fu::str& result, /*E:A*/ TokenIdx_frKi& _here)
{
    visit_HYoU(lt, result, _here);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_frKi _here {};
    fu::str result {};
    Lifetime_process_sh4u(str_o8uKE12imx9, result, _here);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || FAIL("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct TokenIdx_frKi;
inline static void visit_BqSK(fu::vec_range<char>, fu::vec_range_mut<char>, TokenIdx_frKi&);

                                #ifndef DEF_TokenIdx_frKiGYQwZde
                                #define DEF_TokenIdx_frKiGYQwZde
struct TokenIdx_frKi
{
                                // shape_hash:    1e1657080f102b5a
                                // non_triv_mask: 0000000000000000
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef STR_o8uKE12imx9
                                #define STR_o8uKE12imx9
static const fu::str str_o8uKE12imx9 fu_INIT_PRIORITY(1001) { "abc"_fu };
                                #endif

                                #ifndef STR_JmtqAEDv4j8
                                #define STR_JmtqAEDv4j8
static const fu::str str_JmtqAEDv4j8 fu_INIT_PRIORITY(1001) { "here-1"_fu };
                                #endif

                                #ifndef STR_Yxhb5HLOvof
                                #define STR_Yxhb5HLOvof
static const fu::str str_Yxhb5HLOvof fu_INIT_PRIORITY(1001) { "here-0"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*3:3*/ fu::vec_range<char> reason, /*3:3*/ const TokenIdx_frKi& _here)
{
    fu::fail(fu::str((_here ? reason : (*(fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_MbR9(/*7:7*/ fu::vec_range<char> reason, /*7:7*/ fu::view<char> backtrack, /*6:6*/ TokenIdx_frKi& _here)
{
    if (backtrack)
    {
        _here = TokenIdx_frKi{};
    };
    FAIL_MbR9(reason, _here);
}

static fu::str climbWhat_MbR9(/*MOV*/ fu::str&& str, /*3:3*/ TokenIdx_frKi& _here)
{
    if (str)
    {
        str.pop();
        return str.destructive_move();
    }
    else
    {
        fail_MbR9(str_JmtqAEDv4j8, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_MbR9(/*1:1*/ fu::view<char> lt)
{
    return !!lt;
}

                                #ifndef DEF_visit_BqSK6tIsbTh
                                #define DEF_visit_BqSK6tIsbTh
inline static void visit_BqSK(/*7:7*/ fu::vec_range<char> chars, /*6:2*/ fu::vec_range_mut<char> result, /*6:4*/ TokenIdx_frKi& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            fu::vec_range<char> /*chars*/ lt = fu::get_range(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_MbR9(fu::str(lt), _here);
            if (opaque_bool_check_MbR9(init))
            {
                fu::vec_range<char> /*init*/ parent = init;
                visit_BqSK(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            FAIL_MbR9(str_Yxhb5HLOvof, _here);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_uZSkqTMKG9l
                                #define DEF_Lifetime_process_uZSkqTMKG9l
inline static void Lifetime_process_uZSk(/*F:F*/ fu::vec_range<char> lt, /*E:6*/ fu::vec_range_mut<char> result, /*E:A*/ TokenIdx_frKi& _here)
{
    visit_BqSK(lt, result, _here);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_frKi _here {};
    fu::str result = fu::str(""_fu);
    Lifetime_process_uZSk(str_o8uKE12imx9, result, _here);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || FAIL("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct TokenIdx_frKi;
inline static void visit_BqSK(fu::vec_range<char>, fu::str&, TokenIdx_frKi&);

                                #ifndef DEF_TokenIdx_frKiGYQwZde
                                #define DEF_TokenIdx_frKiGYQwZde
struct TokenIdx_frKi
{
                                // shape_hash:    1e1657080f102b5a
                                // non_triv_mask: 0000000000000000
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef STR_o8uKE12imx9
                                #define STR_o8uKE12imx9
static const fu::str str_o8uKE12imx9 fu_INIT_PRIORITY(1001) { "abc"_fu };
                                #endif

                                #ifndef STR_JmtqAEDv4j8
                                #define STR_JmtqAEDv4j8
static const fu::str str_JmtqAEDv4j8 fu_INIT_PRIORITY(1001) { "here-1"_fu };
                                #endif

                                #ifndef STR_Yxhb5HLOvof
                                #define STR_Yxhb5HLOvof
static const fu::str str_Yxhb5HLOvof fu_INIT_PRIORITY(1001) { "here-0"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*3:3*/ fu::vec_range<char> reason, /*3:3*/ const TokenIdx_frKi& _here)
{
    fu::fail(fu::str((_here ? reason : (*(fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_MbR9(/*7:7*/ fu::vec_range<char> reason, /*7:7*/ fu::view<char> backtrack, /*6:6*/ TokenIdx_frKi& _here)
{
    if (backtrack)
    {
        _here = TokenIdx_frKi{};
    };
    FAIL_MbR9(reason, _here);
}

static fu::str climbWhat_MbR9(/*MOV*/ fu::str&& str, /*3:3*/ TokenIdx_frKi& _here)
{
    if (str)
    {
        str.pop();
        return str.destructive_move();
    }
    else
    {
        fail_MbR9(str_JmtqAEDv4j8, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_MbR9(/*1:1*/ fu::view<char> lt)
{
    return !!lt;
}

                                #ifndef DEF_visit_BqSK6tIsbTh
                                #define DEF_visit_BqSK6tIsbTh
inline static void visit_BqSK(/*7:7*/ fu::vec_range<char> chars, /*6:2*/ fu::str& result, /*6:4*/ TokenIdx_frKi& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            fu::vec_range<char> /*chars*/ lt = fu::get_range(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_MbR9(fu::str(lt), _here);
            if (opaque_bool_check_MbR9(init))
            {
                fu::vec_range<char> /*init*/ parent = init;
                visit_BqSK(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            FAIL_MbR9(str_Yxhb5HLOvof, _here);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_uZSkqTMKG9l
                                #define DEF_Lifetime_process_uZSkqTMKG9l
inline static void Lifetime_process_uZSk(/*F:F*/ fu::vec_range<char> lt, /*E:6*/ fu::str& result, /*E:A*/ TokenIdx_frKi& _here)
{
    visit_BqSK(lt, result, _here);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_frKi _here {};
    fu::str result {};
    Lifetime_process_uZSk(str_o8uKE12imx9, result, _here);
    if (result == "abcababbcbc"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_COWRestrict

========

        struct Module { modid: i32; scope: string[] }
        struct Target { modid: i32; globid: i32 }
        struct Solver { scope: string[]; tp: string }

        // This hit flatCount asserts in lifetime paths during bck
        fn test(
            implicit ref ctx:       Module[],
            using implicit ref ss:  Solver,
            target:                 Target)
        {
            ref s = ctx.len > target.modid
                    ? ctx[target.modid].scope
                    : scope;

            return s.len > target.globid
                    ? s[target.globid]
                    : tp;
        }

        fn main() {
            implicit mut ss = Solver(scope: [ "h", "w" ], tp: "Hello!");
            implicit mut ctx = [
                Module(modid: 0, scope: [ "hello", "world" ]),
                Module(modid: 1, scope: [ "Hello", "World" ]),
            ];

            let append = ", " ~ test(Target(modid: 1, globid: 1))
                       ~ "! " ~ test(Target(modid: 0, globid: 2));

            ref res = test(Target(modid: 0, globid: 0));
            res ~= append;

            return res == "hello, World! Hello!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Solver_GdUu;
struct Module_cJbq;
struct Target_1yUy;

                                #ifndef DEF_Solver_GdUu4de1G92
                                #define DEF_Solver_GdUu4de1G92
struct Solver_GdUu
{
                                // shape_hash:    0ea7cf967140d191
                                // non_triv_mask: 0000c00010000000
    fu::vec<fu::str> scope;
    fu::str tp;
    explicit operator bool() const noexcept
    {
        return false
            || scope
            || tp
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_cJbqP1kNu0h
                                #define DEF_Module_cJbqP1kNu0h
struct Module_cJbq
{
                                // shape_hash:    eda3654b6e25a16c
                                // non_triv_mask: 0000c00400000000
    int modid;
    fu::vec<fu::str> scope;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || scope
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_1yUyc5EFFj1
                                #define DEF_Target_1yUyc5EFFj1
struct Target_1yUy
{
                                // shape_hash:    da62dd119b3e75f0
                                // non_triv_mask: 0000000000000000
    int modid;
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || globid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> test_GL0m(/*7:7*/ const Target_1yUy& target, /*7:7*/ fu::view<Module_cJbq> ctx, /*7:7*/ const Solver_GdUu& ss)
{
    fu::view<fu::str> /*ctx|ss|static*/ s = ((ctx.size() > target.modid) ? ctx[target.modid].scope : ss.scope);
    if (s.size() > target.globid)
        return s[target.globid];
    else
        return ss.tp;

}

static fu::vec_range_mut<char> test_MbR9(/*7:7*/ const Target_1yUy& target, /*6:2*/ fu::view_mut<Module_cJbq> ctx, /*7:7*/ Solver_GdUu& ss)
{
    fu::view_mut<fu::str> /*ctx|ss|static*/ s = ((ctx.size() > target.modid) ? ctx.mutref(target.modid).scope : ss.scope);
    if (s.size() > target.globid)
        return s.mutref(target.globid);
    else
        return ss.tp;

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Solver_GdUu ss = Solver_GdUu { fu::vec<fu::str> {{ fu::str("h"_fu), fu::str("w"_fu) }}, fu::str("Hello!"_fu) };
    fu::vec<Module_cJbq> ctx = fu::vec<Module_cJbq> {{ Module_cJbq { 0, fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("world"_fu) }} }, Module_cJbq { 1, fu::vec<fu::str> {{ fu::str("Hello"_fu), fu::str("World"_fu) }} } }};
    fu::str append = (((", "_view + test_GL0m(Target_1yUy { 1, 1 }, ctx, ss)) + "! "_view) + test_GL0m(Target_1yUy { 0, 2 }, ctx, ss));
    fu::vec_range_mut<char> /*ctx|ss|static*/ res = test_MbR9(Target_1yUy { 0, 0 }, ctx, ss);
    res += append;
    if (res == "hello, World! Hello!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Target       { modid: i32; globid: i32 }
        struct SolvedNode   { items: SolvedNode[]; target?: Target }

        fn stealInit(ref allNodes: SolvedNode[], t: Target)
        {
            fn GET_mut(target: Target)
                allNodes[target.globid];

            ref node = GET_mut(t);
            if (node.items && node.items[0]) {
                mut init: SolvedNode;
                swap(init, node.items[0]); // flatCount mismatch here
                return init;
            }

            return [];
        }

        fn main() {
            mut allNodes = [
                SolvedNode([
                    SolvedNode([
                        SolvedNode(),
                    ]),
                ]),
            ];

            novec fn count(items: SolvedNode[]) {
                mut count = items.len;
                items.each: |node| count += node.items.count;
                return count;
            }

            let cnt0 = allNodes.count;
            let init = stealInit(allNodes, Target(0, 0));
            let cnt1 = [ init ].count;
            let cnt2 = allNodes.count;

            return cnt0 == 3 && cnt1 == 2 && cnt2 == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <utility>
#include <fu/vec.h>
#include <fu/view.h>

struct SolvedNode_j8YS;
struct Target_1yUy;
static int count_MbR9(fu::view<SolvedNode_j8YS>);

                                #ifndef DEF_Target_1yUyc5EFFj1
                                #define DEF_Target_1yUyc5EFFj1
struct Target_1yUy
{
                                // shape_hash:    da62dd119b3e75f0
                                // non_triv_mask: 0000000000000000
    int modid;
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_j8YSIfQByR5
                                #define DEF_SolvedNode_j8YSIfQByR5
struct SolvedNode_j8YS
{
                                // shape_hash:    3aa2bee2eafbc444
                                // non_triv_mask: 0000000080000400
    fu::vec<SolvedNode_j8YS> items;
    Target_1yUy target;
    SolvedNode_j8YS(const SolvedNode_j8YS&) = default;
    SolvedNode_j8YS(SolvedNode_j8YS&&) = default;
    SolvedNode_j8YS& operator=(SolvedNode_j8YS&&) = default;
    SolvedNode_j8YS& operator=(const SolvedNode_j8YS& selfrec) { return *this = SolvedNode_j8YS(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___pg8mkGkk710
                                #define DEF___pg8mkGkk710
inline static int _pg8m(/*3:3*/ const SolvedNode_j8YS& node, /*3:3*/ int& count)
{
    return (count += count_MbR9(node.items));
}
                                #endif

                                #ifndef DEF_each_pqlhPSStae4
                                #define DEF_each_pqlhPSStae4
inline void each_pqlh(/*7:7*/ fu::view<SolvedNode_j8YS> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _pg8m(a[i], count);

}
                                #endif

static int count_MbR9(/*1:1*/ fu::view<SolvedNode_j8YS> items)
{
    int count = items.size();
    each_pqlh(items, count);
    return count;
}

static SolvedNode_j8YS& GET_mut_MbR9(/*3:3*/ const Target_1yUy& target, /*3:3*/ fu::view_mut<SolvedNode_j8YS> allNodes)
{
    return allNodes.mutref(target.globid);
}

static SolvedNode_j8YS stealInit_MbR9(/*3:3*/ fu::view_mut<SolvedNode_j8YS> allNodes, /*3:3*/ const Target_1yUy& t)
{
    SolvedNode_j8YS& /*allNodes|static*/ node = GET_mut_MbR9(t, allNodes);
    if (node.items && node.items[0])
    {
        /*MOV*/ SolvedNode_j8YS init {};
        std::swap(init, node.items.mutref(0));
        return /*NRVO*/ init;
    }
    else
    {
        return SolvedNode_j8YS{};
    };
}

int fu_MAIN()
{
    fu::vec<SolvedNode_j8YS> allNodes = fu::vec<SolvedNode_j8YS> {{ SolvedNode_j8YS { fu::vec<SolvedNode_j8YS> {{ SolvedNode_j8YS { fu::vec<SolvedNode_j8YS> {{ SolvedNode_j8YS{} }}, Target_1yUy{} } }}, Target_1yUy{} } }};
    const int cnt0 = count_MbR9(allNodes);
    /*MOV*/ SolvedNode_j8YS init = stealInit_MbR9(allNodes, Target_1yUy { {/*unused non-zst*/}, 0 });
    const int cnt1 = count_MbR9(fu::view<SolvedNode_j8YS> {{ static_cast<SolvedNode_j8YS&&>(init) }});
    const int cnt2 = count_MbR9(allNodes);
    if ((cnt0 == 3) && (cnt1 == 2) && (cnt2 == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        noinline fn test(ref ints: i32[], ref iview: i32[..]) {
            inline fn a() {
                mut empty: i32[];
                ref indirect = ints || empty;
                indirect ~= indirect;
            }

            inline fn b() {
                mut empty: i32[];
                ref indirect = iview || empty;

                ref head = indirect[.. indirect.len / 2];
                for (mut i = 0; i < head.len; i++) head[i] *= 2;

                ref tail = indirect[indirect.len - indirect.len / 2 ..];
                for (mut i = 0; i < tail.len; i++) tail[i] *= 2;
            }


            a(); b(); 
        }

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5 ];
            test(ints, ints);
            return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 26:24+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut ints = [ 1, 2, 3, 4, 5 ];[0m
[2m   26 | [0m            test(ints, [31;1mints[0m);
[2m      |             return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1miview[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mints[0m

	    both alias:

	    [35;3mmut[0m [94;1mints[0m at [2m25:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   25 | [0m            mut [31;1mints[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             test(ints, ints);[0m
[2m      |             return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1miview[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mints[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m24:12+4[0m

========

        noinline fn test(ref ints: i32[], ref iview: i32[..]) {
            inline fn a() {
                mut empty: i32[];
                ref indirect = ints || empty;
                indirect ~= indirect;
            }

            inline fn b() {
                mut empty: i32[];
                ref indirect = iview || empty;

                ref head = indirect[.. indirect.len / 2];
                for (mut i = 0; i < head.len; i++) head[i] *= 2;

                ref tail = indirect[indirect.len - indirect.len / 2 ..];
                for (mut i = 0; i < tail.len; i++) tail[i] *= 2;
            }


            b(); a(); 
        }

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5 ];
            test(ints, ints);
            return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*3:3*/ fu::vec_range_mut<int> ints, /*3:2*/ fu::view_mut<int> iview)
{

    {
        fu::vec<int> empty {};
        fu::view_mut<int> /*empty|iview*/ indirect = (iview ? iview : empty);
        fu::view_mut<int> /*indirect*/ head = fu::get_view_start0_mut(indirect, (indirect.size() / 2));
        for (int i = 0; i < head.size(); i++)
            head.mutref(i) *= 2;

        fu::view_mut<int> /*indirect*/ tail = fu::get_view_mut(indirect, (indirect.size() - (indirect.size() / 2)));
        for (int i_1 = 0; i_1 < tail.size(); i_1++)
            tail.mutref(i_1) *= 2;

    };
    fu::vec<int> empty {};
    fu::vec_range_mut<int> /*empty|ints*/ indirect = (ints ? ints : empty);
    indirect += fu::vec<int>(/*bck:vi 0*/ indirect);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> ints = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    test_MbR9(ints, ints);
    if (ints == fu::view<int> {{ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_AARSoftRisk

========

        struct TEA { a: byte[]; b: byte[] };

        fn hash(ref res: TEA, u8view: byte[]) {
            let u32len  = u8view.len & ~3;
            let u32view = u8view[.. u32len];
            ref out     = res.a || res.b;
            out        ~= out;
            mut x       = u32view ~ "?";
            out        ~= x;
        }

        fn main() {
            mut res: TEA;
            res.b = "hello, world! ";
            hash(res, res.b);
            return res.b == "hello, world! hello, world! hello, world?"
                 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TEA_v3Lz;

                                #ifndef DEF_TEA_v3LzRL3xQL3
                                #define DEF_TEA_v3LzRL3xQL3
struct TEA_v3Lz
{
                                // shape_hash:    d2eff2c7fa28eeb2
                                // non_triv_mask: 0000800000020000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void hash_MbR9(/*1:1*/ TEA_v3Lz& res, /*3:3*/ fu::view<char> u8view)
{
    const int u32len = (u8view.size() & ~3);
    fu::view<char> /*u8view*/ u32view = fu::get_view_start0(u8view, u32len);
    fu::str& /*res*/ out = (res.a ? res.a : res.b);
    out += fu::str(/*bck:vi 0*/ out);
    fu::str x = (u32view + "?"_view);
    out += x;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TEA_v3Lz res {};
    res.b = fu::str("hello, world! "_fu);
    hash_MbR9(res, fu::str(/*bck:vi 0*/ res.b));
    if (res.b == "hello, world! hello, world! hello, world?"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            inline fn    a = tv.a;


            inline fn    b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    tv.a += tv.b;
    tv.b += tv.a;
    tv.a += tv.b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            inline fn    a = tv.a;


            noinline fn  b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<int> b_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.b;
}

static fu::vec<int>& b_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.b;
}

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    tv.a += b_GL0m(tv);
    b_MbR9(tv) += tv.a;
    tv.a += b_GL0m(tv);
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            inline fn    a = tv.a;


            ref          b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    fu::vec<int>& /*tv*/ b = tv.b;
    tv.a += b;
    b += tv.a;
    tv.a += b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            noinline fn  a = tv.a;


            inline fn    b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int>& a_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.a;
}

static fu::view<int> a_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.a;
}

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    a_MbR9(tv) += tv.b;
    tv.b += a_GL0m(tv);
    a_MbR9(tv) += tv.b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            noinline fn  a = tv.a;


            noinline fn  b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<int> b_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.b;
}

static fu::vec<int>& a_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.a;
}

static fu::view<int> a_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.a;
}

static fu::vec<int>& b_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.b;
}

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    a_MbR9(tv) += b_GL0m(tv);
    b_MbR9(tv) += a_GL0m(tv);
    a_MbR9(tv) += b_GL0m(tv);
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            noinline fn  a = tv.a;


            ref          b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int>& a_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.a;
}

static fu::view<int> a_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.a;
}

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    fu::vec<int>& /*tv*/ b = tv.b;
    a_MbR9(tv) += b;
    b += a_GL0m(tv);
    a_MbR9(tv) += b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            ref          a = tv.a;


            inline fn    b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    fu::vec<int>& /*tv*/ a = tv.a;
    a += tv.b;
    tv.b += a;
    a += tv.b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            ref          a = tv.a;


            noinline fn  b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<int> b_GL0m(/*1:1*/ const TwoVecs_rs1H& tv)
{
    return tv.b;
}

static fu::vec<int>& b_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    return tv.b;
}

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    fu::vec<int>& /*tv*/ a = tv.a;
    a += b_GL0m(tv);
    b_MbR9(tv) += a;
    a += b_GL0m(tv);
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {

            ref          a = tv.a;


            ref          b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(704) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct TwoVecs_rs1H;

                                #ifndef DEF_TwoVecs_rs1HMqQFky8
                                #define DEF_TwoVecs_rs1HMqQFky8
struct TwoVecs_rs1H
{
                                // shape_hash:    fc59dc06c1981a36
                                // non_triv_mask: 0008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void disjoint_refs_MbR9(/*1:1*/ TwoVecs_rs1H& tv)
{
    fu::vec<int>& /*tv*/ a = tv.a;
    fu::vec<int>& /*tv*/ b = tv.b;
    a += b;
    b += a;
    a += b;
}

int fu_MAIN()
{
    TwoVecs_rs1H tv = TwoVecs_rs1H { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }}, fu::vec<int> {{ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }} };
    disjoint_refs_MbR9(tv);
    return tv.a.size() - 53;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct PrimArray { prims: i32[]; }
        nocopy struct Node { index: i32; items?: Node[]; }
        nocopy struct SolverState { _root: Node; _prim_arrays: PrimArray[] }

        noinline fn AAR_typesCantAlias_lifetimesIntersect(using ref ss: SolverState)
        {
            fn unorderedPrep_B(ref root: Node) {
                let index  = root.index;
                if (_prim_arrays.len > index) {
                    ref eph     = _prim_arrays[index];
                    eph.prims  ~= root.index += eph.prims.len;
                               // ^^^^^^^^^^ should notice eph can't alias root
                }
            }

            return _root.unorderedPrep_B();
        }

        fn main() {
            mut ss = SolverState(Node(), [ PrimArray() ]);
            ss.AAR_typesCantAlias_lifetimesIntersect();
            return ss._prim_arrays.len == 1 && ss._prim_arrays[0].prims.len == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct SolverState_hIIy;
struct Node_Ycmy;
struct PrimArray_JpgT;

                                #ifndef DEF_Node_Ycmyp1Im9Fd
                                #define DEF_Node_Ycmyp1Im9Fd
struct Node_Ycmy
{
                                // shape_hash:    cda4801417e562f9
                                // non_triv_mask: 0020000100000000
    int index;
    fu::vec<Node_Ycmy> items;
    Node_Ycmy(const Node_Ycmy&) = delete;
    Node_Ycmy(Node_Ycmy&&) = default;
    Node_Ycmy& operator=(const Node_Ycmy&) = delete;
    Node_Ycmy& operator=(Node_Ycmy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_PrimArray_JpgTxaIfZn7
                                #define DEF_PrimArray_JpgTxaIfZn7
struct PrimArray_JpgT
{
                                // shape_hash:    3197891c5d13a065
                                // non_triv_mask: 0008800000000000
    fu::vec<int> prims;
    PrimArray_JpgT(const PrimArray_JpgT&) = delete;
    PrimArray_JpgT(PrimArray_JpgT&&) = default;
    PrimArray_JpgT& operator=(const PrimArray_JpgT&) = delete;
    PrimArray_JpgT& operator=(PrimArray_JpgT&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || prims
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_hIIyyc77hXd
                                #define DEF_SolverState_hIIyyc77hXd
struct SolverState_hIIy
{
                                // shape_hash:    9327c8eab7f0e82a
                                // non_triv_mask: 0028800120000020
    Node_Ycmy _root;
    fu::vec<PrimArray_JpgT> _prim_arrays;
    SolverState_hIIy(const SolverState_hIIy&) = delete;
    SolverState_hIIy(SolverState_hIIy&&) = default;
    SolverState_hIIy& operator=(const SolverState_hIIy&) = delete;
    SolverState_hIIy& operator=(SolverState_hIIy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || _root
            || _prim_arrays
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void unorderedPrep_B_MbR9(/*1:1*/ Node_Ycmy& root, /*3:2*/ SolverState_hIIy& ss)
{
    const int /*root*/ index = root.index;
    if (ss._prim_arrays.size() > index)
    {
        PrimArray_JpgT& /*ss|static*/ eph = ss._prim_arrays.mutref(index);
        eph.prims += (root.index += eph.prims.size());
    };
}

static void AAR_typesCantAlias_lifetimesIntersect_MbR9(/*1:1*/ SolverState_hIIy& ss)
{
    unorderedPrep_B_MbR9(ss._root, ss);
}

int fu_MAIN()
{
    SolverState_hIIy ss = SolverState_hIIy { Node_Ycmy{}, fu::vec<PrimArray_JpgT> {{ PrimArray_JpgT{} }} };
    AAR_typesCantAlias_lifetimesIntersect_MbR9(ss);
    if ((ss._prim_arrays.size() == 1) && (ss._prim_arrays[0].prims.size() == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct TokenIdx { modid: i32 }
        struct SolverState { _solver_safety: int }

        noinline fn doTrySpecialize(
            there: TokenIdx,
            using implicit ref _ss: SolverState,
            implicit ref _here: TokenIdx)
        {
            let here0   = _here; ///// <- this emitted a const auto&,
            _here       = TokenIdx( /////// immediately clobbered here
                _here.modid + there.modid);

            let solver_safety0  = _solver_safety++;
            if (solver_safety0 > 1)
                return _here.modid ~ ":" ~ there.modid ~ ";";

            defer {
                _here           = here0;
                _solver_safety  = solver_safety0;
            }

            return _here.modid ~ ";";
        }

        fn main() {
            implicit mut _here: TokenIdx;
            implicit mut _ss: SolverState;

            mut res = "";           res ~= doTrySpecialize(TokenIdx(1));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));

            return res == "1;2;3:3;7:4;" ? 0 : 1;                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct TokenIdx_2v2a;
struct SolverState_ivhR;

                                #ifndef DEF_TokenIdx_2v2aTXdRXUl
                                #define DEF_TokenIdx_2v2aTXdRXUl
struct TokenIdx_2v2a
{
                                // shape_hash:    c0ba27370624d4ff
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_ivhRUavGv1g
                                #define DEF_SolverState_ivhRUavGv1g
struct SolverState_ivhR
{
                                // shape_hash:    03eef1ec73155aab
                                // non_triv_mask: 0000000000000000
    int _solver_safety;
    explicit operator bool() const noexcept
    {
        return false
            || _solver_safety
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str doTrySpecialize_MbR9(/*7:7*/ const TokenIdx_2v2a& there, /*6:2*/ SolverState_ivhR& _ss, /*6:4*/ TokenIdx_2v2a& _here)
{
    const TokenIdx_2v2a here0 = _here;
    _here = TokenIdx_2v2a { (_here.modid + there.modid) };
    const int solver_safety0 = _ss._solver_safety++;
    if (solver_safety0 > 1)
        return x7E_rA00(x7E_rA00(fu::i64dec(_here.modid), ":"_view), fu::i64dec(there.modid)) + ";"_view;
    else
    {
        fu_DEFER(
        {
            _here = here0;
            _ss._solver_safety = solver_safety0;
        });
        return x7E_rA00(fu::i64dec(_here.modid), ";"_view);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_2v2a _here {};
    SolverState_ivhR _ss {};
    fu::str res = fu::str(""_fu);
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 1 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 2 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 3 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 4 }, _ss, _here);
    if (res == "1;2;3:3;7:4;"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct TokenIdx { modid: i32 }
        struct SolverState { _solver_safety: int }

        noinline fn doTrySpecialize(
            there: TokenIdx,
            using implicit ref _ss: SolverState,
            implicit ref _here: TokenIdx)
        {
            let here0   = _here; ///// <- this emitted a const auto&,
            _here       = TokenIdx( /////// immediately clobbered here
                _here.modid + there.modid);

            let solver_safety0  = _solver_safety++;
            if (solver_safety0 > 1)
                return _here.modid ~ ":" ~ there.modid ~ ";";

            defer {
                _here           = here0;
                _solver_safety  = solver_safety0;
            }

            return _here.modid ~ ";";
        }

        fn main() {
            implicit mut _here: TokenIdx;
            implicit mut _ss: SolverState;

            mut res = "";           res ~= doTrySpecialize(TokenIdx(1));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));

            return res == "1;2;3:3;7:4;" ? 0 : 1;                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct TokenIdx_2v2a;
struct SolverState_ivhR;

                                #ifndef DEF_TokenIdx_2v2aTXdRXUl
                                #define DEF_TokenIdx_2v2aTXdRXUl
struct TokenIdx_2v2a
{
                                // shape_hash:    c0ba27370624d4ff
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_ivhRUavGv1g
                                #define DEF_SolverState_ivhRUavGv1g
struct SolverState_ivhR
{
                                // shape_hash:    03eef1ec73155aab
                                // non_triv_mask: 0000000000000000
    int _solver_safety;
    explicit operator bool() const noexcept
    {
        return false
            || _solver_safety
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str doTrySpecialize_MbR9(/*7:7*/ const TokenIdx_2v2a& there, /*6:2*/ SolverState_ivhR& _ss, /*6:4*/ TokenIdx_2v2a& _here)
{
    const TokenIdx_2v2a here0 = _here;
    _here = TokenIdx_2v2a { (_here.modid + there.modid) };
    const int solver_safety0 = _ss._solver_safety++;
    if (solver_safety0 > 1)
        return x7E_rA00(x7E_rA00(fu::i64dec(_here.modid), ":"_view), fu::i64dec(there.modid)) + ";"_view;
    else
    {
        fu_DEFER(
        {
            _here = here0;
            _ss._solver_safety = solver_safety0;
        });
        return x7E_rA00(fu::i64dec(_here.modid), ";"_view);
    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_2v2a _here {};
    SolverState_ivhR _ss {};
    fu::str res {};
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 1 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 2 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 3 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 4 }, _ss, _here);
    if (res == "1;2;3:3;7:4;"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct TokenIdx { modid: i32 }
        struct SolverState { _solver_safety: int }

        noinline fn doTrySpecialize(
            there: TokenIdx,
            using implicit ref _ss: SolverState,
            implicit ref _here: TokenIdx)
        {
            let here0   = _here; ///// <- this emitted a const auto&,
            _here       = TokenIdx( /////// immediately clobbered here
                _here.modid + there.modid);

            let solver_safety0  = _solver_safety++;
            if (solver_safety0 > 1) {
                return _here.modid ~ ":" ~ there.modid ~ ";";
            }
            else {
                defer {
                    _here           = here0;
                    _solver_safety  = solver_safety0;
                }

                if (_here.modid & 1)
                    return _here.modid ~ ";";
            }

            return _here.modid ~ "!";
        }

        fn main() {
            implicit mut _here: TokenIdx;
            implicit mut _ss: SolverState;

            mut res = "";           res ~= doTrySpecialize(TokenIdx(1));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));

            return res == "1;0!3:3;7:4;" ? 0 : 1;                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct TokenIdx_2v2a;
struct SolverState_ivhR;

                                #ifndef DEF_TokenIdx_2v2aTXdRXUl
                                #define DEF_TokenIdx_2v2aTXdRXUl
struct TokenIdx_2v2a
{
                                // shape_hash:    c0ba27370624d4ff
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_ivhRUavGv1g
                                #define DEF_SolverState_ivhRUavGv1g
struct SolverState_ivhR
{
                                // shape_hash:    03eef1ec73155aab
                                // non_triv_mask: 0000000000000000
    int _solver_safety;
    explicit operator bool() const noexcept
    {
        return false
            || _solver_safety
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str doTrySpecialize_MbR9(/*7:7*/ const TokenIdx_2v2a& there, /*6:2*/ SolverState_ivhR& _ss, /*6:4*/ TokenIdx_2v2a& _here)
{
    const TokenIdx_2v2a here0 = _here;
    _here = TokenIdx_2v2a { (_here.modid + there.modid) };
    const int solver_safety0 = _ss._solver_safety++;
    if (solver_safety0 > 1)
        return x7E_rA00(x7E_rA00(fu::i64dec(_here.modid), ":"_view), fu::i64dec(there.modid)) + ";"_view;
    else
    {
        fu_DEFER(
        {
            _here = here0;
            _ss._solver_safety = solver_safety0;
        });
        if (_here.modid & 1)
            return x7E_rA00(fu::i64dec(_here.modid), ";"_view);

    };
    return x7E_rA00(fu::i64dec(_here.modid), "!"_view);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_2v2a _here {};
    SolverState_ivhR _ss {};
    fu::str res = fu::str(""_fu);
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 1 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 2 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 3 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 4 }, _ss, _here);
    if (res == "1;0!3:3;7:4;"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct TokenIdx { modid: i32 }
        struct SolverState { _solver_safety: int }

        noinline fn doTrySpecialize(
            there: TokenIdx,
            using implicit ref _ss: SolverState,
            implicit ref _here: TokenIdx)
        {
            let here0   = _here; ///// <- this emitted a const auto&,
            _here       = TokenIdx( /////// immediately clobbered here
                _here.modid + there.modid);

            let solver_safety0  = _solver_safety++;
            if (solver_safety0 > 1) {
                return _here.modid ~ ":" ~ there.modid ~ ";";
            }
            else {
                defer {
                    _here           = here0;
                    _solver_safety  = solver_safety0;
                }

                if (_here.modid & 1)
                    return _here.modid ~ ";";
            }

            return _here.modid ~ "!";
        }

        fn main() {
            implicit mut _here: TokenIdx;
            implicit mut _ss: SolverState;

            mut res = "";           res ~= doTrySpecialize(TokenIdx(1));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(2));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(3));
            _ss._solver_safety++;   res ~= doTrySpecialize(TokenIdx(4));

            return res == "1;0!3:3;7:4;" ? 0 : 1;                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct TokenIdx_2v2a;
struct SolverState_ivhR;

                                #ifndef DEF_TokenIdx_2v2aTXdRXUl
                                #define DEF_TokenIdx_2v2aTXdRXUl
struct TokenIdx_2v2a
{
                                // shape_hash:    c0ba27370624d4ff
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_ivhRUavGv1g
                                #define DEF_SolverState_ivhRUavGv1g
struct SolverState_ivhR
{
                                // shape_hash:    03eef1ec73155aab
                                // non_triv_mask: 0000000000000000
    int _solver_safety;
    explicit operator bool() const noexcept
    {
        return false
            || _solver_safety
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str doTrySpecialize_MbR9(/*7:7*/ const TokenIdx_2v2a& there, /*6:2*/ SolverState_ivhR& _ss, /*6:4*/ TokenIdx_2v2a& _here)
{
    const TokenIdx_2v2a here0 = _here;
    _here = TokenIdx_2v2a { (_here.modid + there.modid) };
    const int solver_safety0 = _ss._solver_safety++;
    if (solver_safety0 > 1)
        return x7E_rA00(x7E_rA00(fu::i64dec(_here.modid), ":"_view), fu::i64dec(there.modid)) + ";"_view;
    else
    {
        fu_DEFER(
        {
            _here = here0;
            _ss._solver_safety = solver_safety0;
        });
        if (_here.modid & 1)
            return x7E_rA00(fu::i64dec(_here.modid), ";"_view);

    };
    return x7E_rA00(fu::i64dec(_here.modid), "!"_view);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    TokenIdx_2v2a _here {};
    SolverState_ivhR _ss {};
    fu::str res {};
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 1 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 2 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 3 }, _ss, _here);
    _ss._solver_safety++;
    res += doTrySpecialize_MbR9(TokenIdx_2v2a { 4 }, _ss, _here);
    if (res == "1;0!3:3;7:4;"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // Same thing as above, i had forgotten to remove a missing-failcase note,
        //  reduced again and only saw the test above once i was looking for a spot for this one.
        fn deferAfterConditionalThrow_danglesConstRef(
            mut _here: string, ref _solver_safety: int)
        {
            fn doTrySpecialize() {
                let here0   = _here;        // N_NonTrivAutoCopy
                _here       = [];
                if (_solver_safety++ >= 128) throw("woot");
                defer _here = here0;
                return 0;
            }

            doTrySpecialize();
            return _here;
        }

        fn main() {
            mut _solver_safety = 0;
            return deferAfterConditionalThrow_danglesConstRef(
                "Hello", _solver_safety).len - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/defer.h>
#include <fu/never.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static int doTrySpecialize_MbR9(/*3:1*/ fu::vec_range_mut<char> _here, /*3:2*/ int& _solver_safety)
{
    /*MOV*/ fu::str here0 = fu::str(_here);
    _here = fu::str{};
    if ((_solver_safety++ >= 128))
        fu::fail(fu::str("woot"_fu));
    else
    {
        fu_DEFER(_here = here0.destructive_move());
        return 0;
    };
}

static fu::str deferAfterConditionalThrow_danglesConstRef_MbR9(/*MOV*/ fu::str&& _here, /*3:2*/ int& _solver_safety)
{
    doTrySpecialize_MbR9(_here, _solver_safety);
    return _here.destructive_move();
}

int fu_MAIN()
{
    int _solver_safety = 0;
    return deferAfterConditionalThrow_danglesConstRef_MbR9(fu::str("Hello"_fu), _solver_safety).size() - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        fn incr_out(ref out: i32[][], a: i32[], b: i32[]) {
            out ~= a;
            out ~= b;
        }

        fn incr_state(ref state: i32[]) {
            state ~= state.len;
            return state;
        }

        fn bck_discards_its_edits_to_defer_nodes(
            ref out: i32[][], ref state: i32[])
        {
            incr_out        (:out, incr_state(state), incr_state(state));
            defer incr_out  (:out, incr_state(state), incr_state(state));
            return out;
        }

        fn main() {
            mut state = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];
            mut out: i32[][];
            bck_discards_its_edits_to_defer_nodes(:out, :state);

            mut result = 0;
            for (mut i = 0; i < out.len; i++) {
                let item = out[i];
                result += item.len << ((3 - i) * 4);
            }

            return result.u32 == 0xabcd ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(560) arc_count(5) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec_range<int> incr_state_kGbb(/*1:1*/ fu::vec_range_mut<int> state)
{
    state += state.size();
    return state;
}

static void incr_out_MbR9(/*3:3*/ fu::vec_range_mut<fu::vec<int>> out, /*7:7*/ fu::vec_range<int> a, /*7:7*/ fu::vec_range<int> b)
{
    out += fu::vec<int>(a);
    out += fu::vec<int>(b);
}

static fu::view<fu::vec<int>> bck_discards_its_edits_to_defer_nodes_GL0m(/*1:1*/ fu::vec_range_mut<fu::vec<int>> out, /*3:2*/ fu::vec_range_mut<int> state)
{
    fu::vec<int> _0 {};
    fu::vec_range<int> _1 {};
    (_0 = fu::vec<int>(/*bck:pra -2*/ incr_state_kGbb(state)), _1.ptr_reassign(incr_state_kGbb(state)), incr_out_MbR9(out, static_cast<fu::vec<int>&&>(_0), _1));
    fu::vec<int> _2 {};
    fu::vec_range<int> _3 {};
    fu_DEFER((_2 = fu::vec<int>(/*bck:pra -2*/ incr_state_kGbb(state)), _3.ptr_reassign(incr_state_kGbb(state)), incr_out_MbR9(out, static_cast<fu::vec<int>&&>(_2), _3)));
    return out;
}

int fu_MAIN()
{
    fu::vec<int> state = fu::vec<int> {{ 0, 1, 2, 3, 4, 5, 6, 7, 8 }};
    fu::vec<fu::vec<int>> out {};
    bck_discards_its_edits_to_defer_nodes_GL0m(out, state);
    int result = 0;
    for (int i = 0; i < out.size(); i++)
    {
        fu::view<int> /*out|static*/ item = out[i];
        result += (item.size() << ((3 - i) * 4));
    };
    if (unsigned(result) == 0xabcdu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_AARMustSeq

========

        fn main() {
            ref res = {                                         // GNUStmtExpr
                :BRK {
                    mut data = [ 1, 2, 3, 4, 5 ];

                    ref  DONT_DANGLE_ME = data[2 .. 3];
                    for (mut i = 0; i < 2; i++)
                        if !(i & 1)
                            for (mut j = 0; j < 8; j++)
                                data ~= data;
                        else
                            break :BRK DONT_DANGLE_ME;          // Goto

                    data
                }
            };

            mut sum = 0;
            for (mut i = 0; i < res.len; i++) sum += res[i];
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 13:40+14[0m:

[2m      |                                 data ~= data;[0m
[2m      |                         else[0m
[2m   13 | [0m                            break :BRK [31;1mDONT_DANGLE_ME[0m;          // Goto
[2m      | [0m
[2m      |                     data[0m

	Cannot access [35;3mconst ref[0m [94;1mDONT_DANGLE_ME[0m, reference invalidated by write to [35;3mmut[0m [94;1mdata[0m at [2m11:38+2[0m:

[2m      |                         if !(i & 1)[0m
[2m      |                             for (mut j = 0; j < 8; j++)[0m
[2m   11 | [0m                                data [31;1m~=[0m data;
[2m      |                         else[0m
[2m      |                             break :BRK DONT_DANGLE_ME;          // Goto[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            ref res = {                                         // GNUStmtExpr
                :BRK {
                    mut data = [ 1, 2, 3, 4, 5 ];

                    let  DONT_DANGLE_ME = data[2 .. 3];
                    for (mut i = 0; i < 2; i++)
                        if !(i & 1)
                            for (mut j = 0; j < 8; j++)
                                data ~= data;
                        else
                            break :BRK DONT_DANGLE_ME;          // Goto

                    data
                }
            };

            mut sum = 0;
            for (mut i = 0; i < res.len; i++) sum += res[i];
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> DONT_DANGLE_ME {};
    fu::vec<int> data {};
    fu::view<int> BL_1_v {};
    fu::view<int> /*DONT_DANGLE_ME|data*/ res = (__extension__ (
    { {
        data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
        DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
        for (int i = 0; i < 2; i++)
        {
            if (!(i & 1))
                for (int j = 0; j < 8; j++)
                    data += fu::vec<int>(/*bck:vi 0*/ data);

            else
            {
                { BL_1_v.ptr_reassign(DONT_DANGLE_ME); goto BL_1; };
            };
        };
        BL_1_v.ptr_reassign(data);
      } BL_1:;
        (void)0;
    }), BL_1_v);
    int sum = 0;
    for (int i = 0; i < res.size(); i++)
        sum += res[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            ref res = {                                         // GNUStmtExpr
                :BRK {
                    mut data = [ 1, 2, 3, 4, 5 ];

                    ref  DONT_DANGLE_ME = data[2 .. 3];
                    for (mut i = 0; i < 2; i++)
                        if (i & 1)
                            break :BRK DONT_DANGLE_ME;          // Goto
                        else for (mut j = 0; j < 8; j++)
                            data ~= data;

                    data
                }
            };

            mut sum = 0;
            for (mut i = 0; i < res.len; i++) sum += res[i];
            return sum - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 12:34+2[0m:

[2m      |                             break :BRK DONT_DANGLE_ME;          // Goto[0m
[2m      |                         else for (mut j = 0; j < 8; j++)[0m
[2m   12 | [0m                            data [31;1m~=[0m data;
[2m      | [0m
[2m      |                     data[0m

	Write to [35;3mmut[0m [94;1mdata[0m at call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m invalidates the use of [35;3mconst ref[0m [94;1mDONT_DANGLE_ME[0m at [2m10:40+14[0m:

[2m      |                     for (mut i = 0; i < 2; i++)[0m
[2m      |                         if (i & 1)[0m
[2m   10 | [0m                            break :BRK [31;1mDONT_DANGLE_ME[0m;          // Goto
[2m      |                         else for (mut j = 0; j < 8; j++)[0m
[2m      |                             data ~= data;[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            ref res = {                                         // GNUStmtExpr
                :BRK {
                    mut data = [ 1, 2, 3, 4, 5 ];

                    let  DONT_DANGLE_ME = data[2 .. 3];
                    for (mut i = 0; i < 2; i++)
                        if (i & 1)
                            break :BRK DONT_DANGLE_ME;          // Goto
                        else for (mut j = 0; j < 8; j++)
                            data ~= data;

                    data
                }
            };

            mut sum = 0;
            for (mut i = 0; i < res.len; i++) sum += res[i];
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> DONT_DANGLE_ME {};
    fu::vec<int> data {};
    fu::view<int> BL_1_v {};
    fu::view<int> /*DONT_DANGLE_ME|data*/ res = (__extension__ (
    { {
        data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
        DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
        for (int i = 0; i < 2; i++)
        {
            if (i & 1)
            {
                { BL_1_v.ptr_reassign(DONT_DANGLE_ME); goto BL_1; };
            }
            else
                for (int j = 0; j < 8; j++)
                    data += fu::vec<int>(/*bck:vi 0*/ data);
;
        };
        BL_1_v.ptr_reassign(data);
      } BL_1:;
        (void)0;
    }), BL_1_v);
    int sum = 0;
    for (int i = 0; i < res.size(); i++)
        sum += res[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn test(ref data: int[],

            ref DONT_DANGLE_ME: int[])
        {
            for (mut i = 0; i < 2; i++)

                if !(i & 1) for (mut j = 0; j < 8; j++)
                                data ~= data;
                else
                    return DONT_DANGLE_ME;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data, :DONT_DANGLE_ME)) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 26:37+14[0m:

[2m      |             }[0m
[2m      | [0m
[2m   26 | [0m            return sum(test(:data, :[31;1mDONT_DANGLE_ME[0m)) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m17:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             ref DONT_DANGLE_ME = data[2 .. 3];[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        noinline fn test(ref data: int[],

            ref DONT_DANGLE_ME: int[])
        {
            for (mut i = 0; i < 2; i++)

                if (i & 1)
                    return DONT_DANGLE_ME;
                else for (mut j = 0; j < 8; j++)
                    data ~= data;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data, :DONT_DANGLE_ME)) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 26:37+14[0m:

[2m      |             }[0m
[2m      | [0m
[2m   26 | [0m            return sum(test(:data, :[31;1mDONT_DANGLE_ME[0m)) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3mref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m and
	    1:	[35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m17:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      |             ref DONT_DANGLE_ME = data[2 .. 3];[0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mDONT_DANGLE_ME[0m is [31;1mref[0m

	    [35;3mref arg[0m [94;1mtest[0m:[94;1mdata[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        noinline fn test(ref data: int[],

            mut DONT_DANGLE_ME: int[])
        {
            for (mut i = 0; i < 2; i++)

                if !(i & 1) for (mut j = 0; j < 8; j++)
                                data ~= data;
                else
                    return DONT_DANGLE_ME;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data, :DONT_DANGLE_ME)) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec<int> test_MbR9(/*3:1*/ fu::vec_range_mut<int> data, /*MOV*/ fu::vec<int>&& DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (!(i & 1))
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);

        else
            return DONT_DANGLE_ME.destructive_move();

    };
    return fu::vec<int>(data);
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec_range<int> /*data*/ DONT_DANGLE_ME = fu::get_range(data, 2, 3);
    return sum_MbR9(test_MbR9(data, fu::vec<int>(DONT_DANGLE_ME))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn test(ref data: int[],

            mut DONT_DANGLE_ME: int[])
        {
            for (mut i = 0; i < 2; i++)

                if (i & 1)
                    return DONT_DANGLE_ME;
                else for (mut j = 0; j < 8; j++)
                    data ~= data;

            return data;
        }

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];
            ref DONT_DANGLE_ME = data[2 .. 3];

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test(:data, :DONT_DANGLE_ME)) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec<int> test_MbR9(/*3:1*/ fu::vec_range_mut<int> data, /*MOV*/ fu::vec<int>&& DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (i & 1)
            return DONT_DANGLE_ME.destructive_move();
        else
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);
;
    };
    return fu::vec<int>(data);
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec_range<int> /*data*/ DONT_DANGLE_ME = fu::get_range(data, 2, 3);
    return sum_MbR9(test_MbR9(data, fu::vec<int>(DONT_DANGLE_ME))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            ref  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if !(i & 1) for (mut j = 0; j < 8; j++)
                                    data ~= data;
                    else
                        return DONT_DANGLE_ME;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 24:24+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   24 | [0m            return sum([31;1mtest[0m) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:DONT_DANGLE_ME[0m and
	    1:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:data[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:DONT_DANGLE_ME[0m is [31;1mimplicit[0m

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:data[0m is [31;1mimplicit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            ref  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if (i & 1)
                        return DONT_DANGLE_ME;
                    else for (mut j = 0; j < 8; j++)
                        data ~= data;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 24:24+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   24 | [0m            return sum([31;1mtest[0m) - 3;
[2m      |         }[0m
[2m      | [0m

	At call to [35;3mfn[0m [94;1mtest[0m, arguments:

	    2:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:DONT_DANGLE_ME[0m and
	    1:	[35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:data[0m

	    both alias:

	    [35;3mmut[0m [94;1mdata[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mdata[0m = [ 1, 2, 3, 4, 5 ];
[2m      | [0m
[2m      | [0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:DONT_DANGLE_ME[0m is [31;1mimplicit[0m

	    [35;3minjected implicit ref arg[0m [94;1mtest[0m:[94;1mmain:data[0m is [31;1mimplicit[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            let  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if !(i & 1) for (mut j = 0; j < 8; j++)
                                    data ~= data;
                    else
                        return DONT_DANGLE_ME;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::view<int> test_kGbb(/*3:1*/ fu::vec_range_mut<int> data, /*3:3*/ fu::vec_range<int> DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (!(i & 1))
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);

        else
            return DONT_DANGLE_ME;

    };
    return data;
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec<int> DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
    return sum_MbR9(test_kGbb(data, DONT_DANGLE_ME)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            let  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if !(i & 1) for (mut j = 0; j < 8; j++)
                                    data ~= data;
                    else
                        return DONT_DANGLE_ME;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::view<int> test_kGbb(/*3:1*/ fu::vec<int>& data, /*3:3*/ fu::vec_range<int> DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (!(i & 1))
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);

        else
            return DONT_DANGLE_ME;

    };
    return data;
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec<int> DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
    return sum_MbR9(test_kGbb(data, DONT_DANGLE_ME)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            let  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if (i & 1)
                        return DONT_DANGLE_ME;
                    else for (mut j = 0; j < 8; j++)
                        data ~= data;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::view<int> test_kGbb(/*3:1*/ fu::vec_range_mut<int> data, /*3:3*/ fu::vec_range<int> DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (i & 1)
            return DONT_DANGLE_ME;
        else
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);
;
    };
    return data;
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec<int> DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
    return sum_MbR9(test_kGbb(data, DONT_DANGLE_ME)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut data = [ 1, 2, 3, 4, 5 ];


            let  DONT_DANGLE_ME = data[2 .. 3];
            noinline fn test() {
                for (mut i = 0; i < 2; i++)

                    if (i & 1)
                        return DONT_DANGLE_ME;
                    else for (mut j = 0; j < 8; j++)
                        data ~= data;

                return data;
            }

            fn sum(arr: int[]) {
                mut sum = 0;
                for (mut i = 0; i < arr.len; i++) sum += arr[i];
                return sum;
            }

            return sum(test) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16368) arc_count(9) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::view<int> test_kGbb(/*3:1*/ fu::vec<int>& data, /*3:3*/ fu::vec_range<int> DONT_DANGLE_ME)
{
    for (int i = 0; i < 2; i++)
    {
        if (i & 1)
            return DONT_DANGLE_ME;
        else
            for (int j = 0; j < 8; j++)
                data += fu::vec<int>(/*bck:vi 0*/ data);
;
    };
    return data;
}

static int sum_MbR9(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

int fu_MAIN()
{
    fu::vec<int> data = fu::vec<int> {{ 1, 2, 3, 4, 5 }};
    fu::vec<int> DONT_DANGLE_ME = fu::vec<int>(fu::get_range(data, 2, 3));
    return sum_MbR9(test_kGbb(data, DONT_DANGLE_ME)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Map(type K) { index: K[] }

        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int)) {
            map.index ~= 10

            // Original manual inline of the testcase below
            ref outer = map.index[0 .. map.index.len];
            for (mut i = 0; i < outer.len; i++) {
                let b = outer[i]

                // Writes to 'inner' invalidate 'outer',
                //  but the return below makes sure we'll never use 'outer' again.
                shadow ref inner = map.index[0 .. map.index.len];
                for (shadow mut i = 0; i < inner.len; i++) {
                    ref a = inner[i]
                    a = b + 1
                }

                inner ~= inner.len;
                return; // <- we dont use 'outer' again if we wrote through 'inner'
            }

            outer ~= outer.len;
        }

        fn main() {
            mut map: Map(int)
            map.bckUsedInALoopFalsePositive()
            return map.index[0] == 11 ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Map_Oue5;

                                #ifndef DEF_Map_Oue5Do0u5A1
                                #define DEF_Map_Oue5Do0u5A1
struct Map_Oue5
{
                                // shape_hash:    6f10e5309086d621
                                // non_triv_mask: 0008000000000400
    fu::vec<int> index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void bckUsedInALoopFalsePositive_MbR9(/*1:1*/ Map_Oue5& map)
{
    map.index += 10;
    fu::vec_range_mut<int> /*map*/ outer = fu::get_range_mut(map.index, 0, map.index.size());
    for (int i = 0; i < outer.size(); i++)
    {
        const int /*outer|static*/ b = outer[i];
        fu::vec_range_mut<int> /*map*/ inner = fu::get_range_mut(map.index, 0, map.index.size());
        for (int i_1 = 0; i_1 < inner.size(); i_1++)
        {
            int& /*inner|static*/ a = inner.mutref(i_1);
            a = (b + 1);
        };
        inner += inner.size();
        return;
    };
    outer += outer.size();
}

int fu_MAIN()
{
    Map_Oue5 map {};
    bckUsedInALoopFalsePositive_MbR9(map);
    if (map.index[0] == 11)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Map(type K) { index: K[] }

        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int))
        {
            // Manual inline of the testcase that follows.
            ref outer = map.index[0 .. map.index.len - 1];
            for (mut i = 0; i < outer.len; i++) {
                ref b = outer[i]
                if !(b & 1)
                {
                    // Writes to 'inner' invalidate 'outer',
                    //  but the return below makes sure we'll never use 'outer' again.
                    shadow ref inner = map.index[i ..];
                    for (shadow mut i = 0; i < inner.len; i++)
                        inner = [ inner[i] + 1 ]

                    return; // <- we dont use 'outer' again if we wrote through 'inner'
                }

                b++
            }
        }

        fn main() {
            mut map = Map(int)([ 9, 10, 101, 102, 1001, 1002, 10001, 10002 ])
            map.bckUsedInALoopFalsePositive()
            return map.index == [ 10, 11 ] ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Map_Oue5;

                                #ifndef DEF_Map_Oue5Do0u5A1
                                #define DEF_Map_Oue5Do0u5A1
struct Map_Oue5
{
                                // shape_hash:    6f10e5309086d621
                                // non_triv_mask: 0008000000000400
    fu::vec<int> index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void bckUsedInALoopFalsePositive_MbR9(/*1:1*/ Map_Oue5& map)
{
    fu::view_mut<int> /*map*/ outer = fu::get_view_mut(map.index, 0, (map.index.size() - 1));
    for (int i = 0; i < outer.size(); i++)
    {
        int& /*outer|static*/ b = outer.mutref(i);
        if (!(b & 1))
        {
            fu::vec_range_mut<int> /*map*/ inner = fu::get_range_mut(map.index, i);
            for (int i_1 = 0; i_1 < inner.size(); i_1++)
            {
                inner = fu::vec<int> {{ (inner[i_1] + 1) }};
            };
            return;
        }
        else
            b++;

    };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    Map_Oue5 map = Map_Oue5 { fu::vec<int> {{ 9, 10, 101, 102, 1001, 1002, 10001, 10002 }} };
    bckUsedInALoopFalsePositive_MbR9(map);
    if (map.index == fu::view<int> {{ 10, 11 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Map(type K) { index: K[] }

        inline fn probe(ref index: int[], hash: int, visit) {
            for (mut i = 0; i < index.len; i++)
                visit(entry: index[(hash + i) & (index.len - 1)])

            index ~= index.len // Rellocate to trigger bck
        }

        inline fn incr(ref map: Map(int), hash: int, visit?) {
            probe(:map.index, :hash): |entry!b| {
                map.index.probe(:hash): |ref entry!a| a = b + 1 // PointlessMustSeq
                return visit()
            }
        }

        noinline fn bckUsedInALoopFalsePositive(ref map: Map(int)) {
            map.index ~= 10
            map.incr(0)
        }

        fn main() {
            mut map: Map(int)
            map.bckUsedInALoopFalsePositive()
            return map.index[0] == 11 ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Map_Oue5;

                                #ifndef DEF_Map_Oue5Do0u5A1
                                #define DEF_Map_Oue5Do0u5A1
struct Map_Oue5
{
                                // shape_hash:    6f10e5309086d621
                                // non_triv_mask: 0008000000000400
    fu::vec<int> index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___vtmdjmnYUF5
                                #define DEF___vtmdjmnYUF5
inline static int _vtmd(/*3:3*/ int& a, /*3:3*/ const int b)
{
    return (a = (b + 1));
}
                                #endif

static fu::view<int> bckUsedInALoopFalsePositive_kGbb(/*1:1*/ Map_Oue5& map)
{
    map.index += 10;
    const int hash = 0;
    fu::vec<int>& /*map*/ index = map.index;
    for (int i = 0; i < index.size(); i++)
    {
        const int /*index|static*/ b = index[((hash + i) & (index.size() - 1))];

        {
            fu::vec<int>& /*map*/ index_1 = map.index;
            for (int i_1 = 0; i_1 < index_1.size(); i_1++)
                _vtmd(index_1.mutref(((hash + i_1) & (index_1.size() - 1))), b);

            index_1 += index_1.size();
        };
        return fu::view<int>{};
    };
    return (index += index.size());
}

int fu_MAIN()
{
    Map_Oue5 map {};
    bckUsedInALoopFalsePositive_kGbb(map);
    if (map.index[0] == 11)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedLet, N_BckMustSeq

========

        primitive DataPos:  int

        nocopy struct IndexEntry {
            hash:           int
            data_pos:       DataPos
        }

        pub struct Map {
            index:          IndexEntry[]
            data:           int[]
        }

        inline fn hash_mask(index)
            index.len && index.len - 1

        fn ref(ref map: Map, hash!: int, visit) {
            mut ref value = {
                :SEARCH {                                       // GNUStmtExpr
                    for (;;) {                                  // Goto
                        ref index   = map.index
                        let mask    = index.hash_mask           // !N_NonTrivAutoCopy
                        let i       = hash & mask

                        if (index.len > i) {
                            ref index_entry = index[i]
                            let data_pos = DataPos(map.data.len)
                            index_entry = IndexEntry(:hash, :data_pos)

                            map.data.grow(map.data.len + 1)
                            break :SEARCH map.data[data_pos.int]
                        }
                        else {
                            index.grow(index.len + 1)
                        }
                    }
                }
            }

            return visit(:value)
        }

        fn main() {
            mut map: Map
            map.ref(hash: 0, visit: |ref value| value = 0)
            return map.data.len - 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Map_djzv;
struct IndexEntry_TPju;
typedef int DataPos_EFQL;

                                #ifndef DEF_DataPos_EFQL
                                #define DEF_DataPos_EFQL
                                #endif

                                #ifndef DEF_Map_djzvB5IY5Z6
                                #define DEF_Map_djzvB5IY5Z6
struct Map_djzv
{
                                // shape_hash:    beb54b049b31d515
                                // non_triv_mask: 0008000000808002
    fu::vec<IndexEntry_TPju> index;
    fu::vec<int> data;
    Map_djzv(const Map_djzv&) = delete;
    Map_djzv(Map_djzv&&) = default;
    Map_djzv& operator=(const Map_djzv&) = delete;
    Map_djzv& operator=(Map_djzv&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_IndexEntry_TPjuFOO1Gx9
                                #define DEF_IndexEntry_TPjuFOO1Gx9
struct IndexEntry_TPju
{
                                // shape_hash:    d37c2df421cc72f6
                                // non_triv_mask: 0000000000000002
    int hash;
    DataPos_EFQL data_pos;
    IndexEntry_TPju(const IndexEntry_TPju&) = delete;
    IndexEntry_TPju(IndexEntry_TPju&&) = default;
    IndexEntry_TPju& operator=(const IndexEntry_TPju&) = delete;
    IndexEntry_TPju& operator=(IndexEntry_TPju&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || hash
            || data_pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_visit_rHtSjaSxfY9
                                #define DEF_visit_rHtSjaSxfY9
inline static int visit_rHtS(/*1:1*/ int& value)
{
    return (value = 0);
}
                                #endif

                                #ifndef DEF_ref_QbkzXskUUVj
                                #define DEF_ref_QbkzXskUUVj
inline static int ref_Qbkz(/*7:7*/ Map_djzv& map, const int hash)
{
    int* BL_1_v;
    int& /*map|static*/ value = (__extension__ (
    { {
        for (; ; )
        {
            fu::vec<IndexEntry_TPju>& /*map*/ index = map.index;
            fu::view<IndexEntry_TPju> index_1 {};
            const int mask = (index_1.ptr_reassign(index), (index_1.size() ? (index_1.size() - 1) : 0));
            const int i = (hash & mask);
            if (index.size() > i)
            {
                IndexEntry_TPju& /*index|static*/ index_entry = index.mutref(i);
                const DataPos_EFQL data_pos = DataPos_EFQL(map.data.size());
                index_entry = IndexEntry_TPju { hash, data_pos };
                map.data.grow((map.data.size() + 1));
                { BL_1_v = &(map.data.mutref(int(data_pos))); goto BL_1; };
            }
            else
                index.grow((index.size() + 1));

        };
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    return visit_rHtS(value);
}
                                #endif

int fu_MAIN()
{
    Map_djzv map {};
    ref_Qbkz(map, 0);
    return map.data.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        nocopy struct IndexEntry { data_pos: int }
        struct Map { index: IndexEntry[]; data: int[] }

        inline fn hash_mask(index) index.len && index.len - 1;

        fn ref(ref map: Map, hash!: int, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (;;) {
                        ref index   = map.index;
                        let mask    = index.hash_mask;          // GNUStmtExpr
                        let i       = hash & mask;

                        for (;;) {
                            if (i >= index.len) {
                                index.grow(index.len + 1);      
                            }
                            else {
                                ref index_entry = index[i];
                                index_entry.data_pos = map.data.len;
                                map.data.grow(map.data.len + 1);
                                break :SEARCH map.data[index_entry.data_pos];
                            }                                   // Goto
                        }
                    }
                }
            }

            return visit(data_entry);   
        }

        noinline fn test(ref map: Map, i: int)
            map.ref(hash: i, visit: |ref value| value = i);

        fn main() {
            mut map: Map;
            test(map, 1);
            return map.data.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Map_MvuS;
struct IndexEntry_S7Gr;

                                #ifndef DEF_Map_MvuS3l6ADG6
                                #define DEF_Map_MvuS3l6ADG6
struct Map_MvuS
{
                                // shape_hash:    a8e2d63a55e55ed4
                                // non_triv_mask: 004a001000000000
    fu::vec<IndexEntry_S7Gr> index;
    fu::vec<int> data;
    Map_MvuS(const Map_MvuS&) = delete;
    Map_MvuS(Map_MvuS&&) = default;
    Map_MvuS& operator=(const Map_MvuS&) = delete;
    Map_MvuS& operator=(Map_MvuS&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_IndexEntry_S7GrOYwBZO2
                                #define DEF_IndexEntry_S7GrOYwBZO2
struct IndexEntry_S7Gr
{
                                // shape_hash:    8da48941e9900e02
                                // non_triv_mask: 0000001000000000
    int data_pos;
    IndexEntry_S7Gr(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr(IndexEntry_S7Gr&&) = default;
    IndexEntry_S7Gr& operator=(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr& operator=(IndexEntry_S7Gr&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || data_pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_visit_RzMFKJqxHag
                                #define DEF_visit_RzMFKJqxHag
inline static int visit_RzMF(/*3:3*/ int& value, /*3:3*/ const int i)
{
    return (value = i);
}
                                #endif

                                #ifndef DEF_ref_KF9DYKRcL4i
                                #define DEF_ref_KF9DYKRcL4i
inline static int ref_KF9D(/*F:7*/ Map_MvuS& map, const int hash, /*F:F*/ const int i)
{
    int* BL_1_v;
    int& /*map|static*/ data_entry = (__extension__ (
    { {
        for (; ; )
        {
            fu::vec<IndexEntry_S7Gr>& /*map*/ index = map.index;
            fu::view<IndexEntry_S7Gr> index_1 {};
            const int mask = (index_1.ptr_reassign(index), (index_1.size() ? (index_1.size() - 1) : 0));
            const int i_1 = (hash & mask);
            for (; ; )
            {
                if ((i_1 >= index.size()))
                    index.grow((index.size() + 1));
                else
                {
                    IndexEntry_S7Gr& /*index|static*/ index_entry = index.mutref(i_1);
                    index_entry.data_pos = map.data.size();
                    map.data.grow((map.data.size() + 1));
                    { BL_1_v = &(map.data.mutref(index_entry.data_pos)); goto BL_1; };
                };
            };
        };
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    return visit_RzMF(data_entry, i);
}
                                #endif

static int test_kGbb(/*3:3*/ Map_MvuS& map, const int i)
{
    return ref_KF9D(map, i, i);
}

int fu_MAIN()
{
    Map_MvuS map {};
    test_kGbb(map, 1);
    return map.data.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        nocopy struct IndexEntry { data_pos: int }
        struct Map { index: IndexEntry[]; data: int[] }

        inline fn hash_mask(index) index.len && index.len - 1;

        fn ref(ref map: Map, hash!: int, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (;;) {
                        ref index   = map.index;
                        let mask    = index.hash_mask;          // GNUStmtExpr
                        let i       = hash & mask;

                        for (;;) {
                            if (i >= index.len) {
                                index.grow(index.len + 1);      
                            }
                            else {
                                ref index_entry = index[i];
                                index_entry.data_pos = map.data.len;
                                map.data.grow(map.data.len + 1);
                                break :SEARCH map.data[index_entry.data_pos];
                            }                                   // Goto
                        }
                    }
                }
            }

            visit(data_entry);          
        }

        noinline fn test(ref map: Map, i: int)
            map.ref(hash: i, visit: |ref value| value = i);

        fn main() {
            mut map: Map;
            test(map, 1);
            return map.data.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Map_MvuS;
struct IndexEntry_S7Gr;

                                #ifndef DEF_Map_MvuS3l6ADG6
                                #define DEF_Map_MvuS3l6ADG6
struct Map_MvuS
{
                                // shape_hash:    a8e2d63a55e55ed4
                                // non_triv_mask: 004a001000000000
    fu::vec<IndexEntry_S7Gr> index;
    fu::vec<int> data;
    Map_MvuS(const Map_MvuS&) = delete;
    Map_MvuS(Map_MvuS&&) = default;
    Map_MvuS& operator=(const Map_MvuS&) = delete;
    Map_MvuS& operator=(Map_MvuS&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_IndexEntry_S7GrOYwBZO2
                                #define DEF_IndexEntry_S7GrOYwBZO2
struct IndexEntry_S7Gr
{
                                // shape_hash:    8da48941e9900e02
                                // non_triv_mask: 0000001000000000
    int data_pos;
    IndexEntry_S7Gr(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr(IndexEntry_S7Gr&&) = default;
    IndexEntry_S7Gr& operator=(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr& operator=(IndexEntry_S7Gr&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || data_pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_visit_TvKAdUeckMc
                                #define DEF_visit_TvKAdUeckMc
inline static int visit_TvKA(/*3:3*/ int& value, /*3:3*/ const int i)
{
    return (value = i);
}
                                #endif

                                #ifndef DEF_ref_U9miHqS9qNl
                                #define DEF_ref_U9miHqS9qNl
inline static void ref_U9mi(/*F:7*/ Map_MvuS& map, const int hash, /*F:F*/ const int i)
{
    int* BL_1_v;
    int& /*map|static*/ data_entry = (__extension__ (
    { {
        for (; ; )
        {
            fu::vec<IndexEntry_S7Gr>& /*map*/ index = map.index;
            fu::view<IndexEntry_S7Gr> index_1 {};
            const int mask = (index_1.ptr_reassign(index), (index_1.size() ? (index_1.size() - 1) : 0));
            const int i_1 = (hash & mask);
            for (; ; )
            {
                if ((i_1 >= index.size()))
                    index.grow((index.size() + 1));
                else
                {
                    IndexEntry_S7Gr& /*index|static*/ index_entry = index.mutref(i_1);
                    index_entry.data_pos = map.data.size();
                    map.data.grow((map.data.size() + 1));
                    { BL_1_v = &(map.data.mutref(index_entry.data_pos)); goto BL_1; };
                };
            };
        };
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    visit_TvKA(data_entry, i);
}
                                #endif

static void test_MbR9(/*3:3*/ Map_MvuS& map, const int i)
{
    ref_U9mi(map, i, i);
}

int fu_MAIN()
{
    Map_MvuS map {};
    test_MbR9(map, 1);
    return map.data.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        nocopy struct IndexEntry { data_pos: int }
        struct Map { index: IndexEntry[]; data: int[] }

        inline fn hash_mask(index) index.len && index.len - 1;

        fn ref(ref map: Map, hash!: int, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (;;) {
                        ref index   = map.index;
                        let mask    = index.hash_mask;          // GNUStmtExpr
                        let i       = hash & mask;

                        for (;;) {
                            if (i >= index.len) {
                                index.grow(index.len + 1);      
                                if (index.len & 1)
                                    break;                      
                            }
                            else {
                                ref index_entry = index[i];
                                index_entry.data_pos = map.data.len;
                                map.data.grow(map.data.len + 1);
                                break :SEARCH map.data[index_entry.data_pos];
                            }                                   // Goto
                        }
                    }
                }
            }

            return visit(data_entry);   
        }

        noinline fn test(ref map: Map, i: int)
            map.ref(hash: i, visit: |ref value| value = i);

        fn main() {
            mut map: Map;
            test(map, 1);
            return map.data.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Map_MvuS;
struct IndexEntry_S7Gr;

                                #ifndef DEF_Map_MvuS3l6ADG6
                                #define DEF_Map_MvuS3l6ADG6
struct Map_MvuS
{
                                // shape_hash:    a8e2d63a55e55ed4
                                // non_triv_mask: 004a001000000000
    fu::vec<IndexEntry_S7Gr> index;
    fu::vec<int> data;
    Map_MvuS(const Map_MvuS&) = delete;
    Map_MvuS(Map_MvuS&&) = default;
    Map_MvuS& operator=(const Map_MvuS&) = delete;
    Map_MvuS& operator=(Map_MvuS&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_IndexEntry_S7GrOYwBZO2
                                #define DEF_IndexEntry_S7GrOYwBZO2
struct IndexEntry_S7Gr
{
                                // shape_hash:    8da48941e9900e02
                                // non_triv_mask: 0000001000000000
    int data_pos;
    IndexEntry_S7Gr(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr(IndexEntry_S7Gr&&) = default;
    IndexEntry_S7Gr& operator=(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr& operator=(IndexEntry_S7Gr&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || data_pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_visit_RzMFKJqxHag
                                #define DEF_visit_RzMFKJqxHag
inline static int visit_RzMF(/*3:3*/ int& value, /*3:3*/ const int i)
{
    return (value = i);
}
                                #endif

                                #ifndef DEF_ref_VoQXKnwPfS5
                                #define DEF_ref_VoQXKnwPfS5
inline static int ref_VoQX(/*F:7*/ Map_MvuS& map, const int hash, /*F:F*/ const int i)
{
    int* BL_1_v;
    int& /*map|static*/ data_entry = (__extension__ (
    { {
        for (; ; )
        {
            fu::vec<IndexEntry_S7Gr>& /*map*/ index = map.index;
            fu::view<IndexEntry_S7Gr> index_1 {};
            const int mask = (index_1.ptr_reassign(index), (index_1.size() ? (index_1.size() - 1) : 0));
            const int i_1 = (hash & mask);
            for (; ; )
            {
                if ((i_1 >= index.size()))
                {
                    index.grow((index.size() + 1));
                    if (index.size() & 1)
                        break;

                }
                else
                {
                    IndexEntry_S7Gr& /*index|static*/ index_entry = index.mutref(i_1);
                    index_entry.data_pos = map.data.size();
                    map.data.grow((map.data.size() + 1));
                    { BL_1_v = &(map.data.mutref(index_entry.data_pos)); goto BL_1; };
                };
            };
        };
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    return visit_RzMF(data_entry, i);
}
                                #endif

static int test_kGbb(/*3:3*/ Map_MvuS& map, const int i)
{
    return ref_VoQX(map, i, i);
}

int fu_MAIN()
{
    Map_MvuS map {};
    test_kGbb(map, 1);
    return map.data.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        nocopy struct IndexEntry { data_pos: int }
        struct Map { index: IndexEntry[]; data: int[] }

        inline fn hash_mask(index) index.len && index.len - 1;

        fn ref(ref map: Map, hash!: int, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (;;) {
                        ref index   = map.index;
                        let mask    = index.hash_mask;          // GNUStmtExpr
                        let i       = hash & mask;

                        for (;;) {
                            if (i >= index.len) {
                                index.grow(index.len + 1);      
                                if (index.len & 1)
                                    break;                      
                            }
                            else {
                                ref index_entry = index[i];
                                index_entry.data_pos = map.data.len;
                                map.data.grow(map.data.len + 1);
                                break :SEARCH map.data[index_entry.data_pos];
                            }                                   // Goto
                        }
                    }
                }
            }

            visit(data_entry);          
        }

        noinline fn test(ref map: Map, i: int)
            map.ref(hash: i, visit: |ref value| value = i);

        fn main() {
            mut map: Map;
            test(map, 1);
            return map.data.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Map_MvuS;
struct IndexEntry_S7Gr;

                                #ifndef DEF_Map_MvuS3l6ADG6
                                #define DEF_Map_MvuS3l6ADG6
struct Map_MvuS
{
                                // shape_hash:    a8e2d63a55e55ed4
                                // non_triv_mask: 004a001000000000
    fu::vec<IndexEntry_S7Gr> index;
    fu::vec<int> data;
    Map_MvuS(const Map_MvuS&) = delete;
    Map_MvuS(Map_MvuS&&) = default;
    Map_MvuS& operator=(const Map_MvuS&) = delete;
    Map_MvuS& operator=(Map_MvuS&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || index
            || data
        ;
    }
};
                                #endif

                                #ifndef DEF_IndexEntry_S7GrOYwBZO2
                                #define DEF_IndexEntry_S7GrOYwBZO2
struct IndexEntry_S7Gr
{
                                // shape_hash:    8da48941e9900e02
                                // non_triv_mask: 0000001000000000
    int data_pos;
    IndexEntry_S7Gr(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr(IndexEntry_S7Gr&&) = default;
    IndexEntry_S7Gr& operator=(const IndexEntry_S7Gr&) = delete;
    IndexEntry_S7Gr& operator=(IndexEntry_S7Gr&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || data_pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_visit_TvKAdUeckMc
                                #define DEF_visit_TvKAdUeckMc
inline static int visit_TvKA(/*3:3*/ int& value, /*3:3*/ const int i)
{
    return (value = i);
}
                                #endif

                                #ifndef DEF_ref_1xJxgvS7Mm2
                                #define DEF_ref_1xJxgvS7Mm2
inline static void ref_1xJx(/*F:7*/ Map_MvuS& map, const int hash, /*F:F*/ const int i)
{
    int* BL_1_v;
    int& /*map|static*/ data_entry = (__extension__ (
    { {
        for (; ; )
        {
            fu::vec<IndexEntry_S7Gr>& /*map*/ index = map.index;
            fu::view<IndexEntry_S7Gr> index_1 {};
            const int mask = (index_1.ptr_reassign(index), (index_1.size() ? (index_1.size() - 1) : 0));
            const int i_1 = (hash & mask);
            for (; ; )
            {
                if ((i_1 >= index.size()))
                {
                    index.grow((index.size() + 1));
                    if (index.size() & 1)
                        break;

                }
                else
                {
                    IndexEntry_S7Gr& /*index|static*/ index_entry = index.mutref(i_1);
                    index_entry.data_pos = map.data.size();
                    map.data.grow((map.data.size() + 1));
                    { BL_1_v = &(map.data.mutref(index_entry.data_pos)); goto BL_1; };
                };
            };
        };
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    visit_TvKA(data_entry, i);
}
                                #endif

static void test_MbR9(/*3:3*/ Map_MvuS& map, const int i)
{
    ref_1xJx(map, i, i);
}

int fu_MAIN()
{
    Map_MvuS map {};
    test_MbR9(map, 1);
    return map.data.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        struct TwoArrays { a: i32[]; b: i32[] };
        noinline fn what(ref arr: i32[], ref w: TwoArrays) {
            w.b ~= w.a;
            w.b ~= arr;
        }

        fn main() {
            mut ab = TwoArrays([ 1, 2, 3 ], [ 4, 5, 6 ]);
            what(ab.a[1 ..], ab);
            return ab.b == [ 4, 5, 6, 1, 2, 3, 2, 3 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TwoArrays_Ky0L;

                                #ifndef DEF_TwoArrays_Ky0LbdzFjXh
                                #define DEF_TwoArrays_Ky0LbdzFjXh
struct TwoArrays_Ky0L
{
                                // shape_hash:    24416b4ea443721d
                                // non_triv_mask: 4008000000000000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void what_MbR9(/*3:3*/ fu::view<int> arr, /*2:2*/ TwoArrays_Ky0L& w)
{
    w.b += w.a;
    w.b += arr;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    TwoArrays_Ky0L ab = TwoArrays_Ky0L { fu::vec<int> {{ 1, 2, 3 }}, fu::vec<int> {{ 4, 5, 6 }} };
    what_MbR9(fu::get_view(ab.a, 1), ab);
    if (ab.b == fu::view<int> {{ 4, 5, 6, 1, 2, 3, 2, 3 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Target   { globid: int[] }
        struct Entity   { quals: int[]; specs?: Spec[] }
        struct Spec     { relax: int[]; inst: Target }

        noinline fn redundantCopiesOfCopies(    
                entities: Entity[], target: Target)
        {
            fn GET_mut(t) entities[t.globid.len];

            fn lazySolveStart(t: Target) {
                ref o           = GET_mut(t);
                let specs       = o.specs;
                let actual      = o.quals;

                for (mut i = 0; i < specs.len; i++) {
                    let spec        = specs[i];
                    shadow let t    = spec.inst;
                    shadow ref o    = GET_mut(t);

                    if (min(actual.len, spec.relax.len) == spec.relax.len) {
                        o = [];
                        return lazySolveStart(t);
                    }
                }
            }

            return lazySolveStart(target);
        }

        fn main() {
            mut entities = [
                Entity([ 1 ], [ Spec([ 1 ], Target([ 1 ])) ]),
                Entity([ 2, 2 ]),
                Entity([ 3, 3, 3 ]),
            ];

            redundantCopiesOfCopies(entities, []);
            mut sum = 0;
            entities.map(|v| sum += v.quals.len);
            return sum - 4;
        }

---- <fail> ----
[2m[0m_0[2m.fu 22:27+1[0m:

[2m      | [0m
[2m      |                     if (min(actual.len, spec.relax.len) == spec.relax.len) {[0m
[2m   22 | [0m                        o [31;1m=[0m [];
[2m      |                         return lazySolveStart(t);[0m
[2m      |                     }[0m

	Bad call to [94;1m=[0m with args ([35;3mstruct[0m [94;1mEntity[0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m): 

	[35;3mtemplate[0m [94;1m=[0m at [2m../../../../../[0mprelude[2m 212:12+1[0m:
[2m  212 | [0minfix fn   [31;1m=[0m (mut ref a: <T>,    mut b: T): &mut T = __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3mconst ref[0m [94;1mo[0m at [2m19:32+1[0m:

[2m      |                     let spec        = specs[i];[0m
[2m      |                     shadow let t    = spec.inst;[0m
[2m   19 | [0m                    shadow ref [31;1mo[0m    = GET_mut(t);
[2m      | [0m
[2m      |                     if (min(actual.len, spec.relax.len) == spec.relax.len) {[0m

	    ... which is a ref to [35;3minjected implicit const ref arg[0m [94;1mredundantCopiesOfCopies:entities[0m at [2m7:17+8[0m:

[2m      | [0m
[2m      |         noinline fn redundantCopiesOfCopies(    [0m
[2m    7 | [0m                [31;1mentities[0m: Entity[], target: Target)
[2m      |         {[0m
[2m      |             fn GET_mut(t) entities[t.globid.len];[0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mlazySolveStart[0m([94;1mTarget[0m) at [2m11:16+14[0m
                [35;3mfn[0m [94;1mredundantCopiesOfCopies[0m([94;1mEntity[0m[35;3m[..][0m, [94;1mTarget[0m) at [2m6:21+23[0m

========

        struct Target   { globid: int[] }
        struct Entity   { quals: int[]; specs?: Spec[] }
        struct Spec     { relax: int[]; inst: Target }

        noinline fn redundantCopiesOfCopies(    
            ref                                 
                entities: Entity[], target: Target)
        {
            fn GET_mut(t) entities[t.globid.len];

            fn lazySolveStart(t: Target) {
                ref o           = GET_mut(t);
                let specs       = o.specs;
                let actual      = o.quals;

                for (mut i = 0; i < specs.len; i++) {
                    let spec        = specs[i];
                    shadow let t    = spec.inst;
                    shadow ref o    = GET_mut(t);

                    if (min(actual.len, spec.relax.len) == spec.relax.len) {
                        o = [];
                        return lazySolveStart(t);
                    }
                }
            }

            return lazySolveStart(target);
        }

        fn main() {
            mut entities = [
                Entity([ 1 ], [ Spec([ 1 ], Target([ 1 ])) ]),
                Entity([ 2, 2 ]),
                Entity([ 3, 3, 3 ]),
            ];

            redundantCopiesOfCopies(entities, []);
            mut sum = 0;
            entities.map(|v| sum += v.quals.len);
            return sum - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct Entity_1S7d;
struct Spec_xao2;
struct Target_mD0F;
static void lazySolveStart_MbR9(const Target_mD0F&, fu::view_mut<Entity_1S7d>);

                                #ifndef DEF_Target_mD0FGokFADa
                                #define DEF_Target_mD0FGokFADa
struct Target_mD0F
{
                                // shape_hash:    0619e570becf9eb7
                                // non_triv_mask: 0008000010000000
    fu::vec<int> globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_Entity_1S7djNALuyl
                                #define DEF_Entity_1S7djNALuyl
struct Entity_1S7d
{
                                // shape_hash:    953e30a5e83a41bf
                                // non_triv_mask: 4008002210000000
    fu::vec<int> quals;
    fu::vec<Spec_xao2> specs;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || specs
        ;
    }
};
                                #endif

                                #ifndef DEF_Spec_xao2CHKTgRc
                                #define DEF_Spec_xao2CHKTgRc
struct Spec_xao2
{
                                // shape_hash:    ddf43d6e7ea87c59
                                // non_triv_mask: 0008000210000000
    fu::vec<int> relax;
    Target_mD0F inst;
    explicit operator bool() const noexcept
    {
        return false
            || relax
            || inst
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_GET_mut_SxJpswQT4e8
                                #define DEF_GET_mut_SxJpswQT4e8
inline static const Entity_1S7d& GET_mut_SxJp(/*3:3*/ const Target_mD0F& t, /*3:3*/ fu::view<Entity_1S7d> entities)
{
    return entities[t.globid.size()];
}
                                #endif

                                #ifndef DEF_GET_mut_nLbXVN87so5
                                #define DEF_GET_mut_nLbXVN87so5
inline static Entity_1S7d& GET_mut_nLbX(/*3:3*/ const Target_mD0F& t, /*3:3*/ fu::view_mut<Entity_1S7d> entities)
{
    return entities.mutref(t.globid.size());
}
                                #endif

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(/*3:3*/ const int a, /*3:3*/ const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

static void lazySolveStart_MbR9(/*3:3*/ const Target_mD0F& t, /*3:3*/ fu::view_mut<Entity_1S7d> entities)
{
    const Entity_1S7d& /*entities|static*/ o = GET_mut_SxJp(t, entities);
    fu::vec<Spec_xao2> specs = fu::vec<Spec_xao2>(o.specs);
    fu::vec<int> actual = fu::vec<int>(o.quals);
    for (int i = 0; i < specs.size(); i++)
    {
        const Spec_xao2& /*specs|static*/ spec = specs[i];
        const Target_mD0F& /*spec*/ t_1 = spec.inst;
        Entity_1S7d& /*entities|static*/ o_1 = GET_mut_nLbX(t_1, entities);
        if (min_DbqN(actual.size(), spec.relax.size()) == spec.relax.size())
        {
            o_1 = Entity_1S7d{};
            lazySolveStart_MbR9(t_1, entities);
            return;
        };
    };
}

static void redundantCopiesOfCopies_MbR9(/*3:3*/ fu::view_mut<Entity_1S7d> entities, /*3:3*/ const Target_mD0F& target)
{
    lazySolveStart_MbR9(target, entities);
}

                                #ifndef DEF___BjnnqB3bryk
                                #define DEF___BjnnqB3bryk
inline static int _Bjnn(/*3:3*/ const Entity_1S7d& v, /*3:3*/ int& sum)
{
    return (sum += v.quals.size());
}
                                #endif

                                #ifndef DEF_map_AgN6hh9vedf
                                #define DEF_map_AgN6hh9vedf
inline fu::vec<int> map_AgN6(/*7:7*/ fu::view<Entity_1S7d> a, /*7:6*/ int& sum)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _Bjnn(a[i], sum);

    return /*NRVO*/ res;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Entity_1S7d> entities = fu::vec<Entity_1S7d> {{ Entity_1S7d { fu::vec<int> {{ 1 }}, fu::vec<Spec_xao2> {{ Spec_xao2 { fu::vec<int> {{ 1 }}, Target_mD0F { fu::vec<int> {{ 1 }} } } }} }, Entity_1S7d { fu::vec<int> {{ 2, 2 }}, fu::vec<Spec_xao2>{} }, Entity_1S7d { fu::vec<int> {{ 3, 3, 3 }}, fu::vec<Spec_xao2>{} } }};
    redundantCopiesOfCopies_MbR9(entities, (*(Target_mD0F*)fu::NIL));
    int sum = 0;
    map_AgN6(entities, sum);
    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall

========

        struct Node     { items?: Node[]; target: int }
        struct Extended { min: i32; node?: Node }

        fn solve(root: Node, ref _extended: Extended)
        {
            noinline fn GET() _extended.node;
            noinline fn EXT() _extended;

            fn unorderedPrep_A(node: Node) {
                ref o       = GET();
                ref ext     = EXT();
                ext.min     = 0x7fffffff.i32;
                o           = node;
            }

            return unorderedPrep_A(root);
        }

        fn main() {
            mut _extended: Extended;
            solve(Node([], 11), :_extended);
            return _extended.min == i32.MAX && _extended.node.target == 11 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Extended_FpAp;
struct Node_KzZI;

                                #ifndef DEF_Node_KzZIc9ndfma
                                #define DEF_Node_KzZIc9ndfma
struct Node_KzZI
{
                                // shape_hash:    c1dd108b5c2c7a87
                                // non_triv_mask: 0000000104000000
    fu::vec<Node_KzZI> items;
    int target;
    Node_KzZI(const Node_KzZI&) = default;
    Node_KzZI(Node_KzZI&&) = default;
    Node_KzZI& operator=(Node_KzZI&&) = default;
    Node_KzZI& operator=(const Node_KzZI& selfrec) { return *this = Node_KzZI(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_FpApuHFimL3
                                #define DEF_Extended_FpApuHFimL3
struct Extended_FpAp
{
                                // shape_hash:    fba2dbaf93f07db2
                                // non_triv_mask: 0000000104000008
    int min;
    Node_KzZI node;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || node
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Node_KzZI& GET_MbR9(/*1:1*/ Extended_FpAp& _extended)
{
    return _extended.node;
}

static Extended_FpAp& EXT_MbR9(/*1:1*/ Extended_FpAp& _extended)
{
    return _extended;
}

static void unorderedPrep_A_MbR9(/*3:3*/ const Node_KzZI& node, /*2:2*/ Extended_FpAp& _extended)
{
    Node_KzZI& /*_extended*/ o = GET_MbR9(_extended);
    Extended_FpAp& /*_extended*/ ext = EXT_MbR9(_extended);
    ext.min = int(0x7fffffffu);
    o = node;
}

static void solve_MbR9(/*3:3*/ const Node_KzZI& root, /*2:2*/ Extended_FpAp& _extended)
{
    unorderedPrep_A_MbR9(root, _extended);
}

                                #ifndef DEF_MAX_GzC5uMH53i1
                                #define DEF_MAX_GzC5uMH53i1
inline int MAX_GzC5()
{
    return 2147483647;
}
                                #endif

int fu_MAIN()
{
    Extended_FpAp _extended {};
    solve_MbR9(Node_KzZI { fu::vec<Node_KzZI>{}, 11 }, _extended);
    if ((_extended.min == MAX_GzC5()) && (_extended.node.target == 11))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy

========

        struct Child  { hello: int; irrelevant?: string };
        struct Parent { world?: int; children?: Child[] };

        fn test(ref parents: Parent[], t: int) {
            fn getParent(index: int)    parents[index];
            fn getChild(index: int)     getParent(index).children[index];

            ref c = getChild(t);        c.hello++;
            ref p = getParent(t);       p.world++;
        }

        fn main() {
            mut parents = [ Parent(children: [ Child() ]) ];
            test(parents, 0);

            mut sum = 0;
            fn count(what: <What>)
                case (What.is::primitive)       sum += what.int;
                case (What -> _[])              what.each(.count);
                default for (fieldname i: What) what.i.count();

            count(parents);
            return sum - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct Parent_6XFd;
struct Child_12T1;

                                #ifndef DEF_Child_12T1oi9SD60
                                #define DEF_Child_12T1oi9SD60
struct Child_12T1
{
                                // shape_hash:    1d6f800997d7f310
                                // non_triv_mask: 0000a00000000000
    int hello;
    fu::str irrelevant;
    explicit operator bool() const noexcept
    {
        return false
            || hello
            || irrelevant
        ;
    }
};
                                #endif

                                #ifndef DEF_Parent_6XFdUmGKMGj
                                #define DEF_Parent_6XFdUmGKMGj
struct Parent_6XFd
{
                                // shape_hash:    cc09d426ea1c755e
                                // non_triv_mask: 0001a00000000001
    int world;
    fu::vec<Child_12T1> children;
    explicit operator bool() const noexcept
    {
        return false
            || world
            || children
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Parent_6XFd& getParent_MbR9(const int index, /*3:3*/ fu::view_mut<Parent_6XFd> parents)
{
    return parents.mutref(index);
}

static Child_12T1& getChild_MbR9(const int index, /*3:3*/ fu::view_mut<Parent_6XFd> parents)
{
    return getParent_MbR9(index, parents).children.mutref(index);
}

static void test_MbR9(/*3:3*/ fu::view_mut<Parent_6XFd> parents, const int t)
{
    Child_12T1& /*parents|static*/ c = getChild_MbR9(t, parents);
    c.hello++;
    Parent_6XFd& /*parents|static*/ p = getParent_MbR9(t, parents);
    p.world++;
}

                                #ifndef DEF_count_IhhPrr8vl5l
                                #define DEF_count_IhhPrr8vl5l
inline static int count_IhhP(const int what, /*3:3*/ int& sum)
{
    return (sum += int(what));
}
                                #endif

                                #ifndef DEF_count_fOiqrSVZz12
                                #define DEF_count_fOiqrSVZz12
inline static int count_fOiq(const char what, /*3:3*/ int& sum)
{
    return (sum += int(fu::u8(what)));
}
                                #endif

                                #ifndef DEF___Zy6SK76Izb0
                                #define DEF___Zy6SK76Izb0
inline static int _Zy6S(/*3:3*/ const char _, /*3:3*/ int& sum)
{
    return count_fOiq(_, sum);
}
                                #endif

                                #ifndef DEF_each_fluGIDJiVki
                                #define DEF_each_fluGIDJiVki
inline void each_fluG(/*7:7*/ fu::view<char> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _Zy6S(a[i], sum);

}
                                #endif

                                #ifndef DEF_count_8jMICxaOmM0
                                #define DEF_count_8jMICxaOmM0
inline static void count_8jMI(/*3:3*/ fu::view<char> what, /*2:2*/ int& sum)
{
    each_fluG(what, sum);
}
                                #endif

                                #ifndef DEF_count_yuqIvYdFVW6
                                #define DEF_count_yuqIvYdFVW6
inline static void count_yuqI(/*3:3*/ const Child_12T1& what, /*2:2*/ int& sum)
{
    count_IhhP(what.hello, sum);
    count_8jMI(what.irrelevant, sum);
}
                                #endif

                                #ifndef DEF___RNjh3TkE3i9
                                #define DEF___RNjh3TkE3i9
inline static void _RNjh(/*3:3*/ const Child_12T1& _, /*2:2*/ int& sum)
{
    count_yuqI(_, sum);
}
                                #endif

                                #ifndef DEF_each_jIY5kiQQHp1
                                #define DEF_each_jIY5kiQQHp1
inline void each_jIY5(/*7:7*/ fu::view<Child_12T1> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _RNjh(a[i], sum);

}
                                #endif

                                #ifndef DEF_count_ZuNbTD5L99f
                                #define DEF_count_ZuNbTD5L99f
inline static void count_ZuNb(/*3:3*/ fu::view<Child_12T1> what, /*2:2*/ int& sum)
{
    each_jIY5(what, sum);
}
                                #endif

                                #ifndef DEF_count_HdzF8lIO7Xg
                                #define DEF_count_HdzF8lIO7Xg
inline static void count_HdzF(/*3:3*/ const Parent_6XFd& what, /*2:2*/ int& sum)
{
    count_IhhP(what.world, sum);
    count_ZuNb(what.children, sum);
}
                                #endif

                                #ifndef DEF___fFvPiWg3Cde
                                #define DEF___fFvPiWg3Cde
inline static void _fFvP(/*3:3*/ const Parent_6XFd& _, /*2:2*/ int& sum)
{
    count_HdzF(_, sum);
}
                                #endif

                                #ifndef DEF_each_1cyn9Eq9JD3
                                #define DEF_each_1cyn9Eq9JD3
inline void each_1cyn(/*7:7*/ fu::view<Parent_6XFd> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _fFvP(a[i], sum);

}
                                #endif

                                #ifndef DEF_count_ka23R6toge6
                                #define DEF_count_ka23R6toge6
inline static void count_ka23(/*3:3*/ fu::view<Parent_6XFd> what, /*2:2*/ int& sum)
{
    each_1cyn(what, sum);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Parent_6XFd> parents = fu::vec<Parent_6XFd> {{ Parent_6XFd { 0, fu::vec<Child_12T1> {{ Child_12T1{} }} } }};
    test_MbR9(parents, 0);
    int sum = 0;
    count_ka23(parents, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct ArrayTuple { a: i32[]; b: i32[] };
        struct TupleTuple { a: ArrayTuple; b: ArrayTuple };
        fn main() {
            mut tt: TupleTuple;
            tt.b.b      = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ];


            ref  fin = tt.b.b[tt.b.b.len - 1];

            ref other   = tt.b;
            ref other_2 = other.b;
            for (mut i = 0; i < 8; i++)
                other_2 ~= other_2.map(|v| v + 1);

            return ++fin;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:22+3[0m:

[2m      |                 other_2 ~= other_2.map(|v| v + 1);[0m
[2m      | [0m
[2m   16 | [0m            return ++[31;1mfin[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mfin[0m, reference invalidated by write to [35;3mmut ref[0m [94;1mother_2[0m at [2m14:25+2[0m:

[2m      |             ref other_2 = other.b;[0m
[2m      |             for (mut i = 0; i < 8; i++)[0m
[2m   14 | [0m                other_2 [31;1m~=[0m other_2.map(|v| v + 1);
[2m      | [0m
[2m      |             return ++fin;[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct ArrayTuple { a: i32[]; b: i32[] };
        struct TupleTuple { a: ArrayTuple; b: ArrayTuple };
        fn main() {
            mut tt: TupleTuple;
            tt.b.b      = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ];


            mut  fin = tt.b.b[tt.b.b.len - 1];

            ref other   = tt.b;
            ref other_2 = other.b;
            for (mut i = 0; i < 8; i++)
                other_2 ~= other_2.map(|v| v + 1);

            return ++fin;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(48768) arc_count(16) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct TupleTuple_efaa;
struct ArrayTuple_FWBU;

                                #ifndef DEF_ArrayTuple_FWBUeafqaYc
                                #define DEF_ArrayTuple_FWBUeafqaYc
struct ArrayTuple_FWBU
{
                                // shape_hash:    96087b8f64c23179
                                // non_triv_mask: 0008000000200000
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_TupleTuple_efaaFNy1Tu4
                                #define DEF_TupleTuple_efaaFNy1Tu4
struct TupleTuple_efaa
{
                                // shape_hash:    8f2a6036a65a4643
                                // non_triv_mask: 0008000000200010
    ArrayTuple_FWBU a;
    ArrayTuple_FWBU b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___IQ7pCaWlLNe
                                #define DEF___IQ7pCaWlLNe
inline static int _IQ7p(const int v)
{
    return v + 1;
}
                                #endif

                                #ifndef DEF_map_F4wc3eQlUW8
                                #define DEF_map_F4wc3eQlUW8
inline fu::vec<int> map_F4wc(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _IQ7p(a[i]);

    return /*NRVO*/ res;
}
                                #endif

int fu_MAIN()
{
    TupleTuple_efaa tt {};
    tt.b.b = fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 }};
    int fin = tt.b.b[(tt.b.b.size() - 1)];
    ArrayTuple_FWBU& /*tt*/ other = tt.b;
    fu::vec<int>& /*other*/ other_2 = other.b;
    for (int i = 0; i < 8; i++)
        other_2 += map_F4wc(other_2);

    return ++fin;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Pad4 { a: int; b: int; c: int; d: int };
        struct Pad16 { a: Pad4; b: Pad4; c: Pad4; d: Pad4 };
        struct Pad64 { a: Pad16; b: Pad16; c: Pad16; d: Pad16 };
        struct Pad256 { a: Pad64; b: Pad64; c: Pad64; d: Pad64 };

        struct Data {
            pad_front?: Pad256;
            ints: int[];
            pad_back?: Pad256;
        }

        fn main() {
            mut data = Data(ints: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ]);


            ref  fin = data.ints[data.ints.len - 1];

            for (mut i = 0; i < 8; i++)
                data.ints ~= data.ints.map(|v| v + 1);

            return ++fin;
        }

---- <fail> ----
[2m[0m_0[2m.fu 22:22+3[0m:

[2m      |                 data.ints ~= data.ints.map(|v| v + 1);[0m
[2m      | [0m
[2m   22 | [0m            return ++[31;1mfin[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mfin[0m, reference invalidated by write to [35;3mmut[0m [94;1mdata[0m at [2m20:27+2[0m:

[2m      | [0m
[2m      |             for (mut i = 0; i < 8; i++)[0m
[2m   20 | [0m                data.ints [31;1m~=[0m data.ints.map(|v| v + 1);
[2m      | [0m
[2m      |             return ++fin;[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        struct Pad4 { a: int; b: int; c: int; d: int };
        struct Pad16 { a: Pad4; b: Pad4; c: Pad4; d: Pad4 };
        struct Pad64 { a: Pad16; b: Pad16; c: Pad16; d: Pad16 };
        struct Pad256 { a: Pad64; b: Pad64; c: Pad64; d: Pad64 };

        struct Data {
            pad_front?: Pad256;
            ints: int[];
            pad_back?: Pad256;
        }

        fn main() {
            mut data = Data(ints: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ]);


            ref  fin = data.ints[data.ints.len - 1];

            ref v = data.ints;
            for (mut i = 0; i < 8; i++) v ~= v.map(|w| w + 1);

            return ++fin;
        }

---- <fail> ----
[2m[0m_0[2m.fu 22:22+3[0m:

[2m      |             for (mut i = 0; i < 8; i++) v ~= v.map(|w| w + 1);[0m
[2m      | [0m
[2m   22 | [0m            return ++[31;1mfin[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;3mmut ref[0m [94;1mfin[0m, reference invalidated by write to [35;3mmut ref[0m [94;1mv[0m at [2m20:43+2[0m:

[2m      | [0m
[2m      |             ref v = data.ints;[0m
[2m   20 | [0m            for (mut i = 0; i < 8; i++) v [31;1m~=[0m v.map(|w| w + 1);
[2m      | [0m
[2m      |             return ++fin;[0m

	At call to [35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        struct Pad4 { a: int; b: int; c: int; d: int };
        struct Pad16 { a: Pad4; b: Pad4; c: Pad4; d: Pad4 };
        struct Pad64 { a: Pad16; b: Pad16; c: Pad16; d: Pad16 };
        struct Pad256 { a: Pad64; b: Pad64; c: Pad64; d: Pad64 };

        struct Data {
            pad_front?: Pad256;
            ints: int[];
            pad_back?: Pad256;
        }

        fn main() {
            mut data = Data(ints: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ]);


            mut  fin = data.ints[data.ints.len - 1];

            for (mut i = 0; i < 8; i++)
                data.ints ~= data.ints.map(|v| v + 1);

            return ++fin;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(48768) arc_count(16) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Data_Kuua;
struct Pad256_9elA;
struct Pad64_iMwi;
struct Pad16_tfzu;
struct Pad4_u9JE;

                                #ifndef DEF_Pad4_u9JELDKghw1
                                #define DEF_Pad4_u9JELDKghw1
struct Pad4_u9JE
{
                                // shape_hash:    0576b1756ec26b11
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    int c;
    int d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad16_tfzu9bsoESh
                                #define DEF_Pad16_tfzu9bsoESh
struct Pad16_tfzu
{
                                // shape_hash:    b88fb47a910d640d
                                // non_triv_mask: 0000000000000000
    Pad4_u9JE a;
    Pad4_u9JE b;
    Pad4_u9JE c;
    Pad4_u9JE d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad64_iMwibdP0xZj
                                #define DEF_Pad64_iMwibdP0xZj
struct Pad64_iMwi
{
                                // shape_hash:    27c309ef0625dd8e
                                // non_triv_mask: 0000000000000000
    Pad16_tfzu a;
    Pad16_tfzu b;
    Pad16_tfzu c;
    Pad16_tfzu d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad256_9elAai9vHpe
                                #define DEF_Pad256_9elAai9vHpe
struct Pad256_9elA
{
                                // shape_hash:    1c38e46e4f425e7a
                                // non_triv_mask: 0000000000000000
    Pad64_iMwi a;
    Pad64_iMwi b;
    Pad64_iMwi c;
    Pad64_iMwi d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Data_KuuaZnnwBe1
                                #define DEF_Data_KuuaZnnwBe1
struct Data_Kuua
{
                                // shape_hash:    a4fb6abdc24346e0
                                // non_triv_mask: 0048000000000000
    Pad256_9elA pad_front;
    fu::vec<int> ints;
    Pad256_9elA pad_back;
    explicit operator bool() const noexcept
    {
        return false
            || pad_front
            || ints
            || pad_back
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___IQ7pCaWlLNe
                                #define DEF___IQ7pCaWlLNe
inline static int _IQ7p(const int v)
{
    return v + 1;
}
                                #endif

                                #ifndef DEF_map_F4wc3eQlUW8
                                #define DEF_map_F4wc3eQlUW8
inline fu::vec<int> map_F4wc(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _IQ7p(a[i]);

    return /*NRVO*/ res;
}
                                #endif

int fu_MAIN()
{
    Data_Kuua data = Data_Kuua { Pad256_9elA{}, fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 }}, Pad256_9elA{} };
    int fin = data.ints[(data.ints.size() - 1)];
    for (int i = 0; i < 8; i++)
        data.ints += map_F4wc(data.ints);

    return ++fin;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Pad4 { a: int; b: int; c: int; d: int };
        struct Pad16 { a: Pad4; b: Pad4; c: Pad4; d: Pad4 };
        struct Pad64 { a: Pad16; b: Pad16; c: Pad16; d: Pad16 };
        struct Pad256 { a: Pad64; b: Pad64; c: Pad64; d: Pad64 };

        struct Data {
            pad_front?: Pad256;
            ints: int[];
            pad_back?: Pad256;
        }

        fn main() {
            mut data = Data(ints: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 ]);


            mut  fin = data.ints[data.ints.len - 1];

            ref v = data.ints;
            for (mut i = 0; i < 8; i++) v ~= v.map(|w| w + 1);

            return ++fin;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(48768) arc_count(16) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Data_Kuua;
struct Pad256_9elA;
struct Pad64_iMwi;
struct Pad16_tfzu;
struct Pad4_u9JE;

                                #ifndef DEF_Pad4_u9JELDKghw1
                                #define DEF_Pad4_u9JELDKghw1
struct Pad4_u9JE
{
                                // shape_hash:    0576b1756ec26b11
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    int c;
    int d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad16_tfzu9bsoESh
                                #define DEF_Pad16_tfzu9bsoESh
struct Pad16_tfzu
{
                                // shape_hash:    b88fb47a910d640d
                                // non_triv_mask: 0000000000000000
    Pad4_u9JE a;
    Pad4_u9JE b;
    Pad4_u9JE c;
    Pad4_u9JE d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad64_iMwibdP0xZj
                                #define DEF_Pad64_iMwibdP0xZj
struct Pad64_iMwi
{
                                // shape_hash:    27c309ef0625dd8e
                                // non_triv_mask: 0000000000000000
    Pad16_tfzu a;
    Pad16_tfzu b;
    Pad16_tfzu c;
    Pad16_tfzu d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Pad256_9elAai9vHpe
                                #define DEF_Pad256_9elAai9vHpe
struct Pad256_9elA
{
                                // shape_hash:    1c38e46e4f425e7a
                                // non_triv_mask: 0000000000000000
    Pad64_iMwi a;
    Pad64_iMwi b;
    Pad64_iMwi c;
    Pad64_iMwi d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Data_KuuaZnnwBe1
                                #define DEF_Data_KuuaZnnwBe1
struct Data_Kuua
{
                                // shape_hash:    a4fb6abdc24346e0
                                // non_triv_mask: 0048000000000000
    Pad256_9elA pad_front;
    fu::vec<int> ints;
    Pad256_9elA pad_back;
    explicit operator bool() const noexcept
    {
        return false
            || pad_front
            || ints
            || pad_back
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___IQ7pCaWlLNe
                                #define DEF___IQ7pCaWlLNe
inline static int _IQ7p(const int w)
{
    return w + 1;
}
                                #endif

                                #ifndef DEF_map_F4wc3eQlUW8
                                #define DEF_map_F4wc3eQlUW8
inline fu::vec<int> map_F4wc(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _IQ7p(a[i]);

    return /*NRVO*/ res;
}
                                #endif

int fu_MAIN()
{
    Data_Kuua data = Data_Kuua { Pad256_9elA{}, fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 }}, Pad256_9elA{} };
    int fin = data.ints[(data.ints.size() - 1)];
    fu::vec<int>& /*data*/ v = data.ints;
    for (int i = 0; i < 8; i++)
        v += map_F4wc(v);

    return ++fin;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Ensure(ref a: <T>[], exists!i: int) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Thing4   { a: int; b: int; c: int; d: int }
        struct Thing16  { a: Thing4; b: Thing4; c: Thing4; d: Thing4 }
        struct Thing64  { a: Thing16; b: Thing16; c: Thing16; d: Thing16 }
        struct Thing256 { a: Thing64; b: Thing64; c: Thing64; d: Thing64 }

        struct SolverState {
            _pad_before:    Thing256;
            _warnings:      int[];
            _pad_after:     Thing256;
        }

        fn search(using ref ss: SolverState, t: int)
            _warnings.Ensure(exists: t) ||= t;

        fn main() {
            mut ss: SolverState;
            ss.search(0);
            ss._warnings.len - 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct SolverState_DVRF;
struct Thing256_iUQt;
struct Thing64_NLwV;
struct Thing16_VQmW;
struct Thing4_AzF9;

                                #ifndef DEF_Thing4_AzF9EymZn7c
                                #define DEF_Thing4_AzF9EymZn7c
struct Thing4_AzF9
{
                                // shape_hash:    a3102c5b32fb82d8
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    int c;
    int d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Thing16_VQmW7Q89oLh
                                #define DEF_Thing16_VQmW7Q89oLh
struct Thing16_VQmW
{
                                // shape_hash:    9c0cba18e6e89eec
                                // non_triv_mask: 0000000000000000
    Thing4_AzF9 a;
    Thing4_AzF9 b;
    Thing4_AzF9 c;
    Thing4_AzF9 d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Thing64_NLwVbNGVQc8
                                #define DEF_Thing64_NLwVbNGVQc8
struct Thing64_NLwV
{
                                // shape_hash:    bd56c90e760889f5
                                // non_triv_mask: 0000000000000000
    Thing16_VQmW a;
    Thing16_VQmW b;
    Thing16_VQmW c;
    Thing16_VQmW d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_Thing256_iUQtqy3e2k9
                                #define DEF_Thing256_iUQtqy3e2k9
struct Thing256_iUQt
{
                                // shape_hash:    aadef785a45b79c6
                                // non_triv_mask: 0000000000000000
    Thing64_NLwV a;
    Thing64_NLwV b;
    Thing64_NLwV c;
    Thing64_NLwV d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_DVRFoAnBH1k
                                #define DEF_SolverState_DVRFoAnBH1k
struct SolverState_DVRF
{
                                // shape_hash:    1ccd08e3119b549e
                                // non_triv_mask: 2008000000000000
    Thing256_iUQt _pad_before;
    fu::vec<int> _warnings;
    Thing256_iUQt _pad_after;
    explicit operator bool() const noexcept
    {
        return false
            || _pad_before
            || _warnings
            || _pad_after
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Ensure_2Giz4sIWyKi
                                #define DEF_Ensure_2Giz4sIWyKi
inline static int& Ensure_2Giz(/*3:3*/ fu::vec_range_mut<int> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static int search_kGbb(/*3:3*/ SolverState_DVRF& ss, const int t)
{
    int& /*ss|static*/ a = Ensure_2Giz(ss._warnings, t);
    return a ? a : (a = t);
}

int fu_MAIN()
{
    SolverState_DVRF ss {};
    search_kGbb(ss, 0);
    return ss._warnings.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        nocopy 
        struct AB { a: int; b: int };

        fn main() {
            mut v0 = AB(1, 2);
            mut v1 = v0;
            ref a = v0.a;
            ref b = v1.a;
            a += 10;
            b += a;
            return b - 12;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:22+2[0m:

[2m      |         fn main() {[0m
[2m      |             mut v0 = AB(1, 2);[0m
[2m    8 | [0m            mut v1 = [31;1mv0[0m;
[2m      |             ref a = v0.a;[0m
[2m      |             ref b = v1.a;[0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [94;1mv0[0m [35;3mstruct[0m [94;1mAB[0m

	Cannot move: [35;3mmut[0m [94;1mv0[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========


        struct AB { a: int; b: int };

        fn main() {
            mut v0 = AB(1, 2);
            mut v1 = v0;
            ref a = v0.a;
            ref b = v1.a;
            a += 10;
            b += a;
            return b - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    AB_kiW0 v0 = AB_kiW0 { 1, {/*unused non-zst*/} };
    AB_kiW0 v1 = v0;
    int& /*v0*/ a = v0.a;
    int& /*v1*/ b = v1.a;
    a += 10;
    b += a;
    return b - 12;
}

#endif

int main() { return fu_MAIN(); }

========

        struct SolverState {
            overloads:          string[];
            eph:                int;
        };

        fn solve(ref ss: SolverState) {
            mut output = "";
            fn qID(id: string) id || "?";
            fn name(t: int) ss.overloads[t].qID;
            ref t = ss.eph;
            output = t.name();
            t = [];
            return output;
        }

        fn main() {
            mut ss = SolverState([ "hello", "world!" ], 1);
            return ss.solve.len + ss.solve.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct SolverState_ckEu;

                                #ifndef DEF_SolverState_ckEuHwjex3c
                                #define DEF_SolverState_ckEuHwjex3c
struct SolverState_ckEu
{
                                // shape_hash:    406bef3da9a8f6c8
                                // non_triv_mask: 0100c00000000000
    fu::vec<fu::str> overloads;
    int eph;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || eph
        ;
    }
};
                                #endif

                                #ifndef STR_Swx7Q1Cie01
                                #define STR_Swx7Q1Cie01
static const fu::str str_Swx7Q1Cie01 fu_INIT_PRIORITY(1001) { "?"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> qID_MbR9(/*1:1*/ fu::vec_range<char> id)
{
    return id ? id : str_Swx7Q1Cie01;
}

static fu::vec_range<char> name_MbR9(const int t, /*3:3*/ const SolverState_ckEu& ss)
{
    return qID_MbR9(ss.overloads[t]);
}

static fu::str solve_MbR9(/*1:1*/ SolverState_ckEu& ss)
{
    /*MOV*/ fu::str output = fu::str(""_fu);
    int& /*ss*/ t = ss.eph;
    output = name_MbR9(t, ss);
    t = 0;
    return /*NRVO*/ output;
}

int fu_MAIN()
{
    SolverState_ckEu ss = SolverState_ckEu { fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("world!"_fu) }}, 1 };
    int _0;
    return (_0 = solve_MbR9(ss).size(), (_0 + solve_MbR9(ss).size())) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct SolverState {
            overloads:          string[];
            eph:                int;
        };

        fn solve(ref ss: SolverState) {
            mut output = "";
            fn qID(id: string) id || "?";
            fn name(t: int) ss.overloads[t].qID;
            ref t = ss.eph;
            output = t.name();
            t = [];
            return output;
        }

        fn main() {
            mut ss = SolverState([ "hello", "world!" ], 1);
            return ss.solve.len + ss.solve.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct SolverState_ckEu;

                                #ifndef DEF_SolverState_ckEuHwjex3c
                                #define DEF_SolverState_ckEuHwjex3c
struct SolverState_ckEu
{
                                // shape_hash:    406bef3da9a8f6c8
                                // non_triv_mask: 0100c00000000000
    fu::vec<fu::str> overloads;
    int eph;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || eph
        ;
    }
};
                                #endif

                                #ifndef STR_Swx7Q1Cie01
                                #define STR_Swx7Q1Cie01
static const fu::str str_Swx7Q1Cie01 fu_INIT_PRIORITY(1001) { "?"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> qID_MbR9(/*1:1*/ fu::vec_range<char> id)
{
    return id ? id : str_Swx7Q1Cie01;
}

static fu::vec_range<char> name_MbR9(const int t, /*3:3*/ const SolverState_ckEu& ss)
{
    return qID_MbR9(ss.overloads[t]);
}

static fu::str solve_MbR9(/*1:1*/ SolverState_ckEu& ss)
{
    /*MOV*/ fu::str output {};
    int& /*ss*/ t = ss.eph;
    output = name_MbR9(t, ss);
    t = 0;
    return /*NRVO*/ output;
}

int fu_MAIN()
{
    SolverState_ckEu ss = SolverState_ckEu { fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("world!"_fu) }}, 1 };
    int _0;
    return (_0 = solve_MbR9(ss).size(), (_0 + solve_MbR9(ss).size())) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Node { handle: int; items: Node[] }
        struct Doc { raw_plaintexts: string[]; root_node?: Node }

        fn assertPathsValid_badFlatCount(ref tree: Doc) {
            fn visit(ref node: Node) {
                mut plaintext: string;
                swap(tree.raw_plaintexts[node.handle], plaintext);

                node.handle = [];
                node.items  = [];
                return plaintext;
            }

            return visit(tree.root_node);
        }

        fn main() {
            mut d = Doc(raw_plaintexts: [ "Hello!" ]);
            return d.assertPathsValid_badFlatCount.len - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>

struct Doc_0XgD;
struct Node_FlMi;

                                #ifndef DEF_Node_FlMilsK6Ix6
                                #define DEF_Node_FlMilsK6Ix6
struct Node_FlMi
{
                                // shape_hash:    fbb99e92a0a083c4
                                // non_triv_mask: 0010000000000008
    int handle;
    fu::vec<Node_FlMi> items;
    Node_FlMi(const Node_FlMi&) = default;
    Node_FlMi(Node_FlMi&&) = default;
    Node_FlMi& operator=(Node_FlMi&&) = default;
    Node_FlMi& operator=(const Node_FlMi& selfrec) { return *this = Node_FlMi(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || handle
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Doc_0XgD3gg9zDk
                                #define DEF_Doc_0XgD3gg9zDk
struct Doc_0XgD
{
                                // shape_hash:    20d4c9ea5e6b260f
                                // non_triv_mask: 4010c00000000008
    fu::vec<fu::str> raw_plaintexts;
    Node_FlMi root_node;
    explicit operator bool() const noexcept
    {
        return false
            || raw_plaintexts
            || root_node
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str visit_MbR9(/*3:3*/ Node_FlMi& node, /*3:2*/ Doc_0XgD& tree)
{
    /*MOV*/ fu::str plaintext {};
    tree.raw_plaintexts.mutref(node.handle).swap(plaintext);
    node.handle = 0;
    node.items = fu::vec<Node_FlMi>{};
    return /*NRVO*/ plaintext;
}

static fu::str assertPathsValid_badFlatCount_MbR9(/*1:1*/ Doc_0XgD& tree)
{
    return visit_MbR9(tree.root_node, tree);
}

int fu_MAIN()
{
    Doc_0XgD d = Doc_0XgD { fu::vec<fu::str> {{ fu::str("Hello!"_fu) }}, Node_FlMi{} };
    return assertPathsValid_badFlatCount_MbR9(d).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct Node { handle: int; items: Node[] }
        struct Doc { raw_plaintexts: string[]; root_node?: Node }

        fn assertPathsValid_badFlatCount(ref tree: Doc) {
            fn visit(ref node) {
                node.items.each(.visit);                        // PointlessMustSeq

                mut plaintext: string;
                swap(plaintext, tree.raw_plaintexts[node.handle]);

                node.handle = 0;
                return plaintext;
            }

            return visit(tree.root_node);
        }

        fn main() {
            mut d = Doc(raw_plaintexts: [ "Hello!" ]);
            return d.assertPathsValid_badFlatCount.len - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct Doc_0XgD;
struct Node_FlMi;
inline static fu::str visit_va3x(Node_FlMi&, Doc_0XgD&);

                                #ifndef DEF_Node_FlMilsK6Ix6
                                #define DEF_Node_FlMilsK6Ix6
struct Node_FlMi
{
                                // shape_hash:    fbb99e92a0a083c4
                                // non_triv_mask: 0010000000000008
    int handle;
    fu::vec<Node_FlMi> items;
    Node_FlMi(const Node_FlMi&) = default;
    Node_FlMi(Node_FlMi&&) = default;
    Node_FlMi& operator=(Node_FlMi&&) = default;
    Node_FlMi& operator=(const Node_FlMi& selfrec) { return *this = Node_FlMi(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || handle
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Doc_0XgD3gg9zDk
                                #define DEF_Doc_0XgD3gg9zDk
struct Doc_0XgD
{
                                // shape_hash:    20d4c9ea5e6b260f
                                // non_triv_mask: 4010c00000000008
    fu::vec<fu::str> raw_plaintexts;
    Node_FlMi root_node;
    explicit operator bool() const noexcept
    {
        return false
            || raw_plaintexts
            || root_node
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___m00xnH4Lxo2
                                #define DEF___m00xnH4Lxo2
inline static fu::str _m00x(/*3:1*/ Node_FlMi& _, /*2:2*/ Doc_0XgD& tree)
{
    return visit_va3x(_, tree);
}
                                #endif

                                #ifndef DEF_each_d4wr2mxzx20
                                #define DEF_each_d4wr2mxzx20
inline void each_d4wr(/*7:3*/ fu::view_mut<Node_FlMi> a, /*6:6*/ Doc_0XgD& tree)
{
    for (int i = 0; i < a.size(); i++)
        _m00x(a.mutref(i), tree);

}
                                #endif

                                #ifndef DEF_visit_va3xO21VULb
                                #define DEF_visit_va3xO21VULb
inline static fu::str visit_va3x(/*3:1*/ Node_FlMi& node, /*2:2*/ Doc_0XgD& tree)
{
    each_d4wr(node.items, tree);
    /*MOV*/ fu::str plaintext {};
    plaintext.swap(tree.raw_plaintexts.mutref(node.handle));
    node.handle = 0;
    return /*NRVO*/ plaintext;
}
                                #endif

static fu::str assertPathsValid_badFlatCount_MbR9(/*1:1*/ Doc_0XgD& tree)
{
    return visit_va3x(tree.root_node, tree);
}

int fu_MAIN()
{
    Doc_0XgD d = Doc_0XgD { fu::vec<fu::str> {{ fu::str("Hello!"_fu) }}, Node_FlMi{} };
    return assertPathsValid_badFlatCount_MbR9(d).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq

========

        fn hello(a: <A>, do) {
            mut ev = [ 10, 20, 30, 40, 50 ];        
            let WITH_A = !(A -> []);
            ref ev_WITH_A = WITH_A && ev;           
            ev ~= 60;
            (do(ev_WITH_A));
        }

        fn main() {
            hello(0): |ref x| {
                x ~= 70;
                return x.len - 7;
            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> ev = fu::vec<int> {{ 10, 20, 30, 40, 50 }};
    ev += 60;
    ev += 70;
    return ev.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        fn hello(a: <A>, do) {
            mut ev = [ 10, 20, 30, 40, 50 ];        
            ref ev_WITH_A = !(A -> []) && ev;       
            ev ~= 60;
            (do(ev_WITH_A));
        }

        fn main() {
            hello(0): |ref x| {
                x ~= 70;
                return x.len - 7;
            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> ev = fu::vec<int> {{ 10, 20, 30, 40, 50 }};
    ev += 60;
    ev += 70;
    return ev.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        nocopy struct Val { x: i32 };
        struct Out { v: Val };
        fn move_Val_into_Out(mut v: Val)    = Out(:v);
        fn main()                           = move_Val_into_Out(Val(0)).v.x;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Val_YHlR;
struct Out_0bsc;

                                #ifndef DEF_Val_YHlRqMQ5Jn6
                                #define DEF_Val_YHlRqMQ5Jn6
struct Val_YHlR
{
                                // shape_hash:    270474368aed75a4
                                // non_triv_mask: 0000000000004000
    int x;
    Val_YHlR(const Val_YHlR&) = delete;
    Val_YHlR(Val_YHlR&&) = default;
    Val_YHlR& operator=(const Val_YHlR&) = delete;
    Val_YHlR& operator=(Val_YHlR&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Out_0bsc8r5qqqd
                                #define DEF_Out_0bsc8r5qqqd
struct Out_0bsc
{
                                // shape_hash:    a12253baa72326c9
                                // non_triv_mask: 0000004000004000
    Val_YHlR v;
    Out_0bsc(const Out_0bsc&) = delete;
    Out_0bsc(Out_0bsc&&) = default;
    Out_0bsc& operator=(const Out_0bsc&) = delete;
    Out_0bsc& operator=(Out_0bsc&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Out_0bsc move_Val_into_Out_MbR9(/*MOV*/ Val_YHlR&& v)
{
    return Out_0bsc { static_cast<Val_YHlR&&>(v) };
}

int fu_MAIN()
{
    return move_Val_into_Out_MbR9(Val_YHlR { 0 }).v.x;
}

#endif

int main() { return fu_MAIN(); }

========

        fn must_not_move_mystr(n: i32) {
            mut mystr = "";
            for (mut i = 0; i < n; i++)
                mystr ~= "!";

            mut result: string[];
            for (mut i = 0; i < n; i++)
                result ~= mystr;

            return result.join();
        }

        fn main() = must_not_move_mystr(3).len - 9;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str must_not_move_mystr_MbR9(const int n)
{
    fu::str mystr = fu::str(""_fu);
    for (int i = 0; i < n; i++)
        mystr += "!"_view;

    fu::vec<fu::str> result {};
    for (int i_1 = 0; i_1 < n; i_1++)
        result += fu::str(mystr);

    return join_QbuI(result);
}

int fu_MAIN()
{
    return must_not_move_mystr_MbR9(3).size() - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn must_not_move_mystr(n: i32) {
            mut mystr = "";
            for (mut i = 0; i < n; i++)
                mystr ~= "!";

            mut result: string[];
            for (mut i = 0; i < n; i++)
                result ~= mystr;

            return result.join();
        }

        fn main() = must_not_move_mystr(3).len - 9;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str must_not_move_mystr_MbR9(const int n)
{
    fu::str mystr {};
    for (int i = 0; i < n; i++)
        mystr += "!"_view;

    fu::vec<fu::str> result {};
    for (int i_1 = 0; i_1 < n; i_1++)
        result += fu::str(mystr);

    return join_QbuI(result);
}

int fu_MAIN()
{
    return must_not_move_mystr_MbR9(3).size() - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_ref_and_val(ref r!: Type, mut v!: Type) {
            v.canon ~= r.canon;
            r.canon ~= v.canon;
            v.quals |= r.quals;
            return r;
        }

        fn main() {
            mut t = Type("abc", 123);
            return takes_ref_and_val(r: t, v: t).canon.len - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>

struct Type_Amej;

                                #ifndef DEF_Type_Amej1c7U605
                                #define DEF_Type_Amej1c7U605
struct Type_Amej
{
                                // shape_hash:    8668dcc37de424a3
                                // non_triv_mask: 0000800000100000
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_Amej& takes_ref_and_val_GL0m(/*1:1*/ Type_Amej& r, Type_Amej&& v)
{
    v.canon += r.canon;
    r.canon += v.canon;
    v.quals |= r.quals;
    return r;
}

int fu_MAIN()
{
    Type_Amej t = Type_Amej { fu::str("abc"_fu), 123 };
    return takes_ref_and_val_GL0m(t, Type_Amej(t)).canon.size() - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings(mut a: Type, mut b: Type) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            return a;
        }

        fn move_on_last_use_OOE(mut canon: string, quals: int) {
            canon ~= canon;
            return takes_two_strings(   // N_MoveMustSeq
                Type(:canon, :quals),
                Type(:canon, :quals));  // out of order move-into-struct will break this
        }

        fn main() {
            let res = move_on_last_use_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    1000);

            return res.canon.len + res.quals - 1192;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(816) arc_count(5) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Type_Amej;

                                #ifndef DEF_Type_Amej1c7U605
                                #define DEF_Type_Amej1c7U605
struct Type_Amej
{
                                // shape_hash:    8668dcc37de424a3
                                // non_triv_mask: 0000800000100000
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

                                #ifndef STR_IvBtwLz74Ge
                                #define STR_IvBtwLz74Ge
static const fu::str str_IvBtwLz74Ge fu_INIT_PRIORITY(1001) { "1234567890abcdef1234567890abcdef"_fu };
                                #endif

#ifndef fu_NO_fdefs

static Type_Amej takes_two_strings_MbR9(/*MOV*/ Type_Amej&& a, Type_Amej&& b)
{
    b.canon += a.canon;
    a.canon += b.canon;
    a.quals |= b.quals;
    return static_cast<Type_Amej&&>(a);
}

static Type_Amej move_on_last_use_OOE_MbR9(/*MOV*/ fu::str&& canon, const int quals)
{
    canon += fu::str(/*bck:vi 0*/ canon);
    Type_Amej _0 {};
    return (_0 = Type_Amej { fu::str(canon), quals }, takes_two_strings_MbR9(static_cast<Type_Amej&&>(_0), Type_Amej { canon.destructive_move(), quals }));
}

int fu_MAIN()
{
    Type_Amej res = move_on_last_use_OOE_MbR9(fu::str(str_IvBtwLz74Ge), 1000);
    return (res.canon.size() + res.quals) - 1192;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_MoveMustSeq

========

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings_and_an_int(mut a: Type, mut b: Type, c: int) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            a.quals += c;
            return a;
        }

        fn moves_reordered_by_bck_OOE(mut canon: string, mut quals: int) {
            canon ~= canon;
            return takes_two_strings_and_an_int(    // N_MoveMustSeq
                Type(:canon, 0),
                Type(:canon, quals++), // quals++ triggered bck MUSTSEQ
                             quals  ); //  which reordered arg b BEFORE arg a,
        }                              //   which broke move-on-last-use.

        fn main() {
            let res = moves_reordered_by_bck_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    0);

            return res.canon.len + res.quals - 193;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(816) arc_count(5) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Type_Amej;

                                #ifndef DEF_Type_Amej1c7U605
                                #define DEF_Type_Amej1c7U605
struct Type_Amej
{
                                // shape_hash:    8668dcc37de424a3
                                // non_triv_mask: 0000800000100000
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

                                #ifndef STR_IvBtwLz74Ge
                                #define STR_IvBtwLz74Ge
static const fu::str str_IvBtwLz74Ge fu_INIT_PRIORITY(1001) { "1234567890abcdef1234567890abcdef"_fu };
                                #endif

#ifndef fu_NO_fdefs

static Type_Amej takes_two_strings_and_an_int_MbR9(/*MOV*/ Type_Amej&& a, Type_Amej&& b, const int c)
{
    b.canon += a.canon;
    a.canon += b.canon;
    a.quals |= b.quals;
    a.quals += c;
    return static_cast<Type_Amej&&>(a);
}

static Type_Amej moves_reordered_by_bck_OOE_MbR9(/*MOV*/ fu::str&& canon, int quals)
{
    canon += fu::str(/*bck:vi 0*/ canon);
    Type_Amej _0 {};
    Type_Amej _1 {};
    return (_0 = Type_Amej { fu::str(canon), 0 }, _1 = Type_Amej { canon.destructive_move(), quals++ }, takes_two_strings_and_an_int_MbR9(static_cast<Type_Amej&&>(_0), static_cast<Type_Amej&&>(_1), quals));
}

int fu_MAIN()
{
    Type_Amej res = moves_reordered_by_bck_OOE_MbR9(fu::str(str_IvBtwLz74Ge), 0);
    return (res.canon.size() + res.quals) - 193;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq, N_MoveMustSeq

========

        nocopy struct NCItem { x: i32 };

        fn unshift_odds_push_evens(n: i32) {
            mut arr: NCItem[];
            for (mut i = 0; i < n; i++) {
                let item = NCItem(i);
                if (i & 1)  arr.unshift(item);                  // !*MustSeq
                else        arr.push(item);
            }
            return arr;
        }

        fn main() {
            let arr = unshift_odds_push_evens(3);
            return arr[0].x == 1
                && arr[1].x == 0
                && arr[2].x == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct NCItem_pEGH;

                                #ifndef DEF_NCItem_pEGHqNzdYV2
                                #define DEF_NCItem_pEGHqNzdYV2
struct NCItem_pEGH
{
                                // shape_hash:    9d318558cad9f222
                                // non_triv_mask: 0000002000000000
    int x;
    NCItem_pEGH(const NCItem_pEGH&) = delete;
    NCItem_pEGH(NCItem_pEGH&&) = default;
    NCItem_pEGH& operator=(const NCItem_pEGH&) = delete;
    NCItem_pEGH& operator=(NCItem_pEGH&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<NCItem_pEGH> unshift_odds_push_evens_MbR9(const int n)
{
    /*MOV*/ fu::vec<NCItem_pEGH> arr {};
    for (int i = 0; i < n; i++)
    {
        /*MOV*/ NCItem_pEGH item = NCItem_pEGH { i };
        if (i & 1)
        {
            arr.unshift(static_cast<NCItem_pEGH&&>(item));
        }
        else
            arr.push(static_cast<NCItem_pEGH&&>(item));

    };
    return /*NRVO*/ arr;
}

int fu_MAIN()
{
    fu::vec<NCItem_pEGH> arr = unshift_odds_push_evens_MbR9(3);
    if ((arr[0].x == 1) && (arr[1].x == 0) && (arr[2].x == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NCThing { x: i32 };

        fn last_used_before_break(mut nc: NCThing, N: i32) {
            mut res: NCThing;
            for (mut i = 0; i < N; i++) {
                nc.x *= 2;
                if (nc.x > 10) {
                    if (nc.x > 20) return nc;
                    res = nc; // <- should move here ...
                    break;
                }
            }


            if (nc.x > 15) return nc; // <- ... unless used here.


            res.x *= 10;
            return res;
        }

        fn main() {
            let res = last_used_before_break(NCThing(3), 10);
            return res.x - 120;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:27+2[0m:

[2m      |                 if (nc.x > 10) {[0m
[2m      |                     if (nc.x > 20) return nc;[0m
[2m   10 | [0m                    res = [31;1mnc[0m; // <- should move here ...
[2m      |                     break;[0m
[2m      |                 }[0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [94;1mnc[0m [35;3mstruct[0m [94;1mNCThing[0m

	Cannot move: [35;3mmut arg[0m [94;1mnc[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mlast_used_before_break[0m([94;1mNCThing[0m, [35;3mi32[0m) at [2m4:12+22[0m

========

        nocopy struct NCThing { x: i32 };

        fn last_used_before_break(mut nc: NCThing, N: i32) {
            mut res: NCThing;
            for (mut i = 0; i < N; i++) {
                nc.x *= 2;
                if (nc.x > 10) {
                    if (nc.x > 20) return nc;
                    res = nc; // <- should move here ...
                    break;
                }
            }



            res.x *= 10;
            return res;
        }

        fn main() {
            let res = last_used_before_break(NCThing(3), 10);
            return res.x - 120;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NCThing_j1Ax;

                                #ifndef DEF_NCThing_j1AxmPcfCX0
                                #define DEF_NCThing_j1AxmPcfCX0
struct NCThing_j1Ax
{
                                // shape_hash:    95120e2c05d233b0
                                // non_triv_mask: 0000002000000000
    int x;
    NCThing_j1Ax(const NCThing_j1Ax&) = delete;
    NCThing_j1Ax(NCThing_j1Ax&&) = default;
    NCThing_j1Ax& operator=(const NCThing_j1Ax&) = delete;
    NCThing_j1Ax& operator=(NCThing_j1Ax&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NCThing_j1Ax last_used_before_break_MbR9(/*MOV*/ NCThing_j1Ax&& nc, const int N)
{
    /*MOV*/ NCThing_j1Ax res {};
    for (int i = 0; i < N; i++)
    {
        nc.x *= 2;
        if (nc.x > 10)
        {
            if (nc.x > 20)
                return static_cast<NCThing_j1Ax&&>(nc);
            else
            {
                res = static_cast<NCThing_j1Ax&&>(nc);
                break;
            };
        };
    };
    res.x *= 10;
    return /*NRVO*/ res;
}

int fu_MAIN()
{
    NCThing_j1Ax res = last_used_before_break_MbR9(NCThing_j1Ax { 3 }, 10);
    return res.x - 120;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NCThing { str: string };

        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {
            defer other = nc; // last use, move here!
            while (nc.str.len < 64)
                nc.str ~= nc.str;


            return nc;                     
        }

        fn main() {
            mut other: NCThing;
            last_used_in_defer(NCThing("Hello!"), other);
            return other.str.len - 96;
        }

---- <fail> ----
[2m[0m_0[2m.fu 10:20+2[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            return [31;1mnc[0m;                     
[2m      |         }[0m
[2m      | [0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mmut[0m [35;3mref[0m [94;1mnc[0m [35;3mstruct[0m [94;1mNCThing[0m

	Cannot move: [35;3mmut arg[0m [94;1mnc[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mlast_used_in_defer[0m([94;1mNCThing[0m, [94;1mNCThing[0m) at [2m4:12+18[0m

========

        nocopy struct NCThing { str: string };

        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {
            defer other = nc; // last use, move here!
            while (nc.str.len < 64)
                nc.str ~= nc.str;


            return nc.str.len;             
        }

        fn main() {
            mut other: NCThing;
            last_used_in_defer(NCThing("Hello!"), other);
            return other.str.len - 96;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/defer.h>
#include <fu/vec/concat.h>

struct NCThing_v71f;

                                #ifndef DEF_NCThing_v71fjg45tOj
                                #define DEF_NCThing_v71fjg45tOj
struct NCThing_v71f
{
                                // shape_hash:    d08b3a968ae39c6e
                                // non_triv_mask: 0002800000000000
    fu::str str;
    NCThing_v71f(const NCThing_v71f&) = delete;
    NCThing_v71f(NCThing_v71f&&) = default;
    NCThing_v71f& operator=(const NCThing_v71f&) = delete;
    NCThing_v71f& operator=(NCThing_v71f&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int last_used_in_defer_MbR9(/*MOV*/ NCThing_v71f&& nc, /*3:3*/ NCThing_v71f& other)
{
    fu_DEFER(other = static_cast<NCThing_v71f&&>(nc));
    while (nc.str.size() < 64)
        nc.str += fu::str(/*bck:vi 0*/ nc.str);

    return nc.str.size();
}

int fu_MAIN()
{
    NCThing_v71f other {};
    last_used_in_defer_MbR9(NCThing_v71f { fu::str("Hello!"_fu) }, other);
    return other.str.size() - 96;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        nocopy struct Node { nodes: Node[]; }

        noinline fn add(a: i32, b: i32) {
            return a + b;
        }

        fn main() {
            mut res = Node([ Node ]);
            mut cpy: Node;

            mut res_len = 0;
            mut cpy_len = 0;                                    // N_MoveMustSeq

            mut sum = add(res_len = res.nodes.len, cpy_len = (cpy = res).nodes.len); 

            return cpy.nodes.len == cpy_len
                && res_len == 1
                && cpy_len == 1
                && sum == 2             ? 0 : 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Node_DjxN;

                                #ifndef DEF_Node_DjxNXRoJmS1
                                #define DEF_Node_DjxNXRoJmS1
struct Node_DjxN
{
                                // shape_hash:    d4c39a2aa877cd51
                                // non_triv_mask: 0002000000000200
    fu::vec<Node_DjxN> nodes;
    Node_DjxN(const Node_DjxN&) = delete;
    Node_DjxN(Node_DjxN&&) = default;
    Node_DjxN& operator=(const Node_DjxN&) = delete;
    Node_DjxN& operator=(Node_DjxN&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int add_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    /*MOV*/ Node_DjxN res = Node_DjxN { fu::vec<Node_DjxN> {{ Node_DjxN{} }} };
    Node_DjxN cpy {};
    int res_len = 0;
    int cpy_len = 0;
    int _0;
    const int sum = (_0 = (res_len = res.nodes.size()), add_MbR9(_0, (cpy_len = (cpy = static_cast<Node_DjxN&&>(res)).nodes.size())));
    if ((cpy.nodes.size() == cpy_len) && (res_len == 1) && (cpy_len == 1) && (sum == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_MoveMustSeq

========

        nocopy struct Node { nodes: Node[]; }

        noinline fn add(a: i32, b: i32) {
            return a + b;
        }

        fn main() {
            mut res = Node([ Node ]);
            mut cpy: Node;

            mut res_len = 0;
            mut cpy_len = 0;                                    // N_MoveMustSeq

            mut sum = (res_len = res.nodes.len) + (cpy_len = (cpy = res).nodes.len); 

            return cpy.nodes.len == cpy_len
                && res_len == 1
                && cpy_len == 1
                && sum == 2             ? 0 : 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Node_DjxN;

                                #ifndef DEF_Node_DjxNXRoJmS1
                                #define DEF_Node_DjxNXRoJmS1
struct Node_DjxN
{
                                // shape_hash:    d4c39a2aa877cd51
                                // non_triv_mask: 0002000000000200
    fu::vec<Node_DjxN> nodes;
    Node_DjxN(const Node_DjxN&) = delete;
    Node_DjxN(Node_DjxN&&) = default;
    Node_DjxN& operator=(const Node_DjxN&) = delete;
    Node_DjxN& operator=(Node_DjxN&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    /*MOV*/ Node_DjxN res = Node_DjxN { fu::vec<Node_DjxN> {{ Node_DjxN{} }} };
    Node_DjxN cpy {};
    int res_len = 0;
    int cpy_len = 0;
    int _0;
    const int sum = (_0 = (res_len = res.nodes.size()), (_0 + (cpy_len = (cpy = static_cast<Node_DjxN&&>(res)).nodes.size())));
    if ((cpy.nodes.size() == cpy_len) && (res_len == 1) && (cpy_len == 1) && (sum == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_MoveMustSeq

========

        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);


        fn main() {
            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);
            let local = intoLocal(foreign);
            return local.name.ncs.len - 2;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Foreign_fgpc;
struct NC_A5g5;
struct Local_DL8f;

                                #ifndef DEF_NC_A5g5gMr7Tdj
                                #define DEF_NC_A5g5gMr7Tdj
struct NC_A5g5
{
                                // shape_hash:    2b703dff8bcf9efd
                                // non_triv_mask: 0000000000004002
    fu::vec<NC_A5g5> ncs;
    NC_A5g5(const NC_A5g5&) = delete;
    NC_A5g5(NC_A5g5&&) = default;
    NC_A5g5& operator=(const NC_A5g5&) = delete;
    NC_A5g5& operator=(NC_A5g5&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_Foreign_fgpcrdkKP87
                                #define DEF_Foreign_fgpcrdkKP87
struct Foreign_fgpc
{
                                // shape_hash:    30851c4d77b61335
                                // non_triv_mask: 8000000000004002
    NC_A5g5 name;
    int kind;
    int flags;
    Foreign_fgpc(const Foreign_fgpc&) = delete;
    Foreign_fgpc(Foreign_fgpc&&) = default;
    Foreign_fgpc& operator=(const Foreign_fgpc&) = delete;
    Foreign_fgpc& operator=(Foreign_fgpc&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_Local_DL8f9rwBXy6
                                #define DEF_Local_DL8f9rwBXy6
struct Local_DL8f
{
                                // shape_hash:    1e51b7a7337247c4
                                // non_triv_mask: 0000000020004002
    int kind;
    int flags;
    NC_A5g5 name;
    Local_DL8f(const Local_DL8f&) = delete;
    Local_DL8f(Local_DL8f&&) = default;
    Local_DL8f& operator=(const Local_DL8f&) = delete;
    Local_DL8f& operator=(Local_DL8f&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Local_DL8f intoLocal_MbR9(/*MOV*/ Foreign_fgpc&& f)
{
    return Local_DL8f { f.kind, f.flags, static_cast<NC_A5g5&&>(f.name) };
}

int fu_MAIN()
{
    /*MOV*/ Foreign_fgpc foreign = Foreign_fgpc { NC_A5g5 { fu::vec<NC_A5g5> {{ NC_A5g5{}, NC_A5g5{} }} }, 0, 0 };
    Local_DL8f local = intoLocal_MbR9(static_cast<Foreign_fgpc&&>(foreign));
    return local.name.ncs.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);

        pub import _0;
        fn main() {
            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);
            let local = intoLocal(foreign);
            return local.name.ncs.len - 2;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Foreign_fgpc;
struct NC_A5g5;
struct Local_DL8f;
Local_DL8f intoLocal_MbR9(Foreign_fgpc&&);

                                #ifndef DEF_NC_A5g5gMr7Tdj
                                #define DEF_NC_A5g5gMr7Tdj
struct NC_A5g5
{
                                // shape_hash:    2b703dff8bcf9efd
                                // non_triv_mask: 0000000000004002
    fu::vec<NC_A5g5> ncs;
    NC_A5g5(const NC_A5g5&) = delete;
    NC_A5g5(NC_A5g5&&) = default;
    NC_A5g5& operator=(const NC_A5g5&) = delete;
    NC_A5g5& operator=(NC_A5g5&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_Foreign_fgpcrdkKP87
                                #define DEF_Foreign_fgpcrdkKP87
struct Foreign_fgpc
{
                                // shape_hash:    30851c4d77b61335
                                // non_triv_mask: 8000000000004002
    NC_A5g5 name;
    int kind;
    int flags;
    Foreign_fgpc(const Foreign_fgpc&) = delete;
    Foreign_fgpc(Foreign_fgpc&&) = default;
    Foreign_fgpc& operator=(const Foreign_fgpc&) = delete;
    Foreign_fgpc& operator=(Foreign_fgpc&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_Local_DL8f9rwBXy6
                                #define DEF_Local_DL8f9rwBXy6
struct Local_DL8f
{
                                // shape_hash:    1e51b7a7337247c4
                                // non_triv_mask: 0000000020004002
    int kind;
    int flags;
    NC_A5g5 name;
    Local_DL8f(const Local_DL8f&) = delete;
    Local_DL8f(Local_DL8f&&) = default;
    Local_DL8f& operator=(const Local_DL8f&) = delete;
    Local_DL8f& operator=(Local_DL8f&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    /*MOV*/ Foreign_fgpc foreign = Foreign_fgpc { NC_A5g5 { fu::vec<NC_A5g5> {{ NC_A5g5{}, NC_A5g5{} }} }, 0, 0 };
    Local_DL8f local = intoLocal_MbR9(static_cast<Foreign_fgpc&&>(foreign));
    return local.name.ncs.size() - 2;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>

struct Local_DL8f;
struct NC_A5g5;
struct Foreign_fgpc;

                                #ifndef DEF_NC_A5g5gMr7Tdj
                                #define DEF_NC_A5g5gMr7Tdj
struct NC_A5g5
{
                                // shape_hash:    2b703dff8bcf9efd
                                // non_triv_mask: 0000000000004002
    fu::vec<NC_A5g5> ncs;
    NC_A5g5(const NC_A5g5&) = delete;
    NC_A5g5(NC_A5g5&&) = default;
    NC_A5g5& operator=(const NC_A5g5&) = delete;
    NC_A5g5& operator=(NC_A5g5&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_Local_DL8f9rwBXy6
                                #define DEF_Local_DL8f9rwBXy6
struct Local_DL8f
{
                                // shape_hash:    1e51b7a7337247c4
                                // non_triv_mask: 0000000020004002
    int kind;
    int flags;
    NC_A5g5 name;
    Local_DL8f(const Local_DL8f&) = delete;
    Local_DL8f(Local_DL8f&&) = default;
    Local_DL8f& operator=(const Local_DL8f&) = delete;
    Local_DL8f& operator=(Local_DL8f&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Foreign_fgpcrdkKP87
                                #define DEF_Foreign_fgpcrdkKP87
struct Foreign_fgpc
{
                                // shape_hash:    30851c4d77b61335
                                // non_triv_mask: 8000000000004002
    NC_A5g5 name;
    int kind;
    int flags;
    Foreign_fgpc(const Foreign_fgpc&) = delete;
    Foreign_fgpc(Foreign_fgpc&&) = default;
    Foreign_fgpc& operator=(const Foreign_fgpc&) = delete;
    Foreign_fgpc& operator=(Foreign_fgpc&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Local_DL8f intoLocal_MbR9(/*MOV*/ Foreign_fgpc&& f)
{
    return Local_DL8f { f.kind, f.flags, static_cast<NC_A5g5&&>(f.name) };
}

#endif

// N_TypeRecursion, N_TypeResolve

========

        struct A { items: i32[] };
        struct B { items: i32[] };


        fn takesRef_OOE(b: B, ref a: A) 
            a.items ~= b.items;

        struct C { items: i32[] };

        fn C2B(mut c: C) B(c.items);

        fn selectA(mut c: C, ref a0: A, ref a1: A) {
            ref a   = c.items.len & 1 ? a0 : a1;
            a.items = c.items;
            return a;
        }

        fn main() {
            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);
            mut a0: A;
            mut a1: A;

            takesRef_OOE(                                       // N_MoveMustSeq
                a: selectA(:c, :a0, :a1),
                b: C2B(:c));

            return a0.items.len - 14;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct C_St6T;
struct A_SnBh;
struct B_tIxm;

                                #ifndef DEF_C_St6TAN8fSca
                                #define DEF_C_St6TAN8fSca
struct C_St6T
{
                                // shape_hash:    c35666780f915e67
                                // non_triv_mask: 0008000000000001
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_A_SnBh6AjAdKe
                                #define DEF_A_SnBh6AjAdKe
struct A_SnBh
{
                                // shape_hash:    47b2d73b436efbba
                                // non_triv_mask: 0008000000000100
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_B_tIxmn3xFbp9
                                #define DEF_B_tIxmn3xFbp9
struct B_tIxm
{
                                // shape_hash:    961f5ed1c008f8d6
                                // non_triv_mask: 0008000000200000
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_tIxm C2B_MbR9(/*MOV*/ C_St6T&& c)
{
    return B_tIxm { static_cast<fu::vec<int>&&>(c.items) };
}

static A_SnBh& selectA_MbR9(/*MOV*/ C_St6T&& c, /*7:7*/ A_SnBh& a0, /*7:7*/ A_SnBh& a1)
{
    A_SnBh& /*a0|a1*/ a = ((c.items.size() & 1) ? a0 : a1);
    a.items = static_cast<fu::vec<int>&&>(c.items);
    return a;
}

static fu::view<int> takesRef_OOE_GL0m(/*3:3*/ const B_tIxm& b, /*2:2*/ A_SnBh& a)
{
    return (a.items += b.items);
}

int fu_MAIN()
{
    /*MOV*/ C_St6T c = C_St6T { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7 }} };
    A_SnBh a0 {};
    A_SnBh a1 {};
    B_tIxm _0 {};
    (_0 = C2B_MbR9(C_St6T(c)), takesRef_OOE_GL0m(static_cast<B_tIxm&&>(_0), selectA_MbR9(static_cast<C_St6T&&>(c), a0, a1)));
    return a0.items.size() - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_MoveMustSeq

========

        struct A { items: i32[] };
        struct B { items: i32[] };


        fn takesRef_OOE(ref a: A, b: B) 
            a.items ~= b.items;

        struct C { items: i32[] };

        fn C2B(mut c: C) B(c.items);

        fn selectA(mut c: C, ref a0: A, ref a1: A) {
            ref a   = c.items.len & 1 ? a0 : a1;
            a.items = c.items;
            return a;
        }

        fn main() {
            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);
            mut a0: A;
            mut a1: A;

            takesRef_OOE(                                       // N_MoveMustSeq
                a: selectA(:c, :a0, :a1),
                b: C2B(:c));

            return a0.items.len - 14;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct C_St6T;
struct A_SnBh;
struct B_tIxm;

                                #ifndef DEF_C_St6TAN8fSca
                                #define DEF_C_St6TAN8fSca
struct C_St6T
{
                                // shape_hash:    c35666780f915e67
                                // non_triv_mask: 0008000000000001
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_A_SnBh6AjAdKe
                                #define DEF_A_SnBh6AjAdKe
struct A_SnBh
{
                                // shape_hash:    47b2d73b436efbba
                                // non_triv_mask: 0008000000000100
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_B_tIxmn3xFbp9
                                #define DEF_B_tIxmn3xFbp9
struct B_tIxm
{
                                // shape_hash:    961f5ed1c008f8d6
                                // non_triv_mask: 0008000000200000
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_tIxm C2B_MbR9(/*MOV*/ C_St6T&& c)
{
    return B_tIxm { static_cast<fu::vec<int>&&>(c.items) };
}

static A_SnBh& selectA_MbR9(/*MOV*/ C_St6T&& c, /*7:7*/ A_SnBh& a0, /*7:7*/ A_SnBh& a1)
{
    A_SnBh& /*a0|a1*/ a = ((c.items.size() & 1) ? a0 : a1);
    a.items = static_cast<fu::vec<int>&&>(c.items);
    return a;
}

static fu::view<int> takesRef_OOE_GL0m(/*1:1*/ A_SnBh& a, /*3:3*/ const B_tIxm& b)
{
    return (a.items += b.items);
}

int fu_MAIN()
{
    /*MOV*/ C_St6T c = C_St6T { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7 }} };
    A_SnBh a0 {};
    A_SnBh a1 {};
    B_tIxm _0 {};
    (_0 = C2B_MbR9(C_St6T(c)), takesRef_OOE_GL0m(selectA_MbR9(static_cast<C_St6T&&>(c), a0, a1), static_cast<B_tIxm&&>(_0)));
    return a0.items.size() - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_MoveMustSeq

========

        nocopy struct NoCopy { a: i32[]; b: i32[] };

        noinline fn mustRelaxMut(mut nc: NoCopy)
            nc.a.len - nc.b.len;

        fn main() {
            mut x = NoCopy([ 0 ], [ 0, 1 ]);
            mut y = NoCopy([ 0, 1, 2, 3 ], [ 0, 1, 2 ]);
            for (mut i = 0; i < 10; i++) {
                if (mustRelaxMut(x) + mustRelaxMut(y))
                    return 1;

                x.a.push(x.a.len);
                y.b.push(y.b.len);
            }

            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>

struct NoCopy_OWaJ;

                                #ifndef DEF_NoCopy_OWaJM9SV6J9
                                #define DEF_NoCopy_OWaJM9SV6J9
struct NoCopy_OWaJ
{
                                // shape_hash:    ed05f7168a1bd417
                                // non_triv_mask: 0008000400000000
    fu::vec<int> a;
    fu::vec<int> b;
    NoCopy_OWaJ(const NoCopy_OWaJ&) = delete;
    NoCopy_OWaJ(NoCopy_OWaJ&&) = default;
    NoCopy_OWaJ& operator=(const NoCopy_OWaJ&) = delete;
    NoCopy_OWaJ& operator=(NoCopy_OWaJ&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int mustRelaxMut_MbR9(/*1:1*/ const NoCopy_OWaJ& nc)
{
    return nc.a.size() - nc.b.size();
}

int fu_MAIN()
{
    NoCopy_OWaJ x = NoCopy_OWaJ { fu::vec<int> {{ 0 }}, fu::vec<int> {{ 0, 1 }} };
    NoCopy_OWaJ y = NoCopy_OWaJ { fu::vec<int> {{ 0, 1, 2, 3 }}, fu::vec<int> {{ 0, 1, 2 }} };
    for (int i = 0; i < 10; i++)
    {
        if (mustRelaxMut_MbR9(x) + mustRelaxMut_MbR9(y))
            return 1;
        else
        {
            x.a.push(x.a.size());
            y.b.push(y.b.size());
        };
    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NonTriv { items: NonTriv[] }

        fn moveViaHoisted(    a: NonTriv,     b: NonTriv) { // ConstCast    
            if (ref either = a || b) return either;
            return [];
        }

        fn main() {
            mut b = moveViaHoisted(NonTriv(), NonTriv([ NonTriv() ]));
            mut a: NonTriv;
            swap(b, a);
            return a.items.len - 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <utility>
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NonTriv_UeFU& moveViaHoisted_MbR9(/*3:3*/ const NonTriv_UeFU& a, /*3:3*/ const NonTriv_UeFU& b)
{
    const NonTriv_UeFU* either;
    if ((*(either = &((a ? a : b)))))
        return (*either);
    else
        return (*(NonTriv_UeFU*)fu::NIL);

}

int fu_MAIN()
{
    NonTriv_UeFU b = fu::move_or_default(const_cast<NonTriv_UeFU&>(moveViaHoisted_MbR9(NonTriv_UeFU{}, NonTriv_UeFU { fu::vec<NonTriv_UeFU> {{ NonTriv_UeFU{} }} })));
    NonTriv_UeFU a {};
    std::swap(b, a);
    return a.items.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        nocopy struct NonTriv { items: NonTriv[] }

        fn moveViaHoisted(ref a: NonTriv, ref b: NonTriv) { // ConstCast    
            if (ref either = a || b) return either;
            return [];
        }

        fn main() {
            mut b = moveViaHoisted(NonTriv(), NonTriv([ NonTriv() ]));
            mut a: NonTriv;
            swap(b, a);
            return a.items.len - 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <utility>
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NonTriv_UeFU& moveViaHoisted_MbR9(/*3:3*/ const NonTriv_UeFU& a, /*3:3*/ const NonTriv_UeFU& b)
{
    const NonTriv_UeFU* either;
    if ((*(either = &((a ? a : b)))))
        return (*either);
    else
        return (*(NonTriv_UeFU*)fu::NIL);

}

int fu_MAIN()
{
    NonTriv_UeFU b = fu::move_or_default(const_cast<NonTriv_UeFU&>(moveViaHoisted_MbR9(NonTriv_UeFU{}, NonTriv_UeFU { fu::vec<NonTriv_UeFU> {{ NonTriv_UeFU{} }} })));
    NonTriv_UeFU a {};
    std::swap(b, a);
    return a.items.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        nocopy struct NonTriv { items: NonTriv[] }

        fn moveViaHoisted(val a: NonTriv, val b: NonTriv) { // ConstCast    
            if (ref either = a || b) return either;
            return [];
        }

        fn main() {
            mut b = moveViaHoisted(NonTriv(), NonTriv([ NonTriv() ]));
            mut a: NonTriv;
            swap(b, a);
            return a.items.len - 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <utility>
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NonTriv_UeFU& moveViaHoisted_MbR9(/*3:3*/ const NonTriv_UeFU& a, /*3:3*/ const NonTriv_UeFU& b)
{
    const NonTriv_UeFU* either;
    if ((*(either = &((a ? a : b)))))
        return (*either);
    else
        return (*(NonTriv_UeFU*)fu::NIL);

}

int fu_MAIN()
{
    NonTriv_UeFU b = fu::move_or_default(const_cast<NonTriv_UeFU&>(moveViaHoisted_MbR9(NonTriv_UeFU{}, NonTriv_UeFU { fu::vec<NonTriv_UeFU> {{ NonTriv_UeFU{} }} })));
    NonTriv_UeFU a {};
    std::swap(b, a);
    return a.items.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        nocopy struct NonTriv { items: NonTriv[] }

        fn moveViaHoisted(mut a: NonTriv, mut b: NonTriv) {                 
            if (ref either = a || b) return either;
            return [];
        }

        fn main() {
            mut b = moveViaHoisted(NonTriv(), NonTriv([ NonTriv() ]));
            mut a: NonTriv;
            swap(b, a);
            return a.items.len - 1;
        }

---- [ status(0) uniq_bytes(128) uniq_count(1) arc_bytes(0) arc_count(0) ] ----
#include <utility>
#include <fu/vec.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU&) = delete;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NonTriv_UeFU moveViaHoisted_MbR9(/*MOV*/ NonTriv_UeFU&& a, /*MOV*/ NonTriv_UeFU&& b)
{
    NonTriv_UeFU* either;
    if ((*(either = &((a ? a : b)))))
        return static_cast<NonTriv_UeFU&&>((*either));
    else
    {
        return NonTriv_UeFU{};
    };
}

int fu_MAIN()
{
    NonTriv_UeFU b = moveViaHoisted_MbR9(NonTriv_UeFU{}, NonTriv_UeFU { fu::vec<NonTriv_UeFU> {{ NonTriv_UeFU{} }} });
    NonTriv_UeFU a {};
    std::swap(b, a);
    return a.items.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========


        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    /*MOV*/ fu::vec_range<NonTriv_DCKg> /*a|zeroes*/ c = ((which & 1) ? a : fu::vec_range<NonTriv_DCKg>{});
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, c, which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    /*MOV*/ fu::vec<NonTriv_DCKg>& /*a|zeroes*/ c = ((which & 1) ? a : (*(fu::vec<NonTriv_DCKg>*)fu::NIL));
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, c, which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            mut b = test(a, [], which);                         // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, (*(fu::vec<NonTriv_DCKg>*)fu::NIL), which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        nocopy 
        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(384) uniq_count(3) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    /*MOV*/ fu::vec_range<NonTriv_DCKg> /*a|zeroes*/ c = ((which & 1) ? a : fu::vec_range<NonTriv_DCKg>{});
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, c, which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        nocopy 
        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(384) uniq_count(3) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    /*MOV*/ fu::vec<NonTriv_DCKg>& /*a|zeroes*/ c = ((which & 1) ? a : (*(fu::vec<NonTriv_DCKg>*)fu::NIL));
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, c, which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        nocopy 
        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv[], b: NonTriv[], which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv[]) while !(a.len & 1) a ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = [ NonTriv(), NonTriv() ];

            mut b = test(a, [], which);                         // ConstCast

            b.balance();
            return (b.len + 1) & 1;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(384) uniq_count(3) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct NonTriv_DCKg;
fu::vec_range<NonTriv_DCKg> test_MbR9(fu::vec_range<NonTriv_DCKg>, fu::vec_range<NonTriv_DCKg>, int);
void balance_MbR9(fu::vec_range_mut<NonTriv_DCKg>);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ fu::vec<NonTriv_DCKg> a = fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }};
    fu::vec<NonTriv_DCKg> b = test_MbR9(a, (*(fu::vec<NonTriv_DCKg>*)fu::NIL), which).const_cast_mut().destructive_move_or_default();
    balance_MbR9(b);
    return (b.size() + 1) & 1;
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range<NonTriv_DCKg> test_MbR9(/*7:7*/ fu::vec_range<NonTriv_DCKg> a, /*7:7*/ fu::vec_range<NonTriv_DCKg> b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ fu::vec_range_mut<NonTriv_DCKg> a)
{
    while (!(a.size() & 1))
    {
        a += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv, b: NonTriv, which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv) while (a.b.len < a.a.len) a.b ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = NonTriv([ NonTriv(), NonTriv() ], [ NonTriv() ]);

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return b.a.len - b.b.len;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_DCKg;
const NonTriv_DCKg& test_MbR9(const NonTriv_DCKg&, const NonTriv_DCKg&, int);
void balance_MbR9(NonTriv_DCKg&);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ NonTriv_DCKg a = NonTriv_DCKg { fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }}, fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{} }} };
    /*MOV*/ NonTriv_DCKg& /*a|zeroes*/ c = ((which & 1) ? a : (*(NonTriv_DCKg*)fu::NIL));
    NonTriv_DCKg b = fu::move_or_default(const_cast<NonTriv_DCKg&>(test_MbR9(a, c, which)));
    balance_MbR9(b);
    return b.a.size() - b.b.size();
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const NonTriv_DCKg& test_MbR9(/*7:7*/ const NonTriv_DCKg& a, /*7:7*/ const NonTriv_DCKg& b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ NonTriv_DCKg& a)
{
    while (a.b.size() < a.a.size())
    {
        a.b += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv, b: NonTriv, which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv) while (a.b.len < a.a.len) a.b ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = NonTriv([ NonTriv(), NonTriv() ], [ NonTriv() ]);

            mut b = test(a, [], which);                         // ConstCast

            b.balance();
            return b.a.len - b.b.len;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_DCKg;
const NonTriv_DCKg& test_MbR9(const NonTriv_DCKg&, const NonTriv_DCKg&, int);
void balance_MbR9(NonTriv_DCKg&);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ NonTriv_DCKg a = NonTriv_DCKg { fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }}, fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{} }} };
    NonTriv_DCKg b = fu::move_or_default(const_cast<NonTriv_DCKg&>(test_MbR9(a, (*(NonTriv_DCKg*)fu::NIL), which)));
    balance_MbR9(b);
    return b.a.size() - b.b.size();
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = default;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg& selfrec) { return *this = NonTriv_DCKg(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const NonTriv_DCKg& test_MbR9(/*7:7*/ const NonTriv_DCKg& a, /*7:7*/ const NonTriv_DCKg& b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ NonTriv_DCKg& a)
{
    while (a.b.size() < a.a.size())
    {
        a.b += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        nocopy 
        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv, b: NonTriv, which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv) while (a.b.len < a.a.len) a.b ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = NonTriv([ NonTriv(), NonTriv() ], [ NonTriv() ]);

            ref c = which & 1 ? a : [];
            mut b = test(a, c, which);                          // ConstCast

            b.balance();
            return b.a.len - b.b.len;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_DCKg;
const NonTriv_DCKg& test_MbR9(const NonTriv_DCKg&, const NonTriv_DCKg&, int);
void balance_MbR9(NonTriv_DCKg&);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ NonTriv_DCKg a = NonTriv_DCKg { fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }}, fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{} }} };
    /*MOV*/ NonTriv_DCKg& /*a|zeroes*/ c = ((which & 1) ? a : (*(NonTriv_DCKg*)fu::NIL));
    NonTriv_DCKg b = fu::move_or_default(const_cast<NonTriv_DCKg&>(test_MbR9(a, c, which)));
    balance_MbR9(b);
    return b.a.size() - b.b.size();
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const NonTriv_DCKg& test_MbR9(/*7:7*/ const NonTriv_DCKg& a, /*7:7*/ const NonTriv_DCKg& b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ NonTriv_DCKg& a)
{
    while (a.b.size() < a.a.size())
    {
        a.b += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========


        nocopy 
        struct NonTriv { a: NonTriv[]; b: NonTriv[] }

        noinline fn test(a: NonTriv, b: NonTriv, which: int) which & 1 ? a : b;
        noinline fn balance(ref a: NonTriv) while (a.b.len < a.a.len) a.b ~= NonTriv();

        import _0;
        fn moveOrDefault(which: int) {
            mut a = NonTriv([ NonTriv(), NonTriv() ], [ NonTriv() ]);

            mut b = test(a, [], which);                         // ConstCast

            b.balance();
            return b.a.len - b.b.len;
        }
        fn main() moveOrDefault(0) * 10 + moveOrDefault(1) * 100;

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/move_or_default.h>

struct NonTriv_DCKg;
const NonTriv_DCKg& test_MbR9(const NonTriv_DCKg&, const NonTriv_DCKg&, int);
void balance_MbR9(NonTriv_DCKg&);

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int moveOrDefault_LtD7(const int which)
{
    /*MOV*/ NonTriv_DCKg a = NonTriv_DCKg { fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{}, NonTriv_DCKg{} }}, fu::vec<NonTriv_DCKg> {{ NonTriv_DCKg{} }} };
    NonTriv_DCKg b = fu::move_or_default(const_cast<NonTriv_DCKg&>(test_MbR9(a, (*(NonTriv_DCKg*)fu::NIL), which)));
    balance_MbR9(b);
    return b.a.size() - b.b.size();
}

int fu_MAIN()
{
    return (moveOrDefault_LtD7(0) * 10) + (moveOrDefault_LtD7(1) * 100);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct NonTriv_DCKg;

                                #ifndef DEF_NonTriv_DCKgR1QryNe
                                #define DEF_NonTriv_DCKgR1QryNe
struct NonTriv_DCKg
{
                                // shape_hash:    3422c81b1fc506ca
                                // non_triv_mask: 8800000000000000
    fu::vec<NonTriv_DCKg> a;
    fu::vec<NonTriv_DCKg> b;
    NonTriv_DCKg(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg(NonTriv_DCKg&&) = default;
    NonTriv_DCKg& operator=(const NonTriv_DCKg&) = delete;
    NonTriv_DCKg& operator=(NonTriv_DCKg&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const NonTriv_DCKg& test_MbR9(/*7:7*/ const NonTriv_DCKg& a, /*7:7*/ const NonTriv_DCKg& b, const int which)
{
    if (which & 1)
        return a;
    else
        return b;

}

void balance_MbR9(/*1:1*/ NonTriv_DCKg& a)
{
    while (a.b.size() < a.a.size())
    {
        a.b += NonTriv_DCKg{};
    };
}

#endif

// N_TypeRecursion, N_TypeResolve

========

        fn E(modid: int) {
            try {
                modid && throw(modid & 1 && "A" ~ modid);
                return [];
            }
            catch (e) {
                return e || "B" ~ modid;
            }
        }

        fn main() {
            let e = E(0) ~ E(1) ~ E(2);
            return e == "A1B2" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str E_MbR9(const int modid)
{

    try
    {
    {
        if (modid)
        {
            fu::fail(((modid & 1) ? x7E_rA00("A"_view, fu::i64dec(modid)) : fu::str{}));
        }
        else
        {
            return fu::str{};
        };
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e ? static_cast<fu::str&&>(e) : x7E_rA00("B"_view, fu::i64dec(modid));
    }
;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str e = ((E_MbR9(0) + E_MbR9(1)) + E_MbR9(2));
    if (e == "A1B2"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items[]:       string[..]                       
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

int opaque_concat_MbR9(fu::view<fu::str>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return opaque_concat_MbR9(fu::view<fu::str> {{ fu::str(""_fu), fu::str{} }});
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items[]:       string[..]                       
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

int opaque_concat_MbR9(fu::view<fu::str>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return opaque_concat_MbR9(fu::view<fu::str> {{ fu::str{}, fu::str{} }});
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items.noinl[]: string[..]   // ConstCast        
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

fu::vec_range<char> noinl_MbR9(fu::vec_range<char>);
int opaque_concat_MbR9(fu::view<fu::str>);

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1002) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return opaque_concat_MbR9(fu::view<fu::str> {{ fu::str(noinl_MbR9(str_00000000000)), noinl_MbR9((*(fu::str*)fu::NIL)).const_cast_mut().destructive_move_or_default() }});
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items.noinl[]: string[..]   // ConstCast        
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>

fu::vec_range<char> noinl_MbR9(fu::vec_range<char>);
int opaque_concat_MbR9(fu::view<fu::str>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return opaque_concat_MbR9(fu::view<fu::str> {{ noinl_MbR9((*(fu::str*)fu::NIL)).const_cast_mut().destructive_move_or_default(), noinl_MbR9((*(fu::str*)fu::NIL)).const_cast_mut().destructive_move_or_default() }});
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items.inl[]:   string[..]   // ConstCast
                                        // PointlessLocal   
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

int opaque_concat_MbR9(fu::view<fu::str>);

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1002) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec_range<char> x {};
    fu::str* x_1;
    return opaque_concat_MbR9(fu::view<fu::str> {{ fu::str((x.ptr_reassign(str_00000000000), x)), (x_1 = &((*(fu::str*)fu::NIL)), (*x_1)).const_cast_mut().destructive_move_or_default() }});
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        inline   fn inl  (x: string) x;
        noinline fn noinl(x: string) x;

        noinline fn opaque_concat(                          
            items.inl[]:   string[..]   // ConstCast
                                        // PointlessLocal   
        ) {
            mut sum = 0;
            for (mut i = 0; i < items.len; i++) sum += items[i].len;
            return sum;
        }

        import _0;
        fn main() opaque_concat("", []);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>

int opaque_concat_MbR9(fu::view<fu::str>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str* x;
    fu::str* x_1;
    return opaque_concat_MbR9(fu::view<fu::str> {{ (x = &((*(fu::str*)fu::NIL)), (*x)).const_cast_mut().destructive_move_or_default(), (x_1 = &((*(fu::str*)fu::NIL)), (*x_1)).const_cast_mut().destructive_move_or_default() }});
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::vec_range<char> noinl_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    return x;
}

int opaque_concat_MbR9(/*1:1*/ fu::view<fu::str> items)
{
    int sum = 0;
    for (int i = 0; i < items.size(); i++)
        sum += items[i].size();

    return sum;
}

#endif

========

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Ex3D_NQuX1RZ2ud4
                                #define DEF_x3Ex3D_NQuX1RZ2ud4
inline bool operator>=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_x3Cx3D_DhOC56ZzPNa
                                #define DEF_x3Cx3D_DhOC56ZzPNa
inline bool operator<=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) <= 0);
}
                                #endif

int fu_MAIN()
{
    const bool hex = true;
    fu::view<char> /*static*/ trail = "x"_view;
    if (!((trail >= "0"_view) && (trail <= "9"_view)) && !(hex && (((trail >= "a"_view) && (trail <= "f"_view)) || ((trail >= "A"_view) && (trail <= "F"_view)))))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Ex3D_NQuX1RZ2ud4
                                #define DEF_x3Ex3D_NQuX1RZ2ud4
inline bool operator>=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_x3Cx3D_DhOC56ZzPNa
                                #define DEF_x3Cx3D_DhOC56ZzPNa
inline bool operator<=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) <= 0);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ trail = "x"_view;
    if (!((trail >= "0"_view) && (trail <= "9"_view)) && !(((trail >= "a"_view) && (trail <= "f"_view)) || ((trail >= "A"_view) && (trail <= "F"_view))))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags?:     i32;
            value?:     string;
            items?:     SolvedNode[];
            token:      Token;

            type:       Type;
            target?:    ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: "definit",
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>

struct Token_tJUt;
struct Type_ybuf;
struct SolvedNode_ePkE;
struct ScopeIdx_W4zm;

                                #ifndef DEF_Token_tJUtg1xkEhb
                                #define DEF_Token_tJUtg1xkEhb
struct Token_tJUt
{
                                // shape_hash:    b1f506d37f090738
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_ybufcqpknV3
                                #define DEF_Type_ybufcqpknV3
struct Type_ybuf
{
                                // shape_hash:    c84f6f3947ac8bd2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeIdx_W4zmFeeGtXe
                                #define DEF_ScopeIdx_W4zmFeeGtXe
struct ScopeIdx_W4zm
{
                                // shape_hash:    e5ea83169399d3ea
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_ePkEKPcvjPl
                                #define DEF_SolvedNode_ePkEKPcvjPl
struct SolvedNode_ePkE
{
                                // shape_hash:    87c3bd0452d7d3ef
                                // non_triv_mask: 1000800000000010
    fu::str kind;
    int flags;
    fu::str value;
    fu::vec<SolvedNode_ePkE> items;
    Token_tJUt token;
    Type_ybuf type;
    ScopeIdx_W4zm target;
    SolvedNode_ePkE(const SolvedNode_ePkE&) = default;
    SolvedNode_ePkE(SolvedNode_ePkE&&) = default;
    SolvedNode_ePkE& operator=(SolvedNode_ePkE&&) = default;
    SolvedNode_ePkE& operator=(const SolvedNode_ePkE& selfrec) { return *this = SolvedNode_ePkE(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || value
            || items
            || token
            || type
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_ePkE createDefaultInit_MbR9(/*3:3*/ const Type_ybuf& type, /*3:3*/ const Token_tJUt& _here)
{
    return SolvedNode_ePkE { fu::str("definit"_fu), 0, fu::str{}, fu::vec<SolvedNode_ePkE>{}, Token_tJUt(_here), Type_ybuf(type), ScopeIdx_W4zm{} };
}

int fu_MAIN()
{
    const Token_tJUt _here {};
    return createDefaultInit_MbR9(Type_ybuf{}, _here).target.i;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            ref scope: Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct Scope_Mrbv;
struct Type_ybuf;
struct Template_4wvO;
struct SolvedNode_eT3D;
struct Partial_tQaj;

                                #ifndef DEF_Scope_Mrbv2vFG35c
                                #define DEF_Scope_Mrbv2vFG35c
struct Scope_Mrbv
{
                                // shape_hash:    e6ec5ccdcdfc8bc8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_ybufcqpknV3
                                #define DEF_Type_ybufcqpknV3
struct Type_ybuf
{
                                // shape_hash:    c84f6f3947ac8bd2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Template_4wvOt8Jhed1
                                #define DEF_Template_4wvOt8Jhed1
struct Template_4wvO
{
                                // shape_hash:    0412d8da606122e0
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_eT3DfLxWPs5
                                #define DEF_SolvedNode_eT3DfLxWPs5
struct SolvedNode_eT3D
{
                                // shape_hash:    487ed829e1cd7af3
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Partial_tQaj54OFHVf
                                #define DEF_Partial_tQaj54OFHVf
struct Partial_tQaj
{
                                // shape_hash:    51020027d7e0e89b
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Scope_add_MbR9(/*FF7:FF7*/ const Scope_Mrbv& scope, /*FF7:FF7*/ fu::view<char> kind, /*FF7:FF7*/ fu::view<char> id, /*FF7:FF7*/ const Type_ybuf& type, const int min, const int max, /*FF7:FF7*/ fu::view<fu::str> arg_n, /*FF7:FF7*/ fu::view<Type_ybuf> arg_t, /*FF7:FF7*/ fu::view<SolvedNode_eT3D> arg_d, /*FF7:FF7*/ const Template_4wvO& tEmplate, /*FF7:FF7*/ const Partial_tQaj& partial)
{
    return (((((((((scope.i + kind.size()) + id.size()) + type.i) + min) + max) + arg_n.size()) + arg_t.size()) + arg_d.size()) + tEmplate.i) + partial.i;
}

int fu_MAIN()
{
    const Scope_Mrbv _scope {};
    fu::str id {};
    const Type_ybuf t_template {};
    const int min {};
    const int max {};
    fu::vec<fu::str> arg_n {};
    const Template_4wvO tEmplate {};
    return Scope_add_MbR9(_scope, ""_view, id, t_template, min, max, arg_n, fu::view<Type_ybuf>{}, fu::view<SolvedNode_eT3D>{}, tEmplate, Partial_tQaj{});
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            ref scope: Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct Scope_Mrbv;
struct Type_ybuf;
struct Template_4wvO;
struct SolvedNode_eT3D;
struct Partial_tQaj;

                                #ifndef DEF_Scope_Mrbv2vFG35c
                                #define DEF_Scope_Mrbv2vFG35c
struct Scope_Mrbv
{
                                // shape_hash:    e6ec5ccdcdfc8bc8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_ybufcqpknV3
                                #define DEF_Type_ybufcqpknV3
struct Type_ybuf
{
                                // shape_hash:    c84f6f3947ac8bd2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Template_4wvOt8Jhed1
                                #define DEF_Template_4wvOt8Jhed1
struct Template_4wvO
{
                                // shape_hash:    0412d8da606122e0
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_eT3DfLxWPs5
                                #define DEF_SolvedNode_eT3DfLxWPs5
struct SolvedNode_eT3D
{
                                // shape_hash:    487ed829e1cd7af3
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Partial_tQaj54OFHVf
                                #define DEF_Partial_tQaj54OFHVf
struct Partial_tQaj
{
                                // shape_hash:    51020027d7e0e89b
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Scope_add_MbR9(/*FF7:FF7*/ const Scope_Mrbv& scope, /*FF7:FF7*/ fu::view<char> kind, /*FF7:FF7*/ fu::view<char> id, /*FF7:FF7*/ const Type_ybuf& type, const int min, const int max, /*FF7:FF7*/ fu::view<fu::str> arg_n, /*FF7:FF7*/ fu::view<Type_ybuf> arg_t, /*FF7:FF7*/ fu::view<SolvedNode_eT3D> arg_d, /*FF7:FF7*/ const Template_4wvO& tEmplate, /*FF7:FF7*/ const Partial_tQaj& partial)
{
    return (((((((((scope.i + kind.size()) + id.size()) + type.i) + min) + max) + arg_n.size()) + arg_t.size()) + arg_d.size()) + tEmplate.i) + partial.i;
}

int fu_MAIN()
{
    const Scope_Mrbv _scope {};
    fu::str id {};
    const Type_ybuf t_template {};
    const int min {};
    const int max {};
    fu::vec<fu::str> arg_n {};
    const Template_4wvO tEmplate {};
    return Scope_add_MbR9(_scope, fu::view<char>{}, id, t_template, min, max, arg_n, fu::view<Type_ybuf>{}, fu::view<SolvedNode_eT3D>{}, tEmplate, Partial_tQaj{});
}

#endif

int main() { return fu_MAIN(); }

========

        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int i = 0;
    fu::vec<fu::str> items = fu::vec<fu::str> {{ fu::str(""_fu) }};
    if (i == (items.size() - 1))
        return i;
    else
        fu::fail(fu::str("what?"_fu));

}

#endif

int main() { return fu_MAIN(); }

========

        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int i = 0;
    fu::vec<fu::str> items = fu::vec<fu::str> {{ fu::str{} }};
    if (i == (items.size() - 1))
        return i;
    else
        fu::fail(fu::str("what?"_fu));

}

#endif

int main() { return fu_MAIN(); }

========

        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (false)
        return int(0xffffffu);
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(id: i32) id;
        return test(/*id*/0); // <- bad parse

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const int id)
{
    return id;
}

int fu_MAIN()
{
    return test_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part: &string = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            return path.join("/");
        }

        fn main() path_normalize("./hello///hey") == "hello/hey" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_BtSjX9TceHc
                                #define STR_BtSjX9TceHc
static const fu::str str_BtSjX9TceHc fu_INIT_PRIORITY(1001) { "./hello///hey"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str path_normalize_MbR9(/*1:1*/ fu::vec_range<char> p)
{
    fu::vec<fu::str> path = split_t3LL(p, "/"_view);
    for (int i = path.size(); i-- > 0; )
    {
        fu::view<char> /*path|static*/ part = path[i];
        if ((part == "."_view) || (!part && (i > 0) && (i < (path.size() - 1))))
            path.splice(i, 1);

    };
    return join_yqDb(path, "/"_view);
}

int fu_MAIN()
{
    if (path_normalize_MbR9(str_BtSjX9TceHc) == "hello/hey"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == "..")
                    path.splice(--i, 2);
            }

            return path.join("/");
        }

        fn path_join(a: string, b: string)
            path_normalize(a ~ "/" ~ b);

        fn main()
            path_join("hello/hey", "./../you//") == "hello/you/"
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str path_normalize_MbR9(/*1:1*/ fu::vec_range<char> p)
{
    fu::vec<fu::str> path = split_t3LL(p, "/"_view);
    for (int i = path.size(); i-- > 0; )
    {
        fu::view<char> /*path|static*/ part = path[i];
        if ((part == "."_view) || (!part && (i > 0) && (i < (path.size() - 1))))
            path.splice(i, 1);

    };
    for (int i_1 = 1; i_1 < path.size(); i_1++)
    {
        if (path[i_1] == ".."_view)
            path.splice(--i_1, 2);

    };
    return join_yqDb(path, "/"_view);
}

static fu::str path_join_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return path_normalize_MbR9(((a + "/"_view) + b));
}

int fu_MAIN()
{
    if (path_join_MbR9("hello/hey"_view, "./../you//"_view) == "hello/you/"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial
        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done
        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done

        pub fn main() {
            let a = Template(ScopeMemo(+3));
            let b = Template(ScopeMemo(-3));
            return a.locals + b.locals; // <- fails to match.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct ScopeMemo_4tRB;
struct Template_w1xV;

                                #ifndef DEF_ScopeMemo_4tRB56kowXi
                                #define DEF_ScopeMemo_4tRB56kowXi
struct ScopeMemo_4tRB
{
                                // shape_hash:    64be0241becd6dcd
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Template_w1xV9VnCYDd
                                #define DEF_Template_w1xV9VnCYDd
struct Template_w1xV
{
                                // shape_hash:    a430a32fe50fdee9
                                // non_triv_mask: 0000000000000000
    ScopeMemo_4tRB locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int operator+(/*3:3*/ const ScopeMemo_4tRB& a, /*3:3*/ const ScopeMemo_4tRB& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    const Template_w1xV a = Template_w1xV { ScopeMemo_4tRB { +3 } };
    const Template_w1xV b = Template_w1xV { ScopeMemo_4tRB { -3 } };
    return a.locals + b.locals;
}

#endif

int main() { return fu_MAIN(); }

========

        novec fn novec_each(ref a: $T[], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut a = [ 1 ];
            a.novec_each: |ref i| i *= 2;
            return a[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___zjS7YPbIRmf
                                #define DEF___zjS7YPbIRmf
inline static int _zjS7(/*1:1*/ int& i)
{
    return (i *= 2);
}
                                #endif

                                #ifndef DEF_novec_each_xo3vwkNDkNb
                                #define DEF_novec_each_xo3vwkNDkNb
inline static void novec_each_xo3v(/*3:3*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        _zjS7(a.mutref(i));

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    novec_each_xo3v(a);
    return a[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        novec fn Each(ref a: $T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        struct Node { kind: string; items: Node[]; flags: i32; };

        let F_PREDICATE = 2;

        fn parse(tokens: byte[]): Node {
            mut _idx = 0;

            fn parseStructDecl(flags! = 0): Node {
                mut items = parseBlockLike('}');

                :F_PREDICATE {
                    items.Each: |item|
                        if (item.kind == "let")
                            if (item.flags & F_PREDICATE)
                                break :F_PREDICATE;             // Goto

                    items.Each: |ref item|
                        if (item.kind == "let")
                            item.flags |= F_PREDICATE;
                }

                return Node("struct", items, :flags);
            }

            fn parseBlockLike(endToken: byte): Node[] {
                mut items: Node[] = [];
                for (;;) {
                    let token = tokens[_idx++];                 // !N_BckMustSeq
                    if (token == endToken)                      // !N_MoveMustSeq
                        break;

                    items ~= Node("let", [], flags: token == '+' && F_PREDICATE);
                }

                return items;
            }

            return parseStructDecl();
        }

        fn main() {
            let tokens = "+-}";
            let p = parse(tokens).items;
            return p.len - p[0].flags
                         + p[1].flags * 17;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Node_uf0D;

                                #ifndef DEF_F_PREDICATE
                                #define DEF_F_PREDICATE
inline constexpr int F_PREDICATE = 2;
                                #endif

                                #ifndef DEF_Node_uf0DrIztRqb
                                #define DEF_Node_uf0DrIztRqb
struct Node_uf0D
{
                                // shape_hash:    8f2bc3ff2aa9b258
                                // non_triv_mask: 0000800200000010
    fu::str kind;
    fu::vec<Node_uf0D> items;
    int flags;
    Node_uf0D(const Node_uf0D&) = default;
    Node_uf0D(Node_uf0D&&) = default;
    Node_uf0D& operator=(Node_uf0D&&) = default;
    Node_uf0D& operator=(const Node_uf0D& selfrec) { return *this = Node_uf0D(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<Node_uf0D> parseBlockLike_MbR9(const char endToken, /*7:7*/ fu::view<char> tokens, /*7:5*/ int& _idx)
{
    /*MOV*/ fu::vec<Node_uf0D> items {};
    for (; ; )
    {
        fu::view<char> _0 {};
        const char /*tokens|static*/ token = (_0.ptr_reassign(tokens), _0[_idx++]);
        if (token == endToken)
            break;
        else
        {
            items += Node_uf0D { fu::str("let"_fu), fu::vec<Node_uf0D>{}, ((token == '+') ? F_PREDICATE : 0) };
        };
    };
    return /*NRVO*/ items;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF___Y1sF5KHuHx7
                                #define DEF___Y1sF5KHuHx7
inline static void _Y1sF(/*1:1*/ Node_uf0D& item)
{
    if (item.kind == "let"_view)
        item.flags |= F_PREDICATE;

}
                                #endif

                                #ifndef DEF_Each_riIUBKPutS6
                                #define DEF_Each_riIUBKPutS6
inline static void Each_riIU(/*3:3*/ fu::view_mut<Node_uf0D> a)
{
    for (int i = 0; i < a.size(); i++)
        _Y1sF(a.mutref(i));

}
                                #endif

static Node_uf0D parseStructDecl_MbR9(const int flags, /*7:7*/ fu::view<char> tokens, /*7:5*/ int& _idx)
{
    /*MOV*/ fu::vec<Node_uf0D> items = parseBlockLike_MbR9('}', tokens, _idx);

    { {

        {
            fu::view<Node_uf0D> /*items*/ a = items;
            for (int i = 0; i < a.size(); i++)
            {
                const Node_uf0D& /*a|static*/ item = a[i];
                if ((item.kind == "let"_view) && (item.flags & F_PREDICATE))
                    goto BL_1;

            };
        };
        Each_riIU(items);
      } BL_1:;
    };
    return Node_uf0D { fu::str("struct"_fu), static_cast<fu::vec<Node_uf0D>&&>(items), flags };
}

static Node_uf0D parse_MbR9(/*1:1*/ fu::view<char> tokens)
{
    int _idx = 0;
    return parseStructDecl_MbR9(0, tokens, _idx);
}

int fu_MAIN()
{
    fu::view<char> /*static*/ tokens = "+-}"_view;
    fu::vec<Node_uf0D> p = parse_MbR9(tokens).items;
    return (p.size() - p[0].flags) + (p[1].flags * 17);
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_SD_HasStaticInit

========

        pub struct MeshBuilder
        {
            verts?:     byte[];
            indices?:   byte[];
            vert_bytes: i32;
            num_verts?: i32;
        };

        pub fn alloc(
            using ref mb: MeshBuilder,
            new_verts: i32,
            new_indices: i32)
        {
            verts.resize_junk((verts.len + new_verts) * vert_bytes);

            let index_bytes = 4;
            indices.resize_junk((indices.len + new_indices) * index_bytes);
        }

        pub fn setup_quads(
            using ref mb: MeshBuilder,  // <- the 'using' introduced more bindings,
            num_quads: i32)             // <-  advancing the target index number of this arg,
                : &mut byte[..]         // <-   confusing the callsite lifetime of this view.
        {
            let b0 = verts.len;
            let v0 = num_verts;
            let i0 = indices.len;

            mut v1 = v0;

            alloc(num_quads * 4, num_quads * 6);

            ref indices_i32: i32[..] =
                indices[i0 .. indices.len]
                    .view(i32);

            for (mut i = 0; i < indices_i32.len; i += 6)
            {
                indices_i32[i    ] = v1;
                indices_i32[i + 1] = v1 + 1;
                indices_i32[i + 2] = v1 + 2;

                indices_i32[i + 3] = v1;
                indices_i32[i + 4] = v1 + 2;
                indices_i32[i + 5] = v1 + 3;

                v1 += 4;
            }

            num_verts = v1;

            return verts[b0 .. verts.len];
        }

        let QUAD_VBO: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0,
            +1, +1, 0,      0, 0, 1,    1, 1,
            -1, +1, 0,      0, 0, 1,    0, 1,
        ];

        pub fn main()
        {
            mut mb = MeshBuilder(
                vert_bytes: 4 * (3+3+2));

            mb.setup_quads(1).view(f32) .= QUAD_VBO;

            return mb.num_verts - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(592) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>

struct MeshBuilder_ieF9;

                                #ifndef DEF_MeshBuilder_ieF9S2DLOX8
                                #define DEF_MeshBuilder_ieF9S2DLOX8
struct MeshBuilder_ieF9
{
                                // shape_hash:    23f637b59b63b686
                                // non_triv_mask: 0000800000004000
    fu::str verts;
    fu::str indices;
    int vert_bytes;
    int num_verts;
    explicit operator bool() const noexcept
    {
        return false
            || verts
            || indices
            || vert_bytes
            || num_verts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void alloc_MbR9(/*7:7*/ MeshBuilder_ieF9& mb, const int new_verts, const int new_indices)
{
    mb.verts.resize<false>(((mb.verts.size() + new_verts) * mb.vert_bytes));
    const int index_bytes = 4;
    mb.indices.resize<false>(((mb.indices.size() + new_indices) * index_bytes));
}

fu::vec_range_mut<char> setup_quads_MbR9(/*3:3*/ MeshBuilder_ieF9& mb, const int num_quads)
{
    const int b0 = mb.verts.size();
    const int /*mb*/ v0 = mb.num_verts;
    const int i0 = mb.indices.size();
    int v1 = v0;
    alloc_MbR9(mb, (num_quads * 4), (num_quads * 6));
    fu::view_mut<int> /*mb|static*/ indices_i32 = fu::view_of_mut<int>(fu::get_range_mut(mb.indices, i0, mb.indices.size()));
    for (int i = 0; i < indices_i32.size(); (i += 6))
    {
        indices_i32.mutref(i) = v1;
        indices_i32.mutref((i + 1)) = (v1 + 1);
        indices_i32.mutref((i + 2)) = (v1 + 2);
        indices_i32.mutref((i + 3)) = v1;
        indices_i32.mutref((i + 4)) = (v1 + 2);
        indices_i32.mutref((i + 5)) = (v1 + 3);
        v1 += 4;
    };
    mb.num_verts = v1;
    return fu::get_range_mut(mb.verts, b0, mb.verts.size());
}

static const fu::vec<float> QUAD_VBO fu_INIT_PRIORITY(1001) = fu::vec<float> {{ -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, +1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f }};

int fu_MAIN()
{
    MeshBuilder_ieF9 mb = MeshBuilder_ieF9 { fu::str{}, fu::str{}, (4 * ((3 + 3) + 2)), 0 };
    fu::view_assign(fu::view_of_mut<float>(setup_quads_MbR9(mb, 1)), QUAD_VBO);
    return mb.num_verts - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn target(implicit ref _target: i32) _target;

        // this suddenly reported that it doesn't see __solveStruct
        fn GET_mut(ref x: i32) x || target;

        // while i was trying to reproduce an ambig "o" fail here
        fn __solveStruct(mut arg: i32): i32 {
            if (arg) {
                ref o = GET_mut(arg);
                o++;
                checkRecursions(o, o);
            }
            return arg;
        }

        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

        fn main() {
            implicit mut _target = 0;
            return __solveStruct(1) - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int& target_MbR9(/*1:1*/ int& _target)
{
    return _target;
}

static int& GET_mut_MbR9(/*3:3*/ int& x, /*3:3*/ int& _target)
{
    return x ? x : target_MbR9(_target);
}

static void checkRecursions_MbR9(/*7:7*/ int& o, const int incr, /*7:7*/ int& _target)
{
    GET_mut_MbR9(o, _target) += incr;
}

static int __solveStruct_MbR9(int arg, /*3:2*/ int& _target)
{
    if (arg)
    {
        int& /*arg|_target*/ o = GET_mut_MbR9(arg, _target);
        o++;
        checkRecursions_MbR9(o, o, _target);
    };
    return arg;
}

int fu_MAIN()
{
    int _target = 0;
    return __solveStruct_MbR9(1, _target) - 4;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   // PointlessMustSeq
            return GET_mut(target) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int GET_mut_kGbb(int, int&);

#ifndef fu_NO_fdefs

static int GET_mut_kGbb(/*3:3*/ const int x, /*3:3*/ int& target)
{
    return x ? x : GET_mut_kGbb((target += 1), target);
}

int fu_MAIN()
{
    int target = 0;
    return GET_mut_kGbb(target, target) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_BckMustSeq

========

        fn target(implicit ref _itarg: i32) _itarg;

        fn main() {
            implicit mut _itarg = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   // PointlessMustSeq
            return GET_mut(target) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int GET_mut_kGbb(int, int&);

#ifndef fu_NO_fdefs

static int target_kGbb(/*1:1*/ const int _itarg)
{
    return _itarg;
}

static int& target_MbR9(/*1:1*/ int& _itarg)
{
    return _itarg;
}

static int GET_mut_kGbb(/*3:3*/ const int x, /*3:3*/ int& _itarg)
{
    return x ? x : GET_mut_kGbb((target_MbR9(_itarg) += 1), _itarg);
}

int fu_MAIN()
{
    int _itarg = 0;
    return GET_mut_kGbb(target_kGbb(_itarg), _itarg) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_BckMustSeq

========

        fn target(implicit ref _itarg: i32) _itarg;
        fn GET_mut(ref x: i32) x || GET_mut(target += 1);       // PointlessMustSeq

        fn main() {
            implicit mut _itarg = 0;
            return GET_mut(target) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int GET_mut_kGbb(int, int&);

#ifndef fu_NO_fdefs

static int target_kGbb(/*1:1*/ const int _itarg)
{
    return _itarg;
}

static int& target_MbR9(/*1:1*/ int& _itarg)
{
    return _itarg;
}

static int GET_mut_kGbb(/*3:3*/ const int x, /*3:3*/ int& _itarg)
{
    return x ? x : GET_mut_kGbb((target_MbR9(_itarg) += 1), _itarg);
}

int fu_MAIN()
{
    int _itarg = 0;
    return GET_mut_kGbb(target_kGbb(_itarg), _itarg) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_BckMustSeq

========

        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(++target);      // PointlessMustSeq
            return GET_mut(target) - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int GET_mut_kGbb(int, int&);

#ifndef fu_NO_fdefs

static int GET_mut_kGbb(/*3:3*/ const int x, /*3:3*/ int& target)
{
    return x ? x : GET_mut_kGbb(++target, target);
}

int fu_MAIN()
{
    int target = 0;
    return GET_mut_kGbb(target, target) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_BckMustSeq

========

        // TODO use something like pragma lax to opt-out of cc warnings.
        // Output looks fine & works on gcc/clang but gcc warns and breaks build.
        pragma emit(`#pragma GCC diagnostic ignored "-Wsequence-point"`);

        fn main() {
            mut target = 0;
            fn __solveStruct(mut arg: i32): i32 {
                ref o = GET_mut(arg); o += target;
                return target;
            }

            fn GET_mut(ref x: i32)
                x || (target = __solveStruct(target += 1));     // PointlessMustSeq

            return __solveStruct(0) - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int __solveStruct_kGbb(int, int&);
#pragma GCC diagnostic ignored "-Wsequence-point"

#ifndef fu_NO_fdefs

static int& GET_mut_MbR9(/*3:3*/ int& x, /*3:3*/ int& target)
{
    return x ? x : (target = __solveStruct_kGbb((target += 1), target));
}

static int __solveStruct_kGbb(int arg, /*3:3*/ int& target)
{
    int& /*arg|target*/ o = GET_mut_MbR9(arg, target);
    o += target;
    return target;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_kGbb(0, target) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec, N_BckMustSeq

========

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || (a = B(incr(a)));
        fn B(ref b: i32) b || (b = A(incr(b)));
        fn main() { mut v = 0; return A(v) - 1; }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int B_kGbb(int&);

#ifndef fu_NO_fdefs

static int& incr_MbR9(/*1:1*/ int& a)
{
    return ++a;
}

static int& A_MbR9(/*1:1*/ int& a)
{
    return a ? a : (a = B_kGbb(incr_MbR9(a)));
}

static int B_kGbb(/*1:1*/ int& b)
{
    return b ? b : (b = A_MbR9(incr_MbR9(b)));
}

static int A_kGbb(/*1:1*/ int& a)
{
    return a ? a : (a = B_kGbb(incr_MbR9(a)));
}

int fu_MAIN()
{
    int v = 0;
    return A_kGbb(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec

========

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }
        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }
        fn main() { mut v = 0; return A(v) - 1; }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int B_kGbb(int&);

#ifndef fu_NO_fdefs

static int& incr_MbR9(/*1:1*/ int& a)
{
    return ++a;
}

static int& A_MbR9(/*1:1*/ int& a)
{
    int& /*a*/ aa = (a ? a : (a = B_kGbb(incr_MbR9(a))));
    return aa;
}

static int B_kGbb(/*1:1*/ int& b)
{
    const int /*b*/ bb = (b ? b : (b = A_MbR9(incr_MbR9(b))));
    return bb;
}

static int A_kGbb(/*1:1*/ int& a)
{
    const int /*a*/ aa = (a ? a : (a = B_kGbb(incr_MbR9(a))));
    return aa;
}

int fu_MAIN()
{
    int v = 0;
    return A_kGbb(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec

========

        fn main()
        {
            fn Each(cond, cons) cond && cons();
            fn arg(implicit ref __arg: i32) __arg;
            fn __solveStruct(x = 3) Each(arg, || arg += x);
            implicit mut __arg = 1;
            return __solveStruct - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int arg_kGbb(/*1:1*/ const int __arg)
{
    return __arg;
}

static int& arg_MbR9(/*1:1*/ int& __arg)
{
    return __arg;
}

                                #ifndef DEF___K9GevyseOr2
                                #define DEF___K9GevyseOr2
inline static int _K9Ge(/*3:3*/ const int x, /*3:3*/ int& __arg)
{
    return (arg_MbR9(__arg) += x);
}
                                #endif

                                #ifndef DEF_Each_M7UKN3GEohf
                                #define DEF_Each_M7UKN3GEohf
inline static int Each_M7UK(/*F:F*/ const int cond, /*F:F*/ const int x, /*F:F*/ int& __arg)
{
    return !cond ? cond : _K9Ge(x, __arg);
}
                                #endif

static int __solveStruct_MbR9(const int x, /*3:3*/ int& __arg)
{
    return Each_M7UK(arg_kGbb(__arg), x, __arg);
}

int fu_MAIN()
{
    int __arg = 1;
    return __solveStruct_MbR9(3, __arg) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32)             Each(arg, || arg);
            return arg_incr_x(+7) - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___Zg7axrjWgYe
                                #define DEF___Zg7axrjWgYe
inline static int _Zg7a(/*1:1*/ const int arg)
{
    return arg;
}
                                #endif

                                #ifndef DEF_Each_ldAVLxlMl90
                                #define DEF_Each_ldAVLxlMl90
inline static int Each_ldAV(/*7:7*/ const int cond, /*7:7*/ const int arg)
{
    return !cond ? cond : _Zg7a(arg);
}
                                #endif

static int arg_incr_x_MbR9(const int arg)
{
    return Each_ldAV(arg, arg);
}

int fu_MAIN()
{
    return arg_incr_x_MbR9(+7) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0)      Each(arg, || arg += x);
            return arg_incr_x(+7, -11) + 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___wq1sVce9t8d
                                #define DEF___wq1sVce9t8d
inline static int _wq1s(/*3:3*/ int& arg, /*3:3*/ const int x)
{
    return (arg += x);
}
                                #endif

                                #ifndef DEF_Each_XwzXW7cxRo0
                                #define DEF_Each_XwzXW7cxRo0
inline static int Each_XwzX(/*F:F*/ const int cond, /*F:F*/ int& arg, /*F:F*/ const int x)
{
    return !cond ? cond : _wq1s(arg, x);
}
                                #endif

static int arg_incr_x_MbR9(int arg, const int x)
{
    return Each_XwzX(arg, arg, x);
}

int fu_MAIN()
{
    return arg_incr_x_MbR9(+7, -11) + 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                return arg;
            }
            return arg_incr_x(+7, -11) + 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___2o3xzJ0Ezz3
                                #define DEF___2o3xzJ0Ezz3
inline static int _2o3x(/*3:3*/ int& arg, /*3:3*/ const int x)
{
    return (arg += x);
}
                                #endif

                                #ifndef DEF_Each_x6ZZywDQrni
                                #define DEF_Each_x6ZZywDQrni
inline static int Each_x6ZZ(/*F:F*/ const int cond, /*F:F*/ int& arg, /*F:F*/ const int x)
{
    return !cond ? cond : _2o3x(arg, x);
}
                                #endif

static int arg_incr_x_MbR9(int arg, const int x)
{
    Each_x6ZZ(arg, arg, x);
    return arg;
}

int fu_MAIN()
{
    return arg_incr_x_MbR9(+7, -11) + 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main()
        {
            mut target = 0;

            fn Each(cond, cons) cond && cons();

            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));

            fn __solveStruct(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int __solveStruct_MbR9(int, int, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF___2o3xzJ0Ezz3
                                #define DEF___2o3xzJ0Ezz3
inline static int _2o3x(/*3:3*/ int& arg, /*3:3*/ const int x)
{
    return (arg += x);
}
                                #endif

                                #ifndef DEF_Each_x6ZZywDQrni
                                #define DEF_Each_x6ZZywDQrni
inline static int Each_x6ZZ(/*F:F*/ const int cond, /*F:F*/ int& arg, /*F:F*/ const int x)
{
    return !cond ? cond : _2o3x(arg, x);
}
                                #endif

static int& GET_mut_MbR9(/*3:3*/ int& x, /*3:3*/ int& target)
{
    return x ? x : (target = __solveStruct_MbR9(target, 0, target));
}

static void checkRecursions_MbR9(/*7:7*/ int& o, const int incr, /*7:7*/ int& target)
{
    GET_mut_MbR9(o, target) += incr;
}

static int __solveStruct_MbR9(int arg, const int x, /*7:6*/ int& target)
{
    Each_x6ZZ(arg, arg, x);
    if (arg)
    {
        int& /*arg|target*/ o = GET_mut_MbR9(arg, target);
        o++;
        checkRecursions_MbR9(o, o, target);
    };
    return arg;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_MbR9(1, 0, target) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_DeadLet, N_RelaxRespec

========

        fn main()
        {
            mut target = 0;

            // this suddenly reported that it doesn't see __solveStruct
            fn GET_mut(ref x) x || (target = __solveStruct(target));

            // while i was trying to reproduce an ambig "o" fail here
            fn __solveStruct(mut arg: i32): i32 {
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int __solveStruct_MbR9(int, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_GET_mut_i78HflTRpZf
                                #define DEF_GET_mut_i78HflTRpZf
inline static int& GET_mut_i78H(/*3:3*/ int& x, /*3:3*/ int& target)
{
    return x ? x : (target = __solveStruct_MbR9(target, target));
}
                                #endif

static void checkRecursions_MbR9(/*7:7*/ int& o, const int incr, /*7:7*/ int& target)
{
    GET_mut_i78H(o, target) += incr;
}

static int __solveStruct_MbR9(int arg, /*3:2*/ int& target)
{
    if (arg)
    {
        int& /*arg|target*/ o = GET_mut_i78H(arg, target);
        o++;
        checkRecursions_MbR9(o, o, target);
    };
    return arg;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_MbR9(1, target) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        pub struct ScopeSkip { start: i32; end: i32; };

        pub fn Each(items: $T[..], scope_skip: ScopeSkip[], fn, start = 0) {
            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

            mut i0 = start;
            for (mut i = 0; i < scope_skip.len + 1; i++) {
                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
                if (ss.end <= i0)
                    continue;

                let i1 = ss.start;
                for (shadow mut i = i0; i < i1; i++)
                    fn(items[i]);

                i0 = ss.end;
            }
        }

        pub fn test(items?: i32[]) {
            mut sum = 0;
            let ss: ScopeSkip[];
            items.Each(ss, |item| sum += item, start: sum);
            return sum;
        }

        pub fn main() test();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct ScopeSkip_iozY;

                                #ifndef DEF_ScopeSkip_iozYP9lEHXh
                                #define DEF_ScopeSkip_iozYP9lEHXh
struct ScopeSkip_iozY
{
                                // shape_hash:    edd18b1834ec931d
                                // non_triv_mask: 0000000000000000
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int item, /*3:3*/ int& sum)
{
    return (sum += item);
}
                                #endif

                                #ifndef DEF_Each_s3f79u9IJz2
                                #define DEF_Each_s3f79u9IJz2
inline void Each_s3f7(/*F1:F1*/ fu::view<int> items, /*F1:F1*/ fu::view<ScopeSkip_iozY> scope_skip, const int start, /*C1:C1*/ int& sum)
{
    const ScopeSkip_iozY END_DUMMY = ScopeSkip_iozY { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const ScopeSkip_iozY& /*END_DUMMY|scope_skip|static*/ ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int /*ss*/ i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _5aAg(items[i_1], sum);

            i0 = ss.end;
        };
    };
}
                                #endif

int test_MbR9(/*1:1*/ fu::view<int> items)
{
    int sum = 0;
    fu::vec<ScopeSkip_iozY> ss {};
    Each_s3f7(items, ss, sum, sum);
    return sum;
}

int fu_MAIN()
{
    return test_MbR9(fu::view<int>{});
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Each(a: $T[..], fn, start!?: i32)
            for (mut i = start; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut sum = 0;
            let a = [ 1, 2, 3 ];
            a.Each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit
            return sum - 6;                     //     perhaps we can use the optionality to infer constness
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int i, /*3:3*/ int& sum)
{
    return (sum += i);
}
                                #endif

                                #ifndef DEF_Each_8VyPgsLGXqa
                                #define DEF_Each_8VyPgsLGXqa
inline static void Each_8VyP(/*F:F*/ fu::view<int> a, const int start, /*E:E*/ int& sum)
{
    for (int i = start; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    fu::vec<int> a = fu::vec<int> {{ 1, 2, 3 }};
    Each_8VyP(a, sum, sum);
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        novec // Abusing to test novec, unrelated to the test

        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:9+5[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        [31;1mnovec[0m // Abusing to test novec, unrelated to the test
[2m      | [0m
[2m      |         fn ScopeSkip_push(ref scope_skip: i32[]) {[0m

	[35;3mfn[0m [94;1mScopeSkip_push[0m is not novec, [35;3mmut ref arg[0m [94;1mscope_skip[0m is [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[][0m:

            via [35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m7:40+2[0m:

[2m      |         fn ScopeSkip_push(ref scope_skip: i32[]) {[0m
[2m      |             if (scope_skip) scope_skip[0]++;[0m
[2m    7 | [0m            else            scope_skip [31;1m~=[0m 1;
[2m      |         }[0m
[2m      | [0m


========


        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void ScopeSkip_push_MbR9(/*1:1*/ fu::vec_range_mut<int> scope_skip)
{
    if (scope_skip)
        scope_skip.mutref(0)++;
    else
        scope_skip += 1;

}

int fu_MAIN()
{
    fu::vec<int> scope_skip = fu::vec<int> {{ 1 }};
    ScopeSkip_push_MbR9(scope_skip);
    return scope_skip[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Hello { v: i32[] };

        fn main() {
            let h = Hello();


            novec // qSTACK bug with args.len == 0 at call to Hello

            fn hello(woot?: i32)
                woot ? Hello() : h;

            return hello.v.len;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:13+5[0m:

[2m      | [0m
[2m      | [0m
[2m    8 | [0m            [31;1mnovec[0m // qSTACK bug with args.len == 0 at call to Hello
[2m      | [0m
[2m      |             fn hello(woot?: i32)[0m

	[35;3mfn[0m [94;1mhello[0m is not novec, [35;3minjected implicit const ref arg[0m [94;1mmain:h[0m is [35;3malways-false[0m [35;3mstruct[0m [94;1mHello[0m:

            via copy at [2m11:34+1[0m:

[2m      | [0m
[2m      |             fn hello(woot?: i32)[0m
[2m   11 | [0m                woot ? Hello() : [31;1mh[0m;
[2m      | [0m
[2m      |             return hello.v.len;[0m


        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct Hello { v: i32[] };

        fn main() {
            let h = Hello();


            fn hello(woot?: i32)
                woot ? Hello() : h;

            return hello.v.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hello_eXxg;

                                #ifndef DEF_Hello_eXxgFlUnoU7
                                #define DEF_Hello_eXxgFlUnoU7
struct Hello_eXxg
{
                                // shape_hash:    ccf554363ada02c5
                                // non_triv_mask: 0009000000000000
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Hello_eXxg hello_MbR9(const int woot, /*3:3*/ const Hello_eXxg& h)
{
    if (woot)
    {
        return Hello_eXxg{};
    }
    else
        return Hello_eXxg(h);

}

int fu_MAIN()
{
    Hello_eXxg h {};
    return hello_MbR9(0, h).v.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Module  { cpp:    string; };
        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here

        fn snippet2cpp(cpp: string): string {
            let ctx = Context( Module(cpp) );
            {
                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.
                if (module.cpp)
                    return module.cpp;          // EXPECT return static_cast<fu::str&&>(module.cpp)
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Context_Bji6;
struct Module_c0gK;

                                #ifndef DEF_Module_c0gKc8m09xk
                                #define DEF_Module_c0gKc8m09xk
struct Module_c0gK
{
                                // shape_hash:    c15b5418ddfdd2fe
                                // non_triv_mask: 0000800100000000
    fu::str cpp;
    explicit operator bool() const noexcept
    {
        return false
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_Bji65xYgy7a
                                #define DEF_Context_Bji65xYgy7a
struct Context_Bji6
{
                                // shape_hash:    700973c60b425e57
                                // non_triv_mask: 0800800100000000
    Module_c0gK module;
    explicit operator bool() const noexcept
    {
        return false
            || module
        ;
    }
};
                                #endif

                                #ifndef STR_ASSagOJsk59
                                #define STR_ASSagOJsk59
static const fu::str str_ASSagOJsk59 fu_INIT_PRIORITY(1001) { "1"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str snippet2cpp_MbR9(/*1:1*/ fu::vec_range<char> cpp)
{
    /*MOV*/ Context_Bji6 ctx = Context_Bji6 { Module_c0gK { fu::str(cpp) } };

    {
        /*MOV*/ Module_c0gK& /*ctx*/ module = ctx.module;
        if (module.cpp)
            return static_cast<fu::str&&>(module.cpp);

    };
    return fu::str{};
}

int fu_MAIN()
{
    return snippet2cpp_MbR9(str_ASSagOJsk59).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Module  { cpp:     string;   };
        struct Context { modules: Module[]; };  // Module[] is COW-capable -
                                                //  - either prove there's no COW,
        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.
            let ctx = Context([ Module(cpp) ]);
            for (mut i = 0; i < ctx.modules.len; i++)
            {
                let module = ctx.modules[i];    // TODO .unique(i)
                if (module.cpp)
                    return module.cpp;          // TODO return static_cast<fu::str&&>(module.cpp)
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Context_t1Lk;
struct Module_c0gK;

                                #ifndef DEF_Module_c0gKc8m09xk
                                #define DEF_Module_c0gKc8m09xk
struct Module_c0gK
{
                                // shape_hash:    c15b5418ddfdd2fe
                                // non_triv_mask: 0000800100000000
    fu::str cpp;
    explicit operator bool() const noexcept
    {
        return false
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_t1LkzUnvyr8
                                #define DEF_Context_t1LkzUnvyr8
struct Context_t1Lk
{
                                // shape_hash:    7e24a0a8b5c9b526
                                // non_triv_mask: 0000800108000400
    fu::vec<Module_c0gK> modules;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef STR_ASSagOJsk59
                                #define STR_ASSagOJsk59
static const fu::str str_ASSagOJsk59 fu_INIT_PRIORITY(1001) { "1"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str snippet2cpp_MbR9(/*1:1*/ fu::vec_range<char> cpp)
{
    Context_t1Lk ctx = Context_t1Lk { fu::vec<Module_c0gK> {{ Module_c0gK { fu::str(cpp) } }} };
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        const Module_c0gK& /*ctx|static*/ module = ctx.modules[i];
        if (module.cpp)
            return fu::str(module.cpp);

    };
    return fu::str(""_fu);
}

int fu_MAIN()
{
    return snippet2cpp_MbR9(str_ASSagOJsk59).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Module  { cpp:     string;   };
        struct Context { modules: Module[]; };  // Module[] is COW-capable -
                                                //  - either prove there's no COW,
        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.
            let ctx = Context([ Module(cpp) ]);
            for (mut i = 0; i < ctx.modules.len; i++)
            {
                let module = ctx.modules[i];    // TODO .unique(i)
                if (module.cpp)
                    return module.cpp;          // TODO return static_cast<fu::str&&>(module.cpp)
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Context_t1Lk;
struct Module_c0gK;

                                #ifndef DEF_Module_c0gKc8m09xk
                                #define DEF_Module_c0gKc8m09xk
struct Module_c0gK
{
                                // shape_hash:    c15b5418ddfdd2fe
                                // non_triv_mask: 0000800100000000
    fu::str cpp;
    explicit operator bool() const noexcept
    {
        return false
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_t1LkzUnvyr8
                                #define DEF_Context_t1LkzUnvyr8
struct Context_t1Lk
{
                                // shape_hash:    7e24a0a8b5c9b526
                                // non_triv_mask: 0000800108000400
    fu::vec<Module_c0gK> modules;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef STR_ASSagOJsk59
                                #define STR_ASSagOJsk59
static const fu::str str_ASSagOJsk59 fu_INIT_PRIORITY(1001) { "1"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str snippet2cpp_MbR9(/*1:1*/ fu::vec_range<char> cpp)
{
    Context_t1Lk ctx = Context_t1Lk { fu::vec<Module_c0gK> {{ Module_c0gK { fu::str(cpp) } }} };
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        const Module_c0gK& /*ctx|static*/ module = ctx.modules[i];
        if (module.cpp)
            return fu::str(module.cpp);

    };
    return fu::str{};
}

int fu_MAIN()
{
    return snippet2cpp_MbR9(str_ASSagOJsk59).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn test(x: string) {
            // cg fail: fwd annots of the two fns where unconsting hey to "enable move",
            //          basically the decision was made in the wrong scope.
            let hey = "hey";
            fn inner(you: string) you && hey ~ you || outer("what#1");
            fn outer(arg: string) inner(arg && " " ~ arg) || inner("what#2");
            return outer(x);
        }

        fn main() test("you").len - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

static fu::str outer_MbR9(fu::view<char>, fu::view<char>);

#ifndef fu_NO_fdefs

static fu::str inner_MbR9(/*3:3*/ fu::view<char> you, /*3:3*/ fu::view<char> hey)
{
    fu::str _0 {};
    return (_0 = (you ? (hey + you) : fu::str{})) ? static_cast<fu::str&&>(_0) : outer_MbR9("what#1"_view, hey);
}

static fu::str outer_MbR9(/*3:3*/ fu::view<char> arg, /*3:3*/ fu::view<char> hey)
{
    return inner_MbR9((arg ? (" "_view + arg) : fu::str{}), hey);
}

static fu::str test_MbR9(/*1:1*/ fu::view<char> x)
{
    fu::view<char> /*static*/ hey = "hey"_view;
    return outer_MbR9(x, hey);
}

int fu_MAIN()
{
    return test_MbR9("you"_view).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;



        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct CurrentFn_lkKH;
struct Target_gES2;

                                #ifndef DEF_Target_gES27JfClze
                                #define DEF_Target_gES27JfClze
struct Target_gES2
{
                                // shape_hash:    819cd4e6d0a15b9a
                                // non_triv_mask: 0000000000000000
    int modid;
    int packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_lkKHqUFPbI6
                                #define DEF_CurrentFn_lkKHqUFPbI6
struct CurrentFn_lkKH
{
                                // shape_hash:    dadf2bfc0d7003e4
                                // non_triv_mask: 0000000000000000
    Target_gES2 target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_MbR9(/*1:1*/ const CurrentFn_lkKH& c)
{
    const Target_gES2& /*c*/ a = c.target;
    return a.packed;
}

int fu_MAIN()
{
    return hello_MbR9(CurrentFn_lkKH{});
}

#endif

int main() { return fu_MAIN(); }

========

        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;

        pub import _0;

        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct CurrentFn_lkKH;
struct Target_gES2;

                                #ifndef DEF_Target_gES27JfClze
                                #define DEF_Target_gES27JfClze
struct Target_gES2
{
                                // shape_hash:    819cd4e6d0a15b9a
                                // non_triv_mask: 0000000000000000
    int modid;
    int packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_lkKHqUFPbI6
                                #define DEF_CurrentFn_lkKHqUFPbI6
struct CurrentFn_lkKH
{
                                // shape_hash:    dadf2bfc0d7003e4
                                // non_triv_mask: 0000000000000000
    Target_gES2 target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_LtD7(/*1:1*/ const CurrentFn_lkKH& c)
{
    const Target_gES2& /*c*/ a = c.target;
    return a.packed;
}

int fu_MAIN()
{
    return hello_LtD7(CurrentFn_lkKH{});
}

#endif

int main() { return fu_MAIN(); }

========

        struct ID   { offset: i32;  };
        struct Data { items:  ID[]; };

        using fn Data(implicit all: Data[], nid: ID): Data {
            return all[nid.offset];
        }

        fn test(node: ID) {
            let init = node.items[0];
            return init.items.len;
        }

        fn main() {
            let implicit all =  [ Data([ ID(1)      ])
                                , Data([ ID, ID, ID ]) ];

            return 0.ID.test - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Data_qRJW;
struct ID_UL8v;

                                #ifndef DEF_ID_UL8vR2VyHb0
                                #define DEF_ID_UL8vR2VyHb0
struct ID_UL8v
{
                                // shape_hash:    2154a7f2eb1d2320
                                // non_triv_mask: 0000000000000000
    int offset;
    explicit operator bool() const noexcept
    {
        return false
            || offset
        ;
    }
};
                                #endif

                                #ifndef DEF_Data_qRJWsLoJzN5
                                #define DEF_Data_qRJWsLoJzN5
struct Data_qRJW
{
                                // shape_hash:    4399e3624de3d834
                                // non_triv_mask: 0000001000000100
    fu::vec<ID_UL8v> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Data_qRJW& Data_MbR9(/*3:3*/ const ID_UL8v& nid, /*3:3*/ fu::view<Data_qRJW> all)
{
    return all[nid.offset];
}

static int test_MbR9(/*3:3*/ const ID_UL8v& node, /*3:3*/ fu::view<Data_qRJW> all)
{
    const ID_UL8v& /*all|static*/ init = Data_MbR9(node, all).items[0];
    return Data_MbR9(init, all).items.size();
}

int fu_MAIN()
{
    fu::vec<Data_qRJW> all = fu::vec<Data_qRJW> {{ Data_qRJW { fu::vec<ID_UL8v> {{ ID_UL8v { 1 } }} }, Data_qRJW { fu::vec<ID_UL8v> {{ ID_UL8v{}, ID_UL8v{}, ID_UL8v{} }} } }};
    return test_MbR9(ID_UL8v { 0 }, all) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:17+1[0m:

[2m      |         fn hello(ref s: S, w: i32) {[0m
[2m      |             infix fn |=(ref s: S, v: i32)[0m
[2m    6 | [0m                [31;1ms[0m.i |= v << w;
[2m      | [0m
[2m      |             s |= 2;[0m

	Ambiguous call to [94;1ms[0m, matches multiple items in scope:

	[35;3mmut ref arg[0m [94;1ms[0m at [2m5:29+1[0m:
[2m    5 | [0m            infix fn |=(ref [31;1ms[0m: S, v: i32)

	[35;3mmut ref arg[0m [94;1ms[0m at [2m4:22+1[0m:
[2m    4 | [0m        fn hello(ref [31;1ms[0m: S, w: i32) {


        Solving [35;3mfn[0m [94;1m|=[0m([94;1mS[0m, [35;3mi32[0m) at [2m5:22+2[0m
                [35;3mfn[0m [94;1mhello[0m([94;1mS[0m, [35;3mi32[0m) at [2m4:12+5[0m

========

        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(shadow ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct S_O24k;

                                #ifndef DEF_S_O24kLTnb0H4
                                #define DEF_S_O24kLTnb0H4
struct S_O24k
{
                                // shape_hash:    e62477e56d15ba63
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int x7Cx3D_GL0m(/*7:7*/ S_O24k& s, const int v, /*7:7*/ const int w)
{
    return (s.i |= (v << w));
}

static void hello_MbR9(/*3:3*/ S_O24k& s, const int w)
{
    x7Cx3D_GL0m(s, 2, w);
}

int fu_MAIN()
{
    S_O24k s = S_O24k { 1 };
    hello_MbR9(s, 3);
    return s.i - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn lex(src: string) {
            let end = src.len;
            mut idx = 0;

            fn err_str(idx1: i32) {
                while (idx < end && src[idx] == ' ') idx++;
                return src.slice(idx, idx1);
            }

            fn err(idx1_x2: i32) err_str(idx1_x2 /2);
            return err(end *2);
        }

        fn main() lex("    hello").len - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static fu::view<char> err_str_kGbb(const int idx1, /*F:F*/ fu::view<char> src, /*F:F*/ const int end, /*F:9*/ int& idx)
{
    while ((idx < end) && (src[idx] == ' '))
        idx++;

    return fu::get_view(src, idx, idx1);
}

static fu::view<char> err_kGbb(const int idx1_x2, /*F:F*/ fu::view<char> src, /*F:F*/ const int end, /*F:9*/ int& idx)
{
    return err_str_kGbb((idx1_x2 / 2), src, end, idx);
}

static fu::view<char> lex_kGbb(/*1:1*/ fu::view<char> src)
{
    const int end = src.size();
    int idx = 0;
    return err_kGbb((end * 2), src, end, idx);
}

int fu_MAIN()
{
    return lex_kGbb("    hello"_view).size() - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void
        {
            // Fuzzing module splits.
            for (mut i = 0; i < sources.len; i++)
            {
                for (;;)
                {
                    ref src     = sources[i];

                    mut start0  = src.find("[split/]");
                    if (start0 < 0)
                        break;

                    let start00 = start0;
                    let start1  = start0 + 8;
                    while (start0 && src[start0 - 1] == ' ') start0--;

                    let moduleA = src.slice(0, start0);
                    let moduleB = src[start0 .. start00] ~ "import _" ~ i ~ ";" ~ src[start1 .. src.len];
                    let without = src[0 .. start0] ~ src[start1 .. src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                }

                sum += sources[i].len;
            }
        }

        fn main() {
            implicit mut sum: i32;

            ZERO( "AAAA|BB[split/]CC".split("|") );
            let expect = 4+2+2 + 4+2+2 + 10; // 10 = "import _0;"

            return sum - expect;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

void ZERO_MbR9(fu::vec<fu::str>&&, int&);

                                #ifndef STR_d8hRbhOLzBd
                                #define STR_d8hRbhOLzBd
static const fu::str str_d8hRbhOLzBd fu_INIT_PRIORITY(1001) { "AAAA|BB[split/]CC"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

void ZERO_MbR9(fu::vec<fu::str>&& sources, /*3:2*/ int& sum)
{
    for (int i = 0; i < sources.size(); i++)
    {
        for (; ; )
        {
            fu::vec_range<char> /*sources|static*/ src = sources[i];
            int start0 = find_7SLc(src, "[split/]"_view);
            if (start0 < 0)
                break;
            else
            {
                const int /*start0*/ start00 = start0;
                const int start1 = (start0 + 8);
                while (start0 && (src[(start0 - 1)] == ' '))
                    start0--;

                /*MOV*/ fu::str moduleA = fu::str(fu::get_range(src, 0, start0));
                /*MOV*/ fu::str moduleB = ((x7E_rA00((fu::get_view(src, start0, start00) + "import _"_view), fu::i64dec(i)) + ";"_view) + fu::get_view(src, start1, src.size()));
                /*MOV*/ fu::str without = (fu::get_view(src, 0, start0) + fu::get_view(src, start1, src.size()));
                sources.mutref(i) = without.destructive_move();
                ZERO_MbR9(fu::vec<fu::str>(sources), sum);
                sources.mutref(i) = moduleA.destructive_move();
                sources.insert((i + 1), moduleB.destructive_move());
            };
        };
        sum += sources[i].size();
    };
}

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    int sum {};
    ZERO_MbR9(split_t3LL(str_d8hRbhOLzBd, "|"_view), sum);
    const int expect = ((((((4 + 2) + 2) + 4) + 2) + 2) + 10);
    return sum - expect;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_COWRestrict

========

        struct SolvedNode {
            bli: i32;
        };

        // --> [2] ... triggered the solve of this fn, ...
        fn SolvedNode(blah: string) {
            return SolvedNode(blah.len.NOT_PREPPED_YET);
        }

        // [1] During prep, this type annotation ...
        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {
            return node.bli + 2;
        }

        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).
        fn NOT_PREPPED_YET(x: i32) {
            return x * 2;
        }

        fn main() {
            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode("hello")) - (2*5+2);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct SolvedNode_h2Al;

                                #ifndef DEF_SolvedNode_h2AlXcVHLXc
                                #define DEF_SolvedNode_h2AlXcVHLXc
struct SolvedNode_h2Al
{
                                // shape_hash:    567d4a94b6000079
                                // non_triv_mask: 0000000000000000
    int bli;
    explicit operator bool() const noexcept
    {
        return false
            || bli
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int NOT_PREPPED_YET_MbR9(const int x)
{
    return x * 2;
}

static SolvedNode_h2Al SolvedNode_MbR9(/*1:1*/ fu::view<char> blah)
{
    return SolvedNode_h2Al { NOT_PREPPED_YET_MbR9(blah.size()) };
}

static int ARG_ANNOT_TRIGGERS_SOLVE_MbR9(/*1:1*/ const SolvedNode_h2Al& node)
{
    return node.bli + 2;
}

int fu_MAIN()
{
    return ARG_ANNOT_TRIGGERS_SOLVE_MbR9(SolvedNode_MbR9("hello"_view)) - ((2 * 5) + 2);
}

#endif

int main() { return fu_MAIN(); }

========

        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                let o = overloads[target.index];
                return o;
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                let nodes = overloads[nid.nodeidx].nodes;
                return nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct CurrentFn_Hkik;
struct SolvedNode_DNLI;
struct Overload_eOu9;
struct SolvedNodeData_wRxF;
struct Target_HIBL;

                                #ifndef DEF_SolvedNode_DNLIoWEbxN2
                                #define DEF_SolvedNode_DNLIoWEbxN2
struct SolvedNode_DNLI
{
                                // shape_hash:    12ee2eed0a6e9902
                                // non_triv_mask: 0000000000000000
    int nodeidx;
    explicit operator bool() const noexcept
    {
        return false
            || nodeidx
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_HkikYm5v0Qd
                                #define DEF_CurrentFn_HkikYm5v0Qd
struct CurrentFn_Hkik
{
                                // shape_hash:    b650bb27d058031a
                                // non_triv_mask: 0000000000000000
    SolvedNode_DNLI out;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_eOu9kLGTCaj
                                #define DEF_Overload_eOu9kLGTCaj
struct Overload_eOu9
{
                                // shape_hash:    abd8a540aaf1d4fd
                                // non_triv_mask: 0000001000000040
    fu::vec<SolvedNodeData_wRxF> nodes;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNodeData_wRxFtaYV6jd
                                #define DEF_SolvedNodeData_wRxFtaYV6jd
struct SolvedNodeData_wRxF
{
                                // shape_hash:    24debd047ad620b9
                                // non_triv_mask: 0000000000000000
    Target_HIBL target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const SolvedNodeData_wRxF& SolvedNodeData_MbR9(/*3:3*/ const SolvedNode_DNLI& nid, /*3:3*/ fu::view<Overload_eOu9> overloads)
{
    fu::view<SolvedNodeData_wRxF> /*overloads|static*/ nodes = overloads[nid.nodeidx].nodes;
    return nodes[nid.nodeidx];
}

static const Overload_eOu9& GET_MbR9(/*3:3*/ const Target_HIBL& target, /*3:3*/ fu::view<Overload_eOu9> overloads)
{
    const Overload_eOu9& /*overloads|static*/ o = overloads[target.index];
    return o;
}

static int test_MbR9(/*3:3*/ fu::view<Overload_eOu9> overloads, /*3:3*/ const CurrentFn_Hkik& _current_fn)
{
    const Target_HIBL& /*overloads|static*/ current_fn = SolvedNodeData_MbR9(_current_fn.out, overloads).target;
    const Overload_eOu9& /*overloads|zeroes|static*/ debug_2 = (current_fn ? GET_MbR9(current_fn, overloads) : (*(Overload_eOu9*)fu::NIL));
    if (debug_2)
        return current_fn.index;
    else
        return 0;

}

int fu_MAIN()
{
    const CurrentFn_Hkik _current_fn = CurrentFn_Hkik { SolvedNode_DNLI { 0 } };
    fu::vec<Overload_eOu9> overloads = fu::vec<Overload_eOu9> {{ Overload_eOu9 { fu::vec<SolvedNodeData_wRxF> {{ SolvedNodeData_wRxF { Target_HIBL { 0 } } }} } }};
    return test_MbR9(overloads, _current_fn);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                if (target.index != 303) // Same as above, different setup.
                    return overloads[target.index];

                return []; // Also this fails to solve: cannot definit mutref
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                return nid.nodeidx != 303 // Same as above, rewording as a logical.
                    && overloads[nid.nodeidx].nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct CurrentFn_Hkik;
struct SolvedNode_DNLI;
struct Overload_eOu9;
struct SolvedNodeData_wRxF;
struct Target_HIBL;

                                #ifndef DEF_SolvedNode_DNLIoWEbxN2
                                #define DEF_SolvedNode_DNLIoWEbxN2
struct SolvedNode_DNLI
{
                                // shape_hash:    12ee2eed0a6e9902
                                // non_triv_mask: 0000000000000000
    int nodeidx;
    explicit operator bool() const noexcept
    {
        return false
            || nodeidx
        ;
    }
};
                                #endif

                                #ifndef DEF_CurrentFn_HkikYm5v0Qd
                                #define DEF_CurrentFn_HkikYm5v0Qd
struct CurrentFn_Hkik
{
                                // shape_hash:    b650bb27d058031a
                                // non_triv_mask: 0000000000000000
    SolvedNode_DNLI out;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_eOu9kLGTCaj
                                #define DEF_Overload_eOu9kLGTCaj
struct Overload_eOu9
{
                                // shape_hash:    abd8a540aaf1d4fd
                                // non_triv_mask: 0000001000000040
    fu::vec<SolvedNodeData_wRxF> nodes;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNodeData_wRxFtaYV6jd
                                #define DEF_SolvedNodeData_wRxFtaYV6jd
struct SolvedNodeData_wRxF
{
                                // shape_hash:    24debd047ad620b9
                                // non_triv_mask: 0000000000000000
    Target_HIBL target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const SolvedNodeData_wRxF& SolvedNodeData_MbR9(/*3:3*/ const SolvedNode_DNLI& nid, /*3:3*/ fu::view<Overload_eOu9> overloads)
{
    if (nid.nodeidx != 303)
        return overloads[nid.nodeidx].nodes[nid.nodeidx];
    else
        return (*(SolvedNodeData_wRxF*)fu::NIL);

}

static const Overload_eOu9& GET_MbR9(/*3:3*/ const Target_HIBL& target, /*3:3*/ fu::view<Overload_eOu9> overloads)
{
    if (target.index != 303)
        return overloads[target.index];
    else
        return (*(Overload_eOu9*)fu::NIL);

}

static int test_MbR9(/*3:3*/ fu::view<Overload_eOu9> overloads, /*3:3*/ const CurrentFn_Hkik& _current_fn)
{
    const Target_HIBL& /*overloads|zeroes|static*/ current_fn = SolvedNodeData_MbR9(_current_fn.out, overloads).target;
    const Overload_eOu9& /*overloads|zeroes|static*/ debug_2 = (current_fn ? GET_MbR9(current_fn, overloads) : (*(Overload_eOu9*)fu::NIL));
    if (debug_2)
        return current_fn.index;
    else
        return 0;

}

int fu_MAIN()
{
    const CurrentFn_Hkik _current_fn = CurrentFn_Hkik { SolvedNode_DNLI { 0 } };
    fu::vec<Overload_eOu9> overloads = fu::vec<Overload_eOu9> {{ Overload_eOu9 { fu::vec<SolvedNodeData_wRxF> {{ SolvedNodeData_wRxF { Target_HIBL { 0 } } }} } }};
    return test_MbR9(overloads, _current_fn);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Token {
            col: i32;
            line: i32;
            value: string;
        };

        fn parse(tokens: Token[]) {
            mut _idx = 0;
            mut _loc = 0;

            fn fail(mut reason = "") {
                let loc  = tokens[_loc];
                let here = tokens[_idx];
                if (!reason)
                    reason = "Unexpected '" ~ here.value ~ "'.";

                let l0 = loc.line;  let c0 = loc.col;
                let l1 = here.line; let c1 = here.col;

                let addr = l1 == l0
                    ? "@" ~ l1 ~ ":" ~ c1
                    : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

                return throw(addr ~ ":\n\t" ~ reason);
            }

            fn consume(value: byte[..], err = "") {
                let token = tokens[_idx];
                if (token.value == value) {
                    _idx++;
                    return token;
                }

                return fail((err || "Expected") ~ " '" ~ value ~ "', got '" ~ token.value ~ "'.");
            }

            fn parseRoot() {
                let ret = consume("sof");
                _loc = _idx;
                return ret;
            }

            return parseRoot();
        }

        fn main() {
            return parse([ Token(1, 1, "sof") ]).value.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct Token_fICA;

                                #ifndef DEF_Token_fICA6YZWo8k
                                #define DEF_Token_fICA6YZWo8k
struct Token_fICA
{
                                // shape_hash:    f43e9948aa8e78ae
                                // non_triv_mask: 0008800000000000
    int col;
    int line;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || col
            || line
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_MbR9(fu::str&& reason, /*F:F*/ fu::view<Token_fICA> tokens, /*F:F*/ const int _idx, /*F:F*/ const int _loc)
{
    const Token_fICA& /*tokens|static*/ loc = tokens[_loc];
    const Token_fICA& /*tokens|static*/ here = tokens[_idx];
    if (!reason)
        reason = (("Unexpected '"_view + here.value) + "'."_view);

    const int /*loc*/ l0 = loc.line;
    const int /*loc*/ c0 = loc.col;
    const int /*here*/ l1 = here.line;
    const int /*here*/ c1 = here.col;
    fu::str addr = ((l1 == l0) ? x7E_rA00((x7E_rA00("@"_view, fu::i64dec(l1)) + ":"_view), fu::i64dec(c1)) : x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00("@"_view, fu::i64dec(l0)) + ":"_view), fu::i64dec(c0)) + ".."_view), fu::i64dec(l1)) + ":"_view), fu::i64dec(c1)));
    fu::fail(((addr + ":\n\t"_view) + reason));
}

static const Token_fICA& consume_MbR9(/*F1:F1*/ fu::view<char> value, /*F1:F1*/ fu::view<char> err, /*F1:F1*/ fu::view<Token_fICA> tokens, /*B1:B1*/ int& _idx, /*F1:F1*/ const int _loc)
{
    const Token_fICA& /*tokens|static*/ token = tokens[_idx];
    if (token.value == value)
    {
        _idx++;
        return token;
    }
    else
        fail_MbR9(((((((err ? err : "Expected"_view) + " '"_view) + value) + "', got '"_view) + token.value) + "'."_view), tokens, _idx, _loc);

}

static const Token_fICA& parseRoot_MbR9(/*7:7*/ fu::view<Token_fICA> tokens, /*6:2*/ int& _idx, /*6:6*/ int& _loc)
{
    const Token_fICA& /*tokens|static*/ ret = consume_MbR9("sof"_view, ""_view, tokens, _idx, _loc);
    _loc = _idx;
    return ret;
}

static const Token_fICA& parse_MbR9(/*1:1*/ fu::view<Token_fICA> tokens)
{
    int _idx = 0;
    int _loc = 0;
    return parseRoot_MbR9(tokens, _idx, _loc);
}

int fu_MAIN()
{
    return parse_MbR9(fu::view<Token_fICA> {{ Token_fICA { 1, 1, fu::str("sof"_fu) } }}).value.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token {
            col: i32;
            line: i32;
            value: string;
        };

        fn parse(tokens: Token[]) {
            mut _idx = 0;
            mut _loc = 0;

            fn fail(mut reason = "") {
                let loc  = tokens[_loc];
                let here = tokens[_idx];
                if (!reason)
                    reason = "Unexpected '" ~ here.value ~ "'.";

                let l0 = loc.line;  let c0 = loc.col;
                let l1 = here.line; let c1 = here.col;

                let addr = l1 == l0
                    ? "@" ~ l1 ~ ":" ~ c1
                    : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

                return throw(addr ~ ":\n\t" ~ reason);
            }

            fn consume(value: byte[..], err = "") {
                let token = tokens[_idx];
                if (token.value == value) {
                    _idx++;
                    return token;
                }

                return fail((err || "Expected") ~ " '" ~ value ~ "', got '" ~ token.value ~ "'.");
            }

            fn parseRoot() {
                let ret = consume("sof");
                _loc = _idx;
                return ret;
            }

            return parseRoot();
        }

        fn main() {
            return parse([ Token(1, 1, "sof") ]).value.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct Token_fICA;

                                #ifndef DEF_Token_fICA6YZWo8k
                                #define DEF_Token_fICA6YZWo8k
struct Token_fICA
{
                                // shape_hash:    f43e9948aa8e78ae
                                // non_triv_mask: 0008800000000000
    int col;
    int line;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || col
            || line
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_MbR9(fu::str&& reason, /*F:F*/ fu::view<Token_fICA> tokens, /*F:F*/ const int _idx, /*F:F*/ const int _loc)
{
    const Token_fICA& /*tokens|static*/ loc = tokens[_loc];
    const Token_fICA& /*tokens|static*/ here = tokens[_idx];
    if (!reason)
        reason = (("Unexpected '"_view + here.value) + "'."_view);

    const int /*loc*/ l0 = loc.line;
    const int /*loc*/ c0 = loc.col;
    const int /*here*/ l1 = here.line;
    const int /*here*/ c1 = here.col;
    fu::str addr = ((l1 == l0) ? x7E_rA00((x7E_rA00("@"_view, fu::i64dec(l1)) + ":"_view), fu::i64dec(c1)) : x7E_rA00((x7E_rA00((x7E_rA00((x7E_rA00("@"_view, fu::i64dec(l0)) + ":"_view), fu::i64dec(c0)) + ".."_view), fu::i64dec(l1)) + ":"_view), fu::i64dec(c1)));
    fu::fail(((addr + ":\n\t"_view) + reason));
}

static const Token_fICA& consume_MbR9(/*F1:F1*/ fu::view<char> value, /*F1:F1*/ fu::view<char> err, /*F1:F1*/ fu::view<Token_fICA> tokens, /*B1:B1*/ int& _idx, /*F1:F1*/ const int _loc)
{
    const Token_fICA& /*tokens|static*/ token = tokens[_idx];
    if (token.value == value)
    {
        _idx++;
        return token;
    }
    else
        fail_MbR9(((((((err ? err : "Expected"_view) + " '"_view) + value) + "', got '"_view) + token.value) + "'."_view), tokens, _idx, _loc);

}

static const Token_fICA& parseRoot_MbR9(/*7:7*/ fu::view<Token_fICA> tokens, /*6:2*/ int& _idx, /*6:6*/ int& _loc)
{
    const Token_fICA& /*tokens|static*/ ret = consume_MbR9("sof"_view, fu::view<char>{}, tokens, _idx, _loc);
    _loc = _idx;
    return ret;
}

static const Token_fICA& parse_MbR9(/*1:1*/ fu::view<Token_fICA> tokens)
{
    int _idx = 0;
    int _loc = 0;
    return parseRoot_MbR9(tokens, _idx, _loc);
}

int fu_MAIN()
{
    return parse_MbR9(fu::view<Token_fICA> {{ Token_fICA { 1, 1, fu::str("sof"_fu) } }}).value.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn CallerNode(mut t?: i32, arr?: i32[])
        {
            for (mut i = 0; i < arr.len; i++) {
                return CallerNode(arr[i]);
                //     ^^^^^^^^^^
                // fn CallerNode: Arg #1, arr not assignable to host_arg:
                //      expect: []+252i32: ref copy resize
                //      actual: []+252i32: ref
            }

            return t;
        }

        fn main() = CallerNode();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>

static int CallerNode_MbR9(int, fu::view<int>);

#ifndef fu_NO_fdefs

static int CallerNode_MbR9(const int t, /*3:3*/ fu::view<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        return CallerNode_MbR9(arr[i], fu::view<int>{});
    };
    return t;
}

int fu_MAIN()
{
    return CallerNode_MbR9(0, fu::view<int>{});
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedCall

========

        struct Target       { index: i32; };
        struct SolvedNode   { target: Target; args: SolvedNode[]; };

        fn CallerNode(
            mut target: Target,
            mut args: SolvedNode[] = [],
            reorder?: i32[],
            conversions?: Target[][]): SolvedNode
        {
            if (reorder) {
                mut args_out: SolvedNode[]; args_out.resize(reorder.len);
                for (mut i = 0; i < reorder.len; i++) {
                    let idx = reorder[i];
                    if (idx >= 0)
                        args_out[i] = args[idx];
                }

                args = args_out;
            }

            for (mut argIdx = 0; argIdx < conversions.len; argIdx++) {
                let conversion = conversions[argIdx];
                for (mut i = 0; i < conversion.len; i++) {
                    args[argIdx] = CallerNode(conversion[i]);
                    //             ^^^^^^^^^^
                    // fn CallerNode: Arg #2, reorder not assignable to host_arg:
                    //      expect: []+252i32: ref copy resize
                    //      actual: []+252i32: ref copy
                }
            }

            return SolvedNode(:target, :args);
        }

        fn main() {
            return CallerNode(Target(0)).target.index;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Target_HIBL;
struct SolvedNode_CFRv;
static SolvedNode_CFRv CallerNode_MbR9(const Target_HIBL&, fu::vec<SolvedNode_CFRv>&&, fu::view<int>, fu::view<fu::vec<Target_HIBL>>);

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_CFRvdoX65E4
                                #define DEF_SolvedNode_CFRvdoX65E4
struct SolvedNode_CFRv
{
                                // shape_hash:    0883296a3dcde163
                                // non_triv_mask: 1000000000002000
    Target_HIBL target;
    fu::vec<SolvedNode_CFRv> args;
    SolvedNode_CFRv(const SolvedNode_CFRv&) = default;
    SolvedNode_CFRv(SolvedNode_CFRv&&) = default;
    SolvedNode_CFRv& operator=(SolvedNode_CFRv&&) = default;
    SolvedNode_CFRv& operator=(const SolvedNode_CFRv& selfrec) { return *this = SolvedNode_CFRv(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || args
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static SolvedNode_CFRv CallerNode_MbR9(/*F:F*/ const Target_HIBL& target, /*MOV*/ fu::vec<SolvedNode_CFRv>&& args, /*F:F*/ fu::view<int> reorder, /*F:F*/ fu::view<fu::vec<Target_HIBL>> conversions)
{
    if (reorder)
    {
        /*MOV*/ fu::vec<SolvedNode_CFRv> args_out {};
        args_out.resize(reorder.size());
        for (int i = 0; i < reorder.size(); i++)
        {
            const int /*reorder|static*/ idx = reorder[i];
            if ((idx >= 0))
                args_out.mutref(i) = SolvedNode_CFRv(args[idx]);

        };
        args = static_cast<fu::vec<SolvedNode_CFRv>&&>(args_out);
    };
    for (int argIdx = 0; argIdx < conversions.size(); argIdx++)
    {
        fu::view<Target_HIBL> /*conversions|static*/ conversion = conversions[argIdx];
        for (int i = 0; i < conversion.size(); i++)
        {
            args.mutref(argIdx) = CallerNode_MbR9(conversion[i], fu::vec<SolvedNode_CFRv>{}, fu::view<int>{}, fu::view<fu::vec<Target_HIBL>>{});
        };
    };
    return SolvedNode_CFRv { Target_HIBL(target), args.destructive_move() };
}

int fu_MAIN()
{
    return CallerNode_MbR9(Target_HIBL { 0 }, fu::vec<SolvedNode_CFRv>{}, fu::view<int>{}, fu::view<fu::vec<Target_HIBL>>{}).target.index;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn qSTACK(x: i32) {
            let rec = x & 1 && "rec ";
            let via = !rec && qSTACK(x / 2);
            return "\n" ~ rec ~ "at #" ~ x ~ via;
        }

        fn main() qSTACK(2).len - 2 - 4 - 8 - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

static fu::str qSTACK_MbR9(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str qSTACK_MbR9(const int x)
{
    fu::view<char> /*zeroes|static*/ rec = ((x & 1) ? "rec "_view : fu::view<char>{});
    fu::str via = (!rec ? qSTACK_MbR9((x / 2)) : fu::str{});
    return x7E_rA00((("\n"_view + rec) + "at #"_view), fu::i64dec(x)) + via;
}

int fu_MAIN()
{
    return (((qSTACK_MbR9(2).size() - 2) - 4) - 8) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        struct SolvedNode { items: SolvedNode[] };

        fn solve(node: SolvedNode) {
            mut events = 0;

            fn propagateType(shadow node: SolvedNode) {
                fn tryTrackLastUse() !(node.items.len & 1);
                let canDiscard = node.items.len != 0;
                fn discardIntoBlock() tryTrackLastUse();

                if (canDiscard && discardIntoBlock)
                    propagateType(node.items[0]);

                events++;
            }

            propagateType(node);
            return events;
        }

        fn main() solve(SolvedNode([ SolvedNode(), SolvedNode() ])) == 2 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SolvedNode_9NmD;
static void propagateType_MbR9(const SolvedNode_9NmD&, int&);

                                #ifndef DEF_SolvedNode_9NmDsj9S8bh
                                #define DEF_SolvedNode_9NmDsj9S8bh
struct SolvedNode_9NmD
{
                                // shape_hash:    7a2972f1d985a18c
                                // non_triv_mask: 4000000008000000
    fu::vec<SolvedNode_9NmD> items;
    SolvedNode_9NmD(const SolvedNode_9NmD&) = default;
    SolvedNode_9NmD(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(SolvedNode_9NmD&&) = default;
    SolvedNode_9NmD& operator=(const SolvedNode_9NmD& selfrec) { return *this = SolvedNode_9NmD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool tryTrackLastUse_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    return !(node.items.size() & 1);
}

static bool discardIntoBlock_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    return tryTrackLastUse_MbR9(node);
}

static void propagateType_MbR9(/*3:3*/ const SolvedNode_9NmD& node, /*3:3*/ int& events)
{
    const bool canDiscard = (node.items.size() != 0);
    if (canDiscard && discardIntoBlock_MbR9(node))
        propagateType_MbR9(node.items[0], events);

    events++;
}

static int solve_MbR9(/*1:1*/ const SolvedNode_9NmD& node)
{
    int events = 0;
    propagateType_MbR9(node, events);
    return events;
}

int fu_MAIN()
{
    if (solve_MbR9(SolvedNode_9NmD { fu::vec<SolvedNode_9NmD> {{ SolvedNode_9NmD{}, SolvedNode_9NmD{} }} }) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall

========

        fn path_relative(from: string, to: string): string {
            let min = from.len < to.len ? from.len : to.len;

            mut same = 0;
            for (mut i = 0; i < min; i++) {
                let a = from[i];
                let b = to[i];

                if (b != a)
                    break;

                if (b == '/')
                    same = i + 1;
            }

            mut res: string;
            for (mut i = same; i < from.len; i++)
                if (from[i] == '/')
                    res ~= "../";

            res ~= to.slice(same);
            return res;
        }

        fn main() {
            let from    = "/a/b/c";
            let to      = "/a/e/f";
            let rel     = path_relative(:from, :to);

            return rel == "../e/f" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str path_relative_MbR9(/*3:3*/ fu::view<char> from, /*3:3*/ fu::view<char> to)
{
    const int min = ((from.size() < to.size()) ? from.size() : to.size());
    int same = 0;
    for (int i = 0; i < min; i++)
    {
        const char /*from|static*/ a = from[i];
        const char /*to|static*/ b = to[i];
        if (b != a)
            break;
        else if (b == '/')
            same = (i + 1);

    };
    /*MOV*/ fu::str res {};
    for (int i_1 = same; i_1 < from.size(); i_1++)
    {
        if (from[i_1] == '/')
            res += "../"_view;

    };
    res += fu::get_view(to, same);
    return /*NRVO*/ res;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ from = "/a/b/c"_view;
    fu::view<char> /*static*/ to = "/a/e/f"_view;
    fu::str rel = path_relative_MbR9(from, to);
    if (rel == "../e/f"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        inline fn test(ref a: i32[]) {
            if ((a[0] + a[2]) & 1) {
                shadow ref a = a[0 .. 2];                       // GNUStmtExpr
                return a;
            }
            else {
                shadow ref a = a[2 .. 4];                       // PointlessLocal
                return a;
            }
        }

        inline fn sum(ref a: i32[..]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            for (mut i = 0; i < a.len; i++) a[i] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            return sum(test(a))[0] - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1, 2, 3, 4 }};
    fu::view_mut<int> a_1 {};
    fu::view<int> BL_1_v {};
    return (__extension__ (
    {
        fu::view_mut<int> a_2 {};
        fu::view_mut<int> a_3 {};
        a_1.ptr_reassign((((a[0] + a[2]) & 1) ? (a_2.ptr_reassign(fu::get_view_mut(a, 0, 2)), a_2) : (a_3.ptr_reassign(fu::get_view_mut(a, 2, 4)), a_3)));
        int sum = 0;
        for (int i = 0; i < a_1.size(); i++)
            sum += a_1[i];

        for (int i_1 = 0; i_1 < a_1.size(); i_1++)
            a_1.mutref(i_1) = sum;

        BL_1_v.ptr_reassign(a_1);
        (void)0;
    }), BL_1_v)[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        inline fn test(ref a: i32[], ref b: i32[]) {
            if ((a[0] + b[0]) & 1)
                return a;

            return b;
        }

        inline fn sum(ref a: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            a.shrink(1);
            a[0] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2 ];
            mut b = [ 3, 4 ];
            return sum(test(a, b))[0] - 7;                      // GNUStmtExpr
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1, 2 }};
    fu::vec<int> b = fu::vec<int> {{ 3, 4 }};
    fu::vec_range_mut<int> a_1 {};
    fu::view<int> BL_1_v {};
    return (__extension__ (
    {
        a_1.ptr_reassign((((a[0] + b[0]) & 1) ? a : b));
        int sum = 0;
        for (int i = 0; i < a_1.size(); i++)
            sum += a_1[i];

        a_1.shrink(1);
        a_1.mutref(0) = sum;
        BL_1_v.ptr_reassign(a_1);
        (void)0;
    }), BL_1_v)[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        inline fn hey(ref arr: i32[], a: i32) {
            if (a & 1) {
                arr.grow_if_oob(a)++;

            }

            return arr;
        }

        fn main() {
            mut a = [ 1 ];
            return a[0] - hey(a, 1)[1];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int _0;
    int a_1;
    return (_0 = a[0], (_0 - (a_1 = 1, ((a_1 & 1) && ((((a.size() <= a_1) && (a.grow((a_1 + 1)), 0)), a.mutref(a_1))++, 0)), a)[1]));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========

        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        inline fn hey(ref arr: i32[], a: i32) {
            if (a & 1) {
                arr.grow_if_oob(a)++;

                return arr[0 .. a + 1];

            }

            return arr;
        }

        fn main() {
            mut a = [ 1 ];
            return a[0] - hey(a, 1)[1];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int _0;
    int a_1;
    return (_0 = a[0], (_0 - (a_1 = 1, ((a_1 & 1) ? ((((a.size() <= a_1) && (a.grow((a_1 + 1)), 0)), a.mutref(a_1))++, fu::get_view(a, 0, (a_1 + 1))) : a))[1]));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

========

        fn serializeType(type: string, debug: string)
            debug ~ ":" ~ type;

        fn mangleArguments(args: $T[..]): string {
            mut mangle = "";
            for (mut i = 0; i < args.len; i++) {
                if (i) mangle ~= ",";
                mangle ~= serializeType(args[i], debug: "M");
            }
            return mangle;
        }

        fn trySpecialize(args: string[], ref args_mangled: string) {
            args_mangled ||= mangleArguments(args);
            return args_mangled.len;
        }

        fn main() {
            mut args_mangled: string;
            return trySpecialize([ "a", "b" ], args_mangled) - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str serializeType_MbR9(/*3:3*/ fu::view<char> type, /*3:3*/ fu::view<char> debug)
{
    return (debug + ":"_view) + type;
}

                                #ifndef DEF_mangleArguments_gXXWk4FfCXc
                                #define DEF_mangleArguments_gXXWk4FfCXc
inline static fu::str mangleArguments_gXXW(/*1:1*/ fu::view<fu::str> args)
{
    /*MOV*/ fu::str mangle = fu::str(""_fu);
    for (int i = 0; i < args.size(); i++)
    {
        if (i)
            mangle += ","_view;

        mangle += serializeType_MbR9(args[i], "M"_view);
    };
    return /*NRVO*/ mangle;
}
                                #endif

static int trySpecialize_MbR9(/*3:3*/ fu::view<fu::str> args, /*2:2*/ fu::vec_range_mut<char> args_mangled)
{
    if (!(args_mangled))
        args_mangled = mangleArguments_gXXW(args);

    return args_mangled.size();
}

int fu_MAIN()
{
    fu::str args_mangled {};
    return trySpecialize_MbR9(fu::view<fu::str> {{ fu::str("a"_fu), fu::str("b"_fu) }}, args_mangled) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_COWRestrict

========

        fn serializeType(type: string, debug: string)
            debug ~ ":" ~ type;

        fn mangleArguments(args: $T[..]): string {
            mut mangle = "";
            for (mut i = 0; i < args.len; i++) {
                if (i) mangle ~= ",";
                mangle ~= serializeType(args[i], debug: "M");
            }
            return mangle;
        }

        fn trySpecialize(args: string[], ref args_mangled: string) {
            args_mangled ||= mangleArguments(args);
            return args_mangled.len;
        }

        fn main() {
            mut args_mangled: string;
            return trySpecialize([ "a", "b" ], args_mangled) - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str serializeType_MbR9(/*3:3*/ fu::view<char> type, /*3:3*/ fu::view<char> debug)
{
    return (debug + ":"_view) + type;
}

                                #ifndef DEF_mangleArguments_gXXWk4FfCXc
                                #define DEF_mangleArguments_gXXWk4FfCXc
inline static fu::str mangleArguments_gXXW(/*1:1*/ fu::view<fu::str> args)
{
    /*MOV*/ fu::str mangle {};
    for (int i = 0; i < args.size(); i++)
    {
        if (i)
            mangle += ","_view;

        mangle += serializeType_MbR9(args[i], "M"_view);
    };
    return /*NRVO*/ mangle;
}
                                #endif

static int trySpecialize_MbR9(/*3:3*/ fu::view<fu::str> args, /*2:2*/ fu::vec_range_mut<char> args_mangled)
{
    if (!(args_mangled))
        args_mangled = mangleArguments_gXXW(args);

    return args_mangled.size();
}

int fu_MAIN()
{
    fu::str args_mangled {};
    return trySpecialize_MbR9(fu::view<fu::str> {{ fu::str("a"_fu), fu::str("b"_fu) }}, args_mangled) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_COWRestrict

========

        let EMIT_CPP = 1 << 0;
        let EMIT_OBJ = 1 << 1;
        let EMIT_BIN = 1 << 2;

        struct Cmd { self: string; options: i32 };

        inline fn unlessHasExt(str: string) {
            let idx = str.find('.');
            if (idx > 0)
                return [];

            return str;
        }

        fn parseOptions(argv: string[]) {
            mut idx = 0;
            fn next(): string {
                let i = idx++;
                if (i < argv.len) return argv[i];
                return "";
            }

            let self = next();
            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.
                return [];

            mut options: i32;
            mut val = next();
            while (val.len > 1 && val[0] == '-') {
                mut opt = val;
                if (opt[1] != '-') {
                    opt = [ opt[1] ];
                    val = '-' ~ val.slice(2);
                    if (val == "-")
                        val = next();
                }
                else
                    val = next();

                fn option(short: string, o: i32) {
                    if (opt == short) {
                        options |= o;
                        opt = "";
                    }
                }

                option("c", EMIT_CPP);
                option("o", EMIT_OBJ);
                option("b", EMIT_BIN);

                if (opt)
                    throw("Unknown option: '" ~ opt ~ "'.");
            }

            return Cmd(unlessHasExt(self), options);
        }

        fn main() = parseOptions([ "./hey", "-c", "-b" ]).options - (EMIT_CPP | EMIT_BIN);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Cmd_JaGQ;

                                #ifndef DEF_EMIT_CPP
                                #define DEF_EMIT_CPP
inline constexpr int EMIT_CPP = (1 << 0);
                                #endif

                                #ifndef DEF_EMIT_OBJ
                                #define DEF_EMIT_OBJ
inline constexpr int EMIT_OBJ = (1 << 1);
                                #endif

                                #ifndef DEF_EMIT_BIN
                                #define DEF_EMIT_BIN
inline constexpr int EMIT_BIN = (1 << 2);
                                #endif

                                #ifndef DEF_Cmd_JaGQnDIB49b
                                #define DEF_Cmd_JaGQnDIB49b
struct Cmd_JaGQ
{
                                // shape_hash:    1baa45b95eb14d18
                                // non_triv_mask: 0000800000002000
    fu::str self;
    int options;
    explicit operator bool() const noexcept
    {
        return false
            || self
            || options
        ;
    }
};
                                #endif

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> next_MbR9(/*3:3*/ fu::view<fu::str> argv, /*3:2*/ int& idx)
{
    const int i = idx++;
    if (i < argv.size())
        return argv[i];
    else
        return str_00000000000;

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static void option_MbR9(/*F:F*/ fu::view<char> sHort, const int o, /*F:7*/ int& options, /*F:F*/ fu::vec_range_mut<char> opt)
{
    if (opt == sHort)
    {
        options |= o;
        opt = fu::str(""_fu);
    };
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static Cmd_JaGQ parseOptions_MbR9(/*1:1*/ fu::view<fu::str> argv)
{
    int idx = 0;
    fu::vec_range<char> /*argv|static*/ self = next_MbR9(argv, idx);
    if (argv.size() == 1)
    {
        return Cmd_JaGQ{};
    }
    else
    {
        int options {};
        fu::str val = fu::str(next_MbR9(argv, idx));
        while ((val.size() > 1) && (val[0] == '-'))
        {
            fu::str opt = fu::str(val);
            if (opt[1] != '-')
            {
                opt = fu::vec<char> {{ opt[1] }};
                val = ('-' + fu::get_view(val, 2));
                if (val == "-"_view)
                    val = next_MbR9(argv, idx);

            }
            else
                val = next_MbR9(argv, idx);

            option_MbR9("c"_view, EMIT_CPP, options, opt);
            option_MbR9("o"_view, EMIT_OBJ, options, opt);
            option_MbR9("b"_view, EMIT_BIN, options, opt);
            if (opt)
                fu::fail((("Unknown option: '"_view + opt) + "'."_view));

        };
        int idx_1;
        return Cmd_JaGQ { fu::str((idx_1 = find_ZKsG(self, '.'), ((idx_1 > 0) ? fu::vec_range<char>{} : self))), options };
    };
}

int fu_MAIN()
{
    return parseOptions_MbR9(fu::view<fu::str> {{ fu::str("./hey"_fu), fu::str("-c"_fu), fu::str("-b"_fu) }}).options - (EMIT_CPP | EMIT_BIN);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        let EMIT_CPP = 1 << 0;
        let EMIT_OBJ = 1 << 1;
        let EMIT_BIN = 1 << 2;

        struct Cmd { self: string; options: i32 };

        inline fn unlessHasExt(str: string) {
            let idx = str.find('.');
            if (idx > 0)
                return [];

            return str;
        }

        fn parseOptions(argv: string[]) {
            mut idx = 0;
            fn next(): string {
                let i = idx++;
                if (i < argv.len) return argv[i];
                return "";
            }

            let self = next();
            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.
                return [];

            mut options: i32;
            mut val = next();
            while (val.len > 1 && val[0] == '-') {
                mut opt = val;
                if (opt[1] != '-') {
                    opt = [ opt[1] ];
                    val = '-' ~ val.slice(2);
                    if (val == "-")
                        val = next();
                }
                else
                    val = next();

                fn option(short: string, o: i32) {
                    if (opt == short) {
                        options |= o;
                        opt = "";
                    }
                }

                option("c", EMIT_CPP);
                option("o", EMIT_OBJ);
                option("b", EMIT_BIN);

                if (opt)
                    throw("Unknown option: '" ~ opt ~ "'.");
            }

            return Cmd(unlessHasExt(self), options);
        }

        fn main() = parseOptions([ "./hey", "-c", "-b" ]).options - (EMIT_CPP | EMIT_BIN);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Cmd_JaGQ;

                                #ifndef DEF_EMIT_CPP
                                #define DEF_EMIT_CPP
inline constexpr int EMIT_CPP = (1 << 0);
                                #endif

                                #ifndef DEF_EMIT_OBJ
                                #define DEF_EMIT_OBJ
inline constexpr int EMIT_OBJ = (1 << 1);
                                #endif

                                #ifndef DEF_EMIT_BIN
                                #define DEF_EMIT_BIN
inline constexpr int EMIT_BIN = (1 << 2);
                                #endif

                                #ifndef DEF_Cmd_JaGQnDIB49b
                                #define DEF_Cmd_JaGQnDIB49b
struct Cmd_JaGQ
{
                                // shape_hash:    1baa45b95eb14d18
                                // non_triv_mask: 0000800000002000
    fu::str self;
    int options;
    explicit operator bool() const noexcept
    {
        return false
            || self
            || options
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> next_MbR9(/*3:3*/ fu::view<fu::str> argv, /*3:2*/ int& idx)
{
    const int i = idx++;
    if (i < argv.size())
        return argv[i];
    else
        return (*(fu::str*)fu::NIL);

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static void option_MbR9(/*F:F*/ fu::view<char> sHort, const int o, /*F:7*/ int& options, /*F:F*/ fu::vec_range_mut<char> opt)
{
    if (opt == sHort)
    {
        options |= o;
        opt = fu::str{};
    };
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static Cmd_JaGQ parseOptions_MbR9(/*1:1*/ fu::view<fu::str> argv)
{
    int idx = 0;
    fu::vec_range<char> /*argv|zeroes|static*/ self = next_MbR9(argv, idx);
    if (argv.size() == 1)
    {
        return Cmd_JaGQ{};
    }
    else
    {
        int options {};
        fu::str val = fu::str(next_MbR9(argv, idx));
        while ((val.size() > 1) && (val[0] == '-'))
        {
            fu::str opt = fu::str(val);
            if (opt[1] != '-')
            {
                opt = fu::vec<char> {{ opt[1] }};
                val = ('-' + fu::get_view(val, 2));
                if (val == "-"_view)
                    val = next_MbR9(argv, idx);

            }
            else
                val = next_MbR9(argv, idx);

            option_MbR9("c"_view, EMIT_CPP, options, opt);
            option_MbR9("o"_view, EMIT_OBJ, options, opt);
            option_MbR9("b"_view, EMIT_BIN, options, opt);
            if (opt)
                fu::fail((("Unknown option: '"_view + opt) + "'."_view));

        };
        int idx_1;
        return Cmd_JaGQ { fu::str((idx_1 = find_ZKsG(self, '.'), ((idx_1 > 0) ? fu::vec_range<char>{} : self))), options };
    };
}

int fu_MAIN()
{
    return parseOptions_MbR9(fu::view<fu::str> {{ fu::str("./hey"_fu), fu::str("-c"_fu), fu::str("-b"_fu) }}).options - (EMIT_CPP | EMIT_BIN);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        fn withPrefixed(b: byte, view: byte[..], fn) {
            mut tmp: string;
            return fn(view.len > 1 ? view : tmp = b ~ view);
        }

        fn main() withPrefixed('a', "b"): |ab| return ab.len - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char b = 'a';
    fu::view<char> /*static*/ view = "b"_view;
    fu::str tmp {};
    fu::view<char> /*tmp|view*/ ab = ((view.size() > 1) ? view : (tmp = (b + view)));
    return ab.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        fn tryIntersect(left: byte[..], right: byte[..], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;


            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : qq.byte ~ left[lq && 1 .. left.len],

                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_wiDRRwhjUB0
                                #define STR_wiDRRwhjUB0
static const fu::str str_wiDRRwhjUB0 fu_INIT_PRIORITY(1001) { "7a012345678900123456789001234567890"_fu };
                                #endif

                                #ifndef STR_Vk4wz1ztpik
                                #define STR_Vk4wz1ztpik
static const fu::str str_Vk4wz1ztpik fu_INIT_PRIORITY(1001) { "5a012345678900123456789001234567890"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    {
        fu::vec_range<char> /*static*/ left = str_wiDRRwhjUB0;
        fu::vec_range<char> /*static*/ right = str_Vk4wz1ztpik;
        const char /*left|static*/ l = left[0];
        const char /*right|static*/ r = right[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (!(fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(right, (rq ? 1 : 0), right.size())))
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            fu::str m = ((qq == ll) ? fu::str(left) : ((qq == rr) ? fu::str(right) : (char(qq) + fu::get_view(left, (lq ? 1 : 0), left.size()))));
            const bool left_1 = (qq == ll);
            if ((m == "7a012345678900123456789001234567890"_view) && left_1)
                return 0;
            else
                return 100;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn tryIntersect(left: byte[..], right: byte[..], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;


            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : qq.byte ~ left[lq && 1 .. left.len],

                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_wiDRRwhjUB0
                                #define STR_wiDRRwhjUB0
static const fu::str str_wiDRRwhjUB0 fu_INIT_PRIORITY(1001) { "7a012345678900123456789001234567890"_fu };
                                #endif

                                #ifndef STR_Vk4wz1ztpik
                                #define STR_Vk4wz1ztpik
static const fu::str str_Vk4wz1ztpik fu_INIT_PRIORITY(1001) { "5a012345678900123456789001234567890"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    {
        const fu::str& /*static*/ left = str_wiDRRwhjUB0;
        const fu::str& /*static*/ right = str_Vk4wz1ztpik;
        const char /*left|static*/ l = left[0];
        const char /*right|static*/ r = right[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (!(fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(right, (rq ? 1 : 0), right.size())))
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            fu::str m = ((qq == ll) ? fu::str(left) : ((qq == rr) ? fu::str(right) : (char(qq) + fu::get_view(left, (lq ? 1 : 0), left.size()))));
            const bool left_1 = (qq == ll);
            if ((m == "7a012345678900123456789001234567890"_view) && left_1)
                return 0;
            else
                return 100;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn tryIntersect(left: byte[..], right: byte[..], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;


            mut tmp: string;
            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : tmp = (qq.byte ~ left[lq && 1 .. left.len]),

                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    {
        fu::view<char> /*static*/ left = "7a012345678900123456789001234567890"_view;
        fu::view<char> /*static*/ right = "5a012345678900123456789001234567890"_view;
        const char /*left|static*/ l = left[0];
        const char /*right|static*/ r = right[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (!(fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(right, (rq ? 1 : 0), right.size())))
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            fu::str tmp {};
            fu::view<char> /*tmp|right|left*/ m = ((qq == ll) ? left : ((qq == rr) ? right : (tmp = (char(qq) + fu::get_view(left, (lq ? 1 : 0), left.size())))));
            const bool left_1 = (qq == ll);
            if ((m == "7a012345678900123456789001234567890"_view) && left_1)
                return 0;
            else
                return 100;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn tryIntersect(left: byte[..], right: byte[..], ifLeft, ifNotLeft) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 .. left.len] != right[rq && 1 .. right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;

            if (qq == ll)   ifLeft();
            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 .. right.len]);

            return true;
        }

        fn TP_get(typeParams!: string, id!: string)
        {
            id || throw("Assertion failed.");

            mut start = 0;
            for (;;)
            {
                let idx = typeParams.find(id, :start);
                if (idx < 0)
                    return -1;

                start = id.len;
                if (typeParams[start] == ' ')
                    return start + 1;
            }
        }

        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {
            let start = TP_get(:typeParams, :id);
            if (start < 0) {
                typeParams ~= id;
                typeParams ~= canon;
                typeParams ~= '	';
                return true;
            }

            let end = typeParams.find('	', :start);
            return tryIntersect(typeParams[start .. end], canon,
                ifLeft: || { /* egyptian */
                    return true;
                },                  // <- Lint complained about the nested curlies here ...
                ifNotLeft: |inter|
                { /* pedantic */
                    typeParams.splice(start, end - start, inter);
                    return true;
                });                 // <-  ... and here.

            return false;
        }

        fn main() {
            mut typeParams = "$T 3hey	";

            // I was fiddling with jumps, and broke return type reporting,
            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),
            //   adding this because the test didn't care.
            if (TP_upsert(:typeParams, id: "$T", "x4x"))
                return 202;

            return TP_upsert(:typeParams, id: "$T", "4hey")
                && typeParams == "$T 7hey	" ? 0 : 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_CuljWmpZyt3
                                #define STR_CuljWmpZyt3
static const fu::str str_CuljWmpZyt3 fu_INIT_PRIORITY(1001) { "x4x"_fu };
                                #endif

                                #ifndef STR_G139tn59Hxj
                                #define STR_G139tn59Hxj
static const fu::str str_G139tn59Hxj fu_INIT_PRIORITY(1001) { "Assertion failed."_fu };
                                #endif

                                #ifndef STR_ipAOgP0k7Zc
                                #define STR_ipAOgP0k7Zc
static const fu::str str_ipAOgP0k7Zc fu_INIT_PRIORITY(1001) { "4hey"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

static int TP_get_MbR9(/*3:3*/ fu::view<char> typeParams, /*3:3*/ fu::view<char> id)
{
    if (id)
    {
        int start = 0;
        for (; ; )
        {
            const int idx = find_BNNw(typeParams, id, start);
            if (idx < 0)
                return -1;
            else
            {
                start = id.size();
                if (typeParams[start] == ' ')
                    return start + 1;

            };
        };
    }
    else
        fu::fail(fu::str(str_G139tn59Hxj));

}

                                #ifndef DEF_find_rkz0SQgq7mk
                                #define DEF_find_rkz0SQgq7mk
inline int find_rkz0(/*F:F*/ fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_ZKsG(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static bool TP_upsert_MbR9(/*1:1*/ fu::vec_range_mut<char> typeParams, /*7:7*/ fu::view<char> id, /*7:7*/ fu::vec_range<char> canon)
{
    const int start = TP_get_MbR9(typeParams, id);
    if (start < 0)
    {
        typeParams += id;
        typeParams += canon;
        typeParams += '\t';
        return true;
    }
    else
    {
        const int end = find_rkz0(typeParams, '\t', start);
        fu::view<char> /*typeParams*/ left = fu::get_view(typeParams, start, end);
        const char /*left|static*/ l = left[0];
        const char /*canon|static*/ r = canon[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(canon, (rq ? 1 : 0), canon.size()))
            return false;
        else
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            if (qq == ll)
                return true;
            else
            {
                fu::str inter = ((qq == rr) ? fu::str(canon) : x7E_rA00(fu::i64dec(qq), fu::get_view(canon, (rq ? 1 : 0), canon.size())));
                typeParams.splice(start, (end - start), inter);
                return true;
            };
        };
    };
}

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str typeParams = fu::str("$T 3hey\t"_fu);
    if (TP_upsert_MbR9(typeParams, "$T"_view, str_CuljWmpZyt3))
        return 202;
    else if (TP_upsert_MbR9(typeParams, "$T"_view, str_ipAOgP0k7Zc) && (typeParams == "$T 7hey\t"_view))
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn fails_with_silly_error(ref set: i32[], i) {

            set  ||= i;  //  outputing a decent err msg
            return set;
        }

        fn main() {
            mut set = [ 0 ];
            fails_with_silly_error(set, 2);

            mut sum = 0;
            for (mut i = 0; i < set.len; i++) sum += set[i];
            return sum - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:18+3[0m:

[2m      |         fn fails_with_silly_error(ref set: i32[], i) {[0m
[2m      | [0m
[2m    4 | [0m            set  [31;1m||=[0m i;  //  outputing a decent err msg
[2m      |             return set;[0m
[2m      |         }[0m

	Bad call to [94;1m||=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[][0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m||=[0m at [2m../../../../../[0mprelude[2m 213:10+3[0m:
[2m  213 | [0minfix fn [31;1m||=[0m (mut ref a: <T>, inline b: T): &mut T = a || (a = b);

	    [35;3marg[0m [94;1m||=[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi32[0m[35;3m[][0m <-> [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mfails_with_silly_error[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m) at [2m2:12+22[0m
                [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        fn fails_with_silly_error(ref set: i32[], i) {
 // this BUGged out instead of
            set   ~= i;  //  outputing a decent err msg
            return set;
        }

        fn main() {
            mut set = [ 0 ];
            fails_with_silly_error(set, 2);

            mut sum = 0;
            for (mut i = 0; i < set.len; i++) sum += set[i];
            return sum - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_fails_with_silly_error_KHzQtDok0Rf
                                #define DEF_fails_with_silly_error_KHzQtDok0Rf
inline static fu::view<int> fails_with_silly_error_KHzQ(/*3:3*/ fu::vec_range_mut<int> set, const int i)
{
    set += i;
    return set;
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> set = fu::vec<int> {{ 0 }};
    fails_with_silly_error_KHzQ(set, 2);
    int sum = 0;
    for (int i = 0; i < set.size(); i++)
        sum += set[i];

    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn solve(ref output: i32[], input: i32[])
        {
            fn SLOW_traverse(visit)
                for (mut i = 0; i < input.len; i++)
                    visit(input[i]);

            fn qSTACK(id: i32, implicit _current_fnort: i32) {
                SLOW_traverse: |x|
                    if (id == x)
                        return id || _current_fnort;

                return 0;
            }

            fn doTrySpecialize(target: i32)
            {
                fn updateScope(result: i32)
                    output ~= result || qSTACK(result + 1);

                if (target & 1) {
                    updateScope(target); // 1 - 1
                    return;
                }

                let implicit _current_fnort = target;
                updateScope(target / 2); // 4 - 2, 2 - 1, 0 - 0
            }

            let implicit _current_fnort = 1;

            doTrySpecialize(1);
            for (mut i = 0; i < input.len; i++)
                doTrySpecialize(input[i]);
        }

        fn main() {
            mut output: i32[];
            solve(output, input: [ 0, 3 ]);

            return output[0] == 1
                && output[1] == 0
                && output[2] == 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int qSTACK_MbR9(const int id, /*7:7*/ const int _current_fnort, /*7:7*/ fu::view<int> input)
{
    for (int i = 0; i < input.size(); i++)
    {
        const int /*input|static*/ x = input[i];
        if (id == x)
            return (id ? id : _current_fnort);

    };
    return 0;
}

static fu::view<int> updateScope_GL0m(const int result, /*F:F*/ fu::vec_range_mut<int> output, /*F:F*/ fu::view<int> input, /*F:F*/ const int _current_fnort)
{
    return (output += (result ? result : qSTACK_MbR9((result + 1), _current_fnort, input)));
}

static void doTrySpecialize_MbR9(const int target, /*F:F*/ fu::vec_range_mut<int> output, /*F:F*/ fu::view<int> input, /*F:F*/ const int _current_fnort)
{
    if (target & 1)
        updateScope_GL0m(target, output, input, _current_fnort);
    else
        updateScope_GL0m((target / 2), output, input, target);

}

static void solve_MbR9(/*1:1*/ fu::vec_range_mut<int> output, /*3:3*/ fu::view<int> input)
{
    const int _current_fnort = 1;
    doTrySpecialize_MbR9(1, output, input, _current_fnort);
    for (int i = 0; i < input.size(); i++)
        doTrySpecialize_MbR9(input[i], output, input, _current_fnort);

}

int fu_MAIN()
{
    fu::vec<int> output {};
    solve_MbR9(output, fu::view<int> {{ 0, 3 }});
    if ((output[0] == 1) && (output[1] == 0) && (output[2] == 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        fn noop_let_lax(lax ref x: i32) {
            let lax y = x;
        }

        fn main() {
            mut x = 0;
            noop_let_lax(x);
            return x;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:12+12[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mnoop_let_lax[0m(lax ref x: i32) {
[2m      |             let lax y = x;[0m
[2m      |         }[0m

	[35;3mfn[0m [94;1mnoop_let_lax[0m does nothing: returns void and has no effects. Make it [35;3mlax[0m if this is intentional.

========


        lax                
        fn noop_let_lax(lax ref x: i32) {
            let lax y = x;
        }

        fn main() {
            mut x = 0;
            noop_let_lax(x);
            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    return x;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        fn compile_begin(mul: i32) {
            let id = mul * 10;
            let implicit options = getModule(:id);
            return compile(:id);
        }

        fn compile(implicit options: i32, id: i32) {
            return getModule(id) + options;
        }

        fn getModule(id: i32, implicit ctx: i32) {
            return ctx + id;
        }

        import _0;

        fn main() {
            let implicit ctx = 2;
            return compile_begin(3) - 64;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int compile_begin_MbR9(int, int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ctx = 2;
    return compile_begin_MbR9(3, ctx) - 64;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int getModule_MbR9(const int id, /*3:3*/ const int ctx)
{
    return ctx + id;
}

int compile_MbR9(const int id, /*7:7*/ const int options, /*7:7*/ const int ctx)
{
    return getModule_MbR9(id, ctx) + options;
}

int compile_begin_MbR9(const int mul, /*3:3*/ const int ctx)
{
    const int id = (mul * 10);
    const int options = getModule_MbR9(id, ctx);
    return compile_MbR9(id, options, ctx);
}

#endif

========

        // An empty file.

        fn sqr(x: i32) x * x;

        import _0;
        import _1;

        fn main() = 0.sqr;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int sqr_LtD7(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return sqr_LtD7(0);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int sqr_LtD7(const int x)
{
    return x * x;
}

#endif

========

        struct vec2 {
            x?: f32;
            y?: f32;
        };

        inline fn *=(ref a: vec2, b: f32) {
            a.x *= b;
            a.y *= b;
            return a;
        }

        fn main() {
            mut v = vec2(1, 1);
            v *= 0.5; // BUG: Considering copy or move for incompatible types: vec2: copy <- f32: copy
            return v.x.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec2_ahM2;

                                #ifndef DEF_vec2_ahM2j5Y44Ua
                                #define DEF_vec2_ahM2j5Y44Ua
struct vec2_ahM2
{
                                // shape_hash:    860b7c05f5c420f7
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec2_ahM2 v = vec2_ahM2 { 1.0f, 1.0f };

    {
        const float b = 0.5f;
        v.x *= b;
        v.y *= b;
    };
    return int(v.x);
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x: f32; y: f32; z: f32; };

        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);

        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        import _0;

        struct Atmosphere { pView: vec3; rPlanet: f32; };

        let rEarth: f32 = 1e3;

        fn Atmosphere(
            altitude: f32,
            rPlanet: f32 = rEarth,
            vUp = vec3(z: 1)) // <- this crashes
        {
            let pView = vUp * (rPlanet + altitude);
            return Atmosphere(:rPlanet, :pView);
        }

        import _0;
        import _1;

        fn main() {
            let atmo = Atmosphere(altitude: 1e2);
            return atmo.pView.z == 11e2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Atmosphere_UHgM;
struct vec3_vMFc;

                                #ifndef DEF_rEarth
                                #define DEF_rEarth
inline constexpr float rEarth = 1e3f;
                                #endif
Atmosphere_UHgM Atmosphere_LtD7(float, float, const vec3_vMFc&);

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_Atmosphere_UHgMYLTTDki
                                #define DEF_Atmosphere_UHgMYLTTDki
struct Atmosphere_UHgM
{
                                // shape_hash:    28c4dd28cab0985d
                                // non_triv_mask: 0000000000000000
    vec3_vMFc pView;
    float rPlanet;
    explicit operator bool() const noexcept
    {
        return false
            || pView
            || rPlanet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    float z;
    float x;
    float y;
    const Atmosphere_UHgM atmo = Atmosphere_LtD7(1e2f, rEarth, (z = 1.0f, x = 0.0f, y = 0.0f, vec3_vMFc { x, y, z }));
    if (atmo.pView.z == 11e2f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
struct Atmosphere_UHgM;
struct vec3_vMFc;

                                #ifndef DEF_rEarth
                                #define DEF_rEarth
inline constexpr float rEarth = 1e3f;
                                #endif

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_Atmosphere_UHgMYLTTDki
                                #define DEF_Atmosphere_UHgMYLTTDki
struct Atmosphere_UHgM
{
                                // shape_hash:    28c4dd28cab0985d
                                // non_triv_mask: 0000000000000000
    vec3_vMFc pView;
    float rPlanet;
    explicit operator bool() const noexcept
    {
        return false
            || pView
            || rPlanet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Atmosphere_UHgM Atmosphere_LtD7(const float altitude, const float rPlanet, /*7:7*/ const vec3_vMFc& vUp)
{
    float b;
    const vec3_vMFc pView = (b = (rPlanet + altitude), vec3_vMFc { (vUp.x * b), (vUp.y * b), (vUp.z * b) });
    return Atmosphere_UHgM { vec3_vMFc(pView), rPlanet };
}

#endif

// N_SD_HasStaticInit

========

        inline fn vec3(fill!: f32) fill;

        let kMie_min: f32 = 3e-6;
        inline fn Atmo(kMie = vec3(fill: kMie_min)) = kMie;     // PointlessLocal

        fn main() Atmo == 3e-6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    float kMie;
    if ((kMie = kMie_min, kMie) == 3e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


        fn main() Atmosphere == 6e-6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec3_vMFc kMie;
    if ((kMie = vec3_vMFc { {/*unused non-zst*/}, kMie_min, {/*unused non-zst*/} }, (kMie.y * 2.0f)) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;

        pub import _0;
        fn main() Atmosphere == 6e-6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec3_vMFc kMie;
    if ((kMie = vec3_vMFc { {/*unused non-zst*/}, kMie_min, {/*unused non-zst*/} }, (kMie.y * 2.0f)) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

// N_SD_HasStaticInit

========

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        pub import _0;
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


        fn main() Atmosphere == 6e-6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec3_vMFc kMie;
    if ((kMie = vec3_vMFc { {/*unused non-zst*/}, kMie_min, {/*unused non-zst*/} }, (kMie.y * 2.0f)) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        pub import _0;
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;

        pub import _1;
        fn main() Atmosphere == 6e-6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec3_vMFc kMie;
    if ((kMie = vec3_vMFc { {/*unused non-zst*/}, kMie_min, {/*unused non-zst*/} }, (kMie.y * 2.0f)) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

// N_SD_HasStaticInit

========

        struct Loop { l: i32 };
        struct Ring { r: i32 };
        struct Mesh { m: i32 };

        fn op(ref m: Mesh, x: i32, l: Loop) m.m += l.l + x;
        fn op(ref m: Mesh, r: Ring, x: i32) m.m *= r.r + x;
        fn op(using ref m: Mesh, l: Loop, r: Ring, x: i32) {
            l.op(:x);
            r.op(:x);
        }

        fn main() {
            mut m = Mesh(1);
            m.op(Loop(2), Ring(7), x: 1);
            return m.m == 32 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Mesh_cpIQ;
struct Loop_qnpw;
struct Ring_IVSo;

                                #ifndef DEF_Mesh_cpIQdojKRb4
                                #define DEF_Mesh_cpIQdojKRb4
struct Mesh_cpIQ
{
                                // shape_hash:    ab71e317451e1d03
                                // non_triv_mask: 0000000000000000
    int m;
    explicit operator bool() const noexcept
    {
        return false
            || m
        ;
    }
};
                                #endif

                                #ifndef DEF_Loop_qnpwkHBQQ12
                                #define DEF_Loop_qnpwkHBQQ12
struct Loop_qnpw
{
                                // shape_hash:    03dc65d0d2ba4a71
                                // non_triv_mask: 0000000000000000
    int l;
    explicit operator bool() const noexcept
    {
        return false
            || l
        ;
    }
};
                                #endif

                                #ifndef DEF_Ring_IVSovtwNkx0
                                #define DEF_Ring_IVSovtwNkx0
struct Ring_IVSo
{
                                // shape_hash:    2ebb4b1de2733460
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int op_4n4A(/*7:7*/ Mesh_cpIQ& m, const int x, /*7:7*/ const Loop_qnpw& l)
{
    return (m.m += (l.l + x));
}

static int op_4wfu(/*7:7*/ Mesh_cpIQ& m, /*7:7*/ const Ring_IVSo& r, const int x)
{
    return (m.m *= (r.r + x));
}

static void op_GL0m(/*B:B*/ Mesh_cpIQ& m, /*F:F*/ const Loop_qnpw& l, /*F:F*/ const Ring_IVSo& r, const int x)
{
    op_4n4A(m, x, l);
    op_4wfu(m, r, x);
}

int fu_MAIN()
{
    Mesh_cpIQ m = Mesh_cpIQ { 1 };
    op_GL0m(m, Loop_qnpw { 2 }, Ring_IVSo { 7 }, 1);
    if (m.m == 32)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        pub struct MultiDraw { id: i32; }

        import _0;
        type ViewQuads = MultiDraw;

        fn ViewQuads(id!: i32, populate!): ViewQuads {
            mut vq = ViewQuads(:id);
            populate(vq);
            return vq;
        }

        import _1;
        fn ViewQuads(id!: i32, camera!: i32): ViewQuads {
            return ViewQuads(:id, populate: |ref vq| vq.id += camera);
        }

        fn main() {
            return ViewQuads(id: 2, camera: 5).id - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct MultiDraw_rMz8;

                                #ifndef DEF_MultiDraw_rMz8jHV5O63
                                #define DEF_MultiDraw_rMz8jHV5O63
struct MultiDraw_rMz8
{
                                // shape_hash:    79ea008426ac8342
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_populate_7AcArHwMnY0
                                #define DEF_populate_7AcArHwMnY0
inline static int populate_7AcA(/*3:3*/ MultiDraw_rMz8& vq, /*3:3*/ const int camera)
{
    return (vq.id += camera);
}
                                #endif

                                #ifndef DEF_ViewQuads_c5DkLtANh8i
                                #define DEF_ViewQuads_c5DkLtANh8i
inline MultiDraw_rMz8 ViewQuads_c5Dk(const int id, /*7:7*/ const int camera)
{
    MultiDraw_rMz8 vq = MultiDraw_rMz8 { id };
    populate_7AcA(vq, camera);
    return vq;
}
                                #endif

static MultiDraw_rMz8 ViewQuads_WLF9(const int id, const int camera)
{
    return ViewQuads_c5Dk(id, camera);
}

int fu_MAIN()
{
    return ViewQuads_WLF9(2, 5).id - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn setupOperators()
        {
            struct Maplike {
                keys: string[];
                vals: i32[];
            };

            fn set(ref m: Maplike, k: string, v: i32) {
                m.keys ~= k;
                m.vals ~= v;
            }

            struct BINOP {
                PRECEDENCE: Maplike;
                RIGHT_TO_LEFT: bool[];
            };

            mut out: BINOP;
            mut precedence: i32 = -1;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT ~= rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE.set(ops[i], precedence);
            }

            rightToLeft = false;
            binop([ "*", "/", "%" ]);

            rightToLeft = true;
            binop([ "*=", "/=", "%=" ]);

            return out;
        }

        let BINOP = setupOperators();
        fn main() BINOP.RIGHT_TO_LEFT[1] && BINOP.PRECEDENCE.vals[3] == 1 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct BINOP_ESAh;
struct Maplike_6P7L;

                                #ifndef DEF_Maplike_6P7L15xsuI3
                                #define DEF_Maplike_6P7L15xsuI3
struct Maplike_6P7L
{
                                // shape_hash:    4b817bac7bb1d4b2
                                // non_triv_mask: 0008c00000000100
    fu::vec<fu::str> keys;
    fu::vec<int> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_BINOP_ESAhwNj2Gb5
                                #define DEF_BINOP_ESAhwNj2Gb5
struct BINOP_ESAh
{
                                // shape_hash:    4e70ace11669e6c3
                                // non_triv_mask: 0008c00001000100
    Maplike_6P7L PRECEDENCE;
    fu::vec<bool> RIGHT_TO_LEFT;
    explicit operator bool() const noexcept
    {
        return false
            || PRECEDENCE
            || RIGHT_TO_LEFT
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void set_MbR9(/*7:7*/ Maplike_6P7L& m, /*7:7*/ fu::vec_range<char> k, const int v)
{
    m.keys += fu::str(k);
    m.vals += v;
}

static void binop_MbR9(/*F:F*/ fu::view<fu::str> ops, /*E:A*/ BINOP_ESAh& out, /*E:4*/ int& precedence, /*F:F*/ const bool rightToLeft)
{
    precedence++;
    out.RIGHT_TO_LEFT += rightToLeft;
    for (int i = 0; i < ops.size(); i++)
        set_MbR9(out.PRECEDENCE, ops[i], precedence);

}

static BINOP_ESAh setupOperators_MbR9()
{
    /*MOV*/ BINOP_ESAh out {};
    int precedence = -1;
    bool rightToLeft = false;
    rightToLeft = false;
    binop_MbR9(fu::view<fu::str> {{ fu::str("*"_fu), fu::str("/"_fu), fu::str("%"_fu) }}, out, precedence, rightToLeft);
    rightToLeft = true;
    binop_MbR9(fu::view<fu::str> {{ fu::str("*="_fu), fu::str("/="_fu), fu::str("%="_fu) }}, out, precedence, rightToLeft);
    return /*NRVO*/ out;
}

static const BINOP_ESAh BINOP fu_INIT_PRIORITY(1001) = setupOperators_MbR9();

int fu_MAIN()
{
    if (BINOP.RIGHT_TO_LEFT[1] && (BINOP.PRECEDENCE.vals[3] == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_SD_HasStaticInit

========

        fn Split !T(str: T[], sep: T or T[..], each) {
            mut last_idx = 0;
            mut next_idx = 0;

            let N = typeof(sep) -> T[..] ? sep.len : 1;
            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {
                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);
                last_idx = next_idx + N;
            }

            if (last_idx)
                each(str.slice(last_idx), first?: false, last?: true);
            else
                each(str, first?: true, last?: true);
        }

        fn Replace !T(str: T[], all: T or T[..], with: T or T[..] or []) {
            mut result: T[];
            Split(str, sep: all, |substr, lax first, lax last| {
                if !(first) {
                    if !(typeof(with) -> [])
                        result ~= with;
                }
                else if (last) {
                    return str;
                }

                result ~= substr;
            });

            return result;
        }

        fn main() {
            let res = "hello".Replace(all: "ll", with: []);
            return res == "heo" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_Replace_dWkiFcVkwHk
                                #define DEF_Replace_dWkiFcVkwHk
inline static fu::str Replace_dWki(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last_idx = 0;
        int next_idx = 0;
        const int N = all.size();
        if (N)
        {
            while (((next_idx = find_BNNw(str, all, last_idx)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last_idx, next_idx);
                    const bool first = !last_idx;
                    const bool last = false;
                    if (!(!first))
                    {
                        if (last)
                            return fu::str(str);

                    };
                    result += substr;
                };
                last_idx = (next_idx + N);
            };
        };
        if (last_idx)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last_idx);
            const bool first = false;
            const bool last = true;
            if (!(!first))
            {
                if (last)
                    return fu::str(str);

            };
            result += substr;
        }
        else
        {
            const bool first = true;
            const bool last = true;
            if (!(!first))
            {
                if (last)
                    return fu::str(str);

            };
            result += str;
        };
    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Replace_dWki(str_LCCnJta4Qr3, "ll"_view);
    if (res == "heo"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        fn Split !T(str: T[], sep: T or T[..], each) {
            mut last_idx = 0;
            mut next_idx = 0;

            let N = typeof(sep) -> T[..] ? sep.len : 1;
            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {
                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);
                last_idx = next_idx + N;
            }

            if (last_idx)
                each(str.slice(last_idx), first?: false, last?: true);
            else
                each(str, first?: true, last?: true);
        }

        fn Replace !T(str: T[], all: T or T[..], with: T or T[..] or []) {
            mut result: T[];
            Split(str, sep: all, |substr, lax first, lax last| {
                if !(first) {
                    if !(typeof(with) -> [])
                        result ~= with;
                }
                else if (last) {
                    return str;
                }

                result ~= substr;
            });

            return result;
        }

        fn main() {
            let res = "hello".Replace(all: "ll", with: []);
            return res == "heo" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_Replace_HNgR9jATQ52
                                #define DEF_Replace_HNgR9jATQ52
inline static fu::str Replace_HNgR(/*7:7*/ fu::vec_range<char> str, /*7:7*/ fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last_idx = 0;
        int next_idx = 0;
        const int N = all.size();
        if (N)
        {
            while (((next_idx = find_BNNw(str, all, last_idx)) >= 0))
            {

                {
                    fu::view<char> /*str*/ substr = fu::get_view(str, last_idx, next_idx);
                    result += substr;
                };
                last_idx = (next_idx + N);
            };
        };
        if (last_idx)
        {
            fu::view<char> /*str*/ substr = fu::get_view(str, last_idx);
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Replace_HNgR(str_LCCnJta4Qr3, "ll"_view);
    if (res == "heo"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedIfElse, N_UnusedLet

========

        struct BitSet { _data: u8[] };

        fn add(using ref _: BitSet, idx: int) {
            let no_neg = idx & int.MIN;
            let bucket = idx >> 3 | no_neg;
            let bit    = idx & 7;
            let mask   = 1 << bit.u8;

            if (_data.len <= bucket)
                _data.grow(bucket + 1);

            _data[bucket] |= mask;
        }

        fn each(using _: BitSet, visit) {
            for (mut i = 0; i < _data.len; i++) {
                let item = _data[i];
                if (item) for (mut b = 0; b < 8; b++) {
                    let mask = 1 << b.u8;
                    if (item & mask)
                        visit(i << 3 | b.int);
                }
            }
        }

        struct Node { items: Node[] }

        fn each(using n: Node, visit)
            for (mut i = 0; i < n.items.len; i++)
                visit(n.items[i]);

        fn traverse(ref node: Node, ref bitset: BitSet) {
            bitset.add(node.items.len);
            node.each(.traverse(:bitset));

            mut res = 0;
            bitset.each: |index|
                res += index;

            return res;
        }

        fn main() {
            mut bitset: BitSet;
            return traverse(Node([ Node([ Node, Node, Node ]), Node ]), :bitset) == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/int.h>
#include <fu/vec.h>

struct BitSet_mmp7;
struct Node_zYlo;
static int traverse_MbR9(const Node_zYlo&, BitSet_mmp7&);

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
                                // shape_hash:    6446e5a2f8d57a0b
                                // non_triv_mask: 0600000000000000
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_MIN_FUlTBoZvFa3
                                #define DEF_MIN_FUlTBoZvFa3
inline int MIN_FUlT()
{
    return -2147483648;
}
                                #endif

static void add_MbR9(/*3:3*/ BitSet_mmp7& _, const int idx)
{
    const int no_neg = (idx & MIN_FUlT());
    const int bucket = ((idx >> 3) | no_neg);
    const int bit = (idx & 7);
    const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(bit))));
    if ((_._data.size() <= bucket))
        _._data.grow((bucket + 1));

    _._data.mutref(bucket) |= mask;
}

                                #ifndef DEF___BTNMu1pkqt5
                                #define DEF___BTNMu1pkqt5
inline static int _BTNM(/*3:3*/ const Node_zYlo& _, /*3:3*/ BitSet_mmp7& bitset)
{
    return traverse_MbR9(_, bitset);
}
                                #endif

                                #ifndef DEF_each_K6N2dw9jAy2
                                #define DEF_each_K6N2dw9jAy2
inline static void each_K6N2(/*7:7*/ const Node_zYlo& n, /*6:6*/ BitSet_mmp7& bitset)
{
    for (int i = 0; i < n.items.size(); i++)
        _BTNM(n.items[i], bitset);

}
                                #endif

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int index, /*3:3*/ int& res)
{
    return (res += index);
}
                                #endif

                                #ifndef DEF_each_Y2wWK6LB8ki
                                #define DEF_each_Y2wWK6LB8ki
inline static void each_Y2wW(/*7:7*/ const BitSet_mmp7& _, /*6:6*/ int& res)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 /*_|static*/ item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _5aAg(((i << 3) | int(b)), res);

            };
        };
    };
}
                                #endif

static int traverse_MbR9(/*3:3*/ const Node_zYlo& node, /*2:2*/ BitSet_mmp7& bitset)
{
    add_MbR9(bitset, node.items.size());
    each_K6N2(node, bitset);
    int res = 0;
    each_Y2wW(bitset, res);
    return res;
}

int fu_MAIN()
{
    BitSet_mmp7 bitset {};
    if (traverse_MbR9(Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{}, Node_zYlo{} }} }, Node_zYlo{} }} }, bitset) == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedImplicit, N_UnusedCall

========

        struct Type {
            quals: i32;
            canon: string;
        };

        fn is_never (t: Type) t.canon == "never";
        fn is_zeroes(t: Type) t.canon == "zeroes";

        let CANNOT_definit_mutrefs = true;

        fn clear_mutref(mut t: Type) {
            t.quals &= ~1;
            return t;
        }

        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {
            if (a.canon != b.canon)
                return a.is_never  ? b
                     : b.is_never  ? a
                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
                     : [];

            return Type(:a.canon, a.quals | b.quals);
        }

        import _0;
        fn main() {
            let Hey1    = Type(1, "hey");
            let Zeroes  = Type(0, "zeroes");
            let res     = union(Hey1, Zeroes);
            return res.canon == "hey" && res.quals == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Type_v5MD;
Type_v5MD uNion_MbR9(const Type_v5MD&, const Type_v5MD&, bool);

                                #ifndef DEF_Type_v5MDCFFJFNd
                                #define DEF_Type_v5MDCFFJFNd
struct Type_v5MD
{
                                // shape_hash:    dd5d39ae9c930c0a
                                // non_triv_mask: 0000800200000000
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Type_v5MD Hey1 = Type_v5MD { 1, fu::str("hey"_fu) };
    Type_v5MD Zeroes = Type_v5MD { 0, fu::str("zeroes"_fu) };
    Type_v5MD res = uNion_MbR9(Hey1, Zeroes, false);
    if ((res.canon == "hey"_view) && (res.quals == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>

struct Type_v5MD;

                                #ifndef DEF_CANNOT_definit_mutrefs
                                #define DEF_CANNOT_definit_mutrefs
inline constexpr bool CANNOT_definit_mutrefs = true;
                                #endif

                                #ifndef DEF_Type_v5MDCFFJFNd
                                #define DEF_Type_v5MDCFFJFNd
struct Type_v5MD
{
                                // shape_hash:    dd5d39ae9c930c0a
                                // non_triv_mask: 0000800200000000
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

bool is_never_MbR9(/*1:1*/ const Type_v5MD& t)
{
    return t.canon == "never"_view;
}

bool is_zeroes_MbR9(/*1:1*/ const Type_v5MD& t)
{
    return t.canon == "zeroes"_view;
}

Type_v5MD clear_mutref_MbR9(/*MOV*/ Type_v5MD&& t)
{
    t.quals &= ~1;
    return static_cast<Type_v5MD&&>(t);
}

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

Type_v5MD uNion_MbR9(/*7:7*/ const Type_v5MD& a, /*7:7*/ const Type_v5MD& b, const bool DONT_match_zeroes)
{
    if (a.canon != b.canon)
    {
        if (is_never_MbR9(a))
            return Type_v5MD(b);
        else if (is_never_MbR9(b))
            return Type_v5MD(a);
        else if (is_zeroes_MbR9(a) && !DONT_match_zeroes)
        {
            if (CANNOT_definit_mutrefs)
                return clear_mutref_MbR9(Type_v5MD(b));
            else
                return Type_v5MD(b);

        }
        else if (is_zeroes_MbR9(b) && !DONT_match_zeroes)
        {
            if (CANNOT_definit_mutrefs)
                return clear_mutref_MbR9(Type_v5MD(a));
            else
                return Type_v5MD(a);

        }
        else
        {
            return Type_v5MD{};
        };
    }
    else
    {
        return Type_v5MD { (a.quals | b.quals), fu::str(a.canon) };
    };
}

#endif

// N_NonTrivAutoCopy, N_SD_HasStaticInit

========

        struct Type {
            quals: i32;
            canon: string;
        };

        fn is_never (t: Type) t.canon == "never";
        fn is_zeroes(t: Type) t.canon == "zeroes";

        let CANNOT_definit_mutrefs = true;

        fn clear_mutref(mut t: Type) {
            t.quals &= ~1;
            return t;
        }

        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {
            if (a.canon != b.canon)
                return a.is_never  ? b
                     : b.is_never  ? a
                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
                     : [];

            return Type(:a.canon, a.quals | b.quals);
        }

        import _0;
        fn main() {
            let Hey1    = Type(1, "hey");
            let Zeroes  = Type(0, "zeroes");
            let res     = union(Hey1, Zeroes);
            return res.canon == "hey" && res.quals == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Type_v5MD;
Type_v5MD uNion_MbR9(const Type_v5MD&, const Type_v5MD&, bool);

                                #ifndef DEF_Type_v5MDCFFJFNd
                                #define DEF_Type_v5MDCFFJFNd
struct Type_v5MD
{
                                // shape_hash:    dd5d39ae9c930c0a
                                // non_triv_mask: 0000800200000000
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Type_v5MD Hey1 = Type_v5MD { 1, fu::str("hey"_fu) };
    Type_v5MD Zeroes = Type_v5MD { 0, fu::str("zeroes"_fu) };
    Type_v5MD res = uNion_MbR9(Hey1, Zeroes, false);
    if ((res.canon == "hey"_view) && (res.quals == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>

struct Type_v5MD;

                                #ifndef DEF_CANNOT_definit_mutrefs
                                #define DEF_CANNOT_definit_mutrefs
inline constexpr bool CANNOT_definit_mutrefs = true;
                                #endif

                                #ifndef DEF_Type_v5MDCFFJFNd
                                #define DEF_Type_v5MDCFFJFNd
struct Type_v5MD
{
                                // shape_hash:    dd5d39ae9c930c0a
                                // non_triv_mask: 0000800200000000
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

bool is_never_MbR9(/*1:1*/ const Type_v5MD& t)
{
    return t.canon == "never"_view;
}

bool is_zeroes_MbR9(/*1:1*/ const Type_v5MD& t)
{
    return t.canon == "zeroes"_view;
}

Type_v5MD clear_mutref_MbR9(/*MOV*/ Type_v5MD&& t)
{
    t.quals &= ~1;
    return static_cast<Type_v5MD&&>(t);
}

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

Type_v5MD uNion_MbR9(/*7:7*/ const Type_v5MD& a, /*7:7*/ const Type_v5MD& b, const bool DONT_match_zeroes)
{
    if (a.canon != b.canon)
    {
        if (is_never_MbR9(a))
            return Type_v5MD(b);
        else if (is_never_MbR9(b))
            return Type_v5MD(a);
        else if (is_zeroes_MbR9(a) && !DONT_match_zeroes)
            return clear_mutref_MbR9(Type_v5MD(b));
        else if (is_zeroes_MbR9(b) && !DONT_match_zeroes)
            return clear_mutref_MbR9(Type_v5MD(a));
        else
        {
            return Type_v5MD{};
        };
    }
    else
    {
        return Type_v5MD { (a.quals | b.quals), fu::str(a.canon) };
    };
}

#endif

// N_NonTrivAutoCopy, N_SD_HasStaticInit

========


        inline 
        fn inlineSelfRecursion(x: int)
            x > 10  ? inlineSelfRecursion(x / 2)
                    : x;

        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 8:19+19[0m:

[2m      |                     : x;[0m
[2m      | [0m
[2m    8 | [0m        fn main() [31;1minlineSelfRecursion[0m(15) == 7 ? 0 : 1;
[2m      | [0m

	Cannot inline self-recursive fns: [35;3minline[0m [94;1minlineSelfRecursion[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========


        fn inlineSelfRecursion(x: int)
            x > 10  ? inlineSelfRecursion(x / 2)
                    : x;

        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int inlineSelfRecursion_MbR9(int);

#ifndef fu_NO_fdefs

static int inlineSelfRecursion_MbR9(const int x)
{
    if (x > 10)
        return inlineSelfRecursion_MbR9((x / 2));
    else
        return x;

}

int fu_MAIN()
{
    if (inlineSelfRecursion_MbR9(15) == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========


        inline 
        fn inlineMutualRecursion_a(x: int)
            x > 10  ? inlineMutualRecursion_b(x / 2)
                    : x;

        inline fn inlineMutualRecursion_b(x: int)
            x > 5   ? inlineMutualRecursion_a(x / 2)
                    : x;

        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 9:23+23[0m:

[2m      | [0m
[2m      |         inline fn inlineMutualRecursion_b(x: int)[0m
[2m    9 | [0m            x > 5   ? [31;1minlineMutualRecursion_a[0m(x / 2)
[2m      |                     : x;[0m
[2m      | [0m

	Cannot inline self-recursive fns: [35;3minline[0m [94;1minlineMutualRecursion_a[0m

        Solving [35;3minline[0m [94;1minlineMutualRecursion_b[0m([35;3mi32[0m) at [2m8:19+23[0m

========


        fn inlineMutualRecursion_a(x: int)
            x > 10  ? inlineMutualRecursion_b(x / 2)
                    : x;

        inline fn inlineMutualRecursion_b(x: int)
            x > 5   ? inlineMutualRecursion_a(x / 2)
                    : x;

        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int inlineMutualRecursion_a_MbR9(int);

#ifndef fu_NO_fdefs

static int inlineMutualRecursion_a_MbR9(const int x)
{
    if (x > 10)
    {
        const int x_1 = (x / 2);
        if (x_1 > 5)
            return inlineMutualRecursion_a_MbR9((x_1 / 2));
        else
            return x_1;

    }
    else
        return x;

}

int fu_MAIN()
{
    if (inlineMutualRecursion_a_MbR9(15) == 3)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        nocopy struct SolverOutput {
            content?: SolverOutput[];
        };

        fn test(ref _helpers_data: i32[], mut content: SolverOutput[])
        {
            _helpers_data.len & 1 && _helpers_data.pop();
            {
                _helpers_data && throw("non-empty _helpers_data.");
                {
                    content.len & 1 && content.pop();
                    {
                        return SolverOutput(:content);
                    }
                }
            }
        }

        fn main() {
            mut _helpers_data: i32[];
            mut content: SolverOutput[];
            return test(_helpers_data, content).content.len;    // !*MustSeq
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct SolverOutput_QR24;

                                #ifndef DEF_SolverOutput_QR24I8KVKyk
                                #define DEF_SolverOutput_QR24I8KVKyk
struct SolverOutput_QR24
{
                                // shape_hash:    2b1faaa02036b7fe
                                // non_triv_mask: 0000200000004000
    fu::vec<SolverOutput_QR24> content;
    SolverOutput_QR24(const SolverOutput_QR24&) = delete;
    SolverOutput_QR24(SolverOutput_QR24&&) = default;
    SolverOutput_QR24& operator=(const SolverOutput_QR24&) = delete;
    SolverOutput_QR24& operator=(SolverOutput_QR24&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || content
        ;
    }
};
                                #endif

                                #ifndef STR_i3opEmHH97b
                                #define STR_i3opEmHH97b
static const fu::str str_i3opEmHH97b fu_INIT_PRIORITY(1001) { "non-empty _helpers_data."_fu };
                                #endif

#ifndef fu_NO_fdefs

static SolverOutput_QR24 test_MbR9(/*3:1*/ fu::vec_range_mut<int> _helpers_data, /*MOV*/ fu::vec<SolverOutput_QR24>&& content)
{
    if (_helpers_data.size() & 1)
        _helpers_data.pop();

    if (_helpers_data)
        fu::fail(fu::str(str_i3opEmHH97b));
    else
    {
        if (content.size() & 1)
            content.pop();

        return SolverOutput_QR24 { content.destructive_move() };
    };
}

int fu_MAIN()
{
    fu::vec<int> _helpers_data {};
    /*MOV*/ fu::vec<SolverOutput_QR24> content {};
    return test_MbR9(_helpers_data, static_cast<fu::vec<SolverOutput_QR24>&&>(content)).content.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct Type { quals: i32; };
        struct Node { type: Type; };

        fn unusedLetExprOrBlock(args_in: Node[..], default: Node) {
            mut inType: Type;
            for (mut i = 0; i < args_in.len; i++) {
                // got this while auto-reducing smth else,
                //  nonsense but currently bugs mcom
                lax let inValue = args_in[i] || {
                    inType = default.type;  //      <- then, mcom tries to copy here
                    default                 // <- first this gets discarded
                };
            }

            return inType;
        }

        fn main() {
            return unusedLetExprOrBlock([ Node() ], Node(Type(1))).quals - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>

struct Node_aSNT;
struct Type_F0he;

                                #ifndef DEF_Type_F0henG0NXOa
                                #define DEF_Type_F0henG0NXOa
struct Type_F0he
{
                                // shape_hash:    dabc56846d3fc0e7
                                // non_triv_mask: 0000000000000000
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || quals
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_aSNTVrJMkbc
                                #define DEF_Node_aSNTVrJMkbc
struct Node_aSNT
{
                                // shape_hash:    a953299b492a6ed8
                                // non_triv_mask: 0000000000000000
    Type_F0he type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Type_F0he unusedLetExprOrBlock_MbR9(/*3:3*/ fu::view<Node_aSNT> args_in, /*3:3*/ const Node_aSNT& dEfault)
{
    Type_F0he inType {};
    for (int i = 0; i < args_in.size(); i++)
    {
        if (!(args_in[i]))
            inType = dEfault.type;

    };
    return inType;
}

int fu_MAIN()
{
    return unusedLetExprOrBlock_MbR9(fu::view<Node_aSNT> {{ Node_aSNT{} }}, Node_aSNT { Type_F0he { 1 } }).quals - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn parse !T(v: byte[..], lax as!: T) {
            mut result: T;

            if (T.is::bitfield) {
                for (mut i = 1; i < v.len; i++) {
                    if (v[i] == '|') {
                        return parse(v[0 .. i], :as) | parse(v[i + 1 .. v.len], :as);
                    }
                }
            }

            for (mut i = 0; i < v.len; i++) {
                if (v[i] == '*') {
                    let prefix = v[0 .. i];
                    let suffix = v[i + 1 .. v.len]

                    for (fieldname i: T) {
                        let opt = "i";
                        if (opt.starts(with: prefix) && opt.ends(with: suffix))
                            result |= T.i;
                    }

                    return result;
                }
                else if (i > 0 && v[i] == '|') {
                    return parse(v[0 .. i], :as) | parse(v[i + 1 .. v.len], :as);
                }
            }

            for (fieldname i: T)
                if (v == "i")
                    return T.i;

            return [];
        }

        flags UpperCase { Hello = 1; World = 2; Cruel = 4; CruelWorld = 8 };
        flags LowerCase { hello = 16; world = 32; cruel = 64; cruel_world = 128 };

        fn parseUpperOrLower(str: string) {
            if (let upper = parse(str, as: UpperCase))
                return upper.i32;
            else if (let lower = parse(str, as: LowerCase))
                return lower.i32;
            else
                return 0;
        }

        fn main() {
            if (parseUpperOrLower("World|Cruel*") != 2|4|8) return 1;
            if (parseUpperOrLower("*world|hello") != 16|32|128) return 2;
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>

typedef fu::u8 UpperCase_LjLi;
typedef fu::u8 LowerCase_dQgd;
inline static UpperCase_LjLi parse_Yu9F(fu::view<char>);
inline static LowerCase_dQgd parse_xOfd(fu::view<char>);

                                #ifndef DEF_UpperCase_LjLi
                                #define DEF_UpperCase_LjLi
inline constexpr UpperCase_LjLi UpperCase_LjLi_Hello = UpperCase_LjLi(1u);
inline constexpr UpperCase_LjLi UpperCase_LjLi_World = UpperCase_LjLi(2u);
inline constexpr UpperCase_LjLi UpperCase_LjLi_Cruel = UpperCase_LjLi(4u);
inline constexpr UpperCase_LjLi UpperCase_LjLi_CruelWorld = UpperCase_LjLi(8u);

inline constexpr UpperCase_LjLi MASK_UpperCase_LjLi
    = UpperCase_LjLi_Hello
    | UpperCase_LjLi_World
    | UpperCase_LjLi_Cruel
    | UpperCase_LjLi_CruelWorld;
                                #endif

                                #ifndef DEF_LowerCase_dQgd
                                #define DEF_LowerCase_dQgd
inline constexpr LowerCase_dQgd LowerCase_dQgd_hello = LowerCase_dQgd(16u);
inline constexpr LowerCase_dQgd LowerCase_dQgd_world = LowerCase_dQgd(32u);
inline constexpr LowerCase_dQgd LowerCase_dQgd_cruel = LowerCase_dQgd(64u);
inline constexpr LowerCase_dQgd LowerCase_dQgd_cruel_world = LowerCase_dQgd(128u);

inline constexpr LowerCase_dQgd MASK_LowerCase_dQgd
    = LowerCase_dQgd_hello
    | LowerCase_dQgd_world
    | LowerCase_dQgd_cruel
    | LowerCase_dQgd_cruel_world;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_ends_OW45P9GlDid
                                #define DEF_ends_OW45P9GlDid
inline bool ends_OW45(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

                                #ifndef DEF_parse_Yu9FDzbEknl
                                #define DEF_parse_Yu9FDzbEknl
inline static UpperCase_LjLi parse_Yu9F(/*3:3*/ fu::view<char> v)
{
    UpperCase_LjLi result {};
    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] == '|')
            return parse_Yu9F(fu::get_view(v, 0, i)) | parse_Yu9F(fu::get_view(v, (i + 1), v.size()));

    };
    for (int i_1 = 0; i_1 < v.size(); i_1++)
    {
        if (v[i_1] == '*')
        {
            fu::view<char> /*v*/ prefix = fu::get_view(v, 0, i_1);
            fu::view<char> /*v*/ suffix = fu::get_view(v, (i_1 + 1), v.size());

            {

                {
                    fu::view<char> /*static*/ opt = "Hello"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= UpperCase_LjLi_Hello;

                };

                {
                    fu::view<char> /*static*/ opt = "World"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= UpperCase_LjLi_World;

                };

                {
                    fu::view<char> /*static*/ opt = "Cruel"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= UpperCase_LjLi_Cruel;

                };
                fu::view<char> /*static*/ opt = "CruelWorld"_view;
                if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                    result |= UpperCase_LjLi_CruelWorld;

            };
            return result;
        }
        else if ((i_1 > 0) && (v[i_1] == '|'))
            return parse_Yu9F(fu::get_view(v, 0, i_1)) | parse_Yu9F(fu::get_view(v, (i_1 + 1), v.size()));

    };
    if (v == "Hello"_view)
        return UpperCase_LjLi_Hello;
    else if (v == "World"_view)
        return UpperCase_LjLi_World;
    else if (v == "Cruel"_view)
        return UpperCase_LjLi_Cruel;
    else if (v == "CruelWorld"_view)
        return UpperCase_LjLi_CruelWorld;

    return UpperCase_LjLi{};
}
                                #endif

                                #ifndef DEF_parse_xOfd2d1U5V7
                                #define DEF_parse_xOfd2d1U5V7
inline static LowerCase_dQgd parse_xOfd(/*3:3*/ fu::view<char> v)
{
    LowerCase_dQgd result {};
    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] == '|')
            return parse_xOfd(fu::get_view(v, 0, i)) | parse_xOfd(fu::get_view(v, (i + 1), v.size()));

    };
    for (int i_1 = 0; i_1 < v.size(); i_1++)
    {
        if (v[i_1] == '*')
        {
            fu::view<char> /*v*/ prefix = fu::get_view(v, 0, i_1);
            fu::view<char> /*v*/ suffix = fu::get_view(v, (i_1 + 1), v.size());

            {

                {
                    fu::view<char> /*static*/ opt = "hello"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= LowerCase_dQgd_hello;

                };

                {
                    fu::view<char> /*static*/ opt = "world"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= LowerCase_dQgd_world;

                };

                {
                    fu::view<char> /*static*/ opt = "cruel"_view;
                    if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                        result |= LowerCase_dQgd_cruel;

                };
                fu::view<char> /*static*/ opt = "cruel_world"_view;
                if (starts_ojop(opt, prefix) && ends_OW45(opt, suffix))
                    result |= LowerCase_dQgd_cruel_world;

            };
            return result;
        }
        else if ((i_1 > 0) && (v[i_1] == '|'))
            return parse_xOfd(fu::get_view(v, 0, i_1)) | parse_xOfd(fu::get_view(v, (i_1 + 1), v.size()));

    };
    if (v == "hello"_view)
        return LowerCase_dQgd_hello;
    else if (v == "world"_view)
        return LowerCase_dQgd_world;
    else if (v == "cruel"_view)
        return LowerCase_dQgd_cruel;
    else if (v == "cruel_world"_view)
        return LowerCase_dQgd_cruel_world;

    return LowerCase_dQgd{};
}
                                #endif

static int parseUpperOrLower_MbR9(/*1:1*/ fu::view<char> str)
{
    UpperCase_LjLi upper;
    LowerCase_dQgd lower;
    if ((upper = parse_Yu9F(str)))
        return int(upper);
    else if ((lower = parse_xOfd(str)))
        return int(lower);
    else
        return 0;

}

int fu_MAIN()
{
    if (parseUpperOrLower_MbR9("World|Cruel*"_view) != ((2 | 4) | 8))
        return 1;
    else if (parseUpperOrLower_MbR9("*world|hello"_view) != ((16 | 32) | 128))
        return 2;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse

========

        struct Type { items: Type[]; }

        fn solve(root: Type) {
            mut out = 0;
            fn test_node(node: Type) {
                for (mut i = 0; i < node.items.len; i++)
                    test_node(node.items[i]);

                fn checkLt(actual: Type) {
                    out += node.items.len;
                    for (mut i = 0; i < actual.items.len; i++)
                        checkLt(actual.items[i]);
                }

                checkLt(node);
            }

            test_node(root);
            return out;
        }

        fn main() solve(Type([ Type([ Type, Type ]), Type([ Type, Type, Type ]) ])) == 34 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>

struct Type_sU6g;
static void test_node_MbR9(const Type_sU6g&, int&);
static void checkLt_MbR9(const Type_sU6g&, const Type_sU6g&, int&);

                                #ifndef DEF_Type_sU6gnR0boGg
                                #define DEF_Type_sU6gnR0boGg
struct Type_sU6g
{
                                // shape_hash:    49cc4496e825352c
                                // non_triv_mask: 0002010000000000
    fu::vec<Type_sU6g> items;
    Type_sU6g(const Type_sU6g&) = default;
    Type_sU6g(Type_sU6g&&) = default;
    Type_sU6g& operator=(Type_sU6g&&) = default;
    Type_sU6g& operator=(const Type_sU6g& selfrec) { return *this = Type_sU6g(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void checkLt_MbR9(/*7:7*/ const Type_sU6g& actual, /*7:7*/ const Type_sU6g& node, /*6:4*/ int& out)
{
    out += node.items.size();
    for (int i = 0; i < actual.items.size(); i++)
        checkLt_MbR9(actual.items[i], node, out);

}

static void test_node_MbR9(/*3:3*/ const Type_sU6g& node, /*2:2*/ int& out)
{
    for (int i = 0; i < node.items.size(); i++)
        test_node_MbR9(node.items[i], out);

    checkLt_MbR9(node, node, out);
}

static int solve_MbR9(/*1:1*/ const Type_sU6g& root)
{
    int out = 0;
    test_node_MbR9(root, out);
    return out;
}

int fu_MAIN()
{
    if (solve_MbR9(Type_sU6g { fu::vec<Type_sU6g> {{ Type_sU6g { fu::vec<Type_sU6g> {{ Type_sU6g{}, Type_sU6g{} }} }, Type_sU6g { fu::vec<Type_sU6g> {{ Type_sU6g{}, Type_sU6g{}, Type_sU6g{} }} } }} }) == 34)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall

========

        fn runSolver(
            implicit ref notes: i32,
            break_notes: i32,
            implicit ref value: i32)
        {
            fn makeNote(note: i32, inline reason: string) {
                if (break_notes & note)
                    throw("#" ~ note ~ ": " ~ reason);

                notes |= note;
            }

            if (value > 0) {
                if (value++ & 1) return makeNote(1, "A: " ~ value);
                if (value++ & 2) return makeNote(2, "B: " ~ value);
            }
            else {
                if (value++ & 4) return makeNote(4, "C: " ~ value);
                if (value++ & 8) return makeNote(8, "D: " ~ value);
            }
        }

        fn main() {
            implicit mut notes: i32;

            implicit mut print: string; 
            implicit mut value = 0;

            runSolver(1|2);
            runSolver(4|8);
            return value == 4 && notes == 2 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 27:26+5[0m:

[2m      |             implicit mut notes: i32;[0m
[2m      | [0m
[2m   27 | [0m            implicit mut [31;1mprint[0m: string; 
[2m      |             implicit mut value = 0;[0m
[2m      | [0m

	Unused variable: [35;3mimplicit[0m [94;1mprint[0m. Make it [35;3mlax[0m if this is intentional.

========

        fn runSolver(
            implicit ref notes: i32,
            break_notes: i32,
            implicit ref value: i32)
        {
            fn makeNote(note: i32, inline reason: string) {
                if (break_notes & note)
                    throw("#" ~ note ~ ": " ~ reason);

                notes |= note;
            }

            if (value > 0) {
                if (value++ & 1) return makeNote(1, "A: " ~ value);
                if (value++ & 2) return makeNote(2, "B: " ~ value);
            }
            else {
                if (value++ & 4) return makeNote(4, "C: " ~ value);
                if (value++ & 8) return makeNote(8, "D: " ~ value);
            }
        }

        fn main() {
            implicit mut notes: i32;

            implicit mut value = 0;

            runSolver(1|2);
            runSolver(4|8);
            return value == 4 && notes == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static void runSolver_MbR9(const int break_notes, /*7:7*/ int& notes, /*7:5*/ int& value)
{
    if (value > 0)
    {
        if (value++ & 1)
        {
            const int note = 1;
            if (break_notes & note)
                fu::fail(((x7E_rA00("#"_view, fu::i64dec(note)) + ": "_view) + x7E_rA00("A: "_view, fu::i64dec(value))));
            else
                notes |= note;

        }
        else if (value++ & 2)
        {
            const int note = 2;
            if (break_notes & note)
                fu::fail(((x7E_rA00("#"_view, fu::i64dec(note)) + ": "_view) + x7E_rA00("B: "_view, fu::i64dec(value))));
            else
                notes |= note;

        };
    }
    else if (value++ & 4)
    {
        const int note = 4;
        if (break_notes & note)
            fu::fail(((x7E_rA00("#"_view, fu::i64dec(note)) + ": "_view) + x7E_rA00("C: "_view, fu::i64dec(value))));
        else
            notes |= note;

    }
    else if (value++ & 8)
    {
        const int note = 8;
        if (break_notes & note)
            fu::fail(((x7E_rA00("#"_view, fu::i64dec(note)) + ": "_view) + x7E_rA00("D: "_view, fu::i64dec(value))));
        else
            notes |= note;

    };
}

int fu_MAIN()
{
    int notes {};
    int value = 0;
    runSolver_MbR9((1 | 2), notes, value);
    runSolver_MbR9((4 | 8), notes, value);
    if ((value == 4) && (notes == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Target { x: i32; };

        fn ScopeSkip_push_bad_args(targets: Target[], ref sum: i32) {
            fn descend(acc?: bool) {
                fn foreach(t: Target) {
                    if (acc)    sum += t.x;
                    else        descend(true);
                }

                targets.each(|u| foreach(u));
            }

            descend();
        }

        fn main() {
            mut targets = [ Target(1), Target(2) ];
            mut sum = 0;
            ScopeSkip_push_bad_args(:targets, :sum);
            return sum == 6 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Target_DZAM;
static void descend_MbR9(bool, fu::view<Target_DZAM>, int&);

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void foreach_MbR9(/*F:F*/ const Target_DZAM& t, /*F:F*/ const bool acc, /*F:F*/ fu::view<Target_DZAM> targets, /*F:B*/ int& sum)
{
    if (acc)
        sum += t.x;
    else
        descend_MbR9(true, targets, sum);

}

                                #ifndef DEF___4BkYFdeX2m0
                                #define DEF___4BkYFdeX2m0
inline static void _4BkY(/*F:F*/ const Target_DZAM& u, /*F:F*/ const bool acc, /*F:F*/ fu::view<Target_DZAM> targets, /*F:B*/ int& sum)
{
    foreach_MbR9(u, acc, targets, sum);
}
                                #endif

                                #ifndef DEF_each_dn19SXdgEGe
                                #define DEF_each_dn19SXdgEGe
inline void each_dn19(/*F1:F1*/ fu::view<Target_DZAM> a, /*F1:F1*/ const bool acc, /*F1:F1*/ fu::view<Target_DZAM> targets, /*F1:21*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _4BkY(a[i], acc, targets, sum);

}
                                #endif

static void descend_MbR9(const bool acc, /*7:7*/ fu::view<Target_DZAM> targets, /*6:4*/ int& sum)
{
    each_dn19(targets, acc, targets, sum);
}

static void ScopeSkip_push_bad_args_MbR9(/*3:3*/ fu::view<Target_DZAM> targets, /*2:2*/ int& sum)
{
    descend_MbR9(false, targets, sum);
}

int fu_MAIN()
{
    fu::vec<Target_DZAM> targets = fu::vec<Target_DZAM> {{ Target_DZAM { 1 }, Target_DZAM { 2 } }};
    int sum = 0;
    ScopeSkip_push_bad_args_MbR9(targets, sum);
    if (sum == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedCall

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_BkxrB6RLkzj
                                #define DEF_profile_BkxrB6RLkzj
inline static void profile_Bkxr(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_Bkxr(2, module);
}

                                #ifndef DEF_profile_e4MZBvvFAMj
                                #define DEF_profile_e4MZBvvFAMj
inline static void profile_e4MZ(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_e4MZ(3, module);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_BkxrB6RLkzj
                                #define DEF_profile_BkxrB6RLkzj
inline static void profile_Bkxr(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_Bkxr(2, module);
}

                                #ifndef DEF_profile_e4MZBvvFAMj
                                #define DEF_profile_e4MZBvvFAMj
inline static void profile_e4MZ(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};
    profile_e4MZ(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_Ke13EhuBxGi
                                #define DEF_profile_Ke13EhuBxGi
inline static void profile_Ke13(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_Ke13(2, module);
}

                                #ifndef DEF_profile_e4MZBvvFAMj
                                #define DEF_profile_e4MZBvvFAMj
inline static void profile_e4MZ(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_e4MZ(3, module);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_Ke13EhuBxGi
                                #define DEF_profile_Ke13EhuBxGi
inline static void profile_Ke13(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_Ke13(2, module);
}

                                #ifndef DEF_profile_e4MZBvvFAMj
                                #define DEF_profile_e4MZBvvFAMj
inline static void profile_e4MZ(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};
    profile_e4MZ(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_BkxrB6RLkzj
                                #define DEF_profile_BkxrB6RLkzj
inline static void profile_Bkxr(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}
                                #endif

                                #ifndef DEF_profile_xHqlsPmKot4
                                #define DEF_profile_xHqlsPmKot4
inline static void profile_xHql(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    profile_Bkxr(2, module);
    module.events += (events0 + id);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_xHql(3, module);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_BkxrB6RLkzj
                                #define DEF_profile_BkxrB6RLkzj
inline static void profile_Bkxr(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}
                                #endif

                                #ifndef DEF_profile_xHqlsPmKot4
                                #define DEF_profile_xHqlsPmKot4
inline static void profile_xHql(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    profile_Bkxr(2, module);
    module.events += (events0 + id);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};
    profile_xHql(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_Ke13EhuBxGi
                                #define DEF_profile_Ke13EhuBxGi
inline static void profile_Ke13(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}
                                #endif

                                #ifndef DEF_profile_H6PqiSY1BPj
                                #define DEF_profile_H6PqiSY1BPj
inline static void profile_H6Pq(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    profile_Ke13(2, module);
    module.events += (events0 + id);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    profile_H6Pq(3, module);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

                                #ifndef DEF_profile_Ke13EhuBxGi
                                #define DEF_profile_Ke13EhuBxGi
inline static void profile_Ke13(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}
                                #endif

                                #ifndef DEF_profile_H6PqiSY1BPj
                                #define DEF_profile_H6PqiSY1BPj
inline static void profile_H6Pq(const int id, /*7:7*/ Module_pRDt& module)
{
    const int /*module*/ events0 = module.events;
    profile_Ke13(2, module);
    module.events += (events0 + id);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};
    profile_H6Pq(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    _TOFR(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        propagateType_MbR9(module);
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    propagateType_MbR9(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    _RamI(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        propagateType_MbR9(module);
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;

    {
        const int id_1 = 2;
        const int /*module*/ events0_1 = module.events;
        _TOFR(module);
        module.events += (events0_1 + id_1);
    };
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___TOFRUcBPd8a
                                #define DEF___TOFRUcBPd8a
inline static int _TOFR(/*1:1*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;

        {
            const int id_1 = 2;
            const int /*module*/ events0_1 = module.events;
            _TOFR(module);
            module.events += (events0_1 + id_1);
        };
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;

    {
        const int id_1 = 2;
        const int /*module*/ events0_1 = module.events;
        _RamI(module);
        module.events += (events0_1 + id_1);
    };
    module.events += (events0 + id);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, |lax unused?| module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___RamIhZyDZ5g
                                #define DEF___RamIhZyDZ5g
inline static int _RamI(/*3:3*/ Module_pRDt& module)
{
    return (module.events = 1);
}
                                #endif

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;

        {
            const int id_1 = 2;
            const int /*module*/ events0_1 = module.events;
            _RamI(module);
            module.events += (events0_1 + id_1);
        };
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        noinline 
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    module.events = 1;
}

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    propagateType_MbR9(module);
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        inline   
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void propagateType_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    module.events = 1;
}

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        fu_DEFER(module.events += (events0 + id));
        propagateType_MbR9(module);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        noinline 
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void runAllPasses_MbR9(/*1:1*/ Module_pRDt& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    const int id_1 = 2;
    const int /*module*/ events0_1 = module.events;
    fu_DEFER(module.events += (events0_1 + id_1));
    module.events = 1;
}

int fu_MAIN()
{
    Module_pRDt module {};
    runAllPasses_MbR9(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        inline   
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct Module_pRDt;

                                #ifndef DEF_Module_pRDtaxzTvXe
                                #define DEF_Module_pRDtaxzTvXe
struct Module_pRDt
{
                                // shape_hash:    36b10ccce115f3ea
                                // non_triv_mask: 0000000000000000
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Module_pRDt module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        fu_DEFER(module.events += (events0 + id));
        const int id_1 = 2;
        const int /*module*/ events0_1 = module.events;
        fu_DEFER(module.events += (events0_1 + id_1));
        module.events = 1;
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Target { template: string; };
        fn BUG(what?: string) throw(what || "Assertion failed.");

        fn assign_WOOT(ref into: Target) {
            mut name = "";
            mut what = "WOOT";
            name ||= what || BUG(); // arg inliner out of range local
            into.template = name;
        }

        fn main() {
            mut t = Target();
            assign_WOOT(into: t);
            return t.template == "WOOT" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Target_ARA2;

                                #ifndef DEF_Target_ARA2SNBWeoi
                                #define DEF_Target_ARA2SNBWeoi
struct Target_ARA2
{
                                // shape_hash:    af21f8c428f0636d
                                // non_triv_mask: 0000800000000040
    fu::str tEmplate;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef STR_AxW19xp1iOk
                                #define STR_AxW19xp1iOk
static const fu::str str_AxW19xp1iOk fu_INIT_PRIORITY(1001) { "WOOT"_fu };
                                #endif

                                #ifndef STR_G139tn59Hxj
                                #define STR_G139tn59Hxj
static const fu::str str_G139tn59Hxj fu_INIT_PRIORITY(1001) { "Assertion failed."_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never BUG_MbR9(/*1:1*/ fu::vec_range<char> what)
{
    fu::fail(fu::str((what ? what : str_G139tn59Hxj)));
}

static void assign_WOOT_MbR9(/*1:1*/ Target_ARA2& into)
{
    /*MOV*/ fu::str name = fu::str(""_fu);
    fu::vec_range<char> /*static*/ what = str_AxW19xp1iOk;
    if (!(name))
        name = (what ? what : BUG_MbR9((*(fu::str*)fu::NIL)));

    into.tEmplate = name.destructive_move();
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Target_ARA2 t {};
    assign_WOOT_MbR9(t);
    if (t.tEmplate == "WOOT"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Target { template: string; };
        fn BUG(what?: string) throw(what || "Assertion failed.");

        fn assign_WOOT(ref into: Target) {
            mut name = "";
            mut what = "WOOT";
            name ||= what || BUG(); // arg inliner out of range local
            into.template = name;
        }

        fn main() {
            mut t = Target();
            assign_WOOT(into: t);
            return t.template == "WOOT" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Target_ARA2;

                                #ifndef DEF_Target_ARA2SNBWeoi
                                #define DEF_Target_ARA2SNBWeoi
struct Target_ARA2
{
                                // shape_hash:    af21f8c428f0636d
                                // non_triv_mask: 0000800000000040
    fu::str tEmplate;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef STR_AxW19xp1iOk
                                #define STR_AxW19xp1iOk
static const fu::str str_AxW19xp1iOk fu_INIT_PRIORITY(1001) { "WOOT"_fu };
                                #endif

                                #ifndef STR_G139tn59Hxj
                                #define STR_G139tn59Hxj
static const fu::str str_G139tn59Hxj fu_INIT_PRIORITY(1001) { "Assertion failed."_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never BUG_MbR9(/*1:1*/ fu::vec_range<char> what)
{
    fu::fail(fu::str((what ? what : str_G139tn59Hxj)));
}

static void assign_WOOT_MbR9(/*1:1*/ Target_ARA2& into)
{
    /*MOV*/ fu::str name {};
    const fu::str& /*static*/ what = str_AxW19xp1iOk;
    if (!(name))
        name = (what ? what : BUG_MbR9((*(fu::str*)fu::NIL)));

    into.tEmplate = static_cast<fu::str&&>(name);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Target_ARA2 t {};
    assign_WOOT_MbR9(t);
    if (t.tEmplate == "WOOT"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Overload { type: Type; }
        struct Type     { lifetime: i32[]; }

        fn BUG(implicit _here: i32, reason: string)
            throw(_here ~ ": " ~ reason);

        fn is_even(type: Type) {
            let a = !(type.lifetime.len & 1);
            let b =   type.lifetime.len < 4;
            a && !b && BUG("THROW-1");
            return a;
        }

        fn solve(check: Type) {
            let implicit mut _here: i32;

            using fn GET(implicit overloads: Overload[], target: i32)
                target < 0 || target >= overloads.len
                    ? BUG("THROW-2")
                    : overloads[target];

            fn Lifetime_each(type, visit)
                for (mut i = type.lifetime.len; i --> 0; )
                    visit(t: type.lifetime[i]);

            fn Lifetime_allEven(type: Type): bool {
                Lifetime_each(:type, visit: |t| {
                    if (!t.type.is_even)                return false;
                    if (!Lifetime_allEven(t.type))      return false;
                    _here = t;
                });

                return true;
            }

            return Lifetime_allEven(check);
        }

        fn main() {
            let implicit overloads = [
                Overload(),             // 0] even
                Overload(Type([0])),    // 1] odd
                Overload(Type([0, 0])), // 2] even
                Overload(Type([0, 2])), // 3] even
            ];

            if !(solve(Type()))         return 1;
            if  (solve(Type([ 1, 2 ]))) return 2;
            if !(solve(Type([ 2, 3 ]))) return 3;
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct Overload_RpGE;
struct Type_GsJl;
static bool Lifetime_allEven_MbR9(const Type_GsJl&, int&, fu::view<Overload_RpGE>);

                                #ifndef DEF_Type_GsJlT1osC7k
                                #define DEF_Type_GsJlT1osC7k
struct Type_GsJl
{
                                // shape_hash:    e48c8b1c1da426ae
                                // non_triv_mask: 000c000000000000
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_RpGELN4zy1d
                                #define DEF_Overload_RpGELN4zy1d
struct Overload_RpGE
{
                                // shape_hash:    bffd366813e26b79
                                // non_triv_mask: 000c000000000080
    Type_GsJl type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never BUG_MbR9(/*3:3*/ fu::view<char> reason, /*3:3*/ const int _here)
{
    fu::fail((x7E_rA00(fu::i64dec(_here), ": "_view) + reason));
}

static const Overload_RpGE& GET_MbR9(const int target, /*7:7*/ fu::view<Overload_RpGE> overloads, /*7:7*/ const int _here)
{
    if ((target < 0) || (target >= overloads.size()))
        BUG_MbR9("THROW-2"_view, _here);
    else
        return overloads[target];

}

static bool is_even_MbR9(/*3:3*/ const Type_GsJl& type, /*3:3*/ const int _here)
{
    const bool a = !(type.lifetime.size() & 1);
    const bool b = (type.lifetime.size() < 4);
    if (a && !b)
        BUG_MbR9("THROW-1"_view, _here);
    else
        return a;

}

static bool Lifetime_allEven_MbR9(/*7:7*/ const Type_GsJl& type, /*2:2*/ int& _here, /*7:7*/ fu::view<Overload_RpGE> overloads)
{
    for (int i = type.lifetime.size(); i-- > 0; )
    {
        const int /*type|static*/ t = type.lifetime[i];
        if (!is_even_MbR9(GET_MbR9(t, overloads, _here).type, _here))
            return false;
        else if (!Lifetime_allEven_MbR9(GET_MbR9(t, overloads, _here).type, _here, overloads))
            return false;
        else
            _here = t;

    };
    return true;
}

static bool solve_MbR9(/*3:3*/ const Type_GsJl& check, /*3:3*/ fu::view<Overload_RpGE> overloads)
{
    int _here {};
    return Lifetime_allEven_MbR9(check, _here, overloads);
}

int fu_MAIN()
{
    fu::vec<Overload_RpGE> overloads = fu::vec<Overload_RpGE> {{ Overload_RpGE{}, Overload_RpGE { Type_GsJl { fu::vec<int> {{ 0 }} } }, Overload_RpGE { Type_GsJl { fu::vec<int> {{ 0, 0 }} } }, Overload_RpGE { Type_GsJl { fu::vec<int> {{ 0, 2 }} } } }};
    if (!solve_MbR9(Type_GsJl{}, overloads))
        return 1;
    else if (solve_MbR9(Type_GsJl { fu::vec<int> {{ 1, 2 }} }, overloads))
        return 2;
    else if (!solve_MbR9(Type_GsJl { fu::vec<int> {{ 2, 3 }} }, overloads))
        return 3;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        struct Overload { name: string; args?: Argument[]; }
        struct Argument { name: string; }
        struct Target   { index: i32; }

        fn solve(overloads: Overload[], check: Target, from?: Target)
        {
            fn fail(mut reason: string) {
                if (from)
                    reason ~= GET(from).qWHAT;

                return throw(reason);
            }

            fn qWHAT(o: Overload) o.name.human;
            fn qWHAT(a: Argument) a.name.human;

            fn tryParse(id: string)
                id.len == 1 && id[0] >= '0' && id[0] <= '9'
                    && Target(index: id[0].i32 - '0'.i32);

            fn human(id: string) {
                let t = tryParse(:id);
                return t ? GET(t).name : id;
            }

            fn parent(target: Target)
                target.index > 0
                    && Target(target.index - 1);

            using fn GET(target: Target) {
                if (overloads.len < target.index)
                    fail("Parent: " ~ (target.parent ? GET(target.parent).name : "-"));

                return overloads[target.index - 1];
            }

            return check.qWHAT;
        }

        fn main() {
            let overloads = [
                Overload("hello"),
                Overload("1"),
            ];

            return solve(overloads, check: Target(2)) == "hello" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_UJfd;
struct Argument_Q1UI;
struct Target_HIBL;
static const Overload_UJfd& GET_MbR9(const Target_HIBL&, fu::view<Overload_UJfd>, const Target_HIBL&);

                                #ifndef DEF_Argument_Q1UIZq2Nmt1
                                #define DEF_Argument_Q1UIZq2Nmt1
struct Argument_Q1UI
{
                                // shape_hash:    2840cf95b7d2a211
                                // non_triv_mask: 4000800000000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_UJfdWFViFlc
                                #define DEF_Overload_UJfdWFViFlc
struct Overload_UJfd
{
                                // shape_hash:    2b936519f5c77df8
                                // non_triv_mask: 4080800000004000
    fu::str name;
    fu::vec<Argument_Q1UI> args;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Target_HIBL parent_MbR9(/*1:1*/ const Target_HIBL& target)
{
    if (target.index > 0)
    {
        return Target_HIBL { (target.index - 1) };
    }
    else
    {
        return Target_HIBL{};
    };
}

static Target_HIBL tryParse_MbR9(/*1:1*/ fu::view<char> id)
{
    if ((id.size() == 1) && (id[0] >= '0') && (id[0] <= '9'))
    {
        return Target_HIBL { (int(fu::u8(id[0])) - int(fu::u8('0'))) };
    }
    else
    {
        return Target_HIBL{};
    };
}

static fu::view<char> human_kGbb(/*7:7*/ fu::view<char> id, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    const Target_HIBL t = tryParse_MbR9(id);
    if (t)
        return GET_MbR9(t, overloads, from).name;
    else
        return id;

}

static fu::view<char> qWHAT_GL0m(/*7:7*/ const Overload_UJfd& o, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    return human_kGbb(o.name, overloads, from);
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    if (from)
        reason += qWHAT_GL0m(GET_MbR9(from, overloads, from), overloads, from);

    fu::fail(reason.destructive_move());
}

static const Overload_UJfd& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    if (overloads.size() < target.index)
        fail_MbR9(("Parent: "_view + (parent_MbR9(target) ? GET_MbR9(parent_MbR9(target), overloads, from).name : "-"_view)), overloads, from);
    else
        return overloads[(target.index - 1)];

}

static fu::vec_range<char> human_MbR9(/*7:7*/ fu::vec_range<char> id, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    const Target_HIBL t = tryParse_MbR9(id);
    if (t)
        return GET_MbR9(t, overloads, from).name;
    else
        return id;

}

static fu::vec_range<char> qWHAT_MbR9(/*7:7*/ const Overload_UJfd& o, /*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& from)
{
    return human_MbR9(o.name, overloads, from);
}

static fu::vec_range<char> solve_MbR9(/*7:7*/ fu::view<Overload_UJfd> overloads, /*7:7*/ const Target_HIBL& check, /*7:7*/ const Target_HIBL& from)
{
    return qWHAT_MbR9(GET_MbR9(check, overloads, from), overloads, from);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Overload_UJfd> overloads = fu::vec<Overload_UJfd> {{ Overload_UJfd { fu::str("hello"_fu), fu::vec<Argument_Q1UI>{} }, Overload_UJfd { fu::str("1"_fu), fu::vec<Argument_Q1UI>{} } }};
    if (solve_MbR9(overloads, Target_HIBL { 2 }, Target_HIBL{}) == "hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_RelaxRespec

========

        struct Type { quals: i32; lifet: i32 };

        fn tryInter(a: Type, b: Type) {
            let quals = a.quals & b.quals;
            let lifet = a.lifet & b.lifet;
            if (!lifet && (a.lifet || b.lifet))
                return [];

            return quals;
        }

        fn fail(reason: string) {
            return 101 + reason.len;
        }

        fn intersect(reason: string, a: Type, b: Type) {
            return tryInter(a, b) || fail(reason);
        }

        fn main() {
            let a = Type(quals: 1, lifet: 1);
            let b = Type(quals: 3, lifet: 3);
            return intersect("Hello!", a, b) == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Type_r1s5;

                                #ifndef DEF_Type_r1s5zupEyek
                                #define DEF_Type_r1s5zupEyek
struct Type_r1s5
{
                                // shape_hash:    15a21825f5effabe
                                // non_triv_mask: 0000000000000000
    int quals;
    int lifet;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || lifet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int tryInter_MbR9(/*3:3*/ const Type_r1s5& a, /*3:3*/ const Type_r1s5& b)
{
    const int quals = (a.quals & b.quals);
    const int lifet = (a.lifet & b.lifet);
    if (!lifet && (a.lifet || b.lifet))
        return 0;
    else
        return quals;

}

static int fail_MbR9(/*1:1*/ fu::view<char> reason)
{
    return 101 + reason.size();
}

static int intersect_MbR9(/*7:7*/ fu::view<char> reason, /*7:7*/ const Type_r1s5& a, /*7:7*/ const Type_r1s5& b)
{
    int _0;
    return (_0 = tryInter_MbR9(a, b)) ? _0 : fail_MbR9(reason);
}

int fu_MAIN()
{
    const Type_r1s5 a = Type_r1s5 { 1, 1 };
    const Type_r1s5 b = Type_r1s5 { 3, 3 };
    if (intersect_MbR9("Hello!"_view, a, b) == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Item { val: i32 };

        fn Each !T(ref a: T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i], i?: i);

        fn parseStructDecl(ref items: Item[..], ref sum: i32) {
            if (items.len & 2)
                parseStructDecl(items[1 .. items.len], sum);    // PointlessMustSeq

            :BLOCK {
                items.Each: |item|
                    if ((sum += item.val) & 2)
                        break :BLOCK;                           // Goto

                items.Each: |ref item|
                    item.val += sum;
            }

            items.Each: |ref item|
                item.val++;
        }

        fn main() {
            mut sum = 0;
            mut items = [ Item(0), Item(1) ];
            parseStructDecl(items, sum);
            return sum == 4
                && items[0].val == 5
                && items[1].val == 8 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Item_jH9R;
static void parseStructDecl_MbR9(fu::view_mut<Item_jH9R>, int&);

                                #ifndef DEF_Item_jH9RgdkW84g
                                #define DEF_Item_jH9RgdkW84g
struct Item_jH9R
{
                                // shape_hash:    95a97a17d44f32bb
                                // non_triv_mask: 0000000000000000
    int val;
    explicit operator bool() const noexcept
    {
        return false
            || val
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___UfwP0ab8ku1
                                #define DEF___UfwP0ab8ku1
inline static int _UfwP(/*3:3*/ Item_jH9R& item, /*3:3*/ const int sum)
{
    return (item.val += sum);
}
                                #endif

                                #ifndef DEF_Each_pmTPb4yVBl5
                                #define DEF_Each_pmTPb4yVBl5
inline static void Each_pmTP(/*7:3*/ fu::view_mut<Item_jH9R> a, /*7:7*/ const int sum)
{
    for (int i = 0; i < a.size(); i++)
        _UfwP(a.mutref(i), sum);

}
                                #endif

                                #ifndef DEF___ij8TqHHpUO6
                                #define DEF___ij8TqHHpUO6
inline static int _ij8T(/*1:1*/ Item_jH9R& item)
{
    return item.val++;
}
                                #endif

                                #ifndef DEF_Each_1vMVZhWoQm1
                                #define DEF_Each_1vMVZhWoQm1
inline static void Each_1vMV(/*3:3*/ fu::view_mut<Item_jH9R> a)
{
    for (int i = 0; i < a.size(); i++)
        _ij8T(a.mutref(i));

}
                                #endif

static void parseStructDecl_MbR9(/*3:1*/ fu::view_mut<Item_jH9R> items, /*2:2*/ int& sum)
{
    if (items.size() & 2)
        parseStructDecl_MbR9(fu::get_view_mut(items, 1, items.size()), sum);


    { {
        for (int i = 0; i < items.size(); i++)
        {
            const Item_jH9R& /*items|static*/ item = items[i];
            if ((sum += item.val) & 2)
                goto BL_2;

        };
        Each_pmTP(items, sum);
      } BL_2:;
    };
    Each_1vMV(items);
}

int fu_MAIN()
{
    int sum = 0;
    fu::vec<Item_jH9R> items = fu::vec<Item_jH9R> {{ Item_jH9R { 0 }, Item_jH9R { 1 } }};
    parseStructDecl_MbR9(items, sum);
    if ((sum == 4) && (items[0].val == 5) && (items[1].val == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_UnusedCall, N_AARMustSeq

========

        struct Node {
            value?: string;
            items?: Node[];
        };

        fn SLOW_traverse(node: Node, visit) {
            mut stack = [ node ];
            while (stack) {
                shadow mut node = stack[stack.len - 1];
                stack.pop();
                visit(node);
                for (mut i = node.items.len; i --> 0; )
                    stack ~= node.items[i];
            }
        }

        fn qSTACK(node: Node) {
            SLOW_traverse(node): |n| {
                if (n.value && n.items)
                    return n.value ~ ", " ~ qSTACK(n.items[0]);
            }

            return node.value ~ "!";
        }

        fn main() {
            let res = qSTACK(
                Node(items: [
                    Node("Ignore me"),
                    Node("Hello", [ Node("World") ]),
                ]));

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Node_ClDc;
static fu::str qSTACK_MbR9(const Node_ClDc&);

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040800000100000
    fu::str value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str qSTACK_MbR9(/*1:1*/ const Node_ClDc& node)
{

    {
        fu::vec<Node_ClDc> stack = fu::vec<Node_ClDc> {{ Node_ClDc(node) }};
        while (stack)
        {
            Node_ClDc node_1 = stack[(stack.size() - 1)];
            stack.pop();

            {
                const Node_ClDc& /*node_1*/ n = node_1;
                if (n.value && n.items)
                    return (n.value + ", "_view) + qSTACK_MbR9(n.items[0]);

            };
            for (int i = node_1.items.size(); i-- > 0; )
                stack += Node_ClDc(node_1.items[i]);

        };
    };
    return node.value + "!"_view;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = qSTACK_MbR9(Node_ClDc { fu::str{}, fu::vec<Node_ClDc> {{ Node_ClDc { fu::str("Ignore me"_fu), fu::vec<Node_ClDc>{} }, Node_ClDc { fu::str("Hello"_fu), fu::vec<Node_ClDc> {{ Node_ClDc { fu::str("World"_fu), fu::vec<Node_ClDc>{} } }} } }} });
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse

========

        fn merge !T(l: T[..], r: T[..], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Lifetime_E5K4;
inline static fu::vec<int> inter_qwDp(fu::vec_range<int>, fu::vec_range<int>);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_both_7CEEnRIKw68
                                #define DEF_both_7CEEnRIKw68
inline static void both_7CEE(const int item, /*7:7*/ fu::vec<int>& result, /*7:7*/ const bool useResult)
{
    if (useResult)
        result += item;

}
                                #endif

                                #ifndef DEF_left_xGLPksIy0me
                                #define DEF_left_xGLPksIy0me
inline static void left_xGLP(const int left, /*F1:F1*/ fu::vec_range<int> l, /*B1:B1*/ fu::vec<int>& result, /*F1:31*/ bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::get_range(l, 0, left);
    };
}
                                #endif

                                #ifndef DEF_merge_BbITl94gxIk
                                #define DEF_merge_BbITl94gxIk
inline static void merge_BbIT(/*FF:FF*/ fu::view<int> l, /*FF:FF*/ fu::view<int> r, /*FF:FF*/ fu::vec_range<int> l_1, /*CD:C5*/ fu::vec<int>& result, /*CF:C9*/ bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
            (void)0;
        }), fu::unreachable) : +1) : (r_done ? -1 : x3Cx3E_odNT(l[li], r[ri])));
        if (cmp == 0)
        {
            both_7CEE(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            left_xGLP(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_qwDpiUWUrY3
                                #define DEF_inter_qwDpiUWUrY3
inline static fu::vec<int> inter_qwDp(/*3:3*/ fu::vec_range<int> l, /*3:3*/ fu::vec_range<int> r)
{
    if (r.size() < l.size())
        return inter_qwDp(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_BbIT(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

static Lifetime_E5K4 Lifetime_inter_MbR9(/*3:3*/ const Lifetime_E5K4& a, /*3:3*/ const Lifetime_E5K4& b)
{
    return Lifetime_E5K4 { inter_qwDp(a.uni0n, b.uni0n) };
}

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    Lifetime_E5K4 a = Lifetime_E5K4 { fu::vec<int> {{ 1, 2, 3 }} };
    Lifetime_E5K4 b = Lifetime_E5K4 { fu::vec<int> {{ 2, 3, 4 }} };
    Lifetime_E5K4 c = Lifetime_inter_MbR9(a, b);
    if (c.uni0n == fu::view<int> {{ 2, 3 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_COWRestrict

========

        fn merge !T(l: T[..], r: T[..], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr

        pub import _0;
        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_E5K4;
Lifetime_E5K4 Lifetime_inter_MbR9(const Lifetime_E5K4&, const Lifetime_E5K4&);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    Lifetime_E5K4 a = Lifetime_E5K4 { fu::vec<int> {{ 1, 2, 3 }} };
    Lifetime_E5K4 b = Lifetime_E5K4 { fu::vec<int> {{ 2, 3, 4 }} };
    Lifetime_E5K4 c = Lifetime_inter_MbR9(a, b);
    if (c.uni0n == fu::view<int> {{ 2, 3 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Lifetime_E5K4;
inline fu::vec<int> inter_qwDp(fu::vec_range<int>, fu::vec_range<int>);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_both_7CEEnRIKw68
                                #define DEF_both_7CEEnRIKw68
inline static void both_7CEE(const int item, /*7:7*/ fu::vec<int>& result, /*7:7*/ const bool useResult)
{
    if (useResult)
        result += item;

}
                                #endif

                                #ifndef DEF_left_xGLPksIy0me
                                #define DEF_left_xGLPksIy0me
inline static void left_xGLP(const int left, /*F1:F1*/ fu::vec_range<int> l, /*B1:B1*/ fu::vec<int>& result, /*F1:31*/ bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::get_range(l, 0, left);
    };
}
                                #endif

                                #ifndef DEF_merge_BbITl94gxIk
                                #define DEF_merge_BbITl94gxIk
inline void merge_BbIT(/*FF:FF*/ fu::view<int> l, /*FF:FF*/ fu::view<int> r, /*FF:FF*/ fu::vec_range<int> l_1, /*CD:C5*/ fu::vec<int>& result, /*CF:C9*/ bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
            (void)0;
        }), fu::unreachable) : +1) : (r_done ? -1 : x3Cx3E_odNT(l[li], r[ri])));
        if (cmp == 0)
        {
            both_7CEE(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            left_xGLP(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_qwDpiUWUrY3
                                #define DEF_inter_qwDpiUWUrY3
inline fu::vec<int> inter_qwDp(/*3:3*/ fu::vec_range<int> l, /*3:3*/ fu::vec_range<int> r)
{
    if (r.size() < l.size())
        return inter_qwDp(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_BbIT(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

Lifetime_E5K4 Lifetime_inter_MbR9(/*3:3*/ const Lifetime_E5K4& a, /*3:3*/ const Lifetime_E5K4& b)
{
    return Lifetime_E5K4 { inter_qwDp(a.uni0n, b.uni0n) };
}

#endif

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_COWRestrict

========

        fn merge !T(l: T[..], r: T[..], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        pub import _0;
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Lifetime_E5K4;
inline fu::vec<int> inter_qwDp(fu::vec_range<int>, fu::vec_range<int>);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_both_7CEEnRIKw68
                                #define DEF_both_7CEEnRIKw68
inline static void both_7CEE(const int item, /*7:7*/ fu::vec<int>& result, /*7:7*/ const bool useResult)
{
    if (useResult)
        result += item;

}
                                #endif

                                #ifndef DEF_left_xGLPksIy0me
                                #define DEF_left_xGLPksIy0me
inline static void left_xGLP(const int left, /*F1:F1*/ fu::vec_range<int> l, /*B1:B1*/ fu::vec<int>& result, /*F1:31*/ bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::get_range(l, 0, left);
    };
}
                                #endif

                                #ifndef DEF_merge_BbITl94gxIk
                                #define DEF_merge_BbITl94gxIk
inline void merge_BbIT(/*FF:FF*/ fu::view<int> l, /*FF:FF*/ fu::view<int> r, /*FF:FF*/ fu::vec_range<int> l_1, /*CD:C5*/ fu::vec<int>& result, /*CF:C9*/ bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
            (void)0;
        }), fu::unreachable) : +1) : (r_done ? -1 : x3Cx3E_odNT(l[li], r[ri])));
        if (cmp == 0)
        {
            both_7CEE(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            left_xGLP(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_qwDpiUWUrY3
                                #define DEF_inter_qwDpiUWUrY3
inline fu::vec<int> inter_qwDp(/*3:3*/ fu::vec_range<int> l, /*3:3*/ fu::vec_range<int> r)
{
    if (r.size() < l.size())
        return inter_qwDp(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_BbIT(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

static Lifetime_E5K4 Lifetime_inter_LtD7(/*3:3*/ const Lifetime_E5K4& a, /*3:3*/ const Lifetime_E5K4& b)
{
    return Lifetime_E5K4 { inter_qwDp(a.uni0n, b.uni0n) };
}

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    Lifetime_E5K4 a = Lifetime_E5K4 { fu::vec<int> {{ 1, 2, 3 }} };
    Lifetime_E5K4 b = Lifetime_E5K4 { fu::vec<int> {{ 2, 3, 4 }} };
    Lifetime_E5K4 c = Lifetime_inter_LtD7(a, b);
    if (c.uni0n == fu::view<int> {{ 2, 3 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_COWRestrict

========

        fn merge !T(l: T[..], r: T[..], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        pub import _0;
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr

        pub import _1;
        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_E5K4;
Lifetime_E5K4 Lifetime_inter_LtD7(const Lifetime_E5K4&, const Lifetime_E5K4&);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    Lifetime_E5K4 a = Lifetime_E5K4 { fu::vec<int> {{ 1, 2, 3 }} };
    Lifetime_E5K4 b = Lifetime_E5K4 { fu::vec<int> {{ 2, 3, 4 }} };
    Lifetime_E5K4 c = Lifetime_inter_LtD7(a, b);
    if (c.uni0n == fu::view<int> {{ 2, 3 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Lifetime_E5K4;
inline fu::vec<int> inter_qwDp(fu::vec_range<int>, fu::vec_range<int>);

                                #ifndef DEF_Lifetime_E5K4Twrphyj
                                #define DEF_Lifetime_E5K4Twrphyj
struct Lifetime_E5K4
{
                                // shape_hash:    6aaf1278e62beb3e
                                // non_triv_mask: 0008000004000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_both_7CEEnRIKw68
                                #define DEF_both_7CEEnRIKw68
inline static void both_7CEE(const int item, /*7:7*/ fu::vec<int>& result, /*7:7*/ const bool useResult)
{
    if (useResult)
        result += item;

}
                                #endif

                                #ifndef DEF_left_xGLPksIy0me
                                #define DEF_left_xGLPksIy0me
inline static void left_xGLP(const int left, /*F1:F1*/ fu::vec_range<int> l, /*B1:B1*/ fu::vec<int>& result, /*F1:31*/ bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::get_range(l, 0, left);
    };
}
                                #endif

                                #ifndef DEF_merge_BbITl94gxIk
                                #define DEF_merge_BbITl94gxIk
inline void merge_BbIT(/*FF:FF*/ fu::view<int> l, /*FF:FF*/ fu::view<int> r, /*FF:FF*/ fu::vec_range<int> l_1, /*CD:C5*/ fu::vec<int>& result, /*CF:C9*/ bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
            (void)0;
        }), fu::unreachable) : +1) : (r_done ? -1 : x3Cx3E_odNT(l[li], r[ri])));
        if (cmp == 0)
        {
            both_7CEE(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            left_xGLP(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_qwDpiUWUrY3
                                #define DEF_inter_qwDpiUWUrY3
inline fu::vec<int> inter_qwDp(/*3:3*/ fu::vec_range<int> l, /*3:3*/ fu::vec_range<int> r)
{
    if (r.size() < l.size())
        return inter_qwDp(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_BbIT(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

Lifetime_E5K4 Lifetime_inter_LtD7(/*3:3*/ const Lifetime_E5K4& a, /*3:3*/ const Lifetime_E5K4& b)
{
    return Lifetime_E5K4 { inter_qwDp(a.uni0n, b.uni0n) };
}

#endif

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_UnusedCall, N_COWRestrict

========

        struct Type { canon: string; quals: i32 };
        struct Node { type: Type; value: string };

        let t_f32 = Type("f32", 2);
        let t_f64 = Type("f32", 2);

        fn solveReal(lax v: string, type: Type): Type {
            if (type.canon == t_f32.canon) return t_f32;
            return t_f64;
        }

        fn tryRetype(node: Node, expect: Type): Type {
            return solveReal(node.value, expect);
        }

        fn main() {
            let a = Node(t_f64, "0.0");
            let b = tryRetype(a, t_f32);
            return b.canon == "f32" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>

struct Type_Amej;

                                #ifndef DEF_Type_Amej1c7U605
                                #define DEF_Type_Amej1c7U605
struct Type_Amej
{
                                // shape_hash:    8668dcc37de424a3
                                // non_triv_mask: 0000800000100000
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_Amej t_f32 fu_INIT_PRIORITY(1001) = Type_Amej { fu::str("f32"_fu), 2 };

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static const Type_Amej t_f64 fu_INIT_PRIORITY(1001) = Type_Amej { fu::str("f32"_fu), 2 };

static const Type_Amej& solveReal_MbR9(/*3:3*/ const Type_Amej& type)
{
    if (type.canon == t_f32.canon)
        return t_f32;
    else
        return t_f64;

}

static const Type_Amej& tryRetype_MbR9(/*3:3*/ const Type_Amej& expect)
{
    return solveReal_MbR9(expect);
}

int fu_MAIN()
{
    const Type_Amej& /*static*/ b = tryRetype_MbR9(t_f32);
    if (b.canon == "f32"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet, N_SD_HasStaticInit

========

        fn main() {
            nocopy struct Nc { items: Nc[]; };

            fn rem_odd(ref items: Nc[])
                for (mut i = items.len; i --> 0; )
                    if (i & 1)
                        items.splice(i, 1);

            mut items: Nc[];
            for (mut i = 0; i < 11; i++)
                items ~= Nc(i & 1 ? [ Nc ] : [ Nc, Nc ]);

            rem_odd(items);

            mut sum = 0;
            fn visit(shadow items: Nc[..])
            {
                fn visit(nc: Nc) {
                    sum++;
                    visit(nc.items);
                }

                for (mut i = 0; i < items.len; i++)
                    visit(items[i]);
            }

            visit(items);
            return sum == 18 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(1792) uniq_count(13) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Nc_eDrX;
static void visit_MbR9(fu::view<Nc_eDrX>, int&);

                                #ifndef DEF_Nc_eDrXKVxuCH1
                                #define DEF_Nc_eDrXKVxuCH1
struct Nc_eDrX
{
                                // shape_hash:    41ba2365d3aa7d31
                                // non_triv_mask: 4000010000000000
    fu::vec<Nc_eDrX> items;
    Nc_eDrX(const Nc_eDrX&) = delete;
    Nc_eDrX(Nc_eDrX&&) = default;
    Nc_eDrX& operator=(const Nc_eDrX&) = delete;
    Nc_eDrX& operator=(Nc_eDrX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void rem_odd_MbR9(/*1:1*/ fu::vec_range_mut<Nc_eDrX> items)
{
    for (int i = items.size(); i-- > 0; )
    {
        if (i & 1)
            items.splice(i, 1);

    };
}

static void visit_kGbb(/*3:3*/ const Nc_eDrX& nc, /*2:2*/ int& sum)
{
    sum++;
    visit_MbR9(nc.items, sum);
}

static void visit_MbR9(/*3:3*/ fu::view<Nc_eDrX> items, /*2:2*/ int& sum)
{
    for (int i = 0; i < items.size(); i++)
        visit_kGbb(items[i], sum);

}

int fu_MAIN()
{
    fu::vec<Nc_eDrX> items {};
    for (int i = 0; i < 11; i++)
    {
        items += Nc_eDrX { ((i & 1) ? fu::vec<Nc_eDrX> {{ Nc_eDrX{} }} : fu::vec<Nc_eDrX> {{ Nc_eDrX{}, Nc_eDrX{} }}) };
    };
    rem_odd_MbR9(items);
    int sum = 0;
    visit_MbR9(items, sum);
    if (sum == 18)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_DeadCode

========

        let SMTH = false;                                       // !DEV_DontFoldLiterals
        fn LITFIX(reason: f32) reason;
        fn litfix(lax mut reason: string) LITFIX(SMTH ? reason : 0);
        fn main() litfix("hello").i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static float LITFIX_MbR9(/*1:1*/ const float reason)
{
    return reason;
}

static float litfix_MbR9()
{
    return LITFIX_MbR9(0.0f);
}

int fu_MAIN()
{
    return int(litfix_MbR9());
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let SMTH = false;

        fn FAIL(reason: string, implicit ref log: string)
            log ~= reason ~ '\n';

        fn fail_appendStack(lax mut reason: string)
            SMTH ? reason : [];

        fn fail(mut reason: string)
            FAIL(reason.fail_appendStack());

        fn main() {
            implicit mut log = "";
            fail("Hello!");
            return log.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_SMTH
                                #define DEF_SMTH
inline constexpr bool SMTH = false;
                                #endif

#ifndef fu_NO_fdefs

static fu::str fail_appendStack_MbR9(/*MOV*/ fu::str&& reason)
{
    if (SMTH)
        return reason.destructive_move();
    else
    {
        return fu::str{};
    };
}

static fu::view<char> FAIL_GL0m(/*3:3*/ fu::view<char> reason, /*2:2*/ fu::vec_range_mut<char> log)
{
    return (log += (reason + '\n'));
}

static fu::view<char> fail_GL0m(/*MOV*/ fu::str&& reason, /*3:3*/ fu::vec_range_mut<char> log)
{
    return FAIL_GL0m(fail_appendStack_MbR9(reason.destructive_move()), log);
}

int fu_MAIN()
{
    fu::str log = fu::str(""_fu);
    fail_GL0m(fu::str("Hello!"_fu), log);
    return log.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit, N_COWRestrict

========

        let SMTH = false;

        fn FAIL(reason: string, implicit ref log: string)
            log ~= reason ~ '\n';

        fn fail_appendStack(lax mut reason: string)
            SMTH ? reason : [];

        fn fail(mut reason: string)
            FAIL(reason.fail_appendStack());

        fn main() {
            implicit mut log = "";
            fail("Hello!");
            return log.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::view<char> FAIL_GL0m(/*3:3*/ fu::view<char> reason, /*2:2*/ fu::vec_range_mut<char> log)
{
    return (log += (reason + '\n'));
}

static fu::view<char> fail_GL0m(/*3:3*/ fu::vec_range_mut<char> log)
{
    return FAIL_GL0m(fu::view<char>{}, log);
}

int fu_MAIN()
{
    fu::str log {};
    fail_GL0m(log);
    return log.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit, N_COWRestrict

========

        struct Type { quals: i32 };
        pub fn tryLookupUserType(type: Type) = type;
        fn propagateType(type: Type) {
            let s = tryLookupUserType(type);
            if (s.quals != 13 || true) return 17;
            return 19;
        }

        fn main = 1.Type.propagateType - 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_F0he;

                                #ifndef DEF_Type_F0henG0NXOa
                                #define DEF_Type_F0henG0NXOa
struct Type_F0he
{
                                // shape_hash:    dabc56846d3fc0e7
                                // non_triv_mask: 0000000000000000
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const Type_F0he& tryLookupUserType_MbR9(/*1:1*/ const Type_F0he& type)
{
    return type;
}

static int propagateType_MbR9(/*1:1*/ const Type_F0he& type)
{
    const Type_F0he& /*type*/ s = tryLookupUserType_MbR9(type);
    if ((s.quals != 13) || true)
        return 17;
    else
        return 19;

}

int fu_MAIN()
{
    return propagateType_MbR9(Type_F0he { 1 }) - 17;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { quals: i32 };
        pub fn tryLookupUserType(type: Type) = type;
        fn propagateType(type: Type) {
            let s = tryLookupUserType(type);
            if (s.quals != 13 || true) return 17;
            return 19;
        }

        fn main = 1.Type.propagateType - 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_F0he;

                                #ifndef DEF_Type_F0henG0NXOa
                                #define DEF_Type_F0henG0NXOa
struct Type_F0he
{
                                // shape_hash:    dabc56846d3fc0e7
                                // non_triv_mask: 0000000000000000
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const Type_F0he& tryLookupUserType_MbR9(/*1:1*/ const Type_F0he& type)
{
    return type;
}

static int propagateType_MbR9()
{
    return 17;
}

int fu_MAIN()
{
    return propagateType_MbR9() - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedAndOr, N_UnusedLet

========


        noinline        
        fn voidfn(ref a: i32) { a += 100; }


        noinline        
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void voidfn_MbR9(/*1:1*/ int& a)
{
    a += 100;
}

static void returnVoidExpr_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    while (b-- > 0)
    {
        a++;
        if (a & 1)
        {
            voidfn_MbR9(a);
            return;
        };
    };
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;
    returnVoidExpr_MbR9(a, b);
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        noinline        
        fn voidfn(ref a: i32) { a += 100; }


        inline   // Goto
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void voidfn_MbR9(/*1:1*/ int& a)
{
    a += 100;
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;

    { {
        while (b-- > 0)
        {
            a++;
            if (a & 1)
            {
                voidfn_MbR9(a);
                goto BL_1;
            };
        };
      } BL_1:;
    };
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        inline          
        fn voidfn(ref a: i32) { a += 100; }


        noinline        
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void returnVoidExpr_MbR9(/*3:1*/ int& a, /*3:2*/ int& b)
{
    while (b-- > 0)
    {
        a++;
        if (a & 1)
        {
            a += 100;
            return;
        };
    };
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;
    returnVoidExpr_MbR9(a, b);
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        inline          
        fn voidfn(ref a: i32) { a += 100; }


        inline   // Goto
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    int b = 10;

    { {
        while (b-- > 0)
        {
            a++;
            if (a & 1)
            {
                a += 100;
                goto BL_1;
            };
        };
      } BL_1:;
    };
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(implicit) = implicit;
        fn main() = 0.hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_0DCJaE9X1mk
                                #define DEF_hello_0DCJaE9X1mk
inline static int hello_0DCJ(/*1:1*/ const int implicit)
{
    return implicit;
}
                                #endif

int fu_MAIN()
{
    return hello_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(implicit: i32) = implicit;
        fn main() = 0.hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hello_MbR9(/*1:1*/ const int implicit)
{
    return implicit;
}

int fu_MAIN()
{
    return hello_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn voidIf(ref a: i32, ref b: u32)

            a   ? a++
                : b++;


        fn main() {
            mut a: i32;
            mut b: u32;
            voidIf(:a, :b);
            return !a && b ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+1[0m:

[2m      |         fn voidIf(ref a: i32, ref b: u32)[0m
[2m      | [0m
[2m    4 | [0m            a   [31;1m?[0m a++
[2m      |                 : b++;[0m
[2m      | [0m

	if/else: No common supertype: [35;3mi32[0m <-> [35;3mu32[0m

        Solving [35;3mfn[0m [94;1mvoidIf[0m([35;3mi32[0m, [35;3mu32[0m) at [2m2:12+6[0m

========

        fn voidIf(ref a: i32, ref b: u32)

            if (a)  a++;
            else    b++;


        fn main() {
            mut a: i32;
            mut b: u32;
            voidIf(:a, :b);
            return !a && b ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void voidIf_MbR9(/*3:3*/ int& a, /*3:3*/ unsigned& b)
{
    if (a)
        a++;
    else
        b++;

}

int fu_MAIN()
{
    int a {};
    unsigned b {};
    voidIf_MbR9(a, b);
    if (!a && b)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct ScopeItem { id: string; uval: u32 }

        fn search(ref items: ScopeItem[..], id: string, ref scope_iterator: i32): u32
        {
            if (!scope_iterator)
                scope_iterator = items.len;

            defer if (scope_iterator == 0)
                scope_iterator = -1;

            while (scope_iterator --> 0) {
                let item = items[scope_iterator];
                if (item.id == id)
                    return item.uval;
            }

            return [];
        }

        fn main() {
            mut items = [ ScopeItem("a", 1), ScopeItem("a", 2), ScopeItem("a", 3) ];
            mut scope_iterator = 0;
            mut uval: u32;

            mut result: u32;
            while ((uval = items.search("a", scope_iterator)))
                result += uval;

            return (result - 6).signed;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>

struct ScopeItem_m3Ns;

                                #ifndef DEF_ScopeItem_m3NsOZT7GH0
                                #define DEF_ScopeItem_m3NsOZT7GH0
struct ScopeItem_m3Ns
{
                                // shape_hash:    471486704b1b4380
                                // non_triv_mask: 0000800000000100
    fu::str id;
    unsigned uval;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || uval
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static unsigned search_MbR9(/*7:7*/ fu::view<ScopeItem_m3Ns> items, /*7:7*/ fu::view<char> id, /*5:4*/ int& scope_iterator)
{
    if (!scope_iterator)
        scope_iterator = items.size();

    fu_DEFER(if (scope_iterator == 0)
        scope_iterator = -1;);
    while (scope_iterator-- > 0)
    {
        const ScopeItem_m3Ns& /*items|static*/ item = items[scope_iterator];
        if (item.id == id)
            return item.uval;

    };
    return 0u;
}

                                #ifndef DEF_sIgned_TtUcjtJxdkl
                                #define DEF_sIgned_TtUcjtJxdkl
inline int sIgned_TtUc(const unsigned v)
{
    return int(v);
}
                                #endif

int fu_MAIN()
{
    fu::vec<ScopeItem_m3Ns> items = fu::vec<ScopeItem_m3Ns> {{ ScopeItem_m3Ns { fu::str("a"_fu), 1u }, ScopeItem_m3Ns { fu::str("a"_fu), 2u }, ScopeItem_m3Ns { fu::str("a"_fu), 3u } }};
    int scope_iterator = 0;
    unsigned uval {};
    unsigned result {};
    while ((uval = search_MbR9(items, "a"_view, scope_iterator)))
        result += uval;

    return sIgned_TtUc((result - 6u));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn woot!E (e?: E) {
            if (E -> [])
                return 2;
            else
                return e(3);
        }

        fn main() woot * woot(|x| x * 5) - 30;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_woot_jWbYEq7byC4
                                #define DEF_woot_jWbYEq7byC4
inline static int woot_jWbY()
{
    return 2;
}
                                #endif

                                #ifndef DEF___Uxar5cdpoYc
                                #define DEF___Uxar5cdpoYc
inline static int _Uxar(const int x)
{
    return x * 5;
}
                                #endif

                                #ifndef DEF_woot_opequLSjyxi
                                #define DEF_woot_opequLSjyxi
inline static int woot_opeq()
{
    return _Uxar(3);
}
                                #endif

int fu_MAIN()
{
    return (woot_jWbY() * woot_opeq()) - 30;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn woot(myfn) myfn(1);

        fn main() {
            mut sum = 0;            // PARSE DRAMA
            woot: |one| sum += one; //  stmt lambda, followed by
            (sum += 1) += 1;        //   '(' which continued as-if-expr
            return sum -3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int one, /*3:3*/ int& sum)
{
    return (sum += one);
}
                                #endif

                                #ifndef DEF_woot_LIt6pFZczni
                                #define DEF_woot_LIt6pFZczni
inline static int woot_LIt6(/*3:3*/ int& sum)
{
    return _5aAg(1, sum);
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    woot_LIt6(sum);
    (sum += 1) += 1;
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let PROFILE = false;               // !DEV_DontFoldLiterals

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

        import _0;
        fn main() {
            mut a: Item;
            a += Item();
            return a.get();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int get_MbR9();

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return get_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

                                #ifndef DEF_PROFILE
                                #define DEF_PROFILE
inline constexpr bool PROFILE = false;
                                #endif

#ifndef fu_NO_fdefs

void x2Bx3D_MbR9()
{
}

int get_MbR9()
{
    return 0;
}

#endif

// N_SD_HasStaticInit

========

        let PROFILE = true;               // !DEV_DontFoldLiterals

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

        import _0;
        fn main() {
            mut a: Item;
            a += Item();
            return a.get();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NonEmpty_fIps;
void operator+=(NonEmpty_fIps&, const NonEmpty_fIps&);
int get_MbR9(const NonEmpty_fIps&);

                                #ifndef DEF_NonEmpty_fIpsnwCywUk
                                #define DEF_NonEmpty_fIpsnwCywUk
struct NonEmpty_fIps
{
                                // shape_hash:    b23537e83da4293f
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    NonEmpty_fIps a {};
    a += NonEmpty_fIps{};
    return get_MbR9(a);
}

#endif

int main() { return fu_MAIN(); }
struct NonEmpty_fIps;

                                #ifndef DEF_PROFILE
                                #define DEF_PROFILE
inline constexpr bool PROFILE = true;
                                #endif

                                #ifndef DEF_NonEmpty_fIpsnwCywUk
                                #define DEF_NonEmpty_fIpsnwCywUk
struct NonEmpty_fIps
{
                                // shape_hash:    b23537e83da4293f
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void operator+=(/*3:3*/ NonEmpty_fIps& a, /*3:3*/ const NonEmpty_fIps& b)
{
    a.v += b.v;
}

int get_MbR9(/*1:1*/ const NonEmpty_fIps& a)
{
    return a.v;
}

#endif

// N_SD_HasStaticInit

========

        fn test(x: i32): bool   
            let y = x > 10;     

        fn main() test(3).i32;

---- <fail> ----
[2m[0m_0[2m.fu 3:17+1[0m:

[2m      | [0m
[2m      |         fn test(x: i32): bool   [0m
[2m    3 | [0m            let [31;1my[0m = x > 10;     
[2m      | [0m
[2m      |         fn main() test(3).i32;[0m

	[35;3mfn[0m [94;1mtest[0m is missing a final return statement: expects [35;3mbool[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(x: i32): bool   
                    x > 10;     

        fn main() test(3).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static bool test_MbR9(const int x)
{
    return x > 10;
}

int fu_MAIN()
{
    return int(test_MbR9(3));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            struct Node {};

            fn evalTypeAnnot(node: Node): bool =        
                return node && [];                      

            fn trySolveTypeParams(node: Node): bool =
                evalTypeAnnot(node);

            return trySolveTypeParams([]) && 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:24+4[0m:

[2m      | [0m
[2m      |             fn evalTypeAnnot(node: Node): bool =        [0m
[2m    6 | [0m                return [31;1mnode[0m && [];                      
[2m      | [0m
[2m      |             fn trySolveTypeParams(node: Node): bool =[0m

	Condition is an always-empty [35;3mstruct[0m [94;1mNode[0m, not meaningful in a boolean context.

	If this is expected, use [94;1m!=[0m [35;3m[][0m to suppress this warning.

        Solving [35;3mfn[0m [94;1mevalTypeAnnot[0m([94;1mNode[0m) at [2m5:16+13[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            struct Node {};

            fn evalTypeAnnot(node: Node): bool =        
                return node != [] && [];                

            fn trySolveTypeParams(node: Node): bool =
                evalTypeAnnot(node);

            return trySolveTypeParams([]) && 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        fn main() {
            struct Node { v: int };

            fn evalTypeAnnot(node: Node): bool =
                return node && [];

            fn trySolveTypeParams(node: Node): bool =   
                let expect = evalTypeAnnot(node);       

            return trySolveTypeParams([]) && 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:21+6[0m:

[2m      | [0m
[2m      |             fn trySolveTypeParams(node: Node): bool =   [0m
[2m    9 | [0m                let [31;1mexpect[0m = evalTypeAnnot(node);       
[2m      | [0m
[2m      |             return trySolveTypeParams([]) && 0;[0m

	[35;3mfn[0m [94;1mtrySolveTypeParams[0m is missing a final return statement: expects [35;3mbool[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mtrySolveTypeParams[0m([94;1mNode[0m) at [2m8:16+18[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            struct Node { v: int };

            fn evalTypeAnnot(node: Node) =
                return !!node;

            fn trySolveTypeParams(node: Node): bool =   
                let expect = evalTypeAnnot(node);       

            return trySolveTypeParams([]) && 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:21+6[0m:

[2m      | [0m
[2m      |             fn trySolveTypeParams(node: Node): bool =   [0m
[2m    9 | [0m                let [31;1mexpect[0m = evalTypeAnnot(node);       
[2m      | [0m
[2m      |             return trySolveTypeParams([]) && 0;[0m

	[35;3mfn[0m [94;1mtrySolveTypeParams[0m is missing a final return statement: expects [35;3mbool[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mtrySolveTypeParams[0m([94;1mNode[0m) at [2m8:16+18[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            struct Node { v: int };

            fn evalTypeAnnot(node: Node): bool =
                return node && [];

            fn trySolveTypeParams(node: Node): bool =   
                             evalTypeAnnot(node);       

            return trySolveTypeParams([]) && 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn main() {
            struct Node { v: int };

            fn evalTypeAnnot(node: Node) =
                return !!node;

            fn trySolveTypeParams(node: Node): bool =   
                             evalTypeAnnot(node);       

            return trySolveTypeParams([]) && 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Node_0h15;

                                #ifndef DEF_Node_0h15beqscl8
                                #define DEF_Node_0h15beqscl8
struct Node_0h15
{
                                // shape_hash:    a6b1e470da2f9216
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool evalTypeAnnot_MbR9(/*1:1*/ const Node_0h15& node)
{
    return !!node;
}

static bool trySolveTypeParams_MbR9(/*1:1*/ const Node_0h15& node)
{
    return evalTypeAnnot_MbR9(node);
}

int fu_MAIN()
{
    if (trySolveTypeParams_MbR9(Node_0h15{}))
        return 0;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Scope    { overloads: Overload[]; extended: Extended[] };
        struct Overload { name: string };
        struct Extended { locals?: Overload[] };

        fn Scope_create(ref scope: Scope, name: string, nest!?: i32): i32 {
            ref overloads = nest > 0
                ? scope.extended.grow_if_oob(nest - 1).locals
                : scope.overloads;

            overloads.push(Overload(:name));
            return overloads.len;
        }

        fn main() {
            mut scope = Scope(
                overloads:  [ Overload("Hello!") ],
                extended:   []);

            let a = scope.Scope_create("World!", nest: 1);
            let b = scope.Scope_create("Bananas!");
            return a * 10 + b - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Scope_2Feg;
struct Overload_BK87;
struct Extended_68Ao;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_68Aop92bMcb
                                #define DEF_Extended_68Aop92bMcb
struct Extended_68Ao
{
                                // shape_hash:    6318a81d2af26828
                                // non_triv_mask: 0000808020000400
    fu::vec<Overload_BK87> locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_2Feg21Shvaa
                                #define DEF_Scope_2Feg21Shvaa
struct Scope_2Feg
{
                                // shape_hash:    8a71ce81b8b13767
                                // non_triv_mask: 0000808020100500
    fu::vec<Overload_BK87> overloads;
    fu::vec<Extended_68Ao> extended;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
        ;
    }
};
                                #endif

                                #ifndef STR_K00VsFkercl
                                #define STR_K00VsFkercl
static const fu::str str_K00VsFkercl fu_INIT_PRIORITY(1001) { "World!"_fu };
                                #endif

                                #ifndef STR_ZfO4UyQsPXc
                                #define STR_ZfO4UyQsPXc
static const fu::str str_ZfO4UyQsPXc fu_INIT_PRIORITY(1001) { "Bananas!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_S7jDh4wAeHf
                                #define DEF_grow_if_oob_S7jDh4wAeHf
inline static Extended_68Ao& grow_if_oob_S7jD(/*3:3*/ fu::vec_range_mut<Extended_68Ao> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static int Scope_create_MbR9(/*5:5*/ Scope_2Feg& scope, /*7:7*/ fu::vec_range<char> name, const int nest)
{
    fu::vec<Overload_BK87>& /*scope|static*/ overloads = ((nest > 0) ? grow_if_oob_S7jD(scope.extended, (nest - 1)).locals : scope.overloads);
    overloads.push(Overload_BK87 { fu::str(name) });
    return overloads.size();
}

int fu_MAIN()
{
    Scope_2Feg scope = Scope_2Feg { fu::vec<Overload_BK87> {{ Overload_BK87 { fu::str("Hello!"_fu) } }}, fu::vec<Extended_68Ao>{} };
    const int a = Scope_create_MbR9(scope, str_K00VsFkercl, 1);
    const int b = Scope_create_MbR9(scope, str_ZfO4UyQsPXc, 0);
    return ((a * 10) + b) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn bfind !T(keys, item: T, hit, miss) {
            mut lo = 0;
            mut hi = keys.len;

            while (lo < hi) {
                let i   = (hi + lo) >> 1;
                let cmp = keys[i] <> item;
                if (cmp == 0)
                    return hit(i);
            }

            return miss(lo);
        }

        fn update !<T, U>(keys, item: T, extras, extra: U)
            bfind(fn keys, :item,
                hit:  |i| { extras[i] = extra; },
                miss: |_| {});

        fn get !<T, U>(keys: T[], item: T, extras: U[])
            bfind(:keys, :item,
                hit:  |i| { return extras[i]; },
                miss: |_| { return []; });

        fn Map(type K, type V)
            struct { keys: K[]; vals: V[] };

        fn set(using ref _: Map(_, _), key, value)
            update(|| keys, key, || vals, value);

        fn get(using _: Map(_, _), key)
            get(keys, key, vals);

        fn resolveFile(ref cache: Map(string, string), path: string): string
        {
            if (let cached = cache.get(path))
                return cached == "" ? "" : cached;

            cache.set(path, "");
            return "";
        }

        fn main() {
            mut cache: Map(string, string);
            return cache.resolveFile("abc").len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Map_VMIG;

                                #ifndef DEF_Map_VMIGQbNAY20
                                #define DEF_Map_VMIGQbNAY20
struct Map_VMIG
{
                                // shape_hash:    95dd75099603f800
                                // non_triv_mask: 0000c02000000000
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

                                #ifndef STR_DtiAaUK6319
                                #define STR_DtiAaUK6319
static const fu::str str_DtiAaUK6319 fu_INIT_PRIORITY(1001) { "\v"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_get_LuFGZMGzLx4
                                #define DEF_get_LuFGZMGzLx4
inline static fu::vec_range<char> get_LuFG(/*7:7*/ fu::view<fu::str> keys, /*7:7*/ fu::view<char> item, /*7:7*/ fu::view<fu::str> extras)
{
    const int lo = 0;
    const int hi = keys.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys[i], item);
        if (cmp == 0)
            return extras[i];

    };
    return fu::vec_range<char>{};
}
                                #endif

                                #ifndef DEF_get_uCSsfowt4Cl
                                #define DEF_get_uCSsfowt4Cl
inline static fu::vec_range<char> get_uCSs(/*3:3*/ const Map_VMIG& _, /*3:3*/ fu::view<char> key)
{
    return get_LuFG(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF___5gtVj26DRV2
                                #define DEF___5gtVj26DRV2
inline static fu::view<fu::str> _5gtV(/*1:1*/ const Map_VMIG& _)
{
    return _.keys;
}
                                #endif

                                #ifndef DEF___9PEhfQg6KP7
                                #define DEF___9PEhfQg6KP7
inline static fu::view_mut<fu::str> _9PEh(/*1:1*/ Map_VMIG& _)
{
    return _.vals;
}
                                #endif

                                #ifndef DEF_hit_csMHIoaU4pk
                                #define DEF_hit_csMHIoaU4pk
inline static void hit_csMH(const int i, /*7:7*/ fu::vec_range<char> extra, /*7:7*/ Map_VMIG& _)
{
    _9PEh(_).mutref(i) = fu::str(extra);
}
                                #endif

                                #ifndef DEF_bfind_QuVeZt2gIX7
                                #define DEF_bfind_QuVeZt2gIX7
inline static void bfind_QuVe(/*F3:F3*/ fu::view<char> item, /*F3:F3*/ fu::vec_range<char> extra, /*F3:F3*/ Map_VMIG& _)
{
    const int lo = 0;
    const int hi = _5gtV(_).size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(_5gtV(_)[i], item);
        if (cmp == 0)
        {
            hit_csMH(i, extra, _);
            return;
        };
    };
}
                                #endif

                                #ifndef DEF_update_rnXQhimHA91
                                #define DEF_update_rnXQhimHA91
inline static void update_rnXQ(/*F1:F1*/ fu::view<char> item, /*F1:F1*/ fu::vec_range<char> extra, /*F1:F1*/ Map_VMIG& _)
{
    bfind_QuVe(item, extra, _);
}
                                #endif

                                #ifndef DEF_set_2qSp0bXC50i
                                #define DEF_set_2qSp0bXC50i
inline static void set_2qSp(/*7:7*/ Map_VMIG& _, /*7:7*/ fu::view<char> key, /*7:7*/ fu::vec_range<char> value)
{
    update_rnXQ(key, value, _);
}
                                #endif

static fu::vec_range<char> resolveFile_MbR9(/*3:3*/ Map_VMIG& cache, /*3:3*/ fu::view<char> path)
{
    fu::vec_range<char> cached {};
    if (cached.ptr_reassign(get_uCSs(cache, path)))
    {
        if (cached == "\v"_view)
            return str_00000000000;
        else
            return cached;

    }
    else
    {
        set_2qSp(cache, path, str_DtiAaUK6319);
        return str_00000000000;
    };
}

int fu_MAIN()
{
    Map_VMIG cache {};
    return resolveFile_MbR9(cache, "abc"_view).size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedLet

========

        fn bfind !T(keys, item: T, hit, miss) {
            mut lo = 0;
            mut hi = keys.len;

            while (lo < hi) {
                let i   = (hi + lo) >> 1;
                let cmp = keys[i] <> item;
                if (cmp == 0)
                    return hit(i);
            }

            return miss(lo);
        }

        fn update !<T, U>(keys, item: T, extras, extra: U)
            bfind(fn keys, :item,
                hit:  |i| { extras[i] = extra; },
                miss: |_| {});

        fn get !<T, U>(keys: T[], item: T, extras: U[])
            bfind(:keys, :item,
                hit:  |i| { return extras[i]; },
                miss: |_| { return []; });

        fn Map(type K, type V)
            struct { keys: K[]; vals: V[] };

        fn set(using ref _: Map(_, _), key, value)
            update(|| keys, key, || vals, value);

        fn get(using _: Map(_, _), key)
            get(keys, key, vals);

        fn resolveFile(ref cache: Map(string, string), path: string): string
        {
            if (let cached = cache.get(path))
                return cached == "" ? "" : cached;

            cache.set(path, "");
            return "";
        }

        fn main() {
            mut cache: Map(string, string);
            return cache.resolveFile("abc").len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Map_VMIG;

                                #ifndef DEF_Map_VMIGQbNAY20
                                #define DEF_Map_VMIGQbNAY20
struct Map_VMIG
{
                                // shape_hash:    95dd75099603f800
                                // non_triv_mask: 0000c02000000000
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef STR_DtiAaUK6319
                                #define STR_DtiAaUK6319
static const fu::str str_DtiAaUK6319 fu_INIT_PRIORITY(1001) { "\v"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_get_LuFGZMGzLx4
                                #define DEF_get_LuFGZMGzLx4
inline static fu::vec_range<char> get_LuFG(/*7:7*/ fu::view<fu::str> keys, /*7:7*/ fu::view<char> item, /*7:7*/ fu::view<fu::str> extras)
{
    const int lo = 0;
    const int hi = keys.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(keys[i], item);
        if (cmp == 0)
            return extras[i];

    };
    return fu::vec_range<char>{};
}
                                #endif

                                #ifndef DEF_get_uCSsfowt4Cl
                                #define DEF_get_uCSsfowt4Cl
inline static fu::vec_range<char> get_uCSs(/*3:3*/ const Map_VMIG& _, /*3:3*/ fu::view<char> key)
{
    return get_LuFG(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF___5gtVj26DRV2
                                #define DEF___5gtVj26DRV2
inline static fu::view<fu::str> _5gtV(/*1:1*/ const Map_VMIG& _)
{
    return _.keys;
}
                                #endif

                                #ifndef DEF___9PEhfQg6KP7
                                #define DEF___9PEhfQg6KP7
inline static fu::view_mut<fu::str> _9PEh(/*1:1*/ Map_VMIG& _)
{
    return _.vals;
}
                                #endif

                                #ifndef DEF_hit_csMHIoaU4pk
                                #define DEF_hit_csMHIoaU4pk
inline static void hit_csMH(const int i, /*7:7*/ fu::vec_range<char> extra, /*7:7*/ Map_VMIG& _)
{
    _9PEh(_).mutref(i) = fu::str(extra);
}
                                #endif

                                #ifndef DEF_bfind_QuVeZt2gIX7
                                #define DEF_bfind_QuVeZt2gIX7
inline static void bfind_QuVe(/*F3:F3*/ fu::view<char> item, /*F3:F3*/ fu::vec_range<char> extra, /*F3:F3*/ Map_VMIG& _)
{
    const int lo = 0;
    const int hi = _5gtV(_).size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_j5CR(_5gtV(_)[i], item);
        if (cmp == 0)
        {
            hit_csMH(i, extra, _);
            return;
        };
    };
}
                                #endif

                                #ifndef DEF_update_rnXQhimHA91
                                #define DEF_update_rnXQhimHA91
inline static void update_rnXQ(/*F1:F1*/ fu::view<char> item, /*F1:F1*/ fu::vec_range<char> extra, /*F1:F1*/ Map_VMIG& _)
{
    bfind_QuVe(item, extra, _);
}
                                #endif

                                #ifndef DEF_set_2qSp0bXC50i
                                #define DEF_set_2qSp0bXC50i
inline static void set_2qSp(/*7:7*/ Map_VMIG& _, /*7:7*/ fu::view<char> key, /*7:7*/ fu::vec_range<char> value)
{
    update_rnXQ(key, value, _);
}
                                #endif

static fu::vec_range<char> resolveFile_MbR9(/*3:3*/ Map_VMIG& cache, /*3:3*/ fu::view<char> path)
{
    fu::vec_range<char> cached {};
    if (cached.ptr_reassign(get_uCSs(cache, path)))
    {
        if (cached == "\v"_view)
            return (*(fu::str*)fu::NIL);
        else
            return cached;

    }
    else
    {
        set_2qSp(cache, path, str_DtiAaUK6319);
        return (*(fu::str*)fu::NIL);
    };
}

int fu_MAIN()
{
    Map_VMIG cache {};
    return resolveFile_MbR9(cache, "abc"_view).size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedLet

========

        struct Target       { globid: i32; locid: i32 }
        struct Overload     { name: string }
        struct Extended     { locals: Overload[] }

        nocopy struct Scope {
            overloads: Overload[]; extended: Extended[]; total: i32
        }

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {
            ref overloads = nest
                ? scope.extended.grow_if_oob(nest.globid - 1).locals
                : scope.overloads;


            overloads ~= Overload(:name);
            let index = overloads.len;

            scope.total++;


            return Target(
                globid: nest ? nest.globid : index,
                 locid: nest ? index       : 0);
        }

        fn GET(ref scope: Scope, target: Target)
            target.locid
                ? scope.extended[target.globid - 1].locals[target.locid - 1]
                : scope.overloads[target.globid - 1];

        fn DUPE(ref scope: Scope, target: Target)
            CREATE(scope, GET(scope, target).name);

        fn main() {
            mut scope: Scope;
            let hello = scope.CREATE("hello!");
            let world = scope.CREATE("world!", nest: hello);
            scope.DUPE(world);

            mut result  = "";
            scope.overloads.each: |o, i| {
                result ~= "+" ~ o.name;
                if (scope.extended.len > i)
                    scope.extended[i].locals.each: |x|
                        result ~= "-" ~ x.name;
            }

            return scope.total == 3 && result == "+hello!-world!+world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Scope_X2In;
struct Overload_BK87;
struct Extended_68Ao;
struct Target_C55w;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_68Aop92bMcb
                                #define DEF_Extended_68Aop92bMcb
struct Extended_68Ao
{
                                // shape_hash:    6318a81d2af26828
                                // non_triv_mask: 0000808020000400
    fu::vec<Overload_BK87> locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_X2InRJmSRm9
                                #define DEF_Scope_X2InRJmSRm9
struct Scope_X2In
{
                                // shape_hash:    fdaa7dd60c5ff1d6
                                // non_triv_mask: 0000808820000500
    fu::vec<Overload_BK87> overloads;
    fu::vec<Extended_68Ao> extended;
    int total;
    Scope_X2In(const Scope_X2In&) = delete;
    Scope_X2In(Scope_X2In&&) = default;
    Scope_X2In& operator=(const Scope_X2In&) = delete;
    Scope_X2In& operator=(Scope_X2In&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || total
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_C55w2WGPODc
                                #define DEF_Target_C55w2WGPODc
struct Target_C55w
{
                                // shape_hash:    0515a606fde80439
                                // non_triv_mask: 0000000000000000
    int globid;
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
            || locid
        ;
    }
};
                                #endif

                                #ifndef STR_t7X6pg06Cy4
                                #define STR_t7X6pg06Cy4
static const fu::str str_t7X6pg06Cy4 fu_INIT_PRIORITY(1001) { "hello!"_fu };
                                #endif

                                #ifndef STR_FjAIxWhdR2c
                                #define STR_FjAIxWhdR2c
static const fu::str str_FjAIxWhdR2c fu_INIT_PRIORITY(1001) { "world!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_S7jDh4wAeHf
                                #define DEF_grow_if_oob_S7jDh4wAeHf
inline static Extended_68Ao& grow_if_oob_S7jD(/*3:3*/ fu::vec_range_mut<Extended_68Ao> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Target_C55w CREATE_MbR9(/*1:1*/ Scope_X2In& scope, /*7:7*/ fu::vec_range<char> name, /*7:7*/ const Target_C55w& nest)
{
    fu::vec<Overload_BK87>& /*scope|static*/ overloads = (nest ? grow_if_oob_S7jD(scope.extended, (nest.globid - 1)).locals : scope.overloads);
    overloads += Overload_BK87 { fu::str(name) };
    const int index = overloads.size();
    scope.total++;
    return Target_C55w { (nest ? nest.globid : index), (nest ? index : 0) };
}

static const Overload_BK87& GET_kGbb(/*3:3*/ const Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    if (target.locid)
        return scope.extended[(target.globid - 1)].locals[(target.locid - 1)];
    else
        return scope.overloads[(target.globid - 1)];

}

static Target_C55w DUPE_MbR9(/*3:3*/ Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    return CREATE_MbR9(scope, fu::str(/*bck:vi 0*/ GET_kGbb(scope, target).name), Target_C55w{});
}

                                #ifndef DEF___IX1NjxuBeA9
                                #define DEF___IX1NjxuBeA9
inline static fu::view<char> _IX1N(/*3:3*/ const Overload_BK87& x, /*2:2*/ fu::vec_range_mut<char> result)
{
    return (result += ("-"_view + x.name));
}
                                #endif

                                #ifndef DEF_each_JlYoyCmvWfh
                                #define DEF_each_JlYoyCmvWfh
inline void each_JlYo(/*7:7*/ fu::view<Overload_BK87> a, /*6:6*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < a.size(); i++)
        _IX1N(a[i], result);

}
                                #endif

                                #ifndef DEF___EBoIPBvJsAc
                                #define DEF___EBoIPBvJsAc
inline static void _EBoI(/*F:F*/ const Overload_BK87& o, const int i, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::vec_range_mut<char> result)
{
    result += ("+"_view + o.name);
    if (scope.extended.size() > i)
        each_JlYo(scope.extended[i].locals, result);

}
                                #endif

                                #ifndef DEF_each_CIaVIBrFhZ9
                                #define DEF_each_CIaVIBrFhZ9
inline void each_CIaV(/*F:F*/ fu::view<Overload_BK87> a, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < a.size(); i++)
        _EBoI(a[i], i, scope, result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Scope_X2In scope {};
    const Target_C55w hello = CREATE_MbR9(scope, str_t7X6pg06Cy4, Target_C55w{});
    const Target_C55w world = CREATE_MbR9(scope, str_FjAIxWhdR2c, hello);
    DUPE_MbR9(scope, world);
    fu::str result = fu::str(""_fu);
    each_CIaV(scope.overloads, scope, result);
    if ((scope.total == 3) && (result == "+hello!-world!+world!"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq, N_COWRestrict

========

        struct Target       { globid: i32; locid: i32 }
        struct Overload     { name: string }
        struct Extended     { locals: Overload[] }

        nocopy struct Scope {
            overloads: Overload[]; extended: Extended[]; total: i32
        }

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {
            ref overloads = nest
                ? scope.extended.grow_if_oob(nest.globid - 1).locals
                : scope.overloads;


            overloads ~= Overload(:name);
            let index = overloads.len;

            scope.total++;


            return Target(
                globid: nest ? nest.globid : index,
                 locid: nest ? index       : 0);
        }

        fn GET(ref scope: Scope, target: Target)
            target.locid
                ? scope.extended[target.globid - 1].locals[target.locid - 1]
                : scope.overloads[target.globid - 1];

        fn DUPE(ref scope: Scope, target: Target)
            CREATE(scope, GET(scope, target).name);

        fn main() {
            mut scope: Scope;
            let hello = scope.CREATE("hello!");
            let world = scope.CREATE("world!", nest: hello);
            scope.DUPE(world);

            mut result  = "";
            scope.overloads.each: |o, i| {
                result ~= "+" ~ o.name;
                if (scope.extended.len > i)
                    scope.extended[i].locals.each: |x|
                        result ~= "-" ~ x.name;
            }

            return scope.total == 3 && result == "+hello!-world!+world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Scope_X2In;
struct Overload_BK87;
struct Extended_68Ao;
struct Target_C55w;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_68Aop92bMcb
                                #define DEF_Extended_68Aop92bMcb
struct Extended_68Ao
{
                                // shape_hash:    6318a81d2af26828
                                // non_triv_mask: 0000808020000400
    fu::vec<Overload_BK87> locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_X2InRJmSRm9
                                #define DEF_Scope_X2InRJmSRm9
struct Scope_X2In
{
                                // shape_hash:    fdaa7dd60c5ff1d6
                                // non_triv_mask: 0000808820000500
    fu::vec<Overload_BK87> overloads;
    fu::vec<Extended_68Ao> extended;
    int total;
    Scope_X2In(const Scope_X2In&) = delete;
    Scope_X2In(Scope_X2In&&) = default;
    Scope_X2In& operator=(const Scope_X2In&) = delete;
    Scope_X2In& operator=(Scope_X2In&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || total
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_C55w2WGPODc
                                #define DEF_Target_C55w2WGPODc
struct Target_C55w
{
                                // shape_hash:    0515a606fde80439
                                // non_triv_mask: 0000000000000000
    int globid;
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
            || locid
        ;
    }
};
                                #endif

                                #ifndef STR_t7X6pg06Cy4
                                #define STR_t7X6pg06Cy4
static const fu::str str_t7X6pg06Cy4 fu_INIT_PRIORITY(1001) { "hello!"_fu };
                                #endif

                                #ifndef STR_FjAIxWhdR2c
                                #define STR_FjAIxWhdR2c
static const fu::str str_FjAIxWhdR2c fu_INIT_PRIORITY(1001) { "world!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_S7jDh4wAeHf
                                #define DEF_grow_if_oob_S7jDh4wAeHf
inline static Extended_68Ao& grow_if_oob_S7jD(/*3:3*/ fu::vec_range_mut<Extended_68Ao> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Target_C55w CREATE_MbR9(/*1:1*/ Scope_X2In& scope, /*7:7*/ fu::vec_range<char> name, /*7:7*/ const Target_C55w& nest)
{
    fu::vec<Overload_BK87>& /*scope|static*/ overloads = (nest ? grow_if_oob_S7jD(scope.extended, (nest.globid - 1)).locals : scope.overloads);
    overloads += Overload_BK87 { fu::str(name) };
    const int index = overloads.size();
    scope.total++;
    return Target_C55w { (nest ? nest.globid : index), (nest ? index : 0) };
}

static const Overload_BK87& GET_kGbb(/*3:3*/ const Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    if (target.locid)
        return scope.extended[(target.globid - 1)].locals[(target.locid - 1)];
    else
        return scope.overloads[(target.globid - 1)];

}

static Target_C55w DUPE_MbR9(/*3:3*/ Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    return CREATE_MbR9(scope, fu::str(/*bck:vi 0*/ GET_kGbb(scope, target).name), Target_C55w{});
}

                                #ifndef DEF___IX1NjxuBeA9
                                #define DEF___IX1NjxuBeA9
inline static fu::view<char> _IX1N(/*3:3*/ const Overload_BK87& x, /*2:2*/ fu::str& result)
{
    return (result += ("-"_view + x.name));
}
                                #endif

                                #ifndef DEF_each_JlYoyCmvWfh
                                #define DEF_each_JlYoyCmvWfh
inline void each_JlYo(/*7:7*/ fu::view<Overload_BK87> a, /*6:6*/ fu::str& result)
{
    for (int i = 0; i < a.size(); i++)
        _IX1N(a[i], result);

}
                                #endif

                                #ifndef DEF___EBoIPBvJsAc
                                #define DEF___EBoIPBvJsAc
inline static void _EBoI(/*F:F*/ const Overload_BK87& o, const int i, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::str& result)
{
    result += ("+"_view + o.name);
    if (scope.extended.size() > i)
        each_JlYo(scope.extended[i].locals, result);

}
                                #endif

                                #ifndef DEF_each_CIaVIBrFhZ9
                                #define DEF_each_CIaVIBrFhZ9
inline void each_CIaV(/*F:F*/ fu::view<Overload_BK87> a, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::str& result)
{
    for (int i = 0; i < a.size(); i++)
        _EBoI(a[i], i, scope, result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Scope_X2In scope {};
    const Target_C55w hello = CREATE_MbR9(scope, str_t7X6pg06Cy4, Target_C55w{});
    const Target_C55w world = CREATE_MbR9(scope, str_FjAIxWhdR2c, hello);
    DUPE_MbR9(scope, world);
    fu::str result {};
    each_CIaV(scope.overloads, scope, result);
    if ((scope.total == 3) && (result == "+hello!-world!+world!"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq, N_COWRestrict

========

        struct Target       { globid: i32; locid: i32 }
        struct Overload     { name: string }
        struct Extended     { locals: Overload[] }

        nocopy struct Scope {
            overloads: Overload[]; extended: Extended[]; total: i32
        }

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {
            ref overloads = nest
                ? scope.extended.grow_if_oob(nest.globid - 1).locals
                : scope.overloads;


            scope.total++;

            overloads ~= Overload(:name);
            let index = overloads.len;


            return Target(
                globid: nest ? nest.globid : index,
                 locid: nest ? index       : 0);
        }

        fn GET(ref scope: Scope, target: Target)
            target.locid
                ? scope.extended[target.globid - 1].locals[target.locid - 1]
                : scope.overloads[target.globid - 1];

        fn DUPE(ref scope: Scope, target: Target)
            CREATE(scope, GET(scope, target).name);

        fn main() {
            mut scope: Scope;
            let hello = scope.CREATE("hello!");
            let world = scope.CREATE("world!", nest: hello);
            scope.DUPE(world);

            mut result  = "";
            scope.overloads.each: |o, i| {
                result ~= "+" ~ o.name;
                if (scope.extended.len > i)
                    scope.extended[i].locals.each: |x|
                        result ~= "-" ~ x.name;
            }

            return scope.total == 3 && result == "+hello!-world!+world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Scope_X2In;
struct Overload_BK87;
struct Extended_68Ao;
struct Target_C55w;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_68Aop92bMcb
                                #define DEF_Extended_68Aop92bMcb
struct Extended_68Ao
{
                                // shape_hash:    6318a81d2af26828
                                // non_triv_mask: 0000808020000400
    fu::vec<Overload_BK87> locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_X2InRJmSRm9
                                #define DEF_Scope_X2InRJmSRm9
struct Scope_X2In
{
                                // shape_hash:    fdaa7dd60c5ff1d6
                                // non_triv_mask: 0000808820000500
    fu::vec<Overload_BK87> overloads;
    fu::vec<Extended_68Ao> extended;
    int total;
    Scope_X2In(const Scope_X2In&) = delete;
    Scope_X2In(Scope_X2In&&) = default;
    Scope_X2In& operator=(const Scope_X2In&) = delete;
    Scope_X2In& operator=(Scope_X2In&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || total
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_C55w2WGPODc
                                #define DEF_Target_C55w2WGPODc
struct Target_C55w
{
                                // shape_hash:    0515a606fde80439
                                // non_triv_mask: 0000000000000000
    int globid;
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
            || locid
        ;
    }
};
                                #endif

                                #ifndef STR_t7X6pg06Cy4
                                #define STR_t7X6pg06Cy4
static const fu::str str_t7X6pg06Cy4 fu_INIT_PRIORITY(1001) { "hello!"_fu };
                                #endif

                                #ifndef STR_FjAIxWhdR2c
                                #define STR_FjAIxWhdR2c
static const fu::str str_FjAIxWhdR2c fu_INIT_PRIORITY(1001) { "world!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_S7jDh4wAeHf
                                #define DEF_grow_if_oob_S7jDh4wAeHf
inline static Extended_68Ao& grow_if_oob_S7jD(/*3:3*/ fu::vec_range_mut<Extended_68Ao> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Target_C55w CREATE_MbR9(/*1:1*/ Scope_X2In& scope, /*7:7*/ fu::vec_range<char> name, /*7:7*/ const Target_C55w& nest)
{
    fu::vec<Overload_BK87>& /*scope|static*/ overloads = (nest ? grow_if_oob_S7jD(scope.extended, (nest.globid - 1)).locals : scope.overloads);
    scope.total++;
    overloads += Overload_BK87 { fu::str(name) };
    const int index = overloads.size();
    return Target_C55w { (nest ? nest.globid : index), (nest ? index : 0) };
}

static const Overload_BK87& GET_kGbb(/*3:3*/ const Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    if (target.locid)
        return scope.extended[(target.globid - 1)].locals[(target.locid - 1)];
    else
        return scope.overloads[(target.globid - 1)];

}

static Target_C55w DUPE_MbR9(/*3:3*/ Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    return CREATE_MbR9(scope, fu::str(/*bck:vi 0*/ GET_kGbb(scope, target).name), Target_C55w{});
}

                                #ifndef DEF___IX1NjxuBeA9
                                #define DEF___IX1NjxuBeA9
inline static fu::view<char> _IX1N(/*3:3*/ const Overload_BK87& x, /*2:2*/ fu::vec_range_mut<char> result)
{
    return (result += ("-"_view + x.name));
}
                                #endif

                                #ifndef DEF_each_JlYoyCmvWfh
                                #define DEF_each_JlYoyCmvWfh
inline void each_JlYo(/*7:7*/ fu::view<Overload_BK87> a, /*6:6*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < a.size(); i++)
        _IX1N(a[i], result);

}
                                #endif

                                #ifndef DEF___EBoIPBvJsAc
                                #define DEF___EBoIPBvJsAc
inline static void _EBoI(/*F:F*/ const Overload_BK87& o, const int i, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::vec_range_mut<char> result)
{
    result += ("+"_view + o.name);
    if (scope.extended.size() > i)
        each_JlYo(scope.extended[i].locals, result);

}
                                #endif

                                #ifndef DEF_each_CIaVIBrFhZ9
                                #define DEF_each_CIaVIBrFhZ9
inline void each_CIaV(/*F:F*/ fu::view<Overload_BK87> a, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::vec_range_mut<char> result)
{
    for (int i = 0; i < a.size(); i++)
        _EBoI(a[i], i, scope, result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Scope_X2In scope {};
    const Target_C55w hello = CREATE_MbR9(scope, str_t7X6pg06Cy4, Target_C55w{});
    const Target_C55w world = CREATE_MbR9(scope, str_FjAIxWhdR2c, hello);
    DUPE_MbR9(scope, world);
    fu::str result = fu::str(""_fu);
    each_CIaV(scope.overloads, scope, result);
    if ((scope.total == 3) && (result == "+hello!-world!+world!"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq, N_COWRestrict

========

        struct Target       { globid: i32; locid: i32 }
        struct Overload     { name: string }
        struct Extended     { locals: Overload[] }

        nocopy struct Scope {
            overloads: Overload[]; extended: Extended[]; total: i32
        }

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {
            ref overloads = nest
                ? scope.extended.grow_if_oob(nest.globid - 1).locals
                : scope.overloads;


            scope.total++;

            overloads ~= Overload(:name);
            let index = overloads.len;


            return Target(
                globid: nest ? nest.globid : index,
                 locid: nest ? index       : 0);
        }

        fn GET(ref scope: Scope, target: Target)
            target.locid
                ? scope.extended[target.globid - 1].locals[target.locid - 1]
                : scope.overloads[target.globid - 1];

        fn DUPE(ref scope: Scope, target: Target)
            CREATE(scope, GET(scope, target).name);

        fn main() {
            mut scope: Scope;
            let hello = scope.CREATE("hello!");
            let world = scope.CREATE("world!", nest: hello);
            scope.DUPE(world);

            mut result  = "";
            scope.overloads.each: |o, i| {
                result ~= "+" ~ o.name;
                if (scope.extended.len > i)
                    scope.extended[i].locals.each: |x|
                        result ~= "-" ~ x.name;
            }

            return scope.total == 3 && result == "+hello!-world!+world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Scope_X2In;
struct Overload_BK87;
struct Extended_68Ao;
struct Target_C55w;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_68Aop92bMcb
                                #define DEF_Extended_68Aop92bMcb
struct Extended_68Ao
{
                                // shape_hash:    6318a81d2af26828
                                // non_triv_mask: 0000808020000400
    fu::vec<Overload_BK87> locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_X2InRJmSRm9
                                #define DEF_Scope_X2InRJmSRm9
struct Scope_X2In
{
                                // shape_hash:    fdaa7dd60c5ff1d6
                                // non_triv_mask: 0000808820000500
    fu::vec<Overload_BK87> overloads;
    fu::vec<Extended_68Ao> extended;
    int total;
    Scope_X2In(const Scope_X2In&) = delete;
    Scope_X2In(Scope_X2In&&) = default;
    Scope_X2In& operator=(const Scope_X2In&) = delete;
    Scope_X2In& operator=(Scope_X2In&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || total
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_C55w2WGPODc
                                #define DEF_Target_C55w2WGPODc
struct Target_C55w
{
                                // shape_hash:    0515a606fde80439
                                // non_triv_mask: 0000000000000000
    int globid;
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
            || locid
        ;
    }
};
                                #endif

                                #ifndef STR_t7X6pg06Cy4
                                #define STR_t7X6pg06Cy4
static const fu::str str_t7X6pg06Cy4 fu_INIT_PRIORITY(1001) { "hello!"_fu };
                                #endif

                                #ifndef STR_FjAIxWhdR2c
                                #define STR_FjAIxWhdR2c
static const fu::str str_FjAIxWhdR2c fu_INIT_PRIORITY(1001) { "world!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_S7jDh4wAeHf
                                #define DEF_grow_if_oob_S7jDh4wAeHf
inline static Extended_68Ao& grow_if_oob_S7jD(/*3:3*/ fu::vec_range_mut<Extended_68Ao> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Target_C55w CREATE_MbR9(/*1:1*/ Scope_X2In& scope, /*7:7*/ fu::vec_range<char> name, /*7:7*/ const Target_C55w& nest)
{
    fu::vec<Overload_BK87>& /*scope|static*/ overloads = (nest ? grow_if_oob_S7jD(scope.extended, (nest.globid - 1)).locals : scope.overloads);
    scope.total++;
    overloads += Overload_BK87 { fu::str(name) };
    const int index = overloads.size();
    return Target_C55w { (nest ? nest.globid : index), (nest ? index : 0) };
}

static const Overload_BK87& GET_kGbb(/*3:3*/ const Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    if (target.locid)
        return scope.extended[(target.globid - 1)].locals[(target.locid - 1)];
    else
        return scope.overloads[(target.globid - 1)];

}

static Target_C55w DUPE_MbR9(/*3:3*/ Scope_X2In& scope, /*3:3*/ const Target_C55w& target)
{
    return CREATE_MbR9(scope, fu::str(/*bck:vi 0*/ GET_kGbb(scope, target).name), Target_C55w{});
}

                                #ifndef DEF___IX1NjxuBeA9
                                #define DEF___IX1NjxuBeA9
inline static fu::view<char> _IX1N(/*3:3*/ const Overload_BK87& x, /*2:2*/ fu::str& result)
{
    return (result += ("-"_view + x.name));
}
                                #endif

                                #ifndef DEF_each_JlYoyCmvWfh
                                #define DEF_each_JlYoyCmvWfh
inline void each_JlYo(/*7:7*/ fu::view<Overload_BK87> a, /*6:6*/ fu::str& result)
{
    for (int i = 0; i < a.size(); i++)
        _IX1N(a[i], result);

}
                                #endif

                                #ifndef DEF___EBoIPBvJsAc
                                #define DEF___EBoIPBvJsAc
inline static void _EBoI(/*F:F*/ const Overload_BK87& o, const int i, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::str& result)
{
    result += ("+"_view + o.name);
    if (scope.extended.size() > i)
        each_JlYo(scope.extended[i].locals, result);

}
                                #endif

                                #ifndef DEF_each_CIaVIBrFhZ9
                                #define DEF_each_CIaVIBrFhZ9
inline void each_CIaV(/*F:F*/ fu::view<Overload_BK87> a, /*F:F*/ const Scope_X2In& scope, /*A:A*/ fu::str& result)
{
    for (int i = 0; i < a.size(); i++)
        _EBoI(a[i], i, scope, result);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Scope_X2In scope {};
    const Target_C55w hello = CREATE_MbR9(scope, str_t7X6pg06Cy4, Target_C55w{});
    const Target_C55w world = CREATE_MbR9(scope, str_FjAIxWhdR2c, hello);
    DUPE_MbR9(scope, world);
    fu::str result {};
    each_CIaV(scope.overloads, scope, result);
    if ((scope.total == 3) && (result == "+hello!-world!+world!"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq, N_COWRestrict

========

        fn First(s: $T[..]) s.len && s[0];
        struct Node { items: Node[] }

        fn tryFirst(node: Node)
            node.items
                ? tryFirst(node.items.First)
                : node;

        fn main()
            tryFirst(
                Node([ Node([ Node, Node ])]))
                    .items.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct Node_zYlo;
static const Node_zYlo& tryFirst_kGbb(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_First_vurR3Wn7gM5
                                #define DEF_First_vurR3Wn7gM5
inline static const Node_zYlo& First_vurR(/*1:1*/ fu::view<Node_zYlo> s)
{
    if (s.size())
        return s[0];
    else
        return (*(Node_zYlo*)fu::NIL);

}
                                #endif

static const Node_zYlo& tryFirst_kGbb(/*1:1*/ const Node_zYlo& node)
{
    if (node.items)
        return tryFirst_kGbb(First_vurR(node.items));
    else
        return node;

}

int fu_MAIN()
{
    return tryFirst_kGbb(Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} } }} }).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        fn First(s: $T[..]) s.len && s[0];
        struct Node { value: i32; items: Node[] }

        fn tryFirst(node: Node)
            node.items
                ? tryFirst(node.items.First)
                : node;

        fn main()
            tryFirst(
                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))
                    .value - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct Node_ClDc;
static const Node_ClDc& tryFirst_MbR9(const Node_ClDc&);

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040000000100000
    int value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_First_SPZ2Pm0QYx7
                                #define DEF_First_SPZ2Pm0QYx7
inline static const Node_ClDc& First_SPZ2(/*1:1*/ fu::view<Node_ClDc> s)
{
    if (s.size())
        return s[0];
    else
        return (*(Node_ClDc*)fu::NIL);

}
                                #endif

static const Node_ClDc& tryFirst_MbR9(/*1:1*/ const Node_ClDc& node)
{
    if (node.items)
        return tryFirst_MbR9(First_SPZ2(node.items));
    else
        return node;

}

int fu_MAIN()
{
    return tryFirst_MbR9(Node_ClDc { 1, fu::vec<Node_ClDc> {{ Node_ClDc { 2, fu::vec<Node_ClDc> {{ Node_ClDc { 3, fu::vec<Node_ClDc>{} }, Node_ClDc { 4, fu::vec<Node_ClDc>{} } }} } }} }).value - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

========

        fn First(s: $T[..]) s.len && s[0];
        fn Last (s: $T[..]) s.len && s[s.len - 1];
        struct Node { value: i32; items: Node[] }

        fn tryFirst(node: Node)
            node.items  ? tryLast(node.items.First)
                        : node;

        fn tryLast(node: Node)
            node.items  ? tryFirst(node.items.Last)
                        : node;

        fn main()
            tryFirst(
                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))
                    .value - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct Node_ClDc;
static const Node_ClDc& tryFirst_MbR9(const Node_ClDc&);

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040000000100000
    int value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_First_SPZ2Pm0QYx7
                                #define DEF_First_SPZ2Pm0QYx7
inline static const Node_ClDc& First_SPZ2(/*1:1*/ fu::view<Node_ClDc> s)
{
    if (s.size())
        return s[0];
    else
        return (*(Node_ClDc*)fu::NIL);

}
                                #endif

                                #ifndef DEF_Last_vMauwyjpPq0
                                #define DEF_Last_vMauwyjpPq0
inline static const Node_ClDc& Last_vMau(/*1:1*/ fu::view<Node_ClDc> s)
{
    if (s.size())
        return s[(s.size() - 1)];
    else
        return (*(Node_ClDc*)fu::NIL);

}
                                #endif

static const Node_ClDc& tryLast_MbR9(/*1:1*/ const Node_ClDc& node)
{
    if (node.items)
        return tryFirst_MbR9(Last_vMau(node.items));
    else
        return node;

}

static const Node_ClDc& tryFirst_MbR9(/*1:1*/ const Node_ClDc& node)
{
    if (node.items)
        return tryLast_MbR9(First_SPZ2(node.items));
    else
        return node;

}

int fu_MAIN()
{
    return tryFirst_MbR9(Node_ClDc { 1, fu::vec<Node_ClDc> {{ Node_ClDc { 2, fu::vec<Node_ClDc> {{ Node_ClDc { 3, fu::vec<Node_ClDc>{} }, Node_ClDc { 4, fu::vec<Node_ClDc>{} } }} } }} }).value - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve

========

        struct Thing { a: i32; b: i32 };
        struct Stuff { _gets: Thing[]; _root: Thing; _exts: Thing[] };

        fn GET(ref s: Stuff, i: int) s._gets[i];
        fn EXT(ref s: Stuff, i: int) s._exts[i];

        fn lookup(ref s: Stuff, i: int) {
            let start = s._root || s.GET(i);
            if (!start) return start;
            return s.EXT(i);
        }

        fn main() {
            mut s = Stuff([ Thing(0, 1) ], Thing(1, 2), [ Thing(2, 3) ]);
            return s.lookup(0).a - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Stuff_DwX1;
struct Thing_zmwJ;

                                #ifndef DEF_Thing_zmwJIQ1ZuR3
                                #define DEF_Thing_zmwJIQ1ZuR3
struct Thing_zmwJ
{
                                // shape_hash:    f899782f9fa5efc2
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Stuff_DwX1uj8Xazl
                                #define DEF_Stuff_DwX1uj8Xazl
struct Stuff_DwX1
{
                                // shape_hash:    bc8b30338dc553bf
                                // non_triv_mask: 0080000000000001
    fu::vec<Thing_zmwJ> _gets;
    Thing_zmwJ _root;
    fu::vec<Thing_zmwJ> _exts;
    explicit operator bool() const noexcept
    {
        return false
            || _gets
            || _root
            || _exts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Thing_zmwJ& GET_kGbb(/*3:3*/ const Stuff_DwX1& s, const int i)
{
    return s._gets[i];
}

static const Thing_zmwJ& EXT_kGbb(/*3:3*/ const Stuff_DwX1& s, const int i)
{
    return s._exts[i];
}

static const Thing_zmwJ& lookup_MbR9(/*3:3*/ const Stuff_DwX1& s, const int i)
{
    const Thing_zmwJ& /*s|static*/ start = (s._root ? s._root : GET_kGbb(s, i));
    if (!start)
        return start;
    else
        return EXT_kGbb(s, i);

}

int fu_MAIN()
{
    Stuff_DwX1 s = Stuff_DwX1 { fu::vec<Thing_zmwJ> {{ Thing_zmwJ { 0, 1 } }}, Thing_zmwJ { 1, 2 }, fu::vec<Thing_zmwJ> {{ Thing_zmwJ { 2, 3 } }} };
    return lookup_MbR9(s, 0).a - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Zero(implicit ref result: i32, src: i32[..]) =
            src.each: |x, i| result += x * (i + 1);
        fn Todo(implicit ref result: i32, src: i32[..]) =
            src.each: |x, i| result += x * (i + 1) * 7;

        fn Zero(src: i32) = Zero([ src ]);
        fn Todo(src: i32) = Todo([ src ]);

        import _0;
        fn main() {
            implicit mut result = 0;

            let Solo = fn Zero;
            lax fn Solo_muteRest(_) {}
            shadow let Zero = fn Solo_muteRest;
            shadow let Todo = fn Solo_muteRest;



            let Todo_A = fn Todo;
            let Todo_B = fn Todo;

            Zero([ 10 ]);   Zero(11);
            Todo([ 12 ]);   Todo(13);
            Todo_A([ 14 ]); Todo_A(15);
            Todo_B([ 16 ]); Todo_B(17);
            Solo([ 18 ]);   Solo(19);

            return result - 37;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>

void Zero_MbR9(fu::view<int>, int&);
void Zero_kGbb(int, int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int result = 0;
    Zero_MbR9(fu::view<int> {{ 18 }}, result);
    Zero_kGbb(19, result);
    return result - 37;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedArrlit
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___9wqbwdVVu58
                                #define DEF___9wqbwdVVu58
inline static int _9wqb(const int x, const int i, /*7:7*/ int& result)
{
    return (result += (x * (i + 1)));
}
                                #endif

                                #ifndef DEF_each_UORktqCQoZj
                                #define DEF_each_UORktqCQoZj
inline void each_UORk(/*7:7*/ fu::view<int> a, /*7:6*/ int& result)
{
    for (int i = 0; i < a.size(); i++)
        _9wqb(a[i], i, result);

}
                                #endif

void Zero_MbR9(/*3:3*/ fu::view<int> src, /*2:2*/ int& result)
{
    each_UORk(src, result);
}

                                #ifndef DEF___o5gUvtQLKC0
                                #define DEF___o5gUvtQLKC0
inline static int _o5gU(const int x, const int i, /*7:7*/ int& result)
{
    return (result += ((x * (i + 1)) * 7));
}
                                #endif

                                #ifndef DEF_each_a7qocfTuyX7
                                #define DEF_each_a7qocfTuyX7
inline void each_a7qo(/*7:7*/ fu::view<int> a, /*7:6*/ int& result)
{
    for (int i = 0; i < a.size(); i++)
        _o5gU(a[i], i, result);

}
                                #endif

void Todo_MbR9(/*3:3*/ fu::view<int> src, /*2:2*/ int& result)
{
    each_a7qo(src, result);
}

void Zero_kGbb(const int src, /*3:3*/ int& result)
{
    Zero_MbR9(fu::view<int> {{ src }}, result);
}

void Todo_kGbb(const int src, /*3:3*/ int& result)
{
    Todo_MbR9(fu::view<int> {{ src }}, result);
}

#endif

// N_RelaxRespec

========

        fn Zero(implicit ref result: i32, src: i32[..]) =
            src.each: |x, i| result += x * (i + 1);
        fn Todo(implicit ref result: i32, src: i32[..]) =
            src.each: |x, i| result += x * (i + 1) * 7;

        fn Zero(src: i32) = Zero([ src ]);
        fn Todo(src: i32) = Todo([ src ]);

        import _0;
        fn main() {
            implicit mut result = 0;

            let Solo = fn Zero;
            lax fn Solo_muteRest(_) {}
            shadow let Zero = fn Solo_muteRest;
            shadow let Todo = fn Solo_muteRest;


            mut queue: string;
            fn Parzero(x: i32) queue ~= x;
            shadow let result = || {
                queue.each(.Zero);
                result
            };
            shadow let Zero = fn Parzero;


            let Todo_A = fn Todo;
            let Todo_B = fn Todo;

            Zero([ 10 ]);   Zero(11);
            Todo([ 12 ]);   Todo(13);
            Todo_A([ 14 ]); Todo_A(15);
            Todo_B([ 16 ]); Todo_B(17);
            Solo([ 18 ]);   Solo(19);

            return result - 37;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

void Zero_MbR9(fu::view<int>, int&);
void Zero_kGbb(int, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::view<char> Parzero_oPCT(const int x, /*3:3*/ fu::str& queue)
{
    return x7Ex3D_w1za(queue, fu::i64dec(x));
}

                                #ifndef DEF___ZS4QudXnPnf
                                #define DEF___ZS4QudXnPnf
inline static int _ZS4Q(/*1:1*/ const int result)
{
    return result;
}
                                #endif

int fu_MAIN()
{
    int result = 0;
    fu::str queue {};
    Parzero_oPCT(11, queue);
    Zero_MbR9(fu::view<int> {{ 18 }}, result);
    Zero_kGbb(19, result);
    return _ZS4Q(result) - 37;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_UnusedArrlit
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___9wqbwdVVu58
                                #define DEF___9wqbwdVVu58
inline static int _9wqb(const int x, const int i, /*7:7*/ int& result)
{
    return (result += (x * (i + 1)));
}
                                #endif

                                #ifndef DEF_each_UORktqCQoZj
                                #define DEF_each_UORktqCQoZj
inline void each_UORk(/*7:7*/ fu::view<int> a, /*7:6*/ int& result)
{
    for (int i = 0; i < a.size(); i++)
        _9wqb(a[i], i, result);

}
                                #endif

void Zero_MbR9(/*3:3*/ fu::view<int> src, /*2:2*/ int& result)
{
    each_UORk(src, result);
}

                                #ifndef DEF___o5gUvtQLKC0
                                #define DEF___o5gUvtQLKC0
inline static int _o5gU(const int x, const int i, /*7:7*/ int& result)
{
    return (result += ((x * (i + 1)) * 7));
}
                                #endif

                                #ifndef DEF_each_a7qocfTuyX7
                                #define DEF_each_a7qocfTuyX7
inline void each_a7qo(/*7:7*/ fu::view<int> a, /*7:6*/ int& result)
{
    for (int i = 0; i < a.size(); i++)
        _o5gU(a[i], i, result);

}
                                #endif

void Todo_MbR9(/*3:3*/ fu::view<int> src, /*2:2*/ int& result)
{
    each_a7qo(src, result);
}

void Zero_kGbb(const int src, /*3:3*/ int& result)
{
    Zero_MbR9(fu::view<int> {{ src }}, result);
}

void Todo_kGbb(const int src, /*3:3*/ int& result)
{
    Todo_MbR9(fu::view<int> {{ src }}, result);
}

#endif

// N_RelaxRespec

========

        struct Node { items: Node[]; }
        struct Type { value: i32 };

        let t_void = Type(0);

        fn main() {
            fn createEmpty(lax type: Type or Node = t_void) = [];

            fn solveTypedef(node): Type {
                lax let annot = node.items
                    && solveTypedef(node.items[0]);

                if (annot) {
                    mut relaxed = annot;
                    return createEmpty(type: relaxed);
                }

                return createEmpty();
            }

            return solveTypedef(Node()).value;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_7FcK;

                                #ifndef DEF_Type_7FcKtCDE7sk
                                #define DEF_Type_7FcKtCDE7sk
struct Type_7FcK
{
                                // shape_hash:    588de19fe2c5c3ee
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_solveTypedef_v8LAiJPCzof
                                #define DEF_solveTypedef_v8LAiJPCzof
inline static Type_7FcK solveTypedef_v8LA()
{
    return Type_7FcK{};
}
                                #endif

int fu_MAIN()
{
    return solveTypedef_v8LA().value;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall, N_UnusedIfElse, N_UnusedLet, N_SD_HasStaticInit

========

        using flags DeclAsserts { A; B };
        flags SomethingElse { AA; BB };

        fn GET_NEXT_LOCAL_oob() {
            fn parseNoCopy(x: DeclAsserts or SomethingElse = A) x;
            fn parseBlockLike(y) y | parseNoCopy();
            return parseBlockLike(B);
        }

        fn main() GET_NEXT_LOCAL_oob().i32 - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 DeclAsserts_eF5A;

                                #ifndef DEF_DeclAsserts_eF5A
                                #define DEF_DeclAsserts_eF5A
inline constexpr DeclAsserts_eF5A DeclAsserts_eF5A_A = DeclAsserts_eF5A(1u);
inline constexpr DeclAsserts_eF5A DeclAsserts_eF5A_B = DeclAsserts_eF5A(2u);

inline constexpr DeclAsserts_eF5A MASK_DeclAsserts_eF5A
    = DeclAsserts_eF5A_A
    | DeclAsserts_eF5A_B;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_parseNoCopy_4FQOFpJYLMk
                                #define DEF_parseNoCopy_4FQOFpJYLMk
inline static DeclAsserts_eF5A parseNoCopy_4FQO(/*1:1*/ const DeclAsserts_eF5A x)
{
    return x;
}
                                #endif

                                #ifndef DEF_parseBlockLike_kosUBpp9QTf
                                #define DEF_parseBlockLike_kosUBpp9QTf
inline static DeclAsserts_eF5A parseBlockLike_kosU(const DeclAsserts_eF5A y)
{
    return y | parseNoCopy_4FQO(DeclAsserts_eF5A_A);
}
                                #endif

static DeclAsserts_eF5A GET_NEXT_LOCAL_oob_MbR9()
{
    return parseBlockLike_kosU(DeclAsserts_eF5A_B);
}

int fu_MAIN()
{
    return int(GET_NEXT_LOCAL_oob_MbR9()) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() ("hello" == "world").i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    return int(("hello"_view == "world"_view));
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { items?: Node[]; value?: i32 };

        fn tryConvert(ref default: Node) {
            if (default.items) {
                default.items ~= default;
                default.value += 10;
                return true;
            }

            return false;
        }

        fn updateScope(unspecced: Node[], ref defaults: Node[]) {
            for (mut i = 0; i < defaults.len; i++) {
                defaults[i] = {
                    :DEFAULT {
                        if (!unspecced)
                            break :DEFAULT (i < defaults.len - 1)
                                && defaults[i + 1];

                        mut default = unspecced.len > i && unspecced[i];
                        if (default && tryConvert(default))
                            break :DEFAULT default;

                        break :DEFAULT [];
                    }
                };
            }
        }

        fn main() {
            mut nodes = [ Node(items: [ Node() ]) ];
            for (mut i = 0; i < 4; i++) {
                mut node = nodes[nodes.len - 1];
                tryConvert(node);
                nodes ~= node;
            }

            updateScope(nodes, nodes);

            mut checksum = 0;
            fn checksum(shadow nodes: Node[]) {
                checksum += nodes.len;
                for (mut i = 0; i < nodes.len; i++) {
                    let node = nodes[i];
                    checksum(node.items);
                    checksum += 1000 * node.value;
                }
            }

            checksum(nodes);
            return checksum == 570124 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2096) arc_count(13) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct Node_wziT;
static void checksum_MbR9(fu::view<Node_wziT>, int&);

                                #ifndef DEF_Node_wziT9xRZgu0
                                #define DEF_Node_wziT9xRZgu0
struct Node_wziT
{
                                // shape_hash:    a55e09ec9acffa50
                                // non_triv_mask: 0000104000000000
    fu::vec<Node_wziT> items;
    int value;
    Node_wziT(const Node_wziT&) = default;
    Node_wziT(Node_wziT&&) = default;
    Node_wziT& operator=(Node_wziT&&) = default;
    Node_wziT& operator=(const Node_wziT& selfrec) { return *this = Node_wziT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool tryConvert_MbR9(/*1:1*/ Node_wziT& dEfault)
{
    if (dEfault.items)
    {
        dEfault.items += Node_wziT(dEfault);
        dEfault.value += 10;
        return true;
    }
    else
        return false;

}

static void updateScope_MbR9(/*3:3*/ fu::view<Node_wziT> unspecced, /*2:2*/ fu::view_mut<Node_wziT> defaults)
{
    for (int i = 0; i < defaults.size(); i++)
    {
        Node_wziT dEfault {};
        defaults.mutref(i) = Node_wziT((!unspecced ? ((i < (defaults.size() - 1)) ? defaults[(i + 1)] : (*(Node_wziT*)fu::NIL)) : (dEfault = ((unspecced.size() > i) ? unspecced[i] : (*(Node_wziT*)fu::NIL)), ((dEfault && tryConvert_MbR9(dEfault)) ? dEfault : (*(Node_wziT*)fu::NIL)))));
    };
}

static void checksum_MbR9(/*3:3*/ fu::view<Node_wziT> nodes, /*2:2*/ int& checksum)
{
    checksum += nodes.size();
    for (int i = 0; i < nodes.size(); i++)
    {
        const Node_wziT& /*nodes|static*/ node = nodes[i];
        checksum_MbR9(node.items, checksum);
        checksum += (1000 * node.value);
    };
}

int fu_MAIN()
{
    fu::vec<Node_wziT> nodes = fu::vec<Node_wziT> {{ Node_wziT { fu::vec<Node_wziT> {{ Node_wziT{} }}, 0 } }};
    for (int i = 0; i < 4; i++)
    {
        /*MOV*/ Node_wziT node = nodes[(nodes.size() - 1)];
        tryConvert_MbR9(node);
        nodes += static_cast<Node_wziT&&>(node);
    };
    updateScope_MbR9(fu::vec<Node_wziT>(/*bck:vi 1*/ nodes), nodes);
    int checksum = 0;
    checksum_MbR9(nodes, checksum);
    if (checksum == 570124)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedLet

========

        let a = 7;
        let b = a && 3;
        return b - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 7;
    const int b = (a ? 3 : 0);
    return b - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        let a = 7;
        let b = a && 3;
        return b - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int b = 3;
    return b - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw("woot");

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>

struct S_O24k;

                                #ifndef DEF_S_O24kLTnb0H4
                                #define DEF_S_O24kLTnb0H4
struct S_O24k
{
                                // shape_hash:    e62477e56d15ba63
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const S_O24k a = S_O24k { 0 };
    const S_O24k b = S_O24k { 3 };
    return a.i ? a.i : ((((b ? S_O24k(b) : S_O24k { 4 }).i * 2) - (a ? S_O24k(a) : S_O24k { 6 }).i) ? fu::fail(fu::str("woot"_fu)) : 0);
}

#endif

int main() { return fu_MAIN(); }

========

        struct KindValue { kind: string; value: string; };

        mut spec = KindValue(kind: "fn", value: "val");
        spec.kind == "fn" && spec.value || throw("nope");
        ref v = spec.kind == "fn" ? spec.value : throw("nope");

        v ~= "ue";
        return spec.value == "value" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct KindValue_dbix;

                                #ifndef DEF_KindValue_dbixsmOLHt4
                                #define DEF_KindValue_dbixsmOLHt4
struct KindValue_dbix
{
                                // shape_hash:    7ff4b61a1b2db243
                                // non_triv_mask: 0000800000000800
    fu::str kind;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    KindValue_dbix spec = KindValue_dbix { fu::str("fn"_fu), fu::str("val"_fu) };
    if ((spec.kind == "fn"_view) && spec.value)
    {
        fu::str& /*spec*/ v = ((spec.kind == "fn"_view) ? spec.value : fu::fail(fu::str("nope"_fu)));
        v += "ue"_view;
        if (spec.value == "value"_view)
            return 0;
        else
            return 1;

    }
    else
        fu::fail(fu::str("nope"_fu));

}

#endif

int main() { return fu_MAIN(); }

========

        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>

struct Token_pmhe;

                                #ifndef DEF_Token_pmheiqtyBOi
                                #define DEF_Token_pmheiqtyBOi
struct Token_pmhe
{
                                // shape_hash:    163587bf5270a2bd
                                // non_triv_mask: 0000800020000000
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Token_pmhe consume_MbR9()
{
    return Token_pmhe { fu::str("hey"_fu) };
}

int fu_MAIN()
{
    const int a = 3;
    fu::str v = (a ? consume_MbR9().value : fu::str{});
    return v.size() - a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>

struct Token_pmhe;

                                #ifndef DEF_Token_pmheiqtyBOi
                                #define DEF_Token_pmheiqtyBOi
struct Token_pmhe
{
                                // shape_hash:    163587bf5270a2bd
                                // non_triv_mask: 0000800020000000
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Token_pmhe consume_MbR9()
{
    return Token_pmhe { fu::str("hey"_fu) };
}

int fu_MAIN()
{
    const int a = 3;
    fu::str v = consume_MbR9().value;
    return v.size() - a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct ScopeIdx { raw: i32; };

        fn thing(x: i32) x;             
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);

---- <fail> ----
[2m[0m_0[2m.fu 12:27+1[0m:

[2m      |         fn hey(x: i32) {[0m
[2m      |             let scope0 = thing(x);[0m
[2m   12 | [0m            _return_scope [31;1m=[0m scope0; //overload
[2m      |             return _return_scope.raw;[0m
[2m      |         }[0m

	Bad call to [94;1m=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mScopeIdx[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m=[0m at [2m../../../../../[0mprelude[2m 212:12+1[0m:
[2m  212 | [0minfix fn   [31;1m=[0m (mut ref a: <T>,    mut b: T): &mut T = __native;

	    [35;3marg[0m [94;1m=[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstruct[0m [94;1mScopeIdx[0m <-> [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mhey[0m([35;3mi32[0m) at [2m10:12+3[0m
                [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct ScopeIdx { raw: i32; };

        fn thing(x: i32) ScopeIdx(x);   
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct ScopeIdx_KQ0S;

                                #ifndef DEF_ScopeIdx_KQ0SiPGIhA5
                                #define DEF_ScopeIdx_KQ0SiPGIhA5
struct ScopeIdx_KQ0S
{
                                // shape_hash:    65504fdc25f0e014
                                // non_triv_mask: 0000000000000000
    int raw;
    explicit operator bool() const noexcept
    {
        return false
            || raw
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static ScopeIdx_KQ0S thing_MbR9(const int x)
{
    return ScopeIdx_KQ0S { x };
}

static int hey_kGbb(const int x, /*3:3*/ ScopeIdx_KQ0S& _return_scope)
{
    const ScopeIdx_KQ0S scope0 = thing_MbR9(x);
    _return_scope = scope0;
    return _return_scope.raw;
}

int fu_MAIN()
{
    ScopeIdx_KQ0S _return_scope {};
    return hey_kGbb(0, _return_scope);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= [ "world!" ]; // same as below but wrapped
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::str> maybe_empty_MbR9(const int N)
{
    /*MOV*/ fu::vec<fu::str> res {};
    for (int i = 0; i < N; i++)
    {
        res += fu::view<fu::str> {{ fu::str("world!"_fu) }};
    };
    return /*NRVO*/ res;
}

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> arr = fu::vec<fu::str> {{ fu::str("Hello"_fu) }};
    for (int i = 0; i < 2; i++)
        arr += maybe_empty_MbR9(i);

    if (join_yqDb(arr, " "_view) == "Hello world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= "world!"; // cpp template issue here
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::str> maybe_empty_MbR9(const int N)
{
    /*MOV*/ fu::vec<fu::str> res {};
    for (int i = 0; i < N; i++)
        res += fu::str("world!"_fu);

    return /*NRVO*/ res;
}

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> arr = fu::vec<fu::str> {{ fu::str("Hello"_fu) }};
    for (int i = 0; i < 2; i++)
        arr += maybe_empty_MbR9(i);

    if (join_yqDb(arr, " "_view) == "Hello world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut _info = "abc";

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && info.i32;
                return reason;
            }

            return fail.len - 2; // 'a' is 97, "97".len is 2.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<char> _info)
{
    const char /*_info|static*/ info = _info[0];
    x7Ex3D_w1za(reason, fu::i64dec((info ? int(fu::u8(info)) : 0)));
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::view<char> /*static*/ _info = "abc"_view;
    return fail_MbR9(fu::str(""_fu), _info).size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut _info = "abc";

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && info.i32;
                return reason;
            }

            return fail.len - 2; // 'a' is 97, "97".len is 2.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_MbR9(/*MOV*/ fu::str&& reason, /*3:3*/ fu::view<char> _info)
{
    const char /*_info|static*/ info = _info[0];
    x7Ex3D_w1za(reason, fu::i64dec((info ? int(fu::u8(info)) : 0)));
    return reason.destructive_move();
}

int fu_MAIN()
{
    fu::view<char> /*static*/ _info = "abc"_view;
    return fail_MbR9(fu::str{}, _info).size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        let q_mutref = 1;
        pub let RELAX_mutref_only = q_mutref;
        pub fn what(relax_mask: i32) relax_mask -1;

        import _0;
        fn main() what(RELAX_mutref_only);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_q_mutref
                                #define DEF_q_mutref
inline constexpr int q_mutref = 1;
                                #endif

                                #ifndef DEF_RELAX_mutref_only
                                #define DEF_RELAX_mutref_only
inline constexpr int /*static*/ RELAX_mutref_only = q_mutref;
                                #endif
int what_MbR9(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return what_MbR9(RELAX_mutref_only);
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_q_mutref
                                #define DEF_q_mutref
inline constexpr int q_mutref = 1;
                                #endif

                                #ifndef DEF_RELAX_mutref_only
                                #define DEF_RELAX_mutref_only
inline constexpr int /*static*/ RELAX_mutref_only = q_mutref;
                                #endif

#ifndef fu_NO_fdefs

int what_MbR9(const int relax_mask)
{
    return relax_mask - 1;
}

#endif

// N_SD_HasStaticInit

========

        fn main() {
            try         { return 0; }
            catch (e)   { return e == "x=2: even!" ? 11 : 22; }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedTry

========

        fn fail(str: string)
            throw(str ~ "!");

        fn test(x: i32)
        {
            // We want to override fail but
            //  we want to call it within the override,
            //   so we can do this i guess?
            //
            shadow let fail = |mut str: string| {
                str = "x=" ~ x ~ ": " ~ str;
                fail(str);
            };

            return x & 1 || fail("even");
        }

        fn main() {
            try {
                return test(2);
            }
            catch (e) {

                shadow let e = "hello " ~ e;
                return e == "hello x=2: even!" ? 0 : 10;

            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_MbR9(/*1:1*/ fu::view<char> str)
{
    fu::fail((str + "!"_view));
}

                                #ifndef DEF___txeX2Fi9ih3
                                #define DEF___txeX2Fi9ih3
[[noreturn]] inline static fu::never _txeX(fu::str&& str, /*3:3*/ const int x)
{
    str = ((x7E_rA00("x="_view, fu::i64dec(x)) + ": "_view) + str);
    fail_MbR9(str);
}
                                #endif

static int test_MbR9(const int x)
{
    int _0;
    return (_0 = (x & 1)) ? _0 : _txeX(fu::str("even"_fu), x);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        return test_MbR9(2);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        fu::str e_1 = ("hello "_view + e);
        if (e_1 == "hello x=2: even!"_view)
            return 0;
        else
            return 10;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn fail(str: string)
            throw(str ~ "!");

        fn test(x: i32)
        {
            // We want to override fail but
            //  we want to call it within the override,
            //   so we can do this i guess?
            //
            shadow let fail = |mut str: string| {
                str = "x=" ~ x ~ ": " ~ str;
                fail(str);
            };

            return x & 1 || fail("even");
        }

        fn main() {
            try {
                return test(2);
            }
            catch (e) {

                return e == "x=2: even!" ? 0 : 10;

            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_MbR9(/*1:1*/ fu::view<char> str)
{
    fu::fail((str + "!"_view));
}

                                #ifndef DEF___txeX2Fi9ih3
                                #define DEF___txeX2Fi9ih3
[[noreturn]] inline static fu::never _txeX(fu::str&& str, /*3:3*/ const int x)
{
    str = ((x7E_rA00("x="_view, fu::i64dec(x)) + ": "_view) + str);
    fail_MbR9(str);
}
                                #endif

static int test_MbR9(const int x)
{
    int _0;
    return (_0 = (x & 1)) ? _0 : _txeX(fu::str("even"_fu), x);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        return test_MbR9(2);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "x=2: even!"_view)
            return 0;
        else
            return 10;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        // The Cats&Dogs example from
        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch
        //   https://www.youtube.com/watch?v=kc9HwsxE1OY
        //
        fn encounter(a, b) {
            let verb = meets(a, b);
            return a.name ~ " meets " ~ b.name ~ " and " ~ verb ~ "\n";
        }

        struct Dog { name: string };
        struct Cat { name: string };

        fn meets(lax a: Dog, lax b: Dog) "sniffs";
        fn meets(lax a: Dog, lax b: Cat) "chases";
        fn meets(lax a: Cat, lax b: Dog) "hisses";
        fn meets(lax a: Cat, lax b: Cat) "slinks";

        fn main() {
            let fido        = Dog("Fido");
            let rex         = Dog("Rex");
            let whiskers    = Cat("Whiskers");
            let spots       = Cat("Spots");

            mut res = encounter(fido, rex)
                    ~ encounter(fido, whiskers)
                    ~ encounter(whiskers, rex)
                    ~ encounter(whiskers, spots);

            return res == "Fido meets Rex and sniffs\n"
                        ~ "Fido meets Whiskers and chases\n"
                        ~ "Whiskers meets Rex and hisses\n"
                        ~ "Whiskers meets Spots and slinks\n"
                            ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1040) arc_count(7) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Dog_YufH;
struct Cat_wjBp;

                                #ifndef DEF_Dog_YufHKRrGPa5
                                #define DEF_Dog_YufHKRrGPa5
struct Dog_YufH
{
                                // shape_hash:    46de4ee373af54c3
                                // non_triv_mask: 0000800001000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Cat_wjBpQA75qGb
                                #define DEF_Cat_wjBpQA75qGb
struct Cat_wjBp
{
                                // shape_hash:    68a9dec7639d7188
                                // non_triv_mask: 0400800000000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef STR_0Hgb7IdBAgk
                                #define STR_0Hgb7IdBAgk
static const fu::str str_0Hgb7IdBAgk fu_INIT_PRIORITY(1001) { "sniffs"_fu };
                                #endif

                                #ifndef STR_Z1JCsjjerCg
                                #define STR_Z1JCsjjerCg
static const fu::str str_Z1JCsjjerCg fu_INIT_PRIORITY(1001) { "chases"_fu };
                                #endif

                                #ifndef STR_LMoAwzZkhs4
                                #define STR_LMoAwzZkhs4
static const fu::str str_LMoAwzZkhs4 fu_INIT_PRIORITY(1001) { "hisses"_fu };
                                #endif

                                #ifndef STR_kLaWW2S34I1
                                #define STR_kLaWW2S34I1
static const fu::str str_kLaWW2S34I1 fu_INIT_PRIORITY(1001) { "slinks"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> meets_MbR9()
{
    return str_0Hgb7IdBAgk;
}

                                #ifndef DEF_encounter_tiRYaW6Iza0
                                #define DEF_encounter_tiRYaW6Iza0
inline static fu::str encounter_tiRY(/*3:3*/ const Dog_YufH& a, /*3:3*/ const Dog_YufH& b)
{
    fu::view<char> /*static*/ verb = meets_MbR9();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static fu::vec_range<char> meets_kGbb()
{
    return str_Z1JCsjjerCg;
}

                                #ifndef DEF_encounter_1eGBzRcI2ad
                                #define DEF_encounter_1eGBzRcI2ad
inline static fu::str encounter_1eGB(/*3:3*/ const Dog_YufH& a, /*3:3*/ const Cat_wjBp& b)
{
    fu::view<char> /*static*/ verb = meets_kGbb();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static fu::vec_range<char> meets_GL0m()
{
    return str_LMoAwzZkhs4;
}

                                #ifndef DEF_encounter_nsUai68ewje
                                #define DEF_encounter_nsUai68ewje
inline static fu::str encounter_nsUa(/*3:3*/ const Cat_wjBp& a, /*3:3*/ const Dog_YufH& b)
{
    fu::view<char> /*static*/ verb = meets_GL0m();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static fu::vec_range<char> meets_haRm()
{
    return str_kLaWW2S34I1;
}

                                #ifndef DEF_encounter_ZOjz2NoADz1
                                #define DEF_encounter_ZOjz2NoADz1
inline static fu::str encounter_ZOjz(/*3:3*/ const Cat_wjBp& a, /*3:3*/ const Cat_wjBp& b)
{
    fu::view<char> /*static*/ verb = meets_haRm();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Dog_YufH fido = Dog_YufH { fu::str("Fido"_fu) };
    Dog_YufH rex = Dog_YufH { fu::str("Rex"_fu) };
    Cat_wjBp whiskers = Cat_wjBp { fu::str("Whiskers"_fu) };
    Cat_wjBp spots = Cat_wjBp { fu::str("Spots"_fu) };
    fu::str res = (((encounter_tiRY(fido, rex) + encounter_1eGB(fido, whiskers)) + encounter_nsUa(whiskers, rex)) + encounter_ZOjz(whiskers, spots));
    if (res == ((("Fido meets Rex and sniffs\n"_view + "Fido meets Whiskers and chases\n"_view) + "Whiskers meets Rex and hisses\n"_view) + "Whiskers meets Spots and slinks\n"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // The Cats&Dogs example from
        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch
        //   https://www.youtube.com/watch?v=kc9HwsxE1OY
        //
        fn encounter(a, b) {
            let verb = meets(a, b);
            return a.name ~ " meets " ~ b.name ~ " and " ~ verb ~ "\n";
        }

        struct Dog { name: string };
        struct Cat { name: string };

        fn meets(lax a: Dog, lax b: Dog) "sniffs";
        fn meets(lax a: Dog, lax b: Cat) "chases";
        fn meets(lax a: Cat, lax b: Dog) "hisses";
        fn meets(lax a: Cat, lax b: Cat) "slinks";

        fn main() {
            let fido        = Dog("Fido");
            let rex         = Dog("Rex");
            let whiskers    = Cat("Whiskers");
            let spots       = Cat("Spots");

            mut res = encounter(fido, rex)
                    ~ encounter(fido, whiskers)
                    ~ encounter(whiskers, rex)
                    ~ encounter(whiskers, spots);

            return res == "Fido meets Rex and sniffs\n"
                        ~ "Fido meets Whiskers and chases\n"
                        ~ "Whiskers meets Rex and hisses\n"
                        ~ "Whiskers meets Spots and slinks\n"
                            ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1040) arc_count(7) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Dog_YufH;
struct Cat_wjBp;

                                #ifndef DEF_Dog_YufHKRrGPa5
                                #define DEF_Dog_YufHKRrGPa5
struct Dog_YufH
{
                                // shape_hash:    46de4ee373af54c3
                                // non_triv_mask: 0000800001000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Cat_wjBpQA75qGb
                                #define DEF_Cat_wjBpQA75qGb
struct Cat_wjBp
{
                                // shape_hash:    68a9dec7639d7188
                                // non_triv_mask: 0400800000000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef STR_0Hgb7IdBAgk
                                #define STR_0Hgb7IdBAgk
static const fu::str str_0Hgb7IdBAgk fu_INIT_PRIORITY(1001) { "sniffs"_fu };
                                #endif

                                #ifndef STR_Z1JCsjjerCg
                                #define STR_Z1JCsjjerCg
static const fu::str str_Z1JCsjjerCg fu_INIT_PRIORITY(1001) { "chases"_fu };
                                #endif

                                #ifndef STR_LMoAwzZkhs4
                                #define STR_LMoAwzZkhs4
static const fu::str str_LMoAwzZkhs4 fu_INIT_PRIORITY(1001) { "hisses"_fu };
                                #endif

                                #ifndef STR_kLaWW2S34I1
                                #define STR_kLaWW2S34I1
static const fu::str str_kLaWW2S34I1 fu_INIT_PRIORITY(1001) { "slinks"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& meets_MbR9()
{
    return str_0Hgb7IdBAgk;
}

                                #ifndef DEF_encounter_tiRYaW6Iza0
                                #define DEF_encounter_tiRYaW6Iza0
inline static fu::str encounter_tiRY(/*3:3*/ const Dog_YufH& a, /*3:3*/ const Dog_YufH& b)
{
    fu::view<char> /*static*/ verb = meets_MbR9();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static const fu::str& meets_kGbb()
{
    return str_Z1JCsjjerCg;
}

                                #ifndef DEF_encounter_1eGBzRcI2ad
                                #define DEF_encounter_1eGBzRcI2ad
inline static fu::str encounter_1eGB(/*3:3*/ const Dog_YufH& a, /*3:3*/ const Cat_wjBp& b)
{
    fu::view<char> /*static*/ verb = meets_kGbb();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static const fu::str& meets_GL0m()
{
    return str_LMoAwzZkhs4;
}

                                #ifndef DEF_encounter_nsUai68ewje
                                #define DEF_encounter_nsUai68ewje
inline static fu::str encounter_nsUa(/*3:3*/ const Cat_wjBp& a, /*3:3*/ const Dog_YufH& b)
{
    fu::view<char> /*static*/ verb = meets_GL0m();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

static const fu::str& meets_haRm()
{
    return str_kLaWW2S34I1;
}

                                #ifndef DEF_encounter_ZOjz2NoADz1
                                #define DEF_encounter_ZOjz2NoADz1
inline static fu::str encounter_ZOjz(/*3:3*/ const Cat_wjBp& a, /*3:3*/ const Cat_wjBp& b)
{
    fu::view<char> /*static*/ verb = meets_haRm();
    return ((((a.name + " meets "_view) + b.name) + " and "_view) + verb) + "\n"_view;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    Dog_YufH fido = Dog_YufH { fu::str("Fido"_fu) };
    Dog_YufH rex = Dog_YufH { fu::str("Rex"_fu) };
    Cat_wjBp whiskers = Cat_wjBp { fu::str("Whiskers"_fu) };
    Cat_wjBp spots = Cat_wjBp { fu::str("Spots"_fu) };
    fu::str res = (((encounter_tiRY(fido, rex) + encounter_1eGB(fido, whiskers)) + encounter_nsUa(whiskers, rex)) + encounter_ZOjz(whiskers, spots));
    if (res == ((("Fido meets Rex and sniffs\n"_view + "Fido meets Whiskers and chases\n"_view) + "Whiskers meets Rex and hisses\n"_view) + "Whiskers meets Spots and slinks\n"_view))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct S_O24k;

                                #ifndef DEF_S_O24kLTnb0H4
                                #define DEF_S_O24kLTnb0H4
struct S_O24k
{
                                // shape_hash:    e62477e56d15ba63
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(S_O24k&& x)
{
    return (x.i += 1);
}

int fu_MAIN()
{
    return test_MbR9(S_O24k { -1 });
}

#endif

int main() { return fu_MAIN(); }

========
                                  // DuplicateFunctions
        fn ARR_LAST(ref a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_ARR_LAST_TunKe5eLNid
                                #define DEF_ARR_LAST_TunKe5eLNid
inline static int ARR_LAST_TunK(/*1:1*/ fu::view<int> a)
{
    return a[(a.size() - 1)];
}
                                #endif

                                #ifndef DEF_ARR_LAST_w4a7tqPcUpc
                                #define DEF_ARR_LAST_w4a7tqPcUpc
inline static int& ARR_LAST_w4a7(/*1:1*/ fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    fu::vec<int> b = fu::vec<int> {{ 2 }};
    ARR_LAST_w4a7(b) += ARR_LAST_TunK(a);
    return ARR_LAST_TunK(b) - ARR_LAST_TunK(fu::view<int> {{ 3 }});
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct mat4 { i: i32; };
        struct RenderFrame { u_mat4_VP: mat4; };

        inline fn mat4_identity() mat4(1);

        fn test(ref output: RenderFrame) {
            output.u_mat4_VP = mat4_identity;
        }

        fn main() {
            mut ret: RenderFrame;
            test(ret);
            return ret.u_mat4_VP.i - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct RenderFrame_pWVh;
struct mat4_yN3c;

                                #ifndef DEF_mat4_yN3cTSDCcFj
                                #define DEF_mat4_yN3cTSDCcFj
struct mat4_yN3c
{
                                // shape_hash:    c166ae0db23ab05e
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_RenderFrame_pWVhOl7ViCi
                                #define DEF_RenderFrame_pWVhOl7ViCi
struct RenderFrame_pWVh
{
                                // shape_hash:    140631bb4c37ad8d
                                // non_triv_mask: 0000000000000000
    mat4_yN3c u_mat4_VP;
    explicit operator bool() const noexcept
    {
        return false
            || u_mat4_VP
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ RenderFrame_pWVh& output)
{
    output.u_mat4_VP = mat4_yN3c { 1 };
}

int fu_MAIN()
{
    RenderFrame_pWVh ret {};
    test_MbR9(ret);
    return ret.u_mat4_VP.i - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()

            ScopeSkip(min: -1, max: +1)     
                .end - 1;

---- <fail> ----
[2m[0m_0[2m.fu 12:13+9[0m:

[2m      |         pub fn main()[0m
[2m      | [0m
[2m   12 | [0m            [31;1mScopeSkip[0m(min: -1, max: +1)     
[2m      |                 .end - 1;[0m
[2m      | [0m

	Bad call to [94;1mScopeSkip[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtype[0m [94;1mScopeSkip[0m at [2m2:13+6[0m:
[2m    2 | [0m        pub [31;1mstruct[0m ScopeSkip {

	    Named :argument mismatch: no [31;3marg[0m [31;1mmin[0m.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m10:16+4[0m

========

        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()

            ScopeSkip(min: -1, max: +1)     
                .end - 1;

---- <fail> ----
[2m[0m_0[2m.fu 12:13+9[0m:

[2m      |         pub fn main()[0m
[2m      | [0m
[2m   12 | [0m            [31;1mScopeSkip[0m(min: -1, max: +1)     
[2m      |                 .end - 1;[0m
[2m      | [0m

	Bad call to [94;1mScopeSkip[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtype[0m [94;1mScopeSkip[0m at [2m2:13+6[0m:
[2m    2 | [0m        pub [31;1mstruct[0m ScopeSkip {

	    Named :argument mismatch: no [31;3marg[0m [31;1mmin[0m.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m10:16+4[0m

========

        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()

            ScopeSkip(start: -1, end: +1)   
                .end - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct ScopeSkip_iozY;

                                #ifndef DEF_ScopeSkip_iozYP9lEHXh
                                #define DEF_ScopeSkip_iozYP9lEHXh
struct ScopeSkip_iozY
{
                                // shape_hash:    edd18b1834ec931d
                                // non_triv_mask: 0000000000000000
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int search_MbR9(/*1:1*/ const ScopeSkip_iozY& skip)
{
    return skip.end - skip.start;
}

int fu_MAIN()
{
    return ScopeSkip_iozY { {/*unused non-zst*/}, +1 }.end - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x?: f32; y?: f32; z?: f32; };

        struct mat34 {
            mx: vec3; my: vec3; mz: vec3;
            mo: vec3;
        };

        inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        // What broke is this using reports a conflict,
        //  because 'determinant' got expanded within 'inverse',
        //   and there's another using mat34 there.
        //    Basically we totally don't want it to expand there.
        inline fn determinant(using _: mat34): f32
            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z
            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;

        fn inverse(using mat: mat34): mat34
        {
            let idet = 1 / mat.determinant;

            let i_mx = vec3(
                idet * (- mz.y * my.z + my.y * mz.z),
                idet * (+ mz.y * mx.z - mx.y * mz.z),
                idet * (- my.y * mx.z + mx.y * my.z));

            let i_my = vec3(
                idet * (+ mz.x * my.z - my.x * mz.z),
                idet * (- mz.x * mx.z + mx.x * mz.z),
                idet * (+ my.x * mx.z - mx.x * my.z));

            let i_mz = vec3(
                idet * (- mz.x * my.y + my.x * mz.y),
                idet * (+ mz.x * mx.y - mx.x * mz.y),
                idet * (- my.x * mx.y + mx.x * my.y));

            return mat34(
                i_mx, i_my, i_mz,

                vec3( // point3
                      mo.x * -i_mx.x +
                      mo.y * -i_my.x +
                      mo.z * -i_mz.x,

                      mo.x * -i_mx.y +
                      mo.y * -i_my.y +
                      mo.z * -i_mz.y,

                      mo.x * -i_mx.z +
                      mo.y * -i_my.z +
                      mo.z * -i_mz.z));
        }

        fn main() i32 <|
            mat34_identity.inverse.determinant - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct mat34_EVl8;
struct vec3_vMFc;

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_mat34_EVl8LEVPS98
                                #define DEF_mat34_EVl8LEVPS98
struct mat34_EVl8
{
                                // shape_hash:    abf9930a363b90f5
                                // non_triv_mask: 0000000000000000
    vec3_vMFc mx;
    vec3_vMFc my;
    vec3_vMFc mz;
    vec3_vMFc mo;
    explicit operator bool() const noexcept
    {
        return false
            || mx
            || my
            || mz
            || mo
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static mat34_EVl8 inverse_MbR9(/*1:1*/ const mat34_EVl8& mat)
{
    const float idet = (1.0f / (((((((-mat.mz.x * mat.my.y) * mat.mx.z) + ((mat.my.x * mat.mz.y) * mat.mx.z)) + ((mat.mz.x * mat.mx.y) * mat.my.z)) - ((mat.mx.x * mat.mz.y) * mat.my.z)) - ((mat.my.x * mat.mx.y) * mat.mz.z)) + ((mat.mx.x * mat.my.y) * mat.mz.z)));
    const vec3_vMFc i_mx = vec3_vMFc { (idet * ((-mat.mz.y * mat.my.z) + (mat.my.y * mat.mz.z))), (idet * ((+mat.mz.y * mat.mx.z) - (mat.mx.y * mat.mz.z))), (idet * ((-mat.my.y * mat.mx.z) + (mat.mx.y * mat.my.z))) };
    const vec3_vMFc i_my = vec3_vMFc { (idet * ((+mat.mz.x * mat.my.z) - (mat.my.x * mat.mz.z))), (idet * ((-mat.mz.x * mat.mx.z) + (mat.mx.x * mat.mz.z))), (idet * ((+mat.my.x * mat.mx.z) - (mat.mx.x * mat.my.z))) };
    const vec3_vMFc i_mz = vec3_vMFc { (idet * ((-mat.mz.x * mat.my.y) + (mat.my.x * mat.mz.y))), (idet * ((+mat.mz.x * mat.mx.y) - (mat.mx.x * mat.mz.y))), (idet * ((-mat.my.x * mat.mx.y) + (mat.mx.x * mat.my.y))) };
    return mat34_EVl8 { vec3_vMFc(i_mx), vec3_vMFc(i_my), vec3_vMFc(i_mz), vec3_vMFc { (((mat.mo.x * -i_mx.x) + (mat.mo.y * -i_my.x)) + (mat.mo.z * -i_mz.x)), (((mat.mo.x * -i_mx.y) + (mat.mo.y * -i_my.y)) + (mat.mo.z * -i_mz.y)), (((mat.mo.x * -i_mx.z) + (mat.mo.y * -i_my.z)) + (mat.mo.z * -i_mz.z)) } };
}

int fu_MAIN()
{
    mat34_EVl8 _;
    return int(((_ = inverse_MbR9(mat34_EVl8 { vec3_vMFc { 1.0f, 0.0f, 0.0f }, vec3_vMFc { 0.0f, 1.0f, 0.0f }, vec3_vMFc { 0.0f, 0.0f, 1.0f }, vec3_vMFc{} }), (((((((-_.mz.x * _.my.y) * _.mx.z) + ((_.my.x * _.mz.y) * _.mx.z)) + ((_.mz.x * _.mx.y) * _.my.z)) - ((_.mx.x * _.mz.y) * _.my.z)) - ((_.my.x * _.mx.y) * _.mz.z)) + ((_.mx.x * _.my.y) * _.mz.z))) - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

========

        struct TEA { v0: u32; v1: u32 }

        inline fn r4(using ref _: TEA, ref sum: u32) {
            mut delta: u32 = 0x9e3779b9;
            for (mut i = 0; i < 4; i++) {
                sum += delta;
                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        // Stack overflow solving this,
        //  argmax is +inf, and it just
        //   re-enters and re-enters.
        inline fn r4(ref tea: TEA) {
            mut sum: u32; tea.r4(sum);
        }

        fn main() {
            mut tea: TEA;
            tea.r4();
            return (tea.v0 ^ tea.v0).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct TEA_0Daz;

                                #ifndef DEF_TEA_0DazMLEH01f
                                #define DEF_TEA_0DazMLEH01f
struct TEA_0Daz
{
                                // shape_hash:    22fcb95c2ae77eea
                                // non_triv_mask: 0000000000000000
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    TEA_0Daz tea {};

    {
        unsigned sum {};
        const unsigned delta = 0x9e3779b9u;
        for (int i = 0; i < 4; i++)
        {
            sum += delta;
            tea.v0 += ((((tea.v1 << 4u) + 0xa341316cu) ^ (tea.v1 + sum)) ^ ((tea.v1 >> 5u) + 0xc8013ea4u));
            tea.v1 += ((((tea.v0 << 4u) + 0xad90777du) ^ (tea.v0 + sum)) ^ ((tea.v0 >> 5u) + 0x7e95761eu));
        };
    };
    return int((tea.v0 ^ tea.v0));
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { i: i32; };
        type Y = X;
        fn main() Y(1).i / 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_SchF;

                                #ifndef DEF_X_SchFD6M49r4
                                #define DEF_X_SchFD6M49r4
struct X_SchF
{
                                // shape_hash:    aca42a82859b0b33
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return X_SchF { 1 }.i / 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node {
            kind  ?: string;
            items ?: Node[];
            value ?: string;
        };

        fn astReplace(node: Node, mutate): Node {
            fn walk(shadow ref node: Node) {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        fn test(n: Node, a: string, b: string) {
            return astReplace(n, |ref item: Node| {
                if (item.value == a) {
                    if (item.items.len == 1 && item.kind == "call")
                        item.value = b;
                    else if (item.kind == "str")
                        item.value = b;
                }
            });
        }

        fn main() {
            let v0 = Node(kind: "str", value: "woot");
            let v1 = v0.test("woot", "who");
            return v1.value.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Node_Hqeu;
inline static void walk_8JbI(Node_Hqeu&, fu::view<char>, fu::vec_range<char>);

                                #ifndef DEF_Node_HqeuCQM2lP7
                                #define DEF_Node_HqeuCQM2lP7
struct Node_Hqeu
{
                                // shape_hash:    f934419c5be9d2b5
                                // non_triv_mask: 0000801800000000
    fu::str kind;
    fu::vec<Node_Hqeu> items;
    fu::str value;
    Node_Hqeu(const Node_Hqeu&) = default;
    Node_Hqeu(Node_Hqeu&&) = default;
    Node_Hqeu& operator=(Node_Hqeu&&) = default;
    Node_Hqeu& operator=(const Node_Hqeu& selfrec) { return *this = Node_Hqeu(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
            || value
        ;
    }
};
                                #endif

                                #ifndef STR_2MbpvmVG5fd
                                #define STR_2MbpvmVG5fd
static const fu::str str_2MbpvmVG5fd fu_INIT_PRIORITY(1001) { "who"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF___zsUGTWq9pkb
                                #define DEF___zsUGTWq9pkb
inline static void _zsUG(/*7:7*/ Node_Hqeu& item, /*7:7*/ fu::view<char> a, /*7:7*/ fu::vec_range<char> b)
{
    if (item.value == a)
    {
        if ((item.items.size() == 1) && (item.kind == "call"_view))
            item.value = b;
        else if (item.kind == "str"_view)
            item.value = b;

    };
}
                                #endif

                                #ifndef DEF_walk_8JbIQGwupdf
                                #define DEF_walk_8JbIQGwupdf
inline static void walk_8JbI(/*7:1*/ Node_Hqeu& node, /*7:7*/ fu::view<char> a, /*7:7*/ fu::vec_range<char> b)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        Node_Hqeu* _0;
        (_0 = &(node.items.mutref(i)), walk_8JbI(*_0, a, b));
    };
    _zsUG(node, a, b);
}
                                #endif

                                #ifndef DEF_astReplace_jpqai3H6xOk
                                #define DEF_astReplace_jpqai3H6xOk
inline static Node_Hqeu astReplace_jpqa(/*F:F*/ const Node_Hqeu& node, /*F:F*/ fu::view<char> a, /*F:F*/ fu::vec_range<char> b)
{
    /*MOV*/ Node_Hqeu node_1 = node;
    walk_8JbI(node_1, a, b);
    return /*NRVO*/ node_1;
}
                                #endif

static Node_Hqeu test_MbR9(/*7:7*/ const Node_Hqeu& n, /*7:7*/ fu::view<char> a, /*7:7*/ fu::vec_range<char> b)
{
    return astReplace_jpqa(n, a, b);
}

int fu_MAIN()
{
    Node_Hqeu v0 = Node_Hqeu { fu::str("str"_fu), fu::vec<Node_Hqeu>{}, fu::str("woot"_fu) };
    Node_Hqeu v1 = test_MbR9(v0, "woot"_view, str_2MbpvmVG5fd);
    return v1.value.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_AARMustSeq

========

        fn main() {
            mut x:  
                    typeof(i32)      = 0;
            return x;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:28+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut x:  [0m
[2m    4 | [0m                    typeof([31;1mi32[0m)      = 0;
[2m      |             return x;[0m
[2m      |         }[0m

	Redundant [31;1mtypeof[0m, this is a type, not a value: [35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            mut x:  
                    i32              = 0;
            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    return x;
}

#endif

int main() { return fu_MAIN(); }

========

        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(ref _v: $V, _n: SolvedNode)
        {
            fn traverse(ref v: $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using ref v: Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);



            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SolvedNode_5CCD;
struct Visitor_YWCb;
inline static void traverse_Al3r(Visitor_YWCb&, const SolvedNode_5CCD&);

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000040000200000
    int value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Visitor_YWCbUJaheZ9
                                #define DEF_Visitor_YWCbUJaheZ9
struct Visitor_YWCb
{
                                // shape_hash:    86d8e6be772e4547
                                // non_triv_mask: 0000000000000000
    int sum;
    explicit operator bool() const noexcept
    {
        return false
            || sum
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void visit_MbR9(/*3:3*/ Visitor_YWCb& v, /*3:3*/ const SolvedNode_5CCD& node)
{
    v.sum += node.value;
}

                                #ifndef DEF_traverse_Al3rcZncfr7
                                #define DEF_traverse_Al3rcZncfr7
inline static void traverse_Al3r(/*1:1*/ Visitor_YWCb& v, /*3:3*/ const SolvedNode_5CCD& n)
{
    visit_MbR9(v, n);
    for (int i = 0; i < n.items.size(); i++)
        traverse_Al3r(v, n.items[i]);

}
                                #endif

                                #ifndef DEF_visitNodes_ltP1EjfV5mk
                                #define DEF_visitNodes_ltP1EjfV5mk
inline static void visitNodes_ltP1(/*1:1*/ Visitor_YWCb& _v, /*3:3*/ const SolvedNode_5CCD& _n)
{
    traverse_Al3r(_v, _n);
}
                                #endif

int fu_MAIN()
{
    SolvedNode_5CCD tree = SolvedNode_5CCD { 3, fu::vec<SolvedNode_5CCD> {{ SolvedNode_5CCD { 5, fu::vec<SolvedNode_5CCD>{} }, SolvedNode_5CCD { 7, fu::vec<SolvedNode_5CCD>{} } }} };
    Visitor_YWCb myVisitor {};
    visitNodes_ltP1(myVisitor, tree);
    return myVisitor.sum - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall

========

        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(ref _v: $V, _n: SolvedNode)
        {
            fn traverse(ref v: $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using ref v: Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);


            // This is an aside, managed to lose the copy qual when working structs
            //  Initially noticed it because visitNodes tried to change its sighash
            mut cpy = tree; cpy = tree; // <- but this fails cleanly when tree is nocopy


            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct SolvedNode_5CCD;
struct Visitor_YWCb;
inline static void traverse_Al3r(Visitor_YWCb&, const SolvedNode_5CCD&);

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000040000200000
    int value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Visitor_YWCbUJaheZ9
                                #define DEF_Visitor_YWCbUJaheZ9
struct Visitor_YWCb
{
                                // shape_hash:    86d8e6be772e4547
                                // non_triv_mask: 0000000000000000
    int sum;
    explicit operator bool() const noexcept
    {
        return false
            || sum
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void visit_MbR9(/*3:3*/ Visitor_YWCb& v, /*3:3*/ const SolvedNode_5CCD& node)
{
    v.sum += node.value;
}

                                #ifndef DEF_traverse_Al3rcZncfr7
                                #define DEF_traverse_Al3rcZncfr7
inline static void traverse_Al3r(/*1:1*/ Visitor_YWCb& v, /*3:3*/ const SolvedNode_5CCD& n)
{
    visit_MbR9(v, n);
    for (int i = 0; i < n.items.size(); i++)
        traverse_Al3r(v, n.items[i]);

}
                                #endif

                                #ifndef DEF_visitNodes_ltP1EjfV5mk
                                #define DEF_visitNodes_ltP1EjfV5mk
inline static void visitNodes_ltP1(/*1:1*/ Visitor_YWCb& _v, /*3:3*/ const SolvedNode_5CCD& _n)
{
    traverse_Al3r(_v, _n);
}
                                #endif

int fu_MAIN()
{
    SolvedNode_5CCD tree = SolvedNode_5CCD { 3, fu::vec<SolvedNode_5CCD> {{ SolvedNode_5CCD { 5, fu::vec<SolvedNode_5CCD>{} }, SolvedNode_5CCD { 7, fu::vec<SolvedNode_5CCD>{} } }} };
    SolvedNode_5CCD cpy = tree;
    cpy = tree;
    Visitor_YWCb myVisitor {};
    visitNodes_ltP1(myVisitor, tree);
    return myVisitor.sum - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedCall

========

        return 0 > 1 ? throw("should type check") : 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/init_priority.h>


                                #ifndef STR_7wbAmZZhzaj
                                #define STR_7wbAmZZhzaj
static const fu::str str_7wbAmZZhzaj fu_INIT_PRIORITY(1001) { "should type check"_fu };
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0 > 1)
        fu::fail(fu::str(str_7wbAmZZhzaj));
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_MbR9()
{
    fu::fail(fu::str("hey"_fu));
}

int fu_MAIN()
{

    try
    {
        throw_hey_MbR9();
    }
    catch (const std::exception& o_0)
    {
        fu::str err = fu::to_str(o_0.what());

        return err.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

========

        fn throw_hey() {
            throw("hey");
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_MbR9()
{
    fu::fail(fu::str("hey"_fu));
}

int fu_MAIN()
{

    try
    {
        throw_hey_MbR9();
    }
    catch (const std::exception& o_0)
    {
        fu::str err = fu::to_str(o_0.what());

        return err.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

========

        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                return throw_hey();
            }
            catch (e) {
                return e.len - 3;
            }

            return 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_MbR9()
{
    fu::fail(fu::str("hey"_fu));
}

int fu_MAIN()
{

    try
    {
        throw_hey_MbR9();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> next_MbR9(/*3:3*/ fu::view<fu::str> args, /*3:2*/ int& idx)
{
    const int i = idx++;
    if (i < args.size())
        return args[i];
    else
        return str_00000000000;

}

static int cli_handle_MbR9(/*1:1*/ fu::view<fu::str> args)
{
    int idx = 0;
    return next_MbR9(args, idx).size() - 5;
}

int fu_MAIN()
{
    return cli_handle_MbR9(fu::view<fu::str> {{ fu::str("hello"_fu), fu::str("you"_fu) }});
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec_range<char> next_MbR9(/*3:3*/ fu::view<fu::str> args, /*3:2*/ int& idx)
{
    const int i = idx++;
    if (i < args.size())
        return args[i];
    else
        return (*(fu::str*)fu::NIL);

}

static int cli_handle_MbR9(/*1:1*/ fu::view<fu::str> args)
{
    int idx = 0;
    return next_MbR9(args, idx).size() - 5;
}

int fu_MAIN()
{
    return cli_handle_MbR9(fu::view<fu::str> {{ fu::str("hello"_fu), fu::str("you"_fu) }});
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { i: i32; };

        fn         ++(using ref x: X) ++i;
        postfix fn ++(using ref x: X) i++;

        fn main() {
            mut x: X;
            let a = x++;
            let b = ++x;
            return a || b - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_SchF;

                                #ifndef DEF_X_SchFD6M49r4
                                #define DEF_X_SchFD6M49r4
struct X_SchF
{
                                // shape_hash:    aca42a82859b0b33
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int operator++(/*1:1*/ X_SchF& x, /*postfix*/int)
{
    return x.i++;
}

static int operator++(/*1:1*/ X_SchF& x)
{
    return ++x.i;
}

int fu_MAIN()
{
    X_SchF x {};
    const int a = x++;
    const int /*x*/ b = ++x;
    return a ? a : (b - 2);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(s: $T) {
            mut sum = 0;
            for (fieldname i: $T) sum += s.i;
            return sum;
        }

        struct XY { x: i32; y: i32; };

        fn main() {
            let thing = XY(1, 2);
            let sum = test(thing);
            return sum - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_FNIMw9DYfzb
                                #define DEF_test_FNIMw9DYfzb
inline static int test_FNIM(/*1:1*/ const XY_tqAU& s)
{
    int sum = 0;

    {
        sum += s.x;
        sum += s.y;
    };
    return sum;
}
                                #endif

int fu_MAIN()
{
    const XY_tqAU thing = XY_tqAU { 1, 2 };
    const int sum = test_FNIM(thing);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct ScopeSkip     { imports:     i32[]; implicits:     i32[]; }
        struct ScopeSkipMemo { imports_len: i32;   implicits_len: i32;   }

        fn snap(ss: ScopeSkip) {
            mut r: ScopeSkipMemo;
            for (fieldname i: typeof(ss))
                r.i_len = ss.i.len;

            return r;
        }

        fn check(v) {
            mut sum = 0; mut mul = 1;
            for (fieldname i: typeof(v)) {
                sum += v.i * mul; mul *= 10;
            }

            return sum;
        }

        fn main() check(snap(ScopeSkip([ 1 ], [ 2, 2 ]))) - 21;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct ScopeSkip_kee3;
struct ScopeSkipMemo_uJ4k;

                                #ifndef DEF_ScopeSkip_kee3NJui3f7
                                #define DEF_ScopeSkip_kee3NJui3f7
struct ScopeSkip_kee3
{
                                // shape_hash:    88732e9d3ed7c545
                                // non_triv_mask: 0018000000000000
    fu::vec<int> imports;
    fu::vec<int> implicits;
    explicit operator bool() const noexcept
    {
        return false
            || imports
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeSkipMemo_uJ4kuckx4K9
                                #define DEF_ScopeSkipMemo_uJ4kuckx4K9
struct ScopeSkipMemo_uJ4k
{
                                // shape_hash:    453fc0cc8cdeb717
                                // non_triv_mask: 0000000000000000
    int imports_len;
    int implicits_len;
    explicit operator bool() const noexcept
    {
        return false
            || imports_len
            || implicits_len
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static ScopeSkipMemo_uJ4k snap_MbR9(/*1:1*/ const ScopeSkip_kee3& ss)
{
    ScopeSkipMemo_uJ4k r {};

    {
        r.imports_len = ss.imports.size();
        r.implicits_len = ss.implicits.size();
    };
    return r;
}

                                #ifndef DEF_check_SSd3oOgLF48
                                #define DEF_check_SSd3oOgLF48
inline static int check_SSd3(/*1:1*/ const ScopeSkipMemo_uJ4k& v)
{
    int sum = 0;
    int mul = 1;

    {

        {
            sum += (v.imports_len * mul);
            mul *= 10;
        };
        sum += (v.implicits_len * mul);
        mul *= 10;
    };
    return sum;
}
                                #endif

int fu_MAIN()
{
    return check_SSd3(snap_MbR9(ScopeSkip_kee3 { fu::vec<int> {{ 1 }}, fu::vec<int> {{ 2, 2 }} })) - 21;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Lazy(getValue) {
            struct Lazy {
                evaluated?: bool;
                value?:     typeof(getValue());
                getValue?:  typeof(fn getValue);
            };

            return Lazy();
        }

        fn get(ref lazy) {
            if (!lazy.evaluated) {
                lazy.evaluated  = true;

                // This is just exploratory stuff,
                //  don't feel obliged to keep this working.
                let getValue    = lazy.getValue;
                lazy.value      = getValue();
            }

            return lazy.value;
        }

        fn main() {
            mut calls   = 0;
            mut lazy    = Lazy(|| calls++);
            mut res     = lazy.get() + lazy.get();

            return res == 0 && calls == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Lazy_A3ds;

                                #ifndef DEF_Lazy_A3dszJbmkp8
                                #define DEF_Lazy_A3dszJbmkp8
struct Lazy_A3ds
{
                                // shape_hash:    28949a52af270f16
                                // non_triv_mask: 0000000000000000
    bool evaluated;
    int value;
    Lazy_A3ds(const Lazy_A3ds&) = delete;
    Lazy_A3ds(Lazy_A3ds&&) = default;
    Lazy_A3ds& operator=(const Lazy_A3ds&) = delete;
    Lazy_A3ds& operator=(Lazy_A3ds&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || evaluated
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Lazy_iDQMysYNC6b
                                #define DEF_Lazy_iDQMysYNC6b
inline static Lazy_A3ds Lazy_iDQM()
{
    return Lazy_A3ds{};
}
                                #endif

                                #ifndef DEF___5inzhtc1y8f
                                #define DEF___5inzhtc1y8f
inline static int _5inz(/*1:1*/ int& calls)
{
    return calls++;
}
                                #endif

                                #ifndef DEF_get_Bc22ablRkSl
                                #define DEF_get_Bc22ablRkSl
inline static int get_Bc22(/*3:1*/ Lazy_A3ds& lazy, /*3:2*/ int& calls)
{
    if (!lazy.evaluated)
    {
        lazy.evaluated = true;
        lazy.value = _5inz(calls);
    };
    return lazy.value;
}
                                #endif

int fu_MAIN()
{
    int calls = 0;
    Lazy_A3ds lazy = Lazy_iDQM();
    int _0;
    const int res = (_0 = get_Bc22(lazy, calls), (_0 + get_Bc22(lazy, calls)));
    if ((res == 0) && (calls == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedImplicit, N_BckMustSeq

========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }


        let PRELUDE =           
            parse("AAB");       


        fn main() PRELUDE.len == 6 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 43:13+5[0m:

[2m      | [0m
[2m      |         let PRELUDE =           [0m
[2m   43 | [0m            [31;1mparse[0m("AAB");       
[2m      | [0m
[2m      | [0m

	No implicit [31;1merrout[0m: [35;3mmut[0m [35;3mref[0m [35;3mstring[0m in scope, needed to call [35;3mfn[0m [94;1mparse[0m:

            because of call to [35;3mfn[0m [94;1mparseExpression[0m at [2m37:20+15[0m:

[2m      |             }[0m
[2m      | [0m
[2m   37 | [0m            return [31;1mparseExpression[0m()
[2m      |                  ~ parseExpression(parseHead: popTwoChars);[0m
[2m      |         }[0m

            because of call to [35;3mfn[0m [94;1mpopOneChar[0m at [2m15:28+9[0m:

[2m      |         {[0m
[2m      |             fn parseExpression!T(parseHead: T = fn popOneChar) {[0m
[2m   15 | [0m                let head = [31;1mparseHead[0m();
[2m      |                 return parseExpressionTail(head);[0m
[2m      |             }[0m

            because of call to [35;3mfn[0m [94;1mERRLOG[0m at [2m20:34+6[0m:

[2m      | [0m
[2m      |             fn popOneChar() {[0m
[2m   20 | [0m                if (!str) return [31;1mERRLOG[0m("str.len < 1");
[2m      |                 let lastChar = str.slice(str.len - 1, str.len);[0m
[2m      |                 str.pop();[0m

            because of [35;3mimplicit mut ref arg[0m [94;1merrout[0m at [2m2:32+6[0m:

[2m      | [0m
[2m    2 | [0m        fn ERRLOG(implicit ref [31;1merrout[0m: string, msg = "Assertion failed.\n") {
[2m      |             errout ~= msg;[0m
[2m      |             return [];[0m


========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }


        let PRELUDE =           
            parse("AAB");       

        pub import _0;
        fn main() PRELUDE.len == 6 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 43:13+5[0m:

[2m      | [0m
[2m      |         let PRELUDE =           [0m
[2m   43 | [0m            [31;1mparse[0m("AAB");       
[2m      | [0m
[2m      | [0m

	No implicit [31;1merrout[0m: [35;3mmut[0m [35;3mref[0m [35;3mstring[0m in scope, needed to call [35;3mfn[0m [94;1mparse[0m:

            because of call to [35;3mfn[0m [94;1mparseExpression[0m at [2m37:20+15[0m:

[2m      |             }[0m
[2m      | [0m
[2m   37 | [0m            return [31;1mparseExpression[0m()
[2m      |                  ~ parseExpression(parseHead: popTwoChars);[0m
[2m      |         }[0m

            because of call to [35;3mfn[0m [94;1mpopOneChar[0m at [2m15:28+9[0m:

[2m      |         {[0m
[2m      |             fn parseExpression!T(parseHead: T = fn popOneChar) {[0m
[2m   15 | [0m                let head = [31;1mparseHead[0m();
[2m      |                 return parseExpressionTail(head);[0m
[2m      |             }[0m

            because of call to [35;3mfn[0m [94;1mERRLOG[0m at [2m20:34+6[0m:

[2m      | [0m
[2m      |             fn popOneChar() {[0m
[2m   20 | [0m                if (!str) return [31;1mERRLOG[0m("str.len < 1");
[2m      |                 let lastChar = str.slice(str.len - 1, str.len);[0m
[2m      |                 str.pop();[0m

            because of [35;3mimplicit mut ref arg[0m [94;1merrout[0m at [2m2:32+6[0m:

[2m      | [0m
[2m    2 | [0m        fn ERRLOG(implicit ref [31;1merrout[0m: string, msg = "Assertion failed.\n") {
[2m      |             errout ~= msg;[0m
[2m      |             return [];[0m


========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }

        pub import _0;
        let PRELUDE =           
            parse("AAB");       


        fn main() PRELUDE.len == 6 ? 0 : 1;

---- <fail> ----
[2m[0m_1[2m.fu 3:13+5[0m:

[2m      |         pub import _0;[0m
[2m      |         let PRELUDE =           [0m
[2m    3 | [0m            [31;1mparse[0m("AAB");       
[2m      | [0m
[2m      | [0m

	No implicit [31;1merrout[0m: [35;3mmut[0m [35;3mref[0m [35;3mstring[0m in scope, needed to call [35;3mfn[0m [94;1mparse[0m:

            because of call to [35;3mfn[0m [94;1mparseExpression[0m at [2m[0m_0[2m.fu 37:20+15[0m:

[2m      |             }[0m
[2m      | [0m
[2m   37 | [0m            return [31;1mparseExpression[0m()
[2m      |                  ~ parseExpression(parseHead: popTwoChars);[0m
[2m      |         }[0m

            because of call to [35;3mfn[0m [94;1mpopOneChar[0m at [2m[0m_0[2m.fu 15:28+9[0m:

[2m      |         {[0m
[2m      |             fn parseExpression!T(parseHead: T = fn popOneChar) {[0m
[2m   15 | [0m                let head = [31;1mparseHead[0m();
[2m      |                 return parseExpressionTail(head);[0m
[2m      |             }[0m

            because of call to [35;3mfn[0m [94;1mERRLOG[0m at [2m[0m_0[2m.fu 20:34+6[0m:

[2m      | [0m
[2m      |             fn popOneChar() {[0m
[2m   20 | [0m                if (!str) return [31;1mERRLOG[0m("str.len < 1");
[2m      |                 let lastChar = str.slice(str.len - 1, str.len);[0m
[2m      |                 str.pop();[0m

            because of [35;3mimplicit mut ref arg[0m [94;1merrout[0m at [2m[0m_0[2m.fu 2:32+6[0m:

[2m      | [0m
[2m    2 | [0m        fn ERRLOG(implicit ref [31;1merrout[0m: string, msg = "Assertion failed.\n") {
[2m      |             errout ~= msg;[0m
[2m      |             return [];[0m


========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }

        pub import _0;
        let PRELUDE =           
            parse("AAB");       

        pub import _1;
        fn main() PRELUDE.len == 6 ? 0 : 1;

---- <fail> ----
[2m[0m_1[2m.fu 3:13+5[0m:

[2m      |         pub import _0;[0m
[2m      |         let PRELUDE =           [0m
[2m    3 | [0m            [31;1mparse[0m("AAB");       
[2m      | [0m
[2m      | [0m

	No implicit [31;1merrout[0m: [35;3mmut[0m [35;3mref[0m [35;3mstring[0m in scope, needed to call [35;3mfn[0m [94;1mparse[0m:

            because of call to [35;3mfn[0m [94;1mparseExpression[0m at [2m[0m_0[2m.fu 37:20+15[0m:

[2m      |             }[0m
[2m      | [0m
[2m   37 | [0m            return [31;1mparseExpression[0m()
[2m      |                  ~ parseExpression(parseHead: popTwoChars);[0m
[2m      |         }[0m

            because of call to [35;3mfn[0m [94;1mpopOneChar[0m at [2m[0m_0[2m.fu 15:28+9[0m:

[2m      |         {[0m
[2m      |             fn parseExpression!T(parseHead: T = fn popOneChar) {[0m
[2m   15 | [0m                let head = [31;1mparseHead[0m();
[2m      |                 return parseExpressionTail(head);[0m
[2m      |             }[0m

            because of call to [35;3mfn[0m [94;1mERRLOG[0m at [2m[0m_0[2m.fu 20:34+6[0m:

[2m      | [0m
[2m      |             fn popOneChar() {[0m
[2m   20 | [0m                if (!str) return [31;1mERRLOG[0m("str.len < 1");
[2m      |                 let lastChar = str.slice(str.len - 1, str.len);[0m
[2m      |                 str.pop();[0m

            because of [35;3mimplicit mut ref arg[0m [94;1merrout[0m at [2m[0m_0[2m.fu 2:32+6[0m:

[2m      | [0m
[2m    2 | [0m        fn ERRLOG(implicit ref [31;1merrout[0m: string, msg = "Assertion failed.\n") {
[2m      |             errout ~= msg;[0m
[2m      |             return [];[0m


========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }


        let PRELUDE =           
            tryParse("AAB");    


        fn main() PRELUDE.len == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_iKo80AlQRfj
                                #define STR_iKo80AlQRfj
static const fu::str str_iKo80AlQRfj fu_INIT_PRIORITY(1001) { "AAB"_fu };
                                #endif

#ifndef fu_NO_fdefs

static void ERRLOG_MbR9(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> errout)
{
    errout += msg;
    return;
}

static fu::str popOneChar_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (!str)
    {
        ERRLOG_MbR9("str.len < 1"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChar = fu::str(fu::get_range(str, (str.size() - 1), str.size()));
        str.pop();
        return /*NRVO*/ lastChar;
    };
}

static fu::str parseExpressionTail_MbR9(/*1:1*/ fu::view<char> head)
{
    return head + head;
}

                                #ifndef DEF_parseExpression_0JIj71REDxc
                                #define DEF_parseExpression_0JIj71REDxc
inline static fu::str parseExpression_0JIj(/*7:7*/ fu::vec_range_mut<char> str, /*7:7*/ fu::vec_range_mut<char> errout)
{
    fu::str head = popOneChar_MbR9(str, errout);
    return parseExpressionTail_MbR9(head);
}
                                #endif

static fu::str popTwoChars_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (str.size() < 2)
    {
        ERRLOG_MbR9("str.len < 2"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChars = fu::str(((str.size() > 1) ? fu::get_range(str, (str.size() - 2), str.size()) : (*(fu::str*)fu::NIL)));
        str.shrink((str.size() - 2));
        return /*NRVO*/ lastChars;
    };
}

                                #ifndef DEF_parseExpression_p8DiBfBVbD3
                                #define DEF_parseExpression_p8DiBfBVbD3
inline static fu::str parseExpression_p8Di(/*1:1*/ fu::view<char> parseHead)
{
    return parseExpressionTail_MbR9(parseHead);
}
                                #endif

static fu::str parse_MbR9(fu::str&& str, /*2:2*/ fu::vec_range_mut<char> errout)
{
    fu::str _0 {};
    return (_0 = parseExpression_0JIj(str, errout), (static_cast<fu::str&&>(_0) + parseExpression_p8Di(popTwoChars_MbR9(str, errout))));
}

static fu::str tryParse_MbR9(/*1:1*/ fu::vec_range<char> str)
{
    /*MOV*/ fu::str errout {};
    fu::str _0 {};
    return (_0 = parse_MbR9(fu::str(str), errout)) ? static_cast<fu::str&&>(_0) : static_cast<fu::str&&>(errout);
}

static const fu::str PRELUDE fu_INIT_PRIORITY(1001) = tryParse_MbR9(str_iKo80AlQRfj);

int fu_MAIN()
{
    if (PRELUDE.size() == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_SD_HasStaticInit, N_COWRestrict

========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }


        let PRELUDE =           
            tryParse("AAB");    

        pub import _0;
        fn main() PRELUDE.len == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>


#ifndef fu_NO_fdefs

extern const fu::str PRELUDE;
int fu_MAIN()
{
    if (PRELUDE.size() == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_iKo80AlQRfj
                                #define STR_iKo80AlQRfj
static const fu::str str_iKo80AlQRfj fu_INIT_PRIORITY(1001) { "AAB"_fu };
                                #endif

#ifndef fu_NO_fdefs

void ERRLOG_MbR9(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> errout)
{
    errout += msg;
    return;
}

static fu::str popOneChar_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (!str)
    {
        ERRLOG_MbR9("str.len < 1"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChar = fu::str(fu::get_range(str, (str.size() - 1), str.size()));
        str.pop();
        return /*NRVO*/ lastChar;
    };
}

static fu::str parseExpressionTail_MbR9(/*1:1*/ fu::view<char> head)
{
    return head + head;
}

                                #ifndef DEF_parseExpression_0JIj71REDxc
                                #define DEF_parseExpression_0JIj71REDxc
inline static fu::str parseExpression_0JIj(/*7:7*/ fu::vec_range_mut<char> str, /*7:7*/ fu::vec_range_mut<char> errout)
{
    fu::str head = popOneChar_MbR9(str, errout);
    return parseExpressionTail_MbR9(head);
}
                                #endif

static fu::str popTwoChars_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (str.size() < 2)
    {
        ERRLOG_MbR9("str.len < 2"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChars = fu::str(((str.size() > 1) ? fu::get_range(str, (str.size() - 2), str.size()) : (*(fu::str*)fu::NIL)));
        str.shrink((str.size() - 2));
        return /*NRVO*/ lastChars;
    };
}

                                #ifndef DEF_parseExpression_p8DiBfBVbD3
                                #define DEF_parseExpression_p8DiBfBVbD3
inline static fu::str parseExpression_p8Di(/*1:1*/ fu::view<char> parseHead)
{
    return parseExpressionTail_MbR9(parseHead);
}
                                #endif

fu::str parse_MbR9(fu::str&& str, /*2:2*/ fu::vec_range_mut<char> errout)
{
    fu::str _0 {};
    return (_0 = parseExpression_0JIj(str, errout), (static_cast<fu::str&&>(_0) + parseExpression_p8Di(popTwoChars_MbR9(str, errout))));
}

fu::str tryParse_MbR9(/*1:1*/ fu::vec_range<char> str)
{
    /*MOV*/ fu::str errout {};
    fu::str _0 {};
    return (_0 = parse_MbR9(fu::str(str), errout)) ? static_cast<fu::str&&>(_0) : static_cast<fu::str&&>(errout);
}

extern const fu::str PRELUDE fu_INIT_PRIORITY(1001) = tryParse_MbR9(str_iKo80AlQRfj);
#endif

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_SD_HasStaticInit, N_COWRestrict

========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }

        pub import _0;
        let PRELUDE =           
            tryParse("AAB");    


        fn main() PRELUDE.len == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

fu::str tryParse_MbR9(fu::vec_range<char>);

                                #ifndef STR_iKo80AlQRfj
                                #define STR_iKo80AlQRfj
static const fu::str str_iKo80AlQRfj fu_INIT_PRIORITY(1002) { "AAB"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str PRELUDE fu_INIT_PRIORITY(1002) = tryParse_MbR9(str_iKo80AlQRfj);

int fu_MAIN()
{
    if (PRELUDE.size() == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

void ERRLOG_MbR9(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> errout)
{
    errout += msg;
    return;
}

static fu::str popOneChar_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (!str)
    {
        ERRLOG_MbR9("str.len < 1"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChar = fu::str(fu::get_range(str, (str.size() - 1), str.size()));
        str.pop();
        return /*NRVO*/ lastChar;
    };
}

static fu::str parseExpressionTail_MbR9(/*1:1*/ fu::view<char> head)
{
    return head + head;
}

                                #ifndef DEF_parseExpression_0JIj71REDxc
                                #define DEF_parseExpression_0JIj71REDxc
inline static fu::str parseExpression_0JIj(/*7:7*/ fu::vec_range_mut<char> str, /*7:7*/ fu::vec_range_mut<char> errout)
{
    fu::str head = popOneChar_MbR9(str, errout);
    return parseExpressionTail_MbR9(head);
}
                                #endif

static fu::str popTwoChars_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (str.size() < 2)
    {
        ERRLOG_MbR9("str.len < 2"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChars = fu::str(((str.size() > 1) ? fu::get_range(str, (str.size() - 2), str.size()) : (*(fu::str*)fu::NIL)));
        str.shrink((str.size() - 2));
        return /*NRVO*/ lastChars;
    };
}

                                #ifndef DEF_parseExpression_p8DiBfBVbD3
                                #define DEF_parseExpression_p8DiBfBVbD3
inline static fu::str parseExpression_p8Di(/*1:1*/ fu::view<char> parseHead)
{
    return parseExpressionTail_MbR9(parseHead);
}
                                #endif

fu::str parse_MbR9(fu::str&& str, /*2:2*/ fu::vec_range_mut<char> errout)
{
    fu::str _0 {};
    return (_0 = parseExpression_0JIj(str, errout), (static_cast<fu::str&&>(_0) + parseExpression_p8Di(popTwoChars_MbR9(str, errout))));
}

fu::str tryParse_MbR9(/*1:1*/ fu::vec_range<char> str)
{
    /*MOV*/ fu::str errout {};
    fu::str _0 {};
    return (_0 = parse_MbR9(fu::str(str), errout)) ? static_cast<fu::str&&>(_0) : static_cast<fu::str&&>(errout);
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_COWRestrict

========

        fn ERRLOG(implicit ref errout: string, msg = "Assertion failed.\n") {
            errout ~= msg;
            return [];
        }

        fn tryParse(str: string) {
            implicit mut errout: string;
            return parse(str) || errout;
        }

        fn parse(mut str: string)
        {
            fn parseExpression!T(parseHead: T = fn popOneChar) {
                let head = parseHead();
                return parseExpressionTail(head);
            }

            fn popOneChar() {
                if (!str) return ERRLOG("str.len < 1");
                let lastChar = str.slice(str.len - 1, str.len);
                str.pop();
                return lastChar;
            }

            fn popTwoChars() {
                if (str.len < 2) return ERRLOG("str.len < 2");
                let lastChars = str.len > 1 && str.slice(str.len - 2, str.len);
                str.shrink(str.len - 2);
                return lastChars;
            }

            fn parseExpressionTail(head: string) {
                return head ~ head;
            }

            return parseExpression()
                 ~ parseExpression(parseHead: popTwoChars);
        }

        pub import _0;
        let PRELUDE =           
            tryParse("AAB");    

        pub import _1;
        fn main() PRELUDE.len == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>


#ifndef fu_NO_fdefs

extern const fu::str PRELUDE;
int fu_MAIN()
{
    if (PRELUDE.size() == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

fu::str tryParse_MbR9(fu::vec_range<char>);

                                #ifndef STR_iKo80AlQRfj
                                #define STR_iKo80AlQRfj
static const fu::str str_iKo80AlQRfj fu_INIT_PRIORITY(1002) { "AAB"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::str PRELUDE fu_INIT_PRIORITY(1002) = tryParse_MbR9(str_iKo80AlQRfj);
#endif

// N_SD_HasStaticInit
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

void ERRLOG_MbR9(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> errout)
{
    errout += msg;
    return;
}

static fu::str popOneChar_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (!str)
    {
        ERRLOG_MbR9("str.len < 1"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChar = fu::str(fu::get_range(str, (str.size() - 1), str.size()));
        str.pop();
        return /*NRVO*/ lastChar;
    };
}

static fu::str parseExpressionTail_MbR9(/*1:1*/ fu::view<char> head)
{
    return head + head;
}

                                #ifndef DEF_parseExpression_0JIj71REDxc
                                #define DEF_parseExpression_0JIj71REDxc
inline static fu::str parseExpression_0JIj(/*7:7*/ fu::vec_range_mut<char> str, /*7:7*/ fu::vec_range_mut<char> errout)
{
    fu::str head = popOneChar_MbR9(str, errout);
    return parseExpressionTail_MbR9(head);
}
                                #endif

static fu::str popTwoChars_MbR9(/*3:3*/ fu::vec_range_mut<char> str, /*3:3*/ fu::vec_range_mut<char> errout)
{
    if (str.size() < 2)
    {
        ERRLOG_MbR9("str.len < 2"_view, errout);
        return fu::str{};
    }
    else
    {
        /*MOV*/ fu::str lastChars = fu::str(((str.size() > 1) ? fu::get_range(str, (str.size() - 2), str.size()) : (*(fu::str*)fu::NIL)));
        str.shrink((str.size() - 2));
        return /*NRVO*/ lastChars;
    };
}

                                #ifndef DEF_parseExpression_p8DiBfBVbD3
                                #define DEF_parseExpression_p8DiBfBVbD3
inline static fu::str parseExpression_p8Di(/*1:1*/ fu::view<char> parseHead)
{
    return parseExpressionTail_MbR9(parseHead);
}
                                #endif

fu::str parse_MbR9(fu::str&& str, /*2:2*/ fu::vec_range_mut<char> errout)
{
    fu::str _0 {};
    return (_0 = parseExpression_0JIj(str, errout), (static_cast<fu::str&&>(_0) + parseExpression_p8Di(popTwoChars_MbR9(str, errout))));
}

fu::str tryParse_MbR9(/*1:1*/ fu::vec_range<char> str)
{
    /*MOV*/ fu::str errout {};
    fu::str _0 {};
    return (_0 = parse_MbR9(fu::str(str), errout)) ? static_cast<fu::str&&>(_0) : static_cast<fu::str&&>(errout);
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq, N_COWRestrict

========

        fn Zero(src) = src.len;
        fn Todo(src) = src.NOT_DEFINED();


        fn main() {
            let Solo            = fn Zero;

            lax fn Solo_muteRest(lax src) {}
            shadow let Zero     = fn Solo_muteRest;
            shadow let Todo     = fn Solo_muteRest;

            lax fn Noop(src)    = Zero(src);
            shadow let Zero     = fn Noop;

            let Todo_Renamed    = fn Todo;
            Todo_Renamed("Unused!");

            return Solo("Hello World!") - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Zero_9vppMwOQVTb
                                #define DEF_Zero_9vppMwOQVTb
inline static int Zero_9vpp(/*1:1*/ fu::view<char> src)
{
    return src.size();
}
                                #endif

int fu_MAIN()
{
    return Zero_9vpp("Hello World!"_view) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn Zero(src) = src.len;
        fn Todo(src) = src.NOT_DEFINED();

        pub import _0;
        fn main() {
            let Solo            = fn Zero;

            lax fn Solo_muteRest(lax src) {}
            shadow let Zero     = fn Solo_muteRest;
            shadow let Todo     = fn Solo_muteRest;

            lax fn Noop(src)    = Zero(src);
            shadow let Zero     = fn Noop;

            let Todo_Renamed    = fn Todo;
            Todo_Renamed("Unused!");

            return Solo("Hello World!") - 12;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Zero_9vppMwOQVTb
                                #define DEF_Zero_9vppMwOQVTb
inline int Zero_9vpp(/*1:1*/ fu::view<char> src)
{
    return src.size();
}
                                #endif

int fu_MAIN()
{
    return Zero_9vpp("Hello World!"_view) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        nocopy struct EventLoop { loop_fd: int };

        fn ipv4_listen(else) {
            let err = wakeUp_whenReadable();
            if (err) (else(:err));
        }

        fn EventLoop(loop_fd: int, loop_start!) {
            mut err = 0;
            implicit mut event_loop = {                         // GNUStmtExpr
                if (loop_fd < 0) return err = loop_fd;          // Goto
                EventLoop(loop_fd)
            };

            return loop_start();
        }

        fn wakeUp_whenReadable(implicit event_loop: EventLoop) {
            return event_loop.loop_fd;
        }

        fn main() {
            EventLoop(loop_fd: 1, loop_start: || {
                ipv4_listen(): |err| return err - 1;
                return 10;
            });
            return 20;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>

struct EventLoop_94lA;

                                #ifndef DEF_EventLoop_94lAVixiNQk
                                #define DEF_EventLoop_94lAVixiNQk
struct EventLoop_94lA
{
                                // shape_hash:    5c01ca6c587eed2f
                                // non_triv_mask: 0200000000000000
    int loop_fd;
    EventLoop_94lA(const EventLoop_94lA&) = delete;
    EventLoop_94lA(EventLoop_94lA&&) = default;
    EventLoop_94lA& operator=(const EventLoop_94lA&) = delete;
    EventLoop_94lA& operator=(EventLoop_94lA&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || loop_fd
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int wakeUp_whenReadable_MbR9(/*1:1*/ const EventLoop_94lA& event_loop)
{
    return event_loop.loop_fd;
}

int fu_MAIN()
{

    { {
        const int loop_fd = 1;
        int err = 0;
        EventLoop_94lA event_loop = ((loop_fd < 0) ? (__extension__ (
        {
            err = loop_fd;
            goto BL_1;
            (void)0;
        }), fu::unreachable) : EventLoop_94lA { loop_fd });

        {
            const int /*event_loop*/ err_1 = wakeUp_whenReadable_MbR9(event_loop);
            if (err_1)
                return err_1 - 1;

        };
        return 10;
      } BL_1:;
    };
    return 20;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct EventLoop { loop_fd: string };

        fn ipv4_listen(else) {
            let err = wakeUp_whenReadable();
            if (err) (else(:err));
        }

        fn EventLoop(loop_fd: string, loop_start!) {
            mut err = "none";
            implicit mut event_loop = {                         // GNUStmtExpr
                if !(loop_fd.len & 1) return err = loop_fd;     // Goto
                EventLoop(loop_fd)
            };

            return loop_start();
        }

        fn wakeUp_whenReadable(implicit event_loop: EventLoop) {
            return event_loop.loop_fd;
        }

        fn main() {
            EventLoop(loop_fd: "loop_fd", loop_start: || {
                ipv4_listen(): |err| return err.len - 7;
                return 10;
            });
            return 20;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct EventLoop_Y6J9;

                                #ifndef DEF_EventLoop_Y6J9WlX1QX5
                                #define DEF_EventLoop_Y6J9WlX1QX5
struct EventLoop_Y6J9
{
                                // shape_hash:    c5539118e92da754
                                // non_triv_mask: 0000800100000000
    fu::str loop_fd;
    EventLoop_Y6J9(const EventLoop_Y6J9&) = delete;
    EventLoop_Y6J9(EventLoop_Y6J9&&) = default;
    EventLoop_Y6J9& operator=(const EventLoop_Y6J9&) = delete;
    EventLoop_Y6J9& operator=(EventLoop_Y6J9&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || loop_fd
        ;
    }
};
                                #endif

                                #ifndef STR_RMqhhC9YcRb
                                #define STR_RMqhhC9YcRb
static const fu::str str_RMqhhC9YcRb fu_INIT_PRIORITY(1001) { "loop_fd"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> wakeUp_whenReadable_kGbb(/*1:1*/ const EventLoop_Y6J9& event_loop)
{
    return event_loop.loop_fd;
}

int fu_MAIN()
{

    { {
        fu::vec_range<char> /*static*/ loop_fd = str_RMqhhC9YcRb;
        fu::str err = fu::str("none"_fu);
        EventLoop_Y6J9 event_loop = (!(loop_fd.size() & 1) ? (__extension__ (
        {
            err = loop_fd;
            goto BL_1;
            (void)0;
        }), fu::unreachable) : EventLoop_Y6J9 { fu::str(loop_fd) });

        {
            fu::view<char> /*event_loop*/ err_1 = wakeUp_whenReadable_kGbb(event_loop);
            if (err_1)
                return err_1.size() - 7;

        };
        return 10;
      } BL_1:;
    };
    return 20;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        nocopy struct EventLoop { loop_fd: string };

        fn ipv4_listen(else) {
            let err = wakeUp_whenReadable();
            if (err) (else(:err));
        }

        fn EventLoop(loop_fd: string, loop_start!) {
            mut err = "none";
            implicit mut event_loop = {                         // GNUStmtExpr
                if !(loop_fd.len & 1) return err = loop_fd;     // Goto
                EventLoop(loop_fd)
            };

            return loop_start();
        }

        fn wakeUp_whenReadable(implicit event_loop: EventLoop) {
            return event_loop.loop_fd;
        }

        fn main() {
            EventLoop(loop_fd: "loop_fd", loop_start: || {
                ipv4_listen(): |err| return err.len - 7;
                return 10;
            });
            return 20;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/init_priority.h>

struct EventLoop_Y6J9;

                                #ifndef DEF_EventLoop_Y6J9WlX1QX5
                                #define DEF_EventLoop_Y6J9WlX1QX5
struct EventLoop_Y6J9
{
                                // shape_hash:    c5539118e92da754
                                // non_triv_mask: 0000800100000000
    fu::str loop_fd;
    EventLoop_Y6J9(const EventLoop_Y6J9&) = delete;
    EventLoop_Y6J9(EventLoop_Y6J9&&) = default;
    EventLoop_Y6J9& operator=(const EventLoop_Y6J9&) = delete;
    EventLoop_Y6J9& operator=(EventLoop_Y6J9&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || loop_fd
        ;
    }
};
                                #endif

                                #ifndef STR_RMqhhC9YcRb
                                #define STR_RMqhhC9YcRb
static const fu::str str_RMqhhC9YcRb fu_INIT_PRIORITY(1001) { "loop_fd"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> wakeUp_whenReadable_kGbb(/*1:1*/ const EventLoop_Y6J9& event_loop)
{
    return event_loop.loop_fd;
}

int fu_MAIN()
{

    { {
        const fu::str& /*static*/ loop_fd = str_RMqhhC9YcRb;
        fu::str err = fu::str("none"_fu);
        EventLoop_Y6J9 event_loop = (!(loop_fd.size() & 1) ? (__extension__ (
        {
            err = loop_fd;
            goto BL_1;
            (void)0;
        }), fu::unreachable) : EventLoop_Y6J9 { fu::str(loop_fd) });

        {
            fu::view<char> /*event_loop*/ err_1 = wakeUp_whenReadable_kGbb(event_loop);
            if (err_1)
                return err_1.size() - 7;

        };
        return 10;
      } BL_1:;
    };
    return 20;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Child { pid: int };
        fn call(do) = (do());

        noinline fn test(ref pid: int) {
            fn spawn(else) {
                let err = pid + 5;
                if (err) (else(:err));
                return pid;
            }

            fn fatal(err: int) return :test err;                // GNUStmtExpr
            call(do: || pid = spawn(else: |err| fatal(err * 10)));
            return pid;
        }

        fn main() {
            mut pid = 5;
            return test(pid) - 100;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ int& pid)
{
    int BL_1_v;
    pid = (__extension__ (
    {
        const int err = (pid + 5);
        BL_1_v = ((err ? (__extension__ (
        {
            const int err_1 = (err * 10);
            return err_1;
            (void)0;
        }), fu::unreachable) : pid));
        (void)0;
    }), BL_1_v);
    return pid;
}

int fu_MAIN()
{
    int pid = 5;
    return test_MbR9(pid) - 100;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Child { pid: string };
        fn call(do) = (do());

        fn append_if_odd(pid: string, other: string)
            pid.len & 1 ? pid ~ other : pid;

        noinline fn test(ref pid: string) {
            fn spawn(else) {
                let err = append_if_odd(pid, "5555555555");
                if (err) (else(:err));
                return pid;
            }

            fn fatal(err: string) return :test err;                // GNUStmtExpr
            call(do: || pid = spawn(else: |err| fatal(err ~ "101010101010")));
            return pid;
        }

        fn main() {
            mut pid = "xxxyyyzzz";
            return test(pid) == "xxxyyyzzz5555555555101010101010" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str append_if_odd_MbR9(/*3:3*/ fu::vec_range<char> pid, /*3:3*/ fu::view<char> other)
{
    if (pid.size() & 1)
        return pid + other;
    else
        return fu::str(pid);

}

static fu::str test_MbR9(/*1:1*/ fu::vec_range_mut<char> pid)
{
    fu::vec_range<char> BL_1_v {};
    pid = (__extension__ (
    {
        fu::str err = append_if_odd_MbR9(pid, "5555555555"_view);
        BL_1_v.ptr_reassign((err ? (__extension__ (
        {
            /*MOV*/ fu::str err_1 = (err + "101010101010"_view);
            return /*NRVO*/ err_1;
            (void)0;
        }), fu::unreachable) : pid));
        (void)0;
    }), BL_1_v);
    return fu::str(pid);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str pid = fu::str("xxxyyyzzz"_fu);
    if (test_MbR9(pid) == "xxxyyyzzz5555555555101010101010"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Hello { stuff: i32 };

        fn hello(ref h) h.stuff;    
        fn get(h) h.hello;
        fn incr(ref h) h.hello++;

        fn main() {
            mut h: Hello;
            let a = get(h);
            let b = incr(h);
            return a == 0 && b == 0 && h.stuff == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_wzRs;

                                #ifndef DEF_Hello_wzRszIjWN3c
                                #define DEF_Hello_wzRszIjWN3c
struct Hello_wzRs
{
                                // shape_hash:    efe9cfcfec08c7c8
                                // non_triv_mask: 0000000000000000
    int stuff;
    explicit operator bool() const noexcept
    {
        return false
            || stuff
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_Indm1m1NPU3
                                #define DEF_hello_Indm1m1NPU3
inline static int hello_Indm(/*1:1*/ const Hello_wzRs& h)
{
    return h.stuff;
}
                                #endif

                                #ifndef DEF_get_Eis6woazA42
                                #define DEF_get_Eis6woazA42
inline static int get_Eis6(/*1:1*/ const Hello_wzRs& h)
{
    return hello_Indm(h);
}
                                #endif

                                #ifndef DEF_hello_xgMxcIrbVYa
                                #define DEF_hello_xgMxcIrbVYa
inline static int& hello_xgMx(/*1:1*/ Hello_wzRs& h)
{
    return h.stuff;
}
                                #endif

                                #ifndef DEF_incr_dV33t65BHMb
                                #define DEF_incr_dV33t65BHMb
inline static int incr_dV33(/*1:1*/ Hello_wzRs& h)
{
    return hello_xgMx(h)++;
}
                                #endif

int fu_MAIN()
{
    Hello_wzRs h {};
    const int /*h*/ a = get_Eis6(h);
    const int b = incr_dV33(h);
    if ((a == 0) && (b == 0) && (h.stuff == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Hello { stuff: i32 };

        fn hello(ref .stuff) stuff; 
        fn get(h) h.hello;
        fn incr(ref h) h.hello++;

        fn main() {
            mut h: Hello;
            let a = get(h);
            let b = incr(h);
            return a == 0 && b == 0 && h.stuff == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_wzRs;

                                #ifndef DEF_Hello_wzRszIjWN3c
                                #define DEF_Hello_wzRszIjWN3c
struct Hello_wzRs
{
                                // shape_hash:    efe9cfcfec08c7c8
                                // non_triv_mask: 0000000000000000
    int stuff;
    explicit operator bool() const noexcept
    {
        return false
            || stuff
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_0DCJaE9X1mk
                                #define DEF_hello_0DCJaE9X1mk
inline static int hello_0DCJ(/*1:1*/ const int stuff)
{
    return stuff;
}
                                #endif

                                #ifndef DEF_get_yN3mPAQXA62
                                #define DEF_get_yN3mPAQXA62
inline static int get_yN3m(/*1:1*/ const Hello_wzRs& h)
{
    return hello_0DCJ(h.stuff);
}
                                #endif

                                #ifndef DEF_hello_g7f12vRPyS6
                                #define DEF_hello_g7f12vRPyS6
inline static int& hello_g7f1(/*1:1*/ int& stuff)
{
    return stuff;
}
                                #endif

                                #ifndef DEF_incr_O5o1QLg9VQj
                                #define DEF_incr_O5o1QLg9VQj
inline static int incr_O5o1(/*1:1*/ Hello_wzRs& h)
{
    return hello_g7f1(h.stuff)++;
}
                                #endif

int fu_MAIN()
{
    Hello_wzRs h {};
    const int /*h*/ a = get_yN3m(h);
    const int b = incr_O5o1(h);
    if ((a == 0) && (b == 0) && (h.stuff == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        primitive DataPos: int

        struct DataEntry(type K, type V) {
            key: K
            value?: V
            collision: DataPos
        }

        pub struct Map(type K, type V) {
            index_entries: DataPos[]
            data_entries: DataEntry(:K, :V)[]
        }

        inline fn [](ref .data_entries, data_pos)
            data_entries[data_pos.int - 1]

        fn ref !<K>(mut ref map: Map(:K, _), key: K, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (mut i = 0; i < map.index_entries.len; i++) {
                        mut data_pos = map.index_entries[i]
                        while (data_pos) {
                            ref data_entry = map[:data_pos]
                            if (data_entry.key == key)
                                break :SEARCH data_entry

                            data_pos = data_entry.collision
                        }
                    }

                    map.data_entries ~= []
                    let data_pos = DataPos(map.data_entries.len)
                    map.index_entries ~= data_pos
                    break :SEARCH map[:data_pos]
                }
            }

            return visit(:data_entry.value)
        }

        pub inline fn set !<K, V>(ref map: Map(:K, :V), key: K, mut value: V)
            map.ref(:key, visit: |shadow ref value| value)  // GNUStmtExpr
                = value                                     // Goto

        fn len(map: Map(_, _)) {
            mut count = 0
            for (mut i = 0; i < map.index_entries.len; i++) {
                mut data_pos = map.index_entries[i]
                while (data_pos) {
                    count++
                    data_pos = map[:data_pos].collision
                }
            }

            return count
        }

        fn main() {
            mut actual: Map(int, int)
            let len0 = actual.len
            actual.set(0, 0)
            let len1 = actual.len
            let x = actual.data_entries[0].value
            return len0 == 0 && len1 == 1 && x == 0 ? 0 : 1
        }

---- <fail> ----
[2m[0m_0[2m.fu 32:38+2[0m:

[2m      |                     }[0m
[2m      | [0m
[2m   32 | [0m                    map.data_entries [31;1m~=[0m []
[2m      |                     let data_pos = DataPos(map.data_entries.len)[0m
[2m      |                     map.index_entries ~= data_pos[0m

	Ambiguous call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mDataEntry[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	[35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");


        Solving [35;3mfn[0m [94;1mref[0m([94;1mMap[0m, [35;3mi32[0m, [35;3m@1h0[0m) at [2m18:12+3[0m
                [35;3mfn[0m [94;1mset[0m([94;1mMap[0m, [35;3mi32[0m, [35;3mi32[0m) at [2m42:23+3[0m
                [35;3mfn[0m [94;1mmain[0m at [2m59:12+4[0m

========

        primitive DataPos: int

        struct DataEntry(type K, type V) {
            key: K
            value?: V
            collision: DataPos
        }

        pub struct Map(type K, type V) {
            index_entries: DataPos[]
            data_entries: DataEntry(:K, :V)[]
        }

        inline fn [](ref .data_entries, data_pos)
            data_entries[data_pos.int - 1]

        fn ref !<K>(mut ref map: Map(:K, _), key: K, visit) {
            mut ref data_entry = {
                :SEARCH {
                    for (mut i = 0; i < map.index_entries.len; i++) {
                        mut data_pos = map.index_entries[i]
                        while (data_pos) {
                            ref data_entry = map[:data_pos]
                            if (data_entry.key == key)
                                break :SEARCH data_entry

                            data_pos = data_entry.collision
                        }
                    }

                    map.data_entries ~= typeof(map.data_entries[0])()
                    let data_pos = DataPos(map.data_entries.len)
                    map.index_entries ~= data_pos
                    break :SEARCH map[:data_pos]
                }
            }

            return visit(:data_entry.value)
        }

        pub inline fn set !<K, V>(ref map: Map(:K, :V), key: K, mut value: V)
            map.ref(:key, visit: |shadow ref value| value)  // GNUStmtExpr
                = value                                     // Goto

        fn len(map: Map(_, _)) {
            mut count = 0
            for (mut i = 0; i < map.index_entries.len; i++) {
                mut data_pos = map.index_entries[i]
                while (data_pos) {
                    count++
                    data_pos = map[:data_pos].collision
                }
            }

            return count
        }

        fn main() {
            mut actual: Map(int, int)
            let len0 = actual.len
            actual.set(0, 0)
            let len1 = actual.len
            let x = actual.data_entries[0].value
            return len0 == 0 && len1 == 1 && x == 0 ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Map_OGDx;
typedef int DataPos_EFQL;
struct DataEntry_TKoV;

                                #ifndef DEF_DataPos_EFQL
                                #define DEF_DataPos_EFQL
                                #endif

                                #ifndef DEF_DataEntry_TKoVjmRHyKg
                                #define DEF_DataEntry_TKoVjmRHyKg
struct DataEntry_TKoV
{
                                // shape_hash:    329bbcebf2ddb13c
                                // non_triv_mask: 0000000000000000
    int key;
    int value;
    DataPos_EFQL collision;
    explicit operator bool() const noexcept
    {
        return false
            || key
            || value
            || collision
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_OGDxt1Jrur8
                                #define DEF_Map_OGDxt1Jrur8
struct Map_OGDx
{
                                // shape_hash:    2692fc7e15678526
                                // non_triv_mask: 00002000c0000000
    fu::vec<DataPos_EFQL> index_entries;
    fu::vec<DataEntry_TKoV> data_entries;
    explicit operator bool() const noexcept
    {
        return false
            || index_entries
            || data_entries
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_len_k2cj2ci5zif
                                #define DEF_len_k2cj2ci5zif
inline static int len_k2cj(/*1:1*/ const Map_OGDx& map)
{
    int count = 0;
    for (int i = 0; i < map.index_entries.size(); i++)
    {
        DataPos_EFQL data_pos = map.index_entries[i];
        while (data_pos)
        {
            count++;
            fu::view<DataEntry_TKoV> data_entries {};
            DataPos_EFQL data_pos_1;
            data_pos = (data_entries.ptr_reassign(map.data_entries), data_pos_1 = data_pos, data_entries[(int(data_pos_1) - 1)]).collision;
        };
    };
    return count;
}
                                #endif

                                #ifndef DEF_visit_g7f12vRPyS6
                                #define DEF_visit_g7f12vRPyS6
inline static int& visit_g7f1(/*1:1*/ int& value)
{
    return value;
}
                                #endif

                                #ifndef DEF_ref_bxoYRkAwQU9
                                #define DEF_ref_bxoYRkAwQU9
inline static int& ref_bxoY(/*7:7*/ Map_OGDx& map, const int key)
{
    fu::view_mut<DataEntry_TKoV> data_entries {};
    DataEntry_TKoV* data_entry_1;
    DataEntry_TKoV* BL_1_v;
    DataEntry_TKoV& /*data_entries|data_entry|static*/ data_entry = (__extension__ (
    { {
        for (int i = 0; i < map.index_entries.size(); i++)
        {
            DataPos_EFQL data_pos = map.index_entries[i];
            while (data_pos)
            {
                fu::view_mut<DataEntry_TKoV> data_entries_1 {};
                DataPos_EFQL data_pos_1;
                data_entry_1 = &((data_pos_1 = data_pos, data_entries_1.ptr_reassign(map.data_entries), data_entries_1.mutref((int(data_pos_1) - 1))));
                if ((*data_entry_1).key == key)
                {
                    { BL_1_v = &((*data_entry_1)); goto BL_1; };
                }
                else
                    data_pos = (*data_entry_1).collision;

            };
        };
        map.data_entries += DataEntry_TKoV{};
        const DataPos_EFQL data_pos = DataPos_EFQL(map.data_entries.size());
        map.index_entries += data_pos;
        data_entries.ptr_reassign(map.data_entries);
        BL_1_v = &(data_entries.mutref((int(data_pos) - 1)));
      } BL_1:;
        (void)0;
    }), *BL_1_v);
    return visit_g7f1(data_entry.value);
}
                                #endif

int fu_MAIN()
{
    Map_OGDx actual {};
    const int len0 = len_k2cj(actual);

    {
        const int key = 0;
        const int value = 0;
        ref_bxoY(actual, key) = value;
    };
    const int len1 = len_k2cj(actual);
    const int /*actual|static*/ x = actual.data_entries[0].value;
    if ((len0 == 0) && (len1 == 1) && (x == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Type { vfacts?: VFacts };
        flags VFacts { RightAligned };

        fn main() Type().vfacts.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

struct Type_7ENx;
typedef fu::u8 VFacts_dxw6;

                                #ifndef DEF_VFacts_dxw6
                                #define DEF_VFacts_dxw6
inline constexpr VFacts_dxw6 VFacts_dxw6_RightAligned = VFacts_dxw6(1u);

inline constexpr VFacts_dxw6 MASK_VFacts_dxw6
    = VFacts_dxw6_RightAligned;
                                #endif

                                #ifndef DEF_Type_7ENxP2A6f42
                                #define DEF_Type_7ENxP2A6f42
struct Type_7ENx
{
                                // shape_hash:    363f7d9cd0ca7181
                                // non_triv_mask: 0000000000000000
    VFacts_dxw6 vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(Type_7ENx{}.vfacts);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { vfacts?: VFacts };
        flags VFacts { RightAligned };
        pub import _0;
        fn main() Type().vfacts.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

struct Type_7ENx;
typedef fu::u8 VFacts_dxw6;

                                #ifndef DEF_VFacts_dxw6
                                #define DEF_VFacts_dxw6
inline constexpr VFacts_dxw6 VFacts_dxw6_RightAligned = VFacts_dxw6(1u);

inline constexpr VFacts_dxw6 MASK_VFacts_dxw6
    = VFacts_dxw6_RightAligned;
                                #endif

                                #ifndef DEF_Type_7ENxP2A6f42
                                #define DEF_Type_7ENxP2A6f42
struct Type_7ENx
{
                                // shape_hash:    363f7d9cd0ca7181
                                // non_triv_mask: 0000000000000000
    VFacts_dxw6 vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(Type_7ENx{}.vfacts);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { canon: int; items: string };

        fn evalTypeAnnot(node: Type) {
            let exprType = node ? node || throw("always true") : Type();
            return exprType.canon;
        }

        fn main() evalTypeAnnot(Type());

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>

struct Type_eZ6M;

                                #ifndef DEF_Type_eZ6MnCcpeh6
                                #define DEF_Type_eZ6MnCcpeh6
struct Type_eZ6M
{
                                // shape_hash:    c9e92315c318f194
                                // non_triv_mask: 0000800100000000
    int canon;
    fu::str items;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int evalTypeAnnot_MbR9(/*1:1*/ const Type_eZ6M& node)
{
    Type_eZ6M exprType = (node ? Type_eZ6M { (node ? node : fu::fail(fu::str("always true"_fu))).canon, {/*unused non-zst*/} } : Type_eZ6M{});
    return exprType.canon;
}

int fu_MAIN()
{
    return evalTypeAnnot_MbR9(Type_eZ6M{});
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { items: Node[]; type: Type };
        struct Type { canon: string; items: Type[] };

        noinline fn evalTypeParam(id: int, implicit ref _typeParams: Type[]) {
            return id >= 0 && id < _typeParams.len
                && _typeParams[id]
                || throw("always true");
        }

        noinline fn evalTypeAnnot(node) {
            let exprType = node.items   ? evalTypeParam(node.items.len)
                                        : [].type;
            return exprType.canon.len;
        }

        fn main() {
            implicit mut _typeParams: Type[];
            return evalTypeAnnot(Type());
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>

struct Type_KnBH;

                                #ifndef DEF_Type_KnBHAhqFK11
                                #define DEF_Type_KnBHAhqFK11
struct Type_KnBH
{
                                // shape_hash:    c1738d29d851afb0
                                // non_triv_mask: 0000800100004000
    fu::str canon;
    fu::vec<Type_KnBH> items;
    Type_KnBH(const Type_KnBH&) = default;
    Type_KnBH(Type_KnBH&&) = default;
    Type_KnBH& operator=(Type_KnBH&&) = default;
    Type_KnBH& operator=(const Type_KnBH& selfrec) { return *this = Type_KnBH(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Type_KnBH& evalTypeParam_MbR9(const int id, /*3:3*/ fu::view<Type_KnBH> _typeParams)
{
    const Type_KnBH* _0;
    return *(_0 = &((((id >= 0) && (id < _typeParams.size())) ? _typeParams[id] : (*(Type_KnBH*)fu::NIL)))) ? *_0 : fu::fail(fu::str("always true"_fu));
}

                                #ifndef DEF_evalTypeAnnot_0N63hkTjzb3
                                #define DEF_evalTypeAnnot_0N63hkTjzb3
inline static int evalTypeAnnot_0N63(/*3:3*/ const Type_KnBH& node, /*3:3*/ fu::view<Type_KnBH> _typeParams)
{
    Type_KnBH exprType = (node.items ? Type_KnBH(evalTypeParam_MbR9(node.items.size(), _typeParams)) : Type_KnBH{});
    return exprType.canon.size();
}
                                #endif

int fu_MAIN()
{
    fu::vec<Type_KnBH> _typeParams {};
    return evalTypeAnnot_0N63(Type_KnBH{}, _typeParams);
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn convolutedHelloWorld(ref _scope: int) {
            mut TRACE_out = string();
            fn fail(reason: string) {
                TRACE_out ~= reason;
                throw(", World!");
            }

            fn solveNode(targets = [ _scope || fail("Hello") ]) {
                _scope--;
                if (targets) solveNode();
            }

            try         solveNode();
            catch (e)   return TRACE_out ~ e;
            return [];
        }

        fn main() {
            mut _scope = 1;
            return convolutedHelloWorld(:_scope) == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

static void solveNode_MbR9(fu::view<int>, int&, fu::vec_range_mut<char>);

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never fail_MbR9(/*3:3*/ fu::view<char> reason, /*2:2*/ fu::vec_range_mut<char> TRACE_out)
{
    TRACE_out += reason;
    fu::fail(fu::str(", World!"_fu));
}

static void solveNode_MbR9(/*7:7*/ fu::view<int> targets, /*6:2*/ int& _scope, /*7:5*/ fu::vec_range_mut<char> TRACE_out)
{
    _scope--;
    if (targets)
    {
        fu::vec<int> _0 {};
        (_0 = fu::vec<int> {{ (_scope ? _scope : fail_MbR9("Hello"_view, TRACE_out)) }}, solveNode_MbR9(static_cast<fu::vec<int>&&>(_0), _scope, TRACE_out));
    };
}

static fu::str convolutedHelloWorld_MbR9(/*1:1*/ int& _scope)
{
    fu::str TRACE_out {};

    try
    {
    {
        fu::vec<int> _0 {};
        (_0 = fu::vec<int> {{ (_scope ? _scope : fail_MbR9("Hello"_view, TRACE_out)) }}, solveNode_MbR9(static_cast<fu::vec<int>&&>(_0), _scope, TRACE_out));
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return TRACE_out + e;
    }
;
    return fu::str{};
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    int _scope = 1;
    if (convolutedHelloWorld_MbR9(_scope) == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_UnusedCall, N_UnusedArrlit, N_BckMustSeq

========

        fn incr(ref x: i32) { x++; }
        fn badRetvalAnnot(ref x: i32)   
            : bool                      
                { incr(x) }

        fn main() {
            mut x = -1;
            badRetvalAnnot(x);
            return x;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:19+4[0m:

[2m      |         fn badRetvalAnnot(ref x: i32)   [0m
[2m      |             : bool                      [0m
[2m    5 | [0m                { [31;1mincr[0m(x) }
[2m      | [0m
[2m      |         fn main() {[0m

	[35;3mfn[0m [94;1mbadRetvalAnnot[0m: return type does not match annotation: expects [35;3mbool[0m, got [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mbadRetvalAnnot[0m([35;3mi32[0m) at [2m3:12+14[0m

========

        fn incr(ref x: i32) { x++; }
        fn badRetvalAnnot(ref x: i32)   
                { incr(x) }

        fn main() {
            mut x = -1;
            badRetvalAnnot(x);
            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void incr_MbR9(/*1:1*/ int& x)
{
    x++;
}

static void badRetvalAnnot_MbR9(/*1:1*/ int& x)
{
    incr_MbR9(x);
}

int fu_MAIN()
{
    int x = -1;
    badRetvalAnnot_MbR9(x);
    return x;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Shape { hash: int };

        fn main() {
            mut shape = [];
            shape.hash = 3;
            return -shape.hash + 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:17+5[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mshape[0m = [];
[2m      |             shape.hash = 3;[0m
[2m      |             return -shape.hash + 3;[0m

	[35;3mmut[0m [94;1mshape[0m needs a tighter type annotation, inferred type is [35;3m[][0m. Make it [35;3mlax[0m if this is intentional.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct Shape { hash: int };

        fn main() {
            mut shape: Shape = [];
            shape.hash = 3;
            return -shape.hash + 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Shape_JATz;

                                #ifndef DEF_Shape_JATzS7NM7Yg
                                #define DEF_Shape_JATzS7NM7Yg
struct Shape_JATz
{
                                // shape_hash:    96cf997401a48a5c
                                // non_triv_mask: 0000000000000000
    int hash;
    explicit operator bool() const noexcept
    {
        return false
            || hash
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Shape_JATz shape {};
    shape.hash = 3;
    return -shape.hash + 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Shape { hash: int };

        fn test(mut shape) {
            shape.hash = 3;
            return shape;
        }

        fn main() {
            let shape = test([]);
            return -shape.hash + 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:21+5[0m:

[2m      |         struct Shape { hash: int };[0m
[2m      | [0m
[2m    4 | [0m        fn test(mut [31;1mshape[0m) {
[2m      |             shape.hash = 3;[0m
[2m      |             return shape;[0m

	[35;3mmut arg[0m [94;1mshape[0m needs a tighter type annotation, inferred type is [35;3m[][0m. Make it [35;3mlax[0m if this is intentional.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m9:12+4[0m

========

        struct Shape { hash: int };

        fn test(mut shape: Shape) {
            shape.hash = 3;
            return shape;
        }

        fn main() {
            let shape = test([]);
            return -shape.hash + 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Shape_JATz;

                                #ifndef DEF_Shape_JATzS7NM7Yg
                                #define DEF_Shape_JATzS7NM7Yg
struct Shape_JATz
{
                                // shape_hash:    96cf997401a48a5c
                                // non_triv_mask: 0000000000000000
    int hash;
    explicit operator bool() const noexcept
    {
        return false
            || hash
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Shape_JATz test_MbR9(Shape_JATz&& shape)
{
    shape.hash = 3;
    return shape;
}

int fu_MAIN()
{
    const Shape_JATz shape = test_MbR9(Shape_JATz{});
    return -shape.hash + 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Shape { hash: int };
        struct NotAShape { other: int };

        fn test(ref a: <T>, mut b: T) {

            b.other += 3; 
            a = b;
        }

        fn main() {
            mut shape: Shape;
            test(shape, []);
            return -shape.hash + 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:15+5[0m:

[2m      |         fn test(ref a: <T>, mut b: T) {[0m
[2m      | [0m
[2m    7 | [0m            b.[31;1mother[0m += 3; 
[2m      |             a = b;[0m
[2m      |         }[0m

	Bad call to [94;1mother[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mShape[0m): 

	[35;3mfield[0m [94;1mNotAShape[0m:[94;1mother[0m at [2m3:28+5[0m:
[2m    3 | [0m        struct NotAShape { [31;1mother[0m: int };

	    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mNotAShape[0m, got [35;3mstruct[0m [94;1mShape[0m

        Solving [35;3mfn[0m [94;1mtest[0m([94;1mShape[0m, [94;1mShape[0m) at [2m5:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m11:12+4[0m

========

        struct Shape { hash: int };
        struct NotAShape { other: int };

        fn test(ref a: <T>, mut b: T) {

            b.hash  += 3; 
            a = b;
        }

        fn main() {
            mut shape: Shape;
            test(shape, []);
            return -shape.hash + 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Shape_JATz;

                                #ifndef DEF_Shape_JATzS7NM7Yg
                                #define DEF_Shape_JATzS7NM7Yg
struct Shape_JATz
{
                                // shape_hash:    96cf997401a48a5c
                                // non_triv_mask: 0000000000000000
    int hash;
    explicit operator bool() const noexcept
    {
        return false
            || hash
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_ywLwML1mMJ2
                                #define DEF_test_ywLwML1mMJ2
inline static void test_ywLw(/*3:3*/ Shape_JATz& a, Shape_JATz&& b)
{
    b.hash += 3;
    a = b;
}
                                #endif

int fu_MAIN()
{
    Shape_JATz shape {};
    test_ywLw(shape, Shape_JATz{});
    return -shape.hash + 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Thing { using i: int };

        fn vfactsAssignableComplainsAboutAlwaysFalse(ref things: Thing[], into?: Thing) {
            fn DISCARD(thing: Thing)    = thing && [];
            fn THROW_IF_ZERO(i)         = Thing(i || throw("zero"));

            let x: Thing = into || {
                let x: Thing = DISCARD(THROW_IF_ZERO(things.len));
                x                                               // PointlessLocal
            };

            things[x.i].i++;
        }

        fn main() {
            mut things = [ Thing() ];
            vfactsAssignableComplainsAboutAlwaysFalse(things);
            return things.len == 1 && things[0].i == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct Thing_tBC1;

                                #ifndef DEF_Thing_tBC1d7hSROd
                                #define DEF_Thing_tBC1d7hSROd
struct Thing_tBC1
{
                                // shape_hash:    3d8686b643cb9f0a
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_THROW_IF_ZERO_nFWM5fuyhFl
                                #define DEF_THROW_IF_ZERO_nFWM5fuyhFl
inline static Thing_tBC1 THROW_IF_ZERO_nFWM(const int i)
{
    return Thing_tBC1 { (i ? i : fu::fail(fu::str("zero"_fu))) };
}
                                #endif

static void vfactsAssignableComplainsAboutAlwaysFalse_MbR9(/*3:3*/ fu::view_mut<Thing_tBC1> things, /*3:3*/ const Thing_tBC1& into)
{
    Thing_tBC1 x_1;
    const Thing_tBC1& /*x|into*/ x = (into ? into : (x_1 = (THROW_IF_ZERO_nFWM(things.size()), Thing_tBC1{}), x_1));
    things.mutref(x.i).i++;
}

int fu_MAIN()
{
    fu::vec<Thing_tBC1> things = fu::vec<Thing_tBC1> {{ Thing_tBC1{} }};
    vfactsAssignableComplainsAboutAlwaysFalse_MbR9(things, Thing_tBC1{});
    if ((things.size() == 1) && (things[0].i == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall, N_UnusedIfElse

========

        struct AB       { a: int; b: int }
        struct IdxLocP  { _idx: int; _loc: int; _p: AB }

        fn trackWritesAssertPathsValid(using ref _ps: IdxLocP, pa: AB) {
            fn unary(p: AB) { _p = p; _loc = _idx }
            fn nullary() { unary(_p) }
            return pa ? { nullary(); _loc } : { unary(pa); _idx };
        }

        fn main() {
            mut _ps: IdxLocP;
            return trackWritesAssertPathsValid(_ps, []);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct IdxLocP_yLpN;
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_IdxLocP_yLpNEUgNWj5
                                #define DEF_IdxLocP_yLpNEUgNWj5
struct IdxLocP_yLpN
{
                                // shape_hash:    0631b710d455cfd3
                                // non_triv_mask: 0000000000000000
    int _idx;
    int _loc;
    AB_kiW0 _p;
    explicit operator bool() const noexcept
    {
        return false
            || _idx
            || _loc
            || _p
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int unary_GL0m(/*3:3*/ const AB_kiW0& p, /*3:3*/ IdxLocP_yLpN& _ps)
{
    _ps._p = p;
    return (_ps._loc = _ps._idx);
}

static int nullary_GL0m(/*1:1*/ IdxLocP_yLpN& _ps)
{
    return unary_GL0m(_ps._p, _ps);
}

static int trackWritesAssertPathsValid_kGbb(/*3:3*/ IdxLocP_yLpN& _ps, /*3:3*/ const AB_kiW0& pa)
{
    if (pa)
    {
        nullary_GL0m(_ps);
        return _ps._loc;
    }
    else
    {
        unary_GL0m(pa, _ps);
        return _ps._idx;
    };
}

int fu_MAIN()
{
    IdxLocP_yLpN _ps {};
    return trackWritesAssertPathsValid_kGbb(_ps, AB_kiW0{});
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Overload { flags: u32; type: Type };
        struct Type { quals: int; lifetime: int[] };

        noinline fn bckWritesAssertPathsValid(ref overload: Overload) {
            noinline fn GET_mut() overload;
            noinline fn clearMutVal(ref o: Overload) {
                o.type = [];
                o.flags &= ~0x1;
            }

            shadow ref o = GET_mut();
            o.clearMutVal();
        }

        fn main() {
            mut overload = Overload(3, Type(12345, [ 1, 2, 3, 4, 5 ]));
            bckWritesAssertPathsValid(overload);
            return overload == Overload(2, Type()) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Overload_jZIZ;
struct Type_bS7X;

                                #ifndef DEF_Type_bS7XD6Q7EQe
                                #define DEF_Type_bS7XD6Q7EQe
struct Type_bS7X
{
                                // shape_hash:    398195e371c05fca
                                // non_triv_mask: 0008800000000000
    int quals;
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_jZIZfvzveZ3
                                #define DEF_Overload_jZIZfvzveZ3
struct Overload_jZIZ
{
                                // shape_hash:    1f2c7f121a2527e2
                                // non_triv_mask: 0008800000002000
    unsigned flags;
    Type_bS7X type;
    explicit operator bool() const noexcept
    {
        return false
            || flags
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Overload_jZIZ& GET_mut_MbR9(/*1:1*/ Overload_jZIZ& overload)
{
    return overload;
}

static void clearMutVal_MbR9(/*1:1*/ Overload_jZIZ& o)
{
    o.type = Type_bS7X{};
    o.flags &= ~0x1u;
}

static void bckWritesAssertPathsValid_MbR9(/*1:1*/ Overload_jZIZ& overload)
{
    Overload_jZIZ& /*overload*/ o = GET_mut_MbR9(overload);
    clearMutVal_MbR9(o);
}

                                #ifndef DEF_x3Cx3E_Rgh3ARpn2a3
                                #define DEF_x3Cx3E_Rgh3ARpn2a3
inline int x3Cx3E_Rgh3(const unsigned a, const unsigned b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_p7jTAJsiiIh
                                #define DEF_x3Cx3E_p7jTAJsiiIh
inline int x3Cx3E_p7jT(/*3:3*/ const Type_bS7X& a, /*3:3*/ const Type_bS7X& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.quals, b.quals)))
        return cmp;
    else if ((cmp = x3Cx3E_2Y4m(a.lifetime, b.lifetime)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_KNBcEA1baKk
                                #define DEF_x3Cx3E_KNBcEA1baKk
inline int x3Cx3E_KNBc(/*3:3*/ const Overload_jZIZ& a, /*3:3*/ const Overload_jZIZ& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_Rgh3(a.flags, b.flags)))
        return cmp;
    else if ((cmp = x3Cx3E_p7jT(a.type, b.type)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_OGzcyzycxXd
                                #define DEF_x3Dx3D_OGzcyzycxXd
inline bool operator==(/*3:3*/ const Overload_jZIZ& a, /*3:3*/ const Overload_jZIZ& b)
{
    return !x3Cx3E_KNBc(a, b);
}
                                #endif

int fu_MAIN()
{
    Overload_jZIZ overload = Overload_jZIZ { 3u, Type_bS7X { 12345, fu::vec<int> {{ 1, 2, 3, 4, 5 }} } };
    bckWritesAssertPathsValid_MbR9(overload);
    if (overload == Overload_jZIZ { 2u, Type_bS7X{} })
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Hello(type A, type B) { a: A; b: B };
        fn main() {
            mut h: Hello(, int);
            return h.a + h.b;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:26+1[0m:

[2m      |         struct Hello(type A, type B) { a: A; b: B };[0m
[2m      |         fn main() {[0m
[2m    4 | [0m            mut h: Hello([31;1m,[0m int);
[2m      |             return h.a + h.b;[0m
[2m      |         }[0m

	Unexpected `,`.

========

        struct Hello(type A, type B) { a: A; b: B };
        fn main() {
            mut h: Hello(int, int);
            return h.a + h.b;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_PZ6S;

                                #ifndef DEF_Hello_PZ6SNdi8yY1
                                #define DEF_Hello_PZ6SNdi8yY1
struct Hello_PZ6S
{
                                // shape_hash:    1559a19971fd5071
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Hello_PZ6S h {};
    return h.a + h.b;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hello(type A, type B) { a: A; b: B };
        fn main() {
            mut h: Hello(i

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:0+0[0m:

[2m      |             mut h: Hello(i[0m
[2m      | [0m

	Missing comma before [31;1m?[0m.

========

        struct Hello(type A, type B) { a: A; b: B };
        fn main() {
            mut h: Hello(int, int);
            return h.a + h.b;
        }


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_PZ6S;

                                #ifndef DEF_Hello_PZ6SNdi8yY1
                                #define DEF_Hello_PZ6SNdi8yY1
struct Hello_PZ6S
{
                                // shape_hash:    1559a19971fd5071
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Hello_PZ6S h {};
    return h.a + h.b;
}

#endif

int main() { return fu_MAIN(); }

========

        novec fn test(ref items: int[]) {
            fn qStackInfLoop(mut v) {                           // PointlessMustSeq
                v--;
                if      (v > 8) qStackInfLoop(v.u64);
                else if (v > 7) qStackInfLoop(v.i64);
                else if (v > 6) qStackInfLoop(v.u32);
                else if (v > 5) qStackInfLoop(v.i32);
                else if (v > 4) qStackInfLoop(v.u16);
                else if (v > 3) qStackInfLoop(v.i16);
                else if (v > 2) qStackInfLoop(v.u8);
                else if (v > 1) qStackInfLoop(v.i8);
                else {                  
                    let back = items;
                    for (mut i = 0; i < items.len; i++)
                        items[i] += back[back.len - 1 - i] + v.int;             
                }
            }

            items.len.qStackInfLoop();
        }

        fn main() {
            mut v = [ 1 ];
            v.test();
            return v.only - 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 2:9+5[0m:

[2m      | [0m
[2m    2 | [0m        [31;1mnovec[0m fn test(ref items: int[]) {
[2m      |             fn qStackInfLoop(mut v) {                           // PointlessMustSeq[0m
[2m      |                 v--;[0m

	[35;3mfn[0m [94;1mtest[0m is not novec, [35;3mmut ref arg[0m [94;1mitems[0m is [35;3mmut[0m [35;3mref[0m [35;3mi32[0m[35;3m[][0m:

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m20:23+13[0m:

[2m      |             }[0m
[2m      | [0m
[2m   20 | [0m            items.len.[31;1mqStackInfLoop[0m();
[2m      |         }[0m
[2m      | [0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m5:33+13[0m:

[2m      |             fn qStackInfLoop(mut v) {                           // PointlessMustSeq[0m
[2m      |                 v--;[0m
[2m    5 | [0m                if      (v > 8) [31;1mqStackInfLoop[0m(v.u64);
[2m      |                 else if (v > 7) qStackInfLoop(v.i64);[0m
[2m      |                 else if (v > 6) qStackInfLoop(v.u32);[0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m6:33+13[0m:

[2m      |                 v--;[0m
[2m      |                 if      (v > 8) qStackInfLoop(v.u64);[0m
[2m    6 | [0m                else if (v > 7) [31;1mqStackInfLoop[0m(v.i64);
[2m      |                 else if (v > 6) qStackInfLoop(v.u32);[0m
[2m      |                 else if (v > 5) qStackInfLoop(v.i32);[0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m7:33+13[0m:

[2m      |                 if      (v > 8) qStackInfLoop(v.u64);[0m
[2m      |                 else if (v > 7) qStackInfLoop(v.i64);[0m
[2m    7 | [0m                else if (v > 6) [31;1mqStackInfLoop[0m(v.u32);
[2m      |                 else if (v > 5) qStackInfLoop(v.i32);[0m
[2m      |                 else if (v > 4) qStackInfLoop(v.u16);[0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m9:33+13[0m:

[2m      |                 else if (v > 6) qStackInfLoop(v.u32);[0m
[2m      |                 else if (v > 5) qStackInfLoop(v.i32);[0m
[2m    9 | [0m                else if (v > 4) [31;1mqStackInfLoop[0m(v.u16);
[2m      |                 else if (v > 3) qStackInfLoop(v.i16);[0m
[2m      |                 else if (v > 2) qStackInfLoop(v.u8);[0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m10:33+13[0m:

[2m      |                 else if (v > 5) qStackInfLoop(v.i32);[0m
[2m      |                 else if (v > 4) qStackInfLoop(v.u16);[0m
[2m   10 | [0m                else if (v > 3) [31;1mqStackInfLoop[0m(v.i16);
[2m      |                 else if (v > 2) qStackInfLoop(v.u8);[0m
[2m      |                 else if (v > 1) qStackInfLoop(v.i8);[0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m11:33+13[0m:

[2m      |                 else if (v > 4) qStackInfLoop(v.u16);[0m
[2m      |                 else if (v > 3) qStackInfLoop(v.i16);[0m
[2m   11 | [0m                else if (v > 2) [31;1mqStackInfLoop[0m(v.u8);
[2m      |                 else if (v > 1) qStackInfLoop(v.i8);[0m
[2m      |                 else {                  [0m

            via [35;3mfn[0m [94;1mqStackInfLoop[0m at [2m12:33+13[0m:

[2m      |                 else if (v > 3) qStackInfLoop(v.i16);[0m
[2m      |                 else if (v > 2) qStackInfLoop(v.u8);[0m
[2m   12 | [0m                else if (v > 1) [31;1mqStackInfLoop[0m(v.i8);
[2m      |                 else {                  [0m
[2m      |                     let back = items;[0m

            via copy at [2m14:32+5[0m:

[2m      |                 else if (v > 1) qStackInfLoop(v.i8);[0m
[2m      |                 else {                  [0m
[2m   14 | [0m                    let back = [31;1mitems[0m;
[2m      |                     for (mut i = 0; i < items.len; i++)[0m
[2m      |                         items[i] += back[back.len - 1 - i] + v.int;             [0m


========

        novec fn test(ref items: int[]) {
            fn qStackInfLoop(mut v) {                           // PointlessMustSeq
                v--;
                if      (v > 8) qStackInfLoop(v.u64);
                else if (v > 7) qStackInfLoop(v.i64);
                else if (v > 6) qStackInfLoop(v.u32);
                else if (v > 5) qStackInfLoop(v.i32);
                else if (v > 4) qStackInfLoop(v.u16);
                else if (v > 3) qStackInfLoop(v.i16);
                else if (v > 2) qStackInfLoop(v.u8);
                else if (v > 1) qStackInfLoop(v.i8);
                else {                  
                    items.each: |ref item| item *= 2 + v.int;                   
                }
            }

            items.len.qStackInfLoop();
        }

        fn main() {
            mut v = [ 1 ];
            v.test();
            return v.only - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/assert.h>

inline static void qStackInfLoop_wws0(uint64_t, fu::view_mut<int>);
inline static void qStackInfLoop_mO3O(int64_t, fu::view_mut<int>);
inline static void qStackInfLoop_Qi0H(unsigned, fu::view_mut<int>);
inline static void qStackInfLoop_A558(int, fu::view_mut<int>);
inline static void qStackInfLoop_0UBG(uint16_t, fu::view_mut<int>);
inline static void qStackInfLoop_yzeR(short, fu::view_mut<int>);
inline static void qStackInfLoop_yTYo(fu::u8, fu::view_mut<int>);
inline static void qStackInfLoop_m64O(fu::i8, fu::view_mut<int>);

#ifndef fu_NO_fdefs

                                #ifndef DEF___FuDODzfXlHa
                                #define DEF___FuDODzfXlHa
inline static int _FuDO(/*3:3*/ int& item, /*3:3*/ const fu::i8 v)
{
    return (item *= (2 + int(v)));
}
                                #endif

                                #ifndef DEF_each_WLQApWHzxb4
                                #define DEF_each_WLQApWHzxb4
inline void each_WLQA(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const fu::i8 v)
{
    for (int i = 0; i < a.size(); i++)
        _FuDO(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_m64OyYWPLca
                                #define DEF_qStackInfLoop_m64OyYWPLca
inline static void qStackInfLoop_m64O(fu::i8 v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > fu::i8(8))
        qStackInfLoop_wws0(uint64_t(fu::u8(v)), items);
    else if (v > fu::i8(7))
        qStackInfLoop_mO3O(int64_t(v), items);
    else if (v > fu::i8(6))
        qStackInfLoop_Qi0H(unsigned(fu::u8(v)), items);
    else if (v > fu::i8(5))
        qStackInfLoop_A558(int(v), items);
    else if (v > fu::i8(4))
        qStackInfLoop_0UBG(uint16_t(fu::u8(v)), items);
    else if (v > fu::i8(3))
        qStackInfLoop_yzeR(short(v), items);
    else if (v > fu::i8(2))
        qStackInfLoop_yTYo(fu::u8(v), items);
    else if (v > fu::i8(1))
        qStackInfLoop_m64O(fu::i8(v), items);
    else
        each_WLQA(items, v);

}
                                #endif

                                #ifndef DEF___4JLvtLyKUGl
                                #define DEF___4JLvtLyKUGl
inline static int _4JLv(/*3:3*/ int& item, /*3:3*/ const fu::u8 v)
{
    return (item *= (2 + int(unsigned(v))));
}
                                #endif

                                #ifndef DEF_each_OvCKXNKO7B8
                                #define DEF_each_OvCKXNKO7B8
inline void each_OvCK(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const fu::u8 v)
{
    for (int i = 0; i < a.size(); i++)
        _4JLv(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_yTYo2TgUwZ4
                                #define DEF_qStackInfLoop_yTYo2TgUwZ4
inline static void qStackInfLoop_yTYo(fu::u8 v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > fu::u8(8u))
        qStackInfLoop_wws0(uint64_t(v), items);
    else if (v > fu::u8(7u))
        qStackInfLoop_mO3O(int64_t(uint64_t(v)), items);
    else if (v > fu::u8(6u))
        qStackInfLoop_Qi0H(unsigned(v), items);
    else if (v > fu::u8(5u))
        qStackInfLoop_A558(int(unsigned(v)), items);
    else if (v > fu::u8(4u))
        qStackInfLoop_0UBG(uint16_t(v), items);
    else if (v > fu::u8(3u))
        qStackInfLoop_yzeR(short(uint16_t(v)), items);
    else if (v > fu::u8(2u))
        qStackInfLoop_yTYo(fu::u8(v), items);
    else if (v > fu::u8(1u))
        qStackInfLoop_m64O(fu::i8(v), items);
    else
        each_OvCK(items, v);

}
                                #endif

                                #ifndef DEF___MIUOjUggljb
                                #define DEF___MIUOjUggljb
inline static int _MIUO(/*3:3*/ int& item, /*3:3*/ const short v)
{
    return (item *= (2 + int(v)));
}
                                #endif

                                #ifndef DEF_each_q2DeOuySUx9
                                #define DEF_each_q2DeOuySUx9
inline void each_q2De(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const short v)
{
    for (int i = 0; i < a.size(); i++)
        _MIUO(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_yzeRQ2LJr50
                                #define DEF_qStackInfLoop_yzeRQ2LJr50
inline static void qStackInfLoop_yzeR(short v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > short(8))
        qStackInfLoop_wws0(uint64_t(uint16_t(v)), items);
    else if (v > short(7))
        qStackInfLoop_mO3O(int64_t(v), items);
    else if (v > short(6))
        qStackInfLoop_Qi0H(unsigned(uint16_t(v)), items);
    else if (v > short(5))
        qStackInfLoop_A558(int(v), items);
    else if (v > short(4))
        qStackInfLoop_0UBG(uint16_t(v), items);
    else if (v > short(3))
        qStackInfLoop_yzeR(short(v), items);
    else if (v > short(2))
        qStackInfLoop_yTYo(fu::u8(uint16_t(v)), items);
    else if (v > short(1))
        qStackInfLoop_m64O(fu::i8(v), items);
    else
        each_q2De(items, v);

}
                                #endif

                                #ifndef DEF___wQoxUU1Xpq7
                                #define DEF___wQoxUU1Xpq7
inline static int _wQox(/*3:3*/ int& item, /*3:3*/ const uint16_t v)
{
    return (item *= (2 + int(unsigned(v))));
}
                                #endif

                                #ifndef DEF_each_PHs9PMlmlHf
                                #define DEF_each_PHs9PMlmlHf
inline void each_PHs9(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const uint16_t v)
{
    for (int i = 0; i < a.size(); i++)
        _wQox(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_0UBGc6zGgGi
                                #define DEF_qStackInfLoop_0UBGc6zGgGi
inline static void qStackInfLoop_0UBG(uint16_t v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > uint16_t(8u))
        qStackInfLoop_wws0(uint64_t(v), items);
    else if (v > uint16_t(7u))
        qStackInfLoop_mO3O(int64_t(uint64_t(v)), items);
    else if (v > uint16_t(6u))
        qStackInfLoop_Qi0H(unsigned(v), items);
    else if (v > uint16_t(5u))
        qStackInfLoop_A558(int(unsigned(v)), items);
    else if (v > uint16_t(4u))
        qStackInfLoop_0UBG(uint16_t(v), items);
    else if (v > uint16_t(3u))
        qStackInfLoop_yzeR(short(v), items);
    else if (v > uint16_t(2u))
        qStackInfLoop_yTYo(fu::u8(v), items);
    else if (v > uint16_t(1u))
        qStackInfLoop_m64O(fu::i8(fu::u8(v)), items);
    else
        each_PHs9(items, v);

}
                                #endif

                                #ifndef DEF___3bOFDgOyiMl
                                #define DEF___3bOFDgOyiMl
inline static int _3bOF(/*3:3*/ int& item, /*3:3*/ const unsigned v)
{
    return (item *= (2 + int(v)));
}
                                #endif

                                #ifndef DEF_each_wsfYKHcNClg
                                #define DEF_each_wsfYKHcNClg
inline void each_wsfY(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const unsigned v)
{
    for (int i = 0; i < a.size(); i++)
        _3bOF(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_Qi0HAnZT2Jj
                                #define DEF_qStackInfLoop_Qi0HAnZT2Jj
inline static void qStackInfLoop_Qi0H(unsigned v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > 8u)
        qStackInfLoop_wws0(uint64_t(v), items);
    else if (v > 7u)
        qStackInfLoop_mO3O(int64_t(uint64_t(v)), items);
    else if (v > 6u)
        qStackInfLoop_Qi0H(unsigned(v), items);
    else if (v > 5u)
        qStackInfLoop_A558(int(v), items);
    else if (v > 4u)
        qStackInfLoop_0UBG(uint16_t(v), items);
    else if (v > 3u)
        qStackInfLoop_yzeR(short(uint16_t(v)), items);
    else if (v > 2u)
        qStackInfLoop_yTYo(fu::u8(v), items);
    else if (v > 1u)
        qStackInfLoop_m64O(fu::i8(fu::u8(v)), items);
    else
        each_wsfY(items, v);

}
                                #endif

                                #ifndef DEF___4orJEOrUvig
                                #define DEF___4orJEOrUvig
inline static int _4orJ(/*3:3*/ int& item, /*3:3*/ const int64_t v)
{
    return (item *= (2 + int(v)));
}
                                #endif

                                #ifndef DEF_each_D7hsIWqSmAk
                                #define DEF_each_D7hsIWqSmAk
inline void each_D7hs(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const int64_t v)
{
    for (int i = 0; i < a.size(); i++)
        _4orJ(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_mO3ON4HbjMa
                                #define DEF_qStackInfLoop_mO3ON4HbjMa
inline static void qStackInfLoop_mO3O(int64_t v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > 8ll)
        qStackInfLoop_wws0(uint64_t(v), items);
    else if (v > 7ll)
        qStackInfLoop_mO3O(int64_t(v), items);
    else if (v > 6ll)
        qStackInfLoop_Qi0H(unsigned(uint64_t(v)), items);
    else if (v > 5ll)
        qStackInfLoop_A558(int(v), items);
    else if (v > 4ll)
        qStackInfLoop_0UBG(uint16_t(uint64_t(v)), items);
    else if (v > 3ll)
        qStackInfLoop_yzeR(short(v), items);
    else if (v > 2ll)
        qStackInfLoop_yTYo(fu::u8(uint64_t(v)), items);
    else if (v > 1ll)
        qStackInfLoop_m64O(fu::i8(v), items);
    else
        each_D7hs(items, v);

}
                                #endif

                                #ifndef DEF___JdbeLhDt0Qf
                                #define DEF___JdbeLhDt0Qf
inline static int _Jdbe(/*3:3*/ int& item, /*3:3*/ const uint64_t v)
{
    return (item *= (2 + int(unsigned(v))));
}
                                #endif

                                #ifndef DEF_each_26UeoqpYQoc
                                #define DEF_each_26UeoqpYQoc
inline void each_26Ue(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const uint64_t v)
{
    for (int i = 0; i < a.size(); i++)
        _Jdbe(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_wws04gfMiFh
                                #define DEF_qStackInfLoop_wws04gfMiFh
inline static void qStackInfLoop_wws0(uint64_t v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > 8ull)
        qStackInfLoop_wws0(uint64_t(v), items);
    else if (v > 7ull)
        qStackInfLoop_mO3O(int64_t(v), items);
    else if (v > 6ull)
        qStackInfLoop_Qi0H(unsigned(v), items);
    else if (v > 5ull)
        qStackInfLoop_A558(int(unsigned(v)), items);
    else if (v > 4ull)
        qStackInfLoop_0UBG(uint16_t(v), items);
    else if (v > 3ull)
        qStackInfLoop_yzeR(short(uint16_t(v)), items);
    else if (v > 2ull)
        qStackInfLoop_yTYo(fu::u8(v), items);
    else if (v > 1ull)
        qStackInfLoop_m64O(fu::i8(fu::u8(v)), items);
    else
        each_26Ue(items, v);

}
                                #endif

                                #ifndef DEF___waNOtLVUzO7
                                #define DEF___waNOtLVUzO7
inline static int _waNO(/*3:3*/ int& item, /*3:3*/ const int v)
{
    return (item *= (2 + int(v)));
}
                                #endif

                                #ifndef DEF_each_cfBwX2BCDO9
                                #define DEF_each_cfBwX2BCDO9
inline void each_cfBw(/*7:3*/ fu::view_mut<int> a, /*7:7*/ const int v)
{
    for (int i = 0; i < a.size(); i++)
        _waNO(a.mutref(i), v);

}
                                #endif

                                #ifndef DEF_qStackInfLoop_A558DTbq3M1
                                #define DEF_qStackInfLoop_A558DTbq3M1
inline static void qStackInfLoop_A558(int v, /*3:2*/ fu::view_mut<int> items)
{
    v--;
    if (v > 8)
        qStackInfLoop_wws0(uint64_t(unsigned(v)), items);
    else if (v > 7)
        qStackInfLoop_mO3O(int64_t(v), items);
    else if (v > 6)
        qStackInfLoop_Qi0H(unsigned(v), items);
    else if (v > 5)
        qStackInfLoop_A558(int(v), items);
    else if (v > 4)
        qStackInfLoop_0UBG(uint16_t(unsigned(v)), items);
    else if (v > 3)
        qStackInfLoop_yzeR(short(v), items);
    else if (v > 2)
        qStackInfLoop_yTYo(fu::u8(unsigned(v)), items);
    else if (v > 1)
        qStackInfLoop_m64O(fu::i8(v), items);
    else
        each_cfBw(items, v);

}
                                #endif

static void test_MbR9(/*1:1*/ fu::view_mut<int> items)
{
    qStackInfLoop_A558(items.size(), items);
}

                                #ifndef DEF_only_6W5nZbKz8v4
                                #define DEF_only_6W5nZbKz8v4
inline int only_6W5n(/*1:1*/ fu::view<int> a)
{
    fu_ASSERT((a.size() == 1));
    return a[0];
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> v = fu::vec<int> {{ 1 }};
    test_MbR9(v);
    return only_6W5n(v) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_RelaxRespec, N_UnusedCall, N_AARMustSeq

========

        let T_unorm     = 0x1;
        let T_8x4       = 0x1 << 8;
        let T_rgba8un   = T_8x4 | T_unorm;

        import _0;

        fn extern_integer_constant(x: uint) {
            mut res = 1;
            pragma output("switch ("x") { case "T_rgba8un": "res" = 0; }");
            return res;
        }

        fn main() T_rgba8un.extern_integer_constant;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_T_8x4
                                #define DEF_T_8x4
inline constexpr unsigned T_8x4 = (0x1u << 8u);
                                #endif

                                #ifndef DEF_T_unorm
                                #define DEF_T_unorm
inline constexpr unsigned T_unorm = 0x1u;
                                #endif

                                #ifndef DEF_T_rgba8un
                                #define DEF_T_rgba8un
inline constexpr unsigned T_rgba8un = (T_8x4 | T_unorm);
                                #endif

#ifndef fu_NO_fdefs

static int extern_integer_constant_LtD7(const unsigned x)
{
    int res = 1;
    switch (x) { case T_rgba8un: res = 0; };
    return res;
}

int fu_MAIN()
{
    return extern_integer_constant_LtD7(T_rgba8un);
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_T_unorm
                                #define DEF_T_unorm
inline constexpr unsigned T_unorm = 0x1u;
                                #endif

                                #ifndef DEF_T_8x4
                                #define DEF_T_8x4
inline constexpr unsigned T_8x4 = (0x1u << 8u);
                                #endif

                                #ifndef DEF_T_rgba8un
                                #define DEF_T_rgba8un
inline constexpr unsigned T_rgba8un = (T_8x4 | T_unorm);
                                #endif

// N_SD_HasStaticInit

========

        let TWO = 2;

        import _0;
        pragma emit_top("int times_TWO(int x) { return x * "TWO"; }");
        fn main() {
            mut res = 3;
            pragma emit(res" = times_TWO(" res ");");
            return res - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_TWO
                                #define DEF_TWO
inline constexpr int TWO = 2;
                                #endif
int times_TWO(int x) { return x * TWO; }

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int res = 3;
    res = times_TWO(res);

    return res - 6;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_TWO
                                #define DEF_TWO
inline constexpr int TWO = 2;
                                #endif

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        let priv = ROPOptions("Lteq");
        pub fn rop_Skybox() = priv;


        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

static const ROPOptions_UFti priv = (void(), ROPOptions_UFti(unsigned(depth_test)));

ROPOptions_UFti rop_Skybox_MbR9()
{
    return priv;
}

int fu_MAIN()
{
    return int(unsigned(rop_Skybox_MbR9())) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        let priv = ROPOptions("Lteq");
        pub fn rop_Skybox() = priv;

        pub import _0;
        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;
ROPOptions_UFti rop_Skybox_MbR9();

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(unsigned(rop_Skybox_MbR9())) - 4;
}

#endif

int main() { return fu_MAIN(); }
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

static const ROPOptions_UFti priv = (void(), ROPOptions_UFti(unsigned(depth_test)));

ROPOptions_UFti rop_Skybox_MbR9()
{
    return priv;
}

#endif

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        pub let rop_Skybox = ROPOptions("Lteq");


        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

extern const ROPOptions_UFti rop_Skybox = (void(), ROPOptions_UFti(unsigned(depth_test)));
int fu_MAIN()
{
    return int(unsigned(rop_Skybox)) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        pub let rop_Skybox = ROPOptions("Lteq");

        pub import _0;
        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

#ifndef fu_NO_fdefs

extern const ROPOptions_UFti rop_Skybox;
int fu_MAIN()
{
    return int(unsigned(rop_Skybox)) - 4;
}

#endif

int main() { return fu_MAIN(); }
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

extern const ROPOptions_UFti rop_Skybox = (void(), ROPOptions_UFti(unsigned(depth_test)));
#endif

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        let rop_Skybox = ROPOptions("Lteq");


        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

static const ROPOptions_UFti rop_Skybox = (void(), ROPOptions_UFti(unsigned(depth_test)));

int fu_MAIN()
{
    return int(unsigned(rop_Skybox)) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        primitive ROPOptions: u32;
        enum DepthTest: u32 { Always = 0; Gteq; Neq; Gt; Lteq; Eq; Lt; Never };
        inline fn ROPOptions(depth_test: DepthTest) = ROPOptions(depth_test.u32);

        let rop_Skybox = ROPOptions("Lteq");

        pub import _0;
        fn main() rop_Skybox.int - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef unsigned ROPOptions_UFti;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

#ifndef fu_NO_fdefs

extern const ROPOptions_UFti rop_Skybox;
int fu_MAIN()
{
    return int(unsigned(rop_Skybox)) - 4;
}

#endif

int main() { return fu_MAIN(); }
typedef unsigned ROPOptions_UFti;
enum DepthTest_s3Fb: unsigned;

                                #ifndef DEF_ROPOptions_UFti
                                #define DEF_ROPOptions_UFti
                                #endif

                                #ifndef DEF_DepthTest_s3Fb
                                #define DEF_DepthTest_s3Fb
enum DepthTest_s3Fb: unsigned
{
    DepthTest_s3Fb_Always = 0u,
    DepthTest_s3Fb_Gteq = 1u,
    DepthTest_s3Fb_Neq = 2u,
    DepthTest_s3Fb_Gt = 3u,
    DepthTest_s3Fb_Lteq = 4u,
    DepthTest_s3Fb_Eq = 5u,
    DepthTest_s3Fb_Lt = 6u,
    DepthTest_s3Fb_Never = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

static const DepthTest_s3Fb depth_test = DepthTest_s3Fb_Lteq;

extern const ROPOptions_UFti rop_Skybox = (void(), ROPOptions_UFti(unsigned(depth_test)));
#endif

// N_SD_HasStaticInit

========

        fn test(mut x: int) {
            if (x > 9) pragma emit(x" += 7; "x" *= 3;");
            ++x
        }

        fn main() test(10) == 52 && test(5) == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(int x)
{
    if (x > 9)
    {
        x += 7; x *= 3;

    };
    return ++x;
}

int fu_MAIN()
{
    if ((test_MbR9(10) == 52) && (test_MbR9(5) == 6))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Batch {};
        type ViewQuads = Batch;
        let VIEW_QUADS: ViewQuads = [];
        fn main() VIEW_QUADS == Batch() ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_i5rtCxP3lNb
                                #define DEF_x3Cx3E_i5rtCxP3lNb
inline int x3Cx3E_i5rt()
{
    return 0;
}
                                #endif

                                #ifndef DEF_x3Dx3D_E1ARSbOg6df
                                #define DEF_x3Dx3D_E1ARSbOg6df
inline bool x3Dx3D_E1AR()
{
    return !x3Cx3E_i5rt();
}
                                #endif

int fu_MAIN()
{
    if (x3Dx3D_E1AR())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet, N_SD_HasStaticInit

========

        struct Batch {};
        type ViewQuads = Batch;
        let VIEW_QUADS: ViewQuads = [];
        fn main() VIEW_QUADS == Batch() ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet, N_SD_HasStaticInit

========

        fn args_in_cases(a, b)              
            case (a -> typeof(b))            = a + b;

        fn main() args_in_cases(+1, -1);

---- <fail> ----
[2m[0m_0[2m.fu 3:19+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case ([31;1ma[0m -> typeof(b))            = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn args_in_cases(a, b)              
            case (typeof(a) -> b)            = a + b;

        fn main() args_in_cases(+1, -1);

---- <fail> ----
[2m[0m_0[2m.fu 3:32+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case (typeof(a) -> [31;1mb[0m)            = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn args_in_cases(a, b)              
            case (a -> b)                    = a + b;

        fn main() args_in_cases(+1, -1);

---- <fail> ----
[2m[0m_0[2m.fu 3:19+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case ([31;1ma[0m -> b)                    = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn args_in_cases(a, b)              
            case (typeof(a) -> typeof(b))    = a + b;

        fn main() args_in_cases(+1, -1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_args_in_cases_NN4PnOIxMqb
                                #define DEF_args_in_cases_NN4PnOIxMqb
inline static int args_in_cases_NN4P(const int a, const int b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return args_in_cases_NN4P(+1, -1);
}

#endif

int main() { return fu_MAIN(); }

========
                                  // DuplicateFunctions
        fn ARR_LAST(ref a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        fn main()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_ARR_LAST_TunKe5eLNid
                                #define DEF_ARR_LAST_TunKe5eLNid
inline static int ARR_LAST_TunK(/*1:1*/ fu::view<int> a)
{
    return a[(a.size() - 1)];
}
                                #endif

                                #ifndef DEF_ARR_LAST_w4a7tqPcUpc
                                #define DEF_ARR_LAST_w4a7tqPcUpc
inline static int& ARR_LAST_w4a7(/*1:1*/ fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    fu::vec<int> b = fu::vec<int> {{ 2 }};
    ARR_LAST_w4a7(b) += ARR_LAST_TunK(a);
    return ARR_LAST_TunK(b) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========
                                  // DuplicateFunctions
        fn ARR_LAST(ref a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_ARR_LAST_TunKe5eLNid
                                #define DEF_ARR_LAST_TunKe5eLNid
inline static int ARR_LAST_TunK(/*1:1*/ fu::view<int> a)
{
    return a[(a.size() - 1)];
}
                                #endif

                                #ifndef DEF_ARR_LAST_w4a7tqPcUpc
                                #define DEF_ARR_LAST_w4a7tqPcUpc
inline static int& ARR_LAST_w4a7(/*1:1*/ fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    fu::vec<int> b = fu::vec<int> {{ 2 }};
    ARR_LAST_w4a7(b) += ARR_LAST_TunK(a);
    return ARR_LAST_TunK(b) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        // Same as below, but avoids the $T call, which is also broken somehow.
        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -
        //   we emit useless overloads for mutrefs when its clearly useless.

        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i) {
                shadow mut a = a;
                a.i /= 2;
                return rec_cases(a);
            }
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_SchF;
inline static int rec_cases_Pwl2(const X_SchF&);
inline static int rec_cases_Qwbg(int);

                                #ifndef DEF_X_SchFD6M49r4
                                #define DEF_X_SchFD6M49r4
struct X_SchF
{
                                // shape_hash:    aca42a82859b0b33
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_rec_cases_QwbgbzCd37i
                                #define DEF_rec_cases_QwbgbzCd37i
inline static int rec_cases_Qwbg(const int a)
{
    if (a)
        return rec_cases_Qwbg((a / 2));
    else
        return a;

}
                                #endif

                                #ifndef DEF_rec_cases_Pwl2N3MIpa4
                                #define DEF_rec_cases_Pwl2N3MIpa4
inline static int rec_cases_Pwl2(/*1:1*/ const X_SchF& a)
{
    if (a.i)
    {
        X_SchF a_1 = a;
        a_1.i /= 2;
        return rec_cases_Pwl2(a_1);
    }
    else
        return rec_cases_Qwbg(a.i);

}
                                #endif

int fu_MAIN()
{
    return rec_cases_Pwl2(X_SchF { 1 });
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

========

        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i)    return rec_cases($T(i: a.i / 2));
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_SchF;
inline static int rec_cases_bC8A(const X_SchF&);
inline static int rec_cases_7H7z(int);

                                #ifndef DEF_X_SchFD6M49r4
                                #define DEF_X_SchFD6M49r4
struct X_SchF
{
                                // shape_hash:    aca42a82859b0b33
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_rec_cases_7H7zSzs8Sxj
                                #define DEF_rec_cases_7H7zSzs8Sxj
inline static int rec_cases_7H7z(const int a)
{
    if (a)
        return rec_cases_7H7z((a / 2));
    else
        return a;

}
                                #endif

                                #ifndef DEF_rec_cases_bC8AyXgiSJ8
                                #define DEF_rec_cases_bC8AyXgiSJ8
inline static int rec_cases_bC8A(/*1:1*/ const X_SchF& a)
{
    if (a.i)
    {
        return rec_cases_bC8A(X_SchF { (a.i / 2) });
    }
    else
        return rec_cases_7H7z(a.i);

}
                                #endif

int fu_MAIN()
{
    return rec_cases_bC8A(X_SchF { 1 });
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

========

        let OK = true;                                          // !DEV_DontFoldLiterals
        fn what(a: int) case (OK) a;
        fn main() 0.what;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_what_0DCJaE9X1mk
                                #define DEF_what_0DCJaE9X1mk
inline static int what_0DCJ(/*1:1*/ const int a)
{
    return a;
}
                                #endif

int fu_MAIN()
{
    return what_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        enum K { A }

        fn Str(n: <T>) case (T.is::enum) {
            for (fieldname i: T) if (n == "i") return "i";
            return "?";
        }


        inline fn Print(x: string): string = x;
        inline fn Print(x.Str)    : string = x;

        fn concat(parts.Print[]: string[..]) {
            mut res = "(";
            for (mut i = 0; i < parts.len; i++) {
                if (i) res ~= ", ";
                res ~= parts[i];
            }
            return res ~= ")";
        }

        fn consumeNextLinePrefix(kind: K, bullet: byte)
            concat(kind, bullet);                               // PointlessLocal

        fn main() {
            mut str = concat("A", 'B');
            return str == "(A, B)" ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:13+6[0m:

[2m      | [0m
[2m      |         fn consumeNextLinePrefix(kind: K, bullet: byte)[0m
[2m   23 | [0m            [31;1mconcat[0m(kind, bullet);                               // PointlessLocal
[2m      | [0m
[2m      |         fn main() {[0m

	Bad call to [94;1mconcat[0m with args ([35;3menum[0m [94;1mK[0m, [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mconcat[0m at [2m13:12+6[0m:
[2m   13 | [0m        fn [31;1mconcat[0m(parts.Print[]: string[..]) {

	    Cannot match [35;3marg[0m [94;1mconcat[0m:[94;1mparts[0m autocall [94;1mPrint[0m: 

		[35;3mtemplate[0m [94;1mPrint[0m at [2m11:19+5[0m:
[2m   11 | [0m        inline fn [31;1mPrint[0m(x.Str)    : string = x;

		    Cannot match [35;3marg[0m [94;1mx[0m autocall [94;1mStr[0m: 

				[35;3mtemplate[0m [94;1mStr[0m at [2m4:12+3[0m:
[2m    4 | [0m        fn [31;1mStr[0m(n: <T>) case (T.is::enum) {

				    No body pattern matched.

		[35;3minline[0m [94;1mPrint[0m at [2m10:19+5[0m:
[2m   10 | [0m        inline fn [31;1mPrint[0m(x: string): string = x;

		    [35;3marg[0m [94;1mPrint[0m:[94;1mx[0m expects [35;3mstring[0m, got [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mconsumeNextLinePrefix[0m([94;1mK[0m, [35;3mbyte[0m) at [2m22:12+21[0m

========

        enum K { A }

        fn Str(n: <T>) case (T.is::enum) {
            for (fieldname i: T) if (n == "i") return "i";
            return "?";
        }


        inline fn Print(x: byte)  : string = [ x ]; 
        inline fn Print(x: string): string = x;
        inline fn Print(x.Str)    : string = x;

        fn concat(parts.Print[]: string[..]) {
            mut res = "(";
            for (mut i = 0; i < parts.len; i++) {
                if (i) res ~= ", ";
                res ~= parts[i];
            }
            return res ~= ")";
        }

        fn consumeNextLinePrefix(kind: K, bullet: byte)
            concat(kind, bullet);                               // PointlessLocal

        fn main() {
            mut str = concat("A", 'B');
            return str == "(A, B)" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_WKc5mY6hffl
                                #define STR_WKc5mY6hffl
static const fu::str str_WKc5mY6hffl fu_INIT_PRIORITY(1001) { "A"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str concat_MbR9(/*1:1*/ fu::view<fu::str> parts)
{
    /*MOV*/ fu::str res = fu::str("("_fu);
    for (int i = 0; i < parts.size(); i++)
    {
        if (i)
            res += ", "_view;

        res += parts[i];
    };
    return (res += ")"_view).destructive_move();
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec_range<char> x {};
    char x_1;
    fu::str str = concat_MbR9(fu::view<fu::str> {{ fu::str((x.ptr_reassign(str_WKc5mY6hffl), x)), (x_1 = 'B', fu::vec<char> {{ x_1 }}) }});
    if (str == "(A, B)"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        enum K { A }

        fn Str(n: <T>) case (T.is::enum) {
            for (fieldname i: T) if (n == "i") return "i";
            return "?";
        }


        inline fn Print(x: byte)  : string = [ x ]; 
        inline fn Print(x: string): string = x;
        inline fn Print(x.Str)    : string = x;

        fn concat(parts.Print[]: string[..]) {
            mut res = "(";
            for (mut i = 0; i < parts.len; i++) {
                if (i) res ~= ", ";
                res ~= parts[i];
            }
            return res ~= ")";
        }

        fn consumeNextLinePrefix(kind: K, bullet: byte)
            concat(kind, bullet);                               // PointlessLocal

        fn main() {
            mut str = concat("A", 'B');
            return str == "(A, B)" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_WKc5mY6hffl
                                #define STR_WKc5mY6hffl
static const fu::str str_WKc5mY6hffl fu_INIT_PRIORITY(1001) { "A"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str concat_MbR9(/*1:1*/ fu::view<fu::str> parts)
{
    /*MOV*/ fu::str res = fu::str("("_fu);
    for (int i = 0; i < parts.size(); i++)
    {
        if (i)
            res += ", "_view;

        res += parts[i];
    };
    return (res += ")"_view).destructive_move();
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    const fu::str* x;
    char x_1;
    fu::str str = concat_MbR9(fu::view<fu::str> {{ fu::str((x = &(str_WKc5mY6hffl), (*x))), (x_1 = 'B', fu::vec<char> {{ x_1 }}) }});
    if (str == "(A, B)"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn Concat(a: byte[..], b.PrettyPronto) a ~ b;
        fn Concat(a.PrettyPronto, b: byte[..]) a ~ b;

        fn PrettyPronto(n: <T>) n & 1 ? "odd" : "even";


        fn main() {
            mut str = Concat(0, 1);
            return str.len - 7;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:23+6[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    9 | [0m            mut str = [31;1mConcat[0m(0, 1);
[2m      |             return str.len - 7;[0m
[2m      |         }[0m

	Bad call to [94;1mConcat[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mConcat[0m at [2m3:12+6[0m:
[2m    3 | [0m        fn [31;1mConcat[0m(a.PrettyPronto, b: byte[..]) a ~ b;

	    [35;3marg[0m [94;1mConcat[0m:[94;1mb[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1mConcat[0m at [2m2:12+6[0m:
[2m    2 | [0m        fn [31;1mConcat[0m(a: byte[..], b.PrettyPronto) a ~ b;

	    [35;3marg[0m [94;1mConcat[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        fn Concat(a: byte[..], b.PrettyPronto) a ~ b;
        fn Concat(a.PrettyPronto, b: byte[..]) a ~ b;

        fn PrettyPronto(n: <T>) n & 1 ? "odd" : "even";


        fn main() {
            mut str = Concat(0, 1);
            return str.len - 7;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:23+6[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    9 | [0m            mut str = [31;1mConcat[0m(0, 1);
[2m      |             return str.len - 7;[0m
[2m      |         }[0m

	Bad call to [94;1mConcat[0m with args ([35;3malways-false[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mConcat[0m at [2m3:12+6[0m:
[2m    3 | [0m        fn [31;1mConcat[0m(a.PrettyPronto, b: byte[..]) a ~ b;

	    [35;3marg[0m [94;1mConcat[0m:[94;1mb[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1mConcat[0m at [2m2:12+6[0m:
[2m    2 | [0m        fn [31;1mConcat[0m(a: byte[..], b.PrettyPronto) a ~ b;

	    [35;3marg[0m [94;1mConcat[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        fn Concat(a: byte[..], b.PrettyPronto) a ~ b;
        fn Concat(a.PrettyPronto, b: byte[..]) a ~ b;

        fn PrettyPronto(n: <T>) n & 1 ? "odd" : "even";

        fn Concat(a.PrettyPronto, b.PrettyPronto) a ~ b;    

        fn main() {
            mut str = Concat(0, 1);
            return str.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_BAZKVmETzMa
                                #define STR_BAZKVmETzMa
static const fu::str str_BAZKVmETzMa fu_INIT_PRIORITY(1001) { "odd"_fu };
                                #endif

                                #ifndef STR_4F5ZhuCIeNd
                                #define STR_4F5ZhuCIeNd
static const fu::str str_4F5ZhuCIeNd fu_INIT_PRIORITY(1001) { "even"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_PrettyPronto_ynITKgqA2El
                                #define DEF_PrettyPronto_ynITKgqA2El
inline static fu::vec_range<char> PrettyPronto_ynIT(const int n)
{
    if (n & 1)
        return str_BAZKVmETzMa;
    else
        return str_4F5ZhuCIeNd;

}
                                #endif

                                #ifndef DEF_Concat_rA003L6Quul
                                #define DEF_Concat_rA003L6Quul
inline static fu::str Concat_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    fu::str str = Concat_rA00(PrettyPronto_ynIT(0), PrettyPronto_ynIT(1));
    return str.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Concat(a: byte[..], b.PrettyPronto) a ~ b;
        fn Concat(a.PrettyPronto, b: byte[..]) a ~ b;

        fn PrettyPronto(n: <T>) n & 1 ? "odd" : "even";

        fn Concat(a.PrettyPronto, b.PrettyPronto) a ~ b;    

        fn main() {
            mut str = Concat(0, 1);
            return str.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_BAZKVmETzMa
                                #define STR_BAZKVmETzMa
static const fu::str str_BAZKVmETzMa fu_INIT_PRIORITY(1001) { "odd"_fu };
                                #endif

                                #ifndef STR_4F5ZhuCIeNd
                                #define STR_4F5ZhuCIeNd
static const fu::str str_4F5ZhuCIeNd fu_INIT_PRIORITY(1001) { "even"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_PrettyPronto_ynITKgqA2El
                                #define DEF_PrettyPronto_ynITKgqA2El
inline static const fu::str& PrettyPronto_ynIT(const int n)
{
    if (n & 1)
        return str_BAZKVmETzMa;
    else
        return str_4F5ZhuCIeNd;

}
                                #endif

                                #ifndef DEF_Concat_rA003L6Quul
                                #define DEF_Concat_rA003L6Quul
inline static fu::str Concat_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    fu::str str = Concat_rA00(PrettyPronto_ynIT(0), PrettyPronto_ynIT(1));
    return str.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {                     
            mut str = 0      ~ 1;       
            return str.len - 2;                                 // DuplicateFunctions
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:30+1[0m:

[2m      | [0m
[2m      |         fn main() {                     [0m
[2m    3 | [0m            mut str = 0      [31;1m~[0m 1;       
[2m      |             return str.len - 2;                                 // DuplicateFunctions[0m
[2m      |         }[0m

	Bad call to [94;1m~[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 551:10+1[0m:
[2m  551 | [0minfix fn [31;1m~[0m (        a.str,       b: byte[..]) a ~ b;

	    [35;3marg[0m [94;1m~[0m:[94;1mb[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 550:10+1[0m:
[2m  550 | [0minfix fn [31;1m~[0m (        a: byte[..], b.str      ) a ~ b;

	    [35;3marg[0m [94;1m~[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;3marg[0m [94;1m<fu/vec/concat_one.h> +[0m:[94;1mb[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;3marg[0m [94;1m<fu/vec/concat_one.h> +[0m:[94;1ma[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat.h> +[0m at [2m../../../../../[0mprelude[2m 479:10+1[0m:
[2m  479 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T[..]): T[] __native("<fu/vec/concat.h>",     "+");

	    [35;3marg[0m [94;1m<fu/vec/concat.h> +[0m:[94;1ma[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 54:11+1[0m:
[2m   54 | [0mprefix fn [31;1m~[0m (a: <T>) case (T.is::bitfield): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {                     
            mut str = 0      ~ 1;       
            return str.len - 2;                                 // DuplicateFunctions
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:30+1[0m:

[2m      | [0m
[2m      |         fn main() {                     [0m
[2m    3 | [0m            mut str = 0      [31;1m~[0m 1;       
[2m      |             return str.len - 2;                                 // DuplicateFunctions[0m
[2m      |         }[0m

	Bad call to [94;1m~[0m with args ([35;3malways-false[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 551:10+1[0m:
[2m  551 | [0minfix fn [31;1m~[0m (        a.str,       b: byte[..]) a ~ b;

	    [35;3marg[0m [94;1m~[0m:[94;1mb[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 550:10+1[0m:
[2m  550 | [0minfix fn [31;1m~[0m (        a: byte[..], b.str      ) a ~ b;

	    [35;3marg[0m [94;1m~[0m:[94;1ma[0m expects [35;3mstring[0m, got [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;3marg[0m [94;1m<fu/vec/concat_one.h> +[0m:[94;1mb[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;3marg[0m [94;1m<fu/vec/concat_one.h> +[0m:[94;1ma[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m<fu/vec/concat.h> +[0m at [2m../../../../../[0mprelude[2m 479:10+1[0m:
[2m  479 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T[..]): T[] __native("<fu/vec/concat.h>",     "+");

	    [35;3marg[0m [94;1m<fu/vec/concat.h> +[0m:[94;1ma[0m:
	    Not sliceable: [35;3mi32[0m

	[35;3mtemplate[0m [94;1m~[0m at [2m../../../../../[0mprelude[2m 54:11+1[0m:
[2m   54 | [0mprefix fn [31;1m~[0m (a: <T>) case (T.is::bitfield): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {                     
            mut str = 0 ~ "" ~ 1;       
            return str.len - 2;                                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    fu::str str = x7E_rA00(x7E_rA00(fu::i64dec(0), ""_view), fu::i64dec(1));
    return str.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {                     
            mut str = 0 ~ "" ~ 1;       
            return str.len - 2;                                 // DuplicateFunctions
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    fu::str str = x7E_rA00(x7E_rA00(fu::i64dec(0), fu::view<char>{}), fu::i64dec(1));
    return str.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test() {
            mut x = 5;
            return x;
        }

        fn main()
            test() - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    const int x = 5;
    return x;
}

int fu_MAIN()
{
    return test_MbR9() - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { i: i32; };

        fn test() {
            mut x = Test(5);
            return x;
        }

        fn main()
            test().i - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_B0Kd;

                                #ifndef DEF_Test_B0KdfMSe4pd
                                #define DEF_Test_B0KdfMSe4pd
struct Test_B0Kd
{
                                // shape_hash:    5e809f471f5e02c9
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_B0Kd test_MbR9()
{
    const Test_B0Kd x = Test_B0Kd { 5 };
    return x;
}

int fu_MAIN()
{
    return test_MbR9().i - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a: i32; b: i32; };

        fn test() {
            mut x = Test(5, -5);
            return x;
        }

        fn main()
            test().a + test().b;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_ikd8 test_MbR9()
{
    const Test_ikd8 x = Test_ikd8 { 5, -5 };
    return x;
}

int fu_MAIN()
{
    return test_MbR9().a + test_MbR9().b;
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { x: i32; };
        fn ref2arg(x: X) = x;

        fn main() {
            let NOTREF = ref2arg(X(101));
            return NOTREF.x - 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct X_GlLV;

                                #ifndef DEF_X_GlLVSBH0iih
                                #define DEF_X_GlLVSBH0iih
struct X_GlLV
{
                                // shape_hash:    4bfe9f2a4961279c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const X_GlLV& ref2arg_MbR9(/*1:1*/ const X_GlLV& x)
{
    return x;
}

int fu_MAIN()
{
    const X_GlLV NOTREF = ref2arg_MbR9(X_GlLV { 101 });
    return NOTREF.x - 101;
}

#endif

int main() { return fu_MAIN(); }

========


        nocopy 
        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             let a = Copied(1);[0m
[2m    8 | [0m            mut b = [31;1ma[0m;
[2m      |             b.x++;[0m
[2m      |             return b.x - a.x * 2;[0m

	A value is needed, but cannot be copied or moved from: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [94;1ma[0m [35;3mstruct[0m [94;1mCopied[0m

	Cannot move: [35;3mlet[0m [94;1ma[0m is used again.

RelaxCopyResize [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========


        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Copied_mRmI;

                                #ifndef DEF_Copied_mRmIpNQAR7k
                                #define DEF_Copied_mRmIpNQAR7k
struct Copied_mRmI
{
                                // shape_hash:    4531687bd980e6ae
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Copied_mRmI a = Copied_mRmI { 1 };
    Copied_mRmI b = a;
    b.x++;
    return b.x - (a.x * 2);
}

#endif

int main() { return fu_MAIN(); }

========

        struct XY { x: i32; y: i32; };
        fn ref2arg(v: XY) = v;

        fn main() {
            let a = XY(99, 2);
            let ref2a = ref2arg(a);
            mut ret = 1;
            pragma emit(`
                `ret` -= int(&`ref2a` == &`a`);
            `);
            return ret;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const XY_tqAU& ref2arg_MbR9(/*1:1*/ const XY_tqAU& v)
{
    return v;
}

int fu_MAIN()
{
    const XY_tqAU a = XY_tqAU { 99, 2 };
    const XY_tqAU& /*a*/ ref2a = ref2arg_MbR9(a);
    int ret = 1;

                ret -= int(&ref2a == &a);

    return ret;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NoCopy { i: i32; };
        fn retmutref(ref nc: NoCopy) nc;

        fn main() {
            mut nc: NoCopy;
            nc.retmutref.retmutref.i++;
            return nc.i - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NoCopy_vO9Z;

                                #ifndef DEF_NoCopy_vO9Zqgzy30i
                                #define DEF_NoCopy_vO9Zqgzy30i
struct NoCopy_vO9Z
{
                                // shape_hash:    7da6a83755cfaa1d
                                // non_triv_mask: 0000080000000000
    int i;
    NoCopy_vO9Z(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z(NoCopy_vO9Z&&) = default;
    NoCopy_vO9Z& operator=(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z& operator=(NoCopy_vO9Z&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NoCopy_vO9Z& retmutref_MbR9(/*1:1*/ NoCopy_vO9Z& nc)
{
    return nc;
}

int fu_MAIN()
{
    NoCopy_vO9Z nc {};
    retmutref_MbR9(retmutref_MbR9(nc)).i++;
    return nc.i - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NoCopy { i: i32; };
        fn mutrefself(ref nc: NoCopy) {
            nc.i++;
            return nc;
        }

        fn main() {
            mut nc: NoCopy;
            nc.mutrefself().mutrefself();
            return nc.i - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NoCopy_vO9Z;

                                #ifndef DEF_NoCopy_vO9Zqgzy30i
                                #define DEF_NoCopy_vO9Zqgzy30i
struct NoCopy_vO9Z
{
                                // shape_hash:    7da6a83755cfaa1d
                                // non_triv_mask: 0000080000000000
    int i;
    NoCopy_vO9Z(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z(NoCopy_vO9Z&&) = default;
    NoCopy_vO9Z& operator=(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z& operator=(NoCopy_vO9Z&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static NoCopy_vO9Z& mutrefself_MbR9(/*1:1*/ NoCopy_vO9Z& nc)
{
    nc.i++;
    return nc;
}

static const NoCopy_vO9Z& mutrefself_kGbb(/*1:1*/ NoCopy_vO9Z& nc)
{
    nc.i++;
    return nc;
}

int fu_MAIN()
{
    NoCopy_vO9Z nc {};
    mutrefself_kGbb(mutrefself_MbR9(nc));
    return nc.i - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;
            let b: NoCopy;
            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NoCopy_vO9Z;

                                #ifndef DEF_NoCopy_vO9Zqgzy30i
                                #define DEF_NoCopy_vO9Zqgzy30i
struct NoCopy_vO9Z
{
                                // shape_hash:    7da6a83755cfaa1d
                                // non_triv_mask: 0000080000000000
    int i;
    NoCopy_vO9Z(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z(NoCopy_vO9Z&&) = default;
    NoCopy_vO9Z& operator=(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z& operator=(NoCopy_vO9Z&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NoCopy_vO9Z& retargs_or_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    return a ? a : b;
}

static const NoCopy_vO9Z& retargs_and_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    return !a ? a : b;
}

static const NoCopy_vO9Z& retargs_if_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    if (a.i)
        return b;
    else
        return a;

}

static const NoCopy_vO9Z& retarg_MbR9(/*1:1*/ const NoCopy_vO9Z& a)
{
    return a;
}

int fu_MAIN()
{
    NoCopy_vO9Z a {};
    NoCopy_vO9Z b {};
    return retarg_MbR9(retargs_if_MbR9(a, retargs_and_MbR9(a, retargs_or_MbR9(a, b)))).i;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;                      // <- b now temp

            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NoCopy_vO9Z;

                                #ifndef DEF_NoCopy_vO9Zqgzy30i
                                #define DEF_NoCopy_vO9Zqgzy30i
struct NoCopy_vO9Z
{
                                // shape_hash:    7da6a83755cfaa1d
                                // non_triv_mask: 0000080000000000
    int i;
    NoCopy_vO9Z(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z(NoCopy_vO9Z&&) = default;
    NoCopy_vO9Z& operator=(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z& operator=(NoCopy_vO9Z&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NoCopy_vO9Z& retargs_or_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    return a ? a : b;
}

static const NoCopy_vO9Z& retargs_and_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    return !a ? a : b;
}

static const NoCopy_vO9Z& retargs_if_MbR9(/*3:3*/ const NoCopy_vO9Z& a, /*3:3*/ const NoCopy_vO9Z& b)
{
    if (a.i)
        return b;
    else
        return a;

}

static const NoCopy_vO9Z& retarg_MbR9(/*1:1*/ const NoCopy_vO9Z& a)
{
    return a;
}

int fu_MAIN()
{
    NoCopy_vO9Z a {};
    return retarg_MbR9(retargs_if_MbR9(a, retargs_and_MbR9(a, retargs_or_MbR9(a, NoCopy_vO9Z{})))).i;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct NoCopy { i: i32; };

        fn      retarg(ref a) a;                    // <- now templates
        fn  retargs_if(ref a, ref b) a.i ? b : a;
        fn  retargs_or(ref a, ref b) a || b;
        fn retargs_and(ref a, ref b) a && b;

        fn main() {
            mut a: NoCopy;                      // <- now muts
            mut b: NoCopy;
            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;
            return a.i + b.i - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct NoCopy_vO9Z;

                                #ifndef DEF_NoCopy_vO9Zqgzy30i
                                #define DEF_NoCopy_vO9Zqgzy30i
struct NoCopy_vO9Z
{
                                // shape_hash:    7da6a83755cfaa1d
                                // non_triv_mask: 0000080000000000
    int i;
    NoCopy_vO9Z(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z(NoCopy_vO9Z&&) = default;
    NoCopy_vO9Z& operator=(const NoCopy_vO9Z&) = delete;
    NoCopy_vO9Z& operator=(NoCopy_vO9Z&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_retargs_or_qSZchX7WzE2
                                #define DEF_retargs_or_qSZchX7WzE2
inline static NoCopy_vO9Z& retargs_or_qSZc(/*3:3*/ NoCopy_vO9Z& a, /*3:3*/ NoCopy_vO9Z& b)
{
    return a ? a : b;
}
                                #endif

                                #ifndef DEF_retargs_and_Bv98e0TgfAc
                                #define DEF_retargs_and_Bv98e0TgfAc
inline static NoCopy_vO9Z& retargs_and_Bv98(/*3:3*/ NoCopy_vO9Z& a, /*3:3*/ NoCopy_vO9Z& b)
{
    return !a ? a : b;
}
                                #endif

                                #ifndef DEF_retargs_if_UJUtLLAXjEa
                                #define DEF_retargs_if_UJUtLLAXjEa
inline static NoCopy_vO9Z& retargs_if_UJUt(/*3:3*/ NoCopy_vO9Z& a, /*3:3*/ NoCopy_vO9Z& b)
{
    if (a.i)
        return b;
    else
        return a;

}
                                #endif

                                #ifndef DEF_retarg_UL05LuKbHh1
                                #define DEF_retarg_UL05LuKbHh1
inline static NoCopy_vO9Z& retarg_UL05(/*1:1*/ NoCopy_vO9Z& a)
{
    return a;
}
                                #endif

int fu_MAIN()
{
    NoCopy_vO9Z a {};
    NoCopy_vO9Z b {};
    retarg_UL05(retargs_if_UJUt(a, retargs_and_Bv98(a, retargs_or_qSZc(a, b)))).i++;
    return (a.i + b.i) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn as_blocks_after(x: i32) {
            mut zero = 0;
            if (x > 2) // a broken stmt emit lifted the loop out of the conditional
                for (mut i = 0; i < x; i++)
                    zero = i + i*zero;

            return zero;
        }

        fn main() 2.as_blocks_after;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int as_blocks_after_MbR9(const int x)
{
    int zero = 0;
    if (x > 2)
        for (int i = 0; i < x; i++)
            zero = (i + (i * zero));
;
    return zero;
}

int fu_MAIN()
{
    return as_blocks_after_MbR9(2);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Lifetime { woot: Lifetime[]; };

        fn Lifetime_test(x: Lifetime) {
            x.woot.len & 1 && throw("This is very important.");
            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);
            return x;
        }

        fn Lifetime_fromBinding(x: i32) {
            mut woot: Lifetime[];
            for (mut i = 0; i < x; i++)
                woot[i] = Lifetime();

            // !N_NonTrivAutoCopy
            //
            //  1. Move 'woot' into Lifetime
            //      instead of naively copying it.
            //                             ....
            return Lifetime_test(Lifetime(:woot));              // ConstCast
            //     ....
            //  2. Move the result out even though
            //      Lifetime_test takes and returns refs.
        }

        fn main() 0.Lifetime_fromBinding.woot.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>
#include <fu/init_priority.h>

struct Lifetime_L9po;
static const Lifetime_L9po& Lifetime_test_MbR9(const Lifetime_L9po&);

                                #ifndef DEF_Lifetime_L9poxAV3U2b
                                #define DEF_Lifetime_L9poxAV3U2b
struct Lifetime_L9po
{
                                // shape_hash:    1539d8adc6e5ba08
                                // non_triv_mask: 0000200000000800
    fu::vec<Lifetime_L9po> woot;
    Lifetime_L9po(const Lifetime_L9po&) = default;
    Lifetime_L9po(Lifetime_L9po&&) = default;
    Lifetime_L9po& operator=(Lifetime_L9po&&) = default;
    Lifetime_L9po& operator=(const Lifetime_L9po& selfrec) { return *this = Lifetime_L9po(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || woot
        ;
    }
};
                                #endif

                                #ifndef STR_4XA7K4pL2o9
                                #define STR_4XA7K4pL2o9
static const fu::str str_4XA7K4pL2o9 fu_INIT_PRIORITY(1001) { "This is very important."_fu };
                                #endif

#ifndef fu_NO_fdefs

static const Lifetime_L9po& Lifetime_test_MbR9(/*1:1*/ const Lifetime_L9po& x)
{
    if (x.woot.size() & 1)
        fu::fail(fu::str(str_4XA7K4pL2o9));
    else
    {
        for (int i = 0; i < x.woot.size(); i++)
        {
            Lifetime_test_MbR9(x.woot[i]);
        };
        return x;
    };
}

static Lifetime_L9po Lifetime_fromBinding_MbR9(const int x)
{
    /*MOV*/ fu::vec<Lifetime_L9po> woot {};
    for (int i = 0; i < x; i++)
    {
        woot.mutref(i) = Lifetime_L9po{};
    };
    return static_cast<Lifetime_L9po&&>(const_cast<Lifetime_L9po&>(Lifetime_test_MbR9(Lifetime_L9po { static_cast<fu::vec<Lifetime_L9po>&&>(woot) })));
}

int fu_MAIN()
{
    return Lifetime_fromBinding_MbR9(0).woot.size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall

========

        fn test(x: i32) {                       // none of these need vecs
            let c = [10007];                    // TODO fu::slate<1, int> c
            let a = [7, 11, 9, 21, x, x, x, x]; // TODO fu::slate<2, int> a
            let b = {                           // TODO fu::slate<1, int> b
                :BRK {                          // !N_NonTrivAutoCopy
                    if (x & 2) break :BRK c;
                    if (x & 1) break :BRK [ x ]; // a val
                    a // a ref
                }
            };
            return a[0] - b[0] * a[1];
        }

        fn main() 1.test + 4.test + 74;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    /*MOV*/ fu::vec<int> c = fu::vec<int> {{ 10007 }};
    fu::vec<int> a = fu::vec<int> {{ 7, 11, 9, 21, x, x, x, x }};
    fu::vec<int> b = ((x & 2) ? c.destructive_move() : ((x & 1) ? fu::vec<int> {{ x }} : fu::vec<int>(a)));
    return a[0] - (b[0] * a[1]);
}

int fu_MAIN()
{
    return (test_MbR9(1) + test_MbR9(4)) + 74;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Test { i: i32[]; };

        fn test(mut x: Test) {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Test_Uroc;

                                #ifndef DEF_Test_UrocfMrDqte
                                #define DEF_Test_UrocfMrDqte
struct Test_Uroc
{
                                // shape_hash:    2f02371a25f6898a
                                // non_triv_mask: 0008000000004000
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_Uroc test_MbR9(/*MOV*/ Test_Uroc&& x)
{
    x.i.mutref(0) += x.i[1];
    return static_cast<Test_Uroc&&>(x);
}

int fu_MAIN()
{
    Test_Uroc s = Test_Uroc { fu::vec<int> {{ 1, 2 }} };
    return test_MbR9(Test_Uroc(s)).i[0] - (s.i[0] * 3);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Test { i: i32[]; };

        fn test(mut x: Test): Test {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Test_Uroc;

                                #ifndef DEF_Test_UrocfMrDqte
                                #define DEF_Test_UrocfMrDqte
struct Test_Uroc
{
                                // shape_hash:    2f02371a25f6898a
                                // non_triv_mask: 0008000000004000
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_Uroc test_MbR9(/*MOV*/ Test_Uroc&& x)
{
    x.i.mutref(0) += x.i[1];
    return static_cast<Test_Uroc&&>(x);
}

int fu_MAIN()
{
    Test_Uroc s = Test_Uroc { fu::vec<int> {{ 1, 2 }} };
    return test_MbR9(Test_Uroc(s)).i[0] - (s.i[0] * 3);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn compile_snippets(x0: string) x0.find('a') && throw("throw#1");
        fn ZERO(x1: string) x1.find('b') && throw("throw#2");

        fn FAIL(x2: string): string {                   // EXPECT fu::view<char> x2
            try {
                let ctx = compile_snippets(x2) && "hey";
                return ctx;
            }
            catch (e) {
                return ZERO(x2) && e;
            }
        }

        fn main() FAIL("a").len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static int compile_snippets_MbR9(/*1:1*/ fu::view<char> x0)
{
    if (find_ZKsG(x0, 'a'))
        fu::fail(fu::str("throw#1"_fu));
    else
        return 0;

}

static int ZERO_MbR9(/*1:1*/ fu::view<char> x1)
{
    if (find_ZKsG(x1, 'b'))
        fu::fail(fu::str("throw#2"_fu));
    else
        return 0;

}

static const fu::str& FAIL_MbR9(/*1:1*/ fu::view<char> x2)
{

    try
    {
    {
        const fu::str& /*zeroes*/ ctx = (compile_snippets_MbR9(x2), (*(fu::str*)fu::NIL));
        return ctx;
    }
    }
    catch (const std::exception& o_0)
    {
    {
        ZERO_MbR9(x2);
        return (*(fu::str*)fu::NIL);
    }
    }
;
}

int fu_MAIN()
{
    return FAIL_MbR9("a"_view).size();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        // The thing below but shorter:
        //  the '|| throw' introduces a bullshit lambda during codegen,
        //   which misreturns a dangling reference to its own frame.
        fn test(x: string) [x][0] || throw("nope!");
        fn main() "what".test.len - 4;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_ycdnww6SFij
                                #define STR_ycdnww6SFij
static const fu::str str_ycdnww6SFij fu_INIT_PRIORITY(1001) { "what"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str test_MbR9(/*1:1*/ fu::vec_range<char> x)
{
    fu::vec_range<char> _0 {};
    return fu::str(((_0.ptr_reassign(fu::view<fu::str> {{ fu::str(x) }}[0])) ? _0 : fu::fail(fu::str("nope!"_fu))));
}

int fu_MAIN()
{
    return test_MbR9(str_ycdnww6SFij).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn Only(s: $T[]) s.len == 1 ? s[0] : throw ("len != 1: " ~ s.len);

        struct Node       { kind: string; };
        struct SolvedNode { kind: string; };

        fn solveNodes(n: Node[]) {
            mut r: SolvedNode[];
            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);
            return r;
        }

        // the '|| throw' introduces a bullshit lambda during codegen,
        //  which misreturns a dangling reference to its own frame.
        fn solveDeclExpr(n: Node) solveNodes([ n ]).Only || throw ("!only");

        fn main() solveDeclExpr(Node("a")).kind.len - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Node_EKPi;
struct SolvedNode_nVJs;

                                #ifndef DEF_Node_EKPivabdlel
                                #define DEF_Node_EKPivabdlel
struct Node_EKPi
{
                                // shape_hash:    878398e93fb5b47f
                                // non_triv_mask: 0000800000000010
    fu::str kind;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_nVJscNB67u0
                                #define DEF_SolvedNode_nVJscNB67u0
struct SolvedNode_nVJs
{
                                // shape_hash:    994ff598a7058a50
                                // non_triv_mask: 0000802000000000
    fu::str kind;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<SolvedNode_nVJs> solveNodes_MbR9(/*1:1*/ fu::view<Node_EKPi> n)
{
    /*MOV*/ fu::vec<SolvedNode_nVJs> r {};
    for (int i = 0; i < n.size(); i++)
    {
        r += SolvedNode_nVJs { fu::str(n[i].kind) };
    };
    return /*NRVO*/ r;
}

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_Only_70FDbGCtjV3
                                #define DEF_Only_70FDbGCtjV3
inline static const SolvedNode_nVJs& Only_70FD(/*1:1*/ fu::view<SolvedNode_nVJs> s)
{
    if (s.size() == 1)
        return s[0];
    else
        fu::fail(x7E_rA00("len != 1: "_view, fu::i64dec(s.size())));

}
                                #endif

static SolvedNode_nVJs solveDeclExpr_MbR9(/*1:1*/ const Node_EKPi& n)
{
    const SolvedNode_nVJs* _0;
    return SolvedNode_nVJs((*(_0 = &(Only_70FD(solveNodes_MbR9(fu::view<Node_EKPi> {{ Node_EKPi(n) }})))) ? *_0 : fu::fail(fu::str("!only"_fu))));
}

int fu_MAIN()
{
    return solveDeclExpr_MbR9(Node_EKPi { fu::str("a"_fu) }).kind.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        pub fn test(x: i32): i32[] { // !N_NonTrivAutoCopy
            mut a = [ 4 ];
            mut b = [ 5 ];
            mut c = [ 6 ];

            for (mut i = 0; i < x; i++) {
                a.unshift(x);
                b.unshift(x);
                c.unshift(x);
            }

            inline fn which() {
                return :test x & 1 ? a : b;
            }

            if !(x & 2)
                return which();

            return c;
        }

        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

fu::vec<int> test_MbR9(const int x)
{
    /*MOV*/ fu::vec<int> a = fu::vec<int> {{ 4 }};
    /*MOV*/ fu::vec<int> b = fu::vec<int> {{ 5 }};
    /*MOV*/ fu::vec<int> c = fu::vec<int> {{ 6 }};
    for (int i = 0; i < x; i++)
    {
        a.unshift(x);
        b.unshift(x);
        c.unshift(x);
    };
    if (!(x & 2))
    {
        if (x & 1)
            return /*NRVO*/ a;
        else
            return /*NRVO*/ b;

    }
    else
        return /*NRVO*/ c;

}

int fu_MAIN()
{
    return (test_MbR9(2)[2] + test_MbR9(1)[1]) - (2 * test_MbR9(0)[0]);
}

#endif

int main() { return fu_MAIN(); }

========

        fn incr_x_to_1(ref x: i32) {
            x && throw("this reports return t_never");
            fn incr_x() { return x++; }
            incr_x();
        }
        fn main() {
            mut x = 0;
            incr_x_to_1(x);
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/init_priority.h>


                                #ifndef STR_BMC3tuHASr7
                                #define STR_BMC3tuHASr7
static const fu::str str_BMC3tuHASr7 fu_INIT_PRIORITY(1001) { "this reports return t_never"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int incr_x_MbR9(/*1:1*/ int& x)
{
    return x++;
}

static void incr_x_to_1_MbR9(/*1:1*/ int& x)
{
    if (x)
        fu::fail(fu::str(str_BMC3tuHASr7));
    else
        incr_x_MbR9(x);

}

int fu_MAIN()
{
    int x = 0;
    incr_x_to_1_MbR9(x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut x = 0;
            fn incr_x_to_1() {
                x && throw("this reports return t_never");
                fn incr_x() { return x++; }
                incr_x();
            }
            incr_x_to_1();
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/init_priority.h>


                                #ifndef STR_BMC3tuHASr7
                                #define STR_BMC3tuHASr7
static const fu::str str_BMC3tuHASr7 fu_INIT_PRIORITY(1001) { "this reports return t_never"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int incr_x_MbR9(/*1:1*/ int& x)
{
    return x++;
}

static void incr_x_to_1_MbR9(/*1:1*/ int& x)
{
    if (x)
        fu::fail(fu::str(str_BMC3tuHASr7));
    else
        incr_x_MbR9(x);

}

int fu_MAIN()
{
    int x = 0;
    incr_x_to_1_MbR9(x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn apply(fn, v) fn(v);
        fn main() {
            mut x = 0;
            fn scope_using(via: i32) {
                x && throw("this reports return t_never");
                // which messed up retcount for scope_using
                fn visit(item: i32) {
                    if (item) return item;
                    return x++;
                }
                apply(fn visit, via);
            }

            scope_using(x);
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/init_priority.h>


                                #ifndef STR_BMC3tuHASr7
                                #define STR_BMC3tuHASr7
static const fu::str str_BMC3tuHASr7 fu_INIT_PRIORITY(1001) { "this reports return t_never"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int visit_MbR9(const int item, /*3:3*/ int& x)
{
    if (item)
        return item;
    else
        return x++;

}

                                #ifndef DEF_apply_qR80s7l0rij
                                #define DEF_apply_qR80s7l0rij
inline static int apply_qR80(const int v, /*7:7*/ int& x)
{
    return visit_MbR9(v, x);
}
                                #endif

static void scope_using_MbR9(const int via, /*3:3*/ int& x)
{
    if (x)
        fu::fail(fu::str(str_BMC3tuHASr7));
    else
        apply_qR80(via, x);

}

int fu_MAIN()
{
    int x = 0;
    scope_using_MbR9(x, x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()   
            010     
                == 8 ? 0 : 1;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+1[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m0[0m10     
[2m      |                 == 8 ? 0 : 1;[0m
[2m      | [0m

	Leading zero in numeric literal, perhaps you meant 0x, 0b or 0o.

========

        fn main()   
            0o10    
                == 8 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (010u == 8u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        fn main() 0x101 == 257 ? 0 : 1; 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0x101u == 257u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        fn main() 0o101 ==  65 ? 0 : 1; 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0101u == 65u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        fn main() 0b101 ==   5 ? 0 : 1; 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0b101u == 5u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main()
            i32(f64.PI * 2.0) - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((static_cast<double>(M_PI) * 2.0)) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()
            i32(f64.PI * 2 - 6);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()
            f64.PI * 2 - 6 |> i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main()
            i32 <| f64.PI * 2 - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

========

        let x: f32 = 1; fn main() 1 - x.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr float x = 1.0f;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let x: f32 = 1.0; fn main() 1 - x.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr float x = 1.0f;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let x: u8 = 1; fn main() 1 - x.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


                                #ifndef DEF_x
                                #define DEF_x
inline constexpr fu::u8 x = fu::u8(1u);
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 1 - int(unsigned(x));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let x = 1.f32; fn main() 1 - x.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static const float x = float(1);

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn gt0(x: f32) x > 0;
        fn main() gt0(1.f32) ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static bool gt0_MbR9(const float x)
{
    return x > 0.0f;
}

int fu_MAIN()
{
    if (gt0_MbR9(float(1)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Hey { x: f32; };
        fn hey() Hey(1);
        fn main() hey.x.i32 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_OFug;

                                #ifndef DEF_Hey_OFugmXf8IAa
                                #define DEF_Hey_OFugmXf8IAa
struct Hey_OFug
{
                                // shape_hash:    8dd9e34b6ef7f5b7
                                // non_triv_mask: 0000000000000000
    float x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Hey_OFug hey_MbR9()
{
    return Hey_OFug { 1.0f };
}

int fu_MAIN()
{
    return int(hey_MbR9().x) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);
        fn main() {
            let v = test(1);
            return (v.x + v.z).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static vec3_vMFc test_MbR9(const int i)
{
    return vec3_vMFc { float((i - 2)), 0.0f, 1.0f };
}

int fu_MAIN()
{
    const vec3_vMFc v = test_MbR9(1);
    return int((v.x + v.z));
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(f: f32) vec3(x: f, z: -1);
        fn main() {
            let v = test(-1);
            return (v.x - v.z).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static vec3_vMFc test_MbR9(const float f)
{
    return vec3_vMFc { f, 0.0f, -1.0f };
}

int fu_MAIN()
{
    const vec3_vMFc v = test_MbR9(-1.0f);
    return int((v.x - v.z));
}

#endif

int main() { return fu_MAIN(); }

========

        fn hey(i: f32) i.f32 + 0.5;
        fn main() hey(1).i32 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static float hey_MbR9(const float i)
{
    return float(i) + 0.5f;
}

int fu_MAIN()
{
    return int(hey_MbR9(1.0f)) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn lin2srgb(l: f32): f32
            l <= 0.0031308
                ? l * 12.92
                : 1.055 * pow(l, 1/2.4.f32) - 0.055;

        fn lin255(v: f32) u32 <|
            v.lin2srgb.max(0).min(1) * 255.99;

        fn main() i32 <|
            lin255(1) - 255;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cmath>


#ifndef fu_NO_fdefs

static float lin2srgb_MbR9(const float l)
{
    if ((l <= 0.0031308f))
        return l * 12.92f;
    else
        return (1.055f * std::pow(l, (1.0f / float(2.4)))) - 0.055f;

}

static unsigned lin255_MbR9(const float v)
{
    return unsigned((std::fmax(std::fmin(lin2srgb_MbR9(v), 0.0f), 1.0f) * 255.99f));
}

int fu_MAIN()
{
    return int((lin255_MbR9(1.0f) - 255u));
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x?: f32; y?: f32; z?: f32; };

        inline fn /(a: f32, b: vec3)
            vec3(a / b.x, a / b.y, a / b.z);

        fn main() i32 <|
            (1/vec3(x: 1)).x - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_vMFc;

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    float a;
    vec3_vMFc b;
    return int(((a = 1.0f, b = vec3_vMFc { 1.0f, {/*unused non-zst*/}, {/*unused non-zst*/} }, vec3_vMFc { (a / b.x), {/*unused non-zst*/}, {/*unused non-zst*/} }).x - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        let QUAD_DATA: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
            -1, +1, 0,      0, 0, 1,    0, 1, 0,

            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
        ];

        fn main() QUAD_DATA.len - 6 * 9;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(240) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<float> QUAD_DATA fu_INIT_PRIORITY(1001) = fu::vec<float> {{ -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, -1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, +1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f }};

int fu_MAIN()
{
    return QUAD_DATA.size() - (6 * 9);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn test(a: bool): u8 = a ? 1 : 0;

        fn main() test(false).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

static fu::u8 test_MbR9(const bool a)
{
    if (a)
        return fu::u8(1u);
    else
        return fu::u8(0u);

}

int fu_MAIN()
{
    return int(unsigned(test_MbR9(false)));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a: bool): u8 = a && 1;

        fn main() test(false).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

static fu::u8 test_MbR9(const bool a)
{
    if (a)
        return fu::u8(1u);
    else
        return fu::u8(0u);

}

int fu_MAIN()
{
    return int(unsigned(test_MbR9(false)));
}

#endif

int main() { return fu_MAIN(); }

========

        pub let A_u8: u8 = 0x0;

        fn ATTRIB(type: u8, count: i32, srgb = false): u8
            = type & 0x3 | count.u8 << 2

            // TODO can't deep-retype the last cast unfortunately:
            //  we need another hint to drive typing here,
            //   perhaps monogenous signatures, or else.
            | (srgb && 0x80.u8);

        fn main() ATTRIB(A_u8, 4).i32 - 16;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


                                #ifndef DEF_A_u8
                                #define DEF_A_u8
inline constexpr fu::u8 A_u8 = fu::u8(0x0u);
                                #endif

#ifndef fu_NO_fdefs

static fu::u8 ATTRIB_MbR9(const fu::u8 type, const int count, const bool srgb)
{
    return fu::u8((fu::u8((type & fu::u8(0x3u))) | fu::u8((fu::u8(unsigned(count)) << fu::u8(2u))))) | (srgb ? fu::u8(0x80u) : fu::u8(0u));
}

int fu_MAIN()
{
    return int(unsigned(ATTRIB_MbR9(A_u8, 4, false))) - 16;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        pub struct Geometry    { g: i32; };
        pub struct Texture     { t: i32; };
        pub struct RenderFrame { r: i32; };

        pub struct LogicFrame_in
        {
            lastLogic:  LogicFrame;
        };

        pub struct LogicFrame
        {
            DATA_fbx:   Geometry;
            TEX_A:      Texture;
            TEX_AO:     Texture;
            TEX_M:      Texture;
            TEX_N:      Texture;
            TEX_R:      Texture;
            HDR:        Texture;
        };

        pub struct RenderFrame_in
        {
            w:          i16;
            h:          i16;
            frame:      i32;

            mouseX:     f32;
            mouseY:     f32;
            mouseBtns:  i32;

            using logic:    LogicFrame;
            lastRender:     RenderFrame;
        };

        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame
        {
            return RenderFrame(args.HDR.t);
        }

        fn main() 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct RenderFrame_Rb90;
struct RenderFrame_in_WoPA;
struct LogicFrame_gCMh;
struct Geometry_YDvm;
struct Texture_bKVj;

                                #ifndef DEF_RenderFrame_Rb90FDvSbe2
                                #define DEF_RenderFrame_Rb90FDvSbe2
struct RenderFrame_Rb90
{
                                // shape_hash:    37ffd7c455a16f91
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_Texture_bKVjw47EOob
                                #define DEF_Texture_bKVjw47EOob
struct Texture_bKVj
{
                                // shape_hash:    bb81ae295d839c48
                                // non_triv_mask: 0000000000000000
    int t;
    explicit operator bool() const noexcept
    {
        return false
            || t
        ;
    }
};
                                #endif

                                #ifndef DEF_Geometry_YDvm42z1t78
                                #define DEF_Geometry_YDvm42z1t78
struct Geometry_YDvm
{
                                // shape_hash:    abbb54b97cd759e5
                                // non_triv_mask: 0000000000000000
    int g;
    explicit operator bool() const noexcept
    {
        return false
            || g
        ;
    }
};
                                #endif

                                #ifndef DEF_LogicFrame_gCMhzPfAum4
                                #define DEF_LogicFrame_gCMhzPfAum4
struct LogicFrame_gCMh
{
                                // shape_hash:    c007e142ac0f0d23
                                // non_triv_mask: 0000000000000000
    Geometry_YDvm DATA_fbx;
    Texture_bKVj TEX_A;
    Texture_bKVj TEX_AO;
    Texture_bKVj TEX_M;
    Texture_bKVj TEX_N;
    Texture_bKVj TEX_R;
    Texture_bKVj HDR;
    explicit operator bool() const noexcept
    {
        return false
            || DATA_fbx
            || TEX_A
            || TEX_AO
            || TEX_M
            || TEX_N
            || TEX_R
            || HDR
        ;
    }
};
                                #endif

                                #ifndef DEF_RenderFrame_in_WoPApxqtRrd
                                #define DEF_RenderFrame_in_WoPApxqtRrd
struct RenderFrame_in_WoPA
{
                                // shape_hash:    623fa3759b647ac9
                                // non_triv_mask: 0000000000000000
    short w;
    short h;
    int frame;
    float mouseX;
    float mouseY;
    int mouseBtns;
    LogicFrame_gCMh logic;
    RenderFrame_Rb90 lastRender;
    explicit operator bool() const noexcept
    {
        return false
            || w
            || h
            || frame
            || mouseX
            || mouseY
            || mouseBtns
            || logic
            || lastRender
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

RenderFrame_Rb90 APP_renderFrame_MbR9(/*1:1*/ const RenderFrame_in_WoPA& args)
{
    return RenderFrame_Rb90 { args.logic.HDR.t };
}

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;
        fn main() "hello".leadingDigit.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static bool leadingDigit_MbR9(/*1:1*/ fu::view<char> name)
{
    return fu::u8((fu::u8(fu::u8(name[0])) - fu::u8(fu::u8('0')))) < fu::u8(10u);
}

int fu_MAIN()
{
    return int(leadingDigit_MbR9("hello"_view));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() 1_000_000 - 1000000
               || 0xffff_ffff.i32 - 0xffffffff.i32
               || 123_456.789.i32 - 123456.789.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int _0;
    return (_0 = (1000000 - 1000000)) ? _0 : (_0 = (int(0xffffffffu) - int(0xffffffffu))) ? _0 : (int(123456.789) - int(123456.789));
}

#endif

int main() { return fu_MAIN(); }

========
                                  // litfix through && /////
        fn test(a: u32, shadows: bool)      (a << 1) | (shadows && 1);
        fn main()                           test(1, true).i32 - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static unsigned test_MbR9(const unsigned a, const bool shadows)
{
    return (a << 1u) | (shadows ? 1u : 0u);
}

int fu_MAIN()
{
    return int(test_MbR9(1u, true)) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;
        inline fn len(a: vec3) a.lensq.sqrt;

        inline fn norm(a: vec3) {
            mut n = 1 / a.len;
            n = n.finite ? n : 0;
            return a * n;
        }

        inline fn test(ref v) {
            v = v.norm();
            return v.len;
        }

        fn main() {
            mut v = _0::vec3(2, 0, 0);
            return v.test() == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cmath>

struct vec3_vMFc;

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    vec3_vMFc v = vec3_vMFc { 2.0f, 0.0f, 0.0f };
    const vec3_vMFc* a;
    float n;
    float b;
    const vec3_vMFc* a_1;
    if (((v = (a = &(v), n = (1.0f / std::sqrt(((((*a).x * (*a).x) + ((*a).y * (*a).y)) + ((*a).z * (*a).z)))), (n = (std::isfinite(n) ? n : 0.0f)), b = n, vec3_vMFc { ((*a).x * b), ((*a).y * b), ((*a).z * b) })), a_1 = &(v), std::sqrt(((((*a_1).x * (*a_1).x) + ((*a_1).y * (*a_1).y)) + ((*a_1).z * (*a_1).z)))) == 1.0f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn sub15(x: i32) x - 15;
        fn main() 0xf.sub15;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sub15_MbR9(const int x)
{
    return x - 15;
}

int fu_MAIN()
{
    return sub15_MbR9(0xf);
}

#endif

int main() { return fu_MAIN(); }

========

        fn pick(albedo: i32 = 0x12345678, shift = 16)
            albedo >> shift & 0xf;
        fn main()
            pick() == 4 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int pick_MbR9(const int albedo, const int shift)
{
    return (albedo >> shift) & 0xf;
}

int fu_MAIN()
{
    if (pick_MbR9(0x12345678, 16) == 4)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() abs(-19191) - 19191
                + abs(+72713) - 72713;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_abs_NHZZYqEtT21
                                #define DEF_abs_NHZZYqEtT21
inline int abs_NHZZ(const int v)
{
    if (v < 0)
        return -v;
    else
        return v;

}
                                #endif

int fu_MAIN()
{
    return ((abs_NHZZ(-19191) - 19191) + abs_NHZZ(+72713)) - 72713;
}

#endif

int main() { return fu_MAIN(); }

========

        fn litfix_order!T(a: T, b: T) = a * 2 + b * 3;
        fn main() = litfix_order(0.5, 2) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_litfix_order_0Y2A19tBge3
                                #define DEF_litfix_order_0Y2A19tBge3
inline static double litfix_order_0Y2A(const double a, const double b)
{
    return (a * 2.0) + (b * 3.0);
}
                                #endif

int fu_MAIN()
{
    if (litfix_order_0Y2A(0.5, 2.0) == 7.0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn litfix_order!T(a: T, b: T) = a * 3 + b * 2;
        fn main() = litfix_order(2, 0.5) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_litfix_order_3WMYFaNJ4hk
                                #define DEF_litfix_order_3WMYFaNJ4hk
inline static double litfix_order_3WMY(const double a, const double b)
{
    return (a * 3.0) + (b * 2.0);
}
                                #endif

int fu_MAIN()
{
    if (litfix_order_3WMY(2.0, 0.5) == 7.0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn litfix_order!T(a: T, b: T) = a * 2 + b * 3;
        fn main() = litfix_order(a: 0.5, b: 2) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_litfix_order_0Y2A19tBge3
                                #define DEF_litfix_order_0Y2A19tBge3
inline static double litfix_order_0Y2A(const double a, const double b)
{
    return (a * 2.0) + (b * 3.0);
}
                                #endif

int fu_MAIN()
{
    if (litfix_order_0Y2A(0.5, 2.0) == 7.0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn litfix_order!T(a: T, b: T) = a * 3 + b * 2;
        fn main() = litfix_order(a: 2, b: 0.5) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_litfix_order_3WMYFaNJ4hk
                                #define DEF_litfix_order_3WMYFaNJ4hk
inline static double litfix_order_3WMY(const double a, const double b)
{
    return (a * 3.0) + (b * 2.0);
}
                                #endif

int fu_MAIN()
{
    if (litfix_order_3WMY(2.0, 0.5) == 7.0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn why_doesnt_this_match(list: <T>[], other: T[]) list ~ other;
        fn main() why_doesnt_this_match([ 1, 2, 3 ], []).len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_why_doesnt_this_match_LU244OH3yx7
                                #define DEF_why_doesnt_this_match_LU244OH3yx7
inline static fu::vec<int> why_doesnt_this_match_LU24(/*3:3*/ fu::view<int> list, /*3:3*/ fu::view<int> other)
{
    return list + other;
}
                                #endif

int fu_MAIN()
{
    return why_doesnt_this_match_LU24(fu::view<int> {{ 1, 2, 3 }}, fu::view<int>{}).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn why_doesnt_this_match(list: <T>[], other: T[..]) list ~ other;
        fn main() why_doesnt_this_match([ 1, 2, 3 ], []).len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_why_doesnt_this_match_LU244OH3yx7
                                #define DEF_why_doesnt_this_match_LU244OH3yx7
inline static fu::vec<int> why_doesnt_this_match_LU24(/*3:3*/ fu::view<int> list, /*3:3*/ fu::view<int> other)
{
    return list + other;
}
                                #endif

int fu_MAIN()
{
    return why_doesnt_this_match_LU24(fu::view<int> {{ 1, 2, 3 }}, fu::view<int>{}).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn why_doesnt_this_match(list: <T>[..], other: T[]) list ~ other;
        fn main() why_doesnt_this_match([ 1, 2, 3 ], []).len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_why_doesnt_this_match_LU244OH3yx7
                                #define DEF_why_doesnt_this_match_LU244OH3yx7
inline static fu::vec<int> why_doesnt_this_match_LU24(/*3:3*/ fu::view<int> list, /*3:3*/ fu::view<int> other)
{
    return list + other;
}
                                #endif

int fu_MAIN()
{
    return why_doesnt_this_match_LU24(fu::view<int> {{ 1, 2, 3 }}, fu::view<int>{}).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn why_doesnt_this_match(list: <T>[..], other: T[..]) list ~ other;
        fn main() why_doesnt_this_match([ 1, 2, 3 ], []).len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_why_doesnt_this_match_LU244OH3yx7
                                #define DEF_why_doesnt_this_match_LU244OH3yx7
inline static fu::vec<int> why_doesnt_this_match_LU24(/*3:3*/ fu::view<int> list, /*3:3*/ fu::view<int> other)
{
    return list + other;
}
                                #endif

int fu_MAIN()
{
    return why_doesnt_this_match_LU24(fu::view<int> {{ 1, 2, 3 }}, fu::view<int>{}).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        let glsl_what = [ 1, 2, 3 ] ~ [];
        fn main() glsl_what.len - 3;

---- <fail> ----
[2m[0m_0[2m.fu 2:37+1[0m:

[2m      | [0m
[2m    2 | [0m        let glsl_what = [ 1, 2, 3 ] [31;1m~[0m [];
[2m      |         fn main() glsl_what.len - 3;[0m
[2m      | [0m

	Ambiguous call to [94;1m~[0m with args ([35;3mi32[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");


========

        let glsl_what = [ 1, 2, 3 ] ~ [];
        fn main() glsl_what.len - 3;

---- <fail> ----
[2m[0m_0[2m.fu 2:37+1[0m:

[2m      | [0m
[2m    2 | [0m        let glsl_what = [ 1, 2, 3 ] [31;1m~[0m [];
[2m      |         fn main() glsl_what.len - 3;[0m
[2m      | [0m

	Ambiguous call to [94;1m~[0m with args ([35;3malways-true[0m [35;3mi32[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 481:10+1[0m:
[2m  481 | [0minfix fn [31;1m~[0m (a: <T>    , b: T[..]): T[] __native("<fu/vec/concat_one.h>", "+");

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +[0m at [2m../../../../../[0mprelude[2m 480:10+1[0m:
[2m  480 | [0minfix fn [31;1m~[0m (a: <T>[..], b: T    ): T[] __native("<fu/vec/concat_one.h>", "+");


========

        let glsl_what = [ 1, 2, 3 ] ~ int[];
        fn main() glsl_what.len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_typeof_WBXNnHZQ6al
                                #define DEF_typeof_WBXNnHZQ6al
inline fu::vec<int> typeof_WBXN()
{
    return fu::vec<int>{};
}
                                #endif

                                #ifndef DEF_x5Bx5D_Azh1AWh7LJe
                                #define DEF_x5Bx5D_Azh1AWh7LJe
inline fu::vec<int> x5Bx5D_Azh1()
{
    return typeof_WBXN();
}
                                #endif

static const fu::vec<int> glsl_what fu_INIT_PRIORITY(1001) = (fu::view<int> {{ 1, 2, 3 }} + x5Bx5D_Azh1());

int fu_MAIN()
{
    return glsl_what.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn must_not_match(other: 
                                 string) "Hello" ~ other;

        fn main() must_not_match(false && '!').len - 6;         // !DEV_DontFoldLiterals

---- <fail> ----
[2m[0m_0[2m.fu 5:19+14[0m:

[2m      |                                  string) "Hello" ~ other;[0m
[2m      | [0m
[2m    5 | [0m        fn main() [31;1mmust_not_match[0m(false && '!').len - 6;         // !DEV_DontFoldLiterals
[2m      | [0m

	Bad call to [94;1mmust_not_match[0m with args ([35;3malways-false[0m [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mmust_not_match[0m at [2m2:12+14[0m:
[2m    2 | [0m        fn [31;1mmust_not_match[0m(other: 

	    [35;3marg[0m [94;1mmust_not_match[0m:[94;1mother[0m expects [35;3mstring[0m, got [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn must_not_match(other: 
                                 byte  ) "Hello" ~ other;

        fn main() must_not_match(false && '!').len - 6;         // !DEV_DontFoldLiterals

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str must_not_match_MbR9(const char other)
{
    return "Hello"_view + other;
}

int fu_MAIN()
{
    return must_not_match_MbR9(char{}).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn must_not_match(other: 
                                 byte  ) "Hello" ~ other;

        fn main() must_not_match(false && "!").len - 5;         // !DEV_DontFoldLiterals

---- <fail> ----
[2m[0m_0[2m.fu 5:19+14[0m:

[2m      |                                  byte  ) "Hello" ~ other;[0m
[2m      | [0m
[2m    5 | [0m        fn main() [31;1mmust_not_match[0m(false && "!").len - 5;         // !DEV_DontFoldLiterals
[2m      | [0m

	Bad call to [94;1mmust_not_match[0m with args ([35;3malways-false[0m [35;3mstring[0m): 

	[35;3mfn[0m [94;1mmust_not_match[0m at [2m2:12+14[0m:
[2m    2 | [0m        fn [31;1mmust_not_match[0m(other: 

	    [35;3marg[0m [94;1mmust_not_match[0m:[94;1mother[0m expects [35;3mbyte[0m, got [35;3mstring[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn must_not_match(other: 
                                 string) "Hello" ~ other;

        fn main() must_not_match(false && "!").len - 5;         // !DEV_DontFoldLiterals

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str must_not_match_MbR9(/*1:1*/ fu::view<char> other)
{
    return "Hello"_view + other;
}

int fu_MAIN()
{
    return must_not_match_MbR9(fu::view<char>{}).size() - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn must_not_match(hello: <T>[..], other: 
                                                 T[..]) hello ~ other;

        fn main() must_not_match("Hello", 0 && '!').len - 6;    // !DEV_DontFoldLiterals

---- <fail> ----
[2m[0m_0[2m.fu 5:19+14[0m:

[2m      |                                                  T[..]) hello ~ other;[0m
[2m      | [0m
[2m    5 | [0m        fn main() [31;1mmust_not_match[0m("Hello", 0 && '!').len - 6;    // !DEV_DontFoldLiterals
[2m      | [0m

	Bad call to [94;1mmust_not_match[0m with args ([35;3malways-true[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mbyte[0m): 

	[35;3mtemplate[0m [94;1mmust_not_match[0m at [2m2:12+14[0m:
[2m    2 | [0m        fn [31;1mmust_not_match[0m(hello: <T>[..], other: 

	    [35;3marg[0m [94;1mmust_not_match[0m:[94;1mother[0m:
	    Not sliceable: [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn must_not_match(hello: <T>[..], other: 
                                                 T    ) hello ~ other;

        fn main() must_not_match("Hello", 0 && '!').len - 6;    // !DEV_DontFoldLiterals

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_must_not_match_6Dtj0AUYylj
                                #define DEF_must_not_match_6Dtj0AUYylj
inline static fu::str must_not_match_6Dtj(/*3:3*/ fu::view<char> hello, const char other)
{
    return hello + other;
}
                                #endif

int fu_MAIN()
{
    return must_not_match_6Dtj("Hello"_view, char{}).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn must_not_match(hello: <T>[..], other: 
                                                 T    ) hello ~ other;

        fn main() must_not_match("Hello", 0 && "!").len - 5;    // !DEV_DontFoldLiterals

---- <fail> ----
[2m[0m_0[2m.fu 5:19+14[0m:

[2m      |                                                  T    ) hello ~ other;[0m
[2m      | [0m
[2m    5 | [0m        fn main() [31;1mmust_not_match[0m("Hello", 0 && "!").len - 5;    // !DEV_DontFoldLiterals
[2m      | [0m

	Bad call to [94;1mmust_not_match[0m with args ([35;3malways-true[0m [35;3mstring[0m, [35;3malways-false[0m [35;3mstring[0m): 

	[35;3mtemplate[0m [94;1mmust_not_match[0m at [2m2:12+14[0m:
[2m    2 | [0m        fn [31;1mmust_not_match[0m(hello: <T>[..], other: 

	    [35;3marg[0m [94;1mmust_not_match[0m:[94;1mhello[0m:
	    Incompatible types for [31;1mT[0m: [35;3mstring[0m -> [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn must_not_match(hello: <T>[..], other: 
                                                 T[..]) hello ~ other;

        fn main() must_not_match("Hello", 0 && "!").len - 5;    // !DEV_DontFoldLiterals

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_must_not_match_rA003L6Quul
                                #define DEF_must_not_match_rA003L6Quul
inline static fu::str must_not_match_rA00(/*3:3*/ fu::view<char> hello, /*3:3*/ fu::view<char> other)
{
    return hello + other;
}
                                #endif

int fu_MAIN()
{
    return must_not_match_rA00("Hello"_view, fu::view<char>{}).size() - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS && "B ") ~ "C";
        fn main() glsl_what.len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef DEF_USE_MIPMAPS
                                #define DEF_USE_MIPMAPS
inline constexpr bool USE_MIPMAPS = false;
                                #endif

#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + (USE_MIPMAPS ? "B "_view : fu::view<char>{})) + "C"_view);

int fu_MAIN()
{
    return glsl_what.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS && "B ") ~ "C";
        fn main() glsl_what.len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + fu::view<char>{}) + "C"_view);

int fu_MAIN()
{
    return glsl_what.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS && 'B') ~ " C";
        fn main() glsl_what == "A \0 C" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_USE_MIPMAPS
                                #define DEF_USE_MIPMAPS
inline constexpr bool USE_MIPMAPS = false;
                                #endif

#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + (USE_MIPMAPS ? 'B' : char{})) + " C"_view);

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (glsl_what == "A \x00 C"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let USE_MIPMAPS = false;
        let glsl_what = "A " ~ (USE_MIPMAPS && 'B') ~ " C";
        fn main() glsl_what == "A \0 C" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static const fu::str glsl_what fu_INIT_PRIORITY(1001) = (("A "_view + char{}) + " C"_view);

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (glsl_what == "A \x00 C"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        type Test = i32[];
        fn yo(t: Test) t[0] + t[1];
        fn main() yo([-1, +1]);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int yo_MbR9(/*1:1*/ fu::view<int> t)
{
    return t[0] + t[1];
}

int fu_MAIN()
{
    return yo_MbR9(fu::view<int> {{ -1, +1 }});
}

#endif

int main() { return fu_MAIN(); }

========

        fn ifFirst(a: $T[]) a && a[0];
        fn hello(a: i32[]) a.ifFirst;
        fn main() hello([ 3 ]) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_ifFirst_uSDsQwcba87
                                #define DEF_ifFirst_uSDsQwcba87
inline static int ifFirst_uSDs(/*1:1*/ fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}
                                #endif

static int hello_MbR9(/*1:1*/ fu::view<int> a)
{
    return ifFirst_uSDs(a);
}

int fu_MAIN()
{
    return hello_MbR9(fu::view<int> {{ 3 }}) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ifFirst(a: $T[]) a && a[0];
        type X = i32[];
        fn hello(a: X) a.ifFirst;
        fn main() hello([ 3 ]) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_ifFirst_uSDsQwcba87
                                #define DEF_ifFirst_uSDsQwcba87
inline static int ifFirst_uSDs(/*1:1*/ fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}
                                #endif

static int hello_MbR9(/*1:1*/ fu::view<int> a)
{
    return ifFirst_uSDs(a);
}

int fu_MAIN()
{
    return hello_MbR9(fu::view<int> {{ 3 }}) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ifFirst(a: $T[]) a && a[0];

        fn list(): i32[][] {
            return [[ 3 ]];
        }

        fn hello() list.ifFirst.ifFirst;
        fn main() hello - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> list_MbR9()
{
    return fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 3 }} }};
}

                                #ifndef DEF_ifFirst_IMiIgq6RhU0
                                #define DEF_ifFirst_IMiIgq6RhU0
inline static fu::vec_range<int> ifFirst_IMiI(/*1:1*/ fu::view<fu::vec<int>> a)
{
    if (a)
        return a[0];
    else
        return (*(fu::vec<int>*)fu::NIL);

}
                                #endif

                                #ifndef DEF_ifFirst_uSDsQwcba87
                                #define DEF_ifFirst_uSDsQwcba87
inline static int ifFirst_uSDs(/*1:1*/ fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}
                                #endif

static int hello_MbR9()
{
    return ifFirst_uSDs(ifFirst_IMiI(list_MbR9()));
}

int fu_MAIN()
{
    return hello_MbR9() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ifFirst(a: $T[]) a && a[0];
        type X = i32[];

        fn list(): X[] {
            return [[ 3 ]];
        }

        fn hello() list.ifFirst.ifFirst;
        fn main() hello - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> list_MbR9()
{
    return fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 3 }} }};
}

                                #ifndef DEF_ifFirst_IMiIgq6RhU0
                                #define DEF_ifFirst_IMiIgq6RhU0
inline static fu::vec_range<int> ifFirst_IMiI(/*1:1*/ fu::view<fu::vec<int>> a)
{
    if (a)
        return a[0];
    else
        return (*(fu::vec<int>*)fu::NIL);

}
                                #endif

                                #ifndef DEF_ifFirst_uSDsQwcba87
                                #define DEF_ifFirst_uSDsQwcba87
inline static int ifFirst_uSDs(/*1:1*/ fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}
                                #endif

static int hello_MbR9()
{
    return ifFirst_uSDs(ifFirst_IMiI(list_MbR9()));
}

int fu_MAIN()
{
    return hello_MbR9() - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        let arr = [1, 2];
        fn eq(a: i32[], b: i32[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<int> arr fu_INIT_PRIORITY(1001) = fu::vec<int> {{ 1, 2 }};

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

static bool eq_MbR9(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return a == b;
}

int fu_MAIN()
{
    if (eq_MbR9(arr, arr))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let arr = [1, 2];
        fn eq(a: $T[], b: $T[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<int> arr fu_INIT_PRIORITY(1001) = fu::vec<int> {{ 1, 2 }};

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

                                #ifndef DEF_eq_MoJJ2rYDHh3
                                #define DEF_eq_MoJJ2rYDHh3
inline static bool eq_MoJJ(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return a == b;
}
                                #endif

int fu_MAIN()
{
    if (eq_MoJJ(arr, arr))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            mut b = a[1.. ];
            mut c = a[ ..3];
            mut d = a[1..3];

            mut res = b ~ c ~ d;
            return res <> [ 2, 3, 4,  1, 2, 3,  2, 3 ];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1, 2, 3, 4 }};
    fu::view<int> /*a*/ b = fu::get_view(a, 1);
    fu::view<int> /*a*/ c = fu::get_view_start0(a, 3);
    fu::view<int> /*a*/ d = fu::get_view(a, 1, 3);
    fu::vec<int> res = ((b + c) + d);
    return x3Cx3E_2Y4m(res, fu::view<int> {{ 2, 3, 4, 1, 2, 3, 2, 3 }});
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            let str = "hello world";
            let s10 = str[..5] ~ str[6..];
            return s10.len - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ str = "hello world"_view;
    fu::str s10 = (fu::get_view_start0(str, 5) + fu::get_view(str, 6));
    return s10.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut strs = [ "hello", "world" ];
            let hello = strs[0];
            strs.insert(1,          
                hello.slice(0, 5)   
            );
            return strs.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::str> strs = fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("world"_fu) }};
    fu::vec_range<char> /*strs|static*/ hello = strs[0];
    strs.insert(1, fu::str(fu::get_range(hello, 0, 5)));
    return strs.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut strs = [ "hello", "world" ];
            let hello = strs[0];
            strs.insert(1,          
                hello[0..5]         
            );
            return strs.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::str> strs = fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("world"_fu) }};
    fu::vec_range<char> /*strs|static*/ hello = strs[0];
    strs.insert(1, fu::str(fu::get_range(hello, 0, 5)));
    return strs.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(hey: i32[..])
            hey[0] + hey[1];

        fn main()
            test([-1, +1]);

        // EXPECT fu::view<int> {{ -1, +1 }}

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view<int> hey)
{
    return hey[0] + hey[1];
}

int fu_MAIN()
{
    return test_MbR9(fu::view<int> {{ -1, +1 }});
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref hey: i32[..])
            hey[0] += hey[1];

        fn main() {
            mut hey = [-1, +1];
            return hey.test();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_kGbb(/*1:1*/ fu::view_mut<int> hey)
{
    return (hey.mutref(0) += hey[1]);
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> {{ -1, +1 }};
    return test_kGbb(hey);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(i: i32) [ i, i + 1 ];
        fn main() test(0)[1] - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static fu::vec<int> test_MbR9(const int i)
{
    return fu::vec<int> {{ i, (i + 1) }};
}

int fu_MAIN()
{
    return test_MbR9(0)[1] - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(hey: byte[])
            hey.view(u32)[0];

        fn main() {
            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];
            return (hey.test - 0x1010101).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static unsigned test_MbR9(/*1:1*/ fu::vec_range<char> hey)
{
    return fu::view_of<unsigned>(hey)[0];
}

int fu_MAIN()
{
    fu::str hey = fu::vec<char> {{ char(1), char(1), char(1), char(1) }};
    return int((test_MbR9(hey) - 0x1010101u));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(hey: i32[..])
            hey[0] + hey[1];

        fn main() {
            let hey = [7, -1, +1];
            return test(hey[1 .. 3]);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ fu::view<int> hey)
{
    return hey[0] + hey[1];
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> {{ 7, -1, +1 }};
    return test_MbR9(fu::get_view(hey, 1, 3));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref hey: i32[..])
            hey[0] += hey[1];

        fn main() {
            mut hey = [7, -1, +1];
            return hey[1 .. 3].test();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_kGbb(/*1:1*/ fu::view_mut<int> hey)
{
    return (hey.mutref(0) += hey[1]);
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> {{ 7, -1, +1 }};
    return test_kGbb(fu::get_view_mut(hey, 1, 3));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref hey: i32[..])
            hey.= [2, -3];

        fn main() {
            mut hey = [1, 0, 0];
            test(hey[1 .. 3]);
            return hey[0] + hey[1] + hey[2];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::view_mut<int> hey)
{
    fu::view_assign(hey, fu::view<int> {{ 2, -3 }});
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> {{ 1, 0, 0 }};
    test_MbR9(fu::get_view_mut(hey, 1, 3));
    return (hey[0] + hey[1]) + hey[2];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Hey {
            i: i32;
        };

        fn test(ref out: Hey[]) {
            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];
        }

        fn main() {
            mut a = [ Hey ];
            a.test();
            return a[0].i - 16843009;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/view_assign.h>

struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<Hey_Nwzp> out)
{
    fu::view_assign(fu::view_of_mut<fu::u8>(out), fu::view<fu::u8> {{ fu::u8(unsigned(1)), fu::u8(unsigned(1)), fu::u8(unsigned(1)), fu::u8(unsigned(1)) }});
}

int fu_MAIN()
{
    fu::vec<Hey_Nwzp> a = fu::vec<Hey_Nwzp> {{ Hey_Nwzp{} }};
    test_MbR9(a);
    return a[0].i - 16843009;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Hey {
            i: i32;
        };

        fn test(ref x: i32[], y: Hey[])
            x .= y.view(i32);

        fn main() {
            mut a = [ 0 ];
            test(a, [ Hey(13) ]);
            return a[0] - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/view_assign.h>

struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::view_mut<int> x, /*3:3*/ fu::vec_range<Hey_Nwzp> y)
{
    fu::view_assign(x, fu::view_of<int>(y));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    test_MbR9(a, fu::vec<Hey_Nwzp> {{ Hey_Nwzp { 13 } }});
    return a[0] - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Hey {
            i: i32;
        };

        fn main() {
            mut a = [ 0 ];
            a .= [ Hey(13) ].view(i32);
            return a[0] - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>

struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0 }};
    fu::view_assign(a, fu::view_of<int>(fu::vec<Hey_Nwzp> {{ Hey_Nwzp { 13 } }}));
    return a[0] - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(a: byte[..], b?: byte[..]) a == b;
        fn main() test("") ? 0 : 1;

        // EXPECT (fu::view<char>{}, fu::view<char>{})

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool test_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a == b;
}

int fu_MAIN()
{
    if (test_MbR9(fu::view<char>{}, fu::view<char>{}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // The slice() should relax to a get_view, which doesnt need annot to be a string.
        //  We generally want to remove the distinction between slice(a,b) and [a:b] altogether.
        //
        let NOTES = [ "AAA", "BBB", "CCC" ];
        novec fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
        fn main() what("!BBB") - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<fu::str> NOTES fu_INIT_PRIORITY(1001) = fu::vec<fu::str> {{ fu::str("AAA"_fu), fu::str("BBB"_fu), fu::str("CCC"_fu) }};

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_find_cVszpoH03s0
                                #define DEF_find_cVszpoH03s0
inline int find_cVsz(/*F:F*/ fu::view<fu::str> haystack, /*F:F*/ fu::view<char> needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static int what_MbR9(/*1:1*/ fu::view<char> annot)
{
    return find_cVsz(NOTES, fu::get_view(annot, 1, annot.size()));
}

int fu_MAIN()
{
    return what_MbR9("!BBB"_view) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_SD_HasStaticInit

========

        fn Join(a: $T[][], lax sep = [])            // The sep is of type any-init.
        {                                           //
            if (a.len < 2)                          //
                return a.len && a[0];               // NOT SURE WHAT'S 100% IDEAL, BUT:
                                                    //
            let N = typeof(sep) -> $T[..] ? sep.len // should either match here,
                  : typeof(sep) -> $T     ? 1       //                                    but currently matches here, which is just wrong.
                                 : 0;               //                           or here,

            mut size = a[0].len;
            for (mut i = 1; i < a.len; i++)
                size += N + a[i].len;

            mut res: $T[];
            res.grow_junk(size);

            let head = a[0];
            size = head.len;
            res[.. head.len] .= head;
            for (mut i = 1; i < a.len; i++)
            {
                let range = a[i];
                if (typeof(sep) -> $T[..])
                    res[size .. size + N] .= sep;
                else if (typeof(sep) -> $T)
                    res[size] = sep;

                size += N;
                res[size .. size + range.len] .= range;
                size += range.len;
            }

            return res;
        }

        fn main() {
            let res = Join([ "hello", "world" ], []); // the [] fails the case above
            return res == "helloworld" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Join_QbuIaIZczPf
                                #define DEF_Join_QbuIaIZczPf
inline static fu::str Join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_QbuI(fu::view<fu::str> {{ fu::str("hello"_fu), fu::str("world"_fu) }});
    if (res == "helloworld"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        // one of these things reported there's no $S in scope.
        fn Join(a: $T, b: $T, lax sep: $S = [])
            case ($S -> $T || $S -> $T[..] || $S -> [])
        {
            return typeof(sep) -> $T || typeof(sep) -> $T[..]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Join_h9EVX8jNTBj
                                #define DEF_Join_h9EVX8jNTBj
inline static fu::str Join_h9EV(/*7:7*/ fu::view<char> a, /*7:7*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_h9EV("hello"_view, "world"_view);
    if (res == "helloworld"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // This is the initial type union concept
        fn Join(a: $T, b: $T, lax sep?: $T or $T[..] or [])
        {
            return typeof(sep) -> $T || typeof(sep) -> $T[..]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Join_h9EVX8jNTBj
                                #define DEF_Join_h9EVX8jNTBj
inline static fu::str Join_h9EV(/*7:7*/ fu::view<char> a, /*7:7*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_h9EV("hello"_view, "world"_view);
    if (res == "helloworld"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn Replace(str: $T[], all: $T or $T[..], with: $T or $T[..] or [])
            str.len + (typeof(all)  -> $T ? 1 : all.len)
                    + (typeof(with) -> [] ? 0 : typeof(with) -> $T ? 1 : with.len);

        fn main()
            "Hello".Replace(all: "ll", with: []) == 7 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Replace_SeDrVNhwoMh
                                #define DEF_Replace_SeDrVNhwoMh
inline static int Replace_SeDr(/*7:7*/ fu::view<char> str, /*7:7*/ fu::view<char> all)
{
    return (str.size() + all.size()) + 0;
}
                                #endif

int fu_MAIN()
{
    if (Replace_SeDr("Hello"_view, "ll"_view) == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn test(ref arr: i32[]) {
            while (arr.len < 10) arr.unshift(arr.len);
            while (arr.len < 20) arr.push(arr.len);
        }

        fn main() {
            mut arr = [ 1000, 2000, 3000 ];     
            test(arr[1 ..][.. 1]);              
            return arr == [ 1000, 9, 8, 7, 6, 5, 4, 3, 2, 1,
                            2000, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                            3000 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> arr)
{
    while (arr.size() < 10)
    {
        arr.unshift(arr.size());
    };
    while (arr.size() < 20)
        arr.push(arr.size());

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1000, 2000, 3000 }};
    test_MbR9(fu::get_range_start0_mut(fu::get_range_mut(arr, 1), 1));
    if (arr == fu::view<int> {{ 1000, 9, 8, 7, 6, 5, 4, 3, 2, 1, 2000, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 3000 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn test(ref arr: i32[]) {
            while (arr.len < 10) arr.unshift(arr.len);
            while (arr.len < 20) arr.push(arr.len);
        }

        fn main() {
            mut arr = [ 1000, 2000, 3000 ];     
            test(arr[1 .. 2]);                  
            return arr == [ 1000, 9, 8, 7, 6, 5, 4, 3, 2, 1,
                            2000, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                            3000 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ fu::vec_range_mut<int> arr)
{
    while (arr.size() < 10)
    {
        arr.unshift(arr.size());
    };
    while (arr.size() < 20)
        arr.push(arr.size());

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1000, 2000, 3000 }};
    test_MbR9(fu::get_range_mut(arr, 1, 2));
    if (arr == fu::view<int> {{ 1000, 9, 8, 7, 6, 5, 4, 3, 2, 1, 2000, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 3000 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn indirect_swap(ref a: i32[], ref b: i32[]) {
            swap(a, b);
        }

        fn main() {
            mut a = [ 0, 1, 2, 3, 4, 5 ];
            mut b = [ 6, 7, 8, 9 ];

            indirect_swap(a[1 .. 5], b[1 .. 3]);
            return (a ~ b) == [ 0, 7,8, 5, 6, 1,2,3,4, 9 ] ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void indirect_swap_MbR9(/*1:1*/ fu::vec_range_mut<int> a, /*2:2*/ fu::vec_range_mut<int> b)
{
    a.swap(b);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0, 1, 2, 3, 4, 5 }};
    fu::vec<int> b = fu::vec<int> {{ 6, 7, 8, 9 }};
    indirect_swap_MbR9(fu::get_range_mut(a, 1, 5), fu::get_range_mut(b, 1, 3));
    if ((a + b) == fu::view<int> {{ 0, 7, 8, 5, 6, 1, 2, 3, 4, 9 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn indirect_swap(ref a: i32[], ref b: i32[]) {
            swap(a, b);
        }

        fn main() {
            mut a = [ 0, 1, 2, 3, 4, 5 ];
            mut b = [ 6, 7, 8, 9 ];

            indirect_swap(a[1 .. 5], b);
            return (a ~ b) == [ 0, 6,7,8,9, 5, 1,2,3,4 ] ? 0 : 1;

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void indirect_swap_MbR9(/*1:1*/ fu::vec_range_mut<int> a, /*2:2*/ fu::vec_range_mut<int> b)
{
    a.swap(b);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 0, 1, 2, 3, 4, 5 }};
    fu::vec<int> b = fu::vec<int> {{ 6, 7, 8, 9 }};
    indirect_swap_MbR9(fu::get_range_mut(a, 1, 5), b);
    if ((a + b) == fu::view<int> {{ 0, 6, 7, 8, 9, 5, 1, 2, 3, 4 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn inject_via_empty_range(ref a: i32[]) {
            a.push(10);
            a.insert(a.len - 1, 20);
            a ~= [ 30, 40 ];
            a.splice(a.len - 2, 0, [ 50, 60 ]);
        }

        fn main() {
            mut a = [ 1000, 2000, 3000 ];           
            inject_via_empty_range(a[2 ..][.. 0]);  
            return a == [ 1000, 2000,
                            20, 10, 50, 60, 30, 40,
                          3000 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void inject_via_empty_range_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    a.push(10);
    a.insert((a.size() - 1), 20);
    a += fu::view<int> {{ 30, 40 }};
    a.splice((a.size() - 2), 0, fu::view<int> {{ 50, 60 }});
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1000, 2000, 3000 }};
    inject_via_empty_range_MbR9(fu::get_range_start0_mut(fu::get_range_mut(a, 2), 0));
    if (a == fu::view<int> {{ 1000, 2000, 20, 10, 50, 60, 30, 40, 3000 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn inject_via_empty_range(ref a: i32[]) {
            a.push(10);
            a.insert(a.len - 1, 20);
            a ~= [ 30, 40 ];
            a.splice(a.len - 2, 0, [ 50, 60 ]);
        }

        fn main() {
            mut a = [ 1000, 2000, 3000 ];           
            inject_via_empty_range(a[2 .. 2]);      
            return a == [ 1000, 2000,
                            20, 10, 50, 60, 30, 40,
                          3000 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void inject_via_empty_range_MbR9(/*1:1*/ fu::vec_range_mut<int> a)
{
    a.push(10);
    a.insert((a.size() - 1), 20);
    a += fu::view<int> {{ 30, 40 }};
    a.splice((a.size() - 2), 0, fu::view<int> {{ 50, 60 }});
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1000, 2000, 3000 }};
    inject_via_empty_range_MbR9(fu::get_range_mut(a, 2, 2));
    if (a == fu::view<int> {{ 1000, 2000, 20, 10, 50, 60, 30, 40, 3000 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { items: Node[] };
        noinline fn make(items?: Node[]) Node(:items);
        noinline fn items_len(n: Node) return n.items.len;

        fn main() _0::make.items_len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec_range.h>

struct Node_zYlo;
Node_zYlo make_MbR9(fu::vec_range<Node_zYlo>);
int items_len_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return items_len_MbR9(make_MbR9((*(fu::vec<Node_zYlo>*)fu::NIL)));
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Node_zYlo;

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Node_zYlo make_MbR9(/*1:1*/ fu::vec_range<Node_zYlo> items)
{
    return Node_zYlo { fu::vec<Node_zYlo>(items) };
}

int items_len_MbR9(/*1:1*/ const Node_zYlo& n)
{
    return n.items.size();
}

#endif

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy

========

        noinline fn move_from_slice(a: string, b: string) {
            mut c = a ~ b;
            return c[(a.len >> 1) .. c.len - (b.len >> 1)];     // ConstCast
        }

        fn main() {
            mut c = move_from_slice("HelloHelloHelloHelloHello",
                                    "WorldWorldWorldWorldWorld");

            return c == "lloHelloHelloWorldWorldWor" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str move_from_slice_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    /*MOV*/ fu::str c = (a + b);
    return fu::get_range(c, (a.size() >> 1), (c.size() - (b.size() >> 1))).const_cast_mut().destructive_move();
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str c = move_from_slice_MbR9("HelloHelloHelloHelloHello"_view, "WorldWorldWorldWorldWorld"_view);
    if (c == "lloHelloHelloWorldWorldWor"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            match = (other ~= x);

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 1000, 2, 3 ];
            assign_via_vec_range(:match[1..], :other[1..], 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:6*/ fu::vec_range_mut<int> other, const int x)
{
    match = (other += x);
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 1000, 2, 3 }};
    assign_via_vec_range_MbR9(fu::get_range_mut(match, 1), fu::get_range_mut(other, 1), 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            match = (other ~= x);

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 2, 3 ];
            assign_via_vec_range(:match[1..], :other, 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:6*/ fu::vec_range_mut<int> other, const int x)
{
    match = (other += x);
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 2, 3 }};
    assign_via_vec_range_MbR9(fu::get_range_mut(match, 1), other, 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            match = (other ~= x);

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 100, 2, 3 ];
            assign_via_vec_range(:match, :other, 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:6*/ fu::vec_range_mut<int> other, const int x)
{
    match = (other += x);
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 100, 2, 3 }};
    assign_via_vec_range_MbR9(match, other, 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            (match = other) ~= x;

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 1000, 2, 3 ];
            assign_via_vec_range(:match[1..], :other[1..], 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:7*/ fu::vec_range<int> other, const int x)
{
    (match = other) += x;
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 1000, 2, 3 }};
    assign_via_vec_range_MbR9(fu::get_range_mut(match, 1), fu::get_range(other, 1), 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            (match = other) ~= x;

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 2, 3 ];
            assign_via_vec_range(:match[1..], :other, 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:7*/ fu::vec_range<int> other, const int x)
{
    (match = other) += x;
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 2, 3 }};
    assign_via_vec_range_MbR9(fu::get_range_mut(match, 1), other, 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn assign_via_vec_range(ref match: i32[], ref other: i32[], x: i32) {

            (match = other) ~= x;

        }

        fn main() {
            mut match = [ 1 ];

            mut other = [ 100, 2, 3 ];
            assign_via_vec_range(:match, :other, 4);

            return match.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void assign_via_vec_range_MbR9(/*5:5*/ fu::vec_range_mut<int> match, /*7:7*/ fu::vec_range<int> other, const int x)
{
    (match = other) += x;
}

int fu_MAIN()
{
    fu::vec<int> match = fu::vec<int> {{ 1 }};
    fu::vec<int> other = fu::vec<int> {{ 100, 2, 3 }};
    assign_via_vec_range_MbR9(match, other, 4);
    return match.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        noinline fn test(ref arr: i32[]) {
            mut right: i32[];
            swap(right, arr[arr.len / 2 ..]);
            return right;
        }

        fn main() {
            mut left = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
            mut right = test(left);
            return left.len + right.len * 10 - 54;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static fu::vec<int> test_MbR9(/*1:1*/ fu::vec_range_mut<int> arr)
{
    /*MOV*/ fu::vec<int> right {};
    right.swap(fu::get_range_mut(arr, (arr.size() / 2)));
    return /*NRVO*/ right;
}

int fu_MAIN()
{
    fu::vec<int> left = fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }};
    fu::vec<int> right = test_MbR9(left);
    return (left.size() + (right.size() * 10)) - 54;
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn what(ref s: string, AoB: int)
            s = AoB ? "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
                    : "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"

        fn main() {
            inline fn what(AoB: int) {
                mut s: string;
                what(s, AoB)
            }

            let concat = what(0) ~ what(1)
            return concat.len - 65
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_Ka0yavo9NM9
                                #define STR_Ka0yavo9NM9
static const fu::str str_Ka0yavo9NM9 fu_INIT_PRIORITY(1001) { "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"_fu };
                                #endif

                                #ifndef STR_EQyexwUqDm7
                                #define STR_EQyexwUqDm7
static const fu::str str_EQyexwUqDm7 fu_INIT_PRIORITY(1001) { "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> what_GL0m(/*3:3*/ fu::vec_range_mut<char> s, const int AoB)
{
    return (s = (AoB ? str_Ka0yavo9NM9 : str_EQyexwUqDm7));
}

int fu_MAIN()
{
    fu::str s {};
    int AoB;
    fu::str s_1 {};
    int AoB_1;
    fu::str concat = ((AoB = 0, s = {}, what_GL0m(s, AoB)) + (AoB_1 = 1, s_1 = {}, what_GL0m(s_1, AoB_1)));
    return concat.size() - 65;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        enum Method { GET };
        struct Request { method: Method; url: byte[] }
        noinline fn moveFromVecRangeConst(mut buf: byte[]) {
            let first_space = 3;
            let last_space  = buf.len - 9;
            if (last_space <= first_space) return [];
            let method_str  = buf[0 .. first_space];
            let url         = buf[first_space + 1 .. last_space];
            let ver_str     = buf[last_space + 1 ..];
            return ver_str == "HTTP/1.1" && method_str == "GET"
                && Request("GET", url);                         // ConstCast
        }

        fn main() {
            mut hello = moveFromVecRangeConst("GET / HTTP/1.1");
            return hello.url == "/" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Request_0AfH;
enum Method_fib3: fu::u8;

                                #ifndef DEF_Method_fib3
                                #define DEF_Method_fib3
enum Method_fib3: fu::u8
{
    Method_fib3_GET = 1u,
};
                                #endif

                                #ifndef DEF_Request_0AfHWI0h71d
                                #define DEF_Request_0AfHWI0h71d
struct Request_0AfH
{
                                // shape_hash:    c38c19671b201a79
                                // non_triv_mask: 0000800000000001
    Method_fib3 method;
    fu::str url;
    explicit operator bool() const noexcept
    {
        return false
            || method
            || url
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static Request_0AfH moveFromVecRangeConst_MbR9(/*MOV*/ fu::str&& buf)
{
    const int first_space = 3;
    const int last_space = (buf.size() - 9);
    if ((last_space <= first_space))
    {
        return Request_0AfH{};
    }
    else
    {
        fu::view<char> /*buf*/ method_str = fu::get_view(buf, 0, first_space);
        /*MOV*/ fu::vec_range<char> /*buf*/ url = fu::get_range(buf, (first_space + 1), last_space);
        fu::view<char> /*buf*/ ver_str = fu::get_view(buf, (last_space + 1));
        if ((ver_str == "HTTP/1.1"_view) && (method_str == "GET"_view))
        {
            return Request_0AfH { Method_fib3_GET, url.const_cast_mut().destructive_move() };
        }
        else
        {
            return Request_0AfH{};
        };
    };
}

int fu_MAIN()
{
    Request_0AfH hello = moveFromVecRangeConst_MbR9(fu::str("GET / HTTP/1.1"_fu));
    if (hello.url == "/"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        inline fn Stringlike(x: string): string = x;

        inline fn Concat(mut parts.Stringlike[]: string[]) {
            mut str = "";
            for (mut i = 0; i < parts.len; i++) str ~= parts[i];
            return str;
        }

        inline fn Konkat(mut parts.Stringlike[]: string[]) {
            mut str = "";
            for (mut i = 0; i < parts.len; i++) str = Concat(str, parts[i]);
            return str;
        }

        fn main() {                                             // ConstCast
            let hello = Konkat("Hello, ", "World!");            // GNUStmtExpr
            return hello == "Hello, World!" ? 0 : 1;            // PointlessLocal
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_59vvPMBHtob
                                #define STR_59vvPMBHtob
static const fu::str str_59vvPMBHtob fu_INIT_PRIORITY(1001) { "Hello, "_fu };
                                #endif

                                #ifndef STR_K00VsFkercl
                                #define STR_K00VsFkercl
static const fu::str str_K00VsFkercl fu_INIT_PRIORITY(1001) { "World!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str {};
    fu::view<char> BL_1_v {};
    fu::view<char> /*str*/ hello = (__extension__ (
    {
        fu::vec_range<char> x {};
        fu::vec_range<char> x_1 {};
        fu::vec<fu::str> parts = fu::vec<fu::str> {{ fu::str((x.ptr_reassign(str_59vvPMBHtob), x)), fu::str((x_1.ptr_reassign(str_K00VsFkercl), x_1)) }};
        str = fu::str(""_fu);
        for (int i = 0; i < parts.size(); i++)
        {
            fu::str str_1 {};
            fu::vec_range<char> BL_4_v {};
            str = (__extension__ (
            {
                fu::vec_range<char> x_2 {};
                fu::vec_range<char> x_3 {};
                fu::vec<fu::str> parts_1 = fu::vec<fu::str> {{ fu::str((x_2.ptr_reassign(str), x_2)), fu::str((x_3.ptr_reassign(parts[i]), x_3)) }};
                str_1 = fu::str(""_fu);
                for (int i_1 = 0; i_1 < parts_1.size(); i_1++)
                    str_1 += parts_1[i_1];

                BL_4_v.ptr_reassign(str_1);
                (void)0;
            }), BL_4_v).const_cast_mut().destructive_move();
        };
        BL_1_v.ptr_reassign(str);
        (void)0;
    }), BL_1_v);
    if (hello == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        inline fn Stringlike(x: string): string = x;

        inline fn Concat(mut parts.Stringlike[]: string[]) {
            mut str = "";
            for (mut i = 0; i < parts.len; i++) str ~= parts[i];
            return str;
        }

        inline fn Konkat(mut parts.Stringlike[]: string[]) {
            mut str = "";
            for (mut i = 0; i < parts.len; i++) str = Concat(str, parts[i]);
            return str;
        }

        fn main() {                                             // ConstCast
            let hello = Konkat("Hello, ", "World!");            // GNUStmtExpr
            return hello == "Hello, World!" ? 0 : 1;            // PointlessLocal
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_59vvPMBHtob
                                #define STR_59vvPMBHtob
static const fu::str str_59vvPMBHtob fu_INIT_PRIORITY(1001) { "Hello, "_fu };
                                #endif

                                #ifndef STR_K00VsFkercl
                                #define STR_K00VsFkercl
static const fu::str str_K00VsFkercl fu_INIT_PRIORITY(1001) { "World!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str {};
    fu::view<char> BL_1_v {};
    fu::view<char> /*str*/ hello = (__extension__ (
    {
        const fu::str* x;
        const fu::str* x_1;
        fu::vec<fu::str> parts = fu::vec<fu::str> {{ fu::str((x = &(str_59vvPMBHtob), (*x))), fu::str((x_1 = &(str_K00VsFkercl), (*x_1))) }};
        str = {};
        for (int i = 0; i < parts.size(); i++)
        {
            fu::str str_1 {};
            fu::str* BL_4_v;
            str = static_cast<fu::str&&>(const_cast<fu::str&>((__extension__ (
            {
                const fu::str* x_2;
                fu::vec_range<char> x_3 {};
                fu::vec<fu::str> parts_1 = fu::vec<fu::str> {{ fu::str((x_2 = &(str), (*x_2))), fu::str((x_3.ptr_reassign(parts[i]), x_3)) }};
                str_1 = {};
                for (int i_1 = 0; i_1 < parts_1.size(); i_1++)
                    str_1 += parts_1[i_1];

                BL_4_v = &(str_1);
                (void)0;
            }), *BL_4_v)));
        };
        BL_1_v.ptr_reassign(str);
        (void)0;
    }), BL_1_v);
    if (hello == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn u64reduce(str: string) {
            mut x: u64;
            let u64s = str[0 .. str.len & ~7].view(of: u64);
            for (mut i = 0; i < u64s.len; i++) {
                x ^= u64s[i];
                x ^= x << 13;
                x ^= x >> 17;
                x ^= x << 5;
            }
            return x;
        }

        fn main() {
            let a = u64reduce("hello, world!");
            let b = u64reduce("Hello, world!");
            let c = u64reduce("Hello, World!");
            let sum = a + b + c;
            let ret = (sum ^ sum >> 32).u32.i32;
            return ret - 1184288320;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_qkzXJwSGkQ5
                                #define STR_qkzXJwSGkQ5
static const fu::str str_qkzXJwSGkQ5 fu_INIT_PRIORITY(1001) { "hello, world!"_fu };
                                #endif

                                #ifndef STR_Eo96t7ccMBh
                                #define STR_Eo96t7ccMBh
static const fu::str str_Eo96t7ccMBh fu_INIT_PRIORITY(1001) { "Hello, world!"_fu };
                                #endif

                                #ifndef STR_M1K48y3AaFf
                                #define STR_M1K48y3AaFf
static const fu::str str_M1K48y3AaFf fu_INIT_PRIORITY(1001) { "Hello, World!"_fu };
                                #endif

#ifndef fu_NO_fdefs

static uint64_t u64reduce_MbR9(/*1:1*/ fu::vec_range<char> str)
{
    uint64_t x {};
    fu::view<uint64_t> /*str|static*/ u64s = fu::view_of<uint64_t>(fu::get_range(str, 0, (str.size() & ~7)));
    for (int i = 0; i < u64s.size(); i++)
    {
        x ^= u64s[i];
        x ^= (x << 13ull);
        x ^= (x >> 17ull);
        x ^= (x << 5ull);
    };
    return x;
}

int fu_MAIN()
{
    const uint64_t a = u64reduce_MbR9(str_qkzXJwSGkQ5);
    const uint64_t b = u64reduce_MbR9(str_Eo96t7ccMBh);
    const uint64_t c = u64reduce_MbR9(str_M1K48y3AaFf);
    const uint64_t sum = ((a + b) + c);
    const int ret = int(unsigned((sum ^ (sum >> 32ull))));
    return ret - 1184288320;
}

#endif

int main() { return fu_MAIN(); }

========


        noinline

        fn sillyDot(a: int[..], b: int[..]) {
            mut res: int[];
            let n = min(a.len, b.len);
            for (mut i = 0; i < n; i++) res.push(a[i] * b[i]);
            return res;
        }

        fn main() {
            mut counter = 0;
            fn c() counter++;
            mut res = sillyDot(
                [ c,c,c,c, c,c,c,c ],  // 0, 1, 2, 3,  4, 5, 6, 7
                [ c,c,c,c, c,c,c,c ]); // 8, 9,10,11, 12,13,14,15

            return counter == 16 && res == [ 0,9,20,33, 48,65,84,105 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int c_MbR9(/*1:1*/ int& counter)
{
    return counter++;
}

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(/*3:3*/ const int a, /*3:3*/ const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

static fu::vec<int> sillyDot_MbR9(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    /*MOV*/ fu::vec<int> res {};
    const int n = min_DbqN(a.size(), b.size());
    for (int i = 0; i < n; i++)
        res.push((a[i] * b[i]));

    return /*NRVO*/ res;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    int counter = 0;
    fu::vec<int> _0 {};
    fu::vec<int> res = (_0 = fu::vec<int> {{ c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter) }}, sillyDot_MbR9(static_cast<fu::vec<int>&&>(_0), fu::view<int> {{ c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter) }}));
    if ((counter == 16) && (res == fu::view<int> {{ 0, 9, 20, 33, 48, 65, 84, 105 }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========


        inline                                                  // GNUStmtExpr

        fn sillyDot(a: int[..], b: int[..]) {
            mut res: int[];
            let n = min(a.len, b.len);
            for (mut i = 0; i < n; i++) res.push(a[i] * b[i]);
            return res;
        }

        fn main() {
            mut counter = 0;
            fn c() counter++;
            mut res = sillyDot(
                [ c,c,c,c, c,c,c,c ],  // 0, 1, 2, 3,  4, 5, 6, 7
                [ c,c,c,c, c,c,c,c ]); // 8, 9,10,11, 12,13,14,15

            return counter == 16 && res == [ 0,9,20,33, 48,65,84,105 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int c_MbR9(/*1:1*/ int& counter)
{
    return counter++;
}

                                #ifndef DEF_min_DbqN29MT8e3
                                #define DEF_min_DbqN29MT8e3
inline int min_DbqN(/*3:3*/ const int a, /*3:3*/ const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    int counter = 0;
    fu::vec<int> res_1 {};
    fu::view<int> BL_1_v {};
    fu::view<int> /*res*/ res = (__extension__ (
    {
        fu::vec<int> a = fu::vec<int> {{ c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter) }};
        fu::vec<int> b = fu::vec<int> {{ c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter), c_MbR9(counter) }};
        res_1 = {};
        const int n = min_DbqN(a.size(), b.size());
        for (int i = 0; i < n; i++)
            res_1.push((a[i] * b[i]));

        BL_1_v.ptr_reassign(res_1);
        (void)0;
    }), BL_1_v);
    if ((counter == 16) && (res == fu::view<int> {{ 0, 9, 20, 33, 48, 65, 84, 105 }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        noinline        
        fn slicePromotion_inner(ref array: i32[], ref view: i32[..]) {
            array ~= array.map(|x| x + view.len);
            for (mut i = 0; i < view.len; i++) view[i] += array.len;
        }

        noinline fn slicePromotion_outer(ref array: i32[], ref view: i32[..]) {
            return slicePromotion_inner(array, view);
        }

        fn main() {
            mut array = [ 1, 2, 3, 4 ];
            mut view  = [ 2, 3, 4, 5 ];
            slicePromotion_outer(array, view);
            return array == [ 1, 2, 3, 4, 5, 6, 7, 8 ]
                && view  == [ 10, 11, 12, 13 ]
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___C8eaQBlrMO0
                                #define DEF___C8eaQBlrMO0
inline static int _C8ea(const int x, /*3:3*/ fu::view<int> view)
{
    return x + view.size();
}
                                #endif

                                #ifndef DEF_map_zLF6JbyTO8b
                                #define DEF_map_zLF6JbyTO8b
inline fu::vec<int> map_zLF6(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> view)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _C8ea(a[i], view);

    return /*NRVO*/ res;
}
                                #endif

static void slicePromotion_inner_MbR9(/*1:1*/ fu::vec_range_mut<int> array, /*3:2*/ fu::view_mut<int> view)
{
    array += map_zLF6(array, view);
    for (int i = 0; i < view.size(); i++)
        view.mutref(i) += array.size();

}

static void slicePromotion_outer_MbR9(/*1:1*/ fu::vec_range_mut<int> array, /*3:2*/ fu::view_mut<int> view)
{
    slicePromotion_inner_MbR9(array, view);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> array = fu::vec<int> {{ 1, 2, 3, 4 }};
    fu::vec<int> view = fu::vec<int> {{ 2, 3, 4, 5 }};
    slicePromotion_outer_MbR9(array, view);
    if ((array == fu::view<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}) && (view == fu::view<int> {{ 10, 11, 12, 13 }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        inline          
        fn slicePromotion_inner(ref array: i32[], ref view: i32[..]) {
            array ~= array.map(|x| x + view.len);
            for (mut i = 0; i < view.len; i++) view[i] += array.len;
        }

        noinline fn slicePromotion_outer(ref array: i32[], ref view: i32[..]) {
            return slicePromotion_inner(array, view);
        }

        fn main() {
            mut array = [ 1, 2, 3, 4 ];
            mut view  = [ 2, 3, 4, 5 ];
            slicePromotion_outer(array, view);
            return array == [ 1, 2, 3, 4, 5, 6, 7, 8 ]
                && view  == [ 10, 11, 12, 13 ]
                    ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___C8eaQBlrMO0
                                #define DEF___C8eaQBlrMO0
inline static int _C8ea(const int x, /*3:3*/ fu::view<int> view)
{
    return x + view.size();
}
                                #endif

                                #ifndef DEF_map_zLF6JbyTO8b
                                #define DEF_map_zLF6JbyTO8b
inline fu::vec<int> map_zLF6(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> view)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _C8ea(a[i], view);

    return /*NRVO*/ res;
}
                                #endif

static void slicePromotion_outer_MbR9(/*1:1*/ fu::vec_range_mut<int> array, /*3:2*/ fu::view_mut<int> view)
{
    array += map_zLF6(array, view);
    for (int i = 0; i < view.size(); i++)
        view.mutref(i) += array.size();

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> array = fu::vec<int> {{ 1, 2, 3, 4 }};
    fu::vec<int> view = fu::vec<int> {{ 2, 3, 4, 5 }};
    slicePromotion_outer_MbR9(array, view);
    if ((array == fu::view<int> {{ 1, 2, 3, 4, 5, 6, 7, 8 }}) && (view == fu::view<int> {{ 10, 11, 12, 13 }}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn ifLetVecRangeMut(ref x: i32[]) {
            if (ref items = x[.. x.len / 2]) {
                mut hello = [ 1, 2 ];
                swap(items, hello);
            }

            x ~= 5;
        }

        fn main() {
            mut arr = [ 5, 6, 3, 4 ];
            ifLetVecRangeMut(arr);
            return arr == [ 1, 2, 3, 4, 5 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void ifLetVecRangeMut_MbR9(/*1:1*/ fu::vec_range_mut<int> x)
{
    fu::vec_range_mut<int> items {};
    if (items.ptr_reassign(fu::get_range_start0_mut(x, (x.size() / 2))))
    {
        fu::vec<int> hello = fu::vec<int> {{ 1, 2 }};
        items.swap(hello);
    };
    x += 5;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 5, 6, 3, 4 }};
    ifLetVecRangeMut_MbR9(arr);
    if (arr == fu::view<int> {{ 1, 2, 3, 4, 5 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) HOME ~ '!';

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9()
{
    return HOME + '!';
}

static fu::str get_FU_ROOT_MbR9()
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9();
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9().size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) HOME ~ '!';

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9()
{
    return HOME.ref + '!';
}

static fu::str get_FU_ROOT_MbR9()
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9();
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME.ref + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9().size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) HOME ~ "!";

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9()
{
    return HOME + "!"_view;
}

static fu::str get_FU_ROOT_MbR9()
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9();
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9().size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) HOME ~ "!";

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9()
{
    return HOME.ref + "!"_view;
}

static fu::str get_FU_ROOT_MbR9()
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9();
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME.ref + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9().size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) n & 1 && HOME ~ '!';

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9(const int n)
{
    if (n & 1)
        return HOME + '!';
    else
    {
        return fu::str{};
    };
}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9(n);
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) n & 1 && HOME ~ '!';

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9(const int n)
{
    if (n & 1)
        return HOME.ref + '!';
    else
    {
        return fu::str{};
    };
}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9(n);
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME.ref + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) n & 1 && HOME ~ "!";

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9(const int n)
{
    if (n & 1)
        return HOME + "!"_view;
    else
    {
        return fu::str{};
    };
}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9(n);
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let HOME = "Hello";
        fn HOME_bang(lax n: int) n & 1 && HOME ~ "!";

        fn get_FU_ROOT(n: int) {
            let FU_ROOT = HOME_bang(n);
            return FU_ROOT || HOME ~ "!!";
        }

        fn main() get_FU_ROOT(1).len - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_5Dh86r8K971;

static fu::str HOME_bang_MbR9(const int n)
{
    if (n & 1)
        return HOME.ref + "!"_view;
    else
    {
        return fu::str{};
    };
}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    /*MOV*/ fu::str FU_ROOT = HOME_bang_MbR9(n);
    return FU_ROOT ? FU_ROOT.destructive_move() : (HOME.ref + "!!"_view);
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn slash(a: string)
            a.if_last == '/' ? a : a ~ '/';

        fn join(a: string, b: string)
            b.starts  (with: '/') ?           b :
            a.ends    (with: '/') ? a       ~ b :
                                    a ~ '/' ~ b ;

        let HOME = "/hello/world";

        fn HOME_bang(n: int) {
            mut res = HOME;
            for (mut i = 0; i < n; i++) res ~= '!';
            return res;
        }


        fn get_FU_ROOT(n: int): string {
            let FU_ROOT         = {                             // GNUStmtExpr
                let exe         = HOME_bang(:n);

                mut start       = -1;
                for (;;) {
                    let match   = exe.find("/world", :start + 1);
                    if (match   < 0) break;
                    start       = match;
                }

                start > 0 && exe.slice(start: 0, end: start)
            };

            return slash(FU_ROOT || join(HOME, "fu"));          // ConstCast
        }

        fn main() get_FU_ROOT(1).len - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_E4jEYr9Iuyg
                                #define STR_E4jEYr9Iuyg
static const fu::str str_E4jEYr9Iuyg fu_INIT_PRIORITY(1001) { "/hello/world"_fu };
                                #endif

                                #ifndef STR_fDUHOAvuy0b
                                #define STR_fDUHOAvuy0b
static const fu::str str_fDUHOAvuy0b fu_INIT_PRIORITY(1001) { "fu"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_E4jEYr9Iuyg;

static fu::str HOME_bang_MbR9(const int n)
{
    /*MOV*/ fu::str res = fu::str(HOME);
    for (int i = 0; i < n; i++)
        res += '!';

    return /*NRVO*/ res;
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF_ends_L30JVW8oAb6
                                #define DEF_ends_L30JVW8oAb6
inline bool ends_L30J(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[(a.size() - 1)] == with);
}
                                #endif

static fu::str join_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::vec_range<char> b)
{
    if (starts_Sfbf(b, '/'))
        return fu::str(b);
    else if (ends_L30J(a, '/'))
        return a + b;
    else
        return (a + '/') + b;

}

                                #ifndef DEF_if_last_0CThtiA13q7
                                #define DEF_if_last_0CThtiA13q7
inline char if_last_0CTh(/*7:7*/ fu::view<char> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
    {
        return char{};
    };
}
                                #endif

static fu::str slash_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    if (if_last_0CTh(a) == '/')
        return fu::str(a);
    else
        return a + '/';

}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    fu::str exe {};
    fu::vec_range<char> BL_1_v {};
    /*MOV*/ fu::vec_range<char> /*exe|zeroes*/ FU_ROOT = (__extension__ (
    {
        exe = HOME_bang_MbR9(n);
        int start = -1;
        for (; ; )
        {
            const int match = find_BNNw(exe, "/world"_view, (start + 1));
            if (match < 0)
                break;
            else
                start = match;

        };
        BL_1_v.ptr_reassign(((start > 0) ? fu::get_range(exe, 0, start) : (*(fu::str*)fu::NIL)));
        (void)0;
    }), BL_1_v);
    return slash_MbR9((FU_ROOT ? FU_ROOT.const_cast_mut().destructive_move_or_default() : join_MbR9(HOME, str_fDUHOAvuy0b)));
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        fn slash(a: string)
            a.if_last == '/' ? a : a ~ '/';

        fn join(a: string, b: string)
            b.starts  (with: '/') ?           b :
            a.ends    (with: '/') ? a       ~ b :
                                    a ~ '/' ~ b ;

        let HOME = "/hello/world";

        fn HOME_bang(n: int) {
            mut res = HOME;
            for (mut i = 0; i < n; i++) res ~= '!';
            return res;
        }


        fn get_FU_ROOT(n: int): string {
            let FU_ROOT         = {                             // GNUStmtExpr
                let exe         = HOME_bang(:n);

                mut start       = -1;
                for (;;) {
                    let match   = exe.find("/world", :start + 1);
                    if (match   < 0) break;
                    start       = match;
                }

                start > 0 && exe.slice(start: 0, end: start)
            };

            return slash(FU_ROOT || join(HOME, "fu"));          // ConstCast
        }

        fn main() get_FU_ROOT(1).len - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_E4jEYr9Iuyg
                                #define STR_E4jEYr9Iuyg
static const fu::str str_E4jEYr9Iuyg fu_INIT_PRIORITY(1001) { "/hello/world"_fu };
                                #endif

                                #ifndef STR_fDUHOAvuy0b
                                #define STR_fDUHOAvuy0b
static const fu::str str_fDUHOAvuy0b fu_INIT_PRIORITY(1001) { "fu"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_E4jEYr9Iuyg;

static fu::str HOME_bang_MbR9(const int n)
{
    /*MOV*/ fu::str res = fu::str(HOME.ref);
    for (int i = 0; i < n; i++)
        res += '!';

    return /*NRVO*/ res;
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF_ends_L30JVW8oAb6
                                #define DEF_ends_L30JVW8oAb6
inline bool ends_L30J(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[(a.size() - 1)] == with);
}
                                #endif

static fu::str join_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::vec_range<char> b)
{
    if (starts_Sfbf(b, '/'))
        return fu::str(b);
    else if (ends_L30J(a, '/'))
        return a + b;
    else
        return (a + '/') + b;

}

                                #ifndef DEF_if_last_0CThtiA13q7
                                #define DEF_if_last_0CThtiA13q7
inline char if_last_0CTh(/*7:7*/ fu::view<char> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
    {
        return char{};
    };
}
                                #endif

static fu::str slash_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    if (if_last_0CTh(a) == '/')
        return fu::str(a);
    else
        return a + '/';

}

static fu::str get_FU_ROOT_MbR9(const int n)
{
    fu::str exe {};
    fu::vec_range<char> BL_1_v {};
    /*MOV*/ fu::vec_range<char> /*exe|zeroes*/ FU_ROOT = (__extension__ (
    {
        exe = HOME_bang_MbR9(n);
        int start = -1;
        for (; ; )
        {
            const int match = find_BNNw(exe, "/world"_view, (start + 1));
            if (match < 0)
                break;
            else
                start = match;

        };
        BL_1_v.ptr_reassign(((start > 0) ? fu::get_range(exe, 0, start) : (*(fu::str*)fu::NIL)));
        (void)0;
    }), BL_1_v);
    return slash_MbR9((FU_ROOT ? FU_ROOT.const_cast_mut().destructive_move_or_default() : join_MbR9(HOME.ref, str_fDUHOAvuy0b)));
}

int fu_MAIN()
{
    return get_FU_ROOT_MbR9(1).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

========

        fn slash(a: string)
            a.if_last == '/' ? a : a ~ '/';

        fn join(a: string, b: string)
            b.starts  (with: '/') ?           b :
            a.ends    (with: '/') ? a       ~ b :
                                    a ~ '/' ~ b ;

        let HOME = "/hello/world";

        fn HOME_bang(n: int) {
            mut res = HOME;
            for (mut i = 0; i < n; i++) res ~= '!';
            return res;
        }

        pub import _0;
        fn get_FU_ROOT(n: int): string {
            let FU_ROOT         = {                             // GNUStmtExpr
                let exe         = HOME_bang(:n);

                mut start       = -1;
                for (;;) {
                    let match   = exe.find("/world", :start + 1);
                    if (match   < 0) break;
                    start       = match;
                }

                start > 0 && exe.slice(start: 0, end: start)
            };

            return slash(FU_ROOT || join(HOME, "fu"));          // ConstCast
        }

        fn main() get_FU_ROOT(1).len - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

fu::str HOME_bang_MbR9(int);
fu::str join_MbR9(fu::view<char>, fu::vec_range<char>);
fu::str slash_MbR9(fu::vec_range<char>);

                                #ifndef STR_fDUHOAvuy0b
                                #define STR_fDUHOAvuy0b
static const fu::str str_fDUHOAvuy0b fu_INIT_PRIORITY(1002) { "fu"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

extern const fu::vec_range<char> /*static*/ HOME;
static fu::str get_FU_ROOT_LtD7(const int n)
{
    fu::str exe {};
    fu::vec_range<char> BL_1_v {};
    /*MOV*/ fu::vec_range<char> /*exe|zeroes*/ FU_ROOT = (__extension__ (
    {
        exe = HOME_bang_MbR9(n);
        int start = -1;
        for (; ; )
        {
            const int match = find_BNNw(exe, "/world"_view, (start + 1));
            if (match < 0)
                break;
            else
                start = match;

        };
        BL_1_v.ptr_reassign(((start > 0) ? fu::get_range(exe, 0, start) : (*(fu::str*)fu::NIL)));
        (void)0;
    }), BL_1_v);
    return slash_MbR9((FU_ROOT ? FU_ROOT.const_cast_mut().destructive_move_or_default() : join_MbR9(HOME, str_fDUHOAvuy0b)));
}

int fu_MAIN()
{
    return get_FU_ROOT_LtD7(1).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_E4jEYr9Iuyg
                                #define STR_E4jEYr9Iuyg
static const fu::str str_E4jEYr9Iuyg fu_INIT_PRIORITY(1001) { "/hello/world"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_E4jEYr9Iuyg;
                                #ifndef DEF_if_last_0CThtiA13q7
                                #define DEF_if_last_0CThtiA13q7
inline char if_last_0CTh(/*7:7*/ fu::view<char> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
    {
        return char{};
    };
}
                                #endif

fu::str slash_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    if (if_last_0CTh(a) == '/')
        return fu::str(a);
    else
        return a + '/';

}

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF_ends_L30JVW8oAb6
                                #define DEF_ends_L30JVW8oAb6
inline bool ends_L30J(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[(a.size() - 1)] == with);
}
                                #endif

fu::str join_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::vec_range<char> b)
{
    if (starts_Sfbf(b, '/'))
        return fu::str(b);
    else if (ends_L30J(a, '/'))
        return a + b;
    else
        return (a + '/') + b;

}

fu::str HOME_bang_MbR9(const int n)
{
    /*MOV*/ fu::str res = fu::str(HOME);
    for (int i = 0; i < n; i++)
        res += '!';

    return /*NRVO*/ res;
}

#endif

// N_NonTrivAutoCopy, N_SD_HasStaticInit

========

        fn slash(a: string)
            a.if_last == '/' ? a : a ~ '/';

        fn join(a: string, b: string)
            b.starts  (with: '/') ?           b :
            a.ends    (with: '/') ? a       ~ b :
                                    a ~ '/' ~ b ;

        let HOME = "/hello/world";

        fn HOME_bang(n: int) {
            mut res = HOME;
            for (mut i = 0; i < n; i++) res ~= '!';
            return res;
        }

        pub import _0;
        fn get_FU_ROOT(n: int): string {
            let FU_ROOT         = {                             // GNUStmtExpr
                let exe         = HOME_bang(:n);

                mut start       = -1;
                for (;;) {
                    let match   = exe.find("/world", :start + 1);
                    if (match   < 0) break;
                    start       = match;
                }

                start > 0 && exe.slice(start: 0, end: start)
            };

            return slash(FU_ROOT || join(HOME, "fu"));          // ConstCast
        }

        fn main() get_FU_ROOT(1).len - 7;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>

fu::str HOME_bang_MbR9(int);
fu::str join_MbR9(fu::view<char>, fu::vec_range<char>);
fu::str slash_MbR9(fu::vec_range<char>);

                                #ifndef STR_fDUHOAvuy0b
                                #define STR_fDUHOAvuy0b
static const fu::str str_fDUHOAvuy0b fu_INIT_PRIORITY(1002) { "fu"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

extern const fu::static_ref<fu::str> /*static*/ HOME;
static fu::str get_FU_ROOT_LtD7(const int n)
{
    fu::str exe {};
    fu::vec_range<char> BL_1_v {};
    /*MOV*/ fu::vec_range<char> /*exe|zeroes*/ FU_ROOT = (__extension__ (
    {
        exe = HOME_bang_MbR9(n);
        int start = -1;
        for (; ; )
        {
            const int match = find_BNNw(exe, "/world"_view, (start + 1));
            if (match < 0)
                break;
            else
                start = match;

        };
        BL_1_v.ptr_reassign(((start > 0) ? fu::get_range(exe, 0, start) : (*(fu::str*)fu::NIL)));
        (void)0;
    }), BL_1_v);
    return slash_MbR9((FU_ROOT ? FU_ROOT.const_cast_mut().destructive_move_or_default() : join_MbR9(HOME.ref, str_fDUHOAvuy0b)));
}

int fu_MAIN()
{
    return get_FU_ROOT_LtD7(1).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>


                                #ifndef STR_E4jEYr9Iuyg
                                #define STR_E4jEYr9Iuyg
static const fu::str str_E4jEYr9Iuyg fu_INIT_PRIORITY(1001) { "/hello/world"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ HOME fu_INIT_PRIORITY(1001) = str_E4jEYr9Iuyg;
                                #ifndef DEF_if_last_0CThtiA13q7
                                #define DEF_if_last_0CThtiA13q7
inline char if_last_0CTh(/*7:7*/ fu::view<char> a)
{
    if (a.size())
        return a[(a.size() - 1)];
    else
    {
        return char{};
    };
}
                                #endif

fu::str slash_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    if (if_last_0CTh(a) == '/')
        return fu::str(a);
    else
        return a + '/';

}

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF_ends_L30JVW8oAb6
                                #define DEF_ends_L30JVW8oAb6
inline bool ends_L30J(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[(a.size() - 1)] == with);
}
                                #endif

fu::str join_MbR9(/*3:3*/ fu::view<char> a, /*3:3*/ fu::vec_range<char> b)
{
    if (starts_Sfbf(b, '/'))
        return fu::str(b);
    else if (ends_L30J(a, '/'))
        return a + b;
    else
        return (a + '/') + b;

}

fu::str HOME_bang_MbR9(const int n)
{
    /*MOV*/ fu::str res = fu::str(HOME.ref);
    for (int i = 0; i < n; i++)
        res += '!';

    return /*NRVO*/ res;
}

#endif

// N_NonTrivAutoCopy, N_SD_HasStaticInit

========

        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const Hey_Nwzp r = (a ? Hey_Nwzp { a } : Hey_Nwzp{});
    return r.i - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const Hey_Nwzp r = Hey_Nwzp { a };
    return r.i - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hey { i: i32; }

        fn main() {
            let a: Hey[] = [ [ -1 ], [ +1 ] ];
            return a[0].i + a[1].i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<Hey_Nwzp> a = fu::vec<Hey_Nwzp> {{ Hey_Nwzp { -1 }, Hey_Nwzp { +1 } }};
    return a[0].i + a[1].i;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hey { i: i32; }

        fn test(): Hey {
            return [ 0 ];
        }

        fn main() test.i;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Hey_Nwzp test_MbR9()
{
    return Hey_Nwzp { 0 };
}

int fu_MAIN()
{
    return test_MbR9().i;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test {

            a: i32;  
            b: i32;
        };

        return Test(b: 1).a;

---- <fail> ----
[2m[0m_0[2m.fu 11:16+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return [31;1mTest[0m(b: 1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test {

            a: i32;  
            b: i32;
        };

        return Test(b: 1).a;

---- <fail> ----
[2m[0m_0[2m.fu 11:16+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return [31;1mTest[0m(b: 1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test {

            a?: i32; 
            b: i32;
        };

        return Test(b: 1).a;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Test_ikd8 { 0, {/*unused non-zst*/} }.a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test {
            b: i32;

            a: i32;  
        };

        return Test(1).a;

---- <fail> ----
[2m[0m_0[2m.fu 11:16+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return [31;1mTest[0m(1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test {
            b: i32;

            a: i32;  
        };

        return Test(1).a;

---- <fail> ----
[2m[0m_0[2m.fu 11:16+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return [31;1mTest[0m(1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test {
            b: i32;

            a?: i32; 
        };

        return Test(1).a;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_Dijv;

                                #ifndef DEF_Test_Dijv3HegJ5a
                                #define DEF_Test_Dijv3HegJ5a
struct Test_Dijv
{
                                // shape_hash:    723853000ea7d857
                                // non_triv_mask: 0000000000000000
    int b;
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || b
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Test_Dijv { {/*unused non-zst*/}, 0 }.a;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node {
            items?: Node[];
            stuff?: Node[];
        };

        fn rec_copy(ref a: Node) {
            // If implemented naively,
            //  by the time you copy stuff it's no longer there.
            a = a.items[0];
        }

        fn main() {
            mut a = Node(items: [ Node(stuff: [ Node ]) ]);
            rec_copy(a);
            return a.stuff.len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct Node_wu6k;

                                #ifndef DEF_Node_wu6kZoSi6O6
                                #define DEF_Node_wu6kZoSi6O6
struct Node_wu6k
{
                                // shape_hash:    c249cce125d4c4f4
                                // non_triv_mask: 0100000000010000
    fu::vec<Node_wu6k> items;
    fu::vec<Node_wu6k> stuff;
    Node_wu6k(const Node_wu6k&) = default;
    Node_wu6k(Node_wu6k&&) = default;
    Node_wu6k& operator=(Node_wu6k&&) = default;
    Node_wu6k& operator=(const Node_wu6k& selfrec) { return *this = Node_wu6k(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || stuff
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void rec_copy_MbR9(/*1:1*/ Node_wu6k& a)
{
    a = a.items[0];
}

int fu_MAIN()
{
    Node_wu6k a = Node_wu6k { fu::vec<Node_wu6k> {{ Node_wu6k { fu::vec<Node_wu6k>{}, fu::vec<Node_wu6k> {{ Node_wu6k{} }} } }}, fu::vec<Node_wu6k>{} };
    rec_copy_MbR9(a);
    return a.stuff.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(a: i32, b!: i32 = 1) a + b;
        return test(-1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_MbR9(-1, 1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(hey!: i32) hey * 2;

        fn main() = (0).test;       

---- <fail> ----
[2m[0m_0[2m.fu 4:25+4[0m:

[2m      |         fn test(hey!: i32) hey * 2;[0m
[2m      | [0m
[2m    4 | [0m        fn main() = (0).[31;1mtest[0m;       
[2m      | [0m

	Bad call to [94;1mtest[0m with args ([35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mtest[0m(hey!: i32) hey * 2;

	    [35;3marg[0m [94;1mtest[0m:[94;1mhey[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn test(hey!: i32) hey * 2;

        fn main() = (0).test;       

---- <fail> ----
[2m[0m_0[2m.fu 4:25+4[0m:

[2m      |         fn test(hey!: i32) hey * 2;[0m
[2m      | [0m
[2m    4 | [0m        fn main() = (0).[31;1mtest[0m;       
[2m      | [0m

	Bad call to [94;1mtest[0m with args ([35;3malways-false[0m [35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mtest[0m(hey!: i32) hey * 2;

	    [35;3marg[0m [94;1mtest[0m:[94;1mhey[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn test(hey!: i32) hey * 2;

        fn main() = test(hey: 0);   

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int hey)
{
    return hey * 2;
}

int fu_MAIN()
{
    return test_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a: i32, b!: i32 = 1) a + b;

        return test(-2, +2);    

---- <fail> ----
[2m[0m_0[2m.fu 7:16+4[0m:

[2m      |         fn test(a: i32, b!: i32 = 1) a + b;[0m
[2m      | [0m
[2m    7 | [0m        return [31;1mtest[0m(-2, +2);    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mtest[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m5:12+4[0m:
[2m    5 | [0m        fn [31;1mtest[0m(a: i32, b!: i32 = 1) a + b;

	    [35;3marg[0m [94;1mtest[0m:[94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        fn test(a: i32, b!: i32 = 1) a + b;

        return test(-2, +2);    

---- <fail> ----
[2m[0m_0[2m.fu 7:16+4[0m:

[2m      |         fn test(a: i32, b!: i32 = 1) a + b;[0m
[2m      | [0m
[2m    7 | [0m        return [31;1mtest[0m(-2, +2);    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mtest[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mfn[0m [94;1mtest[0m at [2m5:12+4[0m:
[2m    5 | [0m        fn [31;1mtest[0m(a: i32, b!: i32 = 1) a + b;

	    [35;3marg[0m [94;1mtest[0m:[94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        fn test(a: i32, b!: i32 = 1) a + b;

        return test(-2, b: +2); 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_MbR9(-2, +2);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

---- <fail> ----
[2m[0m_0[2m.fu 8:16+4[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return [31;1mTest[0m(-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a: i32; b!: i32; };

	    [35;3marg[0m [94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

---- <fail> ----
[2m[0m_0[2m.fu 8:16+4[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return [31;1mTest[0m(-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a: i32; b!: i32; };

	    [35;3marg[0m [94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, b: +2).test; 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const Test_ikd8& t)
{
    return t.a + t.b;
}

int fu_MAIN()
{
    return test_MbR9(Test_ikd8 { -2, +2 });
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

---- <fail> ----
[2m[0m_0[2m.fu 8:16+4[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return [31;1mTest[0m(-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a?: i32; b!?: i32; };

	    [35;3marg[0m [94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

---- <fail> ----
[2m[0m_0[2m.fu 8:16+4[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return [31;1mTest[0m(-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [94;1mTest[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a?: i32; b!?: i32; };

	    [35;3marg[0m [94;1mb[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:4+4[0m

========

        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(b: +2).test - 2; 

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_ikd8;

                                #ifndef DEF_Test_ikd8JQdjPc4
                                #define DEF_Test_ikd8JQdjPc4
struct Test_ikd8
{
                                // shape_hash:    ee80f86d05510013
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const Test_ikd8& t)
{
    return t.a + t.b;
}

int fu_MAIN()
{
    return test_MbR9(Test_ikd8 { 0, +2 }) - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        let _precedence = 0;
        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;
        fn main() parseExpression();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF__precedence
                                #define DEF__precedence
inline constexpr int _precedence = 0;
                                #endif

#ifndef fu_NO_fdefs

static int parseExpression_MbR9(const int p1, const int mode)
{
    return p1 + mode;
}

int fu_MAIN()
{
    return parseExpression_MbR9(_precedence, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn what(a = -1, b!: i32) a + b; // Trailing explicit args.
        fn main() what(b: +1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int what_MbR9(const int b, const int a)
{
    return a + b;
}

int fu_MAIN()
{
    return what_MbR9(+1, -1);
}

#endif

int main() { return fu_MAIN(); }

========

        fn greet(with!greeting: string)     greeting.len;
        fn main()                           greet(with: "Hello!") - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int greet_MbR9(/*1:1*/ fu::view<char> greeting)
{
    return greeting.size();
}

int fu_MAIN()
{
    return greet_MbR9("Hello!"_view) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Each(arr: $T[], visit)
            for (mut i = 0; i < arr.len; i++)
                visit(arr[i], i?: i);

        fn main() {
            mut muls = 0;
            mut arr = [ 1, 2, 3 ];

            arr.Each: |v, i!index|
                muls += v * index; // complained no index in scope

            return muls - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___ixgANoJZ0xf
                                #define DEF___ixgANoJZ0xf
inline static int _ixgA(const int v, const int index, /*7:7*/ int& muls)
{
    return (muls += (v * index));
}
                                #endif

                                #ifndef DEF_Each_UcvtJHIeWl3
                                #define DEF_Each_UcvtJHIeWl3
inline static void Each_Ucvt(/*7:7*/ fu::view<int> arr, /*6:6*/ int& muls)
{
    for (int i = 0; i < arr.size(); i++)
        _ixgA(arr[i], i, muls);

}
                                #endif

int fu_MAIN()
{
    int muls = 0;
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3 }};
    Each_Ucvt(arr, muls);
    return muls - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Lifetime { using regions: i32[] };
        fn isInvalidatedBy(write: i32[]) write.len * write[0];

        // This blew up with a TODO: bck_node(non-empty argid).
        fn main() isInvalidatedBy(write: Lifetime([ 3, 5 ])) - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_yI8e;

                                #ifndef DEF_Lifetime_yI8e4Nvpayl
                                #define DEF_Lifetime_yI8e4Nvpayl
struct Lifetime_yI8e
{
                                // shape_hash:    adfcd672049d40bf
                                // non_triv_mask: 0008004000000000
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int isInvalidatedBy_MbR9(/*1:1*/ fu::view<int> write)
{
    return write.size() * write[0];
}

int fu_MAIN()
{
    return isInvalidatedBy_MbR9(Lifetime_yI8e { fu::vec<int> {{ 3, 5 }} }.regions) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Node { a: i32; b: i32; c: i32; d: i32 };

        fn make(a: i32, b?: i32, c?: i32)
            Node(a, :b, :c, d: 10);

        fn make(a: i32, b?: i32, c?: i32, d!: i32)
            Node(a, :b, :c, :d);

        fn res(using n: Node)
            return a + 10 * b + 100 * c + 1000 * d;

        fn main()
            make(4, 5).res      == 10054 &&
            make(3, b: 4).res   == 10043 &&
            make(2, c: 3).res   == 10302 &&
            make(1, d: 2).res   == 2001 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Node_PdBV;

                                #ifndef DEF_Node_PdBVpO1kHl5
                                #define DEF_Node_PdBVpO1kHl5
struct Node_PdBV
{
                                // shape_hash:    5beea9f24c4805e3
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    int c;
    int d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Node_PdBV make_MbR9(const int a, const int b, const int c)
{
    return Node_PdBV { a, b, c, 10 };
}

static int res_MbR9(/*1:1*/ const Node_PdBV& n)
{
    return ((n.a + (10 * n.b)) + (100 * n.c)) + (1000 * n.d);
}

static Node_PdBV make_kGbb(const int a, const int d, const int b, const int c)
{
    return Node_PdBV { a, b, c, d };
}

int fu_MAIN()
{
    if ((res_MbR9(make_MbR9(4, 5, 0)) == 10054) && (res_MbR9(make_MbR9(3, 4, 0)) == 10043) && (res_MbR9(make_MbR9(2, 0, 3)) == 10302) && (res_MbR9(make_kGbb(1, 2, 0, 0)) == 2001))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, 
                              c       
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;

---- <fail> ----
[2m[0m_0[2m.fu 10:19+4[0m:

[2m      |                 + a2o1(a?: 1, b?: 2) *    100   //    300[0m
[2m      |                 + a2o2(a?: 1, b?: 2) *   1000   //   3000[0m
[2m   10 | [0m                + [31;1ma2o1[0m(a : 1, 
[2m      |                               c       [0m
[2m      |                                ?: 2) *  10000   //  30000[0m

	Bad call to [94;1ma2o1[0m with args ([35;3mi32[0m, [35;3mi32[0m): 

	[35;3mfn[0m [94;1ma2o1[0m at [2m4:12+4[0m:
[2m    4 | [0m        fn [31;1ma2o1[0m(a : i32, b?: i32) a + b;

	    Optional argument ambiguity:

		Expected optional [35;3marg[0m [94;1ma2o1[0m:[94;1mb[0m not provided.

		Optional :named argument mismatch: no [31;3marg[0m [31;1mc[0m.

		Cannot distinguish from a typo.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, 
                              c       
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;

---- <fail> ----
[2m[0m_0[2m.fu 10:19+4[0m:

[2m      |                 + a2o1(a?: 1, b?: 2) *    100   //    300[0m
[2m      |                 + a2o2(a?: 1, b?: 2) *   1000   //   3000[0m
[2m   10 | [0m                + [31;1ma2o1[0m(a : 1, 
[2m      |                               c       [0m
[2m      |                                ?: 2) *  10000   //  30000[0m

	Bad call to [94;1ma2o1[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mfn[0m [94;1ma2o1[0m at [2m4:12+4[0m:
[2m    4 | [0m        fn [31;1ma2o1[0m(a : i32, b?: i32) a + b;

	    Optional argument ambiguity:

		Expected optional [35;3marg[0m [94;1ma2o1[0m:[94;1mb[0m not provided.

		Optional :named argument mismatch: no [31;3marg[0m [31;1mc[0m.

		Cannot distinguish from a typo.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, 
                              b       
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int a0o0_MbR9()
{
    return 0;
}

static int a1o0_MbR9(/*1:1*/ const int a)
{
    return a;
}

static int a2o1_MbR9(const int a, const int b)
{
    return a + b;
}

static int a2o2_MbR9(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return ((((((a0o0_MbR9() * 1) + (a1o0_MbR9(1) * 10)) + (a2o1_MbR9(1, 2) * 100)) + (a2o2_MbR9(1, 2) * 1000)) + (a2o1_MbR9(1, 2) * 10000)) + (a2o1_MbR9(1, 0) * 100000)) - 133310;
}

#endif

int main() { return fu_MAIN(); }

========

        pub fn reveach(items: $T[..], fn)
            for (mut i = items.len; i --> 0; )
                fn(items[i], i?: i);

        pub fn main() {
            mut sum = 0;
            [1, 2, 3].reveach(|x   | sum += x          );
            [1, 2, 3].reveach(|x, i| sum += x * i * 100);
            return sum - 806;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_reveach_x5GTgWl1tel
                                #define DEF_reveach_x5GTgWl1tel
inline void reveach_x5GT(/*7:7*/ fu::view<int> items, /*6:6*/ int& sum)
{
    for (int i = items.size(); i-- > 0; )
        _5aAg(items[i], sum);

}
                                #endif

                                #ifndef DEF___2KD2QPt2nP1
                                #define DEF___2KD2QPt2nP1
inline static int _2KD2(const int x, const int i, /*7:7*/ int& sum)
{
    return (sum += ((x * i) * 100));
}
                                #endif

                                #ifndef DEF_reveach_peUaK8cEEwh
                                #define DEF_reveach_peUaK8cEEwh
inline void reveach_peUa(/*7:7*/ fu::view<int> items, /*6:6*/ int& sum)
{
    for (int i = items.size(); i-- > 0; )
        _2KD2(items[i], i, sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    reveach_x5GT(fu::view<int> {{ 1, 2, 3 }}, sum);
    reveach_peUa(fu::view<int> {{ 1, 2, 3 }}, sum);
    return sum - 806;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        pub lax fn noop() 0;
        pub fn woot(ref i: i32, fn) i += fn(i?: i += 1); // Will not add 1.

        fn main() {
            mut sum = 0;
            woot(sum, fn noop);
            return sum;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int noop_MbR9()
{
    return 0;
}

                                #ifndef DEF_woot_FoNEJKibKG4
                                #define DEF_woot_FoNEJKibKG4
inline int woot_FoNE(/*3:3*/ int& i)
{
    return (i += noop_MbR9());
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    woot_FoNE(sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn takesFns(x, f)
            f(x * 2, optAndUnused?: x * 3);

        fn hasUnusedOptArg(x: int, alt = 7, lax optAndUnused?: int)
            x + alt;

        fn main()
            takesFns(2, fn hasUnusedOptArg) - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hasUnusedOptArg_MbR9(const int x, const int alt)
{
    return x + alt;
}

                                #ifndef DEF_takesFns_jltCQhxAKqc
                                #define DEF_takesFns_jltCQhxAKqc
inline static int takesFns_jltC(const int x)
{
    return hasUnusedOptArg_MbR9((x * 2), 7);
}
                                #endif

int fu_MAIN()
{
    return takesFns_jltC(2) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn main() {
            let ret: i8 = 
                128 ;

            return (ret - 100).i32 - 27;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i8 = 
[2m      |                 128 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi8[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i8 = 
                127 ;

            return (ret - 100).i32 - 27;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 ret = fu::i8(127);
    return int(fu::i8((ret - fu::i8(100)))) - 27;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: i16 = 
                32768 ;

            return (ret - 32700).i32 - 67;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i16 = 
[2m      |                 32768 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi16[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i16 = 
                32767 ;

            return (ret - 32700).i32 - 67;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const short ret = short(32767);
    return int(short((ret - short(32700)))) - 67;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: i32 = 
                2147483648 ;

            return (ret - 2147483600).i32 - 47;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i32 = 
[2m      |                 2147483648 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi32[0m, got [35;3mi64[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i32 = 
                2147483647 ;

            return (ret - 2147483600).i32 - 47;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ret = 2147483647;
    return int((ret - 2147483600)) - 47;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() { // weird error, see the other two below
            let ret: i64 = 
                9223372036854775808 ;

            return (ret - 9223372036854775800).i32 - 7;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+19[0m:

[2m      |         fn main() { // weird error, see the other two below[0m
[2m      |             let ret: i64 = [0m
[2m    4 | [0m                [31;1m9223372036854775808[0m ;
[2m      | [0m
[2m      |             return (ret - 9223372036854775800).i32 - 7;[0m

	Bad int literal.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() { // weird error, see the other two below
            let ret: i64 = 
                9223372036854775807 ;

            return (ret - 9223372036854775800).i32 - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int64_t ret = 9223372036854775807ll;
    return int((ret - 9223372036854775800ll)) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: i8 = 
                -129 ;

            return (ret + 100).i32 + 28;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i8 = 
[2m      |                 -129 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi8[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i8 = 
                -128 ;

            return (ret + 100).i32 + 28;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 ret = fu::i8(-128);
    return int(fu::i8((ret + fu::i8(100)))) + 28;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: i16 = 
                -32769 ;

            return (ret + 32700).i32 + 68;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i16 = 
[2m      |                 -32769 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi16[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i16 = 
                -32768 ;

            return (ret + 32700).i32 + 68;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const short ret = short(-32768);
    return int(short((ret + short(32700)))) + 68;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: i32 = 
                -2147483649 ;

            return (ret + 2147483600).i32 + 48;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i32 = 
[2m      |                 -2147483649 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mi32[0m, got [35;3mi64[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: i32 = 
                -2147483648 ;

            return (ret + 2147483600).i32 + 48;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ret = -2147483648;
    return int((ret + 2147483600)) + 48;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() { // wording different from the ones above and below
            let ret: i64 = 
                -9223372036854775809 ;

            return (ret + 9223372036854775800).i32 + 8;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:18+19[0m:

[2m      |         fn main() { // wording different from the ones above and below[0m
[2m      |             let ret: i64 = [0m
[2m    4 | [0m                -[31;1m9223372036854775809[0m ;
[2m      | [0m
[2m      |             return (ret + 9223372036854775800).i32 + 8;[0m

	Oversized signed int literal.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() { // wording different from the ones above and below
            let ret: i64 = 
                -9223372036854775808 ;

            return (ret + 9223372036854775800).i32 + 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int64_t ret = (-9223372036854775807-1);
    return int((ret + 9223372036854775800ll)) + 8;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: u8 = 
                256 ;

            return (ret - 0xff).i32;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u8 = 
[2m      |                 256 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mu8[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: u8 = 
                255 ;

            return (ret - 0xff).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::u8 ret = fu::u8(255u);
    return int(unsigned(fu::u8((ret - fu::u8(0xffu)))));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: u16 = 
                65536 ;

            return (ret - 0xffff).i32;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u16 = 
[2m      |                 65536 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mu16[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: u16 = 
                65535 ;

            return (ret - 0xffff).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint16_t ret = uint16_t(65535u);
    return int(unsigned(uint16_t((ret - uint16_t(0xffffu)))));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let ret: u32 = 
                4294967296 ;

            return (ret - 0xffffffff).i32;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u32 = 
[2m      |                 4294967296 ;[0m
[2m      | [0m

	Type annotation does not match initializer: expects [35;3mu32[0m, got [35;3mi64[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let ret: u32 = 
                4294967295 ;

            return (ret - 0xffffffff).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned ret = 4294967295u;
    return int((ret - 0xffffffffu));
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() { // this is the best of the weird ones
            let ret: u64 = 
                18446744073709551616 ;

            return (ret - 0xffffffffffffffff).i32;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+20[0m:

[2m      |         fn main() { // this is the best of the weird ones[0m
[2m      |             let ret: u64 = [0m
[2m    4 | [0m                [31;1m18446744073709551616[0m ;
[2m      | [0m
[2m      |             return (ret - 0xffffffffffffffff).i32;[0m

	Integer literal overflows a u64.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() { // this is the best of the weird ones
            let ret: u64 = 
                18446744073709551615 ;

            return (ret - 0xffffffffffffffff).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint64_t ret = 18446744073709551615ull;
    return int(unsigned((ret - 0xffffffffffffffffull)));
}

#endif

int main() { return fu_MAIN(); }

========

        pub fn set_once(ref entry, bit: i32): bool
        {
            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'
            if (entry & mask)           //  which doesnt work for some reason
                return false;

            entry |= mask;
            return true;
        }

        fn main() {
            mut entry: u64;
            let a = set_once(entry, 32);
            let b = set_once(entry, 32);
            return a && !b ? 0 : 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

                                #ifndef DEF_set_once_j7UOiXaa7N3
                                #define DEF_set_once_j7UOiXaa7N3
inline bool set_once_j7UO(/*3:3*/ uint64_t& entry, const int bit)
{
    const uint64_t mask = (1ull << uint64_t(unsigned(bit)));
    if (entry & mask)
        return false;
    else
    {
        entry |= mask;
        return true;
    };
}
                                #endif

int fu_MAIN()
{
    uint64_t entry {};
    const bool a = set_once_j7UO(entry, 32);
    const bool b = set_once_j7UO(entry, 32);
    if (a && !b)
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let hey: u128 = 0x8000000000000000.u128;
            let res = hey + hey;
            return res > hey ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const __uint128_t hey = __uint128_t(0x8000000000000000ull);
    const __uint128_t res = (hey + hey);
    if (res > hey)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = byte(128);
            return v.i32 == 128 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char v = char(128);
    if (int(fu::u8(v)) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = u8(128);
            return v.i32 == 128 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::u8 v = fu::u8(unsigned(128));
    if (int(unsigned(v)) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = u32(128);
            return byte(v) == byte(128) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(128);
    if (char(v) == char(128))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = i32(128);
            return byte(v) == byte(128) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(128);
    if (char(v) == char(128))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = u32(2147483648);
            return byte(v) == byte(0) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(uint64_t(2147483648ll));
    if (char(v) == char(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = i32(2147483648);
            return byte(v) == byte(0) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(2147483648ll);
    if (char(v) == char(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = u32(-1);
            return byte(v) == byte(255) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(-1);
    if (char(v) == char(255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let v = i32(-1);
            return byte(v) == byte(255) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(-1);
    if (char(v) == char(255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            return i32(byte(i32(128))) == 128 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (int(fu::u8(char(int(128)))) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;


        fn test(f) {
            let a = 1; // none of these should need 'lax',
            let b = 2; //  they're all SS_MATCHED below,
            let c = 3; //   and their use is explicitly discard-ok.
            return f(?:a, ?:b, ?:c);
        }

        fn main() test(fn hello) - 210;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hello_MbR9(const int a, const int b)
{
    return (10 * a) + (100 * b);
}

                                #ifndef DEF_test_yzKTj4F3Br6
                                #define DEF_test_yzKTj4F3Br6
inline static int test_yzKT()
{
    const int a = 1;
    const int b = 2;
    return hello_MbR9(a, b);
}
                                #endif

int fu_MAIN()
{
    return test_yzKT() - 210;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;


        inline                  
        fn test(f) {
            let a = 1; // none of these should need 'lax',
            let b = 2; //  they're all SS_MATCHED below,
            let c = 3; //   and their use is explicitly discard-ok.
            return f(?:a, ?:b, ?:c);
        }

        fn main() test(fn hello) - 210;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hello_MbR9(const int a, const int b)
{
    return (10 * a) + (100 * b);
}

int fu_MAIN()
{
    int a;
    int b;
    return (a = 1, b = 2, hello_MbR9(a, b)) - 210;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        pub lax fn noop() {} // AUTOPUB

        fn hello() 3;

        import _0;
        fn main() 6 - hello * 2;

---- <fail> ----
[2m[0m_1[2m.fu 3:23+5[0m:

[2m      | [0m
[2m      |         import _0;[0m
[2m    3 | [0m        fn main() 6 - [31;1mhello[0m * 2;
[2m      | [0m

	Bad call to [94;1mhello[0m: [94;1mhello[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        pub lax fn noop() {} // AUTOPUB

        pub

        fn hello() 3;

        import _0;
        fn main() 6 - hello * 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int hello_MbR9();

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 6 - (hello_MbR9() * 2);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

void noop_MbR9()
{
}

int hello_MbR9()
{
    return 3;
}

#endif

========

        pub struct Hey { i: i32; };

        fn main() 1._0::Hey.i - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Hey_Nwzp { 1 }.i - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct Hey { i: i32; };

        import _0;
        pub inline fn test(h: Hey) h.i + 2;

        import _1;
        fn main() 1._0::Hey.test - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_Nwzp h;
    return (h = Hey_Nwzp { 1 }, (h.i + 2)) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

        import _1;
        fn main() 1._0::Hey.test - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_Nwzp h;
    return (h = Hey_Nwzp { 1 }, (h.i + 2)) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

        fn main() 1._0::Hey._1::test - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_Nwzp h;
    return (h = Hey_Nwzp { 1 }, (h.i + 2)) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct You { i: i32; };

        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];

        pub inline fn test(using h = _1::init3) i + 7;

        fn main() _2::test - 10;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_gMwB;
struct You_5OSF;
Hey_gMwB init3_LtD7();

                                #ifndef DEF_You_5OSFDibX0D8
                                #define DEF_You_5OSFDibX0D8
struct You_5OSF
{
                                // shape_hash:    128377cd894b2846
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_gMwBAdqVqLc
                                #define DEF_Hey_gMwBAdqVqLc
struct Hey_gMwB
{
                                // shape_hash:    8a4017c1892cea49
                                // non_triv_mask: 0000000000000000
    You_5OSF you;
    explicit operator bool() const noexcept
    {
        return false
            || you
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_gMwB h;
    return (h = init3_LtD7(), (h.you.i + 7)) - 10;
}

#endif

int main() { return fu_MAIN(); }
struct Hey_gMwB;
struct You_5OSF;

                                #ifndef DEF_You_5OSFDibX0D8
                                #define DEF_You_5OSFDibX0D8
struct You_5OSF
{
                                // shape_hash:    128377cd894b2846
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_gMwBAdqVqLc
                                #define DEF_Hey_gMwBAdqVqLc
struct Hey_gMwB
{
                                // shape_hash:    8a4017c1892cea49
                                // non_triv_mask: 0000000000000000
    You_5OSF you;
    explicit operator bool() const noexcept
    {
        return false
            || you
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Hey_gMwB init3_LtD7()
{
    return Hey_gMwB { You_5OSF { 3 } };
}

#endif

========

        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };

        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;

        pub fn main()
        {
            let m34 = _1::mat34_identity;
            let m44 = _2::mat4(m34);

            return m44.determinant.i32 - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct mat34_EVl8;
struct vec3_vMFc;
struct mat4_jcw2;
float determinant_WLF9(const mat4_jcw2&);

                                #ifndef DEF_vec3_vMFcEqMWiSk
                                #define DEF_vec3_vMFcEqMWiSk
struct vec3_vMFc
{
                                // shape_hash:    343a86f384c8723f
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_mat34_EVl8LEVPS98
                                #define DEF_mat34_EVl8LEVPS98
struct mat34_EVl8
{
                                // shape_hash:    abf9930a363b90f5
                                // non_triv_mask: 0000000000000000
    vec3_vMFc mx;
    vec3_vMFc my;
    vec3_vMFc mz;
    vec3_vMFc mo;
    explicit operator bool() const noexcept
    {
        return false
            || mx
            || my
            || mz
            || mo
        ;
    }
};
                                #endif

                                #ifndef DEF_mat4_jcw2yEO7SP7
                                #define DEF_mat4_jcw2yEO7SP7
struct mat4_jcw2
{
                                // shape_hash:    b8b914e2ee7474b5
                                // non_triv_mask: 0000000000000000
    float m0;
    float m1;
    float m2;
    float m3;
    float m4;
    float m5;
    float m6;
    float m7;
    float m8;
    float m9;
    float mA;
    float mB;
    float mC;
    float mD;
    float mE;
    float mF;
    explicit operator bool() const noexcept
    {
        return false
            || m0
            || m1
            || m2
            || m3
            || m4
            || m5
            || m6
            || m7
            || m8
            || m9
            || mA
            || mB
            || mC
            || mD
            || mE
            || mF
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const mat34_EVl8 m34 = mat34_EVl8 { vec3_vMFc { 1.0f, 0.0f, 0.0f }, vec3_vMFc { 0.0f, 1.0f, 0.0f }, vec3_vMFc { 0.0f, 0.0f, 1.0f }, vec3_vMFc{} };
    const mat4_jcw2 m44 = mat4_jcw2 { m34.mx.x, m34.mx.y, m34.mx.z, 0.0f, m34.my.x, m34.my.y, m34.my.z, 0.0f, m34.mz.x, m34.mz.y, m34.mz.z, 0.0f, m34.mo.x, m34.mo.y, m34.mo.z, 1.0f };
    return int(determinant_WLF9(m44)) - 1;
}

#endif

int main() { return fu_MAIN(); }
struct mat4_jcw2;

                                #ifndef DEF_mat4_jcw2yEO7SP7
                                #define DEF_mat4_jcw2yEO7SP7
struct mat4_jcw2
{
                                // shape_hash:    b8b914e2ee7474b5
                                // non_triv_mask: 0000000000000000
    float m0;
    float m1;
    float m2;
    float m3;
    float m4;
    float m5;
    float m6;
    float m7;
    float m8;
    float m9;
    float mA;
    float mB;
    float mC;
    float mD;
    float mE;
    float mF;
    explicit operator bool() const noexcept
    {
        return false
            || m0
            || m1
            || m2
            || m3
            || m4
            || m5
            || m6
            || m7
            || m8
            || m9
            || mA
            || mB
            || mC
            || mD
            || mE
            || mF
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float determinant_WLF9(/*1:1*/ const mat4_jcw2& _)
{
    return (((((((((((((((((((((((((+_.mC * _.m9) * _.m6) * _.m3) - (((_.m8 * _.mD) * _.m6) * _.m3)) - (((_.mC * _.m5) * _.mA) * _.m3)) + (((_.m4 * _.mD) * _.mA) * _.m3)) + (((_.m8 * _.m5) * _.mE) * _.m3)) - (((_.m4 * _.m9) * _.mE) * _.m3)) - (((_.mC * _.m9) * _.m2) * _.m7)) + (((_.m8 * _.mD) * _.m2) * _.m7)) + (((_.mC * _.m1) * _.mA) * _.m7)) - (((_.m0 * _.mD) * _.mA) * _.m7)) - (((_.m8 * _.m1) * _.mE) * _.m7)) + (((_.m0 * _.m9) * _.mE) * _.m7)) + (((_.mC * _.m5) * _.m2) * _.mB)) - (((_.m4 * _.mD) * _.m2) * _.mB)) - (((_.mC * _.m1) * _.m6) * _.mB)) + (((_.m0 * _.mD) * _.m6) * _.mB)) + (((_.m4 * _.m1) * _.mE) * _.mB)) - (((_.m0 * _.m5) * _.mE) * _.mB)) - (((_.m8 * _.m5) * _.m2) * _.mF)) + (((_.m4 * _.m9) * _.m2) * _.mF)) + (((_.m8 * _.m1) * _.m6) * _.mF)) - (((_.m0 * _.m9) * _.m6) * _.mF)) - (((_.m4 * _.m1) * _.mA) * _.mF)) + (((_.m0 * _.m5) * _.mA) * _.mF);
}

#endif

========

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;


        fn main() ::_0.maxc.i32;


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct _0_W5Jl;
float maxc_MbR9(const _0_W5Jl&);

                                #ifndef DEF__0_W5JlL8H97z1
                                #define DEF__0_W5JlL8H97z1
struct _0_W5Jl
{
                                // shape_hash:    ca816958b3c9e321
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(maxc_MbR9(_0_W5Jl{}));
}

#endif

int main() { return fu_MAIN(); }
struct _0_W5Jl;

                                #ifndef DEF__0_W5JlL8H97z1
                                #define DEF__0_W5JlL8H97z1
struct _0_W5Jl
{
                                // shape_hash:    ca816958b3c9e321
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float maxc_MbR9(/*1:1*/ const _0_W5Jl& vec)
{
    if (vec.x > vec.y)
        return vec.x;
    else
        return vec.y;

}

#endif

========

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;


        import _0;
        fn main() _0.maxc.i32;


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct _0_W5Jl;
float maxc_MbR9(const _0_W5Jl&);

                                #ifndef DEF__0_W5JlL8H97z1
                                #define DEF__0_W5JlL8H97z1
struct _0_W5Jl
{
                                // shape_hash:    ca816958b3c9e321
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(maxc_MbR9(_0_W5Jl{}));
}

#endif

int main() { return fu_MAIN(); }
struct _0_W5Jl;

                                #ifndef DEF__0_W5JlL8H97z1
                                #define DEF__0_W5JlL8H97z1
struct _0_W5Jl
{
                                // shape_hash:    ca816958b3c9e321
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float maxc_MbR9(/*1:1*/ const _0_W5Jl& vec)
{
    if (vec.x > vec.y)
        return vec.x;
    else
        return vec.y;

}

#endif

========

        pub fn _0(i: i32) i + 1;

        fn main() (-1).::_0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int _0_MbR9(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return _0_MbR9(-1);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int _0_MbR9(const int i)
{
    return i + 1;
}

#endif

========

        pub fn add(ref to: $T[], item: $T) {
            for (mut i = 0; i < to.len; i++) {
                if (to[i] >= item) {
                    if (to[i] != item)
                        to.insert(i, item);

                    return;
                }
            }

            to.push(item);
        }

        fn main() {
            mut x = [1, 2, 3];
            x._0::add(3); if (x.len != 3) return 33;
            x._0::add(4); return x.len - x[3];
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_add_oiadmfdiuH9
                                #define DEF_add_oiadmfdiuH9
inline void add_oiad(/*3:3*/ fu::vec_range_mut<int> to, const int item)
{
    for (int i = 0; i < to.size(); i++)
    {
        if ((to[i] >= item))
        {
            if (to[i] != item)
                to.insert(i, item);

            return;
        };
    };
    to.push(item);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> {{ 1, 2, 3 }};
    add_oiad(x, 3);
    if (x.size() != 3)
        return 33;
    else
    {
        add_oiad(x, 4);
        return x.size() - x[3];
    };
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";

        import _0;
        fn test(i: i32) {
            let v = i & 1 ? A : B;
            return v.len;
        }

        fn main() 0.test - 1.test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ A;
extern const fu::vec_range<char> /*static*/ B;
static int test_LtD7(const int i)
{
    fu::view<char> /*static*/ v = ((i & 1) ? A : B);
    return v.size();
}

int fu_MAIN()
{
    return test_LtD7(0) - test_LtD7(1);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef DEF_pad0
                                #define DEF_pad0
inline constexpr int pad0 = 0;
                                #endif

                                #ifndef DEF_pad1
                                #define DEF_pad1
inline constexpr int pad1 = 1;
                                #endif

                                #ifndef DEF_pad2
                                #define DEF_pad2
inline constexpr int pad2 = 2;
                                #endif

                                #ifndef DEF_pad3
                                #define DEF_pad3
inline constexpr int pad3 = 3;
                                #endif

                                #ifndef DEF_pad4
                                #define DEF_pad4
inline constexpr int pad4 = 4;
                                #endif

                                #ifndef DEF_pad5
                                #define DEF_pad5
inline constexpr int pad5 = 5;
                                #endif

                                #ifndef DEF_pad6
                                #define DEF_pad6
inline constexpr int pad6 = 6;
                                #endif

                                #ifndef DEF_pad7
                                #define DEF_pad7
inline constexpr int pad7 = 7;
                                #endif

                                #ifndef DEF_pad8
                                #define DEF_pad8
inline constexpr int pad8 = 8;
                                #endif

                                #ifndef DEF_pad9
                                #define DEF_pad9
inline constexpr int pad9 = 9;
                                #endif

                                #ifndef DEF_PAD0
                                #define DEF_PAD0
inline constexpr int PAD0 = 0;
                                #endif

                                #ifndef DEF_PAD1
                                #define DEF_PAD1
inline constexpr int PAD1 = 1;
                                #endif

                                #ifndef DEF_PAD2
                                #define DEF_PAD2
inline constexpr int PAD2 = 2;
                                #endif

                                #ifndef DEF_PAD3
                                #define DEF_PAD3
inline constexpr int PAD3 = 3;
                                #endif

                                #ifndef DEF_PAD4
                                #define DEF_PAD4
inline constexpr int PAD4 = 4;
                                #endif

                                #ifndef DEF_PAD5
                                #define DEF_PAD5
inline constexpr int PAD5 = 5;
                                #endif

                                #ifndef DEF_PAD6
                                #define DEF_PAD6
inline constexpr int PAD6 = 6;
                                #endif

                                #ifndef DEF_PAD7
                                #define DEF_PAD7
inline constexpr int PAD7 = 7;
                                #endif

                                #ifndef DEF_PAD8
                                #define DEF_PAD8
inline constexpr int PAD8 = 8;
                                #endif

                                #ifndef DEF_PAD9
                                #define DEF_PAD9
inline constexpr int PAD9 = 9;
                                #endif

                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

                                #ifndef STR_9VaFzJwl1w6
                                #define STR_9VaFzJwl1w6
static const fu::str str_9VaFzJwl1w6 fu_INIT_PRIORITY(1001) { "world"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ A fu_INIT_PRIORITY(1001) = str_LCCnJta4Qr3;
extern const fu::vec_range<char> /*static*/ B fu_INIT_PRIORITY(1001) = str_9VaFzJwl1w6;
#endif

// N_SD_HasStaticInit

========

        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";

        import _0;
        fn test(i: i32) {
            let v = i & 1 ? A : B;
            return v.len;
        }

        fn main() 0.test - 1.test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/static_ref.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ A;
extern const fu::static_ref<fu::str> /*static*/ B;
static int test_LtD7(const int i)
{
    fu::view<char> /*static*/ v = ((i & 1) ? A.ref : B.ref);
    return v.size();
}

int fu_MAIN()
{
    return test_LtD7(0) - test_LtD7(1);
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


                                #ifndef DEF_pad0
                                #define DEF_pad0
inline constexpr int pad0 = 0;
                                #endif

                                #ifndef DEF_pad1
                                #define DEF_pad1
inline constexpr int pad1 = 1;
                                #endif

                                #ifndef DEF_pad2
                                #define DEF_pad2
inline constexpr int pad2 = 2;
                                #endif

                                #ifndef DEF_pad3
                                #define DEF_pad3
inline constexpr int pad3 = 3;
                                #endif

                                #ifndef DEF_pad4
                                #define DEF_pad4
inline constexpr int pad4 = 4;
                                #endif

                                #ifndef DEF_pad5
                                #define DEF_pad5
inline constexpr int pad5 = 5;
                                #endif

                                #ifndef DEF_pad6
                                #define DEF_pad6
inline constexpr int pad6 = 6;
                                #endif

                                #ifndef DEF_pad7
                                #define DEF_pad7
inline constexpr int pad7 = 7;
                                #endif

                                #ifndef DEF_pad8
                                #define DEF_pad8
inline constexpr int pad8 = 8;
                                #endif

                                #ifndef DEF_pad9
                                #define DEF_pad9
inline constexpr int pad9 = 9;
                                #endif

                                #ifndef DEF_PAD0
                                #define DEF_PAD0
inline constexpr int PAD0 = 0;
                                #endif

                                #ifndef DEF_PAD1
                                #define DEF_PAD1
inline constexpr int PAD1 = 1;
                                #endif

                                #ifndef DEF_PAD2
                                #define DEF_PAD2
inline constexpr int PAD2 = 2;
                                #endif

                                #ifndef DEF_PAD3
                                #define DEF_PAD3
inline constexpr int PAD3 = 3;
                                #endif

                                #ifndef DEF_PAD4
                                #define DEF_PAD4
inline constexpr int PAD4 = 4;
                                #endif

                                #ifndef DEF_PAD5
                                #define DEF_PAD5
inline constexpr int PAD5 = 5;
                                #endif

                                #ifndef DEF_PAD6
                                #define DEF_PAD6
inline constexpr int PAD6 = 6;
                                #endif

                                #ifndef DEF_PAD7
                                #define DEF_PAD7
inline constexpr int PAD7 = 7;
                                #endif

                                #ifndef DEF_PAD8
                                #define DEF_PAD8
inline constexpr int PAD8 = 8;
                                #endif

                                #ifndef DEF_PAD9
                                #define DEF_PAD9
inline constexpr int PAD9 = 9;
                                #endif

                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1001) { "hello"_fu };
                                #endif

                                #ifndef STR_9VaFzJwl1w6
                                #define STR_9VaFzJwl1w6
static const fu::str str_9VaFzJwl1w6 fu_INIT_PRIORITY(1001) { "world"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ A fu_INIT_PRIORITY(1001) = str_LCCnJta4Qr3;
extern const fu::static_ref<fu::str> /*static*/ B fu_INIT_PRIORITY(1001) = str_9VaFzJwl1w6;
#endif

// N_SD_HasStaticInit

========

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> $T) {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };

        pub struct ModuleOutputs {
            deps: i32[];
            scope: Scope;
        };

        pub fn test(a: ModuleOutputs) {
            let b = a._0::clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct ModuleOutputs_kin0;
struct Scope_JhVx;

                                #ifndef DEF_Scope_JhVx2AT0avk
                                #define DEF_Scope_JhVx2AT0avk
struct Scope_JhVx
{
                                // shape_hash:    783b35bfa587ecee
                                // non_triv_mask: 0800000000000000
    int x;
    Scope_JhVx(const Scope_JhVx&) = delete;
    Scope_JhVx(Scope_JhVx&&) = default;
    Scope_JhVx& operator=(const Scope_JhVx&) = delete;
    Scope_JhVx& operator=(Scope_JhVx&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_ModuleOutputs_kin0MfEcKN3
                                #define DEF_ModuleOutputs_kin0MfEcKN3
struct ModuleOutputs_kin0
{
                                // shape_hash:    ce6ec54c6a9c94c2
                                // non_triv_mask: 0808000000010000
    fu::vec<int> deps;
    Scope_JhVx scope;
    ModuleOutputs_kin0(const ModuleOutputs_kin0&) = delete;
    ModuleOutputs_kin0(ModuleOutputs_kin0&&) = default;
    ModuleOutputs_kin0& operator=(const ModuleOutputs_kin0&) = delete;
    ModuleOutputs_kin0& operator=(ModuleOutputs_kin0&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || deps
            || scope
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_clone_vOithUrpyg9
                                #define DEF_clone_vOithUrpyg9
inline fu::vec_range<int> clone_vOit(/*1:1*/ fu::vec_range<int> a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_0DCJaE9X1mk
                                #define DEF_clone_0DCJaE9X1mk
inline int clone_0DCJ(/*1:1*/ const int a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_AGqCvzYoZYc
                                #define DEF_clone_AGqCvzYoZYc
inline Scope_JhVx clone_AGqC(/*1:1*/ const Scope_JhVx& a)
{
    /*MOV*/ Scope_JhVx res {};
    res.x = clone_0DCJ(a.x);
    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_clone_zxmt7pSjlUh
                                #define DEF_clone_zxmt7pSjlUh
inline ModuleOutputs_kin0 clone_zxmt(/*1:1*/ const ModuleOutputs_kin0& a)
{
    /*MOV*/ ModuleOutputs_kin0 res {};

    {
        res.deps = clone_vOit(a.deps);
        res.scope = clone_AGqC(a.scope);
    };
    return /*NRVO*/ res;
}
                                #endif

int test_LtD7(/*1:1*/ const ModuleOutputs_kin0& a)
{
    ModuleOutputs_kin0 b = clone_zxmt(a);
    return a.deps.size() - b.deps.size();
}

int fu_MAIN()
{
    return test_LtD7(ModuleOutputs_kin0{});
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        // a private fn
        fn createShader(src: string) = src;

        // inits a public let
        pub let GEOMETRY_PASS_TEST = createShader("src");

        pub fn main() _0::GEOMETRY_PASS_TEST.len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ GEOMETRY_PASS_TEST;
int fu_MAIN()
{
    return GEOMETRY_PASS_TEST.size() - 3;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_FeinTXwHWv0
                                #define STR_FeinTXwHWv0
static const fu::str str_FeinTXwHWv0 fu_INIT_PRIORITY(1001) { "src"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> createShader_MbR9(/*1:1*/ fu::vec_range<char> src)
{
    return src;
}

extern const fu::vec_range<char> /*static*/ GEOMETRY_PASS_TEST fu_INIT_PRIORITY(1001) = createShader_MbR9(str_FeinTXwHWv0);
#endif

// N_SD_HasStaticInit

========

        struct List {
            vals: string[];
        };

        fn add(using ref _: List, val: string)
            vals ~= val;

        fn [](using _: List, val: string) {
            mut count = 0;
            for (mut i = 0; i < vals.len; i++)
                if (vals[i] == val)
                    count++;

            return count;
        }

        fn main() {
            mut list: _0::List;
            for (mut i = 0; i < 3; i++)
                list.add(i & 1 ? "a" : "b");

            return list["b"] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct List_Zn6L;
fu::vec_range_mut<fu::str> add_MbR9(List_Zn6L&, fu::vec_range<char>);
int x5Bx5D_MbR9(const List_Zn6L&, fu::view<char>);

                                #ifndef DEF_List_Zn6L7zf7YTc
                                #define DEF_List_Zn6L7zf7YTc
struct List_Zn6L
{
                                // shape_hash:    fb948abebd049469
                                // non_triv_mask: 0000c00000000008
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || vals
        ;
    }
};
                                #endif

                                #ifndef STR_ujDub247BYe
                                #define STR_ujDub247BYe
static const fu::str str_ujDub247BYe fu_INIT_PRIORITY(1002) { "a"_fu };
                                #endif

                                #ifndef STR_GURXpaBTk07
                                #define STR_GURXpaBTk07
static const fu::str str_GURXpaBTk07 fu_INIT_PRIORITY(1002) { "b"_fu };
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    List_Zn6L list {};
    for (int i = 0; i < 3; i++)
        add_MbR9(list, ((i & 1) ? str_ujDub247BYe : str_GURXpaBTk07));

    return x5Bx5D_MbR9(list, "b"_view) - 2;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct List_Zn6L;

                                #ifndef DEF_List_Zn6L7zf7YTc
                                #define DEF_List_Zn6L7zf7YTc
struct List_Zn6L
{
                                // shape_hash:    fb948abebd049469
                                // non_triv_mask: 0000c00000000008
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec_range_mut<fu::str> add_MbR9(/*3:3*/ List_Zn6L& _, /*3:3*/ fu::vec_range<char> val)
{
    return (_.vals += fu::str(val));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int x5Bx5D_MbR9(/*3:3*/ const List_Zn6L& _, /*3:3*/ fu::view<char> val)
{
    int count = 0;
    for (int i = 0; i < _.vals.size(); i++)
    {
        if (_.vals[i] == val)
            count++;

    };
    return count;
}

#endif

// N_NonTrivAutoCopy

========

        struct Int { i: i32; };
        fn -(a: Int) Int(-a.i);
        fn +(a: Int, b: Int) Int(a.i + b.i);
        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };
        postfix fn ++(ref a: Int) { a.i++; };

        fn main() {
            mut x: _0::Int = [ 1 ];
            x += -(x + x);
            x++;
            return x.i;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Int_2lV0;
Int_2lV0 operator+(const Int_2lV0&, const Int_2lV0&);
Int_2lV0 operator-(const Int_2lV0&);
Int_2lV0& operator+=(Int_2lV0&, const Int_2lV0&);
void operator++(Int_2lV0&, /*postfix*/int);

                                #ifndef DEF_Int_2lV0557aSvi
                                #define DEF_Int_2lV0557aSvi
struct Int_2lV0
{
                                // shape_hash:    c65205995b225a7d
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Int_2lV0 x = Int_2lV0 { 1 };
    x += -(x + x);
    x++;
    return x.i;
}

#endif

int main() { return fu_MAIN(); }
struct Int_2lV0;

                                #ifndef DEF_Int_2lV0557aSvi
                                #define DEF_Int_2lV0557aSvi
struct Int_2lV0
{
                                // shape_hash:    c65205995b225a7d
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Int_2lV0 operator-(/*1:1*/ const Int_2lV0& a)
{
    return Int_2lV0 { -a.i };
}

Int_2lV0 operator+(/*3:3*/ const Int_2lV0& a, /*3:3*/ const Int_2lV0& b)
{
    return Int_2lV0 { (a.i + b.i) };
}

Int_2lV0& operator+=(/*3:3*/ Int_2lV0& a, /*3:3*/ const Int_2lV0& b)
{
    a.i += b.i;
    return a;
}

void operator++(/*1:1*/ Int_2lV0& a, /*postfix*/int)
{
    a.i++;
}

#endif

========

        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.

        fn main()               1.public - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_pRivate_mI8DDxJzW2b
                                #define DEF_pRivate_mI8DDxJzW2b
inline static int pRivate_mI8D(const int x)
{
    return x * 3;
}
                                #endif

                                #ifndef DEF_pUblic_7qYFjeNl7gj
                                #define DEF_pUblic_7qYFjeNl7gj
inline int pUblic_7qYF(const int y)
{
    return pRivate_mI8D(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_7qYF(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.
        pub import _0;
        fn main()               1.public - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_pRivate_mI8DDxJzW2b
                                #define DEF_pRivate_mI8DDxJzW2b
inline static int pRivate_mI8D(const int x)
{
    return x * 3;
}
                                #endif

                                #ifndef DEF_pUblic_7qYFjeNl7gj
                                #define DEF_pUblic_7qYFjeNl7gj
inline int pUblic_7qYF(const int y)
{
    return pRivate_mI8D(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_7qYF(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn private(x: i32)      x * 3;              // cg fail:
        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.

        fn main()               1._0::public - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int pRivate_MbR9(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_pUblic_f2zRP1y2K48
                                #define DEF_pUblic_f2zRP1y2K48
inline int pUblic_f2zR(const int y)
{
    return pRivate_MbR9(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_f2zR(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int pRivate_MbR9(const int x)
{
    return x * 3;
}

#endif

// N_SD_ExternPrivates

========

        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";   // nowadays problem is OPTOKENS cgs to static in first translation unit

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...
                    return idx - 1;
            }

            return src.len;
        }

        fn main() _0::lex("3 - 3") - 2; // <- from here

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ OPTOKENS;
                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_Mnu2KTFEuhg
                                #define DEF_has_Mnu2KTFEuhg
inline bool has_Mnu2(/*3:3*/ fu::view<char> a, const char b)
{
    return (find_ZKsG(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_lex_xFEA4mfJpSg
                                #define DEF_lex_xFEA4mfJpSg
inline int lex_xFEA(/*1:1*/ fu::view<char> src)
{
    const int end = src.size();
    int idx = 0;
    while (idx < end)
    {
        const char /*src|static*/ c = src[idx++];
        if (has_Mnu2(OPTOKENS, c))
            return idx - 1;

    };
    return src.size();
}
                                #endif

int fu_MAIN()
{
    return lex_xFEA("3 - 3"_view) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_kjRm9m5SAE6
                                #define STR_kjRm9m5SAE6
static const fu::str str_kjRm9m5SAE6 fu_INIT_PRIORITY(1001) { "{}[]()!?~@#$%^&*/-+<=>,.;:|"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::vec_range<char> /*static*/ OPTOKENS fu_INIT_PRIORITY(1001) = str_kjRm9m5SAE6;
#endif

// N_SD_HasStaticInit, N_SD_ExternPrivates

========

        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";   // nowadays problem is OPTOKENS cgs to static in first translation unit

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...
                    return idx - 1;
            }

            return src.len;
        }

        fn main() _0::lex("3 - 3") - 2; // <- from here

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/static_ref.h>


#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ OPTOKENS;
                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_Mnu2KTFEuhg
                                #define DEF_has_Mnu2KTFEuhg
inline bool has_Mnu2(/*3:3*/ fu::view<char> a, const char b)
{
    return (find_ZKsG(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_lex_xFEA4mfJpSg
                                #define DEF_lex_xFEA4mfJpSg
inline int lex_xFEA(/*1:1*/ fu::view<char> src)
{
    const int end = src.size();
    int idx = 0;
    while (idx < end)
    {
        const char /*src|static*/ c = src[idx++];
        if (has_Mnu2(OPTOKENS.ref, c))
            return idx - 1;

    };
    return src.size();
}
                                #endif

int fu_MAIN()
{
    return lex_xFEA("3 - 3"_view) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


                                #ifndef STR_kjRm9m5SAE6
                                #define STR_kjRm9m5SAE6
static const fu::str str_kjRm9m5SAE6 fu_INIT_PRIORITY(1001) { "{}[]()!?~@#$%^&*/-+<=>,.;:|"_fu };
                                #endif

#ifndef fu_NO_fdefs

extern const fu::static_ref<fu::str> /*static*/ OPTOKENS fu_INIT_PRIORITY(1001) = str_kjRm9m5SAE6;
#endif

// N_SD_HasStaticInit, N_SD_ExternPrivates

========

        pub fn pubbed(a: i32) a * 2;

        fn not_pubbed(b: i32) b * 3;

        fn main() 1._0::pubbed._0::not_pubbed - 6;

---- <fail> ----
[2m[0m_1[2m.fu 2:36+10[0m:

[2m      | [0m
[2m    2 | [0m        fn main() 1._0::pubbed._0::[31;1mnot_pubbed[0m - 6;
[2m      | [0m

	Bad call to [94;1mnot_pubbed[0m with args ([35;3mi32[0m): [94;1mnot_pubbed[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        pub fn pubbed(a: i32) a * 2;

        pub                          
        fn not_pubbed(b: i32) b * 3;

        fn main() 1._0::pubbed._0::not_pubbed - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int pubbed_MbR9(int);
int not_pubbed_MbR9(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return not_pubbed_MbR9(pubbed_MbR9(1)) - 6;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int pubbed_MbR9(const int a)
{
    return a * 2;
}

int not_pubbed_MbR9(const int b)
{
    return b * 3;
}

#endif

========

        let SELF_TEST           = true;
        let NODEIDX_signbits    = SELF_TEST && 4;
        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;

        fn main() _0::NODEIDX_signmask - 15;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

extern const int NODEIDX_signmask;
int fu_MAIN()
{
    return NODEIDX_signmask - 15;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = true;
                                #endif

#ifndef fu_NO_fdefs

extern const int NODEIDX_signbits = (SELF_TEST ? 4 : 0);
extern const int NODEIDX_signmask = ((1 << NODEIDX_signbits) - 1);
#endif

// N_SD_HasStaticInit

========

        let SELF_TEST           = true;
        let NODEIDX_signbits    = SELF_TEST && 4;
        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;

        fn main() _0::NODEIDX_signmask - 15;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_NODEIDX_signbits
                                #define DEF_NODEIDX_signbits
inline constexpr int NODEIDX_signbits = 4;
                                #endif

                                #ifndef DEF_NODEIDX_signmask
                                #define DEF_NODEIDX_signmask
inline constexpr int NODEIDX_signmask = ((1 << NODEIDX_signbits) - 1);
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return NODEIDX_signmask - 15;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = true;
                                #endif

                                #ifndef DEF_NODEIDX_signbits
                                #define DEF_NODEIDX_signbits
inline constexpr int NODEIDX_signbits = 4;
                                #endif

                                #ifndef DEF_NODEIDX_signmask
                                #define DEF_NODEIDX_signmask
inline constexpr int NODEIDX_signmask = ((1 << NODEIDX_signbits) - 1);
                                #endif

// N_SD_HasStaticInit

========

        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;

        import _0;
        fn main() {
 //  feels like this override should be explicit
            infix fn +(a: Helpers, b: Helpers) a.index + b.index;
            return Helpers(+1) + Helpers(-1);
        }

---- <fail> ----
[2m[0m_1[2m.fu 6:32+1[0m:

[2m      |  //  feels like this override should be explicit[0m
[2m      |             infix fn +(a: Helpers, b: Helpers) a.index + b.index;[0m
[2m    6 | [0m            return Helpers(+1) [31;1m+[0m Helpers(-1);
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [94;1m+[0m with args ([35;3mstruct[0m [94;1mHelpers[0m, [35;3mstruct[0m [94;1mHelpers[0m), matches multiple items in scope:

	[35;3mfn[0m [94;1m+[0m at [2m5:22+1[0m:
[2m    5 | [0m            infix fn [31;1m+[0m(a: Helpers, b: Helpers) a.index + b.index;

	[35;3mfn[0m [94;1m+[0m at [2m[0m_0[2m.fu 3:12+1[0m:
[2m    3 | [0m        fn [31;1m+[0m(a: Helpers, b: Helpers) a.index - b.index;


        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;

        import _0;
        fn main() {
 // autoshadowing surprised me here
            shadow       //  feels like this override should be explicit
            infix fn +(a: Helpers, b: Helpers) a.index + b.index;
            return Helpers(+1) + Helpers(-1);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Helpers_DyqV;

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
                                // shape_hash:    340726173a03831e
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int operator+(/*3:3*/ const Helpers_DyqV& a, /*3:3*/ const Helpers_DyqV& b)
{
    return a.index + b.index;
}

int fu_MAIN()
{
    return Helpers_DyqV { +1 } + Helpers_DyqV { -1 };
}

#endif

int main() { return fu_MAIN(); }
struct Helpers_DyqV;

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
                                // shape_hash:    340726173a03831e
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int operator+(/*3:3*/ const Helpers_DyqV& a, /*3:3*/ const Helpers_DyqV& b)
{
    return a.index - b.index;
}

#endif

========

        struct Options { v: i32; };

        fn compile(o: _0::Options) = o.v;

        // Won't find Options if solving in reverse modid order.
        fn compile_snippets(o: _0::Options) = o.v;

        import _1;
        import _2;

        fn main() {
            let o = _0::Options(0);
            return compile(o) + compile_snippets(o);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Options_XygC;
int compile_LtD7(const Options_XygC&);
int compile_snippets_WLF9(const Options_XygC&);

                                #ifndef DEF_Options_XygCzo7F4vd
                                #define DEF_Options_XygCzo7F4vd
struct Options_XygC
{
                                // shape_hash:    7f7b858ac69c14d9
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Options_XygC o = Options_XygC { 0 };
    return compile_LtD7(o) + compile_snippets_WLF9(o);
}

#endif

int main() { return fu_MAIN(); }
struct Options_XygC;

                                #ifndef DEF_Options_XygCzo7F4vd
                                #define DEF_Options_XygCzo7F4vd
struct Options_XygC
{
                                // shape_hash:    7f7b858ac69c14d9
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int compile_LtD7(/*1:1*/ const Options_XygC& o)
{
    return o.v;
}

#endif
struct Options_XygC;

                                #ifndef DEF_Options_XygCzo7F4vd
                                #define DEF_Options_XygCzo7F4vd
struct Options_XygC
{
                                // shape_hash:    7f7b858ac69c14d9
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int compile_snippets_WLF9(/*1:1*/ const Options_XygC& o)
{
    return o.v;
}

#endif

========

        let x: i32 = 2;

        pub import _0;
        let y: i32 = 3;

        import _1;
        fn main() x + y - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr int x = 2;
                                #endif

                                #ifndef DEF_y
                                #define DEF_y
inline constexpr int y = 3;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return (x + y) - 5;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_y
                                #define DEF_y
inline constexpr int y = 3;
                                #endif

// N_SD_HasStaticInit

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr int x = 2;
                                #endif

// N_SD_HasStaticInit

========

        struct Profile {
            a: i32;
            b: i32;
            c: i32;
        };

        fn incr(implicit ref p: Profile, which) {
            p.which++;
        }

        fn main() {
            implicit mut p: _0::Profile;

            _0::incr(fn _0::a);
            _0::incr(|ref i| i._0::b);
            _0::incr(|ref i| i.b);                              // DuplicateFunctions
            _0::incr(._0::c);
            _0::incr(.c);

            return p._0::a + p.b * 10 + p.c * 100 == 221 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Profile_LIwu;

                                #ifndef DEF_Profile_LIwu0BGgOpl
                                #define DEF_Profile_LIwu0BGgOpl
struct Profile_LIwu
{
                                // shape_hash:    74a9b1029fce279f
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    int c;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_incr_wo0jXHsf83j
                                #define DEF_incr_wo0jXHsf83j
inline void incr_wo0j(/*3:3*/ Profile_LIwu& p)
{
    p.a++;
}
                                #endif

                                #ifndef DEF___pm04sL418Kd
                                #define DEF___pm04sL418Kd
inline static int& _pm04(/*1:1*/ Profile_LIwu& i)
{
    return i.b;
}
                                #endif

                                #ifndef DEF_incr_BQuZECoBj1c
                                #define DEF_incr_BQuZECoBj1c
inline void incr_BQuZ(/*3:3*/ Profile_LIwu& p)
{
    _pm04(p)++;
}
                                #endif

                                #ifndef DEF___XwD7BISesP8
                                #define DEF___XwD7BISesP8
inline static int& _XwD7(/*1:1*/ Profile_LIwu& _)
{
    return _.c;
}
                                #endif

                                #ifndef DEF_incr_cNNHke9teWk
                                #define DEF_incr_cNNHke9teWk
inline void incr_cNNH(/*3:3*/ Profile_LIwu& p)
{
    _XwD7(p)++;
}
                                #endif

int fu_MAIN()
{
    Profile_LIwu p {};
    incr_wo0j(p);
    incr_BQuZ(p);
    incr_BQuZ(p);
    incr_cNNH(p);
    incr_cNNH(p);
    if (((p.a + (p.b * 10)) + (p.c * 100)) == 221)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Sample { x: int; y: int };

        fn main() {
            mut res: Sample;
            mut now_x = 1;
            mut now_y = 2;
            inline fn Now() = Sample(++now_x, now_y++);

            fn PROFILE() unwrap {
                defer {
                    for (mut i = 0; i < 10; i++) now_x++;
                    res = Now();
                }
            }

            {
                PROFILE();
                now_y += 100;
            }
            return res.x == 12 && res.y == 102 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>

struct Sample_VDUS;

                                #ifndef DEF_Sample_VDUSOGO65xk
                                #define DEF_Sample_VDUSOGO65xk
struct Sample_VDUS
{
                                // shape_hash:    b350fd0cd3ada2fe
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Sample_VDUS res {};
    int now_x = 1;
    int now_y = 2;

    {
        fu_DEFER(
        {
            for (int i = 0; i < 10; i++)
                now_x++;

            res = Sample_VDUS { ++now_x, now_y++ };
        });
        now_y += 100;
    };
    if ((res.x == 12) && (res.y == 102))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;

        fn lookupUserType(type: string) =
            "<" ~ type.len ~ ">";

        fn tryLookupUserType(type: string) =
            type._0::isStruct && lookupUserType(type);

        fn getFlatCount(type: string) =
            type._0::isStructOrUnion
                ? _1::tryLookupUserType(type).len
                : 1;

        fn main() = "/a"._2::getFlatCount() == 3 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

int getFlatCount_WLF9(fu::view<char>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (getFlatCount_WLF9("/a"_view) == 3)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/str.h>
#include <fu/view.h>

fu::str tryLookupUserType_LtD7(fu::view<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

int getFlatCount_WLF9(/*1:1*/ fu::view<char> type)
{
    if (starts_Sfbf(type, '/'))
        return tryLookupUserType_LtD7(type).size();
    else
        return 1;

}

#endif
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

fu::str lookupUserType_LtD7(/*1:1*/ fu::view<char> type)
{
    return x7E_rA00("<"_view, fu::i64dec(type.size())) + ">"_view;
}

                                #ifndef DEF_starts_SfbfOAVfSee
                                #define DEF_starts_SfbfOAVfSee
inline bool starts_Sfbf(/*3:3*/ fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

fu::str tryLookupUserType_LtD7(/*1:1*/ fu::view<char> type)
{
    if (starts_Sfbf(type, '/'))
        return lookupUserType_LtD7(type);
    else
    {
        return fu::str{};
    };
}

#endif

========

        noinline fn recA(x) x & 1 ? recB(x) : x;
        noinline fn recB(x) recA(x + 1);

        pub inline fn fun(x: i32) recB(x);

        fn main() _0::fun(0) == 2 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int recB_SWnD(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_recA_TwVdSgBJYvi
                                #define DEF_recA_TwVdSgBJYvi
inline static int recA_TwVd(const int x)
{
    if (x & 1)
        return recB_SWnD(x);
    else
        return x;

}
                                #endif

                                #ifndef DEF_recB_SWnD6XgPh4c
                                #define DEF_recB_SWnD6XgPh4c
inline static int recB_SWnD(const int x)
{
    return recA_TwVd((x + 1));
}
                                #endif

int fu_MAIN()
{
    int x;
    if ((x = 0, recB_SWnD(x)) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * _1::add5(5)     ;

        import _0;
        fn add5(x: i32) add2(x) + 3;

        fn main() _0::times10(_1::add5(8)) - 130;

---- <fail> ----
[2m[0m_2[2m.fu 2:21+2[0m:

[2m      | [0m
[2m    2 | [0m        fn main() _0[31;1m::[0mtimes10(_1::add5(8)) - 130;
[2m      | [0m

	Imports:

[2m[0m_0[2m.fu 5:23+2[0m:

[2m      |         fn times10(x: i32)[0m
[2m      | [0m
[2m    5 | [0m                x * _1[31;1m::[0madd5(5)     ;
[2m      | [0m

	Imports:

[2m[0m_1[2m.fu 2:9+6[0m:

[2m      | [0m
[2m    2 | [0m        [31;1mimport[0m _0;
[2m      |         fn add5(x: i32) add2(x) + 3;[0m
[2m      | [0m

	Resulting in an import circle, not currently supported.

========

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * 10              ;

        import _0;
        fn add5(x: i32) add2(x) + 3;

        fn main() _0::times10(_1::add5(8)) - 130;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int add5_LtD7(int);
int times10_MbR9(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return times10_MbR9(add5_LtD7(8)) - 130;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int add2_MbR9(const int x)
{
    return x + 2;
}

int times10_MbR9(const int x)
{
    return x * 10;
}

#endif
int add2_MbR9(int);

#ifndef fu_NO_fdefs

int add5_LtD7(const int x)
{
    return add2_MbR9(x) + 3;
}

#endif

========

        fn hello(x: i32) x * 3;


        import _2;                       
        fn main() hello(4) - 12;

---- <fail> ----
[2m[0m_1[2m.fu 3:9+6[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        [31;1mimport[0m _2;                       
[2m      |         fn main() hello(4) - 12;[0m
[2m      | [0m

	Could not resolve this import.

	Searched relative to:    	[31;1m/Users/hdachev/fu/__tests__/[0m
	Looking for a file named:	[31;1m_2[0m

========

        fn hello(x: i32) x * 3;


        import _0;                       
        fn main() hello(4) - 12;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int hello_MbR9(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return hello_MbR9(4) - 12;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int hello_MbR9(const int x)
{
    return x * 3;
}

#endif

========

        pub struct What { thing: i32 };


        fn must_be_public(x: What) = x.thing * 11;

        fn main() = _0::What(3).must_be_public - 33;

---- <fail> ----
[2m[0m_1[2m.fu 2:33+14[0m:

[2m      | [0m
[2m    2 | [0m        fn main() = _0::What(3).[31;1mmust_be_public[0m - 33;
[2m      | [0m

	Bad call to [94;1mmust_be_public[0m with args ([35;3mstruct[0m [94;1mWhat[0m): [94;1mmust_be_public[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        pub struct What { thing: i32 };


        pub 
        fn must_be_public(x: What) = x.thing * 11;

        fn main() = _0::What(3).must_be_public - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct What_xp2o;
int must_be_public_MbR9(const What_xp2o&);

                                #ifndef DEF_What_xp2osgjLsr7
                                #define DEF_What_xp2osgjLsr7
struct What_xp2o
{
                                // shape_hash:    77a7771ff8d51b65
                                // non_triv_mask: 0000000000000000
    int thing;
    explicit operator bool() const noexcept
    {
        return false
            || thing
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return must_be_public_MbR9(What_xp2o { 3 }) - 33;
}

#endif

int main() { return fu_MAIN(); }
struct What_xp2o;

                                #ifndef DEF_What_xp2osgjLsr7
                                #define DEF_What_xp2osgjLsr7
struct What_xp2o
{
                                // shape_hash:    77a7771ff8d51b65
                                // non_triv_mask: 0000000000000000
    int thing;
    explicit operator bool() const noexcept
    {
        return false
            || thing
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int must_be_public_MbR9(/*1:1*/ const What_xp2o& x)
{
    return x.thing * 11;
}

#endif

========

        struct Module { modid: i32; target: Target }
        struct Target { _packed: u64 }

        let modid = 2;
        inline fn modid(t: Target) i32(t._packed);
        inline fn index(t: Target) i32(t._packed >> 32);

        fn Target(shadow modid: i32, index: i32) {
            return Target(modid.u64 | index.u64 << 32);
        }

        import _0;
        fn inspect(m: Module) {
            return modid + m.modid + m.target.modid;
        }

        import _0;
        fn main() {
            let m = Module(3, Target(5, 7));
            return m._1::inspect() - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>

struct Module_sqdT;
struct Target_VZrr;
Target_VZrr Target_MbR9(int, int);
int inspect_LtD7(const Module_sqdT&);

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
                                // shape_hash:    3de952c71e14a8d9
                                // non_triv_mask: 0000000000000000
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_sqdTr3Ec2el
                                #define DEF_Module_sqdTr3Ec2el
struct Module_sqdT
{
                                // shape_hash:    43034ad9c3d9c37f
                                // non_triv_mask: 0000000000000000
    int modid;
    Target_VZrr target;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Module_sqdT m = Module_sqdT { 3, Target_MbR9(5, 7) };
    return inspect_LtD7(m) - 10;
}

#endif

int main() { return fu_MAIN(); }
#include <cstdint>

struct Target_VZrr;

                                #ifndef DEF_modid
                                #define DEF_modid
inline constexpr int modid = 2;
                                #endif

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
                                // shape_hash:    3de952c71e14a8d9
                                // non_triv_mask: 0000000000000000
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Target_VZrr Target_MbR9(const int modid, const int index)
{
    return Target_VZrr { (uint64_t(unsigned(modid)) | (uint64_t(unsigned(index)) << 32ull)) };
}

#endif

// N_SD_HasStaticInit
#include <cstdint>

struct Module_sqdT;
struct Target_VZrr;

                                #ifndef DEF_modid
                                #define DEF_modid
inline constexpr int modid = 2;
                                #endif

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
                                // shape_hash:    3de952c71e14a8d9
                                // non_triv_mask: 0000000000000000
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_Module_sqdTr3Ec2el
                                #define DEF_Module_sqdTr3Ec2el
struct Module_sqdT
{
                                // shape_hash:    43034ad9c3d9c37f
                                // non_triv_mask: 0000000000000000
    int modid;
    Target_VZrr target;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int inspect_LtD7(/*1:1*/ const Module_sqdT& m)
{
    const Target_VZrr* t;
    return (modid + m.modid) + (t = &(m.target), int(unsigned((*t)._packed)));
}

#endif

========

        struct Module { modid: i32; };
        struct Target { _packed: u64; };

        fn modid(t: Target) i32(t._packed & 0xffffff);

        fn Target(modid: i32, index: i32, local: i32) {
            return Target(modid.u64
                        | index.u64 << 24
                        | local.u64 << 44);
        }

        import _0;
        fn inspect(module: Module) = module.modid;

        fn main() _1::inspect([]);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Module_beXB;
int inspect_LtD7(const Module_beXB&);

                                #ifndef DEF_Module_beXB9AkPWDg
                                #define DEF_Module_beXB9AkPWDg
struct Module_beXB
{
                                // shape_hash:    3c274b138abedd1c
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return inspect_LtD7(Module_beXB{});
}

#endif

int main() { return fu_MAIN(); }
struct Module_beXB;

                                #ifndef DEF_Module_beXB9AkPWDg
                                #define DEF_Module_beXB9AkPWDg
struct Module_beXB
{
                                // shape_hash:    3c274b138abedd1c
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int inspect_LtD7(/*1:1*/ const Module_beXB& module)
{
    return module.modid;
}

#endif
#include <cstdint>

struct Target_VZrr;

                                #ifndef DEF_Target_VZrrYUw5Awd
                                #define DEF_Target_VZrrYUw5Awd
struct Target_VZrr
{
                                // shape_hash:    3de952c71e14a8d9
                                // non_triv_mask: 0000000000000000
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int modid_MbR9(/*1:1*/ const Target_VZrr& t)
{
    return int(unsigned((t._packed & 0xffffffull)));
}

Target_VZrr Target_MbR9(const int modid, const int index, const int local)
{
    return Target_VZrr { ((uint64_t(unsigned(modid)) | (uint64_t(unsigned(index)) << 24ull)) | (uint64_t(unsigned(local)) << 44ull)) };
}

#endif

========

        struct Opts { b: i32 };

        fn main() {
            fn muteRest(a, opts?: _0::Opts) a + opts.b;
            return 0.muteRest;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Opts_SCY8;

                                #ifndef DEF_Opts_SCY8DuLp3df
                                #define DEF_Opts_SCY8DuLp3df
struct Opts_SCY8
{
                                // shape_hash:    a09ce3578f7ba21b
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_muteRest_2EjoxhEME02
                                #define DEF_muteRest_2EjoxhEME02
inline static int muteRest_2Ejo(const int a, /*3:3*/ const Opts_SCY8& opts)
{
    return a + opts.b;
}
                                #endif

int fu_MAIN()
{
    return muteRest_2Ejo(0, Opts_SCY8{});
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn ifArray(type: string, hit) {
            if (type.starts(with: "[]"))
                hit(type.slice(2));
        }

        noinline fn tryClearArray(type: string, else!?) {
            ifArray(type): |item|
                return item;

            return else();
        }

        inline fn clearArray(type: string) {
            return tryClearArray(type, else: ||
                throw("Not an array: " ~ type));
        }

        fn main() = _0::clearArray("[]int").len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_YV41b4kB9Pi
                                #define STR_YV41b4kB9Pi
static const fu::str str_YV41b4kB9Pi fu_INIT_PRIORITY(1002) { "[]int"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_eLse_5AZU7WfUH2k
                                #define DEF_eLse_5AZU7WfUH2k
[[noreturn]] inline static fu::never eLse_5AZU(/*1:1*/ fu::view<char> type)
{
    fu::fail(("Not an array: "_view + type));
}
                                #endif

                                #ifndef DEF_tryClearArray_f7CDL6eB8Fd
                                #define DEF_tryClearArray_f7CDL6eB8Fd
inline fu::vec_range<char> tryClearArray_f7CD(/*7:7*/ fu::vec_range<char> type, /*7:7*/ fu::view<char> type_1)
{
    if (starts_ojop(type, "[]"_view))
    {
        fu::vec_range<char> /*type*/ item = fu::get_range(type, 2);
        return item;
    }
    else
        eLse_5AZU(type_1);

}
                                #endif

int fu_MAIN()
{
    fu::vec_range<char> type {};
    return (type.ptr_reassign(str_YV41b4kB9Pi), tryClearArray_f7CD(type, type)).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        noinline fn ifArray(type: string, hit) {
            if (type.starts(with: "[]"))
                hit(type.slice(2));
        }

        noinline fn tryClearArray(type: string, else!?) {
            ifArray(type): |item|
                return item;

            return else();
        }

        inline fn clearArray(type: string) {
            return tryClearArray(type, else: ||
                throw("Not an array: " ~ type));
        }

        fn main() = _0::clearArray("[]int").len - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_YV41b4kB9Pi
                                #define STR_YV41b4kB9Pi
static const fu::str str_YV41b4kB9Pi fu_INIT_PRIORITY(1002) { "[]int"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_eLse_5AZU7WfUH2k
                                #define DEF_eLse_5AZU7WfUH2k
[[noreturn]] inline static fu::never eLse_5AZU(/*1:1*/ fu::view<char> type)
{
    fu::fail(("Not an array: "_view + type));
}
                                #endif

                                #ifndef DEF_tryClearArray_f7CDL6eB8Fd
                                #define DEF_tryClearArray_f7CDL6eB8Fd
inline fu::vec_range<char> tryClearArray_f7CD(/*7:7*/ fu::vec_range<char> type, /*7:7*/ fu::view<char> type_1)
{
    if (starts_ojop(type, "[]"_view))
    {
        fu::vec_range<char> /*type*/ item = fu::get_range(type, 2);
        return item;
    }
    else
        eLse_5AZU(type_1);

}
                                #endif

int fu_MAIN()
{
    const fu::str* type;
    return (type = &(str_YV41b4kB9Pi), tryClearArray_f7CD((*type), (*type))).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Arr(type V) struct { items: V[] };
        fn append !V(
            using ref _:    
                ARR(V),     
            item: V) items ~= item;

        fn main() {
            mut arr: _0::Arr(i32);
            return arr.append(0).len - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:17+3[0m:

[2m      |         fn append !V([0m
[2m      |             using ref _:    [0m
[2m    5 | [0m                [31;1mARR[0m(V),     
[2m      |             item: V) items ~= item;[0m
[2m      | [0m

	[94;1mARR[0m is not defined here.

========

        fn Arr(type V) struct { items: V[] };
        fn append !V(
            using ref _:    
                Arr(V),     
            item: V) items ~= item;

        fn main() {
            mut arr: _0::Arr(i32);
            return arr.append(0).len - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Arr_l0eq;

                                #ifndef DEF_Arr_l0eqb7ZU8L3
                                #define DEF_Arr_l0eqb7ZU8L3
struct Arr_l0eq
{
                                // shape_hash:    d8c8f93b4ddaccb2
                                // non_triv_mask: 000a000000000000
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_append_zowRN4okNLh
                                #define DEF_append_zowRN4okNLh
inline fu::view<int> append_zowR(/*3:3*/ Arr_l0eq& _, const int item)
{
    return (_.items += item);
}
                                #endif

int fu_MAIN()
{
    Arr_l0eq arr {};
    return append_zowR(arr, 0).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========


        fn not_public(x: i32) x * 2;
        pub fn public(x: i32) x * 3;

        fn test(x, apply) apply(x);
        fn main() test(5, fn _0::not_public) - 10;

---- <fail> ----
[2m[0m_1[2m.fu 3:34+10[0m:

[2m      | [0m
[2m      |         fn test(x, apply) apply(x);[0m
[2m    3 | [0m        fn main() test(5, fn _0::[31;1mnot_public[0m) - 10;
[2m      | [0m

	[94;1mnot_public[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========


        pub
        fn not_public(x: i32) x * 2;
        pub fn public(x: i32) x * 3;

        fn test(x, apply) apply(x);
        fn main() test(5, fn _0::not_public) - 10;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int not_public_MbR9(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_YplfLctiXJb
                                #define DEF_test_YplfLctiXJb
inline static int test_Yplf(const int x)
{
    return not_public_MbR9(x);
}
                                #endif

int fu_MAIN()
{
    return test_Yplf(5) - 10;
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int not_public_MbR9(const int x)
{
    return x * 2;
}

int pUblic_MbR9(const int x)
{
    return x * 3;
}

#endif

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            target: Target;
        };

        inline fn globid(.x: i32) x;


        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }


        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 17:50+6[0m:

[2m      |             for (mut i = 0; i < implicits.len; i++) {[0m
[2m      |                 let item        = implicits[i];[0m
[2m   17 | [0m                let overload    = overloads[item.[31;1mglobid[0m - 1];   // PointlessLocal
[2m      |                 if (overload) return overload.x;[0m
[2m      |             }[0m

	Bad call to [94;1mglobid[0m with args ([35;3mnocopy[0m [35;3mstruct[0m [94;1mScopeItem[0m): 

	[35;3minline[0m [94;1mglobid[0m at [2m11:19+6[0m:
[2m   11 | [0m        inline fn [31;1mglobid[0m(.x: i32) x;

	    Cannot match [35;3marg[0m [94;1mglobid[0m:[94;1mx[0m autocall [94;1mx[0m: 

		[35;3mfield[0m [94;1mOverload[0m:[94;1mx[0m at [2m3:35+1[0m:
[2m    3 | [0m        nocopy struct Overload  { [31;1mx[0m: i32 };

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mOverload[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

		[35;3mfield[0m [94;1mTarget[0m:[94;1mx[0m at [2m2:35+1[0m:
[2m    2 | [0m        nocopy struct Target    { [31;1mx[0m: i32 }

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mTarget[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

        Solving [35;3mfn[0m [94;1mScope_exports[0m([94;1mScope[0m) at [2m14:12+13[0m

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            target: Target;
        };

        inline fn globid(.x: i32) x;


        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }

        pub import _0;
        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 17:50+6[0m:

[2m      |             for (mut i = 0; i < implicits.len; i++) {[0m
[2m      |                 let item        = implicits[i];[0m
[2m   17 | [0m                let overload    = overloads[item.[31;1mglobid[0m - 1];   // PointlessLocal
[2m      |                 if (overload) return overload.x;[0m
[2m      |             }[0m

	Bad call to [94;1mglobid[0m with args ([35;3mnocopy[0m [35;3mstruct[0m [94;1mScopeItem[0m): 

	[35;3minline[0m [94;1mglobid[0m at [2m11:19+6[0m:
[2m   11 | [0m        inline fn [31;1mglobid[0m(.x: i32) x;

	    Cannot match [35;3marg[0m [94;1mglobid[0m:[94;1mx[0m autocall [94;1mx[0m: 

		[35;3mfield[0m [94;1mOverload[0m:[94;1mx[0m at [2m3:35+1[0m:
[2m    3 | [0m        nocopy struct Overload  { [31;1mx[0m: i32 };

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mOverload[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

		[35;3mfield[0m [94;1mTarget[0m:[94;1mx[0m at [2m2:35+1[0m:
[2m    2 | [0m        nocopy struct Target    { [31;1mx[0m: i32 }

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mTarget[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

        Solving [35;3mfn[0m [94;1mScope_exports[0m([94;1mScope[0m) at [2m14:12+13[0m

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            target: Target;
        };

        inline fn globid(.x: i32) x;

        pub import _0;
        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }


        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- <fail> ----
[2m[0m_1[2m.fu 5:50+6[0m:

[2m      |             for (mut i = 0; i < implicits.len; i++) {[0m
[2m      |                 let item        = implicits[i];[0m
[2m    5 | [0m                let overload    = overloads[item.[31;1mglobid[0m - 1];   // PointlessLocal
[2m      |                 if (overload) return overload.x;[0m
[2m      |             }[0m

	Bad call to [94;1mglobid[0m with args ([35;3mnocopy[0m [35;3mstruct[0m [94;1mScopeItem[0m): 

	[35;3minline[0m [94;1mglobid[0m at [2m[0m_0[2m.fu 11:19+6[0m:
[2m   11 | [0m        inline fn [31;1mglobid[0m(.x: i32) x;

	    Cannot match [35;3marg[0m [94;1mglobid[0m:[94;1mx[0m autocall [94;1mx[0m: 

		[35;3mfield[0m [94;1mOverload[0m:[94;1mx[0m at [2m[0m_0[2m.fu 3:35+1[0m:
[2m    3 | [0m        nocopy struct Overload  { [31;1mx[0m: i32 };

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mOverload[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

		[35;3mfield[0m [94;1mTarget[0m:[94;1mx[0m at [2m[0m_0[2m.fu 2:35+1[0m:
[2m    2 | [0m        nocopy struct Target    { [31;1mx[0m: i32 }

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mTarget[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

        Solving [35;3mfn[0m [94;1mScope_exports[0m([94;1mScope[0m) at [2m2:12+13[0m

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            target: Target;
        };

        inline fn globid(.x: i32) x;

        pub import _0;
        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }

        pub import _1;
        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- <fail> ----
[2m[0m_1[2m.fu 5:50+6[0m:

[2m      |             for (mut i = 0; i < implicits.len; i++) {[0m
[2m      |                 let item        = implicits[i];[0m
[2m    5 | [0m                let overload    = overloads[item.[31;1mglobid[0m - 1];   // PointlessLocal
[2m      |                 if (overload) return overload.x;[0m
[2m      |             }[0m

	Bad call to [94;1mglobid[0m with args ([35;3mnocopy[0m [35;3mstruct[0m [94;1mScopeItem[0m): 

	[35;3minline[0m [94;1mglobid[0m at [2m[0m_0[2m.fu 11:19+6[0m:
[2m   11 | [0m        inline fn [31;1mglobid[0m(.x: i32) x;

	    Cannot match [35;3marg[0m [94;1mglobid[0m:[94;1mx[0m autocall [94;1mx[0m: 

		[35;3mfield[0m [94;1mOverload[0m:[94;1mx[0m at [2m[0m_0[2m.fu 3:35+1[0m:
[2m    3 | [0m        nocopy struct Overload  { [31;1mx[0m: i32 };

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mOverload[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

		[35;3mfield[0m [94;1mTarget[0m:[94;1mx[0m at [2m[0m_0[2m.fu 2:35+1[0m:
[2m    2 | [0m        nocopy struct Target    { [31;1mx[0m: i32 }

		    [35;3marg[0m [94;1mthis[0m expects [35;3mstruct[0m [94;1mTarget[0m, got [35;3mstruct[0m [94;1mScopeItem[0m

        Solving [35;3mfn[0m [94;1mScope_exports[0m([94;1mScope[0m) at [2m2:12+13[0m

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            using 
            target: Target;
        };

        inline fn globid(.x: i32) x;


        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }


        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Scope_exports_MbR9(/*1:1*/ const Scope_VNFX& scope)
{
    for (int i = 0; i < scope.implicits.size(); i++)
    {
        const ScopeItem_z1Yz& /*scope|static*/ item = scope.implicits[i];
        int x;
        const Overload_lo9g& /*scope|static*/ overload = scope.overloads[((x = item.target.x, x) - 1)];
        if (overload)
            return overload.x;

    };
    return 0;
}

int fu_MAIN()
{
    Scope_VNFX scope = Scope_VNFX { fu::vec<Overload_lo9g> {{ Overload_lo9g { 3 } }}, fu::vec<ScopeItem_z1Yz> {{ ScopeItem_z1Yz { Target_DZAM { 1 } } }} };
    return Scope_exports_MbR9(scope) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            using 
            target: Target;
        };

        inline fn globid(.x: i32) x;


        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }

        pub import _0;
        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;
int Scope_exports_MbR9(const Scope_VNFX&);

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Scope_VNFX scope = Scope_VNFX { fu::vec<Overload_lo9g> {{ Overload_lo9g { 3 } }}, fu::vec<ScopeItem_z1Yz> {{ ScopeItem_z1Yz { Target_DZAM { 1 } } }} };
    return Scope_exports_MbR9(scope) - 3;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int Scope_exports_MbR9(/*1:1*/ const Scope_VNFX& scope)
{
    for (int i = 0; i < scope.implicits.size(); i++)
    {
        const ScopeItem_z1Yz& /*scope|static*/ item = scope.implicits[i];
        int x;
        const Overload_lo9g& /*scope|static*/ overload = scope.overloads[((x = item.target.x, x) - 1)];
        if (overload)
            return overload.x;

    };
    return 0;
}

#endif

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            using 
            target: Target;
        };

        inline fn globid(.x: i32) x;

        pub import _0;
        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }


        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Scope_exports_LtD7(/*1:1*/ const Scope_VNFX& scope)
{
    for (int i = 0; i < scope.implicits.size(); i++)
    {
        const ScopeItem_z1Yz& /*scope|static*/ item = scope.implicits[i];
        int x;
        const Overload_lo9g& /*scope|static*/ overload = scope.overloads[((x = item.target.x, x) - 1)];
        if (overload)
            return overload.x;

    };
    return 0;
}

int fu_MAIN()
{
    Scope_VNFX scope = Scope_VNFX { fu::vec<Overload_lo9g> {{ Overload_lo9g { 3 } }}, fu::vec<ScopeItem_z1Yz> {{ ScopeItem_z1Yz { Target_DZAM { 1 } } }} };
    return Scope_exports_LtD7(scope) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct Target    { x: i32 }
        nocopy struct Overload  { x: i32 };
        nocopy struct Scope     { overloads: Overload[]; implicits: ScopeItem[] };

        nocopy struct ScopeItem {

            using 
            target: Target;
        };

        inline fn globid(.x: i32) x;

        pub import _0;
        fn Scope_exports(using implicit scope: Scope) {
            for (mut i = 0; i < implicits.len; i++) {
                let item        = implicits[i];
                let overload    = overloads[item.globid - 1];   // PointlessLocal
                if (overload) return overload.x;
            }

            return 0;
        }

        pub import _1;
        fn main() {
            implicit mut scope = Scope(overloads: [ Overload(3) ], implicits: [ ScopeItem(Target(1)) ]);
            return Scope_exports() - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;
int Scope_exports_LtD7(const Scope_VNFX&);

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Scope_VNFX scope = Scope_VNFX { fu::vec<Overload_lo9g> {{ Overload_lo9g { 3 } }}, fu::vec<ScopeItem_z1Yz> {{ ScopeItem_z1Yz { Target_DZAM { 1 } } }} };
    return Scope_exports_LtD7(scope) - 3;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>

struct Scope_VNFX;
struct Overload_lo9g;
struct ScopeItem_z1Yz;
struct Target_DZAM;

                                #ifndef DEF_Target_DZAMHEQjb9l
                                #define DEF_Target_DZAMHEQjb9l
struct Target_DZAM
{
                                // shape_hash:    d2028506af73356f
                                // non_triv_mask: 0000000000020000
    int x;
    Target_DZAM(const Target_DZAM&) = delete;
    Target_DZAM(Target_DZAM&&) = default;
    Target_DZAM& operator=(const Target_DZAM&) = delete;
    Target_DZAM& operator=(Target_DZAM&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_lo9gdBnPQN6
                                #define DEF_Overload_lo9gdBnPQN6
struct Overload_lo9g
{
                                // shape_hash:    9fac08e782c404f4
                                // non_triv_mask: 0000000000000020
    int x;
    Overload_lo9g(const Overload_lo9g&) = delete;
    Overload_lo9g(Overload_lo9g&&) = default;
    Overload_lo9g& operator=(const Overload_lo9g&) = delete;
    Overload_lo9g& operator=(Overload_lo9g&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_VNFXCxuKwZe
                                #define DEF_Scope_VNFXCxuKwZe
struct Scope_VNFX
{
                                // shape_hash:    3a3f5fabe6a20aea
                                // non_triv_mask: 0020000180030020
    fu::vec<Overload_lo9g> overloads;
    fu::vec<ScopeItem_z1Yz> implicits;
    Scope_VNFX(const Scope_VNFX&) = delete;
    Scope_VNFX(Scope_VNFX&&) = default;
    Scope_VNFX& operator=(const Scope_VNFX&) = delete;
    Scope_VNFX& operator=(Scope_VNFX&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_z1YzJAizU6a
                                #define DEF_ScopeItem_z1YzJAizU6a
struct ScopeItem_z1Yz
{
                                // shape_hash:    98a631ce53856c57
                                // non_triv_mask: 0020000000020000
    Target_DZAM target;
    ScopeItem_z1Yz(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz(ScopeItem_z1Yz&&) = default;
    ScopeItem_z1Yz& operator=(const ScopeItem_z1Yz&) = delete;
    ScopeItem_z1Yz& operator=(ScopeItem_z1Yz&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int Scope_exports_LtD7(/*1:1*/ const Scope_VNFX& scope)
{
    for (int i = 0; i < scope.implicits.size(); i++)
    {
        const ScopeItem_z1Yz& /*scope|static*/ item = scope.implicits[i];
        int x;
        const Overload_lo9g& /*scope|static*/ overload = scope.overloads[((x = item.target.x, x) - 1)];
        if (overload)
            return overload.x;

    };
    return 0;
}

#endif

========
//file flat/List.fu
        struct List(type T) { data: T[] }

        fn main() {
            mut list: flat::List(i32);
            return list.data.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct List_OHOi;

                                #ifndef DEF_List_OHOi84QBbr5
                                #define DEF_List_OHOi84QBbr5
struct List_OHOi
{
                                // shape_hash:    4529515aaba785f3
                                // non_triv_mask: 0008010000000000
    fu::vec<int> data;
    explicit operator bool() const noexcept
    {
        return false
            || data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    List_OHOi list {};
    return list.data.size();
}

#endif

int main() { return fu_MAIN(); }

========
//file markdown/markdown.fu
        struct Document { value: int };

        fn main() markdown::Document().value;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Document_9Lbk;

                                #ifndef DEF_Document_9LbkcR7XL72
                                #define DEF_Document_9LbkcR7XL72
struct Document_9Lbk
{
                                // shape_hash:    75770b81c9e61c81
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Document_9Lbk{}.value;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Batch { x: i32[]; y: i32[] };

        type ViewQuads = Batch;

        let VIEW_QUADS: ViewQuads = [];

        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1001) {};

int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };

        type ViewQuads = Batch;

        let VIEW_QUADS: ViewQuads = [];
        pub import _0;
        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS;
int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1001) {};
#endif

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };

        type ViewQuads = Batch;
        pub import _0;
        let VIEW_QUADS: ViewQuads = [];

        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1002) {};

int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };

        type ViewQuads = Batch;
        pub import _0;
        let VIEW_QUADS: ViewQuads = [];
        pub import _1;
        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS;
int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1002) {};
#endif

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };
        pub import _0;
        type ViewQuads = Batch;

        let VIEW_QUADS: ViewQuads = [];

        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1002) {};

int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };
        pub import _0;
        type ViewQuads = Batch;

        let VIEW_QUADS: ViewQuads = [];
        pub import _1;
        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS;
int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1002) {};
#endif

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };
        pub import _0;
        type ViewQuads = Batch;
        pub import _1;
        let VIEW_QUADS: ViewQuads = [];

        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1003) {};

int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        struct Batch { x: i32[]; y: i32[] };
        pub import _0;
        type ViewQuads = Batch;
        pub import _1;
        let VIEW_QUADS: ViewQuads = [];
        pub import _2;
        fn main() VIEW_QUADS.x.len + VIEW_QUADS.y.len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS;
int fu_MAIN()
{
    return VIEW_QUADS.x.size() + VIEW_QUADS.y.size();
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>
#include <fu/init_priority.h>

struct Batch_np9W;

                                #ifndef DEF_Batch_np9WfbS6tfg
                                #define DEF_Batch_np9WfbS6tfg
struct Batch_np9W
{
                                // shape_hash:    986eed6b9a0a44db
                                // non_triv_mask: 0028000000000000
    fu::vec<int> x;
    fu::vec<int> y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

extern const Batch_np9W VIEW_QUADS fu_INIT_PRIORITY(1003) {};
#endif

// N_SD_HasStaticInit

========

        primitive MyPrim: int;
        fn addback !T(ref a: T, ref b: MyPrim, which = .a) {
            a.which += b;
            b += a.which;
        }


        import _0;
        struct TwoMyPrims { a: MyPrim; b: MyPrim };

        fn main() {
            mut a = TwoMyPrims(1, 3);
            a.b.addback(:a);
            return i32(a.a + a.b) - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct TwoMyPrims_Pq13;
typedef int MyPrim_ZzM3;

                                #ifndef DEF_MyPrim_ZzM3
                                #define DEF_MyPrim_ZzM3
                                #endif

                                #ifndef DEF_TwoMyPrims_Pq137nmQmL3
                                #define DEF_TwoMyPrims_Pq137nmQmL3
struct TwoMyPrims_Pq13
{
                                // shape_hash:    b7f1d60502b77db2
                                // non_triv_mask: 0000000000000000
    MyPrim_ZzM3 a;
    MyPrim_ZzM3 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___rDMosHncGQg
                                #define DEF___rDMosHncGQg
inline static MyPrim_ZzM3& _rDMo(/*1:1*/ TwoMyPrims_Pq13& _)
{
    return _.a;
}
                                #endif

                                #ifndef DEF___LGmaIBH2cHg
                                #define DEF___LGmaIBH2cHg
inline static MyPrim_ZzM3 _LGma(/*1:1*/ const TwoMyPrims_Pq13& _)
{
    return _.a;
}
                                #endif

                                #ifndef DEF_addback_WdIonnq2A4a
                                #define DEF_addback_WdIonnq2A4a
inline void addback_WdIo(/*7:5*/ TwoMyPrims_Pq13& a, /*7:7*/ MyPrim_ZzM3& b)
{
    _rDMo(a) += b;
    b += _LGma(a);
}
                                #endif

int fu_MAIN()
{
    TwoMyPrims_Pq13 a = TwoMyPrims_Pq13 { 1, 3 };
    addback_WdIo(a, a.b);
    return int((a.a + a.b)) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        primitive MyPrim: int;
        fn addback !T(ref a: T, ref b: MyPrim, which = .a) {
            a.which += b;
            b += a.which;
        }


        struct TwoMyPrims { a: _0::MyPrim; b: _0::MyPrim };

        fn main() {
            mut a = TwoMyPrims(1, 3);
            a.b.addback(:a);
            return i32(a.a + a.b) - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct TwoMyPrims_Pq13;
typedef int MyPrim_ZzM3;

                                #ifndef DEF_MyPrim_ZzM3
                                #define DEF_MyPrim_ZzM3
                                #endif

                                #ifndef DEF_TwoMyPrims_Pq137nmQmL3
                                #define DEF_TwoMyPrims_Pq137nmQmL3
struct TwoMyPrims_Pq13
{
                                // shape_hash:    b7f1d60502b77db2
                                // non_triv_mask: 0000000000000000
    MyPrim_ZzM3 a;
    MyPrim_ZzM3 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___rDMosHncGQg
                                #define DEF___rDMosHncGQg
inline static MyPrim_ZzM3& _rDMo(/*1:1*/ TwoMyPrims_Pq13& _)
{
    return _.a;
}
                                #endif

                                #ifndef DEF___LGmaIBH2cHg
                                #define DEF___LGmaIBH2cHg
inline static MyPrim_ZzM3 _LGma(/*1:1*/ const TwoMyPrims_Pq13& _)
{
    return _.a;
}
                                #endif

                                #ifndef DEF_addback_WdIonnq2A4a
                                #define DEF_addback_WdIonnq2A4a
inline void addback_WdIo(/*7:5*/ TwoMyPrims_Pq13& a, /*7:7*/ MyPrim_ZzM3& b)
{
    _rDMo(a) += b;
    b += _LGma(a);
}
                                #endif

int fu_MAIN()
{
    TwoMyPrims_Pq13 a = TwoMyPrims_Pq13 { 1, 3 };
    addback_WdIo(a, a.b);
    return int((a.a + a.b)) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        primitive A: int;
        primitive B: int;
        fn process(v: A or B, what) what(v);


        import _0;
        fn three() A(3);


        fn main() three.process(|v| v * 2).int - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int A_nzG1;

                                #ifndef DEF_A_nzG1
                                #define DEF_A_nzG1
                                #endif

#ifndef fu_NO_fdefs

static A_nzG1 three_LtD7()
{
    return A_nzG1(3);
}

                                #ifndef DEF___0QDY2Bg772i
                                #define DEF___0QDY2Bg772i
inline static A_nzG1 _0QDY(const A_nzG1 v)
{
    return v * 2;
}
                                #endif

                                #ifndef DEF_process_dnCq6cEcgxc
                                #define DEF_process_dnCq6cEcgxc
inline A_nzG1 process_dnCq(const A_nzG1 v)
{
    return _0QDY(v);
}
                                #endif

int fu_MAIN()
{
    return int(process_dnCq(three_LtD7())) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        primitive A: int;
        primitive B: int;
        fn process(v: A or B, what) what(v);


        fn three() _0::A(3);


        fn main() three.process(|v| v * 2).int - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int A_nzG1;

                                #ifndef DEF_A_nzG1
                                #define DEF_A_nzG1
                                #endif

#ifndef fu_NO_fdefs

static A_nzG1 three_LtD7()
{
    return A_nzG1(3);
}

                                #ifndef DEF___0QDY2Bg772i
                                #define DEF___0QDY2Bg772i
inline static A_nzG1 _0QDY(const A_nzG1 v)
{
    return v * 2;
}
                                #endif

                                #ifndef DEF_process_dnCq6cEcgxc
                                #define DEF_process_dnCq6cEcgxc
inline A_nzG1 process_dnCq(const A_nzG1 v)
{
    return _0QDY(v);
}
                                #endif

int fu_MAIN()
{
    return int(process_dnCq(three_LtD7())) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        let HELLO = 0;

        fn main() {

            return _0::HELO;                
        }

---- <fail> ----
[2m[0m_1[2m.fu 4:24+4[0m:

[2m      |         fn main() {[0m
[2m      | [0m
[2m    4 | [0m            return _0::[31;1mHELO[0m;                
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1mHELO[0m: [94;1mHELO[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        let HELLO = 0;

        fn main() {

            return _0::HELLO;               
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_HELLO
                                #define DEF_HELLO
inline constexpr int HELLO = 0;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HELLO;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_HELLO
                                #define DEF_HELLO
inline constexpr int HELLO = 0;
                                #endif

// N_SD_HasStaticInit

========

        struct Hey(type T) { world: T };

        type Hello = _0::Hey(int);

        fn main() _1::Hello.world;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_eaOT;

                                #ifndef DEF_Hey_eaOT5xhtO3k
                                #define DEF_Hey_eaOT5xhtO3k
struct Hey_eaOT
{
                                // shape_hash:    a7e87e0b00d3ba9e
                                // non_triv_mask: 0000000000000000
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Hey_eaOT{}.world;
}

#endif

int main() { return fu_MAIN(); }

========

        let a = 1;
        shadow let a = a + 1;
        return a - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const int a_1 = (a + 1);
    return a_1 - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        inline fn outer() inner(); // <- this reset root-scope
        inline fn inner() {
            // <- so main::i was visible here
            for (mut i = 0; i < 10; i++) return i;
            return 1;
        }
        fn main() {
            for (mut i = 0; i < 10; i++) return outer();
            return 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    for (int i = 0; i < 10; i++)
    {
        for (int i_1 = 0; i_1 < 10; i_1++)
            return i_1;

        return 1;
    };
    return 1;
}

#endif

int main() { return fu_MAIN(); }

========

        pub struct Target { modid: i32; packed: u32; };

        pub fn index(t: Target) i32(t.packed & 0x7fffffff);

        pub fn local_eq(t: Target, index: i32, implicit modid: i32)
            modid - t.modid || index - t.index;

        fn main() {
            let implicit modid = 1;
            return local_eq(Target(1, 0x80000002), 7) - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Target_aB59;

                                #ifndef DEF_Target_aB592x1CfAj
                                #define DEF_Target_aB592x1CfAj
struct Target_aB59
{
                                // shape_hash:    c0ff72b826d7d14e
                                // non_triv_mask: 0000000000000000
    int modid;
    unsigned packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int index_MbR9(/*1:1*/ const Target_aB59& t)
{
    return int((t.packed & 0x7fffffffu));
}

int local_eq_MbR9(/*7:7*/ const Target_aB59& t, const int index, /*7:7*/ const int modid)
{
    int _0;
    return (_0 = (modid - t.modid)) ? _0 : (index - index_MbR9(t));
}

int fu_MAIN()
{
    const int modid = 1;
    return local_eq_MbR9(Target_aB59 { 1, 0x80000002u }, 7, modid) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        nocopy struct P { secs: P[] };

        fn matchImplicitArgByName_closuresAndShadowing(prims: P[]) {
            struct Helper { idx: i32; };

            using fn GET(using _: Helper) prims[idx];

            shadow mut prims = {
                mut res: Helper[];
                for (mut i = 0; i < prims.len; i++)
                    res ~= Helper(i);                           // ConstCast
                res                                             // GNUStmtExpr
            };

            prims.sort(|a, b| a.secs.len < b.secs.len);

            mut res = 101;
            for (mut i = 0; i < prims.len; i++) {
                let m = prims[i];
                res += m.secs.len;
                res *= m.secs.len;
            }

            return res;
        }

        fn main() {
            let prims = [ P([ P, P, P ]), P, P([ P ]), P([ P, P ]) ];
            let res = matchImplicitArgByName_closuresAndShadowing(prims);
            return res == 27 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(512) uniq_count(4) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct P_5Vs8;
struct Helper_Mgv4;

                                #ifndef DEF_P_5Vs8OoRs4Ba
                                #define DEF_P_5Vs8OoRs4Ba
struct P_5Vs8
{
                                // shape_hash:    36b841e82a2d07b7
                                // non_triv_mask: 0000000080000200
    fu::vec<P_5Vs8> secs;
    P_5Vs8(const P_5Vs8&) = delete;
    P_5Vs8(P_5Vs8&&) = default;
    P_5Vs8& operator=(const P_5Vs8&) = delete;
    P_5Vs8& operator=(P_5Vs8&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || secs
        ;
    }
};
                                #endif

                                #ifndef DEF_Helper_Mgv4sZICNA7
                                #define DEF_Helper_Mgv4sZICNA7
struct Helper_Mgv4
{
                                // shape_hash:    c8c9a2b776362785
                                // non_triv_mask: 0000000000000000
    int idx;
    explicit operator bool() const noexcept
    {
        return false
            || idx
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const P_5Vs8& GET_MbR9(/*3:3*/ const Helper_Mgv4& _, /*3:3*/ fu::view<P_5Vs8> prims)
{
    return prims[_.idx];
}

                                #ifndef DEF___9qfaH5kTep3
                                #define DEF___9qfaH5kTep3
inline static bool _9qfa(/*7:7*/ const Helper_Mgv4& a, /*7:7*/ const Helper_Mgv4& b, /*7:7*/ fu::view<P_5Vs8> prims)
{
    return GET_MbR9(a, prims).secs.size() < GET_MbR9(b, prims).secs.size();
}
                                #endif

                                #ifndef DEF_sort_9uctPJKM5V1
                                #define DEF_sort_9uctPJKM5V1
inline static void sort_9uct(/*1:1*/ fu::vec_range_mut<Helper_Mgv4> a, /*3:3*/ fu::view<P_5Vs8> prims)
{
    Helper_Mgv4 l {};
    Helper_Mgv4 r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _9qfa(l, r, prims);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_NoereTyGXo2
                                #define DEF_sort_NoereTyGXo2
inline void sort_Noer(/*3:3*/ fu::vec_range_mut<Helper_Mgv4> a, /*7:7*/ fu::view<P_5Vs8> prims)
{
    sort_9uct(a, prims);
}
                                #endif

static int matchImplicitArgByName_closuresAndShadowing_MbR9(/*1:1*/ fu::view<P_5Vs8> prims)
{
    fu::vec<Helper_Mgv4> res {};
    fu::vec<Helper_Mgv4>* BL_1_v;
    fu::vec<Helper_Mgv4> prims_1 = static_cast<fu::vec<Helper_Mgv4>&&>(const_cast<fu::vec<Helper_Mgv4>&>((__extension__ (
    {
        res = {};
        for (int i = 0; i < prims.size(); i++)
        {
            res += Helper_Mgv4 { i };
        };
        BL_1_v = &(res);
        (void)0;
    }), *BL_1_v)));
    sort_Noer(prims_1, prims);
    int res_1 = 101;
    for (int i = 0; i < prims_1.size(); i++)
    {
        const Helper_Mgv4& /*prims_1|static*/ m = prims_1[i];
        res_1 += GET_MbR9(m, prims).secs.size();
        res_1 *= GET_MbR9(m, prims).secs.size();
    };
    return res_1;
}

int fu_MAIN()
{
    fu::vec<P_5Vs8> prims = fu::vec<P_5Vs8> {{ P_5Vs8 { fu::vec<P_5Vs8> {{ P_5Vs8{}, P_5Vs8{}, P_5Vs8{} }} }, P_5Vs8{}, P_5Vs8 { fu::vec<P_5Vs8> {{ P_5Vs8{} }} }, P_5Vs8 { fu::vec<P_5Vs8> {{ P_5Vs8{}, P_5Vs8{} }} } }};
    const int res = matchImplicitArgByName_closuresAndShadowing_MbR9(prims);
    if (res == 27)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        fn hello(x: int) = x * 10;
        fn originalHello(x: int) = x.hello;

        shadow fn hello(x: int) = x * 100;
        fn shadowedHello(x: int) = x.hello;


        fn main() =  1.originalHello + 2.shadowedHello == 210 ? 0 : 1;

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:16+2[0m:

[2m      |         fn originalHello(x: int) = x.hello;[0m
[2m      | [0m
[2m    5 | [0m        shadow [31;1mfn[0m hello(x: int) = x * 100;
[2m      |         fn shadowedHello(x: int) = x.hello;[0m
[2m      | [0m

	Shadowing is currently only supported inside functions.

========

        fn hello(x: int) = x * 10;
        fn originalHello(x: int) = x.hello;

        shadow fn hello(x: int) = x * 100;
        fn shadowedHello(x: int) = x.hello;


        return       1.originalHello + 2.shadowedHello == 210 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hello_MbR9(const int x)
{
    return x * 10;
}

static int originalHello_MbR9(const int x)
{
    return hello_MbR9(x);
}

static int hello_kGbb(const int x)
{
    return x * 100;
}

static int shadowedHello_MbR9(const int x)
{
    return hello_kGbb(x);
}

int fu_MAIN()
{
    if ((originalHello_MbR9(1) + shadowedHello_MbR9(2)) == 210)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct HasInt { i: i32; };

        fn test(s: HasInt): &i32 {
            let i = s.i;
            return i;
        }

        fn main() HasInt(-1).test + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct HasInt_fNav;

                                #ifndef DEF_HasInt_fNavPRSAUQ3
                                #define DEF_HasInt_fNavPRSAUQ3
struct HasInt_fNav
{
                                // shape_hash:    d2edc5bfac022ec2
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const HasInt_fNav& s)
{
    const int /*s*/ i = s.i;
    return i;
}

int fu_MAIN()
{
    return test_MbR9(HasInt_fNav { -1 }) + 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32): &i32 = x;
        fn main() test(3) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const int x)
{
    return x;
}

int fu_MAIN()
{
    return test_MbR9(3) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32): &i32 {
            fn inner() x;
            return inner;
        }

        fn main() test(3) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int inner_MbR9(/*1:1*/ const int x)
{
    return x;
}

static int test_MbR9(/*1:1*/ const int x)
{
    return inner_MbR9(x);
}

int fu_MAIN()
{
    return test_MbR9(3) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct I { v: i32; };

        fn test(x: I): &i32 {
            fn inner() x.v;
            return inner;
        }

        fn main() test(I(3)) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct I_c2FC;

                                #ifndef DEF_I_c2FCGxZPob0
                                #define DEF_I_c2FCGxZPob0
struct I_c2FC
{
                                // shape_hash:    c3378ae8b6b44220
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_MbR9(/*1:1*/ const I_c2FC& x)
{
    return x.v;
}

static int test_MbR9(/*1:1*/ const I_c2FC& x)
{
    return inner_MbR9(x);
}

int fu_MAIN()
{
    return test_MbR9(I_c2FC { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() x.v[0];
            return inner;
        }

        fn main() test(I([3])) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct I_ly6V;

                                #ifndef DEF_I_ly6VxNpxLKl
                                #define DEF_I_ly6VxNpxLKl
struct I_ly6V
{
                                // shape_hash:    150559335e4c26df
                                // non_triv_mask: 0008200000000000
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_MbR9(/*1:1*/ const I_ly6V& x)
{
    return x.v[0];
}

static int test_MbR9(/*1:1*/ const I_ly6V& x)
{
    return inner_MbR9(x);
}

int fu_MAIN()
{
    return test_MbR9(I_ly6V { fu::vec<int> {{ 3 }} }) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() {
                let v = x.v;
                return v[0];
            }

            return inner;
        }

        fn main() test(I([3])) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct I_ly6V;

                                #ifndef DEF_I_ly6VxNpxLKl
                                #define DEF_I_ly6VxNpxLKl
struct I_ly6V
{
                                // shape_hash:    150559335e4c26df
                                // non_triv_mask: 0008200000000000
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_MbR9(/*1:1*/ const I_ly6V& x)
{
    fu::view<int> /*x*/ v = x.v;
    return v[0];
}

static int test_MbR9(/*1:1*/ const I_ly6V& x)
{
    return inner_MbR9(x);
}

int fu_MAIN()
{
    return test_MbR9(I_ly6V { fu::vec<int> {{ 3 }} }) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn noReturn() throw ("ex");

        fn doesReturn(a: i32) {
            if (a > 0) return noReturn();
            return a;
        }

        fn main() doesReturn(-3) + 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never noReturn_MbR9()
{
    fu::fail(fu::str("ex"_fu));
}

static int doesReturn_MbR9(/*1:1*/ const int a)
{
    if (a > 0)
        noReturn_MbR9();
    else
        return a;

}

int fu_MAIN()
{
    return doesReturn_MbR9(-3) + 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Context { modules: Module[]; };
        struct Module  { fname: i32; };

        fn test(implicit ctx: Context) {
            fn findModule(fname: i32): &Module {
                let modules = ctx.modules;
                for (mut i = 0; i < modules.len; i++) {
                    let module = modules[i];
                    if (module.fname == fname)
                        return module;
                }

                throw("Cannot locate: " ~ fname);
            }

            return findModule(0);
        }

        fn main() {
            let implicit ctx = Context([ Module ]);
            return test.fname;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct Context_uSnX;
struct Module_Ce9B;

                                #ifndef DEF_Module_Ce9Bx37n822
                                #define DEF_Module_Ce9Bx37n822
struct Module_Ce9B
{
                                // shape_hash:    67017a0622342b71
                                // non_triv_mask: 0000000000000000
    int fname;
    explicit operator bool() const noexcept
    {
        return false
            || fname
        ;
    }
};
                                #endif

                                #ifndef DEF_Context_uSnXb2j0GSh
                                #define DEF_Context_uSnXb2j0GSh
struct Context_uSnX
{
                                // shape_hash:    6ec32c2baef0840d
                                // non_triv_mask: 0000040004000000
    fu::vec<Module_Ce9B> modules;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static const Module_Ce9B& findModule_MbR9(const int fname, /*3:3*/ const Context_uSnX& ctx)
{
    fu::view<Module_Ce9B> /*ctx*/ modules = ctx.modules;
    for (int i = 0; i < modules.size(); i++)
    {
        const Module_Ce9B& /*modules|static*/ module = modules[i];
        if (module.fname == fname)
            return module;

    };
    fu::fail(x7E_rA00("Cannot locate: "_view, fu::i64dec(fname)));
}

static const Module_Ce9B& test_MbR9(/*1:1*/ const Context_uSnX& ctx)
{
    return findModule_MbR9(0, ctx);
}

int fu_MAIN()
{
    Context_uSnX ctx = Context_uSnX { fu::vec<Module_Ce9B> {{ Module_Ce9B{} }} };
    return test_MbR9(ctx).fname;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn noReturn() throw ("ex");

        fn returnVoid(a: i32): void {
            if (a > 0) return noReturn();
        }

        fn main() {
            returnVoid(0);
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never noReturn_MbR9()
{
    fu::fail(fu::str("ex"_fu));
}

static void returnVoid_MbR9(const int a)
{
    if (a > 0)
        noReturn_MbR9();

}

int fu_MAIN()
{
    returnVoid_MbR9(0);
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn parseQualifierChain(mut i: i32): i32 {
            for (;;) {
                if !(i & 15) return i;
                i--;
            }
        }

        fn main() parseQualifierChain(15);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int parseQualifierChain_MbR9(int i)
{
    for (; ; )
    {
        if (!(i & 15))
            return i;
        else
            i--;

    };
}

int fu_MAIN()
{
    return parseQualifierChain_MbR9(15);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn main()
        {
            mut sum = 0;
            fn compile(x: i32)
            {
                // 1. this throw contributed a 'never' ret_count.
                x || throw ("x=0");
                if (x & 1) compile(x + 1); // 2. then this recursion did something.
                sum += x; // <- also this must be a closure.
                // 3. finally no ret_actual but non-zero ret_count.
            }

            compile(2);
            return sum - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>

static void compile_MbR9(int, int&);

#ifndef fu_NO_fdefs

static void compile_MbR9(const int x, /*3:3*/ int& sum)
{
    if (x)
    {
        if (x & 1)
            compile_MbR9((x + 1), sum);

        sum += x;
    }
    else
        fu::fail(fu::str("x=0"_fu));

}

int fu_MAIN()
{
    int sum = 0;
    compile_MbR9(2, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedCall

========

        fn main()
        {
            mut sum = 0;
            fn getModule(fname: string) fname.len;
            fn compile(fname: string, via: string = "")
            {
                let module = getModule(fname) || throw ("import circle: '" ~ via ~ fname ~ "'.");
                if (module & 1) {
                    let fuzimports = fname.split("a");
                    for (mut i = 0; i < fuzimports.len; i++)
                        compile(
                            fname: fuzimports[i],
                              via: fname ~ " <- " ~ via);
                }

                sum += module;
            }

            compile("ab");
            return sum - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

static void compile_MbR9(fu::vec_range<char>, fu::view<char>, int&);

                                #ifndef STR_MBMc7M8oSL5
                                #define STR_MBMc7M8oSL5
static const fu::str str_MBMc7M8oSL5 fu_INIT_PRIORITY(1001) { "ab"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int getModule_MbR9(/*1:1*/ fu::view<char> fname)
{
    return fname.size();
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

static void compile_MbR9(/*7:7*/ fu::vec_range<char> fname, /*7:7*/ fu::view<char> via, /*4:4*/ int& sum)
{
    int _0;
    const int module = ((_0 = getModule_MbR9(fname)) ? _0 : fu::fail(((("import circle: '"_view + via) + fname) + "'."_view)));
    if (module & 1)
    {
        fu::vec<fu::str> fuzimports = split_t3LL(fname, "a"_view);
        for (int i = 0; i < fuzimports.size(); i++)
            compile_MbR9(fuzimports[i], ((fname + " <- "_view) + via), sum);

    };
    sum += module;
}

int fu_MAIN()
{
    int sum = 0;
    compile_MbR9(str_MBMc7M8oSL5, ""_view, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_COWRestrict

========

        fn main()
        {
            mut sum = 0;
            fn getModule(fname: string) fname.len;
            fn compile(fname: string, via: string = "")
            {
                let module = getModule(fname) || throw ("import circle: '" ~ via ~ fname ~ "'.");
                if (module & 1) {
                    let fuzimports = fname.split("a");
                    for (mut i = 0; i < fuzimports.len; i++)
                        compile(
                            fname: fuzimports[i],
                              via: fname ~ " <- " ~ via);
                }

                sum += module;
            }

            compile("ab");
            return sum - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

static void compile_MbR9(fu::vec_range<char>, fu::view<char>, int&);

                                #ifndef STR_MBMc7M8oSL5
                                #define STR_MBMc7M8oSL5
static const fu::str str_MBMc7M8oSL5 fu_INIT_PRIORITY(1001) { "ab"_fu };
                                #endif

#ifndef fu_NO_fdefs

static int getModule_MbR9(/*1:1*/ fu::view<char> fname)
{
    return fname.size();
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

static void compile_MbR9(/*7:7*/ fu::vec_range<char> fname, /*7:7*/ fu::view<char> via, /*4:4*/ int& sum)
{
    int _0;
    const int module = ((_0 = getModule_MbR9(fname)) ? _0 : fu::fail(((("import circle: '"_view + via) + fname) + "'."_view)));
    if (module & 1)
    {
        fu::vec<fu::str> fuzimports = split_t3LL(fname, "a"_view);
        for (int i = 0; i < fuzimports.size(); i++)
            compile_MbR9(fuzimports[i], ((fname + " <- "_view) + via), sum);

    };
    sum += module;
}

int fu_MAIN()
{
    int sum = 0;
    compile_MbR9(str_MBMc7M8oSL5, fu::view<char>{}, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_COWRestrict

========

        fn A(implicit _A: i32[]) _A;
        fn B(implicit _B:  u8[]) _B;

        fn AB(x: i32) A[x] - B[x].i32;
        fn BA(x: i32) B[x].i32 - A[x];

        fn cycleA_inner(x: i32)
            x & 1   ? either(x + 1) + AB(x)
                    : BA(x);

        fn cycleA_outer(x: i32)
            x & 1   ? cycleA_inner(x + 1) + AB(x)
                    : BA(x);

        fn cycleB_inner(x: i32)
            x & 2   ? either(x + 1) + BA(x)
                    : AB(x);

        fn cycleB_outer(x: i32)
            x & 2   ? cycleB_inner(x + 1) + BA(x)
                    : AB(x);

        fn either(x: i32)
            x & 4   ? cycleA_outer(x)
                    : cycleB_outer(x);

        fn main() {
            let implicit _A = [ 0,    1,    2    ];
            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];

            return either(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>

static int either_MbR9(int, fu::view<int>, fu::view<fu::u8>);

#ifndef fu_NO_fdefs

static fu::view<int> A_kGbb(/*1:1*/ fu::view<int> _A)
{
    return _A;
}

static fu::view<fu::u8> B_kGbb(/*1:1*/ fu::view<fu::u8> _B)
{
    return _B;
}

static int AB_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    return A_kGbb(_A)[x] - int(unsigned(B_kGbb(_B)[x]));
}

static int BA_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    return int(unsigned(B_kGbb(_B)[x])) - A_kGbb(_A)[x];
}

static int cycleA_inner_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    if (x & 1)
        return either_MbR9((x + 1), _A, _B) + AB_MbR9(x, _A, _B);
    else
        return BA_MbR9(x, _A, _B);

}

static int cycleA_outer_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    if (x & 1)
        return cycleA_inner_MbR9((x + 1), _A, _B) + AB_MbR9(x, _A, _B);
    else
        return BA_MbR9(x, _A, _B);

}

static int cycleB_inner_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    if (x & 2)
        return either_MbR9((x + 1), _A, _B) + BA_MbR9(x, _A, _B);
    else
        return AB_MbR9(x, _A, _B);

}

static int cycleB_outer_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    if (x & 2)
        return cycleB_inner_MbR9((x + 1), _A, _B) + BA_MbR9(x, _A, _B);
    else
        return AB_MbR9(x, _A, _B);

}

static int either_MbR9(const int x, /*7:7*/ fu::view<int> _A, /*7:7*/ fu::view<fu::u8> _B)
{
    if (x & 4)
        return cycleA_outer_MbR9(x, _A, _B);
    else
        return cycleB_outer_MbR9(x, _A, _B);

}

int fu_MAIN()
{
    fu::vec<int> _A = fu::vec<int> {{ 0, 1, 2 }};
    fu::vec<fu::u8> _B = fu::vec<fu::u8> {{ fu::u8(unsigned(0)), fu::u8(unsigned(1)), fu::u8(unsigned(2)) }};
    return either_MbR9(0, _A, _B);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_RelaxRespec

========

        fn if0_ret101(x: i32) {
            if      (x > 2) return x * 2;
            else if (x > 1) return x + 1; // <- left branch seeded right with never
            return x + 101;
        }

        fn main() 0.if0_ret101 - 101;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int if0_ret101_MbR9(const int x)
{
    if (x > 2)
        return x * 2;
    else if (x > 1)
        return x + 1;

    return x + 101;
}

int fu_MAIN()
{
    return if0_ret101_MbR9(0) - 101;
}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(x: i32) {
            if (x & 1)
                return x * 2;


            x;            
        }

        fn main() 0.hello;

---- <fail> ----
[2m[0m_0[2m.fu 7:13+1[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            [31;1mx[0m;            
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mhello[0m is missing a final return statement: No common supertype: [35;3mi32[0m | [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mhello[0m([35;3mi32[0m) at [2m2:12+5[0m

========

        fn hello(x: i32) {
            if (x & 1)
                return x * 2;


            return x;     
        }

        fn main() 0.hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int hello_MbR9(const int x)
{
    if (x & 1)
        return x * 2;
    else
        return x;

}

int fu_MAIN()
{
    return hello_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn throws()         { throw("WHAT!");   }
        fn myfn(a = throws) { return a;         } // never in default argument position!
        fn main() {
            try             { return myfn();                }
            catch (e)       { return e == "WHAT!" ? 0 : 1;  }
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throws_MbR9()
{
    fu::fail(fu::str("WHAT!"_fu));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        throws_MbR9();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "WHAT!"_view)
            return 0;
        else
            return 1;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn printus(parts: string[], implicit ref out: i32)
            parts.each(|part| part.each(|c| out += c.i32 ));


        lax     
        fn silent(lax parts) {}

        fn main() {
            implicit mut out: i32;

            printus([ "Hel","lo" ]);
            if (out != 500)
                return 1;

            // Tries to test dead array literals.
            shadow let printus = fn silent;

            printus([ "Hel","lo" ]);
            return out == 500 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___fOiqrSVZz12
                                #define DEF___fOiqrSVZz12
inline static int _fOiq(const char c, /*3:3*/ int& out)
{
    return (out += int(fu::u8(c)));
}
                                #endif

                                #ifndef DEF_each_o3WQnCf5Tn0
                                #define DEF_each_o3WQnCf5Tn0
inline void each_o3WQ(/*7:7*/ fu::view<char> a, /*7:6*/ int& out)
{
    for (int i = 0; i < a.size(); i++)
        _fOiq(a[i], out);

}
                                #endif

                                #ifndef DEF___5pzOgEqPOa2
                                #define DEF___5pzOgEqPOa2
inline static void _5pzO(/*3:3*/ fu::view<char> part, /*2:2*/ int& out)
{
    each_o3WQ(part, out);
}
                                #endif

                                #ifndef DEF_each_xrpzvHYAez1
                                #define DEF_each_xrpzvHYAez1
inline void each_xrpz(/*7:7*/ fu::view<fu::str> a, /*6:6*/ int& out)
{
    for (int i = 0; i < a.size(); i++)
        _5pzO(a[i], out);

}
                                #endif

static void printus_MbR9(/*3:3*/ fu::view<fu::str> parts, /*2:2*/ int& out)
{
    each_xrpz(parts, out);
}

int fu_MAIN()
{
    int out {};
    printus_MbR9(fu::view<fu::str> {{ fu::str("Hel"_fu), fu::str("lo"_fu) }}, out);
    if (out != 500)
        return 1;
    else if (out == 500)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall, N_UnusedArrlit

========

        fn printus(parts: string[], implicit ref out: i32)
            parts.each(|part| part.each(|c| out += c.i32 ));


        inline  
        fn silent(lax parts) {}

        fn main() {
            implicit mut out: i32;

            printus([ "Hel","lo" ]);
            if (out != 500)
                return 1;

            // Tries to test dead array literals.
            shadow let printus = fn silent;

            printus([ "Hel","lo" ]);
            return out == 500 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___fOiqrSVZz12
                                #define DEF___fOiqrSVZz12
inline static int _fOiq(const char c, /*3:3*/ int& out)
{
    return (out += int(fu::u8(c)));
}
                                #endif

                                #ifndef DEF_each_o3WQnCf5Tn0
                                #define DEF_each_o3WQnCf5Tn0
inline void each_o3WQ(/*7:7*/ fu::view<char> a, /*7:6*/ int& out)
{
    for (int i = 0; i < a.size(); i++)
        _fOiq(a[i], out);

}
                                #endif

                                #ifndef DEF___5pzOgEqPOa2
                                #define DEF___5pzOgEqPOa2
inline static void _5pzO(/*3:3*/ fu::view<char> part, /*2:2*/ int& out)
{
    each_o3WQ(part, out);
}
                                #endif

                                #ifndef DEF_each_xrpzvHYAez1
                                #define DEF_each_xrpzvHYAez1
inline void each_xrpz(/*7:7*/ fu::view<fu::str> a, /*6:6*/ int& out)
{
    for (int i = 0; i < a.size(); i++)
        _5pzO(a[i], out);

}
                                #endif

static void printus_MbR9(/*3:3*/ fu::view<fu::str> parts, /*2:2*/ int& out)
{
    each_xrpz(parts, out);
}

int fu_MAIN()
{
    int out {};
    printus_MbR9(fu::view<fu::str> {{ fu::str("Hel"_fu), fu::str("lo"_fu) }}, out);
    if (out != 500)
        return 1;
    else if (out == 500)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedArrlit, N_UnusedLet

========

        fn test() [] => i32;
        fn main() test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {                                             // !DEV_DontFoldLiterals

            if !(false) return 0;   
            DOESNT_EXIST();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn main() {                                             // !DEV_DontFoldLiterals

            if (!false) return 0;   
            DOESNT_EXIST();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn main() {                                             // !DEV_DontFoldLiterals

            if (true) return 0;     
            DOESNT_EXIST();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn test(a) {
            if (typeof(a) -> _[..])
                return a.len;

            return a * 10;
        }

        fn main() {
            let A = [ 0, 1 ].test;
            let B = 4.test;
            return A + B == 42 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_test_33RNnFg24Yc
                                #define DEF_test_33RNnFg24Yc
inline static int test_33RN(/*1:1*/ fu::view<int> a)
{
    return a.size();
}
                                #endif

                                #ifndef DEF_test_yZZbMOXVrQ7
                                #define DEF_test_yZZbMOXVrQ7
inline static int test_yZZb(const int a)
{
    return a * 10;
}
                                #endif

int fu_MAIN()
{
    const int A = test_33RN(fu::view<int> {{ 0, 1 }});
    const int B = test_yZZb(4);
    if ((A + B) == 42)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn staticIfSymmetry(

            ref a: $U[], b)  
        {
            let N = typeof(b) ->  $T   ? 1 : 2;
            let M = typeof(b) -> $T[..] ? 2 : 1;
            a ~= b;
            return N == M ? 0 : 1;
        }

        fn main() {
            mut arr = [ 0 ];
            return staticIfSymmetry(arr, 0)
                 + staticIfSymmetry(arr, [ 0, 0 ])
                 + arr.len * 10 - 40;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:35+1[0m:

[2m      |             ref a: $U[], b)  [0m
[2m      |         {[0m
[2m    6 | [0m            let N = typeof(b) ->  [31;1m$[0mT   ? 1 : 2;
[2m      |             let M = typeof(b) -> $T[..] ? 2 : 1;[0m
[2m      |             a ~= b;[0m

	Bad call to [94;1m$T[0m: [94;1m$T[0m is not defined here.

        Solving [35;3mfn[0m [94;1mstaticIfSymmetry[0m([35;3mi32[0m[35;3m[..][0m, [35;3mi32[0m) at [2m2:12+16[0m
                [35;3mfn[0m [94;1mmain[0m at [2m12:12+4[0m

========

        fn staticIfSymmetry(

            ref a: $T[], b)  
        {
            let N = typeof(b) ->  $T   ? 1 : 2;
            let M = typeof(b) -> $T[..] ? 2 : 1;
            a ~= b;
            return N == M ? 0 : 1;
        }

        fn main() {
            mut arr = [ 0 ];
            return staticIfSymmetry(arr, 0)
                 + staticIfSymmetry(arr, [ 0, 0 ])
                 + arr.len * 10 - 40;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_staticIfSymmetry_qDwCUU80I8k
                                #define DEF_staticIfSymmetry_qDwCUU80I8k
inline static int staticIfSymmetry_qDwC(/*3:3*/ fu::vec_range_mut<int> a, const int b)
{
    const int N = 1;
    const int M = 1;
    a += b;
    if (N == M)
        return 0;
    else
        return 1;

}
                                #endif

                                #ifndef DEF_staticIfSymmetry_514mxAknrX5
                                #define DEF_staticIfSymmetry_514mxAknrX5
inline static int staticIfSymmetry_514m(/*1:1*/ fu::vec_range_mut<int> a, /*3:3*/ fu::view<int> b)
{
    const int N = 2;
    const int M = 2;
    a += b;
    if (N == M)
        return 0;
    else
        return 1;

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 0 }};
    int _0;
    int _1;
    return (_1 = (_0 = staticIfSymmetry_qDwC(arr, 0), (_0 + staticIfSymmetry_514m(arr, fu::view<int> {{ 0, 0 }}))), (_1 + (arr.size() * 10))) - 40;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

========

        fn main() {
            let a: f32 = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+8[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f32 = 1;[0m
[2m    4 | [0m            let b = a.[31;1munsigned[0m;
[2m      |             let c = a.signed;[0m
[2m      |             if (typeof(a) -> u32) return 1;[0m

	Bad call to [94;1munsigned[0m with args ([35;3mf32[0m): 

	[35;3mtemplate[0m [94;1munsigned[0m at [2m../../../../../[0mprelude[2m 96:4+8[0m:
[2m   96 | [0mfn [31;1munsigned[0m(v: <T>)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let a: f32 = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+8[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f32 = 1;[0m
[2m    4 | [0m            let b = a.[31;1munsigned[0m;
[2m      |             let c = a.signed;[0m
[2m      |             if (typeof(a) -> u32) return 1;[0m

	Bad call to [94;1munsigned[0m with args ([35;3malways-true[0m [35;3mf32[0m): 

	[35;3mtemplate[0m [94;1munsigned[0m at [2m../../../../../[0mprelude[2m 96:4+8[0m:
[2m   96 | [0mfn [31;1munsigned[0m(v: <T>)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let a: i32 = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedLet

========

        fn main() {
            let a: f64 = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+6[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f64 = 1;[0m
[2m    4 | [0m            let b = a.[31;1msigned[0m;
[2m      |             let c = a.unsigned;[0m
[2m      |             if (typeof(a) -> i64) return 1;[0m

	Bad call to [94;1msigned[0m with args ([35;3mf64[0m): 

	[35;3mtemplate[0m [94;1msigned[0m at [2m../../../../../[0mprelude[2m 104:4+6[0m:
[2m  104 | [0mfn [31;1msigned[0m(v: <T>)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let a: f64 = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+6[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f64 = 1;[0m
[2m    4 | [0m            let b = a.[31;1msigned[0m;
[2m      |             let c = a.unsigned;[0m
[2m      |             if (typeof(a) -> i64) return 1;[0m

	Bad call to [94;1msigned[0m with args ([35;3malways-true[0m [35;3mf64[0m): 

	[35;3mtemplate[0m [94;1msigned[0m at [2m../../../../../[0mprelude[2m 104:4+6[0m:
[2m  104 | [0mfn [31;1msigned[0m(v: <T>)

	    No body pattern matched.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let a: u64 = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedLet

========

        fn main() {
            mut a = 1;
            mut b = 0;
            {
                defer a++;
                b = a;
            }
            return (b+1) - a;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;

    {
        fu_DEFER(a++);
        b = a;
    };
    return (b + 1) - a;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut a = 1;
            mut b = 0;
            mut c = 0;
            {
                defer a++;
                defer c = a;
                b = a;
            }
            return (b*27) - (a*11 + c*5);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    int c = 0;

    {
        fu_DEFER(a++);
        fu_DEFER(c = a);
        b = a;
    };
    return (b * 27) - ((a * 11) + (c * 5));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test_defer_if_errok(throw_err: bool) {
            mut x      = 1;
            mut if_err = 0;
            mut if_ok  = 0;
            try {
                defer x++;
                defer:err if_err += x;
                defer:ok  if_ok  += x;

                if (throw_err)
                    throw("len=5");

                x += 8; // 9 defer++ = 10
            }
            catch (e) {
                x += e.len; // 6 defer++ = 7
            }

            return x * 3 + if_err * 5 + if_ok * 7;
        }

        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)
            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/defer.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_defer_if_errok_MbR9(const bool throw_err)
{
    int x = 1;
    int if_err = 0;
    int if_ok = 0;

    try
    {
    {
        fu_DEFER(x++);
        fu_DEFER_IF_ERR(if_err += x);
        fu_DEFER_IF_OK(if_ok += x);
        if (throw_err)
            fu::fail(fu::str("len=5"_fu));
        else
            x += 8;

    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        x += e.size();
    }
;
    return ((x * 3) + (if_err * 5)) + (if_ok * 7);
}

int fu_MAIN()
{
    return (((test_defer_if_errok_MbR9(true) - (7 * 3)) - (1 * 5)) - (0 * 7)) + (100 * (((test_defer_if_errok_MbR9(false) - (10 * 3)) - (0 * 5)) - (9 * 7)));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref x: i32) {
            x++;

            defer:ok x++;   
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ int& x)
{
    x++;
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_MbR9(x);
    if (x == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref x: i32) {
            x++;

            defer x++;      
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ int& x)
{
    x++;
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_MbR9(x);
    if (x == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref x: i32) {

            if (x & 1)              // ------ currently highlights the defer
                return x;           //         probably should highlight the semicollon

            x++;
            defer:err x++;
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 1 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:13+5[0m:

[2m      | [0m
[2m      |             x++;[0m
[2m    8 | [0m            [31;1mdefer[0m:err x++;
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mtest[0m is missing a final return statement: No common supertype: [35;3mi32[0m | [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m2:12+4[0m

========

        fn test(ref x: i32) {

            x++;
            defer:err x++;
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void test_MbR9(/*1:1*/ int& x)
{
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_MbR9(x);
    if (x == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            defer incrarr_by1(:a);
            return a[0] - 1;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void sum_amulb_MbR9(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> b, /*4:4*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static void incrarr_by1_MbR9(/*1:1*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

}

static int test_MbR9(/*3:1*/ fu::vec_range_mut<int> a, /*2:2*/ int& sum)
{
    fu::vec<int> b = fu::vec<int>(a);
    fu_DEFER(sum_amulb_MbR9(a, b, sum));
    fu_DEFER(incrarr_by1_MbR9(a));
    return a[0] - 1;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int sum = 0;
    const int ret = (100 * test_MbR9(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            incrarr_by1(:a);
            return a[0] - 2;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void sum_amulb_MbR9(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> b, /*4:4*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static void incrarr_by1_MbR9(/*1:1*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

}

static int test_MbR9(/*3:1*/ fu::vec_range_mut<int> a, /*2:2*/ int& sum)
{
    fu::vec<int> b = fu::vec<int>(a);
    fu_DEFER(sum_amulb_MbR9(a, b, sum));
    incrarr_by1_MbR9(a);
    return a[0] - 2;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int sum = 0;
    const int ret = (100 * test_MbR9(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            defer for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 1;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void sum_amulb_MbR9(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> b, /*4:4*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static int test_MbR9(/*3:1*/ fu::vec_range_mut<int> a, /*2:2*/ int& sum)
{
    fu::vec<int> b = fu::vec<int>(a);
    fu_DEFER(sum_amulb_MbR9(a, b, sum));
    fu_DEFER(for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;);
    return a[0] - 1;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int sum = 0;
    const int ret = (100 * test_MbR9(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 2;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static void sum_amulb_MbR9(/*7:7*/ fu::view<int> a, /*7:7*/ fu::view<int> b, /*4:4*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static int test_MbR9(/*3:1*/ fu::vec_range_mut<int> a, /*2:2*/ int& sum)
{
    fu::vec<int> b = fu::vec<int>(a);
    fu_DEFER(sum_amulb_MbR9(a, b, sum));
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

    return a[0] - 2;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1 }};
    int sum = 0;
    const int ret = (100 * test_MbR9(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut res = 1;            // single statement blocks unwrap
            { defer res--; }        //  fix by unwraping tailing defers
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int res = 1;
    res--;
    return res;
}

#endif

int main() { return fu_MAIN(); }

========

        fn unwraps_defer(ref x: i32) unwrap {
            defer x++;
        }

        fn main() {
            mut y = 0;
            { unwraps_defer(y); }
            mut x = 0;
            unwraps_defer(x);
            return y == 1 && x == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int y = 0;
    y++;
    int x = 0;
    fu_DEFER(x++);
    if ((y == 1) && (x == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        type Test = i8;
        fn main() 256.Test.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::i8(256));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a: $A, b: $B) b +   
            a;                      

        fn main() i8(-1).test(+1);

---- <fail> ----
[2m[0m_0[2m.fu 2:33+1[0m:

[2m      | [0m
[2m    2 | [0m        fn test(a: $A, b: $B) b [31;1m+[0m   
[2m      |             a;                      [0m
[2m      | [0m

	Bad call to [94;1m+[0m with args ([35;3mi32[0m, [35;3mi8[0m): 

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m+[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi32[0m <-> [35;3mi8[0m

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi8[0m, [35;3mi32[0m) at [2m2:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn test(a: $A, b: $B) b +   
            $B(a);                  

        fn main() i8(-1).test(+1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_test_KICR9XfKL3f
                                #define DEF_test_KICR9XfKL3f
inline static int test_KICR(const fu::i8 a, const int b)
{
    return b + int(a);
}
                                #endif

int fu_MAIN()
{
    return test_KICR(fu::i8(-1), +1);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Test { v: u32 };
        fn test(v   

            ): Test = [ v ];

        fn main() test(2).v == 2 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 5:23+1[0m:

[2m      |         fn test(v   [0m
[2m      | [0m
[2m    5 | [0m            ): Test = [31;1m[[0m v ];
[2m      | [0m
[2m      |         fn main() test(2).v == 2 ? 0 : 1;[0m

	Bad call to [35;3mtype[0m [94;1mTest[0m with args ([35;3mi32[0m): 

	[35;3mtype[0m [94;1mTest[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Test { v: u32 };

	    [35;3marg[0m [94;1mv[0m expects [35;3mu32[0m, got [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mtest[0m([35;3mi32[0m) at [2m3:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========

        struct Test { v: u32 };
        fn test(v   
                 : u32  
            ): Test = [ v ];

        fn main() test(2).v == 2 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Test_X6Na;

                                #ifndef DEF_Test_X6NaS9iVI5f
                                #define DEF_Test_X6NaS9iVI5f
struct Test_X6Na
{
                                // shape_hash:    36b5814fc6b2acfa
                                // non_triv_mask: 0000000000000000
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static Test_X6Na test_MbR9(const unsigned v)
{
    return Test_X6Na { v };
}

int fu_MAIN()
{
    if (test_MbR9(2u).v == 2u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        let x = { mut z = 0; z++; z };
        return x - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int z;
    const int /*z*/ x = (z = 0, z++, z);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn mul2(a) a*2;
        fn test(b, fn) fn(1 + fn(b));
        fn main() 14 - test(3, fn mul2);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_mul2_KMxtzIRZeA4
                                #define DEF_mul2_KMxtzIRZeA4
inline static int mul2_KMxt(const int a)
{
    return a * 2;
}
                                #endif

                                #ifndef DEF_test_uqTIhNKxMcg
                                #define DEF_test_uqTIhNKxMcg
inline static int test_uqTI(const int b)
{
    return mul2_KMxt((1 + mul2_KMxt(b)));
}
                                #endif

int fu_MAIN()
{
    return 14 - test_uqTI(3);
}

#endif

int main() { return fu_MAIN(); }

========

        let overloaded = 1;
        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() 14 - test(3, fn overloaded);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

                                #ifndef DEF_overloaded
                                #define DEF_overloaded
inline constexpr int overloaded = 1;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_overloaded_KMxtzIRZeA4
                                #define DEF_overloaded_KMxtzIRZeA4
inline static int overloaded_KMxt(const int a)
{
    return a * 2;
}
                                #endif

                                #ifndef DEF_test_h2jR55cOrm6
                                #define DEF_test_h2jR55cOrm6
inline static int test_h2jR(const int b)
{
    return overloaded_KMxt((overloaded + overloaded_KMxt(b)));
}
                                #endif

int fu_MAIN()
{
    return 14 - test_h2jR(3);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() {
            let overloaded = 1;
            return 14 - test(3, fn overloaded);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_overloaded_KMxtzIRZeA4
                                #define DEF_overloaded_KMxtzIRZeA4
inline static int overloaded_KMxt(const int a)
{
    return a * 2;
}
                                #endif

                                #ifndef DEF_test_SHseEecTm43
                                #define DEF_test_SHseEecTm43
inline static int test_SHse(const int b, /*7:7*/ const int overloaded)
{
    return overloaded_KMxt((overloaded + overloaded_KMxt(b)));
}
                                #endif

int fu_MAIN()
{
    const int overloaded = 1;
    return 14 - test_SHse(3, overloaded);
}

#endif

int main() { return fu_MAIN(); }

========

        fn MAP(items: $T[], fn) {
            mut result: typeof( fn(items[0]) )[];
            for (mut i = 0; i < items.len; i++)
                result.push(fn(items[i]));

            return result;
        }

        fn sqr(x) x*x;

        fn main() [2].MAP(fn sqr)[0] - 4;

        // EXPECT fu::view<int> {{ 2 }}
        //  During the propagateType rework
        //   the 'mut result: fn(items[0])[]' type annot
        //    was found listed as a callsite for items,
        //     but wasn't reachable for relax.

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sqr_87TBE9BWG51
                                #define DEF_sqr_87TBE9BWG51
inline static int sqr_87TB(const int x)
{
    return x * x;
}
                                #endif

                                #ifndef DEF_MAP_J5tD0AjMZTg
                                #define DEF_MAP_J5tD0AjMZTg
inline static fu::vec<int> MAP_J5tD(/*3:3*/ fu::view<int> items)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < items.size(); i++)
        result.push(sqr_87TB(items[i]));

    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    return MAP_J5tD(fu::view<int> {{ 2 }})[0] - 4;
}

#endif

int main() { return fu_MAIN(); }

========

        fn reduce(items: $T[], fn, init?: $T) {
            mut result = init;
            for (mut i = 0; i < items.len; i++)
                result = fn(result, items[i]);

            return result;
        }

        fn main() [1, 2].reduce(|a, b| a + b) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___NN4PnOIxMqb
                                #define DEF___NN4PnOIxMqb
inline static int _NN4P(const int a, const int b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_reduce_UNXCJx4l47l
                                #define DEF_reduce_UNXCJx4l47l
inline static int reduce_UNXC(/*7:7*/ fu::view<int> items, const int init)
{
    int result = init;
    for (int i = 0; i < items.size(); i++)
        result = _NN4P(result, items[i]);

    return result;
}
                                #endif

int fu_MAIN()
{
    return reduce_UNXC(fu::view<int> {{ 1, 2 }}, 0) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Each(items: $T[], fn) {
            for (mut i = 0; i < items.len; i++) // <- one i
                fn(items[i]);
        }

        fn main() {
            mut i = 0;                  // <- another i, i got them to shadow each other
            [1, 2].Each: |x| i += x;    //      in the everything-a-free-function
            return i - 3;               //      impl of closures
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& i)
{
    return (i += x);
}
                                #endif

                                #ifndef DEF_Each_LBIs4YRlOS5
                                #define DEF_Each_LBIs4YRlOS5
inline static void Each_LBIs(/*7:7*/ fu::view<int> items, /*6:6*/ int& i)
{
    for (int i_1 = 0; i_1 < items.size(); i_1++)
        _5aAg(items[i_1], i);

}
                                #endif

int fu_MAIN()
{
    int i = 0;
    Each_LBIs(fu::view<int> {{ 1, 2 }}, i);
    return i - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        mut sum = 2;

        fn FnDecl_update(parent_idx: i32) {
            fn Each(fn) fn();
            Each(|| makeDirty(:parent_idx));
        }

        fn makeDirty(parent_idx: i32): void {
            sum += parent_idx;
        }

        FnDecl_update(1);

        return sum - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static void makeDirty_MbR9(const int parent_idx, /*3:3*/ int& sum)
{
    sum += parent_idx;
}

                                #ifndef DEF___4twmTtNKbK8
                                #define DEF___4twmTtNKbK8
inline static void _4twm(/*3:3*/ const int parent_idx, /*3:3*/ int& sum)
{
    makeDirty_MbR9(parent_idx, sum);
}
                                #endif

                                #ifndef DEF_Each_DajvNFKxOP8
                                #define DEF_Each_DajvNFKxOP8
inline static void Each_Dajv(/*7:7*/ const int parent_idx, /*7:7*/ int& sum)
{
    _4twm(parent_idx, sum);
}
                                #endif

static void FnDecl_update_MbR9(const int parent_idx, /*3:3*/ int& sum)
{
    Each_Dajv(parent_idx, sum);
}

int fu_MAIN()
{
    int sum = 2;
    FnDecl_update_MbR9(1, sum);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                "".len.addret(x)

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    if (!(x & 1))
        return x;
    else
    {
        const int a = ""_view.size();
        return a + x;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                "".len.addret(x)

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    if (!(x & 1))
        return x;
    else
    {
        const int a = fu::view<char>{}.size();
        return a + x;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                "".len                                          // GNUStmtExpr

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 0;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : ""_view.size()));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 1;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : ""_view.size()));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                "".len                                          // GNUStmtExpr

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 0;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : fu::view<char>{}.size()));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 1;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : fu::view<char>{}.size()));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                continue "".len                                 // GNUStmtExpr

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 0;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : ""_view.size()));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 1;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : ""_view.size()));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation

                continue "".len                                 // GNUStmtExpr

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 0;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : fu::view<char>{}.size()));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 1;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : fu::view<char>{}.size()));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let hey = |x: i32| {
                if !(x & 1)
                    return x;                                   // GNUStmtExpr

                "".len + x
            };

            // and this complains about no match for *(void, void)
            return hey(1) * hey(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 1;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : (""_view.size() + x)));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 0;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : (""_view.size() + x)));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        // something complains about no final return
        fn main() {
            let hey = |x: i32| {
                if !(x & 1)
                    return x;                                   // GNUStmtExpr

                "".len + x
            };

            // and this complains about no match for *(void, void)
            return hey(1) * hey(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    int BL_3_v;
    return (__extension__ (
    {
        const int x = 1;
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : (fu::view<char>{}.size() + x)));
        (void)0;
    }), BL_1_v) * (__extension__ (
    {
        const int x = 0;
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
            (void)0;
        }), fu::unreachable) : (fu::view<char>{}.size() + x)));
        (void)0;
    }), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

========

        fn check(a, b, compare! = infix fn <>)
            compare(a, b);

        fn main() check(0, 0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_check_myQR4bS8Iw8
                                #define DEF_check_myQR4bS8Iw8
inline static int check_myQR(const int a, const int b)
{
    return x3Cx3E_odNT(a, b);
}
                                #endif

int fu_MAIN()
{
    return check_myQR(0, 0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn check(a, b, compare! = |aa, bb| aa <> bb)
            compare(a, b);

        fn main() check(0, 0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___G9C3bt6y7Ze
                                #define DEF___G9C3bt6y7Ze
inline static int _G9C3(const int aa, const int bb)
{
    return x3Cx3E_odNT(aa, bb);
}
                                #endif

                                #ifndef DEF_check_RPfd93T2hwl
                                #define DEF_check_RPfd93T2hwl
inline static int check_RPfd(const int a, const int b)
{
    return _G9C3(a, b);
}
                                #endif

int fu_MAIN()
{
    return check_RPfd(0, 0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn Find !<T>(ref arr: T[], needle: T, visit) {
            for (mut i = 0; i < arr.len; i++) {
                ref item = arr[i];
                if (item == needle) {
                    visit(i?: i, remove?: |ret = true| {
                        arr.splice(i, 1);
                        return ret;
                    });
                    return true;
                }
            }
            return [];
        }

        fn main() {
            mut arr = [1, 2, 3, 4];
            let x = arr.Find(2, |i, remove!| remove(i));
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Find_qmcCLBuviV8
                                #define DEF_Find_qmcCLBuviV8
inline static int Find_qmcC(/*7:7*/ fu::vec_range_mut<int> arr, const int needle)
{
    for (int i = 0; i < arr.size(); i++)
    {
        const int /*arr|static*/ item = arr[i];
        if (item == needle)
        {
            const int /*i*/ i_1 = i;
            arr.splice(i, 1);
            return i_1;
        };
    };
    return 0;
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3, 4 }};
    const int x = Find_qmcC(arr, 2);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        fn Hello(ref str) str ~= "Hello, ";
        fn World(ref str) str ~= "World!";

        struct addrofns {
            hello: typeof(fn Hello);
            world: typeof(fn World);
        };

        fn main() {
            mut str = "";
            mut fns = addrofns();
            for (fieldname i: addrofns) (fns.i)(str);
            return str == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Hello_DTMbQ0lhHc5
                                #define DEF_Hello_DTMbQ0lhHc5
inline static fu::view<char> Hello_DTMb(/*1:1*/ fu::vec_range_mut<char> str)
{
    return (str += "Hello, "_view);
}
                                #endif

                                #ifndef DEF_World_x5bX6a2wCY6
                                #define DEF_World_x5bX6a2wCY6
inline static fu::view<char> World_x5bX(/*1:1*/ fu::vec_range_mut<char> str)
{
    return (str += "World!"_view);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str = fu::str(""_fu);

    {
        Hello_DTMb(str);
        World_x5bX(str);
    };
    if (str == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedLet

========

        fn Hello(ref str) str ~= "Hello, ";
        fn World(ref str) str ~= "World!";

        struct addrofns {
            hello: typeof(fn Hello);
            world: typeof(fn World);
        };

        fn main() {
            mut str = "";
            mut fns = addrofns();
            for (fieldname i: addrofns) (fns.i)(str);
            return str == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_Hello_DTMbQ0lhHc5
                                #define DEF_Hello_DTMbQ0lhHc5
inline static fu::view<char> Hello_DTMb(/*1:1*/ fu::vec_range_mut<char> str)
{
    return (str += "Hello, "_view);
}
                                #endif

                                #ifndef DEF_World_x5bX6a2wCY6
                                #define DEF_World_x5bX6a2wCY6
inline static fu::view<char> World_x5bX(/*1:1*/ fu::vec_range_mut<char> str)
{
    return (str += "World!"_view);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str {};

    {
        Hello_DTMb(str);
        World_x5bX(str);
    };
    if (str == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedLet

========

        fn non_void_ret(fn) {
            return fn();
        }

        fn void_ret(fn): void {
            non_void_ret: || fn();  // statement-mode semi should discard retval
        }

        fn main() {
            mut v = 3;
            void_ret(|| v -= 3);
            return v;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___xJ4o6qEfntc
                                #define DEF___xJ4o6qEfntc
inline static int _xJ4o(/*1:1*/ int& v)
{
    return (v -= 3);
}
                                #endif

                                #ifndef DEF___qJlw8lWI3Sa
                                #define DEF___qJlw8lWI3Sa
inline static int _qJlw(/*1:1*/ int& v)
{
    return _xJ4o(v);
}
                                #endif

                                #ifndef DEF_non_void_ret_R8iDPHy5p1f
                                #define DEF_non_void_ret_R8iDPHy5p1f
inline static int non_void_ret_R8iD(/*3:3*/ int& v)
{
    return _qJlw(v);
}
                                #endif

                                #ifndef DEF_void_ret_vpE4kdglDV0
                                #define DEF_void_ret_vpE4kdglDV0
inline static void void_ret_vpE4(/*3:3*/ int& v)
{
    non_void_ret_R8iD(v);
}
                                #endif

int fu_MAIN()
{
    int v = 3;
    void_ret_vpE4(v);
    return v;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {

            // Previously we considered making the : shorthand available in expression position -
            //  now we're backing off and making it solely available for void-returning lambdas in stmt position,
            //   and making the continue/break rewrites more cautious for regular lambdas.
            //
            // Brief - we're equating the : shorthand with custom control flow.
            //
            mut sum = 0;
            each([ 1, 2, 3 ]        
                .map: |x| x * x     
                    ): |x| sum += x;

            return sum - 14;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:21+1[0m:

[2m      |             mut sum = 0;[0m
[2m      |             each([ 1, 2, 3 ]        [0m
[2m   12 | [0m                .map[31;1m:[0m |x| x * x     
[2m      |                     ): |x| sum += x;[0m
[2m      | [0m

	Missing comma before [31;1m:[0m.

========

        fn main() {

            // Previously we considered making the : shorthand available in expression position -
            //  now we're backing off and making it solely available for void-returning lambdas in stmt position,
            //   and making the continue/break rewrites more cautious for regular lambdas.
            //
            // Brief - we're equating the : shorthand with custom control flow.
            //
            mut sum = 0;
            each([ 1, 2, 3 ]        
                .map(|x| x * x)     
                    ): |x| sum += x;

            return sum - 14;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___87TBE9BWG51
                                #define DEF___87TBE9BWG51
inline static int _87TB(const int x)
{
    return x * x;
}
                                #endif

                                #ifndef DEF_map_VtdDarx5Yl5
                                #define DEF_map_VtdDarx5Yl5
inline fu::vec<int> map_VtdD(/*3:3*/ fu::view<int> a)
{
    /*MOV*/ fu::vec<int> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _87TB(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int x, /*3:3*/ int& sum)
{
    return (sum += x);
}
                                #endif

                                #ifndef DEF_each_LBIs4YRlOS5
                                #define DEF_each_LBIs4YRlOS5
inline void each_LBIs(/*7:7*/ fu::view<int> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _5aAg(a[i], sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    each_LBIs(map_VtdD(fu::view<int> {{ 1, 2, 3 }}), sum);
    return sum - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas( .a)   B(  a * 2); 


        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_7qsLz2jR0Fb
                                #define DEF_bananas_7qsLz2jR0Fb
inline static B_UWB4 bananas_7qsL(const int a)
{
    return B_UWB4 { (a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_7qsL(A_EqO7 { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas( .a)   B(  a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_7qsLz2jR0Fb
                                #define DEF_bananas_7qsLz2jR0Fb
inline B_UWB4 bananas_7qsL(const int a)
{
    return B_UWB4 { (a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_7qsL(A_EqO7 { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a.a)   B(  a * 2); 


        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_7qsLz2jR0Fb
                                #define DEF_bananas_7qsLz2jR0Fb
inline static B_UWB4 bananas_7qsL(const int a)
{
    return B_UWB4 { (a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_7qsL(A_EqO7 { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a.a)   B(  a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_7qsLz2jR0Fb
                                #define DEF_bananas_7qsLz2jR0Fb
inline B_UWB4 bananas_7qsL(const int a)
{
    return B_UWB4 { (a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_7qsL(A_EqO7 { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: _)  // conv-cache: adding the case to salvage this alt
        case(typeof(a) -> A)    B(a.a * 2); 


        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_JG4YRrw0OHj
                                #define DEF_bananas_JG4YRrw0OHj
inline static B_UWB4 bananas_JG4Y(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_JG4Y(A_EqO7 { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: _)  // conv-cache: adding the case to salvage this alt
        case(typeof(a) -> A)    B(a.a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_JG4YRrw0OHj
                                #define DEF_bananas_JG4YRrw0OHj
inline B_UWB4 bananas_JG4Y(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_JG4Y(A_EqO7 { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: A)  B(a.a * 2); 


        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_UWB4 bananas_MbR9(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a * 2) };
}

int fu_MAIN()
{
    return bananas_MbR9(A_EqO7 { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: A)  B(a.a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;
B_UWB4 bananas_MbR9(const A_EqO7&);

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return bananas_MbR9(A_EqO7 { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }
struct B_UWB4;
struct A_EqO7;

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

B_UWB4 bananas_MbR9(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a * 2) };
}

#endif

========

        fn sqr(a: i32) a * a;
        fn woot(a.sqr) a + 1;
        fn main() 2.woot - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int sqr_MbR9(const int a)
{
    return a * a;
}

                                #ifndef DEF_woot_IQ7pCaWlLNe
                                #define DEF_woot_IQ7pCaWlLNe
inline static int woot_IQ7p(const int a)
{
    return a + 1;
}
                                #endif

int fu_MAIN()
{
    return woot_IQ7p(sqr_MbR9(2)) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B  { b:  i32; };

        fn a0(a1: A1) a1.a1 * 100;
        fn bananas(a) B(a.a0 * 2); // <- template
        fn woot(a.bananas: B) a.b; // <- check

        fn main() 1.A0.woot + 1.A1.woot - 202;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A0_niBg;
struct B_UWB4;
struct A1_ydnI;

                                #ifndef DEF_A0_niBgoEUhSM3
                                #define DEF_A0_niBgoEUhSM3
struct A0_niBg
{
                                // shape_hash:    7839c01ec37ff1c2
                                // non_triv_mask: 0000000000000000
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_A1_ydnIwwE5FD5
                                #define DEF_A1_ydnIwwE5FD5
struct A1_ydnI
{
                                // shape_hash:    4c349a5dae770b14
                                // non_triv_mask: 0000000000000000
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_J4jLHAHs6G8
                                #define DEF_bananas_J4jLHAHs6G8
inline static B_UWB4 bananas_J4jL(/*1:1*/ const A0_niBg& a)
{
    return B_UWB4 { (a.a0 * 2) };
}
                                #endif

static int woot_MbR9(/*1:1*/ const B_UWB4& a)
{
    return a.b;
}

static int a0_MbR9(/*1:1*/ const A1_ydnI& a1)
{
    return a1.a1 * 100;
}

                                #ifndef DEF_bananas_0X08H90QBT7
                                #define DEF_bananas_0X08H90QBT7
inline static B_UWB4 bananas_0X08(/*1:1*/ const A1_ydnI& a)
{
    return B_UWB4 { (a0_MbR9(a) * 2) };
}
                                #endif

int fu_MAIN()
{
    return (woot_MbR9(bananas_J4jL(A0_niBg { 1 })) + woot_MbR9(bananas_0X08(A1_ydnI { 1 }))) - 202;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b0: i32; };
        struct B1 { b1: i32; };
        struct C  { c:  i32; };

        fn bananas(using _: A0) B0(a0 * 2);
        fn bananas(using _: A1) B1(a1 * 3);
        using fn c0(using _: B0) C(c: b0 * 5);
        using fn c1(using _: B1) C(c: b1 * 7);
        fn woot(using a.bananas: C) c; // extra conversion

        fn main() 1.A0.woot + 1.A1.woot - 31;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A0_niBg;
struct B0_dQ6B;
struct C_NvDA;
struct A1_ydnI;
struct B1_RIoj;

                                #ifndef DEF_A0_niBgoEUhSM3
                                #define DEF_A0_niBgoEUhSM3
struct A0_niBg
{
                                // shape_hash:    7839c01ec37ff1c2
                                // non_triv_mask: 0000000000000000
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_B0_dQ6BIuGkTUk
                                #define DEF_B0_dQ6BIuGkTUk
struct B0_dQ6B
{
                                // shape_hash:    513e5d71385f3a3f
                                // non_triv_mask: 0000000000000000
    int b0;
    explicit operator bool() const noexcept
    {
        return false
            || b0
        ;
    }
};
                                #endif

                                #ifndef DEF_C_NvDAsnv8cSg
                                #define DEF_C_NvDAsnv8cSg
struct C_NvDA
{
                                // shape_hash:    fca39bbd97a1b84c
                                // non_triv_mask: 0000000000000000
    int c;
    explicit operator bool() const noexcept
    {
        return false
            || c
        ;
    }
};
                                #endif

                                #ifndef DEF_A1_ydnIwwE5FD5
                                #define DEF_A1_ydnIwwE5FD5
struct A1_ydnI
{
                                // shape_hash:    4c349a5dae770b14
                                // non_triv_mask: 0000000000000000
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

                                #ifndef DEF_B1_RIoj47Nn1e9
                                #define DEF_B1_RIoj47Nn1e9
struct B1_RIoj
{
                                // shape_hash:    5c065d9907e767b6
                                // non_triv_mask: 0000000000000000
    int b1;
    explicit operator bool() const noexcept
    {
        return false
            || b1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B0_dQ6B bananas_MbR9(/*1:1*/ const A0_niBg& _)
{
    return B0_dQ6B { (_.a0 * 2) };
}

static C_NvDA c0_MbR9(/*1:1*/ const B0_dQ6B& _)
{
    return C_NvDA { (_.b0 * 5) };
}

static int woot_MbR9(/*1:1*/ const C_NvDA& a)
{
    return a.c;
}

static B1_RIoj bananas_kGbb(/*1:1*/ const A1_ydnI& _)
{
    return B1_RIoj { (_.a1 * 3) };
}

static C_NvDA c1_MbR9(/*1:1*/ const B1_RIoj& _)
{
    return C_NvDA { (_.b1 * 7) };
}

int fu_MAIN()
{
    return (woot_MbR9(c0_MbR9(bananas_MbR9(A0_niBg { 1 }))) + woot_MbR9(c1_MbR9(bananas_kGbb(A1_ydnI { 1 })))) - 31;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b:  i32; };
        struct B1 { b:  i32; };

        fn bananas(a0: A0) B0(a0.a0 * 2);
        fn bananas(a1: A1) B1(a1.a1 * 3);
        fn woot(a.bananas) a.b; // <- template

        fn main() 1.A0.woot + 1.A1.woot - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A0_niBg;
struct B0_UkUN;
struct A1_ydnI;
struct B1_MBhp;

                                #ifndef DEF_A0_niBgoEUhSM3
                                #define DEF_A0_niBgoEUhSM3
struct A0_niBg
{
                                // shape_hash:    7839c01ec37ff1c2
                                // non_triv_mask: 0000000000000000
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_B0_UkUNTM8RBV9
                                #define DEF_B0_UkUNTM8RBV9
struct B0_UkUN
{
                                // shape_hash:    853b36bcb5dc6a37
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_A1_ydnIwwE5FD5
                                #define DEF_A1_ydnIwwE5FD5
struct A1_ydnI
{
                                // shape_hash:    4c349a5dae770b14
                                // non_triv_mask: 0000000000000000
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

                                #ifndef DEF_B1_MBhpyeqJ2jk
                                #define DEF_B1_MBhpyeqJ2jk
struct B1_MBhp
{
                                // shape_hash:    207a0452f63b78ce
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B0_UkUN bananas_MbR9(/*1:1*/ const A0_niBg& a0)
{
    return B0_UkUN { (a0.a0 * 2) };
}

                                #ifndef DEF_woot_ce580jQ4xgh
                                #define DEF_woot_ce580jQ4xgh
inline static int woot_ce58(/*1:1*/ const B0_UkUN& a)
{
    return a.b;
}
                                #endif

static B1_MBhp bananas_kGbb(/*1:1*/ const A1_ydnI& a1)
{
    return B1_MBhp { (a1.a1 * 3) };
}

                                #ifndef DEF_woot_oz1pT2Cu780
                                #define DEF_woot_oz1pT2Cu780
inline static int woot_oz1p(/*1:1*/ const B1_MBhp& a)
{
    return a.b;
}
                                #endif

int fu_MAIN()
{
    return (woot_ce58(bananas_MbR9(A0_niBg { 1 })) + woot_oz1p(bananas_kGbb(A1_ydnI { 1 }))) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn times_implicit(x: i32, implicit y: i32) x * y;
        fn times7(x: i32) x * 7;

        fn woot(a.times_implicit, b: u32) a * b.i32;
        fn woot(a: i32, b.times7: i32) a * b;

        fn test0() 3.woot(2.i32);

        fn test1() {
            let implicit y = 7;
            return 3.woot(2.u32);
        }

        fn main() test0 + test1 * 1000 - 42042;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int times7_MbR9(const int x)
{
    return x * 7;
}

static int woot_MbR9(const int a, const int b)
{
    return a * b;
}

static int test0_MbR9()
{
    return woot_MbR9(3, times7_MbR9(int(2)));
}

static int times_implicit_MbR9(const int x, /*3:3*/ const int y)
{
    return x * y;
}

                                #ifndef DEF_woot_d0FWSge6qac
                                #define DEF_woot_d0FWSge6qac
inline static int woot_d0FW(const int a, const unsigned b)
{
    return a * int(b);
}
                                #endif

static int test1_MbR9()
{
    const int y = 7;
    return woot_d0FW(times_implicit_MbR9(3, y), unsigned(2));
}

int fu_MAIN()
{
    return (test0_MbR9() + (test1_MbR9() * 1000)) - 42042;
}

#endif

int main() { return fu_MAIN(); }

========

        struct X { str: string; };
        fn ~(a: X, b: X) X(a.str ~ b.str);          // currently: invalid operator~ cg
        inline fn ~(a: X, b.to_debug_str) a ~ b;    // currently: pointless blocks

        fn to_debug_str(a: i32) X("i" ~ a);

        fn main() {
            let hey = X("Hey! ") ~ 5;
            return hey.str == "Hey! i5" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct X_wSdR;

                                #ifndef DEF_X_wSdRTm7BT17
                                #define DEF_X_wSdRTm7BT17
struct X_wSdR
{
                                // shape_hash:    0be64758fe0c3e15
                                // non_triv_mask: 0000800000001000
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static X_wSdR to_debug_str_MbR9(const int a)
{
    return X_wSdR { x7E_rA00("i"_view, fu::i64dec(a)) };
}

static X_wSdR x7E_MbR9(/*3:3*/ const X_wSdR& a, /*3:3*/ const X_wSdR& b)
{
    return X_wSdR { (a.str + b.str) };
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    X_wSdR a {};
    X_wSdR b {};
    X_wSdR hey = (a = X_wSdR { fu::str("Hey! "_fu) }, b = to_debug_str_MbR9(5), x7E_MbR9(a, b));
    if (hey.str == "Hey! i5"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        pub struct Module       { modid: i32; };
        pub struct Target       { modid: i32; index: i32; };
        pub struct Type         { using vtype: ValueType; };
        pub struct ValueType    { modid: i32; canon: string; };
        pub struct Overload     { kind: string; locals?: Overload[]; };

        fn main() {
            using fn GET(target: Target, implicit overloads: Overload[]) {
                target.index > 0 || throw("Assertion failed.");
                if (target.modid < 0)
                    return overloads[-target.modid - 1].locals[target.index - 1];
                else
                    return overloads[target.index - 1];
            }

            fn try_GET(target: Target)
                target && GET(target);

            implicit mut overloads: Overload[];
            overloads ~= Overload("What");
            return try_GET(Target(0, 1)).kind.len - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Overload_iivD;
struct Target_84mq;

                                #ifndef DEF_Overload_iivD7YpqnI6
                                #define DEF_Overload_iivD7YpqnI6
struct Overload_iivD
{
                                // shape_hash:    2ea1ae6bed5093e4
                                // non_triv_mask: 0000880040000000
    fu::str kind;
    fu::vec<Overload_iivD> locals;
    Overload_iivD(const Overload_iivD&) = default;
    Overload_iivD(Overload_iivD&&) = default;
    Overload_iivD& operator=(Overload_iivD&&) = default;
    Overload_iivD& operator=(const Overload_iivD& selfrec) { return *this = Overload_iivD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_84mqmNanZdi
                                #define DEF_Target_84mqmNanZdi
struct Target_84mq
{
                                // shape_hash:    8c9cdba7d3c0944d
                                // non_triv_mask: 0000000000000000
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

                                #ifndef STR_G139tn59Hxj
                                #define STR_G139tn59Hxj
static const fu::str str_G139tn59Hxj fu_INIT_PRIORITY(1001) { "Assertion failed."_fu };
                                #endif

#ifndef fu_NO_fdefs

static const Overload_iivD& GET_MbR9(/*3:3*/ const Target_84mq& target, /*3:3*/ fu::view<Overload_iivD> overloads)
{
    if (target.index > 0)
    {
        if (target.modid < 0)
            return overloads[(-target.modid - 1)].locals[(target.index - 1)];
        else
            return overloads[(target.index - 1)];

    }
    else
        fu::fail(fu::str(str_G139tn59Hxj));

}

static const Overload_iivD& try_GET_MbR9(/*3:3*/ const Target_84mq& target, /*3:3*/ fu::view<Overload_iivD> overloads)
{
    if (target)
        return GET_MbR9(target, overloads);
    else
        return (*(Overload_iivD*)fu::NIL);

}

int fu_MAIN()
{
    fu::vec<Overload_iivD> overloads {};
    overloads += Overload_iivD { fu::str("What"_fu), fu::vec<Overload_iivD>{} };
    return try_GET_MbR9(Target_84mq { 0, 1 }, overloads).kind.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode

========

        struct RWEvent { rw_target!: i32 };
        struct ReadID  { id: i32 };

        fn main()
        {

            using   
            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);

            fn rw_target(read: ReadID)  read.id;

            return ReadID(0).rw_target;
        }

---- <fail> ----
[2m[0m_0[2m.fu 13:30+9[0m:

[2m      |             fn rw_target(read: ReadID)  read.id;[0m
[2m      | [0m
[2m   13 | [0m            return ReadID(0).[31;1mrw_target[0m;
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [94;1mrw_target[0m with args ([35;3mstruct[0m [94;1mReadID[0m), matches multiple items in scope:

	[35;3mfn[0m [94;1mrw_target[0m at [2m11:16+9[0m:
[2m   11 | [0m            fn [31;1mrw_target[0m(read: ReadID)  read.id;

	[35;3mfield[0m [94;1mRWEvent[0m:[94;1mrw_target[0m at [2m2:26+9[0m:
[2m    2 | [0m        struct RWEvent { [31;1mrw_target[0m!: i32 };

	    [35;3musing[0m [35;3mfn[0m [94;1mRWEvent[0m at [2m8:13+5[0m [2m9:16+7[0m:
[2m    8 | [0m            [31;1musing[0m   
[2m    9 | [0m            fn [31;1mRWEvent[0m(read: ReadID)    RWEvent(rw_target: read.id);


        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        struct RWEvent { rw_target!: i32 };
        struct ReadID  { id: i32 };

        fn main()
        {

            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);

            fn rw_target(read: ReadID)  read.id;

            return ReadID(0).rw_target;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct ReadID_r2IW;

                                #ifndef DEF_ReadID_r2IWPHLagb1
                                #define DEF_ReadID_r2IWPHLagb1
struct ReadID_r2IW
{
                                // shape_hash:    708195a741d53cd0
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rw_target_MbR9(/*1:1*/ const ReadID_r2IW& read)
{
    return read.id;
}

int fu_MAIN()
{
    return rw_target_MbR9(ReadID_r2IW { 0 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn a_len(a: $T[..]) a.len; // a conversion could navigate this here
        struct Test { using a: i32[]; };
        fn main() Test.a_len;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Test_c6ue;

                                #ifndef DEF_Test_c6ueuKKn0tg
                                #define DEF_Test_c6ueuKKn0tg
struct Test_c6ue
{
                                // shape_hash:    8a70dffa6a6afcfb
                                // non_triv_mask: 0008000000100000
    fu::vec<int> a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_a_len_33RNnFg24Yc
                                #define DEF_a_len_33RNnFg24Yc
inline static int a_len_33RN(/*1:1*/ fu::view<int> a)
{
    return a.size();
}
                                #endif

int fu_MAIN()
{
    return a_len_33RN(Test_c6ue{}.a);
}

#endif

int main() { return fu_MAIN(); }

========

        struct CodegenOutput { using src: string; };

        fn test(ref str: string, out: CodegenOutput) {
            str ~= out && "b";
            return str ~ out;
        }

        fn main() {
            mut str = "a";
            return str.test(CodegenOutput("what")).len - 6; // "abwhat".len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct CodegenOutput_cqTq;

                                #ifndef DEF_CodegenOutput_cqTq1s90Ux8
                                #define DEF_CodegenOutput_cqTq1s90Ux8
struct CodegenOutput_cqTq
{
                                // shape_hash:    43a190e7388dc836
                                // non_triv_mask: 0000800000000100
    fu::str src;
    explicit operator bool() const noexcept
    {
        return false
            || src
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str test_MbR9(/*1:1*/ fu::vec_range_mut<char> str, /*3:3*/ const CodegenOutput_cqTq& out)
{
    str += (out ? "b"_view : fu::view<char>{});
    return str + out.src;
}

int fu_MAIN()
{
    fu::str str = fu::str("a"_fu);
    return test_MbR9(str, CodegenOutput_cqTq { fu::str("what"_fu) }).size() - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        using    
        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];

        using
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];

        fn RGB(linear: bool, r: i32) {
            return linear
                 ? linearRGB(r)
                 :      sRGB(r);
        }

        fn main() {
            mut c = RGB(linear: false, 7);
            return c.r - 21;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:18+1[0m:

[2m      |         fn RGB(linear: bool, r: i32) {[0m
[2m      |             return linear[0m
[2m   14 | [0m                 [31;1m?[0m linearRGB(r)
[2m      |                  :      sRGB(r);[0m
[2m      |         }[0m

	if/else: Type ambiguity, conversions exist both ways:

	[35;3mstruct[0m [94;1mlinearRGB[0m -> [35;3mstruct[0m [94;1msRGB[0m:
	    [35;3musing[0m [35;3mfn[0m [94;1mlin2srgb[0m at [2m6:9+5[0m [2m7:12+8[0m:
[2m    6 | [0m        [31;1musing[0m    
[2m    7 | [0m        fn [31;1mlin2srgb[0m(c: linearRGB): sRGB = [ c.r / 3 ];

	[35;3mstruct[0m [94;1msRGB[0m -> [35;3mstruct[0m [94;1mlinearRGB[0m:
	    [35;3musing[0m [35;3mfn[0m [94;1msrgb2lin[0m at [2m9:9+5[0m [2m10:12+8[0m:
[2m    9 | [0m        [31;1musing[0m
[2m   10 | [0m        fn [31;1msrgb2lin[0m(c: sRGB): linearRGB = [ c.r * 3 ];


        Solving [35;3mfn[0m [94;1mRGB[0m([35;3mbool[0m, [35;3mi32[0m) at [2m12:12+3[0m

========

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];

        using
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];

        fn RGB(linear: bool, r: i32) {
            return linear
                 ? linearRGB(r)
                 :      sRGB(r);
        }

        fn main() {
            mut c = RGB(linear: false, 7);
            return c.r - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct linearRGB_mMn2;
struct sRGB_8Kvg;

                                #ifndef DEF_linearRGB_mMn2D9OzfC8
                                #define DEF_linearRGB_mMn2D9OzfC8
struct linearRGB_mMn2
{
                                // shape_hash:    256f9b69384fd546
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_sRGB_8KvgDQksJK5
                                #define DEF_sRGB_8KvgDQksJK5
struct sRGB_8Kvg
{
                                // shape_hash:    81c33d35e3284034
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static linearRGB_mMn2 srgb2lin_MbR9(/*1:1*/ const sRGB_8Kvg& c)
{
    return linearRGB_mMn2 { (c.r * 3) };
}

static linearRGB_mMn2 RGB_MbR9(const bool linear, const int r)
{
    if (linear)
    {
        return linearRGB_mMn2 { r };
    }
    else
    {
        return srgb2lin_MbR9(sRGB_8Kvg { r });
    };
}

int fu_MAIN()
{
    const linearRGB_mMn2 c = RGB_MbR9(false, 7);
    return c.r - 21;
}

#endif

int main() { return fu_MAIN(); }

========

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];

        fn main() = (sRGB(r: 3) => linearRGB).r - 21;

---- <fail> ----
[2m[0m_0[2m.fu 8:22+4[0m:

[2m      |         fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];[0m
[2m      | [0m
[2m    8 | [0m        fn main() = ([31;1msRGB[0m(r: 3) => linearRGB).r - 21;
[2m      | [0m

	Cannot convert: expects [35;3mstruct[0m [94;1mlinearRGB[0m, got [35;3mstruct[0m [94;1msRGB[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        using                
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];

        fn main() = (sRGB(r: 3) => linearRGB).r - 21;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sRGB_8Kvg;
struct linearRGB_mMn2;

                                #ifndef DEF_sRGB_8KvgDQksJK5
                                #define DEF_sRGB_8KvgDQksJK5
struct sRGB_8Kvg
{
                                // shape_hash:    81c33d35e3284034
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_linearRGB_mMn2D9OzfC8
                                #define DEF_linearRGB_mMn2D9OzfC8
struct linearRGB_mMn2
{
                                // shape_hash:    256f9b69384fd546
                                // non_triv_mask: 0000000000000000
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static linearRGB_mMn2 srgb2lin_MbR9(/*1:1*/ const sRGB_8Kvg& c)
{
    return linearRGB_mMn2 { (c.r * 7) };
}

int fu_MAIN()
{
    return srgb2lin_MbR9(sRGB_8Kvg { 3 }).r - 21;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Overload     { name: string; };
        struct Target       { o_index: i32; };

        struct Helpers      { hd_index: i32; };
        struct HelpersData  { target: Target; };

        fn solve(ref overloads: Overload[], ref helpers: HelpersData[])
        {
            using fn GET(h: Helpers)
                helpers[h.hd_index];

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(t: Target) {
                ref o = overloads[t.o_index];

                // The qWHAT here tried to (pointlessly) solve qWHAT below,
                //  but GET hadn't solved yet so it wasn't available.
                return o.qWHAT ? o : GET(Target(t.o_index + 1));
            }

            fn qWHAT(hd: HelpersData)
                hd.target.qWHAT;

            return Helpers(0).qWHAT;
        }

        fn main() {
            mut overloads: Overload[];
            mut helpers: HelpersData[];

            for (mut i = 0; i < 2; i++) {
                overloads ~= Overload(i && "o=" ~ i);
                helpers ~= HelpersData(Target(i));
            }

            return solve(overloads, helpers) == "o=1" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Overload_BK87;
struct HelpersData_zwUJ;
struct Target_kGGJ;
struct Helpers_Z1aS;
static const Overload_BK87& GET_GL0m(const Target_kGGJ&, fu::view_mut<Overload_BK87>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_kGGJNGCTsz9
                                #define DEF_Target_kGGJNGCTsz9
struct Target_kGGJ
{
                                // shape_hash:    05cf9f61c1ccd7f6
                                // non_triv_mask: 0000000000000000
    int o_index;
    explicit operator bool() const noexcept
    {
        return false
            || o_index
        ;
    }
};
                                #endif

                                #ifndef DEF_HelpersData_zwUJpTW1Rq9
                                #define DEF_HelpersData_zwUJpTW1Rq9
struct HelpersData_zwUJ
{
                                // shape_hash:    b08370c008dafdd6
                                // non_triv_mask: 0000000000000000
    Target_kGGJ target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_Z1aSTlg0pzj
                                #define DEF_Helpers_Z1aSTlg0pzj
struct Helpers_Z1aS
{
                                // shape_hash:    3c642bde25ea4f3e
                                // non_triv_mask: 0000000000000000
    int hd_index;
    explicit operator bool() const noexcept
    {
        return false
            || hd_index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static const HelpersData_zwUJ& GET_haRm(/*3:3*/ const Helpers_Z1aS& h, /*3:3*/ fu::view<HelpersData_zwUJ> helpers)
{
    return helpers[h.hd_index];
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static const Overload_BK87& GET_GL0m(/*3:3*/ const Target_kGGJ& t, /*3:3*/ fu::view_mut<Overload_BK87> overloads)
{
    const Overload_BK87& /*overloads|static*/ o = overloads[t.o_index];
    if (qWHAT_kGbb(o))
        return o;
    else
    {
        return GET_GL0m(Target_kGGJ { (t.o_index + 1) }, overloads);
    };
}

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static const fu::str& qWHAT_GL0m(/*3:3*/ const HelpersData_zwUJ& hd, /*3:3*/ fu::view_mut<Overload_BK87> overloads)
{
    return qWHAT_MbR9(GET_GL0m(hd.target, overloads));
}

static const fu::str& solve_MbR9(/*3:3*/ fu::view_mut<Overload_BK87> overloads, /*3:3*/ fu::view<HelpersData_zwUJ> helpers)
{
    return qWHAT_GL0m(GET_haRm(Helpers_Z1aS { 0 }, helpers), overloads);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Overload_BK87> overloads {};
    fu::vec<HelpersData_zwUJ> helpers {};
    for (int i = 0; i < 2; i++)
    {
        overloads += Overload_BK87 { (i ? x7E_rA00("o="_view, fu::i64dec(i)) : fu::str{}) };
        helpers += HelpersData_zwUJ { Target_kGGJ { i } };
    };
    if (solve_MbR9(overloads, helpers) == "o=1"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        struct Overload     { name: string; };
        struct Target       { o_index: i32; };

        struct Helpers      { hd_index: i32; };
        struct HelpersData  { target: Target; };

        fn overloads(implicit ref o: Overload[]) o;
        fn helpers(implicit ref h: HelpersData[]) h;

        using fn GET(h: Helpers)
            helpers[h.hd_index];

        fn qWHAT(o: Overload)
            o.name;

        using fn GET(t: Target) {
            ref o = overloads[t.o_index];

            // The qWHAT here tried to (pointlessly) solve qWHAT below,
            //  but GET hadn't solved yet so it wasn't available.
            return o.qWHAT ? o : GET(Target(t.o_index + 1));
        }

        fn qWHAT(hd: HelpersData)
            hd.target.qWHAT;

        fn solve() = Helpers(0).qWHAT;

        fn main() {
            implicit mut o: Overload[];
            implicit mut h: HelpersData[];

            for (mut i = 0; i < 2; i++) {
                o ~= Overload(i && "o=" ~ i);
                h ~= HelpersData(Target(i));
            }

            return solve() == "o=1" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct Overload_BK87;
struct HelpersData_zwUJ;
struct Target_kGGJ;
struct Helpers_Z1aS;
static const Overload_BK87& GET_GL0m(const Target_kGGJ&, fu::view_mut<Overload_BK87>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_kGGJNGCTsz9
                                #define DEF_Target_kGGJNGCTsz9
struct Target_kGGJ
{
                                // shape_hash:    05cf9f61c1ccd7f6
                                // non_triv_mask: 0000000000000000
    int o_index;
    explicit operator bool() const noexcept
    {
        return false
            || o_index
        ;
    }
};
                                #endif

                                #ifndef DEF_HelpersData_zwUJpTW1Rq9
                                #define DEF_HelpersData_zwUJpTW1Rq9
struct HelpersData_zwUJ
{
                                // shape_hash:    b08370c008dafdd6
                                // non_triv_mask: 0000000000000000
    Target_kGGJ target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_Z1aSTlg0pzj
                                #define DEF_Helpers_Z1aSTlg0pzj
struct Helpers_Z1aS
{
                                // shape_hash:    3c642bde25ea4f3e
                                // non_triv_mask: 0000000000000000
    int hd_index;
    explicit operator bool() const noexcept
    {
        return false
            || hd_index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::view<HelpersData_zwUJ> helpers_haRm(/*1:1*/ fu::view<HelpersData_zwUJ> h)
{
    return h;
}

static const HelpersData_zwUJ& GET_haRm(/*3:3*/ const Helpers_Z1aS& h, /*3:3*/ fu::view<HelpersData_zwUJ> h_1)
{
    return helpers_haRm(h_1)[h.hd_index];
}

static fu::view<Overload_BK87> overloads_haRm(/*1:1*/ fu::view<Overload_BK87> o)
{
    return o;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static const Overload_BK87& GET_GL0m(/*3:3*/ const Target_kGGJ& t, /*3:3*/ fu::view_mut<Overload_BK87> o)
{
    const Overload_BK87& /*o|static*/ o_1 = overloads_haRm(o)[t.o_index];
    if (qWHAT_kGbb(o_1))
        return o_1;
    else
    {
        return GET_GL0m(Target_kGGJ { (t.o_index + 1) }, o);
    };
}

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static const fu::str& qWHAT_GL0m(/*3:3*/ const HelpersData_zwUJ& hd, /*3:3*/ fu::view_mut<Overload_BK87> o)
{
    return qWHAT_MbR9(GET_GL0m(hd.target, o));
}

static const fu::str& solve_MbR9(/*3:3*/ fu::view<HelpersData_zwUJ> h, /*3:3*/ fu::view_mut<Overload_BK87> o)
{
    return qWHAT_GL0m(GET_haRm(Helpers_Z1aS { 0 }, h), o);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<Overload_BK87> o {};
    fu::vec<HelpersData_zwUJ> h {};
    for (int i = 0; i < 2; i++)
    {
        o += Overload_BK87 { (i ? x7E_rA00("o="_view, fu::i64dec(i)) : fu::str{}) };
        h += HelpersData_zwUJ { Target_kGGJ { i } };
    };
    if (solve_MbR9(h, o) == "o=1"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {

                return n.map(|t| t.qWHAT).join();

            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Overload_BK87>, fu::view<Target_HIBL>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    for (int i = _targets.size(); i-- > 0; )
    {
        const Target_HIBL& /*_targets|static*/ t = _targets[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, _overloads, _targets));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    if ((_overloads.size() >= target.index))
        return _overloads[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads.size() - 1) }, _overloads, _targets))), _overloads, _targets);
    };
}

                                #ifndef DEF___oU4eAmIoGDl
                                #define DEF___oU4eAmIoGDl
inline static const fu::str& _oU4e(/*7:7*/ const Target_HIBL& t, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    return qWHAT_MbR9(GET_MbR9(t, _overloads, _targets));
}
                                #endif

                                #ifndef DEF_map_D51EtbbKsLf
                                #define DEF_map_D51EtbbKsLf
inline fu::vec<fu::str> map_D51E(/*F:F*/ fu::view<Target_HIBL> a, /*F:F*/ fu::view<Overload_BK87> _overloads, /*F:F*/ fu::view<Target_HIBL> _targets)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_oU4e(a[i], _overloads, _targets));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    return join_QbuI(map_D51E(n, _overloads, _targets));
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> _overloads, /*3:3*/ fu::view<Target_HIBL> _targets)
{
    return qWHAT_GL0m(_targets, _overloads, _targets);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {

                mut res = "";
                for (mut i = 0; i < n.len; i++)
                    res ~= n[i].qWHAT;

                return res;

            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Overload_BK87>, fu::view<Target_HIBL>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    for (int i = _targets.size(); i-- > 0; )
    {
        const Target_HIBL& /*_targets|static*/ t = _targets[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, _overloads, _targets));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    if ((_overloads.size() >= target.index))
        return _overloads[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads.size() - 1) }, _overloads, _targets))), _overloads, _targets);
    };
}

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    /*MOV*/ fu::str res = fu::str(""_fu);
    for (int i = 0; i < n.size(); i++)
        res += qWHAT_kGbb(GET_MbR9(n[i], _overloads, _targets));

    return /*NRVO*/ res;
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> _overloads, /*3:3*/ fu::view<Target_HIBL> _targets)
{
    return qWHAT_GL0m(_targets, _overloads, _targets);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {

                mut res = "";
                for (mut i = 0; i < n.len; i++)
                    res ~= n[i].qWHAT;

                return res;

            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Overload_BK87>, fu::view<Target_HIBL>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    for (int i = _targets.size(); i-- > 0; )
    {
        const Target_HIBL& /*_targets|static*/ t = _targets[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, _overloads, _targets));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    if ((_overloads.size() >= target.index))
        return _overloads[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads.size() - 1) }, _overloads, _targets))), _overloads, _targets);
    };
}

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Overload_BK87> _overloads, /*7:7*/ fu::view<Target_HIBL> _targets)
{
    /*MOV*/ fu::str res {};
    for (int i = 0; i < n.size(); i++)
        res += qWHAT_kGbb(GET_MbR9(n[i], _overloads, _targets));

    return /*NRVO*/ res;
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> _overloads, /*3:3*/ fu::view<Target_HIBL> _targets)
{
    return qWHAT_GL0m(_targets, _overloads, _targets);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn _overloads(implicit overloads: Overload[]) overloads;
        fn _targets(implicit targets: Target[]) targets;

        fn fail(mut reason: string): never {
            for (mut i = _targets.len; i --> 0; ) {
                let t = _targets[i];
                if (t)
                    reason ~= GET(t).qWHAT;
            }

            return throw(reason);
        }

        fn qWHAT(o: Overload)
            o.name;

        using fn GET(target: Target) {
            _overloads.len >= target.index || fail(
                GET(Target(_overloads.len - 1)).qWHAT);

            return _overloads[target.index];
        }

        fn qWHAT(n: Target[]) {

            return n.map(|t| t.qWHAT).join();

        }

        fn solve(implicit overloads: Overload[], implicit targets: Target[])
            targets.qWHAT;

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Target_HIBL>, fu::view<Overload_BK87>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Overload_BK87> _overloads_kGbb(/*1:1*/ fu::view<Overload_BK87> overloads)
{
    return overloads;
}

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<Target_HIBL> _targets_kGbb(/*1:1*/ fu::view<Target_HIBL> targets)
{
    return targets;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    for (int i = _targets_kGbb(targets).size(); i-- > 0; )
    {
        const Target_HIBL& /*targets|static*/ t = _targets_kGbb(targets)[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, targets, overloads));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    if ((_overloads_kGbb(overloads).size() >= target.index))
        return _overloads_kGbb(overloads)[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads_kGbb(overloads).size() - 1) }, targets, overloads))), targets, overloads);
    };
}

                                #ifndef DEF___dNxI7yARET4
                                #define DEF___dNxI7yARET4
inline static const fu::str& _dNxI(/*7:7*/ const Target_HIBL& t, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    return qWHAT_MbR9(GET_MbR9(t, targets, overloads));
}
                                #endif

                                #ifndef DEF_map_LorOxQt6449
                                #define DEF_map_LorOxQt6449
inline fu::vec<fu::str> map_LorO(/*F:F*/ fu::view<Target_HIBL> a, /*F:F*/ fu::view<Target_HIBL> targets, /*F:F*/ fu::view<Overload_BK87> overloads)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(_dNxI(a[i], targets, overloads));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    return join_QbuI(map_LorO(n, targets, overloads));
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> overloads, /*3:3*/ fu::view<Target_HIBL> targets)
{
    return qWHAT_GL0m(targets, targets, overloads);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn _overloads(implicit overloads: Overload[]) overloads;
        fn _targets(implicit targets: Target[]) targets;

        fn fail(mut reason: string): never {
            for (mut i = _targets.len; i --> 0; ) {
                let t = _targets[i];
                if (t)
                    reason ~= GET(t).qWHAT;
            }

            return throw(reason);
        }

        fn qWHAT(o: Overload)
            o.name;

        using fn GET(target: Target) {
            _overloads.len >= target.index || fail(
                GET(Target(_overloads.len - 1)).qWHAT);

            return _overloads[target.index];
        }

        fn qWHAT(n: Target[]) {

            mut res = "";
            for (mut i = 0; i < n.len; i++)
                res ~= n[i].qWHAT;

            return res;

        }

        fn solve(implicit overloads: Overload[], implicit targets: Target[])
            targets.qWHAT;

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Target_HIBL>, fu::view<Overload_BK87>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Overload_BK87> _overloads_kGbb(/*1:1*/ fu::view<Overload_BK87> overloads)
{
    return overloads;
}

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<Target_HIBL> _targets_kGbb(/*1:1*/ fu::view<Target_HIBL> targets)
{
    return targets;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    for (int i = _targets_kGbb(targets).size(); i-- > 0; )
    {
        const Target_HIBL& /*targets|static*/ t = _targets_kGbb(targets)[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, targets, overloads));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    if ((_overloads_kGbb(overloads).size() >= target.index))
        return _overloads_kGbb(overloads)[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads_kGbb(overloads).size() - 1) }, targets, overloads))), targets, overloads);
    };
}

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    /*MOV*/ fu::str res = fu::str(""_fu);
    for (int i = 0; i < n.size(); i++)
        res += qWHAT_kGbb(GET_MbR9(n[i], targets, overloads));

    return /*NRVO*/ res;
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> overloads, /*3:3*/ fu::view<Target_HIBL> targets)
{
    return qWHAT_GL0m(targets, targets, overloads);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn _overloads(implicit overloads: Overload[]) overloads;
        fn _targets(implicit targets: Target[]) targets;

        fn fail(mut reason: string): never {
            for (mut i = _targets.len; i --> 0; ) {
                let t = _targets[i];
                if (t)
                    reason ~= GET(t).qWHAT;
            }

            return throw(reason);
        }

        fn qWHAT(o: Overload)
            o.name;

        using fn GET(target: Target) {
            _overloads.len >= target.index || fail(
                GET(Target(_overloads.len - 1)).qWHAT);

            return _overloads[target.index];
        }

        fn qWHAT(n: Target[]) {

            mut res = "";
            for (mut i = 0; i < n.len; i++)
                res ~= n[i].qWHAT;

            return res;

        }

        fn solve(implicit overloads: Overload[], implicit targets: Target[])
            targets.qWHAT;

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct Overload_BK87;
struct Target_HIBL;
static const Overload_BK87& GET_MbR9(const Target_HIBL&, fu::view<Target_HIBL>, fu::view<Overload_BK87>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Overload_BK87> _overloads_kGbb(/*1:1*/ fu::view<Overload_BK87> overloads)
{
    return overloads;
}

static const fu::str& qWHAT_MbR9(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

static fu::view<Target_HIBL> _targets_kGbb(/*1:1*/ fu::view<Target_HIBL> targets)
{
    return targets;
}

static fu::view<char> qWHAT_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_MbR9(/*MOV*/ fu::str&& reason, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    for (int i = _targets_kGbb(targets).size(); i-- > 0; )
    {
        const Target_HIBL& /*targets|static*/ t = _targets_kGbb(targets)[i];
        if (t)
            reason += qWHAT_kGbb(GET_MbR9(t, targets, overloads));

    };
    fu::fail(reason.destructive_move());
}

static const Overload_BK87& GET_MbR9(/*7:7*/ const Target_HIBL& target, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    if ((_overloads_kGbb(overloads).size() >= target.index))
        return _overloads_kGbb(overloads)[target.index];
    else
    {
        fail_MbR9(fu::str(qWHAT_MbR9(GET_MbR9(Target_HIBL { (_overloads_kGbb(overloads).size() - 1) }, targets, overloads))), targets, overloads);
    };
}

static fu::str qWHAT_GL0m(/*7:7*/ fu::view<Target_HIBL> n, /*7:7*/ fu::view<Target_HIBL> targets, /*7:7*/ fu::view<Overload_BK87> overloads)
{
    /*MOV*/ fu::str res {};
    for (int i = 0; i < n.size(); i++)
        res += qWHAT_kGbb(GET_MbR9(n[i], targets, overloads));

    return /*NRVO*/ res;
}

static fu::str solve_MbR9(/*3:3*/ fu::view<Overload_BK87> overloads, /*3:3*/ fu::view<Target_HIBL> targets)
{
    return qWHAT_GL0m(targets, targets, overloads);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) }, Overload_BK87 { fu::str(", "_fu) }, Overload_BK87 { fu::str("! "_fu) }, Overload_BK87 { fu::str("World!"_fu) } }}, fu::view<Target_HIBL> {{ Target_HIBL { 0 }, Target_HIBL { 1 }, Target_HIBL { 3 } }});
    if (res == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        fn a_slash_b(a: f32, b: f32) {
            return a ~ "/" ~ b;                                 // DuplicateFunctions
        }

        fn main() {
            return a_slash_b(1, 2) == "1.000000/2.000000" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str a_slash_b_MbR9(const float a, const float b)
{
    return x7E_rA00(x7E_rA00(fu::f32dec(a), "/"_view), fu::f32dec(b));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (a_slash_b_MbR9(1.0f, 2.0f) == "1.000000/2.000000"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;

            return s + u;             
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:22+1[0m:

[2m      |             let u: u32 =  3;[0m
[2m      | [0m
[2m    6 | [0m            return s [31;1m+[0m u;             
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1m+[0m with args ([35;3mi32[0m, [35;3mu32[0m): 

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m+[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi32[0m <-> [35;3mu32[0m

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;

            return s + u;             
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:22+1[0m:

[2m      |             let u: u32 =  3;[0m
[2m      | [0m
[2m    6 | [0m            return s [31;1m+[0m u;             
[2m      |         }[0m
[2m      | [0m

	Bad call to [94;1m+[0m with args ([35;3malways-true[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mu32[0m): 

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m+[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi32[0m <-> [35;3mu32[0m

	[35;3mtemplate[0m [94;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;

            return s + u.i32;         
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int s = -3;
    const unsigned u = 3u;
    return s + int(u);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        using 
        fn toEnd(midb: MidB) End(midb.b * 7);


        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 18:26+1[0m:

[2m      |         fn main() {[0m
[2m      |             let start = Start(1);[0m
[2m   18 | [0m            return start.[31;1me[0m - 2*5;
[2m      |         }[0m
[2m      | [0m

	Conversion ambiguity, multiple ways to convert [35;3mstruct[0m [94;1mStart[0m into [35;3mnocopy[0m [35;3mstruct[0m [94;1mEnd[0m:

	    [35;3musing[0m [35;3mfn[0m [94;1mtoMidA[0m at [2m7:9+5[0m [2m7:18+6[0m:
[2m    7 | [0m        [31;1musing[0m fn [31;1mtoMidA[0m(start: Start) MidA(start.s * 2);
	    [35;3musing[0m [35;3mfn[0m [94;1mtoEnd[0m at [2m9:9+5[0m [2m9:18+5[0m:
[2m    9 | [0m        [31;1musing[0m fn [31;1mtoEnd[0m(mida: MidA) End(mida.a * 5);

	and:

	    [35;3musing[0m [35;3mfn[0m [94;1mtoMidB[0m at [2m8:9+5[0m [2m8:18+6[0m:
[2m    8 | [0m        [31;1musing[0m fn [31;1mtoMidB[0m(start: Start) MidB(start.s * 3);
	    [35;3musing[0m [35;3mfn[0m [94;1mtoEnd[0m at [2m12:9+5[0m [2m13:12+5[0m:
[2m   12 | [0m        [31;1musing[0m 
[2m   13 | [0m        fn [31;1mtoEnd[0m(midb: MidB) End(midb.b * 7);


        Solving [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        using 
        fn toEnd(midb: MidB) End(midb.b * 7);
        pub import _0;

        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

---- <fail> ----
[2m[0m_1[2m.fu 5:26+1[0m:

[2m      |         fn main() {[0m
[2m      |             let start = Start(1);[0m
[2m    5 | [0m            return start.[31;1me[0m - 2*5;
[2m      |         }[0m
[2m      | [0m

	Conversion ambiguity, multiple ways to convert [35;3mstruct[0m [94;1mStart[0m into [35;3mnocopy[0m [35;3mstruct[0m [94;1mEnd[0m:

	    [35;3musing[0m [35;3mfn[0m [94;1mtoMidA[0m at [2m[0m_0[2m.fu 7:9+5[0m [2m7:18+6[0m:
[2m    7 | [0m        [31;1musing[0m fn [31;1mtoMidA[0m(start: Start) MidA(start.s * 2);
	    [35;3musing[0m [35;3mfn[0m [94;1mtoEnd[0m at [2m[0m_0[2m.fu 9:9+5[0m [2m9:18+5[0m:
[2m    9 | [0m        [31;1musing[0m fn [31;1mtoEnd[0m(mida: MidA) End(mida.a * 5);

	and:

	    [35;3musing[0m [35;3mfn[0m [94;1mtoMidB[0m at [2m[0m_0[2m.fu 8:9+5[0m [2m8:18+6[0m:
[2m    8 | [0m        [31;1musing[0m fn [31;1mtoMidB[0m(start: Start) MidB(start.s * 3);
	    [35;3musing[0m [35;3mfn[0m [94;1mtoEnd[0m at [2m[0m_0[2m.fu 12:9+5[0m [2m13:12+5[0m:
[2m   12 | [0m        [31;1musing[0m 
[2m   13 | [0m        fn [31;1mtoEnd[0m(midb: MidB) End(midb.b * 7);


        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        fn toEnd(midb: MidB) End(midb.b * 7);


        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Start_kaWC;
struct MidA_EFEV;
struct End_a3iQ;

                                #ifndef DEF_Start_kaWCXuxS9m4
                                #define DEF_Start_kaWCXuxS9m4
struct Start_kaWC
{
                                // shape_hash:    86469581131e0c23
                                // non_triv_mask: 0000000000000000
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_MidA_EFEVG40Oqr3
                                #define DEF_MidA_EFEVG40Oqr3
struct MidA_EFEV
{
                                // shape_hash:    e05212727bfa8182
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_End_a3iQnpYMC40
                                #define DEF_End_a3iQnpYMC40
struct End_a3iQ
{
                                // shape_hash:    cb8b5d770867ed00
                                // non_triv_mask: 0000000000000000
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static MidA_EFEV toMidA_MbR9(/*1:1*/ const Start_kaWC& start)
{
    return MidA_EFEV { (start.s * 2) };
}

static End_a3iQ toEnd_MbR9(/*1:1*/ const MidA_EFEV& mida)
{
    return End_a3iQ { (mida.a * 5) };
}

int fu_MAIN()
{
    const Start_kaWC start = Start_kaWC { 1 };
    return toEnd_MbR9(toMidA_MbR9(start)).e - (2 * 5);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        fn toEnd(midb: MidB) End(midb.b * 7);
        pub import _0;

        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Start_kaWC;
struct MidA_EFEV;
struct End_a3iQ;
MidA_EFEV toMidA_MbR9(const Start_kaWC&);
End_a3iQ toEnd_MbR9(const MidA_EFEV&);

                                #ifndef DEF_Start_kaWCXuxS9m4
                                #define DEF_Start_kaWCXuxS9m4
struct Start_kaWC
{
                                // shape_hash:    86469581131e0c23
                                // non_triv_mask: 0000000000000000
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_MidA_EFEVG40Oqr3
                                #define DEF_MidA_EFEVG40Oqr3
struct MidA_EFEV
{
                                // shape_hash:    e05212727bfa8182
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_End_a3iQnpYMC40
                                #define DEF_End_a3iQnpYMC40
struct End_a3iQ
{
                                // shape_hash:    cb8b5d770867ed00
                                // non_triv_mask: 0000000000000000
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Start_kaWC start = Start_kaWC { 1 };
    return toEnd_MbR9(toMidA_MbR9(start)).e - (2 * 5);
}

#endif

int main() { return fu_MAIN(); }
struct MidA_EFEV;
struct Start_kaWC;
struct MidB_pFXt;
struct End_a3iQ;

                                #ifndef DEF_MidA_EFEVG40Oqr3
                                #define DEF_MidA_EFEVG40Oqr3
struct MidA_EFEV
{
                                // shape_hash:    e05212727bfa8182
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_Start_kaWCXuxS9m4
                                #define DEF_Start_kaWCXuxS9m4
struct Start_kaWC
{
                                // shape_hash:    86469581131e0c23
                                // non_triv_mask: 0000000000000000
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_MidB_pFXty01sAGk
                                #define DEF_MidB_pFXty01sAGk
struct MidB_pFXt
{
                                // shape_hash:    b6a88f8d44104f0f
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_End_a3iQnpYMC40
                                #define DEF_End_a3iQnpYMC40
struct End_a3iQ
{
                                // shape_hash:    cb8b5d770867ed00
                                // non_triv_mask: 0000000000000000
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

MidA_EFEV toMidA_MbR9(/*1:1*/ const Start_kaWC& start)
{
    return MidA_EFEV { (start.s * 2) };
}

MidB_pFXt toMidB_MbR9(/*1:1*/ const Start_kaWC& start)
{
    return MidB_pFXt { (start.s * 3) };
}

End_a3iQ toEnd_MbR9(/*1:1*/ const MidA_EFEV& mida)
{
    return End_a3iQ { (mida.a * 5) };
}

End_a3iQ toEnd_kGbb(/*1:1*/ const MidB_pFXt& midb)
{
    return End_a3iQ { (midb.b * 7) };
}

#endif

========

        struct vec3 { x: i32 };
        fn woot(
            using a: vec3,

            using 
            b: vec3)
        {
            return x + b.x;
        }

        fn main() vec3(1).woot(vec3(-1));

---- <fail> ----
[2m[0m_0[2m.fu 9:20+1[0m:

[2m      |             b: vec3)[0m
[2m      |         {[0m
[2m    9 | [0m            return [31;1mx[0m + b.x;
[2m      |         }[0m
[2m      | [0m

	[31;1musing[0m ambiguity, multiple ways to obtain a [35;3mnocopy[0m [35;3mstruct[0m [94;1mvec3[0m in this scope:

	    [35;3musing[0m [35;3marg[0m [94;1ma[0m at [2m4:13+5[0m [2m4:19+1[0m:
[2m    4 | [0m            [31;1musing[0m [31;1ma[0m: vec3,

	and:

	    [35;3musing[0m [35;3marg[0m [94;1mb[0m at [2m6:13+5[0m [2m7:13+1[0m:
[2m    6 | [0m            [31;1musing[0m 
[2m    7 | [0m            [31;1mb[0m: vec3)


        Solving [35;3mfn[0m [94;1mwoot[0m([94;1mvec3[0m, [94;1mvec3[0m) at [2m3:12+4[0m

========

        struct vec3 { x: i32 };
        fn woot(
            using a: vec3,

            b: vec3)
        {
            return x + b.x;
        }

        fn main() vec3(1).woot(vec3(-1));

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct vec3_OAbi;

                                #ifndef DEF_vec3_OAbio7F8FEf
                                #define DEF_vec3_OAbio7F8FEf
struct vec3_OAbi
{
                                // shape_hash:    66bdb33dab08a56b
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int woot_MbR9(/*3:3*/ const vec3_OAbi& a, /*3:3*/ const vec3_OAbi& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    return woot_MbR9(vec3_OAbi { 1 }, vec3_OAbi { -1 });
}

#endif

int main() { return fu_MAIN(); }

========

        struct B { v: i32 };
        struct C { v: i32 };


        struct A { v: i32 };
        using fn AB(a: A) B(a.v * 2);
        using fn AC(a: A) C(a.v * 3);


        fn main() {
            let a = A(1);
            let b: B = a;
            let c: C = a;
            return b.v * c.v - 6;
        }

---- <fail> ----
[2m[0m_0[2m.fu 8:31+1[0m:

[2m      |         struct A { v: i32 };[0m
[2m      |         using fn AB(a: A) B(a.v * 2);[0m
[2m    8 | [0m        using fn AC(a: A) C(a.[31;1mv[0m * 3);
[2m      | [0m
[2m      | [0m

	Ambiguous call to [94;1mv[0m with args ([35;3mstruct[0m [94;1mA[0m), matches multiple items in scope:

	[35;3mfield[0m [94;1mB[0m:[94;1mv[0m at [2m2:20+1[0m:
[2m    2 | [0m        struct B { [31;1mv[0m: i32 };

	    [35;3musing[0m [35;3mfn[0m [94;1mAB[0m at [2m7:9+5[0m [2m7:18+2[0m:
[2m    7 | [0m        [31;1musing[0m fn [31;1mAB[0m(a: A) B(a.v * 2);

	[35;3mfield[0m [94;1mA[0m:[94;1mv[0m at [2m6:20+1[0m:
[2m    6 | [0m        struct A { [31;1mv[0m: i32 };


        Solving [35;3mfn[0m [94;1mAC[0m([94;1mA[0m) at [2m8:18+2[0m

========

        struct B { v: i32 };
        struct C { v: i32 };


        struct A { a: i32 };
        using fn AB(a: A) B(a.a * 2);
        using fn AC(a: A) C(a.a * 3);


        fn main() {
            let a = A(1);
            let b: B = a;
            let c: C = a;
            return b.v * c.v - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_FT58;
struct C_70wN;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_FT58yBmvoRe
                                #define DEF_B_FT58yBmvoRe
struct B_FT58
{
                                // shape_hash:    fcdcf41f316091da
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_C_70wNBA6Xra0
                                #define DEF_C_70wNBA6Xra0
struct C_70wN
{
                                // shape_hash:    fc259af880e96f10
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_FT58 AB_MbR9(/*1:1*/ const A_EqO7& a)
{
    return B_FT58 { (a.a * 2) };
}

static C_70wN AC_MbR9(/*1:1*/ const A_EqO7& a)
{
    return C_70wN { (a.a * 3) };
}

int fu_MAIN()
{
    const A_EqO7 a = A_EqO7 { 1 };
    const B_FT58 b = AB_MbR9(a);
    const C_70wN c = AC_MbR9(a);
    return (b.v * c.v) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A1 { v: i32 };
        struct A2 { v: i32 };
        struct B { v: i32 };

        using fn A1B(a: A1) B(a.v * 2);
        using fn A2B(a: A2) B(a.v * 3);

        fn test(a): B = a;

        fn main() A1(1).test.v * A2(1).test.v - 6;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A1_Pqqm;
struct B_FT58;
struct A2_TboH;

                                #ifndef DEF_A1_PqqmV5WHzBb
                                #define DEF_A1_PqqmV5WHzBb
struct A1_Pqqm
{
                                // shape_hash:    72bd5cb9339de278
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_B_FT58yBmvoRe
                                #define DEF_B_FT58yBmvoRe
struct B_FT58
{
                                // shape_hash:    fcdcf41f316091da
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_A2_TboHMTglHo5
                                #define DEF_A2_TboHMTglHo5
struct A2_TboH
{
                                // shape_hash:    98bcb4d5970d0ee3
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_FT58 A1B_MbR9(/*1:1*/ const A1_Pqqm& a)
{
    return B_FT58 { (a.v * 2) };
}

                                #ifndef DEF_test_hhLpRrEZWe6
                                #define DEF_test_hhLpRrEZWe6
inline static B_FT58 test_hhLp(/*1:1*/ const A1_Pqqm& a)
{
    return A1B_MbR9(a);
}
                                #endif

static B_FT58 A2B_MbR9(/*1:1*/ const A2_TboH& a)
{
    return B_FT58 { (a.v * 3) };
}

                                #ifndef DEF_test_TGVgggjjCth
                                #define DEF_test_TGVgggjjCth
inline static B_FT58 test_TGVg(/*1:1*/ const A2_TboH& a)
{
    return A2B_MbR9(a);
}
                                #endif

int fu_MAIN()
{
    return (test_hhLp(A1_Pqqm { 1 }).v * test_TGVg(A2_TboH { 1 }).v) - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { target: i32; };
        struct B { target: u32; };

        fn definit()    
                = [];

        fn main() = definit.target;

---- <fail> ----
[2m[0m_0[2m.fu 8:29+6[0m:

[2m      |                 = [];[0m
[2m      | [0m
[2m    8 | [0m        fn main() = definit.[31;1mtarget[0m;
[2m      | [0m

	Ambiguous call to [94;1mtarget[0m with args ([35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3mfield[0m [94;1mB[0m:[94;1mtarget[0m at [2m3:20+6[0m:
[2m    3 | [0m        struct B { [31;1mtarget[0m: u32; };

	[35;3mfield[0m [94;1mA[0m:[94;1mtarget[0m at [2m2:20+6[0m:
[2m    2 | [0m        struct A { [31;1mtarget[0m: i32; };


        Solving [35;3mfn[0m [94;1mmain[0m at [2m8:12+4[0m

========

        struct A { target: i32; };
        struct B { target: u32; };

        fn definit()    
            : A         
                = [];

        fn main() = definit.target;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_zlwe;

                                #ifndef DEF_A_zlwe71IQVS6
                                #define DEF_A_zlwe71IQVS6
struct A_zlwe
{
                                // shape_hash:    9910749aad8a4305
                                // non_triv_mask: 0000000000000000
    int target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static A_zlwe definit_MbR9()
{
    return A_zlwe{};
}

int fu_MAIN()
{
    return definit_MbR9().target;
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { x: i32 };
        struct C { a: A };

        using fn C2A(ref a) a.a;    

        using fn getX(ref x.x) x;
        fn main(): i32 {
            let c: C;
            return c;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:26+1[0m:

[2m      |         struct C { a: A };[0m
[2m      | [0m
[2m    5 | [0m        using fn C2A(ref [31;1ma[0m) a.a;    
[2m      | [0m
[2m      |         using fn getX(ref x.x) x;[0m

	Conversion functions need type annotations on their arguments to know when to kick in.

========

        struct A { x: i32 };
        struct C { a: A };

        using fn C2A(ref a.a) a;    

        using fn getX(ref x.x) x;
        fn main(): i32 {
            let c: C;
            return c;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct C_uJl0;
struct A_6j1Y;

                                #ifndef DEF_A_6j1YaFZsIFe
                                #define DEF_A_6j1YaFZsIFe
struct A_6j1Y
{
                                // shape_hash:    48845602b2367eaa
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_C_uJl0hFG6SR1
                                #define DEF_C_uJl0hFG6SR1
struct C_uJl0
{
                                // shape_hash:    8c541dd4c26b4c51
                                // non_triv_mask: 0000000000000000
    A_6j1Y a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_C2A_niioNTs38Pj
                                #define DEF_C2A_niioNTs38Pj
inline static const A_6j1Y& C2A_niio(/*1:1*/ const A_6j1Y& a)
{
    return a;
}
                                #endif

                                #ifndef DEF_getX_0DCJaE9X1mk
                                #define DEF_getX_0DCJaE9X1mk
inline static int getX_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

int fu_MAIN()
{
    const C_uJl0 c {};
    return getX_0DCJ(C2A_niio(c.a).x);
}

#endif

int main() { return fu_MAIN(); }

========

        struct A { x: i32 };
        struct C { a: A };

        using fn C2A(ref a) a.a;    

        using fn getX(ref .x) x;
        fn main(): i32 {
            let c: C;
            return c;
        }

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:26+1[0m:

[2m      |         struct C { a: A };[0m
[2m      | [0m
[2m    5 | [0m        using fn C2A(ref [31;1ma[0m) a.a;    
[2m      | [0m
[2m      |         using fn getX(ref .x) x;[0m

	Conversion functions need type annotations on their arguments to know when to kick in.

========

        struct A { x: i32 };
        struct C { a: A };

        using fn C2A(ref .a)  a;    

        using fn getX(ref .x) x;
        fn main(): i32 {
            let c: C;
            return c;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct C_uJl0;
struct A_6j1Y;

                                #ifndef DEF_A_6j1YaFZsIFe
                                #define DEF_A_6j1YaFZsIFe
struct A_6j1Y
{
                                // shape_hash:    48845602b2367eaa
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_C_uJl0hFG6SR1
                                #define DEF_C_uJl0hFG6SR1
struct C_uJl0
{
                                // shape_hash:    8c541dd4c26b4c51
                                // non_triv_mask: 0000000000000000
    A_6j1Y a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_C2A_niioNTs38Pj
                                #define DEF_C2A_niioNTs38Pj
inline static const A_6j1Y& C2A_niio(/*1:1*/ const A_6j1Y& a)
{
    return a;
}
                                #endif

                                #ifndef DEF_getX_0DCJaE9X1mk
                                #define DEF_getX_0DCJaE9X1mk
inline static int getX_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

int fu_MAIN()
{
    const C_uJl0 c {};
    return getX_0DCJ(C2A_niio(c.a).x);
}

#endif

int main() { return fu_MAIN(); }

========

        struct Set(type T) { using array: T[] }

        struct CountedSet(type T) { using set: _0::Set(T) }

        fn main() {
            mut cs: _1::CountedSet(i32);
            mut count = 0;
            cs.each: |_| count++;
            return count;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct CountedSet_K0dh;
struct Set_B369;

                                #ifndef DEF_Set_B369I1Z0Cbh
                                #define DEF_Set_B369I1Z0Cbh
struct Set_B369
{
                                // shape_hash:    f8f723c44b3f038c
                                // non_triv_mask: 0008000000000000
    fu::vec<int> array;
    explicit operator bool() const noexcept
    {
        return false
            || array
        ;
    }
};
                                #endif

                                #ifndef DEF_CountedSet_K0dh8wnPmzh
                                #define DEF_CountedSet_K0dh8wnPmzh
struct CountedSet_K0dh
{
                                // shape_hash:    a929d6aa6a967acc
                                // non_triv_mask: 0008004000000000
    Set_B369 set;
    explicit operator bool() const noexcept
    {
        return false
            || set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___NXVamzjzpP3
                                #define DEF___NXVamzjzpP3
inline static int _NXVa(/*3:3*/ int& count)
{
    return count++;
}
                                #endif

                                #ifndef DEF_each_WV5UZm3Vdt4
                                #define DEF_each_WV5UZm3Vdt4
inline void each_WV5U(/*7:7*/ fu::view<int> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _NXVa(count);

}
                                #endif

int fu_MAIN()
{
    CountedSet_K0dh cs {};
    int count = 0;
    each_WV5U(cs.set.array, count);
    return count;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

========

        struct Set(type T) {    
            using               
            array: T[];
        }

        fn each !T(ref set: Set(T), visit) set.array.each(fn visit);

        struct CountedSet(type T) { using set: _0::Set(T) }

        fn main() {
            mut cs: _1::CountedSet(i32);
            mut count = 0;
            cs.each: |_| count++;
            return count;
        }

---- <fail> ----
[2m[0m_2[2m.fu 5:16+4[0m:

[2m      |             mut cs: _1::CountedSet(i32);[0m
[2m      |             mut count = 0;[0m
[2m    5 | [0m            cs.[31;1meach[0m: |_| count++;
[2m      |             return count;[0m
[2m      |         }[0m

	Ambiguous call to [94;1meach[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mCountedSet[0m([35;3mi32[0m), [35;3mnocopy[0m [35;3m@1A0[0m), matches multiple items in scope:

	[35;3mfn[0m [94;1meach[0m at [2m../../../../../[0mprelude[2m 858:4+4[0m:
[2m  858 | [0mfn [31;1meach[0m(ref a: <T>[..], fn)

	    [35;3mref arg[0m [94;1meach[0m:[94;1ma[0m: [35;3musing[0m [35;3mfield[0m [94;1mCountedSet[0m:[94;1mset[0m at [2m[0m_1[2m.fu 2:37+5[0m [2m2:43+3[0m:
[2m    2 | [0m        struct CountedSet(type T) { [31;1musing[0m [31;1mset[0m: _0::Set(T) }
	    [35;3musing[0m [35;3mfield[0m [94;1mSet[0m:[94;1marray[0m at [2m[0m_0[2m.fu 3:13+5[0m [2m4:13+5[0m:
[2m    3 | [0m            [31;1musing[0m               
[2m    4 | [0m            [31;1marray[0m: T[];

	[35;3mfn[0m [94;1meach[0m at [2m[0m_0[2m.fu 7:12+4[0m:
[2m    7 | [0m        fn [31;1meach[0m !T(ref set: Set(T), visit) set.array.each(fn visit);

	    [35;3mref arg[0m [94;1meach[0m:[94;1mset[0m: [35;3musing[0m [35;3mfield[0m [94;1mCountedSet[0m:[94;1mset[0m at [2m[0m_1[2m.fu 2:37+5[0m [2m2:43+3[0m:
[2m    2 | [0m        struct CountedSet(type T) { [31;1musing[0m [31;1mset[0m: _0::Set(T) }


        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        struct Set(type T) {    
            array: T[];
        }

        fn each !T(ref set: Set(T), visit) set.array.each(fn visit);

        struct CountedSet(type T) { using set: _0::Set(T) }

        fn main() {
            mut cs: _1::CountedSet(i32);
            mut count = 0;
            cs.each: |_| count++;
            return count;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct CountedSet_K0dh;
struct Set_B369;

                                #ifndef DEF_Set_B369I1Z0Cbh
                                #define DEF_Set_B369I1Z0Cbh
struct Set_B369
{
                                // shape_hash:    f8f723c44b3f038c
                                // non_triv_mask: 0008000000000000
    fu::vec<int> array;
    explicit operator bool() const noexcept
    {
        return false
            || array
        ;
    }
};
                                #endif

                                #ifndef DEF_CountedSet_K0dh8wnPmzh
                                #define DEF_CountedSet_K0dh8wnPmzh
struct CountedSet_K0dh
{
                                // shape_hash:    a929d6aa6a967acc
                                // non_triv_mask: 0008004000000000
    Set_B369 set;
    explicit operator bool() const noexcept
    {
        return false
            || set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___NXVamzjzpP3
                                #define DEF___NXVamzjzpP3
inline static int _NXVa(/*3:3*/ int& count)
{
    return count++;
}
                                #endif

                                #ifndef DEF_each_WV5UZm3Vdt4
                                #define DEF_each_WV5UZm3Vdt4
inline void each_WV5U(/*7:7*/ fu::view<int> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _NXVa(count);

}
                                #endif

                                #ifndef DEF_each_nScAUYBQwH5
                                #define DEF_each_nScAUYBQwH5
inline void each_nScA(/*7:7*/ const Set_B369& set, /*7:6*/ int& count)
{
    each_WV5U(set.array, count);
}
                                #endif

int fu_MAIN()
{
    CountedSet_K0dh cs {};
    int count = 0;
    each_nScA(cs.set, count);
    return count;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

========

        pub struct SillyHash { int: int }
        pub fn SillyHash(str: string) = SillyHash(str.len)

        struct SetItem(type <Key>, type <Hash>) { hash: Hash; key: Key }
        pub struct Set(type <Key>, type <Hash> = SillyHash) { items: SetItem(:Hash, :Key)[] }

        fn if_ref <Hash, Key>(ref set: Set(:Hash, :Key), hash!: Hash, key: Key, visit, else?) {
            for (mut i = 0; i < set.items.len; i++) {
                ref item = set.items[i]
                if (item.hash == hash && item.key == key)
                    return visit(?: item)
            }

            return else()
        }

        pub inline fn get(ref set: Set(:<Hash>, :<Key>), key: Key) {
            return set.if_ref(:key, hash: Hash(key), visit: |item| item) || []
        }

        pub fn add <Hash>(ref set: Set(:Hash, :<Key>), key: Key) {
            let hash = Hash(key)
            set.if_ref(:key, :hash, visit: false): || {
                type Item = SetItem(:Key, :Hash)
                set.items ~= Item(:key, :hash)
                return true
            }
        }

        fn main() {
            mut set = _0::Set(string)
            if (!set.add("Hello!")) return 1
            return set.get("Hello!").hash.int - 6               // LocalConstBool
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Set_62oc;
struct SetItem_B1rV;
struct SillyHash_1p71;
SillyHash_1p71 SillyHash_MbR9(fu::view<char>);

                                #ifndef DEF_SillyHash_1p717IFYFQd
                                #define DEF_SillyHash_1p717IFYFQd
struct SillyHash_1p71
{
                                // shape_hash:    35632044f81b051a
                                // non_triv_mask: 0000000000000000
    int iNt;
    explicit operator bool() const noexcept
    {
        return false
            || iNt
        ;
    }
};
                                #endif

                                #ifndef DEF_Set_62ocyyaOtJ7
                                #define DEF_Set_62ocyyaOtJ7
struct Set_62oc
{
                                // shape_hash:    2eaa29137abd31a5
                                // non_triv_mask: 0800800040000800
    fu::vec<SetItem_B1rV> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_SetItem_B1rVDQU1Aug
                                #define DEF_SetItem_B1rVDQU1Aug
struct SetItem_B1rV
{
                                // shape_hash:    778dd45c7756b10c
                                // non_triv_mask: 0000800000000800
    SillyHash_1p71 hash;
    fu::str key;
    explicit operator bool() const noexcept
    {
        return false
            || hash
            || key
        ;
    }
};
                                #endif

                                #ifndef STR_YH7vqBEGuw9
                                #define STR_YH7vqBEGuw9
static const fu::str str_YH7vqBEGuw9 fu_INIT_PRIORITY(1002) { "Hello!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Set_eK5shScW3F9
                                #define DEF_Set_eK5shScW3F9
inline Set_62oc Set_eK5s()
{
    return Set_62oc{};
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_wQic1R7Og1e
                                #define DEF_x3Cx3E_wQic1R7Og1e
inline int x3Cx3E_wQic(/*3:3*/ const SillyHash_1p71& a, /*3:3*/ const SillyHash_1p71& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.iNt, b.iNt)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_VyMhGrpekE2
                                #define DEF_x3Dx3D_VyMhGrpekE2
inline bool operator==(/*3:3*/ const SillyHash_1p71& a, /*3:3*/ const SillyHash_1p71& b)
{
    return !x3Cx3E_wQic(a, b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_add_Ww8EMkaceSi
                                #define DEF_add_Ww8EMkaceSi
inline bool add_Ww8E(/*3:3*/ Set_62oc& set, /*3:3*/ fu::vec_range<char> key)
{
    const SillyHash_1p71 hash = SillyHash_MbR9(key);
    const bool visit = false;
    for (int i = 0; i < set.items.size(); i++)
    {
        const SetItem_B1rV& /*set|static*/ item = set.items[i];
        if ((item.hash == hash) && (item.key == key))
            return visit;

    };
    set.items += SetItem_B1rV { SillyHash_1p71(hash), fu::str(key) };
    return true;
}
                                #endif

                                #ifndef DEF_visit_N2nXnW7k0x4
                                #define DEF_visit_N2nXnW7k0x4
inline static const SetItem_B1rV& visit_N2nX(/*1:1*/ const SetItem_B1rV& item)
{
    return item;
}
                                #endif

                                #ifndef DEF_if_ref_N1tDhNVvwI6
                                #define DEF_if_ref_N1tDhNVvwI6
inline static const SetItem_B1rV& if_ref_N1tD(/*F1:F1*/ const Set_62oc& set, /*F1:F1*/ const SillyHash_1p71& hash, /*F1:F1*/ fu::view<char> key)
{
    for (int i = 0; i < set.items.size(); i++)
    {
        const SetItem_B1rV& /*set|static*/ item = set.items[i];
        if ((item.hash == hash) && (item.key == key))
            return visit_N2nX(item);

    };
    return (*(SetItem_B1rV*)fu::NIL);
}
                                #endif

int fu_MAIN()
{
    Set_62oc set = Set_eK5s();
    if (!add_Ww8E(set, str_YH7vqBEGuw9))
        return 1;
    else
    {
        fu::view<char> key {};
        const SetItem_B1rV* _0;
        return (key.ptr_reassign("Hello!"_view), (*(_0 = &(if_ref_N1tD(set, SillyHash_MbR9(key), key))) ? *_0 : (*(SetItem_B1rV*)fu::NIL))).hash.iNt - 6;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec
#include <fu/view.h>

struct SillyHash_1p71;

                                #ifndef DEF_SillyHash_1p717IFYFQd
                                #define DEF_SillyHash_1p717IFYFQd
struct SillyHash_1p71
{
                                // shape_hash:    35632044f81b051a
                                // non_triv_mask: 0000000000000000
    int iNt;
    explicit operator bool() const noexcept
    {
        return false
            || iNt
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

SillyHash_1p71 SillyHash_MbR9(/*1:1*/ fu::view<char> str)
{
    return SillyHash_1p71 { str.size() };
}

#endif

========

        fn main() {                                             // GNUStmtExpr
            mut hello: hash::Map(string, string);               // Goto
            hello.set("hello", "world!");
            let a = hello.get("hello").len - 6;
            hello.remove("hello");
            let b = hello.get("hello").len;
            hello.set("world", "world!!");
            let c = hello.get("world").len - 7;
            return a + b * 10 + c * 100;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----

========
//file hlprs.fu
        fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }
//file bs.fu
        struct BitSet { _data: u8[] }

        fn rem(using ref _: BitSet, idx: int) {
            let bucket  = idx >> 3;
            let mask    = 1 << u8(idx & 7);
            if (_data.len > bucket) {
                let item = _data[bucket];
                if (item & mask) {
                    _data[bucket] &= ~mask;
                    if (item == mask && _data.len == bucket + 1)
                        _shrink_to_fit();
                }
            }
        }

        fn add(using ref _: BitSet, idx: int) {
            _data.hlprs::grow_if_oob(idx >> 3) |= 1 << u8(idx & 7);
        }

        fn _shrink_to_fit(using ref _: BitSet) {
            mut end = _data.len;
            while (end --> 0) if (_data[end]) break;
            _data.shrink(end + 1);
        }

        fn main() {
            mut bs: bs::BitSet;
            bs.add(100);    let len0 = bs._data.len;
            bs.rem(100);    let len1 = bs._data.len;
            return len0 == 13 && len1 == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/vec.h>

struct BitSet_mmp7;
void add_MMRQ(BitSet_mmp7&, int);
void rem_MMRQ(BitSet_mmp7&, int);

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
                                // shape_hash:    6446e5a2f8d57a0b
                                // non_triv_mask: 0600000000000000
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    BitSet_mmp7 bs {};
    add_MMRQ(bs, 100);
    const int len0 = bs._data.size();
    rem_MMRQ(bs, 100);
    const int len1 = bs._data.size();
    if ((len0 == 13) && (len1 == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/vec_range.h>

struct BitSet_mmp7;

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
                                // shape_hash:    6446e5a2f8d57a0b
                                // non_triv_mask: 0600000000000000
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void _shrink_to_fit_MMRQ(/*1:1*/ BitSet_mmp7& _)
{
    int end = _._data.size();
    while (end-- > 0)
    {
        if (_._data[end])
            break;

    };
    _._data.shrink((end + 1));
}

void rem_MMRQ(/*3:3*/ BitSet_mmp7& _, const int idx)
{
    const int bucket = (idx >> 3);
    const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned((idx & 7)))));
    if (_._data.size() > bucket)
    {
        const fu::u8 /*_|static*/ item = _._data[bucket];
        if (item & mask)
        {
            _._data.mutref(bucket) &= fu::u8(~mask);
            if ((item == mask) && (_._data.size() == (bucket + 1)))
                _shrink_to_fit_MMRQ(_);

        };
    };
}

                                #ifndef DEF_grow_if_oob_IKJqkhWG7x7
                                #define DEF_grow_if_oob_IKJqkhWG7x7
inline fu::u8& grow_if_oob_IKJq(/*3:3*/ fu::vec_range_mut<fu::u8> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

void add_MMRQ(/*3:3*/ BitSet_mmp7& _, const int idx)
{
    grow_if_oob_IKJq(_._data, (idx >> 3)) |= fu::u8((fu::u8(1u) << fu::u8(unsigned((idx & 7)))));
}

#endif

// N_RelaxRespec

========

        struct Key   { ki: int };
        struct Value { vi: int };
        struct Data  { values: Value[] };

        noinline fn test(using ref _: Data) {
            fn push(v: Value) values ~= v;
            using fn EXT(k: Key) values[k.ki];
            push(Value(101));
            return Key(0).vi;
        }

        fn main() {
            mut data: Data;
            return data.test() - 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Data_MLKG;
struct Value_5LPO;
struct Key_tkqm;

                                #ifndef DEF_Value_5LPOjWxN2d3
                                #define DEF_Value_5LPOjWxN2d3
struct Value_5LPO
{
                                // shape_hash:    35ba78f94a1c4652
                                // non_triv_mask: 0000000000000000
    int vi;
    explicit operator bool() const noexcept
    {
        return false
            || vi
        ;
    }
};
                                #endif

                                #ifndef DEF_Data_MLKGIqJat3l
                                #define DEF_Data_MLKGIqJat3l
struct Data_MLKG
{
                                // shape_hash:    ab348fab0c18045f
                                // non_triv_mask: 0200000000000040
    fu::vec<Value_5LPO> values;
    explicit operator bool() const noexcept
    {
        return false
            || values
        ;
    }
};
                                #endif

                                #ifndef DEF_Key_tkqmxQRnYa1
                                #define DEF_Key_tkqmxQRnYa1
struct Key_tkqm
{
                                // shape_hash:    dfddc961c9095bd0
                                // non_triv_mask: 0000000000000000
    int ki;
    explicit operator bool() const noexcept
    {
        return false
            || ki
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<Value_5LPO> push_GL0m(/*3:3*/ const Value_5LPO& v, /*3:3*/ Data_MLKG& _)
{
    return (_.values += Value_5LPO(v));
}

static const Value_5LPO& EXT_kGbb(/*3:3*/ const Key_tkqm& k, /*3:3*/ const Data_MLKG& _)
{
    return _.values[k.ki];
}

static int test_kGbb(/*1:1*/ Data_MLKG& _)
{
    push_GL0m(Value_5LPO { 101 }, _);
    return EXT_kGbb(Key_tkqm { 0 }, _).vi;
}

int fu_MAIN()
{
    Data_MLKG data {};
    return test_kGbb(data) - 101;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Helpers      { index: int };
        struct HelpersData  { target: Target };
        struct Target       { globid: int };
        struct Overload     { name: string };

        noinline fn test(_overloads: Overload[], _helpers: Helpers[], _data: HelpersData[], t: Target)
        {
            using fn H(h: Helpers): HelpersData {
                h.index >= 0 && h.index < _data.len || throw("A");
                return _data[h.index];
            }

            fn fail_appendStack(mut r: string) {
                for (mut i = _helpers.len; i --> 0; ) r ~= O(_helpers[i].target);
                return r;
            }

            fn fail(r: string) {
                r || fail("B");
                return throw(r.fail_appendStack());
            }

            fn str(o: Overload) = o.name;

            using fn O(target: Target) {
                let globid = target.globid;
                globid > 0 && _overloads.len >= globid || fail("C");
                return _overloads[target.globid - 1];
            }

            return t.name;
        }

        fn main() = test([ Overload("Hello") ], [], [], Target(1)) == "Hello" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>

struct Overload_BK87;
struct Helpers_DyqV;
struct HelpersData_BxqP;
struct Target_9DUs;
static const Overload_BK87& O_MbR9(const Target_9DUs&, fu::view<Overload_BK87>, fu::view<Helpers_DyqV>, fu::view<HelpersData_BxqP>);
[[noreturn]] static fu::never fail_MbR9(fu::vec_range<char>, fu::view<Overload_BK87>, fu::view<Helpers_DyqV>, fu::view<HelpersData_BxqP>);

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
                                // shape_hash:    340726173a03831e
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

                                #ifndef DEF_HelpersData_BxqP2o4bFd0
                                #define DEF_HelpersData_BxqP2o4bFd0
struct HelpersData_BxqP
{
                                // shape_hash:    39d2ef8c30821920
                                // non_triv_mask: 0000000000000000
    Target_9DUs target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef STR_xokhB3CTy1i
                                #define STR_xokhB3CTy1i
static const fu::str str_xokhB3CTy1i fu_INIT_PRIORITY(1001) { "C"_fu };
                                #endif

                                #ifndef STR_OtMUG5RNx3f
                                #define STR_OtMUG5RNx3f
static const fu::str str_OtMUG5RNx3f fu_INIT_PRIORITY(1001) { "B"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const HelpersData_BxqP& H_MbR9(/*3:3*/ const Helpers_DyqV& h, /*3:3*/ fu::view<HelpersData_BxqP> _data)
{
    if ((h.index >= 0) && (h.index < _data.size()))
        return _data[h.index];
    else
        fu::fail(fu::str("A"_fu));

}

static fu::view<char> str_kGbb(/*1:1*/ const Overload_BK87& o)
{
    return o.name;
}

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_appendStack_MbR9(/*MOV*/ fu::str&& r, /*F:F*/ fu::view<Overload_BK87> _overloads, /*F:F*/ fu::view<Helpers_DyqV> _helpers, /*F:F*/ fu::view<HelpersData_BxqP> _data)
{
    for (int i = _helpers.size(); i-- > 0; )
        x7Ex3D_w1za(r, str_kGbb(O_MbR9(H_MbR9(_helpers[i], _data).target, _overloads, _helpers, _data)));

    return r.destructive_move();
}

[[noreturn]] static fu::never fail_MbR9(/*F:F*/ fu::vec_range<char> r, /*F:F*/ fu::view<Overload_BK87> _overloads, /*F:F*/ fu::view<Helpers_DyqV> _helpers, /*F:F*/ fu::view<HelpersData_BxqP> _data)
{
    if (r)
        fu::fail(fail_appendStack_MbR9(fu::str(r), _overloads, _helpers, _data));
    else
        fail_MbR9(str_OtMUG5RNx3f, _overloads, _helpers, _data);

}

static const Overload_BK87& O_MbR9(/*F:F*/ const Target_9DUs& target, /*F:F*/ fu::view<Overload_BK87> _overloads, /*F:F*/ fu::view<Helpers_DyqV> _helpers, /*F:F*/ fu::view<HelpersData_BxqP> _data)
{
    const int /*target*/ globid = target.globid;
    if ((globid > 0) && (_overloads.size() >= globid))
        return _overloads[(target.globid - 1)];
    else
        fail_MbR9(str_xokhB3CTy1i, _overloads, _helpers, _data);

}

static const fu::str& test_MbR9(/*F:F*/ fu::view<Overload_BK87> _overloads, /*F:F*/ fu::view<Helpers_DyqV> _helpers, /*F:F*/ fu::view<HelpersData_BxqP> _data, /*F:F*/ const Target_9DUs& t)
{
    return O_MbR9(t, _overloads, _helpers, _data).name;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (test_MbR9(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("Hello"_fu) } }}, fu::view<Helpers_DyqV>{}, fu::view<HelpersData_BxqP>{}, Target_9DUs { 1 }) == "Hello"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct ConvCacheEntry   { types: int[] }
        struct Set(type T)      { keys_asc!: T[] };

        fn append(using ref _: Set($T), v: int) keys_asc ~= v;

        struct SolverState {    
            _output?: Set(int); 
            _input?: int[];     
        }

        fn ConvCache_fieldItemsOrder_glitch(using ref ss: SolverState) {
            fn append(v: int) _output.append(v);
            _input.each: |v| append(v);
        }

        fn main() {
            mut ss = SolverState(_input: [ 1, 2, 3 ]);
            ss.ConvCache_fieldItemsOrder_glitch();
            return ss._output.keys_asc.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolverState_Bk4V;
struct Set_qOJY;

                                #ifndef DEF_Set_qOJYtbQKZe4
                                #define DEF_Set_qOJYtbQKZe4
struct Set_qOJY
{
                                // shape_hash:    a7d5a11026f58613
                                // non_triv_mask: 0008000000000040
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_Bk4VdE0gbj0
                                #define DEF_SolverState_Bk4VdE0gbj0
struct SolverState_Bk4V
{
                                // shape_hash:    51b547579e18a930
                                // non_triv_mask: 0008020000000040
    Set_qOJY _output;
    fu::vec<int> _input;
    explicit operator bool() const noexcept
    {
        return false
            || _output
            || _input
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_append_N5DV6uNN8me
                                #define DEF_append_N5DV6uNN8me
inline static fu::view<int> append_N5DV(/*3:3*/ Set_qOJY& _, const int v)
{
    return (_.keys_asc += v);
}
                                #endif

static fu::view<int> append_kGbb(const int v, /*3:3*/ SolverState_Bk4V& ss)
{
    return append_N5DV(ss._output, v);
}

                                #ifndef DEF___07bvVMxa5Bf
                                #define DEF___07bvVMxa5Bf
inline static fu::view<int> _07bv(const int v, /*3:3*/ SolverState_Bk4V& ss)
{
    return append_kGbb(v, ss);
}
                                #endif

                                #ifndef DEF_each_lDvFCHg1O53
                                #define DEF_each_lDvFCHg1O53
inline void each_lDvF(/*7:7*/ fu::view<int> a, /*7:6*/ SolverState_Bk4V& ss)
{
    for (int i = 0; i < a.size(); i++)
        _07bv(a[i], ss);

}
                                #endif

static void ConvCache_fieldItemsOrder_glitch_MbR9(/*1:1*/ SolverState_Bk4V& ss)
{
    each_lDvF(ss._input, ss);
}

int fu_MAIN()
{
    SolverState_Bk4V ss = SolverState_Bk4V { Set_qOJY{}, fu::vec<int> {{ 1, 2, 3 }} };
    ConvCache_fieldItemsOrder_glitch_MbR9(ss);
    return ss._output.keys_asc.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct ConvCacheEntry   { types: int[] }
        struct Set(type T)      { keys_asc!: T[] };

        fn append(using ref _: Set($T), v: int) keys_asc ~= v;

        struct SolverState {    
            _input?: int[];     
            _output?: Set(int); 
        }

        fn ConvCache_fieldItemsOrder_glitch(using ref ss: SolverState) {
            fn append(v: int) _output.append(v);
            _input.each: |v| append(v);
        }

        fn main() {
            mut ss = SolverState(_input: [ 1, 2, 3 ]);
            ss.ConvCache_fieldItemsOrder_glitch();
            return ss._output.keys_asc.len - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct SolverState_FA3w;
struct Set_qOJY;

                                #ifndef DEF_Set_qOJYtbQKZe4
                                #define DEF_Set_qOJYtbQKZe4
struct Set_qOJY
{
                                // shape_hash:    a7d5a11026f58613
                                // non_triv_mask: 0008000000000040
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_SolverState_FA3wSiN0dn8
                                #define DEF_SolverState_FA3wSiN0dn8
struct SolverState_FA3w
{
                                // shape_hash:    d49ef8d45909a816
                                // non_triv_mask: 000a000000000040
    fu::vec<int> _input;
    Set_qOJY _output;
    explicit operator bool() const noexcept
    {
        return false
            || _input
            || _output
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_append_N5DV6uNN8me
                                #define DEF_append_N5DV6uNN8me
inline static fu::view<int> append_N5DV(/*3:3*/ Set_qOJY& _, const int v)
{
    return (_.keys_asc += v);
}
                                #endif

static fu::view<int> append_kGbb(const int v, /*3:3*/ SolverState_FA3w& ss)
{
    return append_N5DV(ss._output, v);
}

                                #ifndef DEF___0rM7tq3Ci2c
                                #define DEF___0rM7tq3Ci2c
inline static fu::view<int> _0rM7(const int v, /*3:3*/ SolverState_FA3w& ss)
{
    return append_kGbb(v, ss);
}
                                #endif

                                #ifndef DEF_each_gIGQApz0H2b
                                #define DEF_each_gIGQApz0H2b
inline void each_gIGQ(/*7:7*/ fu::view<int> a, /*7:6*/ SolverState_FA3w& ss)
{
    for (int i = 0; i < a.size(); i++)
        _0rM7(a[i], ss);

}
                                #endif

static void ConvCache_fieldItemsOrder_glitch_MbR9(/*1:1*/ SolverState_FA3w& ss)
{
    each_gIGQ(ss._input, ss);
}

int fu_MAIN()
{
    SolverState_FA3w ss = SolverState_FA3w { fu::vec<int> {{ 1, 2, 3 }}, Set_qOJY{} };
    ConvCache_fieldItemsOrder_glitch_MbR9(ss);
    return ss._output.keys_asc.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct A { x: int };
        struct B { using a: A };
        struct C { using a: A };

        fn main() {
            using mut b = B(A(1));

            using 
            mut c = C(A(2));

            x *= 10;
            return b.x == 10 && c.x == 2 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 12:13+1[0m:

[2m      |             mut c = C(A(2));[0m
[2m      | [0m
[2m   12 | [0m            [31;1mx[0m *= 10;
[2m      |             return b.x == 10 && c.x == 2 ? 0 : 1;[0m
[2m      |         }[0m

	[31;1musing[0m ambiguity, multiple ways to obtain a [35;3mnocopy[0m [35;3mstruct[0m [94;1mA[0m in this scope:

	    [35;3musing[0m [35;3mmut[0m [94;1mb[0m at [2m7:13+5[0m [2m7:23+1[0m:
[2m    7 | [0m            [31;1musing[0m mut [31;1mb[0m = B(A(1));
	    [35;3musing[0m [35;3mfield[0m [94;1mB[0m:[94;1ma[0m at [2m3:20+5[0m [2m3:26+1[0m:
[2m    3 | [0m        struct B { [31;1musing[0m [31;1ma[0m: A };

	and:

	    [35;3musing[0m [35;3mmut[0m [94;1mc[0m at [2m9:13+5[0m [2m10:17+1[0m:
[2m    9 | [0m            [31;1musing[0m 
[2m   10 | [0m            mut [31;1mc[0m = C(A(2));
	    [35;3musing[0m [35;3mfield[0m [94;1mC[0m:[94;1ma[0m at [2m4:20+5[0m [2m4:26+1[0m:
[2m    4 | [0m        struct C { [31;1musing[0m [31;1ma[0m: A };


        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        struct A { x: int };
        struct B { using a: A };
        struct C { using a: A };

        fn main() {
            using mut b = B(A(1));

            mut c = C(A(2));

            x *= 10;
            return b.x == 10 && c.x == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct B_BRmm;
struct A_6j1Y;
struct C_uJl0;

                                #ifndef DEF_A_6j1YaFZsIFe
                                #define DEF_A_6j1YaFZsIFe
struct A_6j1Y
{
                                // shape_hash:    48845602b2367eaa
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_B_BRmmi0hYLL8
                                #define DEF_B_BRmmi0hYLL8
struct B_BRmm
{
                                // shape_hash:    3017c24659ce7266
                                // non_triv_mask: 0000000000000000
    A_6j1Y a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_C_uJl0hFG6SR1
                                #define DEF_C_uJl0hFG6SR1
struct C_uJl0
{
                                // shape_hash:    8c541dd4c26b4c51
                                // non_triv_mask: 0000000000000000
    A_6j1Y a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    B_BRmm b = B_BRmm { A_6j1Y { 1 } };
    const C_uJl0 c = C_uJl0 { A_6j1Y { 2 } };
    b.a.x *= 10;
    if ((b.a.x == 10) && (c.a.x == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Target { id: string }
        struct ScopeItem { name: string }
        fn zeroes() = [];

        import _0;
        fn throwIfEmpty_else_returnEmptyStr(what: string) {
            using inline fn GET(lax h: Target): ScopeItem = zeroes();

            fn throwIfEmpty(id: string) {
                let t = Target(:id);
                return t.AlwaysTrue.name;
            }

            fn AlwaysTrue(target) target || throw(target.id);
            return throwIfEmpty(what);
        }

        fn main() {
            try         return throwIfEmpty_else_returnEmptyStr("Not empty!").len;
            catch (e)   return 1000 + e.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Target_chal;
struct ScopeItem_NODF;

                                #ifndef DEF_Target_chaloL37q50
                                #define DEF_Target_chaloL37q50
struct Target_chal
{
                                // shape_hash:    a8da36e2739b4010
                                // non_triv_mask: 0040800000000000
    fu::str id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_NODFpufeBG4
                                #define DEF_ScopeItem_NODFpufeBG4
struct ScopeItem_NODF
{
                                // shape_hash:    13b26bc4886f7963
                                // non_triv_mask: 0000800000002000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef STR_xQ1OhaM4U89
                                #define STR_xQ1OhaM4U89
static const fu::str str_xQ1OhaM4U89 fu_INIT_PRIORITY(1002) { "Not empty!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_AlwaysTrue_bvwtsT0Phwc
                                #define DEF_AlwaysTrue_bvwtsT0Phwc
inline static const Target_chal& AlwaysTrue_bvwt(/*1:1*/ const Target_chal& target)
{
    return target ? target : fu::fail(fu::str(target.id));
}
                                #endif

static fu::str throwIfEmpty_LtD7(/*1:1*/ fu::vec_range<char> id)
{
    Target_chal t = Target_chal { fu::str(id) };
    return (AlwaysTrue_bvwt(t), ScopeItem_NODF{}).name;
}

static fu::str throwIfEmpty_else_returnEmptyStr_LtD7(/*1:1*/ fu::vec_range<char> what)
{
    return throwIfEmpty_LtD7(what);
}

int fu_MAIN()
{

    try
    {
        return throwIfEmpty_else_returnEmptyStr_LtD7(str_xQ1OhaM4U89).size();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return 1000 + e.size();
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedLet

#ifndef fu_NO_fdefs

void zeroes_MbR9()
{
    return;
}

#endif

========

        struct Target { id: string }
        struct ScopeItem { name: string }
        fn zeroes() = [];

        import _0;
        fn throwIfEmpty_else_returnEmptyStr(what: string) {
            using inline fn GET(lax h: Target): ScopeItem = [];

            fn throwIfEmpty(id: string) {
                let t = Target(:id);
                return t.AlwaysTrue.name;
            }

            fn AlwaysTrue(target) target || throw(target.id);
            return throwIfEmpty(what);
        }

        fn main() {
            try         return throwIfEmpty_else_returnEmptyStr("Not empty!").len;
            catch (e)   return 1000 + e.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Target_chal;
struct ScopeItem_NODF;

                                #ifndef DEF_Target_chaloL37q50
                                #define DEF_Target_chaloL37q50
struct Target_chal
{
                                // shape_hash:    a8da36e2739b4010
                                // non_triv_mask: 0040800000000000
    fu::str id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_ScopeItem_NODFpufeBG4
                                #define DEF_ScopeItem_NODFpufeBG4
struct ScopeItem_NODF
{
                                // shape_hash:    13b26bc4886f7963
                                // non_triv_mask: 0000800000002000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef STR_xQ1OhaM4U89
                                #define STR_xQ1OhaM4U89
static const fu::str str_xQ1OhaM4U89 fu_INIT_PRIORITY(1002) { "Not empty!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_AlwaysTrue_bvwtsT0Phwc
                                #define DEF_AlwaysTrue_bvwtsT0Phwc
inline static const Target_chal& AlwaysTrue_bvwt(/*1:1*/ const Target_chal& target)
{
    return target ? target : fu::fail(fu::str(target.id));
}
                                #endif

static fu::str throwIfEmpty_LtD7(/*1:1*/ fu::vec_range<char> id)
{
    Target_chal t = Target_chal { fu::str(id) };
    return (AlwaysTrue_bvwt(t), ScopeItem_NODF{}).name;
}

static fu::str throwIfEmpty_else_returnEmptyStr_LtD7(/*1:1*/ fu::vec_range<char> what)
{
    return throwIfEmpty_LtD7(what);
}

int fu_MAIN()
{

    try
    {
        return throwIfEmpty_else_returnEmptyStr_LtD7(str_xQ1OhaM4U89).size();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return 1000 + e.size();
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

#ifndef fu_NO_fdefs

void zeroes_MbR9()
{
    return;
}

#endif

========

        struct ValueType { canon: string };
        struct Type { using vtype: ValueType };

        fn ternary_mutrefExact_vs_constUsingField(left: Type, ref right: ValueType[])
            !right ? left : right[0];

        fn main() {
            mut right: ValueType[];
            let a = ternary_mutrefExact_vs_constUsingField(Type(ValueType("Hello, ")), :right);
            right ~= ValueType("World!");
            let b = ternary_mutrefExact_vs_constUsingField(Type(), :right);
            return a.canon ~ b.canon == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct ValueType_hH51;
struct Type_AXDc;

                                #ifndef DEF_ValueType_hH51NAepHPd
                                #define DEF_ValueType_hH51NAepHPd
struct ValueType_hH51
{
                                // shape_hash:    71fb183be45b121a
                                // non_triv_mask: 0000880000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_AXDcuww82Q2
                                #define DEF_Type_AXDcuww82Q2
struct Type_AXDc
{
                                // shape_hash:    a8fa2f82b5812112
                                // non_triv_mask: 0040880000000000
    ValueType_hH51 vtype;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const ValueType_hH51& ternary_mutrefExact_vs_constUsingField_MbR9(/*3:3*/ const Type_AXDc& left, /*3:3*/ fu::view<ValueType_hH51> right)
{
    if (!right)
        return left.vtype;
    else
        return right[0];

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<ValueType_hH51> right {};
    ValueType_hH51 a = ternary_mutrefExact_vs_constUsingField_MbR9(Type_AXDc { ValueType_hH51 { fu::str("Hello, "_fu) } }, right);
    right += ValueType_hH51 { fu::str("World!"_fu) };
    ValueType_hH51 b = ternary_mutrefExact_vs_constUsingField_MbR9(Type_AXDc{}, right);
    if ((a.canon + b.canon) == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct ValueType { canon: string };
        struct Type { using vtype: ValueType };
        pub import _0;
        fn ternary_mutrefExact_vs_constUsingField(left: Type, ref right: ValueType[])
            !right ? left : right[0];

        fn main() {
            mut right: ValueType[];
            let a = ternary_mutrefExact_vs_constUsingField(Type(ValueType("Hello, ")), :right);
            right ~= ValueType("World!");
            let b = ternary_mutrefExact_vs_constUsingField(Type(), :right);
            return a.canon ~ b.canon == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct ValueType_hH51;
struct Type_AXDc;

                                #ifndef DEF_ValueType_hH51NAepHPd
                                #define DEF_ValueType_hH51NAepHPd
struct ValueType_hH51
{
                                // shape_hash:    71fb183be45b121a
                                // non_triv_mask: 0000880000000000
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_Type_AXDcuww82Q2
                                #define DEF_Type_AXDcuww82Q2
struct Type_AXDc
{
                                // shape_hash:    a8fa2f82b5812112
                                // non_triv_mask: 0040880000000000
    ValueType_hH51 vtype;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const ValueType_hH51& ternary_mutrefExact_vs_constUsingField_LtD7(/*3:3*/ const Type_AXDc& left, /*3:3*/ fu::view<ValueType_hH51> right)
{
    if (!right)
        return left.vtype;
    else
        return right[0];

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<ValueType_hH51> right {};
    ValueType_hH51 a = ternary_mutrefExact_vs_constUsingField_LtD7(Type_AXDc { ValueType_hH51 { fu::str("Hello, "_fu) } }, right);
    right += ValueType_hH51 { fu::str("World!"_fu) };
    ValueType_hH51 b = ternary_mutrefExact_vs_constUsingField_LtD7(Type_AXDc{}, right);
    if ((a.canon + b.canon) == "Hello, World!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct A { a: int };
        struct B { b: int };

        fn conversionToZeroesOrNever(what: A) {
            using fn intoB(a: A)    
                [];                 

            return what && what.b;
        }

        fn main() conversionToZeroesOrNever(A(3)) == 6 ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 6:13+5[0m:

[2m      | [0m
[2m      |         fn conversionToZeroesOrNever(what: A) {[0m
[2m    6 | [0m            [31;1musing[0m fn intoB(a: A)    
[2m      |                 [];                 [0m
[2m      | [0m

	[35;3mfn[0m [94;1mintoB[0m returns type [35;3m[][0m.

	This would make the conversion function ambiguous because it assigns to anything.

        Solving [35;3mfn[0m [94;1mconversionToZeroesOrNever[0m([94;1mA[0m) at [2m5:12+25[0m

========

        struct A { a: int };
        struct B { b: int };

        fn conversionToZeroesOrNever(what: A) {
            using fn intoB(a: A)    
                B(a.a * 2);         

            return what && what.b;
        }

        fn main() conversionToZeroesOrNever(A(3)) == 6 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static B_UWB4 intoB_MbR9(/*1:1*/ const A_EqO7& a)
{
    return B_UWB4 { (a.a * 2) };
}

static int conversionToZeroesOrNever_MbR9(/*1:1*/ const A_EqO7& what)
{
    if (what)
        return intoB_MbR9(what).b;
    else
        return 0;

}

int fu_MAIN()
{
    if (conversionToZeroesOrNever_MbR9(A_EqO7 { 3 }) == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut hello = 0;
            using fn what() ++hello;
            fn add(x: int, y: int) x + y;
            return add(-1);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int what_kGbb(/*1:1*/ int& hello)
{
    return ++hello;
}

static int add_MbR9(const int x, const int y)
{
    return x + y;
}

int fu_MAIN()
{
    int hello = 0;
    return add_MbR9(what_kGbb(hello), -1);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        using fn what(implicit ref hello: int) ++hello;
        fn main() {
            implicit mut hello = 0;
            fn add(x: int, y: int) x + y;
            return add(-1);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int what_kGbb(/*1:1*/ int& hello)
{
    return ++hello;
}

static int add_MbR9(const int x, const int y)
{
    return x + y;
}

int fu_MAIN()
{
    int hello = 0;
    return add_MbR9(what_kGbb(hello), -1);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        using fn what(implicit ref a: i32) ++a;
        using fn woot(implicit ref b: u32) ++b;
        fn main() {
            implicit mut a: i32 = 10;
            implicit mut b: u32 = 201;
            fn add(x: i32, y: i32) x + y;
            fn add(x: u32, y: u32) x + y;
            return add(1)
                 + add(1.u32).i32 - 215;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:20+3[0m:

[2m      |             fn add(x: i32, y: i32) x + y;[0m
[2m      |             fn add(x: u32, y: u32) x + y;[0m
[2m    9 | [0m            return [31;1madd[0m(1)
[2m      |                  + add(1.u32).i32 - 215;[0m
[2m      |         }[0m

	Ambiguous call to [94;1madd[0m with args ([35;3mi32[0m), matches multiple items in scope:

	[35;3mfn[0m [94;1madd[0m at [2m8:16+3[0m:
[2m    8 | [0m            fn [31;1madd[0m(x: u32, y: u32) x + y;

	    [35;3marg[0m [94;1madd[0m:[94;1mx[0m: [35;3musing[0m [35;3mfn[0m [94;1mwoot[0m at [2m3:9+5[0m [2m3:18+4[0m:
[2m    3 | [0m        [31;1musing[0m fn [31;1mwoot[0m(implicit ref b: u32) ++b;

	[35;3mfn[0m [94;1madd[0m at [2m7:16+3[0m:
[2m    7 | [0m            fn [31;1madd[0m(x: i32, y: i32) x + y;

	    [35;3marg[0m [94;1madd[0m:[94;1mx[0m: [35;3musing[0m [35;3mfn[0m [94;1mwhat[0m at [2m2:9+5[0m [2m2:18+4[0m:
[2m    2 | [0m        [31;1musing[0m fn [31;1mwhat[0m(implicit ref a: i32) ++a;


        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        using fn what(implicit ref a: i32) ++a;
        using fn woot(implicit ref b: u32) ++b;
        fn main() {
            implicit mut a: i32 = 10;
            implicit mut b: u32 = 201;
            fn add(x: i32, y: i32) x + y;
            fn add(x: u32, y: u32) x + y;
            return add(1)
                 + add(1.u32).i32 - 215;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:20+3[0m:

[2m      |             fn add(x: i32, y: i32) x + y;[0m
[2m      |             fn add(x: u32, y: u32) x + y;[0m
[2m    9 | [0m            return [31;1madd[0m(1)
[2m      |                  + add(1.u32).i32 - 215;[0m
[2m      |         }[0m

	Ambiguous call to [94;1madd[0m with args ([35;3malways-true[0m [35;3mi32[0m), matches multiple items in scope:

	[35;3mfn[0m [94;1madd[0m at [2m8:16+3[0m:
[2m    8 | [0m            fn [31;1madd[0m(x: u32, y: u32) x + y;

	    [35;3marg[0m [94;1madd[0m:[94;1mx[0m: [35;3musing[0m [35;3mfn[0m [94;1mwoot[0m at [2m3:9+5[0m [2m3:18+4[0m:
[2m    3 | [0m        [31;1musing[0m fn [31;1mwoot[0m(implicit ref b: u32) ++b;

	[35;3mfn[0m [94;1madd[0m at [2m7:16+3[0m:
[2m    7 | [0m            fn [31;1madd[0m(x: i32, y: i32) x + y;

	    [35;3marg[0m [94;1madd[0m:[94;1mx[0m: [35;3musing[0m [35;3mfn[0m [94;1mwhat[0m at [2m2:9+5[0m [2m2:18+4[0m:
[2m    2 | [0m        [31;1musing[0m fn [31;1mwhat[0m(implicit ref a: i32) ++a;


        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        using fn what(implicit ref a: i32) ++a;
        using fn woot(implicit ref b: u32) ++b;
        fn main() {
            implicit mut a: i32 = 10;
            implicit mut b: u32 = 201;
            fn add(x: i32, y: i32) x + y;
            fn add(x: u32, y: u32) x + y;
            return add(1.i32)
                 + add(1.u32).i32 - 215;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int what_kGbb(/*1:1*/ int& a)
{
    return ++a;
}

static int add_MbR9(const int x, const int y)
{
    return x + y;
}

static unsigned woot_kGbb(/*1:1*/ unsigned& b)
{
    return ++b;
}

static unsigned add_kGbb(const unsigned x, const unsigned y)
{
    return x + y;
}

int fu_MAIN()
{
    int a = 10;
    unsigned b = 201u;
    return (add_MbR9(what_kGbb(a), int(1)) + int(add_kGbb(woot_kGbb(b), unsigned(1)))) - 215;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct V { v: int };
        fn main() {
            using V();
            return v;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct V_XHsD;

                                #ifndef DEF_V_XHsDY6p70C8
                                #define DEF_V_XHsDY6p70C8
struct V_XHsD
{
                                // shape_hash:    d94d6041ad6f1546
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const V_XHsD _ {};
    return _.v;
}

#endif

int main() { return fu_MAIN(); }

========

        struct vec2     { x: f32; y: f32 };
        struct Player   { position: vec2 };

        fn move(ref player: Player, dist: vec2) {
            using player.position;
            x += dist.x;
            y += dist.y;
        }

        fn main() {
            mut p: Player;
            p.move(vec2(10, 10));
            assert(p.position.x * p.position.y == 100);
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/assert.h>

struct Player_EMcr;
struct vec2_ahM2;

                                #ifndef DEF_vec2_ahM2j5Y44Ua
                                #define DEF_vec2_ahM2j5Y44Ua
struct vec2_ahM2
{
                                // shape_hash:    860b7c05f5c420f7
                                // non_triv_mask: 0000000000000000
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_Player_EMcrkDUQul1
                                #define DEF_Player_EMcrkDUQul1
struct Player_EMcr
{
                                // shape_hash:    084c8cd714fafaf0
                                // non_triv_mask: 0000000000000000
    vec2_ahM2 position;
    explicit operator bool() const noexcept
    {
        return false
            || position
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void move_MbR9(/*1:1*/ Player_EMcr& player, /*3:3*/ const vec2_ahM2& dist)
{
    vec2_ahM2& /*player*/ _ = player.position;
    _.x += dist.x;
    _.y += dist.y;
}

int fu_MAIN()
{
    Player_EMcr p {};
    move_MbR9(p, vec2_ahM2 { 10.0f, 10.0f });
    fu_ASSERT(((p.position.x * p.position.y) == 100.0f));
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn segfault_tryRetypingEmptyBlock(a: int)
            = a & 1 ? a         
                    : {};       
        fn main() 0.segfault_tryRetypingEmptyBlock;

---- <fail> ----
[2m[0m_0[2m.fu 3:21+1[0m:

[2m      | [0m
[2m      |         fn segfault_tryRetypingEmptyBlock(a: int)[0m
[2m    3 | [0m            = a & 1 [31;1m?[0m a         
[2m      |                     : {};       [0m
[2m      |         fn main() 0.segfault_tryRetypingEmptyBlock;[0m

	if/else: No common supertype: [35;3mi32[0m <-> [35;3mnocopy[0m [35;3mvoid[0m

        Solving [35;3mfn[0m [94;1msegfault_tryRetypingEmptyBlock[0m([35;3mi32[0m) at [2m2:12+30[0m

========

        fn segfault_tryRetypingEmptyBlock(a: int)
            = a & 1 ? a         
                    : [];       
        fn main() 0.segfault_tryRetypingEmptyBlock;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int segfault_tryRetypingEmptyBlock_MbR9(/*1:1*/ const int a)
{
    if (a & 1)
        return a;
    else
        return 0;

}

int fu_MAIN()
{
    return segfault_tryRetypingEmptyBlock_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn varargs(a[]) a[0] + a[1];
        fn main() varargs(1, 2) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_varargs_etNkqGjaUi1
                                #define DEF_varargs_etNkqGjaUi1
inline static int varargs_etNk(/*1:1*/ fu::view<int> a)
{
    return a[0] + a[1];
}
                                #endif

int fu_MAIN()
{
    return varargs_etNk(fu::view<int> {{ 1, 2 }}) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;


        fn inspect(.to_debug_str[] items) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int to_debug_str_MbR9(const int a)
{
    return a * 2;
}

static int to_debug_str_kGbb(const unsigned b)
{
    return int(b) * 3;
}

                                #ifndef DEF_inspect_IgOngDZgN9h
                                #define DEF_inspect_IgOngDZgN9h
inline static int inspect_IgOn(/*1:1*/ fu::view<int> items)
{
    int a = 0;
    for (int i = 0; i < items.size(); i++)
        a += items[i];

    return a;
}
                                #endif

int fu_MAIN()
{
    return inspect_IgOn(fu::view<int> {{ to_debug_str_MbR9(int(5)), to_debug_str_kGbb(unsigned(7)) }}) - 31;
}

#endif

int main() { return fu_MAIN(); }

========

        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;


        inline                                                  // GNUStmtExpr

        fn inspect(.to_debug_str[] items) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int to_debug_str_MbR9(const int a)
{
    return a * 2;
}

static int to_debug_str_kGbb(const unsigned b)
{
    return int(b) * 3;
}

int fu_MAIN()
{
    int a;
    int BL_1_v;
    return (__extension__ (
    {
        fu::vec<int> items = fu::vec<int> {{ to_debug_str_MbR9(int(5)), to_debug_str_kGbb(unsigned(7)) }};
        a = 0;
        for (int i = 0; i < items.size(); i++)
            a += items[i];

        BL_1_v = (a);
        (void)0;
    }), BL_1_v) - 31;
}

#endif

int main() { return fu_MAIN(); }

========

        fn va(args[]: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < args.len; i++) sum += args[i];
            return sum;
        }

        fn main() va(1, 2) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int va_MbR9(/*1:1*/ fu::view<int> args)
{
    int sum = 0;
    for (int i = 0; i < args.size(); i++)
        sum += args[i];

    return sum;
}

int fu_MAIN()
{
    return va_MbR9(fu::view<int> {{ 1, 2 }}) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // ConstCast
        inline fn Printy(x.Stringy): string = x;                // PointlessLocal

        fn Println(parts.Printy[]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_y3ibvcul0Fi
                                #define STR_y3ibvcul0Fi
static const fu::str str_y3ibvcul0Fi fu_INIT_PRIORITY(1001) { "str"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_MbR9(const int i)
{
    return x7E_rA00("i:"_view, fu::i64dec(i));
}

                                #ifndef DEF_Println_k4dgDFEg0li
                                #define DEF_Println_k4dgDFEg0li
inline static int Println_k4dg(/*1:1*/ fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}
                                #endif

int fu_MAIN()
{
    fu::vec_range<char> x {};
    fu::str x_1 {};
    return Println_k4dg(fu::view<fu::str> {{ fu::str((x.ptr_reassign(str_y3ibvcul0Fi), x)), (x_1 = Stringy_MbR9(10), x_1).const_cast_mut().destructive_move() }}) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // ConstCast
        inline fn Printy(x.Stringy): string = x;                // PointlessLocal

        fn Println(parts.Printy[]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_y3ibvcul0Fi
                                #define STR_y3ibvcul0Fi
static const fu::str str_y3ibvcul0Fi fu_INIT_PRIORITY(1001) { "str"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_MbR9(const int i)
{
    return x7E_rA00("i:"_view, fu::i64dec(i));
}

                                #ifndef DEF_Println_k4dgDFEg0li
                                #define DEF_Println_k4dgDFEg0li
inline static int Println_k4dg(/*1:1*/ fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}
                                #endif

int fu_MAIN()
{
    const fu::str* x;
    fu::str x_1 {};
    return Println_k4dg(fu::view<fu::str> {{ fu::str((x = &(str_y3ibvcul0Fi), (*x))), (x_1 = Stringy_MbR9(10), x_1).const_cast_mut().destructive_move() }}) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // ConstCast
        inline fn Printy(x.Stringy): string = x;                // PointlessLocal

        fn Println(parts.Printy[]: string[..]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_y3ibvcul0Fi
                                #define STR_y3ibvcul0Fi
static const fu::str str_y3ibvcul0Fi fu_INIT_PRIORITY(1001) { "str"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_MbR9(const int i)
{
    return x7E_rA00("i:"_view, fu::i64dec(i));
}

static int Println_MbR9(/*1:1*/ fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}

int fu_MAIN()
{
    fu::vec_range<char> x {};
    fu::str x_1 {};
    return Println_MbR9(fu::view<fu::str> {{ fu::str((x.ptr_reassign(str_y3ibvcul0Fi), x)), (x_1 = Stringy_MbR9(10), x_1).const_cast_mut().destructive_move() }}) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // ConstCast
        inline fn Printy(x.Stringy): string = x;                // PointlessLocal

        fn Println(parts.Printy[]: string[..]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_y3ibvcul0Fi
                                #define STR_y3ibvcul0Fi
static const fu::str str_y3ibvcul0Fi fu_INIT_PRIORITY(1001) { "str"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_MbR9(const int i)
{
    return x7E_rA00("i:"_view, fu::i64dec(i));
}

static int Println_MbR9(/*1:1*/ fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}

int fu_MAIN()
{
    const fu::str* x;
    fu::str x_1 {};
    return Println_MbR9(fu::view<fu::str> {{ fu::str((x = &(str_y3ibvcul0Fi), (*x))), (x_1 = Stringy_MbR9(10), x_1).const_cast_mut().destructive_move() }}) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========
 // inline fn empty retval on autocall
        inline fn concatable(a: bool)               a ? "yes" : "no";
        inline fn concat(a.concatable, b: string)   a ~ b;
        fn main()                                   concat(true, "!") == "yes!" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> a {};
    bool a_1;
    fu::view<char> b {};
    if ((a.ptr_reassign((a_1 = true, (a_1 ? "yes"_view : "no"_view))), b.ptr_reassign("!"_view), (a + b)) == "yes!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========
 // inline fn empty retval on autocall
        inline fn concatable(a: bool)               a ? "yes" : "no";
        inline fn concat(a.concatable, b: string)   a ~ b;
        fn main()                                   concat(true, "!") == "yes!" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> a {};
    fu::view<char> b {};
    if ((a.ptr_reassign("yes"_view), b.ptr_reassign("!"_view), (a + b)) == "yes!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========
 // inline fn empty retval on autocall
        inline fn inl_print(a: byte)                a;          // PointlessLocal
        fn inl_println(a.inl_print[]: string)       a.len;
        fn main()                                   inl_println('a', 'b') == 2 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int inl_println_MbR9(/*1:1*/ fu::view<char> a)
{
    return a.size();
}

int fu_MAIN()
{
    char a;
    char a_1;
    if (inl_println_MbR9(fu::view<char> {{ (a = 'a', a), (a_1 = 'b', a_1) }}) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct My { i: i32 };

        fn test(oh: My)
        {
            // autocall(): never
            let str = |my: My|: never {             // N_DeadConv
                return my.i; // exits test() here
            };

 // both mess up, this one emits a pointless overload,
            let hello = oh ~ "!";            //  this one messes up earlier in the solver

            return hello.len;
        }

        fn main() {
            return test(My(3)) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct My_AE4a;

                                #ifndef DEF_My_AE4aro7EnH4
                                #define DEF_My_AE4aro7EnH4
struct My_AE4a
{
                                // shape_hash:    409d40e70358db63
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const My_AE4a& oh)
{
    return oh.i;
}

int fu_MAIN()
{
    return test_MbR9(My_AE4a { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet, N_DeadConv

========

        struct My { i: i32 };

        fn test(oh: My)
        {
            // autocall(): never
            let str = |my: My|: never {             // N_DeadConv
                return my.i; // exits test() here
            };


            let hello = "Hello, " ~ oh;      //  this one messes up earlier in the solver

            return hello.len;
        }

        fn main() {
            return test(My(3)) - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct My_AE4a;

                                #ifndef DEF_My_AE4aro7EnH4
                                #define DEF_My_AE4aro7EnH4
struct My_AE4a
{
                                // shape_hash:    409d40e70358db63
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ const My_AE4a& oh)
{
    return oh.i;
}

int fu_MAIN()
{
    return test_MbR9(My_AE4a { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet, N_DeadConv

========

        fn printlike(topic: string, stuff.print[]: string[..], implicit ref out: string) {
            out ~= topic ~ ": " ~ stuff.join() ~ '\n';
        }

        fn main() {
            let topic = "A";
            implicit mut out: string;
            printlike(:topic, "Hello, ", "World", "!");
            return out == "A: Hello, World!\n" ? 0 : 1         // PointlessLocal
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_59vvPMBHtob
                                #define STR_59vvPMBHtob
static const fu::str str_59vvPMBHtob fu_INIT_PRIORITY(1001) { "Hello, "_fu };
                                #endif

                                #ifndef STR_dv2zmTGvsIb
                                #define STR_dv2zmTGvsIb
static const fu::str str_dv2zmTGvsIb fu_INIT_PRIORITY(1001) { "World"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1001) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void printlike_MbR9(/*7:7*/ fu::view<char> topic, /*7:7*/ fu::view<fu::str> stuff, /*4:4*/ fu::vec_range_mut<char> out)
{
    out += (((topic + ": "_view) + join_QbuI(stuff)) + '\n');
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ topic = "A"_view;
    fu::str out {};
    fu::vec_range<char> x {};
    fu::vec_range<char> x_1 {};
    fu::vec_range<char> x_2 {};
    printlike_MbR9(topic, fu::view<fu::str> {{ fu::str((x.ptr_reassign(str_59vvPMBHtob), x)), fu::str((x_1.ptr_reassign(str_dv2zmTGvsIb), x_1)), fu::str((x_2.ptr_reassign(str_5TEYhFzaE10), x_2)) }}, out);
    if (out == "A: Hello, World!\n"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn printlike(topic: string, stuff.print[]: string[..], implicit ref out: string) {
            out ~= topic ~ ": " ~ stuff.join() ~ '\n';
        }

        fn main() {
            let topic = "A";
            implicit mut out: string;
            printlike(:topic, "Hello, ", "World", "!");
            return out == "A: Hello, World!\n" ? 0 : 1         // PointlessLocal
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_59vvPMBHtob
                                #define STR_59vvPMBHtob
static const fu::str str_59vvPMBHtob fu_INIT_PRIORITY(1001) { "Hello, "_fu };
                                #endif

                                #ifndef STR_dv2zmTGvsIb
                                #define STR_dv2zmTGvsIb
static const fu::str str_dv2zmTGvsIb fu_INIT_PRIORITY(1001) { "World"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1001) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void printlike_MbR9(/*7:7*/ fu::view<char> topic, /*7:7*/ fu::view<fu::str> stuff, /*4:4*/ fu::vec_range_mut<char> out)
{
    out += (((topic + ": "_view) + join_QbuI(stuff)) + '\n');
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ topic = "A"_view;
    fu::str out {};
    const fu::str* x;
    const fu::str* x_1;
    const fu::str* x_2;
    printlike_MbR9(topic, fu::view<fu::str> {{ fu::str((x = &(str_59vvPMBHtob), (*x))), fu::str((x_1 = &(str_dv2zmTGvsIb), (*x_1))), fu::str((x_2 = &(str_5TEYhFzaE10), (*x_2))) }}, out);
    if (out == "A: Hello, World!\n"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        fn main() {
            mut out: string;                                    // PointlessLocal
            fn lazywarn(prefix: string, inline stuff.print[]: string[..]) {
                out ||= prefix ~ stuff.join();
            }

            mut once = 0;
            fn once(str: string) {
                once++;
                return str;
            }

            lazywarn(once("Hello"), ", ", "World", "!", prefix: "X: ");
            lazywarn(prefix: "Y: ", once("Hello"), "!");

            return out == "X: Hello, World!" && once == 1 ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1001) { ", "_fu };
                                #endif

                                #ifndef STR_dv2zmTGvsIb
                                #define STR_dv2zmTGvsIb
static const fu::str str_dv2zmTGvsIb fu_INIT_PRIORITY(1001) { "World"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1001) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> once_MbR9(/*3:3*/ fu::vec_range<char> str, /*2:2*/ int& once)
{
    once++;
    return str;
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str out {};
    int once = 0;

    {
        fu::view<char> /*static*/ prefix = "X: "_view;
        if (!(out))
        {
            fu::vec_range<char> x {};
            fu::vec_range<char> x_1 {};
            fu::vec_range<char> x_2 {};
            fu::vec_range<char> x_3 {};
            out = (prefix + join_QbuI(fu::view<fu::str> {{ fu::str((x.ptr_reassign(once_MbR9(str_5Dh86r8K971, once)), x)), fu::str((x_1.ptr_reassign(str_OGhgmtYJxj2), x_1)), fu::str((x_2.ptr_reassign(str_dv2zmTGvsIb), x_2)), fu::str((x_3.ptr_reassign(str_5TEYhFzaE10), x_3)) }}));
        };
    };

    {
        fu::view<char> /*static*/ prefix = "Y: "_view;
        if (!(out))
        {
            fu::vec_range<char> x {};
            fu::vec_range<char> x_1 {};
            out = (prefix + join_QbuI(fu::view<fu::str> {{ fu::str((x.ptr_reassign(once_MbR9(str_5Dh86r8K971, once)), x)), fu::str((x_1.ptr_reassign(str_5TEYhFzaE10), x_1)) }}));
        };
    };
    if ((out == "X: Hello, World!"_view) && (once == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut out: string;                                    // PointlessLocal
            fn lazywarn(prefix: string, inline stuff.print[]: string[..]) {
                out ||= prefix ~ stuff.join();
            }

            mut once = 0;
            fn once(str: string) {
                once++;
                return str;
            }

            lazywarn(once("Hello"), ", ", "World", "!", prefix: "X: ");
            lazywarn(prefix: "Y: ", once("Hello"), "!");

            return out == "X: Hello, World!" && once == 1 ? 0 : 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>


                                #ifndef STR_5Dh86r8K971
                                #define STR_5Dh86r8K971
static const fu::str str_5Dh86r8K971 fu_INIT_PRIORITY(1001) { "Hello"_fu };
                                #endif

                                #ifndef STR_OGhgmtYJxj2
                                #define STR_OGhgmtYJxj2
static const fu::str str_OGhgmtYJxj2 fu_INIT_PRIORITY(1001) { ", "_fu };
                                #endif

                                #ifndef STR_dv2zmTGvsIb
                                #define STR_dv2zmTGvsIb
static const fu::str str_dv2zmTGvsIb fu_INIT_PRIORITY(1001) { "World"_fu };
                                #endif

                                #ifndef STR_5TEYhFzaE10
                                #define STR_5TEYhFzaE10
static const fu::str str_5TEYhFzaE10 fu_INIT_PRIORITY(1001) { "!"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> once_MbR9(/*3:3*/ fu::vec_range<char> str, /*2:2*/ int& once)
{
    once++;
    return str;
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str out {};
    int once = 0;

    {
        fu::view<char> /*static*/ prefix = "X: "_view;
        if (!(out))
        {
            fu::vec_range<char> x {};
            const fu::str* x_1;
            const fu::str* x_2;
            const fu::str* x_3;
            out = (prefix + join_QbuI(fu::view<fu::str> {{ fu::str((x.ptr_reassign(once_MbR9(str_5Dh86r8K971, once)), x)), fu::str((x_1 = &(str_OGhgmtYJxj2), (*x_1))), fu::str((x_2 = &(str_dv2zmTGvsIb), (*x_2))), fu::str((x_3 = &(str_5TEYhFzaE10), (*x_3))) }}));
        };
    };

    {
        fu::view<char> /*static*/ prefix = "Y: "_view;
        if (!(out))
        {
            fu::vec_range<char> x {};
            const fu::str* x_1;
            out = (prefix + join_QbuI(fu::view<fu::str> {{ fu::str((x.ptr_reassign(once_MbR9(str_5Dh86r8K971, once)), x)), fu::str((x_1 = &(str_5TEYhFzaE10), (*x_1))) }}));
        };
    };
    if ((out == "X: Hello, World!"_view) && (once == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn ifThenElse(inline cond, inline cons, inline alt)
            cond ? cons : alt;

        fn main() {
            mut cond = 0;
            ifThenElse(cond++,
                { return 10; },
                { return cond == 1 ? 0 : 100; });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int cond = 0;
    if (cond++)
        return 10;
    else if (cond == 1)
        return 0;
    else
        return 100;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn not_ambig !T(ref sum!: i32,

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     'g'); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:21+9[0m:

[2m      |             let c = not_ambig(:sum, "abc", "de");[0m
[2m      |             let d = not_ambig(:sum, 3, 3);[0m
[2m   23 | [0m            let e = [31;1mnot_ambig[0m(:sum, "abcdef",
[2m      | [0m
[2m      |                                      'g'); [0m

	Bad call to [94;1mnot_ambig[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m, [35;3mstring[0m, [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m14:12+9[0m:
[2m   14 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1mb[0m expects [35;3mi32[0m, got [35;3mbyte[0m

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m13:12+9[0m:
[2m   13 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1ma[0m expects [35;3mi32[0m, got [35;3mstring[0m

	[35;3mtemplate[0m [94;1mnot_ambig[0m at [2m2:12+9[0m:
[2m    2 | [0m        fn [31;1mnot_ambig[0m !T(ref sum!: i32,

	    Rest arguments have no common supertype: [35;3mstring[0m <- [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        fn not_ambig !T(ref sum!: i32,

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     'g'); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:21+9[0m:

[2m      |             let c = not_ambig(:sum, "abc", "de");[0m
[2m      |             let d = not_ambig(:sum, 3, 3);[0m
[2m   23 | [0m            let e = [31;1mnot_ambig[0m(:sum, "abcdef",
[2m      | [0m
[2m      |                                      'g'); [0m

	Bad call to [94;1mnot_ambig[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mstring[0m, [35;3malways-true[0m [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m14:12+9[0m:
[2m   14 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1mb[0m expects [35;3mi32[0m, got [35;3mbyte[0m

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m13:12+9[0m:
[2m   13 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1ma[0m expects [35;3mi32[0m, got [35;3mstring[0m

	[35;3mtemplate[0m [94;1mnot_ambig[0m at [2m2:12+9[0m:
[2m    2 | [0m        fn [31;1mnot_ambig[0m !T(ref sum!: i32,

	    Rest arguments have no common supertype: [35;3malways-true[0m [35;3mstring[0m <- [35;3malways-true[0m [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m16:12+4[0m

========

        fn not_ambig !T(ref sum!: i32,

            inline                                              // GNUStmtExpr

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     'g'); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 25:21+9[0m:

[2m      |             let c = not_ambig(:sum, "abc", "de");[0m
[2m      |             let d = not_ambig(:sum, 3, 3);[0m
[2m   25 | [0m            let e = [31;1mnot_ambig[0m(:sum, "abcdef",
[2m      | [0m
[2m      |                                      'g'); [0m

	Bad call to [94;1mnot_ambig[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m, [35;3mstring[0m, [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m16:12+9[0m:
[2m   16 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1mb[0m expects [35;3mi32[0m, got [35;3mbyte[0m

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m15:12+9[0m:
[2m   15 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1ma[0m expects [35;3mi32[0m, got [35;3mstring[0m

	[35;3mtemplate[0m [94;1mnot_ambig[0m at [2m2:12+9[0m:
[2m    2 | [0m        fn [31;1mnot_ambig[0m !T(ref sum!: i32,

	    Rest arguments have no common supertype: [35;3mstring[0m <- [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m18:12+4[0m

========

        fn not_ambig !T(ref sum!: i32,

            inline                                              // GNUStmtExpr

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     'g'); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 25:21+9[0m:

[2m      |             let c = not_ambig(:sum, "abc", "de");[0m
[2m      |             let d = not_ambig(:sum, 3, 3);[0m
[2m   25 | [0m            let e = [31;1mnot_ambig[0m(:sum, "abcdef",
[2m      | [0m
[2m      |                                      'g'); [0m

	Bad call to [94;1mnot_ambig[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi32[0m, [35;3malways-true[0m [35;3mstring[0m, [35;3malways-true[0m [35;3mbyte[0m): 

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m16:12+9[0m:
[2m   16 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1mb[0m expects [35;3mi32[0m, got [35;3mbyte[0m

	[35;3mfn[0m [94;1mnot_ambig[0m at [2m15:12+9[0m:
[2m   15 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);

	    [35;3marg[0m [94;1mnot_ambig[0m:[94;1ma[0m expects [35;3mi32[0m, got [35;3mstring[0m

	[35;3mtemplate[0m [94;1mnot_ambig[0m at [2m2:12+9[0m:
[2m    2 | [0m        fn [31;1mnot_ambig[0m !T(ref sum!: i32,

	    Rest arguments have no common supertype: [35;3malways-true[0m [35;3mstring[0m <- [35;3malways-true[0m [35;3mbyte[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m18:12+4[0m

========

        fn not_ambig !T(ref sum!: i32,

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     "g"); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int not_ambig_haRm(/*7:7*/ int& sum, const int a, /*7:7*/ fu::view<char> b)
{
    return (sum += (a + b.size()));
}

static int not_ambig_GL0m(/*7:7*/ int& sum, /*7:7*/ fu::view<char> a, const int b)
{
    return (sum += (a.size() + b));
}

                                #ifndef DEF_not_ambig_9r3gAjBWwn2
                                #define DEF_not_ambig_9r3gAjBWwn2
inline static int not_ambig_9r3g(/*1:1*/ int& sum, /*3:3*/ fu::view<fu::str> v)
{
    for (int i = 0; i < v.size(); i++)
        sum += v[i].size();

    return sum;
}
                                #endif

                                #ifndef DEF_not_ambig_Z9JLSA1hfFg
                                #define DEF_not_ambig_Z9JLSA1hfFg
inline static int not_ambig_Z9JL(/*1:1*/ int& sum, /*3:3*/ fu::view<int> v)
{
    for (int i = 0; i < v.size(); i++)
        sum += v[i];

    return sum;
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    const int /*sum*/ a = not_ambig_haRm(sum, 1, "ab"_view);
    const int /*sum*/ b = not_ambig_GL0m(sum, "bc"_view, 2);
    const int /*sum*/ c = not_ambig_9r3g(sum, fu::view<fu::str> {{ fu::str("abc"_fu), fu::str("de"_fu) }});
    const int /*sum*/ d = not_ambig_Z9JL(sum, fu::view<int> {{ 3, 3 }});
    const int /*sum*/ e = not_ambig_9r3g(sum, fu::view<fu::str> {{ fu::str("abcdef"_fu), fu::str("g"_fu) }});
    if ((a == 3) && (b == 7) && (c == 12) && (d == 18) && (e == 25))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn not_ambig !T(ref sum!: i32,

            inline                                              // GNUStmtExpr

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            shadow let v = v; for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     "g"); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int not_ambig_haRm(/*7:7*/ int& sum, const int a, /*7:7*/ fu::view<char> b)
{
    return (sum += (a + b.size()));
}

static int not_ambig_GL0m(/*7:7*/ int& sum, /*7:7*/ fu::view<char> a, const int b)
{
    return (sum += (a.size() + b));
}

int fu_MAIN()
{
    int sum = 0;
    const int /*sum*/ a = not_ambig_haRm(sum, 1, "ab"_view);
    const int /*sum*/ b = not_ambig_GL0m(sum, "bc"_view, 2);
    int BL_1_v;
    const int /*sum*/ c = (__extension__ (
    {
        fu::vec<fu::str> v = fu::vec<fu::str> {{ fu::str("abc"_fu), fu::str("de"_fu) }};
        for (int i = 0; i < v.size(); i++)
            sum += v[i].size();

        BL_1_v = (sum);
        (void)0;
    }), BL_1_v);
    int BL_4_v;
    const int /*sum*/ d = (__extension__ (
    {
        fu::vec<int> v = fu::vec<int> {{ 3, 3 }};
        for (int i = 0; i < v.size(); i++)
            sum += v[i];

        BL_4_v = (sum);
        (void)0;
    }), BL_4_v);
    int BL_7_v;
    const int /*sum*/ e = (__extension__ (
    {
        fu::vec<fu::str> v = fu::vec<fu::str> {{ fu::str("abcdef"_fu), fu::str("g"_fu) }};
        for (int i = 0; i < v.size(); i++)
            sum += v[i].size();

        BL_7_v = (sum);
        (void)0;
    }), BL_7_v);
    if ((a == 3) && (b == 7) && (c == 12) && (d == 18) && (e == 25))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);
            return res == 10000 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>

static int will_relax_args_b_MbR9(fu::view<int>, int, int, int, int, int);
static int will_relax_args_a_MbR9(fu::view<int>, int, int, int, int, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_MbR9(/*F3:F3*/ fu::view<int> data, const int offset, /*F3:F3*/ const int THREE, /*F3:F3*/ const int TWO, /*F3:F3*/ const int FIVE, /*F3:F3*/ const int FOUR)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);

    }
    else
        return THREE * offset;

}

static int will_relax_args_b_MbR9(/*F3:F3*/ fu::view<int> data, const int offset, /*F3:F3*/ const int FOUR, /*F3:F3*/ const int TWO, /*F3:F3*/ const int FIVE, /*F3:F3*/ const int THREE)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);

    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    const int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    const int FIVE = 5;
    fu::vec<int> data = fu::vec<int> {{ 0, 0, 0, 0, 0 }};
    int offset;
    const int res = (offset = 0, (FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE)));
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                if (offset & 2)
                    return 5 * will_relax_args_b(data, offset + 1);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);
            return res == 10000 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

static int will_relax_args_b_MbR9(fu::vec_range_mut<int>, int, int, int, int&, int);
static int will_relax_args_a_MbR9(fu::vec_range_mut<int>, int, int, int, int&, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int THREE, /*F3:F3*/ const int TWO, /*F3:F3*/ int& FIVE, /*F3:F3*/ const int FOUR)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);

    }
    else
        return THREE * offset;

}

static int will_relax_args_b_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int FOUR, /*F3:F3*/ const int TWO, /*F3:F3*/ int& FIVE, /*F3:F3*/ const int THREE)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else if (offset & 2)
            return 5 * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);

    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    const int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    int FIVE = 5;
    fu::vec<int> data = fu::vec<int> {{ 0, 0, 0, 0, 0 }};
    int offset;
    const int res = (offset = 0, (FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE)));
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

========

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                if (offset & 2)
                    return 2 * will_relax_args_a(data, offset + 1);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);
            return res == 10000 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

static int will_relax_args_b_MbR9(fu::vec_range_mut<int>, int, int, int&, int, int);
static int will_relax_args_a_MbR9(fu::vec_range_mut<int>, int, int, int&, int, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int THREE, /*F3:F3*/ int& TWO, /*F3:F3*/ const int FIVE, /*F3:F3*/ const int FOUR)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else if (offset & 2)
            return 2 * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);

    }
    else
        return THREE * offset;

}

static int will_relax_args_b_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int FOUR, /*F3:F3*/ int& TWO, /*F3:F3*/ const int FIVE, /*F3:F3*/ const int THREE)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);

    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    const int FIVE = 5;
    fu::vec<int> data = fu::vec<int> {{ 0, 0, 0, 0, 0 }};
    int offset;
    const int res = (offset = 0, (FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE)));
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

========

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                if (offset & 2)
                    return 2 * will_relax_args_a(data, offset + 1);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                if (offset & 2)
                    return 5 * will_relax_args_b(data, offset + 1);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);
            return res == 10000 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

static int will_relax_args_b_MbR9(fu::vec_range_mut<int>, int, int, int&, int&, int);
static int will_relax_args_a_MbR9(fu::vec_range_mut<int>, int, int, int&, int&, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int THREE, /*F3:F3*/ int& TWO, /*F3:F3*/ int& FIVE, /*F3:F3*/ const int FOUR)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else if (offset & 2)
            return 2 * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);

    }
    else
        return THREE * offset;

}

static int will_relax_args_b_MbR9(/*F3:F3*/ fu::vec_range_mut<int> data, const int offset, /*F3:F3*/ const int FOUR, /*F3:F3*/ int& TWO, /*F3:F3*/ int& FIVE, /*F3:F3*/ const int THREE)
{
    if (offset < data.size())
    {
        if (offset & 1)
            return TWO * will_relax_args_a_MbR9(data, (offset + 1), THREE, TWO, FIVE, FOUR);
        else if (offset & 2)
            return 5 * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);
        else
            return FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE);

    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    int FIVE = 5;
    fu::vec<int> data = fu::vec<int> {{ 0, 0, 0, 0, 0 }};
    int offset;
    const int res = (offset = 0, (FIVE * will_relax_args_b_MbR9(data, (offset + 1), FOUR, TWO, FIVE, THREE)));
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_7jlK710ibV8
                                #define DEF_HERE_7jlK710ibV8
inline static int HERE_7jlK(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_7jlK(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;
        pub import _0;
        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_7jlK710ibV8
                                #define DEF_HERE_7jlK710ibV8
inline int HERE_7jlK(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_7jlK(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_7jlK710ibV8
                                #define DEF_HERE_7jlK710ibV8
inline static int HERE_7jlK(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_7jlK(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token) t.index * 11;
        pub import _1;
        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_7jlK710ibV8
                                #define DEF_HERE_7jlK710ibV8
inline int HERE_7jlK(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_7jlK(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: Token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int HERE_MbR9(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_MbR9(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: Token) t.index * 11;
        pub import _0;
        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;
int HERE_MbR9(const Token_78zN&);

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_MbR9(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }
struct Token_78zN;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_MbR9(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}

#endif

========

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token: Token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int HERE_LtD7(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_LtD7(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token: Token) t.index * 11;
        pub import _1;
        fn main = HERE(Node(Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;
int HERE_LtD7(const Token_78zN&);

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_LtD7(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }
struct Token_78zN;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_LtD7(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}

#endif

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_7jlK710ibV8
                                #define DEF_HERE_7jlK710ibV8
inline int HERE_7jlK(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_7jlK(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: _0::Token) t.index * 11;

        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Token_78zN;
struct Node_AM3P;
int HERE_LtD7(const Token_78zN&);

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_AM3P6UZjB2h
                                #define DEF_Node_AM3P6UZjB2h
struct Node_AM3P
{
                                // shape_hash:    854ab6359d29f76c
                                // non_triv_mask: 0000000000000000
    Token_78zN token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_LtD7(Node_AM3P { Token_78zN { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }
struct Token_78zN;

                                #ifndef DEF_Token_78zNOIGJSo9
                                #define DEF_Token_78zNOIGJSo9
struct Token_78zN
{
                                // shape_hash:    b9c0809aa50d08d6
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_LtD7(/*1:1*/ const Token_78zN& t)
{
    return t.index * 11;
}

#endif

========

        struct A { a: i32 };
        fn hello(.a: i32) a;
        fn world(a.a: i32) a;
        fn main() A(0).hello + A(0).world;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct A_EqO7;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_MbR9(/*1:1*/ const int a)
{
    return a;
}

static int world_MbR9(/*1:1*/ const int a)
{
    return a;
}

int fu_MAIN()
{
    return hello_MbR9(A_EqO7 { 0 }.a) + world_MbR9(A_EqO7 { 0 }.a);
}

#endif

int main() { return fu_MAIN(); }

========

        fn fn_v(fn, v) fn(v);
        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___YAOb0Cf4Y6i
                                #define DEF___YAOb0Cf4Y6i
inline static int _YAOb(/*1:1*/ const XY_tqAU& _)
{
    return _.x;
}
                                #endif

                                #ifndef DEF_fn_v_0DkN6gKxB6i
                                #define DEF_fn_v_0DkN6gKxB6i
inline static int fn_v_0DkN(/*3:3*/ const XY_tqAU& v)
{
    return _YAOb(v);
}
                                #endif

                                #ifndef DEF___tqznOfWc8jk
                                #define DEF___tqznOfWc8jk
inline static int _tqzn(/*1:1*/ const XY_tqAU& _)
{
    return _.y;
}
                                #endif

                                #ifndef DEF_fn_v_zXQ2gd3CHNc
                                #define DEF_fn_v_zXQ2gd3CHNc
inline static int fn_v_zXQ2(/*3:3*/ const XY_tqAU& v)
{
    return _tqzn(v);
}
                                #endif

int fu_MAIN()
{
    const XY_tqAU v = XY_tqAU { 11, 13 };
    return (fn_v_0DkN(v) + fn_v_zXQ2(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

========

        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___YAOb0Cf4Y6i
                                #define DEF___YAOb0Cf4Y6i
inline static int _YAOb(/*1:1*/ const XY_tqAU& _)
{
    return _.x;
}
                                #endif

                                #ifndef DEF_fn_v_0DkN6gKxB6i
                                #define DEF_fn_v_0DkN6gKxB6i
inline static int fn_v_0DkN(/*3:3*/ const XY_tqAU& v)
{
    return _YAOb(v);
}
                                #endif

                                #ifndef DEF___tqznOfWc8jk
                                #define DEF___tqznOfWc8jk
inline static int _tqzn(/*1:1*/ const XY_tqAU& _)
{
    return _.y;
}
                                #endif

                                #ifndef DEF_fn_v_zXQ2gd3CHNc
                                #define DEF_fn_v_zXQ2gd3CHNc
inline static int fn_v_zXQ2(/*3:3*/ const XY_tqAU& v)
{
    return _tqzn(v);
}
                                #endif

int fu_MAIN()
{
    const XY_tqAU v = XY_tqAU { 11, 13 };
    return (fn_v_0DkN(v) + fn_v_zXQ2(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

========

        fn fn_w(x, y) x(y);             // same thing but
        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___YAOb0Cf4Y6i
                                #define DEF___YAOb0Cf4Y6i
inline static int _YAOb(/*1:1*/ const XY_tqAU& _)
{
    return _.x;
}
                                #endif

                                #ifndef DEF_fn_w_0DkN6gKxB6i
                                #define DEF_fn_w_0DkN6gKxB6i
inline static int fn_w_0DkN(/*3:3*/ const XY_tqAU& y)
{
    return _YAOb(y);
}
                                #endif

                                #ifndef DEF_fn_v_MnkjNOKA7Ug
                                #define DEF_fn_v_MnkjNOKA7Ug
inline static int fn_v_Mnkj(/*3:3*/ const XY_tqAU& x)
{
    return fn_w_0DkN(x);
}
                                #endif

                                #ifndef DEF___tqznOfWc8jk
                                #define DEF___tqznOfWc8jk
inline static int _tqzn(/*1:1*/ const XY_tqAU& _)
{
    return _.y;
}
                                #endif

                                #ifndef DEF_fn_w_zXQ2gd3CHNc
                                #define DEF_fn_w_zXQ2gd3CHNc
inline static int fn_w_zXQ2(/*3:3*/ const XY_tqAU& y)
{
    return _tqzn(y);
}
                                #endif

                                #ifndef DEF_fn_v_0AZU5vgSKz9
                                #define DEF_fn_v_0AZU5vgSKz9
inline static int fn_v_0AZU(/*3:3*/ const XY_tqAU& x)
{
    return fn_w_zXQ2(x);
}
                                #endif

int fu_MAIN()
{
    const XY_tqAU v = XY_tqAU { 11, 13 };
    return (fn_v_Mnkj(v) + fn_v_0AZU(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

========

        fn woot(x: int) x + 5;

        let what = fn woot; 
        fn main() (-5).what;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int woot_MbR9(const int x)
{
    return x + 5;
}

int fu_MAIN()
{
    return woot_MbR9(-5);
}

#endif

int main() { return fu_MAIN(); }

========

        fn woot(x: int) x + 5;

        let what = .woot;   
        fn main() (-5).what;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int woot_MbR9(const int x)
{
    return x + 5;
}

                                #ifndef DEF___PnkC69bPgi8
                                #define DEF___PnkC69bPgi8
inline static int _PnkC(/*1:1*/ const int _)
{
    return woot_MbR9(_);
}
                                #endif

int fu_MAIN()
{
    return _PnkC(-5);
}

#endif

int main() { return fu_MAIN(); }

========

        fn identity(x) x;
        fn main() {
            fn outer(depth1) {
                let sum = depth1; return identity(|| sum);
            }
            let sum = 0; return outer(sum);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___Zg7axrjWgYe
                                #define DEF___Zg7axrjWgYe
inline static int _Zg7a(/*1:1*/ const int depth1)
{
    return depth1;
}
                                #endif

                                #ifndef DEF_identity_dnRoAoVdIOc
                                #define DEF_identity_dnRoAoVdIOc
inline static int identity_dnRo(/*3:3*/ const int depth1)
{
    return _Zg7a(depth1);
}
                                #endif

                                #ifndef DEF_outer_6Ves4M8Jcr3
                                #define DEF_outer_6Ves4M8Jcr3
inline static int outer_6Ves(/*1:1*/ const int depth1)
{
    return identity_dnRo(depth1);
}
                                #endif

int fu_MAIN()
{
    const int sum = 0;
    return outer_6Ves(sum);
}

#endif

int main() { return fu_MAIN(); }

========

        fn identity(x) x;
        fn test(depth0) {
            fn outer(depth1) {
                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_identity_VRSJUP1ldRj
                                #define DEF_identity_VRSJUP1ldRj
inline static int identity_VRSJ(/*3:3*/ const int sum)
{
    return sum;
}
                                #endif

                                #ifndef DEF_outer_XBUZW8roRXl
                                #define DEF_outer_XBUZW8roRXl
inline static int outer_XBUZ(/*3:3*/ const int depth0)
{
    const int /*depth0*/ sum = depth0;
    return identity_VRSJ(sum);
}
                                #endif

                                #ifndef DEF_test_xLEGHFnAVeb
                                #define DEF_test_xLEGHFnAVeb
inline static int test_xLEG(/*1:1*/ const int depth0)
{
    return outer_XBUZ(depth0);
}
                                #endif

int fu_MAIN()
{
    return test_xLEG(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(depth0) {
            fn identity(x) x;
            fn outer(depth1) {
                fn inner(depth2) {
                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);
                }
                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_identity_VRSJUP1ldRj
                                #define DEF_identity_VRSJUP1ldRj
inline static int identity_VRSJ(/*3:3*/ const int sum)
{
    return sum;
}
                                #endif

                                #ifndef DEF_inner_XBUZW8roRXl
                                #define DEF_inner_XBUZW8roRXl
inline static int inner_XBUZ(/*3:3*/ const int sum)
{
    const int /*sum*/ sum_1 = sum;
    return identity_VRSJ(sum_1);
}
                                #endif

                                #ifndef DEF_outer_16yat8p7tf4
                                #define DEF_outer_16yat8p7tf4
inline static int outer_16ya(/*3:3*/ const int depth0)
{
    const int /*depth0*/ sum = depth0;
    return inner_XBUZ(sum);
}
                                #endif

                                #ifndef DEF_test_Y1Bjn28MUP1
                                #define DEF_test_Y1Bjn28MUP1
inline static int test_Y1Bj(/*1:1*/ const int depth0)
{
    return outer_16ya(depth0);
}
                                #endif

int fu_MAIN()
{
    return test_Y1Bj(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(depth0)
        {
            fn first(depth1) {
                fn first_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum;
                }

                let sum = depth0 + depth1;
                return first_inner(|| sum);                     // DuplicateFunctions
            }

            fn second(depth1) {
                fn second_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum + first(|| sum);
                }

                let sum = depth0 + depth1;
                return second_inner(|| sum);
            }

            let sum = depth0 + depth0;
            return second(|| sum);
        }

        fn main() test(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___Zg7axrjWgYe
                                #define DEF___Zg7axrjWgYe
inline static int _Zg7a(/*1:1*/ const int sum)
{
    return sum;
}
                                #endif

                                #ifndef DEF_first_inner_zgx7GXZcSO4
                                #define DEF_first_inner_zgx7GXZcSO4
inline static int first_inner_zgx7(/*F:F*/ const int sum, /*F:F*/ const int sum_1, /*F:F*/ const int depth0)
{
    const int sum_2 = ((depth0 + _Zg7a(sum_1)) + _Zg7a(sum));
    return sum_2;
}
                                #endif

                                #ifndef DEF_first_612H9yJP6Fi
                                #define DEF_first_612H9yJP6Fi
inline static int first_612H(/*7:7*/ const int sum, /*7:7*/ const int depth0)
{
    const int sum_1 = (depth0 + _Zg7a(sum));
    return first_inner_zgx7(sum_1, sum, depth0);
}
                                #endif

                                #ifndef DEF_second_inner_tPmobN9IRE7
                                #define DEF_second_inner_tPmobN9IRE7
inline static int second_inner_tPmo(/*F:F*/ const int sum, /*F:F*/ const int depth0, /*F:F*/ const int sum_1)
{
    const int sum_2 = ((depth0 + _Zg7a(sum_1)) + _Zg7a(sum));
    return sum_2 + first_612H(sum_2, depth0);
}
                                #endif

                                #ifndef DEF_second_K8vJbEIrpv0
                                #define DEF_second_K8vJbEIrpv0
inline static int second_K8vJ(/*7:7*/ const int depth0, /*7:7*/ const int sum)
{
    const int sum_1 = (depth0 + _Zg7a(sum));
    return second_inner_tPmo(sum_1, depth0, sum);
}
                                #endif

                                #ifndef DEF_test_NoSbKLmiq31
                                #define DEF_test_NoSbKLmiq31
inline static int test_NoSb(const int depth0)
{
    const int sum = (depth0 + depth0);
    return second_K8vJ(depth0, sum);
}
                                #endif

int fu_MAIN()
{
    return test_NoSb(0);
}

#endif

int main() { return fu_MAIN(); }

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
        return parseStuff_MbR9((y / 2), a, b, c) * parseStuff_MbR9(x, a, b, c);
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int parseStuff_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doStuff_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_MbR9(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doSomething_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_inner_MbR9((x * x), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return doSomething_MbR9((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int descend_MbR9(const int x, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return descend_inner_MbR9((x * x), x, a, b, c);
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    return (y * use_a_MbR9(a)) * descend_MbR9((y * y), a, b, c);
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int doSomethingElse_MbR9(const int x, /*3:3*/ const int b)
{
    return doSomethingElse_inner_MbR9((x * x), b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
        return doSomethingElse_MbR9((y * y), b) * use_c_MbR9(c);

}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline 
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline 
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline 
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int doStuff_MbR9(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_MbR9(/*1:1*/ const int a)
{
    return a * a;
}

static int use_b_MbR9(/*1:1*/ const int b)
{
    return b * b;
}

static int doSomethingElse_inner_MbR9(const int y, /*3:3*/ const int b)
{
    return y * use_b_MbR9(b);
}

static int use_c_MbR9(/*1:1*/ const int c)
{
    return c * c;
}

static int descend_inner_MbR9(const int y, /*F1:F1*/ const int x, /*F1:F1*/ const int a, /*F1:F1*/ const int b, /*F1:F1*/ const int c)
{
    if (y & 1)
    {
        int x_1;
        return (x_1 = (y / 2), doStuff_MbR9((x_1 * x_1), a, b, c)) * doStuff_MbR9((x * x), a, b, c);
    }
    else
    {
        int x_1;
        return (x_1 = (y * y), doSomethingElse_inner_MbR9((x_1 * x_1), b)) * use_c_MbR9(c);
    };
}

static int doSomething_inner_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    int x;
    return (y * use_a_MbR9(a)) * (x = (y * y), descend_inner_MbR9((x * x), x, a, b, c));
}

static int doStuff_MbR9(const int y, /*F:F*/ const int a, /*F:F*/ const int b, /*F:F*/ const int c)
{
    const int x = (y * y);
    return doSomething_inner_MbR9((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_MbR9((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

========

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing("Reason");
            };
            return stuff.len - 15; // "continue Reason"

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_iSg8C5EIdoh
                                #define STR_iSg8C5EIdoh
static const fu::str str_iSg8C5EIdoh fu_INIT_PRIORITY(1001) { "Reason"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___yozy6HIHXig
                                #define DEF___yozy6HIHXig
inline static fu::vec_range<char> _yozy()
{
    fu::vec_range<char> reason {};
    return reason.ptr_reassign(str_iSg8C5EIdoh);
}
                                #endif

                                #ifndef DEF_doThing_rlBbPR22Mkb
                                #define DEF_doThing_rlBbPR22Mkb
inline static void doThing_rlBb(/*3:3*/ fu::vec_range_mut<char> stuff)
{
    stuff = ("continue "_view + _yozy());
}
                                #endif

int fu_MAIN()
{
    fu::str stuff = fu::str(""_fu);
    doThing_rlBb(stuff);
    return stuff.size() - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedTry

========

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing("Reason");
            };
            return stuff.len - 15; // "continue Reason"

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>


                                #ifndef STR_iSg8C5EIdoh
                                #define STR_iSg8C5EIdoh
static const fu::str str_iSg8C5EIdoh fu_INIT_PRIORITY(1001) { "Reason"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___yozy6HIHXig
                                #define DEF___yozy6HIHXig
inline static const fu::str& _yozy()
{
    const fu::str* reason;
    return (*(reason = &(str_iSg8C5EIdoh)));
}
                                #endif

                                #ifndef DEF_doThing_rlBbPR22Mkb
                                #define DEF_doThing_rlBbPR22Mkb
inline static void doThing_rlBb(/*3:3*/ fu::str& stuff)
{
    stuff = ("continue "_view + _yozy());
}
                                #endif

int fu_MAIN()
{
    fu::str stuff {};
    doThing_rlBb(stuff);
    return stuff.size() - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedTry

========

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing(throw("Reason"));
            };
            return stuff.len - 12; // "throw Reason"

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___ZWYW8gMiCg6
                                #define DEF___ZWYW8gMiCg6
[[noreturn]] inline static fu::never _ZWYW()
{
    fu::fail(fu::str("Reason"_fu));
}
                                #endif

                                #ifndef DEF_doThing_WtuVV3eykm5
                                #define DEF_doThing_WtuVV3eykm5
inline static void doThing_WtuV(/*3:3*/ fu::vec_range_mut<char> stuff)
{

    try
    {
        _ZWYW();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        stuff = ("throw "_view + e);
    }
;
}
                                #endif

int fu_MAIN()
{
    fu::str stuff = fu::str(""_fu);
    doThing_WtuV(stuff);
    return stuff.size() - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing(throw("Reason"));
            };
            return stuff.len - 12; // "throw Reason"

        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___ZWYW8gMiCg6
                                #define DEF___ZWYW8gMiCg6
[[noreturn]] inline static fu::never _ZWYW()
{
    fu::fail(fu::str("Reason"_fu));
}
                                #endif

                                #ifndef DEF_doThing_WtuVV3eykm5
                                #define DEF_doThing_WtuVV3eykm5
inline static void doThing_WtuV(/*3:3*/ fu::str& stuff)
{

    try
    {
        _ZWYW();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        stuff = ("throw "_view + e);
    }
;
}
                                #endif

int fu_MAIN()
{
    fu::str stuff {};
    doThing_WtuV(stuff);
    return stuff.size() - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn nested(ref index: i32)
            return index++ && [];

        fn Lifetime_each(ref lifetime: i32[], visit)
            for (mut i = lifetime.len; i --> 0; )
                visit(nested(lifetime[i]));

        fn Lifetime_allowsMutrefReturn(ref lifetime: i32[])
            Lifetime_each(:lifetime): |t|
                return t;

        fn main() {
            mut arr: i32[] = [ 5, -2 ];
            Lifetime_allowsMutrefReturn(arr);

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void nested_MbR9(/*1:1*/ int& index)
{
    index++;
    return;
}

static void Lifetime_allowsMutrefReturn_MbR9(/*1:1*/ fu::view_mut<int> lifetime)
{
    for (int i = lifetime.size(); i-- > 0; )
    {
        nested_MbR9(lifetime.mutref(i));
        return;
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 5, -2 }};
    Lifetime_allowsMutrefReturn_MbR9(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedIfElse, N_UnusedLet

========

        fn Incr(ref x: i32) ++x;

        struct N { v: i32 };


        fn +=(ref a: N, b: i32) {
            a.v = a.v * 10 + b;
            return a;
        }

        fn main() {
            mut c: i32;
            mut a: N;
            (a = N(c.Incr)) += c.Incr;
            return a.v - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct N_88M1;

                                #ifndef DEF_N_88M1mn9ouSa
                                #define DEF_N_88M1mn9ouSa
struct N_88M1
{
                                // shape_hash:    070be1c4d0586be7
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Incr_kGbb(/*1:1*/ int& x)
{
    return ++x;
}

static const N_88M1& operator+=(/*3:3*/ N_88M1& a, const int b)
{
    a.v = ((a.v * 10) + b);
    return a;
}

int fu_MAIN()
{
    int c {};
    N_88M1 a {};
    (a = N_88M1 { Incr_kGbb(c) }) += Incr_kGbb(c);
    return a.v - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Incr(ref x: i32) ++x;

        struct N { v: i32 };


        inline

        fn +=(ref a: N, b: i32) {
            a.v = a.v * 10 + b;
            return a;
        }

        fn main() {
            mut c: i32;
            mut a: N;
            (a = N(c.Incr)) += c.Incr;
            return a.v - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct N_88M1;

                                #ifndef DEF_N_88M1mn9ouSa
                                #define DEF_N_88M1mn9ouSa
struct N_88M1
{
                                // shape_hash:    070be1c4d0586be7
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Incr_kGbb(/*1:1*/ int& x)
{
    return ++x;
}

int fu_MAIN()
{
    int c {};
    N_88M1 a {};

    {
        const int /*c*/ b = Incr_kGbb(c);
        N_88M1& /*a*/ a_1 = (a = N_88M1 { Incr_kGbb(c) });
        a_1.v = ((a_1.v * 10) + b);
    };
    return a.v - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() = test();
        fn test() {

            mut lt = Lifetime([ 1001, 1, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_yI8e;

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

                                #ifndef DEF_Lifetime_yI8e4Nvpayl
                                #define DEF_Lifetime_yI8e4Nvpayl
struct Lifetime_yI8e
{
                                // shape_hash:    adfcd672049d40bf
                                // non_triv_mask: 0008004000000000
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Region_asLocal_MbR9(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_MbR9(const int locid)
{
    return locid & 1;
}

                                #ifndef DEF_Lifetime_each_MIllIWWADn7
                                #define DEF_Lifetime_each_MIllIWWADn7
inline static void Lifetime_each_MIll(/*F7:F7*/ fu::view<int> lt, /*E7:E3*/ int& locids, /*F7:F7*/ bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            int locid;
            if (r == Region_STATIC)
                goto BL_3;
            else if ((locid = Region_asLocal_MbR9(r)))
            {
                if (!isMovedFrom_MbR9(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}
                                #endif

static int test_MbR9()
{
    Lifetime_yI8e lt = Lifetime_yI8e { fu::vec<int> {{ 1001, 1, 1003 }} };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_MIll(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

========

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() = test();
        fn test() {

            mut lt = Lifetime([ 1001, 1002, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_yI8e;

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

                                #ifndef DEF_Lifetime_yI8e4Nvpayl
                                #define DEF_Lifetime_yI8e4Nvpayl
struct Lifetime_yI8e
{
                                // shape_hash:    adfcd672049d40bf
                                // non_triv_mask: 0008004000000000
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Region_asLocal_MbR9(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_MbR9(const int locid)
{
    return locid & 1;
}

                                #ifndef DEF_Lifetime_each_MIllIWWADn7
                                #define DEF_Lifetime_each_MIllIWWADn7
inline static void Lifetime_each_MIll(/*F7:F7*/ fu::view<int> lt, /*E7:E3*/ int& locids, /*F7:F7*/ bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            int locid;
            if (r == Region_STATIC)
                goto BL_3;
            else if ((locid = Region_asLocal_MbR9(r)))
            {
                if (!isMovedFrom_MbR9(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}
                                #endif

static int test_MbR9()
{
    Lifetime_yI8e lt = Lifetime_yI8e { fu::vec<int> {{ 1001, 1002, 1003 }} };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_MIll(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

========

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() {

            mut lt = Lifetime([ 1001, 1, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_yI8e;

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

                                #ifndef DEF_Lifetime_yI8e4Nvpayl
                                #define DEF_Lifetime_yI8e4Nvpayl
struct Lifetime_yI8e
{
                                // shape_hash:    adfcd672049d40bf
                                // non_triv_mask: 0008004000000000
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Region_asLocal_MbR9(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_MbR9(const int locid)
{
    return locid & 1;
}

                                #ifndef DEF_Lifetime_each_MIllIWWADn7
                                #define DEF_Lifetime_each_MIllIWWADn7
inline static void Lifetime_each_MIll(/*F7:F7*/ fu::view<int> lt, /*E7:E3*/ int& locids, /*F7:F7*/ bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            int locid;
            if (r == Region_STATIC)
                goto BL_3;
            else if ((locid = Region_asLocal_MbR9(r)))
            {
                if (!isMovedFrom_MbR9(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}
                                #endif

int fu_MAIN()
{
    Lifetime_yI8e lt = Lifetime_yI8e { fu::vec<int> {{ 1001, 1, 1003 }} };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_MIll(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

========

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() {

            mut lt = Lifetime([ 1001, 1002, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Lifetime_yI8e;

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

                                #ifndef DEF_Lifetime_yI8e4Nvpayl
                                #define DEF_Lifetime_yI8e4Nvpayl
struct Lifetime_yI8e
{
                                // shape_hash:    adfcd672049d40bf
                                // non_triv_mask: 0008004000000000
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Region_asLocal_MbR9(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_MbR9(const int locid)
{
    return locid & 1;
}

                                #ifndef DEF_Lifetime_each_MIllIWWADn7
                                #define DEF_Lifetime_each_MIllIWWADn7
inline static void Lifetime_each_MIll(/*F7:F7*/ fu::view<int> lt, /*E7:E3*/ int& locids, /*F7:F7*/ bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            int locid;
            if (r == Region_STATIC)
                goto BL_3;
            else if ((locid = Region_asLocal_MbR9(r)))
            {
                if (!isMovedFrom_MbR9(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}
                                #endif

int fu_MAIN()
{
    Lifetime_yI8e lt = Lifetime_yI8e { fu::vec<int> {{ 1001, 1002, 1003 }} };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_MIll(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

========

        struct Overload { name: string };
        struct Target { globid: i32 };

        fn solve(overloads: Overload[], target: Target, BUG)
        {
            using fn GET(t: Target)
                overloads[t.globid];

            fn BUG2(topic: string)
                BUG(topic);

            fn relaxBlockVar(t: Target)
                BUG2(t.name.BUG2);

            return target.relaxBlockVar();
        }

        fn main() {
            try
                solve([ Overload("hello") ], Target(0), fn throw);
            catch (e)
                return e == "hello" ? 0 : 1;

            return 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>

struct Overload_BK87;
struct Target_9DUs;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_GET_utbjx3ZOloi
                                #define DEF_GET_utbjx3ZOloi
inline static const Overload_BK87& GET_utbj(/*3:3*/ const Target_9DUs& t, /*3:3*/ fu::view<Overload_BK87> overloads)
{
    return overloads[t.globid];
}
                                #endif

                                #ifndef DEF_BUG2_zAMh7T08Nf1
                                #define DEF_BUG2_zAMh7T08Nf1
[[noreturn]] inline static fu::never BUG2_zAMh(/*1:1*/ fu::vec_range<char> topic)
{
    fu::fail(fu::str(topic));
}
                                #endif

                                #ifndef DEF_relaxBlockVar_BfcxDKt2Cn3
                                #define DEF_relaxBlockVar_BfcxDKt2Cn3
[[noreturn]] inline static fu::never relaxBlockVar_Bfcx(/*3:3*/ const Target_9DUs& t, /*3:3*/ fu::view<Overload_BK87> overloads)
{
    BUG2_zAMh(GET_utbj(t, overloads).name);
}
                                #endif

                                #ifndef DEF_solve_lfzDB3T2irl
                                #define DEF_solve_lfzDB3T2irl
[[noreturn]] inline static fu::never solve_lfzD(/*7:7*/ fu::view<Overload_BK87> overloads, /*7:7*/ const Target_9DUs& target)
{
    relaxBlockVar_Bfcx(target, overloads);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
    {
        solve_lfzD(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("hello"_fu) } }}, Target_9DUs { 0 });
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "hello"_view)
            return 0;
        else
            return 1;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall, N_NonTrivAutoCopy

========

        struct Overload { name: string };
        struct Target { globid: i32 };

        fn solve(overloads: Overload[], target: Target, BUG)
        {
            using fn GET(t: Target)
                overloads[t.globid];

            fn BUG2(inline topic: string)
                BUG(topic);

            fn relaxBlockVar(t: Target)
                BUG2(t.name.BUG2);

            return target.relaxBlockVar();
        }

        fn main() {
            try
                solve([ Overload("hello") ], Target(0), fn throw);
            catch (e)
                return e == "hello" ? 0 : 1;

            return 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>

struct Overload_BK87;
struct Target_9DUs;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_9DUsVseuILe
                                #define DEF_Target_9DUsVseuILe
struct Target_9DUs
{
                                // shape_hash:    b084bb44696f70ca
                                // non_triv_mask: 0000000000000000
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_GET_utbjx3ZOloi
                                #define DEF_GET_utbjx3ZOloi
inline static const Overload_BK87& GET_utbj(/*3:3*/ const Target_9DUs& t, /*3:3*/ fu::view<Overload_BK87> overloads)
{
    return overloads[t.globid];
}
                                #endif

                                #ifndef DEF_relaxBlockVar_bTibsHJfjad
                                #define DEF_relaxBlockVar_bTibsHJfjad
[[noreturn]] inline static fu::never relaxBlockVar_bTib(/*3:3*/ const Target_9DUs& t, /*3:3*/ fu::view<Overload_BK87> overloads)
{
    fu::fail(fu::str(GET_utbj(t, overloads).name));
}
                                #endif

                                #ifndef DEF_solve_XaJv6TDA0nd
                                #define DEF_solve_XaJv6TDA0nd
[[noreturn]] inline static fu::never solve_XaJv(/*7:7*/ fu::view<Overload_BK87> overloads, /*7:7*/ const Target_9DUs& target)
{
    relaxBlockVar_bTib(target, overloads);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
    {
        solve_XaJv(fu::view<Overload_BK87> {{ Overload_BK87 { fu::str("hello"_fu) } }}, Target_9DUs { 0 });
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "hello"_view)
            return 0;
        else
            return 1;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy

========

        let SELF_TEST = false;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
              { result ~= value * 2; }                      

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = false;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___cWUyJOMjooe
                                #define DEF___cWUyJOMjooe
inline static void _cWUy(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    result += (value * 2);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_CIdvVzvxyv4
                                #define DEF_assertPathsValid_CIdvVzvxyv4
inline static void assertPathsValid_CIdv(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    if (SELF_TEST)
        for (int i = 0; i < lt.size(); i++)
            _YomX(lt[i], minPathDepth);
;
}
                                #endif

                                #ifndef DEF___F4Q82xAXnxk
                                #define DEF___F4Q82xAXnxk
inline static void _F4Q8(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _cWUy(value, result);
    assertPathsValid_CIdv(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _F4Q8(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let SELF_TEST = false;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
              { result ~= value * 2; }                      

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___cWUyJOMjooe
                                #define DEF___cWUyJOMjooe
inline static void _cWUy(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    result += (value * 2);
}
                                #endif

                                #ifndef DEF___6VkQGcSrS4d
                                #define DEF___6VkQGcSrS4d
inline static void _6VkQ(const int value, /*3:3*/ fu::vec<int>& result)
{
    _cWUy(value, result);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _6VkQ(lt[i], result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_UnusedLet, N_SD_HasStaticInit

========

        let SELF_TEST = false;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
                result ~= value * 2;                        

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = false;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___3UzeXllE5cf
                                #define DEF___3UzeXllE5cf
inline static fu::view<int> _3Uze(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    return (result += (value * 2));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_CIdvVzvxyv4
                                #define DEF_assertPathsValid_CIdvVzvxyv4
inline static void assertPathsValid_CIdv(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    if (SELF_TEST)
        for (int i = 0; i < lt.size(); i++)
            _YomX(lt[i], minPathDepth);
;
}
                                #endif

                                #ifndef DEF___ba50IivDRz6
                                #define DEF___ba50IivDRz6
inline static void _ba50(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _3Uze(value, result);
    assertPathsValid_CIdv(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _ba50(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let SELF_TEST = false;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
                result ~= value * 2;                        

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___3UzeXllE5cf
                                #define DEF___3UzeXllE5cf
inline static fu::view<int> _3Uze(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    return (result += (value * 2));
}
                                #endif

                                #ifndef DEF___YpqwaJhzxgb
                                #define DEF___YpqwaJhzxgb
inline static void _Ypqw(const int value, /*3:3*/ fu::vec<int>& result)
{
    _3Uze(value, result);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _Ypqw(lt[i], result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedImplicit, N_UnusedCall, N_UnusedLet, N_SD_HasStaticInit

========

        let SELF_TEST = true;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
              { result ~= value * 2; }                      

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = true;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___cWUyJOMjooe
                                #define DEF___cWUyJOMjooe
inline static void _cWUy(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    result += (value * 2);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_hCb0Co0wYHa
                                #define DEF_assertPathsValid_hCb0Co0wYHa
inline static void assertPathsValid_hCb0(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    if (SELF_TEST)
        for (int i = 0; i < lt.size(); i++)
            _YomX(lt[i], minPathDepth);
;
}
                                #endif

                                #ifndef DEF___Bqo5NddzXz4
                                #define DEF___Bqo5NddzXz4
inline static void _Bqo5(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _cWUy(value, result);
    assertPathsValid_hCb0(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _Bqo5(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let SELF_TEST = true;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
              { result ~= value * 2; }                      

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___cWUyJOMjooe
                                #define DEF___cWUyJOMjooe
inline static void _cWUy(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    result += (value * 2);
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_J26K5b4xun3
                                #define DEF_assertPathsValid_J26K5b4xun3
inline static void assertPathsValid_J26K(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    for (int i = 0; i < lt.size(); i++)
        _YomX(lt[i], minPathDepth);

}
                                #endif

                                #ifndef DEF___0ZfqcTT0Kb4
                                #define DEF___0ZfqcTT0Kb4
inline static void _0Zfq(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _cWUy(value, result);
    assertPathsValid_J26K(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _0Zfq(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let SELF_TEST = true;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
                result ~= value * 2;                        

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = true;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___3UzeXllE5cf
                                #define DEF___3UzeXllE5cf
inline static fu::view<int> _3Uze(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    return (result += (value * 2));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_hCb0Co0wYHa
                                #define DEF_assertPathsValid_hCb0Co0wYHa
inline static void assertPathsValid_hCb0(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    if (SELF_TEST)
        for (int i = 0; i < lt.size(); i++)
            _YomX(lt[i], minPathDepth);
;
}
                                #endif

                                #ifndef DEF___eoCzAy1uKhj
                                #define DEF___eoCzAy1uKhj
inline static void _eoCz(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _3Uze(value, result);
    assertPathsValid_hCb0(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _eoCz(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        let SELF_TEST = true;

        inline fn LT_each(lt: i32[..], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[..], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 ..], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  
                result ~= value * 2;                        

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___3UzeXllE5cf
                                #define DEF___3UzeXllE5cf
inline static fu::view<int> _3Uze(const int value, /*3:3*/ fu::vec_range_mut<int> result)
{
    return (result += (value * 2));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF___YomXkzV5yMl
                                #define DEF___YomXkzV5yMl
inline static void _YomX(const int value, /*3:3*/ const int minPathDepth)
{
    if (value < minPathDepth)
        fu::fail(x7E_rA00("BAD: "_view, fu::i64dec(value)));

}
                                #endif

                                #ifndef DEF_assertPathsValid_J26K5b4xun3
                                #define DEF_assertPathsValid_J26K5b4xun3
inline static void assertPathsValid_J26K(/*3:3*/ fu::view<int> lt, const int minPathDepth)
{
    for (int i = 0; i < lt.size(); i++)
        _YomX(lt[i], minPathDepth);

}
                                #endif

                                #ifndef DEF___hZfVxMaC0Tj
                                #define DEF___hZfVxMaC0Tj
inline static void _hZfV(const int value, /*7:7*/ const int minPathDepth, /*7:5*/ fu::vec<int>& result)
{
    const int result0 = result.size();
    _3Uze(value, result);
    assertPathsValid_J26K(fu::get_view(result, result0), minPathDepth);
}
                                #endif

static fu::vec<int> LT_double_MbR9(/*1:1*/ fu::view<int> lt)
{
    const int minPathDepth = 2;
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < lt.size(); i++)
        _hZfV(lt[i], minPathDepth, result);

    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    if (LT_double_MbR9(fu::view<int> {{ 1, 2, 3 }}) == fu::view<int> {{ 2, 4, 6 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        fn solve(ref TRACE_out: string, ref effect: int) {
            fn doTrySpecialize(what) {
                defer TRACE_out ~= "<" ~ effect++ ~ ">";
                what();
            }

            doTrySpecialize(|| {});
        }

        fn main() {
            mut TRACE_out = "";
            mut effect = 10;
            solve(:TRACE_out, :effect);
            return TRACE_out == "<10>" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_doTrySpecialize_IWWQElc3UQ2
                                #define DEF_doTrySpecialize_IWWQElc3UQ2
inline static void doTrySpecialize_IWWQ(/*7:7*/ fu::vec_range_mut<char> TRACE_out, /*7:5*/ int& effect)
{
    fu::str _0 {};
    (_0 = (x7E_rA00("<"_view, fu::i64dec(effect++)) + ">"_view), (TRACE_out += static_cast<fu::str&&>(_0)));
}
                                #endif

static void solve_MbR9(/*3:1*/ fu::vec_range_mut<char> TRACE_out, /*3:2*/ int& effect)
{
    doTrySpecialize_IWWQ(TRACE_out, effect);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str TRACE_out = fu::str(""_fu);
    int effect = 10;
    solve_MbR9(TRACE_out, effect);
    if (TRACE_out == "<10>"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_AARMustSeq

========

        fn solve(ref TRACE_out: string, ref effect: int) {
            fn doTrySpecialize(what) {
                defer TRACE_out ~= "<" ~ effect++ ~ ">";
                what();
            }

            doTrySpecialize(|| {});
        }

        fn main() {
            mut TRACE_out = "";
            mut effect = 10;
            solve(:TRACE_out, :effect);
            return TRACE_out == "<10>" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_doTrySpecialize_IWWQElc3UQ2
                                #define DEF_doTrySpecialize_IWWQElc3UQ2
inline static void doTrySpecialize_IWWQ(/*7:7*/ fu::vec_range_mut<char> TRACE_out, /*7:5*/ int& effect)
{
    fu::str _0 {};
    (_0 = (x7E_rA00("<"_view, fu::i64dec(effect++)) + ">"_view), (TRACE_out += static_cast<fu::str&&>(_0)));
}
                                #endif

static void solve_MbR9(/*3:1*/ fu::vec_range_mut<char> TRACE_out, /*3:2*/ int& effect)
{
    doTrySpecialize_IWWQ(TRACE_out, effect);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str TRACE_out {};
    int effect = 10;
    solve_MbR9(TRACE_out, effect);
    if (TRACE_out == "<10>"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_AARMustSeq

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg };                 // PointlessLocal

        fn main() TRACE_BRACKET(true, "hello" ~ 0) == "hello0" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str msg {};
    bool x;
    if ((x = true, (x ? (msg = x7E_rA00("hello"_view, fu::i64dec(0)), msg) : fu::view<char>{})) == "hello0"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg };                 // PointlessLocal

        fn main() TRACE_BRACKET(true, "hello" ~ 0) == "hello0" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str msg {};
    if ((msg = x7E_rA00("hello"_view, fu::i64dec(0)), msg) == "hello0"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg ~ msg };

        fn main() {
            mut count = 0;      
            noinline            
            fn woot() "hello" ~ (count++);
            let a = TRACE_BRACKET(false, woot);
            let b = TRACE_BRACKET(true, woot);
            return a ~ b == "hello0hello0" && count == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str woot_MbR9(/*1:1*/ int& count)
{
    return x7E_rA00("hello"_view, fu::i64dec(count++));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    int count = 0;
    bool x;
    fu::str msg {};
    fu::str a = (x = false, (x ? (msg = woot_MbR9(count), (msg + msg)) : fu::str{}));
    bool x_1;
    fu::str msg_1 {};
    fu::str b = (x_1 = true, (x_1 ? (msg_1 = woot_MbR9(count), (msg_1 + msg_1)) : fu::str{}));
    if (((a + b) == "hello0hello0"_view) && (count == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg ~ msg };

        fn main() {
            mut count = 0;      
            noinline            
            fn woot() "hello" ~ (count++);
            let a = TRACE_BRACKET(false, woot);
            let b = TRACE_BRACKET(true, woot);
            return a ~ b == "hello0hello0" && count == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str woot_MbR9(/*1:1*/ int& count)
{
    return x7E_rA00("hello"_view, fu::i64dec(count++));
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    int count = 0;
    fu::str a {};
    fu::str msg {};
    fu::str b = (msg = woot_MbR9(count), (msg + msg));
    if (((a + b) == "hello0hello0"_view) && (count == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg ~ msg };

        fn main() {
            mut count = 0;      
            inline              
            fn woot() "hello" ~ (count++);
            let a = TRACE_BRACKET(false, woot);
            let b = TRACE_BRACKET(true, woot);
            return a ~ b == "hello0hello0" && count == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    int count = 0;
    bool x;
    fu::str msg {};
    fu::str a = (x = false, (x ? (msg = x7E_rA00("hello"_view, fu::i64dec(count++)), (msg + msg)) : fu::str{}));
    bool x_1;
    fu::str msg_1 {};
    fu::str b = (x_1 = true, (x_1 ? (msg_1 = x7E_rA00("hello"_view, fu::i64dec(count++)), (msg_1 + msg_1)) : fu::str{}));
    if (((a + b) == "hello0hello0"_view) && (count == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn TRACE_BRACKET(x: bool, inline msg: string)
            x && { shadow let msg = msg; msg ~ msg };

        fn main() {
            mut count = 0;      
            inline              
            fn woot() "hello" ~ (count++);
            let a = TRACE_BRACKET(false, woot);
            let b = TRACE_BRACKET(true, woot);
            return a ~ b == "hello0hello0" && count == 1 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    int count = 0;
    fu::str a {};
    fu::str msg {};
    fu::str b = (msg = x7E_rA00("hello"_view, fu::i64dec(count++)), (msg + msg));
    if (((a + b) == "hello0hello0"_view) && (count == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct Target { _packed: u32 }
        inline fn globid(t: Target) i32(t._packed);

        fn solve(ref TRACE_out: string, a: Target, b: Target)
        {
            fn TRACE_BRACKET(inline msg: string) unwrap {
                mut len0: int;
                defer if (TRACE_out.len > len0) {
                    shadow let msg = msg;
                    TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");
                    TRACE_out ~= "</" ~ msg ~ ">";
                }
            }

            fn TRACE(msg: string) TRACE_out ~= msg;

            fn doTrySpecialize(mut target: Target, what) {
                mut mul = 10;
                TRACE_BRACKET("Hello " ~ (target.globid * mul++));
                what();
            }

            doTrySpecialize(a, || {});
            doTrySpecialize(b, || TRACE("World!"));
        }

        fn main() {
            mut TRACE_out = "";
            solve(:TRACE_out, Target(1), Target(2));
            return TRACE_out == "<Hello 20>World!</Hello 20>" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Target_9Uxv;

                                #ifndef DEF_Target_9UxvIHOHO9c
                                #define DEF_Target_9UxvIHOHO9c
struct Target_9Uxv
{
                                // shape_hash:    589af836568ad9d8
                                // non_triv_mask: 0000000000000000
    unsigned _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_doTrySpecialize_2eY9EDpxdNa
                                #define DEF_doTrySpecialize_2eY9EDpxdNa
inline static void doTrySpecialize_2eY9(/*7:7*/ const Target_9Uxv& target, /*7:7*/ fu::vec_range_mut<char> TRACE_out)
{
    int mul = 10;
    const int len0 {};
    if (TRACE_out.size() > len0)
    {
        const Target_9Uxv* t;
        fu::str msg = x7E_rA00("Hello "_view, fu::i64dec(((t = &(target), int((*t)._packed)) * mul++)));
        TRACE_out.splice(len0, 0, (("<"_view + msg) + ">"_view));
        TRACE_out += (("</"_view + msg) + ">"_view);
    };
}
                                #endif

static fu::view<char> TRACE_kGbb(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> TRACE_out)
{
    return (TRACE_out += msg);
}

                                #ifndef DEF___rEmIbSnHhEa
                                #define DEF___rEmIbSnHhEa
inline static fu::view<char> _rEmI(/*1:1*/ fu::vec_range_mut<char> TRACE_out)
{
    return TRACE_kGbb("World!"_view, TRACE_out);
}
                                #endif

                                #ifndef DEF_doTrySpecialize_y4mskS6Mzj9
                                #define DEF_doTrySpecialize_y4mskS6Mzj9
inline static void doTrySpecialize_y4ms(/*7:7*/ const Target_9Uxv& target, /*6:6*/ fu::vec_range_mut<char> TRACE_out)
{
    int mul = 10;
    const int len0 {};
    fu_DEFER(if (TRACE_out.size() > len0)
    {
        const Target_9Uxv* t;
        fu::str msg = x7E_rA00("Hello "_view, fu::i64dec(((t = &(target), int((*t)._packed)) * mul++)));
        TRACE_out.splice(len0, 0, (("<"_view + msg) + ">"_view));
        TRACE_out += (("</"_view + msg) + ">"_view);
    });
    _rEmI(TRACE_out);
}
                                #endif

static void solve_MbR9(/*3:3*/ fu::vec_range_mut<char> TRACE_out, /*7:7*/ const Target_9Uxv& a, /*7:7*/ const Target_9Uxv& b)
{
    doTrySpecialize_2eY9(a, TRACE_out);
    doTrySpecialize_y4ms(b, TRACE_out);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str TRACE_out = fu::str(""_fu);
    solve_MbR9(TRACE_out, Target_9Uxv { 1u }, Target_9Uxv { 2u });
    if (TRACE_out == "<Hello 20>World!</Hello 20>"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

========

        struct Target { _packed: u32 }
        inline fn globid(t: Target) i32(t._packed);

        fn solve(ref TRACE_out: string, a: Target, b: Target)
        {
            fn TRACE_BRACKET(inline msg: string) unwrap {
                mut len0: int;
                defer if (TRACE_out.len > len0) {
                    shadow let msg = msg;
                    TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");
                    TRACE_out ~= "</" ~ msg ~ ">";
                }
            }

            fn TRACE(msg: string) TRACE_out ~= msg;

            fn doTrySpecialize(mut target: Target, what) {
                mut mul = 10;
                TRACE_BRACKET("Hello " ~ (target.globid * mul++));
                what();
            }

            doTrySpecialize(a, || {});
            doTrySpecialize(b, || TRACE("World!"));
        }

        fn main() {
            mut TRACE_out = "";
            solve(:TRACE_out, Target(1), Target(2));
            return TRACE_out == "<Hello 20>World!</Hello 20>" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Target_9Uxv;

                                #ifndef DEF_Target_9UxvIHOHO9c
                                #define DEF_Target_9UxvIHOHO9c
struct Target_9Uxv
{
                                // shape_hash:    589af836568ad9d8
                                // non_triv_mask: 0000000000000000
    unsigned _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_doTrySpecialize_2eY9EDpxdNa
                                #define DEF_doTrySpecialize_2eY9EDpxdNa
inline static void doTrySpecialize_2eY9(/*7:7*/ const Target_9Uxv& target, /*7:7*/ fu::vec_range_mut<char> TRACE_out)
{
    int mul = 10;
    const int len0 {};
    if (TRACE_out.size() > len0)
    {
        const Target_9Uxv* t;
        fu::str msg = x7E_rA00("Hello "_view, fu::i64dec(((t = &(target), int((*t)._packed)) * mul++)));
        TRACE_out.splice(len0, 0, (("<"_view + msg) + ">"_view));
        TRACE_out += (("</"_view + msg) + ">"_view);
    };
}
                                #endif

static fu::view<char> TRACE_kGbb(/*3:3*/ fu::view<char> msg, /*2:2*/ fu::vec_range_mut<char> TRACE_out)
{
    return (TRACE_out += msg);
}

                                #ifndef DEF___rEmIbSnHhEa
                                #define DEF___rEmIbSnHhEa
inline static fu::view<char> _rEmI(/*1:1*/ fu::vec_range_mut<char> TRACE_out)
{
    return TRACE_kGbb("World!"_view, TRACE_out);
}
                                #endif

                                #ifndef DEF_doTrySpecialize_y4mskS6Mzj9
                                #define DEF_doTrySpecialize_y4mskS6Mzj9
inline static void doTrySpecialize_y4ms(/*7:7*/ const Target_9Uxv& target, /*6:6*/ fu::vec_range_mut<char> TRACE_out)
{
    int mul = 10;
    const int len0 {};
    fu_DEFER(if (TRACE_out.size() > len0)
    {
        const Target_9Uxv* t;
        fu::str msg = x7E_rA00("Hello "_view, fu::i64dec(((t = &(target), int((*t)._packed)) * mul++)));
        TRACE_out.splice(len0, 0, (("<"_view + msg) + ">"_view));
        TRACE_out += (("</"_view + msg) + ">"_view);
    });
    _rEmI(TRACE_out);
}
                                #endif

static void solve_MbR9(/*3:3*/ fu::vec_range_mut<char> TRACE_out, /*7:7*/ const Target_9Uxv& a, /*7:7*/ const Target_9Uxv& b)
{
    doTrySpecialize_2eY9(a, TRACE_out);
    doTrySpecialize_y4ms(b, TRACE_out);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str TRACE_out {};
    solve_MbR9(TRACE_out, Target_9Uxv { 1u }, Target_9Uxv { 2u });
    if (TRACE_out == "<Hello 20>World!</Hello 20>"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

========

        fn incr_do_incr(ref count: i32, inline do) {
            count++;
            count += do;
            count++;
        }

        fn main() {
            mut count = 0;
            try         incr_do_incr(count, throw("what"));
            catch (e)   count += 10 * e.len;
            return count - 41;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int count = 0;

    try
    {
    {
        count++;
        fu::fail(fu::str("what"_fu));
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        count += (10 * e.size());
    }
;
    return count - 41;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        struct Struct { items: Target[] };
        struct Target { index: i32 };
        struct Scope { type: Type };
        struct Type { canon: i32 };

        noinline fn doNothingCreatively(_types: Struct[], _out: string, _type: Type)
        {
            fn zeroInit(lax target: Target)
                return [];

            noinline fn noInline(type, ref out): string =
                return type && inlineOuter(type, :out);

            fn inlineOuter(inline type, ref out): string = {
                inlineInner(_types[type.canon], :out);
                return [];
            }

            fn inlineInner(inline s, ref out) {
                let fields = s.items;
                for (mut i = 0; i < fields.len; i++) {
                    lax let field = zeroInit(fields[i]);
                    lax let annot = noInline(field.type, :out);
                }
            }

            fn cgCopyOrMove(type: Type, ref out: string)
                inlineOuter(type, :out);

            return cgCopyOrMove(_type, _out);
        }

        fn main() {
            mut structs = [ Struct() ];
            mut out: string;
            doNothingCreatively(structs, out, []);
            return out.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str out {};
    return out.size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_UnusedCall, N_UnusedArrlit, N_UnusedLet

========

        fn main() {
            mut error = "Hello";
            fn matchFail(inline reason: string)
                if (error) error ~= reason || throw("-");

            matchFail(", w" ~ 0 ~ "rld!");
            return error == "Hello, w0rld!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str error = fu::str("Hello"_fu);
    if (error)
    {
        fu::str reason {};
        fu::view<char> _0 {};
        error += ((_0.ptr_reassign((reason = (x7E_rA00(", w"_view, fu::i64dec(0)) + "rld!"_view)))) ? _0 : fu::fail(fu::str("-"_fu)));
    };
    if (error == "Hello, w0rld!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn orNodeTypeExpectsRefGotValue(ref error!: string, args?: int[]) {
            fn matchFail(inline reason: string)
                if (error) error ~= reason || throw("-");

            for (mut i = 0; i < args.len; i++) {
                mut arg = args[i];
                if (!arg) matchFail(", w" ~ i ~ "rld!");
            }

            return [];
        }

        fn main() {
            mut error = "Hello";
            orNodeTypeExpectsRefGotValue(:error, [ 0 ]);
            return error == "Hello, w0rld!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

static void orNodeTypeExpectsRefGotValue_MbR9(/*1:1*/ fu::vec_range_mut<char> error, /*3:3*/ fu::view<int> args)
{
    for (int i = 0; i < args.size(); i++)
    {
        const int /*args|static*/ arg = args[i];
        if (!arg)
        {
            if (error)
            {
                fu::str reason {};
                fu::view<char> _0 {};
                error += ((_0.ptr_reassign((reason = (x7E_rA00(", w"_view, fu::i64dec(i)) + "rld!"_view)))) ? _0 : fu::fail(fu::str("-"_fu)));
            };
        };
    };
    return;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str error = fu::str("Hello"_fu);
    orNodeTypeExpectsRefGotValue_MbR9(error, fu::view<int> {{ 0 }});
    if (error == "Hello, w0rld!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn letdefUnwrapsDuringMCOM(
            ref error: string, ref effect: int,
            a: string, b: string, c: string) {

            fn inl4(inline err) if (error) error ~= err;
            fn inl3(inline err) inl4(:err);
            fn inl2(inline err) inl3(:err);
            fn inl1(inline err) inl2(:err);

            inl1("ello");
            inl2({ effect++; a ~ b });
            inl3("World");
            inl4(c);
        }

        fn main() {
            mut error: string;
            mut effect: int;
            letdefUnwrapsDuringMCOM(:error, :effect, ",", " ", "!");
            if (effect || error) return 101;

            error = "H";
            letdefUnwrapsDuringMCOM(:error, :effect, ",", " ", "!");
            return effect == 1 && error == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void letdefUnwrapsDuringMCOM_MbR9(/*3:1*/ fu::vec_range_mut<char> error, /*3:2*/ int& effect, /*F1:F1*/ fu::view<char> a, /*F1:F1*/ fu::view<char> b, /*F1:F1*/ fu::view<char> c)
{
    if (error)
        error += "ello"_view;

    if (error)
    {
        fu::str _0 {};
        (_0 = (effect++, (a + b)), (error += static_cast<fu::str&&>(_0)));
    };
    if (error)
        error += "World"_view;

    if (error)
        error += c;

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str error {};
    int effect {};
    letdefUnwrapsDuringMCOM_MbR9(error, effect, ","_view, " "_view, "!"_view);
    if (effect || error)
        return 101;
    else
    {
        error = fu::str("H"_fu);
        letdefUnwrapsDuringMCOM_MbR9(error, effect, ","_view, " "_view, "!"_view);
        if ((effect == 1) && (error == "Hello, World!"_view))
            return 0;
        else
            return 1;

    };
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

========

        fn letdefUnwrapsDuringMCOM(
            ref error: string, ref effect: int,
            a: string, b: string, c: string) {

            fn inl4(inline err: string) if (error) error ~= err;
            fn inl3(inline err: string) inl4(:err);
            fn inl2(inline err: string) inl3(:err);
            fn inl1(inline err: string) inl2(:err);

            inl1("ello");
            inl2({ effect++; a ~ b });
            inl3("World");
            inl4(c);
        }

        fn main() {
            mut error: string;
            mut effect: int;
            letdefUnwrapsDuringMCOM(:error, :effect, ",", " ", "!");
            if (effect || error) return 101;

            error = "H";
            letdefUnwrapsDuringMCOM(:error, :effect, ",", " ", "!");
            return effect == 1 && error == "Hello, World!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void letdefUnwrapsDuringMCOM_MbR9(/*3:1*/ fu::vec_range_mut<char> error, /*3:2*/ int& effect, /*F1:F1*/ fu::view<char> a, /*F1:F1*/ fu::view<char> b, /*F1:F1*/ fu::view<char> c)
{
    if (error)
        error += "ello"_view;

    if (error)
    {
        fu::str _0 {};
        (_0 = (effect++, (a + b)), (error += static_cast<fu::str&&>(_0)));
    };
    if (error)
        error += "World"_view;

    if (error)
        error += c;

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str error {};
    int effect {};
    letdefUnwrapsDuringMCOM_MbR9(error, effect, ","_view, " "_view, "!"_view);
    if (effect || error)
        return 101;
    else
    {
        error = fu::str("H"_fu);
        letdefUnwrapsDuringMCOM_MbR9(error, effect, ","_view, " "_view, "!"_view);
        if ((effect == 1) && (error == "Hello, World!"_view))
            return 0;
        else
            return 1;

    };
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

========

        inline fn test(inline hey: int) hey;
        fn main() 1.test && 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (1)
        return 0;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_McomUnwrapsLetdef

========

        inline fn test(inline hey: int) hey;
        fn main() 1.test && 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn ALWAYS_TRUE(inline assertion) assertion;

        fn solve(ref overloads: int[]) {
            fn GET(t: int)
                t >= 0 && t < overloads.len && overloads[t];

            fn _current_fn_eachArg(visit) {
                for (mut i = 0; i < overloads.len; i++) {
                    let t = overloads[i];
                    if (t.GET.ALWAYS_TRUE)
                        visit(i?: i);
                }
            }

            mut mask = u32();
            _current_fn_eachArg: |i| mask |= (1 << (i.u32 & 31));
            return mask;
        }

        fn main() solve([ 1, 2 ]) == 1 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int GET_MbR9(const int t, /*3:3*/ fu::view<int> overloads)
{
    if ((t >= 0) && (t < overloads.size()))
        return overloads[t];
    else
        return 0;

}

                                #ifndef DEF___ZfB0RLditEg
                                #define DEF___ZfB0RLditEg
inline static unsigned _ZfB0(const int i, /*3:3*/ unsigned& mask)
{
    return (mask |= (1u << (unsigned(i) & 31u)));
}
                                #endif

                                #ifndef DEF__current_fn_eachArg_U0WpDVYRIkl
                                #define DEF__current_fn_eachArg_U0WpDVYRIkl
inline static void _current_fn_eachArg_U0Wp(/*7:7*/ fu::view<int> overloads, /*7:5*/ unsigned& mask)
{
    for (int i = 0; i < overloads.size(); i++)
    {
        const int /*overloads|static*/ t = overloads[i];
        if (GET_MbR9(t, overloads))
            _ZfB0(i, mask);

    };
}
                                #endif

static unsigned solve_MbR9(/*1:1*/ fu::view<int> overloads)
{
    unsigned mask = 0u;
    _current_fn_eachArg_U0Wp(overloads, mask);
    return mask;
}

int fu_MAIN()
{
    if (solve_MbR9(fu::view<int> {{ 1, 2 }}) == 1u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_McomUnwrapsLetdef

========

        fn unwrapCall(what) unwrap { defer what() }

        fn main() {
            mut res = 0;
            unwrapCall(|| res++);
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___5inzhtc1y8f
                                #define DEF___5inzhtc1y8f
inline static int _5inz(/*1:1*/ int& res)
{
    return res++;
}
                                #endif

int fu_MAIN()
{
    int res = 0;
    fu_DEFER(_5inz(res));
    return res;
}

#endif

int main() { return fu_MAIN(); }

========

        fn unwrapCall(what) unwrap { defer what() }

        fn main() {
            mut res = -1;
            { unwrapCall(|| res++); }
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___5inzhtc1y8f
                                #define DEF___5inzhtc1y8f
inline static int _5inz(/*1:1*/ int& res)
{
    return res++;
}
                                #endif

int fu_MAIN()
{
    int res = -1;
    _5inz(res);
    return res;
}

#endif

int main() { return fu_MAIN(); }

========

        fn unwrapCall(what) unwrap { defer what() }

        fn main() {
            mut res = -1; 
            fn trackVarUsage(what) unwrapCall(fn what);             
            trackVarUsage(|| res++);
            return res;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:36+10[0m:

[2m      |         fn main() {[0m
[2m      |             mut res = -1; [0m
[2m    6 | [0m            fn trackVarUsage(what) [31;1munwrapCall[0m(fn what);             
[2m      |             trackVarUsage(|| res++);[0m
[2m      |             return res;[0m

	Attempting to use an [35;3munwrap[0m [35;3minline[0m [94;1munwrapCall[0m as a value.

	Unwrapping here would complete any defers inside immediately.

	If this is intended, wrap it in a block to disambiguate.

       RelaxMut [35;3mfn[0m [94;1mtrackVarUsage[0m([35;3m@140[0m) at [2m6:16+13[0m
        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        fn unwrapCall(what) unwrap { defer what() }

        fn main() {
            mut res = -1; 
            fn trackVarUsage(what) { unwrapCall(fn what); }         
            trackVarUsage(|| res++);
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___5inzhtc1y8f
                                #define DEF___5inzhtc1y8f
inline static int _5inz(/*1:1*/ int& res)
{
    return res++;
}
                                #endif

                                #ifndef DEF_trackVarUsage_Qz3Ggtt4ndc
                                #define DEF_trackVarUsage_Qz3Ggtt4ndc
inline static void trackVarUsage_Qz3G(/*3:3*/ int& res)
{
    _5inz(res);
}
                                #endif

int fu_MAIN()
{
    int res = -1;
    trackVarUsage_Qz3G(res);
    return res;
}

#endif

int main() { return fu_MAIN(); }

========
                                  
        struct sA(type T) { hey: T; };      

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sA_yem7;

                                #ifndef DEF_sA_yem7Qu86qYa
                                #define DEF_sA_yem7Qu86qYa
struct sA_yem7
{
                                // shape_hash:    6236b402d70c3df7
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_fA_gRjNWgXlnQi
                                #define DEF_fA_gRjNWgXlnQi
inline static sA_yem7 fA_gRjN(const int a)
{
    return sA_yem7 { (a + 2) };
}
                                #endif

int fu_MAIN()
{
    return fA_gRjN(1).hey - 3;
}

#endif

int main() { return fu_MAIN(); }

========
                                  
        struct sA(_: $T) { hey: $T; };      

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sA_yem7;

                                #ifndef DEF_sA_yem7Qu86qYa
                                #define DEF_sA_yem7Qu86qYa
struct sA_yem7
{
                                // shape_hash:    6236b402d70c3df7
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_fA_gRjNWgXlnQi
                                #define DEF_fA_gRjNWgXlnQi
inline static sA_yem7 fA_gRjN(const int a)
{
    return sA_yem7 { (a + 2) };
}
                                #endif

int fu_MAIN()
{
    return fA_gRjN(1).hey - 3;
}

#endif

int main() { return fu_MAIN(); }

========
                                  
        fn sA(type T) struct { hey: T; };   

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sA_yem7;

                                #ifndef DEF_sA_yem7Qu86qYa
                                #define DEF_sA_yem7Qu86qYa
struct sA_yem7
{
                                // shape_hash:    6236b402d70c3df7
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_fA_gRjNWgXlnQi
                                #define DEF_fA_gRjNWgXlnQi
inline static sA_yem7 fA_gRjN(const int a)
{
    return sA_yem7 { (a + 2) };
}
                                #endif

int fu_MAIN()
{
    return fA_gRjN(1).hey - 3;
}

#endif

int main() { return fu_MAIN(); }

========
                                  
        fn sA(_: $T) struct { hey: $T; };   

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sA_yem7;

                                #ifndef DEF_sA_yem7Qu86qYa
                                #define DEF_sA_yem7Qu86qYa
struct sA_yem7
{
                                // shape_hash:    6236b402d70c3df7
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_fA_gRjNWgXlnQi
                                #define DEF_fA_gRjNWgXlnQi
inline static sA_yem7 fA_gRjN(const int a)
{
    return sA_yem7 { (a + 2) };
}
                                #endif

int fu_MAIN()
{
    return fA_gRjN(1).hey - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey   ;

---- <fail> ----
[2m[0m_0[2m.fu 5:28+1[0m:

[2m      | [0m
[2m      |         fn fB(a: $T): sB($T) = [ a + 2 ];[0m
[2m    5 | [0m        fn main() 1.fB.hey [31;1m-[0m 1.u32.fB.hey   ;
[2m      | [0m

	Bad call to [94;1m-[0m with args ([35;3mi32[0m, [35;3mu32[0m): 

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m-[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi32[0m <-> [35;3mu32[0m

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey   
                              .i32          ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sB_7vGo;
struct sB_ldES;

                                #ifndef DEF_sB_7vGo7Wr0gLj
                                #define DEF_sB_7vGo7Wr0gLj
struct sB_7vGo
{
                                // shape_hash:    163414b9c92de26e
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_sB_ldESasC83H1
                                #define DEF_sB_ldESasC83H1
struct sB_ldES
{
                                // shape_hash:    bcf6a8e1dbd3cb31
                                // non_triv_mask: 0000000000000000
    unsigned hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_fB_Pw23jUOljP9
                                #define DEF_fB_Pw23jUOljP9
inline static sB_7vGo fB_Pw23(const int a)
{
    return sB_7vGo { (a + 2) };
}
                                #endif

                                #ifndef DEF_fB_KdK647W2y6e
                                #define DEF_fB_KdK647W2y6e
inline static sB_ldES fB_KdK6(const unsigned a)
{
    return sB_ldES { (a + 2u) };
}
                                #endif

int fu_MAIN()
{
    return fB_Pw23(1).hey - int(fB_KdK6(unsigned(1)).hey);
}

#endif

int main() { return fu_MAIN(); }

========

        fn sB(_: $T) struct { hey: $T; };

        // Prep for the thing below.
        fn test(x) x.hey - 1;

        // 'a' must be callable.
        type a = sB(i32);
        fn main() a(1).test;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sB_7vGo;

                                #ifndef DEF_sB_7vGo7Wr0gLj
                                #define DEF_sB_7vGo7Wr0gLj
struct sB_7vGo
{
                                // shape_hash:    163414b9c92de26e
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_tEvXEVXZP6c
                                #define DEF_test_tEvXEVXZP6c
inline static int test_tEvX(/*1:1*/ const sB_7vGo& x)
{
    return x.hey - 1;
}
                                #endif

int fu_MAIN()
{
    return test_tEvX(sB_7vGo { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn setupOperators(i: i32) {
            struct BINOP { i: i32; };
            return BINOP(:i);
        }

        fn main() setupOperators(0).i;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct BINOP_WwnZ;

                                #ifndef DEF_BINOP_WwnZ11g8Q6g
                                #define DEF_BINOP_WwnZ11g8Q6g
struct BINOP_WwnZ
{
                                // shape_hash:    e5a268add35a5abb
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static BINOP_WwnZ setupOperators_MbR9(const int i)
{
    return BINOP_WwnZ { i };
}

int fu_MAIN()
{
    return setupOperators_MbR9(0).i;
}

#endif

int main() { return fu_MAIN(); }

========

        fn sB(_: $T) struct { hey: $T; };

        fn setupOperators(i: i32) {
            struct BINOP { i: sB(i32); };
            mut s: sB(i32) = [ i ];
            return BINOP(s);
        }

        fn main() setupOperators(0).i.hey;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct BINOP_8J91;
struct sB_7vGo;

                                #ifndef DEF_sB_7vGo7Wr0gLj
                                #define DEF_sB_7vGo7Wr0gLj
struct sB_7vGo
{
                                // shape_hash:    163414b9c92de26e
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_BINOP_8J91rEroAGg
                                #define DEF_BINOP_8J91rEroAGg
struct BINOP_8J91
{
                                // shape_hash:    a74fb95278ccc52c
                                // non_triv_mask: 0000000000000000
    sB_7vGo i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static BINOP_8J91 setupOperators_MbR9(const int i)
{
    const sB_7vGo s = sB_7vGo { i };
    return BINOP_8J91 { sB_7vGo(s) };
}

int fu_MAIN()
{
    return setupOperators_MbR9(0).i.hey;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code
        fn get(s: Hey) s.i;

        fn main() {
            mut s: _0::Hey;
            return s.get();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;
int get_MbR9(const Hey_Nwzp&);

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Hey_Nwzp s {};
    return get_MbR9(s);
}

#endif

int main() { return fu_MAIN(); }
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Hey_Nwzp Hey_MbR9()
{
    return Hey_Nwzp{};
}

int get_MbR9(/*1:1*/ const Hey_Nwzp& s)
{
    return s.i;
}

#endif

========

        fn Hey(_: $T) = struct { i: $T };
        fn get(s) s.i;

        fn main() {
            mut s: _0::Hey(i32);
            return s.get(); // get(): wasn't visible, the struct didnt remember its template origin module.
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_Nwzp;

                                #ifndef DEF_Hey_Nwzp1zcVY6c
                                #define DEF_Hey_Nwzp1zcVY6c
struct Hey_Nwzp
{
                                // shape_hash:    5e5a879155d451d8
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_get_UcEqGNsGqbf
                                #define DEF_get_UcEqGNsGqbf
inline int get_UcEq(/*1:1*/ const Hey_Nwzp& s)
{
    return s.i;
}
                                #endif

int fu_MAIN()
{
    const Hey_Nwzp s {};
    return get_UcEq(s);
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(_: $T) = struct { v: $T };

        fn unwrap(h: _0::Hey(i32)) = h.v * 10;

        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];

        fn main() = _1::unwrap(_2::wrap(4)) - 70;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_18Sg;
struct Hey_18Sg;
Hey_18Sg wrap_WLF9(int);
int unwrap_LtD7(const Hey_18Sg&);

                                #ifndef DEF_Hey_18SgkdJlEPl
                                #define DEF_Hey_18SgkdJlEPl
struct Hey_18Sg
{
                                // shape_hash:    9a65e31b3f8ad4ef
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_18SgkdJlEPl
                                #define DEF_Hey_18SgkdJlEPl
struct Hey_18Sg
{
                                // shape_hash:    9a65e31b3f8ad4ef
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return unwrap_LtD7(wrap_WLF9(4)) - 70;
}

#endif

int main() { return fu_MAIN(); }
struct Hey_18Sg;

                                #ifndef DEF_Hey_18SgkdJlEPl
                                #define DEF_Hey_18SgkdJlEPl
struct Hey_18Sg
{
                                // shape_hash:    9a65e31b3f8ad4ef
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int unwrap_LtD7(/*1:1*/ const Hey_18Sg& h)
{
    return h.v * 10;
}

#endif
struct Hey_18Sg;

                                #ifndef DEF_Hey_18SgkdJlEPl
                                #define DEF_Hey_18SgkdJlEPl
struct Hey_18Sg
{
                                // shape_hash:    9a65e31b3f8ad4ef
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Hey_18Sg wrap_WLF9(const int v)
{
    return Hey_18Sg { (v + 3) };
}

#endif

========

        fn Hello(_: $T) struct { world: $T };

        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];

        fn hello(x: i32) _1::getHello(x + 3);

        fn main() _2::hello(2).world - 25;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_CJFE;
Hello_CJFE hello_WLF9(int);

                                #ifndef DEF_Hello_CJFEjgTFV75
                                #define DEF_Hello_CJFEjgTFV75
struct Hello_CJFE
{
                                // shape_hash:    0e8a5af7d285abb3
                                // non_triv_mask: 0000000000000000
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return hello_WLF9(2).world - 25;
}

#endif

int main() { return fu_MAIN(); }
struct Hello_CJFE;
Hello_CJFE getHello_LtD7(int);

                                #ifndef DEF_Hello_CJFEjgTFV75
                                #define DEF_Hello_CJFEjgTFV75
struct Hello_CJFE
{
                                // shape_hash:    0e8a5af7d285abb3
                                // non_triv_mask: 0000000000000000
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Hello_CJFE hello_WLF9(const int x)
{
    return getHello_LtD7((x + 3));
}

#endif
struct Hello_CJFE;

                                #ifndef DEF_Hello_CJFEjgTFV75
                                #define DEF_Hello_CJFEjgTFV75
struct Hello_CJFE
{
                                // shape_hash:    0e8a5af7d285abb3
                                // non_triv_mask: 0000000000000000
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Hello_CJFE getHello_LtD7(const int x)
{
    return Hello_CJFE { (x * x) };
}

#endif

========

        fn sB(_: $T) struct { hey: $T; };

        // Pattern & partial spec, how?
        fn test(x: sB($T)): $T = x.hey - 1;


        fn main() sB(i32)(1).test;


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sB_7vGo;

                                #ifndef DEF_sB_7vGo7Wr0gLj
                                #define DEF_sB_7vGo7Wr0gLj
struct sB_7vGo
{
                                // shape_hash:    163414b9c92de26e
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_tEvXEVXZP6c
                                #define DEF_test_tEvXEVXZP6c
inline static int test_tEvX(/*1:1*/ const sB_7vGo& x)
{
    return x.hey - 1;
}
                                #endif

int fu_MAIN()
{
    return test_tEvX(sB_7vGo { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn sB(_: $T) struct { hey: $T; };

        // Pattern & partial spec, how?
        fn test(x: sB($T)): $T = x.hey - 1;


        type a = sB(i32);
        fn main() a(1).test;


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct sB_7vGo;

                                #ifndef DEF_sB_7vGo7Wr0gLj
                                #define DEF_sB_7vGo7Wr0gLj
struct sB_7vGo
{
                                // shape_hash:    163414b9c92de26e
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_test_tEvXEVXZP6c
                                #define DEF_test_tEvXEVXZP6c
inline static int test_tEvX(/*1:1*/ const sB_7vGo& x)
{
    return x.hey - 1;
}
                                #endif

int fu_MAIN()
{
    return test_tEvX(sB_7vGo { 1 });
}

#endif

int main() { return fu_MAIN(); }

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline static M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

static M_FUNS add_MbR9(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

                                #ifndef DEF_incr_by_Wh3cyYxUvz8
                                #define DEF_incr_by_Wh3cyYxUvz8
inline static const M_FUNS& incr_by_Wh3c(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_MbR9(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_Wh3c(a, b);
    incr_by_Wh3c(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _0;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_MbR9(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_Wh3cyYxUvz8
                                #define DEF_incr_by_Wh3cyYxUvz8
inline const M_FUNS& incr_by_Wh3c(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_MbR9(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_Wh3c(a, b);
    incr_by_Wh3c(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_MbR9(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_MbR9(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_Wh3cyYxUvz8
                                #define DEF_incr_by_Wh3cyYxUvz8
inline const M_FUNS& incr_by_Wh3c(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_MbR9(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_Wh3c(a, b);
    incr_by_Wh3c(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_MbR9(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_MbR9(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_Wh3cyYxUvz8
                                #define DEF_incr_by_Wh3cyYxUvz8
inline const M_FUNS& incr_by_Wh3c(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_MbR9(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_Wh3c(a, b);
    incr_by_Wh3c(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_MbR9(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline static M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

static M_FUNS add_LtD7(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

                                #ifndef DEF_incr_by_RTQuZZ5KiE2
                                #define DEF_incr_by_RTQuZZ5KiE2
inline static const M_FUNS& incr_by_RTQu(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_LtD7(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_RTQu(a, b);
    incr_by_RTQu(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_LtD7(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_RTQuZZ5KiE2
                                #define DEF_incr_by_RTQuZZ5KiE2
inline const M_FUNS& incr_by_RTQu(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_LtD7(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_RTQu(a, b);
    incr_by_RTQu(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_LtD7(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_LtD7(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_RTQuZZ5KiE2
                                #define DEF_incr_by_RTQuZZ5KiE2
inline const M_FUNS& incr_by_RTQu(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_LtD7(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_RTQu(a, b);
    incr_by_RTQu(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_LtD7(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _2;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;
struct M_FUNS;
M_FUNS add_LtD7(const M_FUNS&, const M_FUNS&);

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_RTQuZZ5KiE2
                                #define DEF_incr_by_RTQuZZ5KiE2
inline const M_FUNS& incr_by_RTQu(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_LtD7(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_RTQu(a, b);
    incr_by_RTQu(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

M_FUNS add_LtD7(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}

#endif

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline static M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline static M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline static const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _0;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline static M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline static M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline static const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline static M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _2;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct M_FUNS;

                                #ifndef DEF_M_FUNSj4y5Sa2
                                #define DEF_M_FUNSj4y5Sa2
struct M_FUNS
{
                                // shape_hash:    d760ea599c876591
                                // non_triv_mask: 0000000000000000
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_itRZ4Q4qWci
                                #define DEF_KK_itRZ4Q4qWci
inline M_FUNS KK_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_VV_itRZ4Q4qWci
                                #define DEF_VV_itRZ4Q4qWci
inline M_FUNS VV_itRZ(const unsigned k, const unsigned v)
{
    return M_FUNS { k, v };
}
                                #endif

                                #ifndef DEF_add_oF9c1PkDXwa
                                #define DEF_add_oF9c1PkDXwa
inline M_FUNS add_oF9c(/*3:3*/ const M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return M_FUNS { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_iUVbcWZ5VJf
                                #define DEF_incr_by_iUVbcWZ5VJf
inline const M_FUNS& incr_by_iUVb(/*3:3*/ M_FUNS& a, /*3:3*/ const M_FUNS& b)
{
    return (a = add_oF9c(a, b));
}
                                #endif

int fu_MAIN()
{
    M_FUNS a = KK_itRZ(0x1u, 2u);
    M_FUNS b = VV_itRZ(3u, 0x4u);
    incr_by_iUVb(a, b);
    incr_by_iUVb(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Hey(_: $T) struct { hey: $T; };

        fn hello(x: i32) x * 10;
        fn hello(x: Hey(i32)) x.hey * 100;
        fn hello(x: Hey($T)) case ($T.is::unsigned) x.hey * 1000;

        fn main() hello(1)
                + hello([ 1 ]   => Hey(i32))
                + hello([ 0x1 ] => Hey(u32)).i32
                    - 1110;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_YvB1;
struct Hey_Kj23;

                                #ifndef DEF_Hey_YvB1ZnGFuL3
                                #define DEF_Hey_YvB1ZnGFuL3
struct Hey_YvB1
{
                                // shape_hash:    a3dc02ccf8d8ddb2
                                // non_triv_mask: 0000000000000000
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_Kj23rHTjnD0
                                #define DEF_Hey_Kj23rHTjnD0
struct Hey_Kj23
{
                                // shape_hash:    84998230c7bb5670
                                // non_triv_mask: 0000000000000000
    unsigned hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_MbR9(const int x)
{
    return x * 10;
}

static int hello_kGbb(/*1:1*/ const Hey_YvB1& x)
{
    return x.hey * 100;
}

                                #ifndef DEF_hello_AyIFqo5Pu2g
                                #define DEF_hello_AyIFqo5Pu2g
inline static unsigned hello_AyIF(/*1:1*/ const Hey_Kj23& x)
{
    return x.hey * 1000u;
}
                                #endif

int fu_MAIN()
{
    return ((hello_MbR9(1) + hello_kGbb(Hey_YvB1 { 1 })) + int(hello_AyIF(Hey_Kj23 { 0x1u }))) - 1110;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(_: $T) struct { hey: $T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hey_fY4H;

                                #ifndef DEF_Hey_fY4HrDK3kW7
                                #define DEF_Hey_fY4HrDK3kW7
struct Hey_fY4H
{
                                // shape_hash:    f115ce634928d7c5
                                // non_triv_mask: 0008000800000000
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_3yNQBWp3Wz5
                                #define DEF_Hey_3yNQBWp3Wz5
inline static Hey_fY4H Hey_3yNQ()
{
    return Hey_fY4H{};
}
                                #endif

int fu_MAIN()
{
    Hey_fY4H _ = Hey_3yNQ();
    return _.hey.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn Hey(type T) struct { hey: T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hey_fY4H;

                                #ifndef DEF_Hey_fY4HrDK3kW7
                                #define DEF_Hey_fY4HrDK3kW7
struct Hey_fY4H
{
                                // shape_hash:    f115ce634928d7c5
                                // non_triv_mask: 0008000800000000
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_hRUxwwJHst0
                                #define DEF_Hey_hRUxwwJHst0
inline static Hey_fY4H Hey_hRUx()
{
    return Hey_fY4H{};
}
                                #endif

int fu_MAIN()
{
    Hey_fY4H _ = Hey_hRUx();
    return _.hey.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn Hey !T(type T)
            case (T.is::arithmetic) = struct { hello: T };
            default                 = struct { world: T };

        fn main() {
            using let _a = Hey(i32);
            using let _b = Hey(i32[]);
            return hello + world.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hey_T6bP;
struct Hey_2guL;

                                #ifndef DEF_Hey_T6bP0fUEQrb
                                #define DEF_Hey_T6bP0fUEQrb
struct Hey_T6bP
{
                                // shape_hash:    f5c21b512401b558
                                // non_triv_mask: 0000000000000000
    int hello;
    explicit operator bool() const noexcept
    {
        return false
            || hello
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_2guLPwfSc28
                                #define DEF_Hey_2guLPwfSc28
struct Hey_2guL
{
                                // shape_hash:    2d97461132f789d5
                                // non_triv_mask: 0008400000000000
    fu::vec<int> world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_uzDiOOPKzI4
                                #define DEF_Hey_uzDiOOPKzI4
inline static Hey_T6bP Hey_uzDi()
{
    return Hey_T6bP{};
}
                                #endif

                                #ifndef DEF_Hey_N5KJPlbXcUb
                                #define DEF_Hey_N5KJPlbXcUb
inline static Hey_2guL Hey_N5KJ()
{
    return Hey_2guL{};
}
                                #endif

int fu_MAIN()
{
    const Hey_T6bP _a = Hey_uzDi();
    Hey_2guL _b = Hey_N5KJ();
    return _a.hello + _b.world.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn Hey !T(lax _: T)
            case (T.is::arithmetic) = struct { hello: T };
            default                 = struct { world: T };

        fn main() {
            using let _a = Hey(i32);
            using let _b = Hey(i32[]);
            return hello + world.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>

struct Hey_T6bP;
struct Hey_2guL;

                                #ifndef DEF_Hey_T6bP0fUEQrb
                                #define DEF_Hey_T6bP0fUEQrb
struct Hey_T6bP
{
                                // shape_hash:    f5c21b512401b558
                                // non_triv_mask: 0000000000000000
    int hello;
    explicit operator bool() const noexcept
    {
        return false
            || hello
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_2guLPwfSc28
                                #define DEF_Hey_2guLPwfSc28
struct Hey_2guL
{
                                // shape_hash:    2d97461132f789d5
                                // non_triv_mask: 0008400000000000
    fu::vec<int> world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_BWJemMDGPsb
                                #define DEF_Hey_BWJemMDGPsb
inline static Hey_T6bP Hey_BWJe()
{
    return Hey_T6bP{};
}
                                #endif

                                #ifndef DEF_Hey_1G3zyoWOv2a
                                #define DEF_Hey_1G3zyoWOv2a
inline static Hey_2guL Hey_1G3z()
{
    return Hey_2guL{};
}
                                #endif

int fu_MAIN()
{
    const Hey_T6bP _a = Hey_BWJe();
    Hey_2guL _b = Hey_1G3z();
    return _a.hello + _b.world.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn new(type T): T = [];
        fn main() =

            new(0)   ;

---- <fail> ----
[2m[0m_0[2m.fu 5:13+3[0m:

[2m      |         fn main() =[0m
[2m      | [0m
[2m    5 | [0m            [31;1mnew[0m(0)   ;
[2m      | [0m

	Bad call to [94;1mnew[0m with args ([35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mnew[0m at [2m2:12+3[0m:
[2m    2 | [0m        fn [31;1mnew[0m(type T): T = [];

	    [35;3marg[0m [94;1mT[0m expects a type, got a value: [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        fn new(type T): T = [];
        fn main() =

            new(0)   ;

---- <fail> ----
[2m[0m_0[2m.fu 5:13+3[0m:

[2m      |         fn main() =[0m
[2m      | [0m
[2m    5 | [0m            [31;1mnew[0m(0)   ;
[2m      | [0m

	Bad call to [94;1mnew[0m with args ([35;3malways-false[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mnew[0m at [2m2:12+3[0m:
[2m    2 | [0m        fn [31;1mnew[0m(type T): T = [];

	    [35;3marg[0m [94;1mT[0m expects a type, got a value: [35;3malways-false[0m [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        fn new(type T): T = [];
        fn main() =

            new(i32) ;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_nEw_s3MUmjdeB10
                                #define DEF_nEw_s3MUmjdeB10
inline static int nEw_s3MU()
{
    return 0;
}
                                #endif

int fu_MAIN()
{
    return nEw_s3MU();
}

#endif

int main() { return fu_MAIN(); }

========

        type A = struct { x: i32 };
        type B = struct { y: i32 };
        fn main() {
            mut a: A;
            mut b: B;
            return a.x + b.y;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Anon_9Joc;
struct Anon_SGMD;

                                #ifndef DEF_Anon_9JocWDl5dUc
                                #define DEF_Anon_9JocWDl5dUc
struct Anon_9Joc
{
                                // shape_hash:    f616e2d647dd4569
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Anon_SGMDvOuqZx6
                                #define DEF_Anon_SGMDvOuqZx6
struct Anon_SGMD
{
                                // shape_hash:    a182b82a229754c4
                                // non_triv_mask: 0000000000000000
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Anon_9Joc a {};
    const Anon_SGMD b {};
    return a.x + b.y;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
        case (typeof(s) -> Hey(_)) {
            fill(s.a, v);
            fill(s.b, v);
        }
        default {
            for (fieldname i: typeof(s))
                s.i = v++;
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_PGFP;
struct Hey_dq4B;
struct Hey_uWyh;

                                #ifndef DEF_Hey_dq4Bax8pHXj
                                #define DEF_Hey_dq4Bax8pHXj
struct Hey_dq4B
{
                                // shape_hash:    147355c98323588e
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_uWyhzGYP7x3
                                #define DEF_Hey_uWyhzGYP7x3
struct Hey_uWyh
{
                                // shape_hash:    a92a9860f788a292
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_PGFPwBFKlPd
                                #define DEF_Hey_PGFPwBFKlPd
struct Hey_PGFP
{
                                // shape_hash:    b01d8b8c839e011a
                                // non_triv_mask: 0000000000000000
    Hey_dq4B a;
    Hey_uWyh b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_T1ELXk8iiN0
                                #define DEF_Hey_T1ELXk8iiN0
inline static Hey_PGFP Hey_T1EL()
{
    return Hey_PGFP{};
}
                                #endif

                                #ifndef DEF_fill_xkYreTYxSMd
                                #define DEF_fill_xkYreTYxSMd
inline static void fill_xkYr(/*3:3*/ Hey_dq4B& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_zIlXd3gPUYk
                                #define DEF_fill_zIlXd3gPUYk
inline static void fill_zIlX(/*3:3*/ Hey_uWyh& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_xT8SZ7gxwo6
                                #define DEF_fill_xT8SZ7gxwo6
inline static void fill_xT8S(/*3:1*/ Hey_PGFP& s, /*3:2*/ int& v)
{
    fill_xkYr(s.a, v);
    fill_zIlX(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_PGFP ab = Hey_T1EL();
    int v = 11;
    fill_xT8S(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32) {
            if (typeof(s) -> Hey(_)) {
                fill(s.a, v);
                fill(s.b, v);
            }
            else for (fieldname i: typeof(s)) {
                s.i = v++;
            }
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_PGFP;
struct Hey_dq4B;
struct Hey_uWyh;

                                #ifndef DEF_Hey_dq4Bax8pHXj
                                #define DEF_Hey_dq4Bax8pHXj
struct Hey_dq4B
{
                                // shape_hash:    147355c98323588e
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_uWyhzGYP7x3
                                #define DEF_Hey_uWyhzGYP7x3
struct Hey_uWyh
{
                                // shape_hash:    a92a9860f788a292
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_PGFPwBFKlPd
                                #define DEF_Hey_PGFPwBFKlPd
struct Hey_PGFP
{
                                // shape_hash:    b01d8b8c839e011a
                                // non_triv_mask: 0000000000000000
    Hey_dq4B a;
    Hey_uWyh b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_T1ELXk8iiN0
                                #define DEF_Hey_T1ELXk8iiN0
inline static Hey_PGFP Hey_T1EL()
{
    return Hey_PGFP{};
}
                                #endif

                                #ifndef DEF_fill_xkYreTYxSMd
                                #define DEF_fill_xkYreTYxSMd
inline static void fill_xkYr(/*3:3*/ Hey_dq4B& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_zIlXd3gPUYk
                                #define DEF_fill_zIlXd3gPUYk
inline static void fill_zIlX(/*3:3*/ Hey_uWyh& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_xT8SZ7gxwo6
                                #define DEF_fill_xT8SZ7gxwo6
inline static void fill_xT8S(/*3:1*/ Hey_PGFP& s, /*3:2*/ int& v)
{
    fill_xkYr(s.a, v);
    fill_zIlX(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_PGFP ab = Hey_T1EL();
    int v = 11;
    fill_xT8S(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
            for (fieldname i: typeof(s))
                if (typeof(s.i) -> i32)     s.i = v++;
                else                        fill(s.i, v);


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_PGFP;
struct Hey_dq4B;
struct Hey_uWyh;

                                #ifndef DEF_Hey_dq4Bax8pHXj
                                #define DEF_Hey_dq4Bax8pHXj
struct Hey_dq4B
{
                                // shape_hash:    147355c98323588e
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_uWyhzGYP7x3
                                #define DEF_Hey_uWyhzGYP7x3
struct Hey_uWyh
{
                                // shape_hash:    a92a9860f788a292
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_PGFPwBFKlPd
                                #define DEF_Hey_PGFPwBFKlPd
struct Hey_PGFP
{
                                // shape_hash:    b01d8b8c839e011a
                                // non_triv_mask: 0000000000000000
    Hey_dq4B a;
    Hey_uWyh b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_T1ELXk8iiN0
                                #define DEF_Hey_T1ELXk8iiN0
inline static Hey_PGFP Hey_T1EL()
{
    return Hey_PGFP{};
}
                                #endif

                                #ifndef DEF_fill_xkYreTYxSMd
                                #define DEF_fill_xkYreTYxSMd
inline static void fill_xkYr(/*3:3*/ Hey_dq4B& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_zIlXd3gPUYk
                                #define DEF_fill_zIlXd3gPUYk
inline static void fill_zIlX(/*3:3*/ Hey_uWyh& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_xT8SZ7gxwo6
                                #define DEF_fill_xT8SZ7gxwo6
inline static void fill_xT8S(/*3:1*/ Hey_PGFP& s, /*3:2*/ int& v)
{
    fill_xkYr(s.a, v);
    fill_zIlX(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_PGFP ab = Hey_T1EL();
    int v = 11;
    fill_xT8S(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
        case (typeof(s) -> Hey(_)) {
            fill(s.a, v);
            fill(s.b, v);
        }
        default {
            for (fieldname i: typeof(s))
                s.i = v++;
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_HCNf;
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_HCNfwo7jdU4
                                #define DEF_Hey_HCNfwo7jdU4
struct Hey_HCNf
{
                                // shape_hash:    be9f05f82f6b6293
                                // non_triv_mask: 0000000000000000
    A_EqO7 a;
    B_UWB4 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_U9erqmbTDGg
                                #define DEF_Hey_U9erqmbTDGg
inline static Hey_HCNf Hey_U9er()
{
    return Hey_HCNf{};
}
                                #endif

                                #ifndef DEF_fill_us13GrhFmqg
                                #define DEF_fill_us13GrhFmqg
inline static void fill_us13(/*3:3*/ A_EqO7& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_BB94JmPJHJ4
                                #define DEF_fill_BB94JmPJHJ4
inline static void fill_BB94(/*3:3*/ B_UWB4& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_LFKYwihuK3b
                                #define DEF_fill_LFKYwihuK3b
inline static void fill_LFKY(/*3:1*/ Hey_HCNf& s, /*3:2*/ int& v)
{
    fill_us13(s.a, v);
    fill_BB94(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_HCNf ab = Hey_U9er();
    int v = 11;
    fill_LFKY(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32) {
            if (typeof(s) -> Hey(_)) {
                fill(s.a, v);
                fill(s.b, v);
            }
            else for (fieldname i: typeof(s)) {
                s.i = v++;
            }
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_HCNf;
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_HCNfwo7jdU4
                                #define DEF_Hey_HCNfwo7jdU4
struct Hey_HCNf
{
                                // shape_hash:    be9f05f82f6b6293
                                // non_triv_mask: 0000000000000000
    A_EqO7 a;
    B_UWB4 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_U9erqmbTDGg
                                #define DEF_Hey_U9erqmbTDGg
inline static Hey_HCNf Hey_U9er()
{
    return Hey_HCNf{};
}
                                #endif

                                #ifndef DEF_fill_us13GrhFmqg
                                #define DEF_fill_us13GrhFmqg
inline static void fill_us13(/*3:3*/ A_EqO7& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_BB94JmPJHJ4
                                #define DEF_fill_BB94JmPJHJ4
inline static void fill_BB94(/*3:3*/ B_UWB4& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_LFKYwihuK3b
                                #define DEF_fill_LFKYwihuK3b
inline static void fill_LFKY(/*3:1*/ Hey_HCNf& s, /*3:2*/ int& v)
{
    fill_us13(s.a, v);
    fill_BB94(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_HCNf ab = Hey_U9er();
    int v = 11;
    fill_LFKY(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
            for (fieldname i: typeof(s))
                if (typeof(s.i) -> i32)     s.i = v++;
                else                        fill(s.i, v);


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hey_HCNf;
struct A_EqO7;
struct B_UWB4;

                                #ifndef DEF_A_EqO71KXo4Pb
                                #define DEF_A_EqO71KXo4Pb
struct A_EqO7
{
                                // shape_hash:    4117766423fd7b98
                                // non_triv_mask: 0000000000000000
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_UWB4xfD03ag
                                #define DEF_B_UWB4xfD03ag
struct B_UWB4
{
                                // shape_hash:    8a2dccbc21aef3cb
                                // non_triv_mask: 0000000000000000
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Hey_HCNfwo7jdU4
                                #define DEF_Hey_HCNfwo7jdU4
struct Hey_HCNf
{
                                // shape_hash:    be9f05f82f6b6293
                                // non_triv_mask: 0000000000000000
    A_EqO7 a;
    B_UWB4 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Hey_U9erqmbTDGg
                                #define DEF_Hey_U9erqmbTDGg
inline static Hey_HCNf Hey_U9er()
{
    return Hey_HCNf{};
}
                                #endif

                                #ifndef DEF_fill_us13GrhFmqg
                                #define DEF_fill_us13GrhFmqg
inline static void fill_us13(/*3:3*/ A_EqO7& s, /*3:2*/ int& v)
{
    s.a = v++;
}
                                #endif

                                #ifndef DEF_fill_BB94JmPJHJ4
                                #define DEF_fill_BB94JmPJHJ4
inline static void fill_BB94(/*3:3*/ B_UWB4& s, /*3:2*/ int& v)
{
    s.b = v++;
}
                                #endif

                                #ifndef DEF_fill_LFKYwihuK3b
                                #define DEF_fill_LFKYwihuK3b
inline static void fill_LFKY(/*3:1*/ Hey_HCNf& s, /*3:2*/ int& v)
{
    fill_us13(s.a, v);
    fill_BB94(s.b, v);
}
                                #endif

int fu_MAIN()
{
    Hey_HCNf ab = Hey_U9er();
    int v = 11;
    fill_LFKY(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

========


        let  X = i32; 
        struct Y { x: X };

        fn main() {
            mut y = Y(1 + 2);
            return y.x - 3;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+1[0m:

[2m      | [0m
[2m      |         let  X = i32; [0m
[2m    4 | [0m        struct Y { x: [31;1mX[0m };
[2m      | [0m
[2m      |         fn main() {[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;3mtype[0m [94;1mY[0m

========


        type X = i32; 
        struct Y { x: X };

        fn main() {
            mut y = Y(1 + 2);
            return y.x - 3;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Y_eIc9;

                                #ifndef DEF_Y_eIc9025qqEg
                                #define DEF_Y_eIc9025qqEg
struct Y_eIc9
{
                                // shape_hash:    e9f09bf0820e4f1c
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Y_eIc9 y = Y_eIc9 { (1 + 2) };
    return y.x - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Hello { a: i32; b: i32 };

        fn Wrap(type T) = struct { using v: T };
        fn incr_a1_b2 !T(using w: Wrap(T)) =
            T(:a + 1, :b + 2);

        fn main() {
            mut zeroes: Wrap(Hello);
            let ones = incr_a1_b2(zeroes);
            return ones.a * 10 + ones.b * 100 - 210;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Wrap_xOJb;
struct Hello_PZ6S;

                                #ifndef DEF_Hello_PZ6SNdi8yY1
                                #define DEF_Hello_PZ6SNdi8yY1
struct Hello_PZ6S
{
                                // shape_hash:    1559a19971fd5071
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Wrap_xOJbrgQ0Oy6
                                #define DEF_Wrap_xOJbrgQ0Oy6
struct Wrap_xOJb
{
                                // shape_hash:    94b62238186bc6c4
                                // non_triv_mask: 0000000000000000
    Hello_PZ6S v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_incr_a1_b2_p4LkjbsXAD2
                                #define DEF_incr_a1_b2_p4LkjbsXAD2
inline static Hello_PZ6S incr_a1_b2_p4Lk(/*1:1*/ const Wrap_xOJb& w)
{
    return Hello_PZ6S { (w.v.a + 1), (w.v.b + 2) };
}
                                #endif

int fu_MAIN()
{
    const Wrap_xOJb zeroes {};
    const Hello_PZ6S ones = incr_a1_b2_p4Lk(zeroes);
    return ((ones.a * 10) + (ones.b * 100)) - 210;
}

#endif

int main() { return fu_MAIN(); }

========

        fn typeArgRename(type Outer!<Inner>)
            case (Inner.is::primitive)
                = Inner;

        fn main() {
            mut x: typeArgRename(

                    i32);

            return x;
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:20+13[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    7 | [0m            mut x: [31;1mtypeArgRename[0m(
[2m      | [0m
[2m      |                     i32);[0m

	Bad call to [94;1mtypeArgRename[0m with args ([35;3malways-false[0m [35;3mtype[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mtypeArgRename[0m at [2m2:12+13[0m:
[2m    2 | [0m        fn [31;1mtypeArgRename[0m(type Outer!<Inner>)

	    [35;3marg[0m [94;1mOuter[0m must be :named explicitly.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        fn typeArgRename(type Outer!<Inner>)
            case (Inner.is::primitive)
                = Inner;

        fn main() {
            mut x: typeArgRename(
Outer: 
                    i32);

            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x {};
    return x;
}

#endif

int main() { return fu_MAIN(); }

========

        struct HasData(type T) { data: T[] };

        fn obfuscate !T(l.data: T[..], r.data: T[..], with_left, with_right) {
            with_left (l0?: 0, l1?: l.len);
            with_right(right: r[.. r.len]);
        }

        fn concatAndFlatten !T(l: HasData(T), r: HasData(T)) {
            mut result: T[];
            obfuscate(l, r,
                with_left:  |l0, l1| result ~= l.data[l0 .. l1],
                with_right: |right|  result ~= right);

            return result.join("");
        }

        fn main() {
            let a: HasData(string) = [ [ "Hello", ", " ] ];
            let b: HasData(string) = [ [ "World", "!" ] ];

            return concatAndFlatten(a, b).len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct HasData_youR;

                                #ifndef DEF_HasData_youRbFaFrSe
                                #define DEF_HasData_youRbFaFrSe
struct HasData_youR
{
                                // shape_hash:    2524d7bc2219b4da
                                // non_triv_mask: 0000c00000000000
    fu::vec<fu::str> data;
    explicit operator bool() const noexcept
    {
        return false
            || data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_with_left_PZIIYHslnfk
                                #define DEF_with_left_PZIIYHslnfk
inline static fu::view<fu::str> with_left_PZII(const int l0, const int l1, /*F:F*/ const HasData_youR& l, /*B:B*/ fu::vec<fu::str>& result)
{
    return (result += fu::get_view(l.data, l0, l1));
}
                                #endif

                                #ifndef DEF_with_right_2A2OeXG26yg
                                #define DEF_with_right_2A2OeXG26yg
inline static fu::view<fu::str> with_right_2A2O(/*3:3*/ fu::view<fu::str> right, /*2:2*/ fu::vec<fu::str>& result)
{
    return (result += right);
}
                                #endif

                                #ifndef DEF_obfuscate_4raAOqW07Xh
                                #define DEF_obfuscate_4raAOqW07Xh
inline static void obfuscate_4raA(/*F3:F3*/ fu::view<fu::str> l, /*F3:F3*/ fu::view<fu::str> r, /*F3:F3*/ const HasData_youR& l_1, /*D2:D2*/ fu::vec<fu::str>& result)
{
    with_left_PZII(0, l.size(), l_1, result);
    with_right_2A2O(fu::get_view_start0(r, r.size()), result);
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_concatAndFlatten_OWqg3ep9Bt9
                                #define DEF_concatAndFlatten_OWqg3ep9Bt9
inline static fu::str concatAndFlatten_OWqg(/*3:3*/ const HasData_youR& l, /*3:3*/ const HasData_youR& r)
{
    fu::vec<fu::str> result {};
    obfuscate_4raA(l.data, r.data, l, result);
    return join_yqDb(result, ""_view);
}
                                #endif

int fu_MAIN()
{
    HasData_youR a = HasData_youR { fu::vec<fu::str> {{ fu::str("Hello"_fu), fu::str(", "_fu) }} };
    HasData_youR b = HasData_youR { fu::vec<fu::str> {{ fu::str("World"_fu), fu::str("!"_fu) }} };
    return concatAndFlatten_OWqg(a, b).size() - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct HasData(type T) { data: T[] };

        fn obfuscate !T(l.data: T[..], r.data: T[..], with_left, with_right) {
            with_left (l0?: 0, l1?: l.len);
            with_right(right: r[.. r.len]);
        }

        fn concatAndFlatten !T(l: HasData(T), r: HasData(T)) {
            mut result: T[];
            obfuscate(l, r,
                with_left:  |l0, l1| result ~= l.data[l0 .. l1],
                with_right: |right|  result ~= right);

            return result.join("");
        }

        fn main() {
            let a: HasData(string) = [ [ "Hello", ", " ] ];
            let b: HasData(string) = [ [ "World", "!" ] ];

            return concatAndFlatten(a, b).len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct HasData_youR;

                                #ifndef DEF_HasData_youRbFaFrSe
                                #define DEF_HasData_youRbFaFrSe
struct HasData_youR
{
                                // shape_hash:    2524d7bc2219b4da
                                // non_triv_mask: 0000c00000000000
    fu::vec<fu::str> data;
    explicit operator bool() const noexcept
    {
        return false
            || data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_with_left_PZIIYHslnfk
                                #define DEF_with_left_PZIIYHslnfk
inline static fu::view<fu::str> with_left_PZII(const int l0, const int l1, /*F:F*/ const HasData_youR& l, /*B:B*/ fu::vec<fu::str>& result)
{
    return (result += fu::get_view(l.data, l0, l1));
}
                                #endif

                                #ifndef DEF_with_right_2A2OeXG26yg
                                #define DEF_with_right_2A2OeXG26yg
inline static fu::view<fu::str> with_right_2A2O(/*3:3*/ fu::view<fu::str> right, /*2:2*/ fu::vec<fu::str>& result)
{
    return (result += right);
}
                                #endif

                                #ifndef DEF_obfuscate_4raAOqW07Xh
                                #define DEF_obfuscate_4raAOqW07Xh
inline static void obfuscate_4raA(/*F3:F3*/ fu::view<fu::str> l, /*F3:F3*/ fu::view<fu::str> r, /*F3:F3*/ const HasData_youR& l_1, /*D2:D2*/ fu::vec<fu::str>& result)
{
    with_left_PZII(0, l.size(), l_1, result);
    with_right_2A2O(fu::get_view_start0(r, r.size()), result);
}
                                #endif

                                #ifndef DEF_join_yqDbqRmcQYi
                                #define DEF_join_yqDbqRmcQYi
inline fu::str join_yqDb(/*3:3*/ fu::view<fu::str> a, /*3:3*/ fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_concatAndFlatten_OWqg3ep9Bt9
                                #define DEF_concatAndFlatten_OWqg3ep9Bt9
inline static fu::str concatAndFlatten_OWqg(/*3:3*/ const HasData_youR& l, /*3:3*/ const HasData_youR& r)
{
    fu::vec<fu::str> result {};
    obfuscate_4raA(l.data, r.data, l, result);
    return join_yqDb(result, fu::view<char>{});
}
                                #endif

int fu_MAIN()
{
    HasData_youR a = HasData_youR { fu::vec<fu::str> {{ fu::str("Hello"_fu), fu::str(", "_fu) }} };
    HasData_youR b = HasData_youR { fu::vec<fu::str> {{ fu::str("World"_fu), fu::str("!"_fu) }} };
    return concatAndFlatten_OWqg(a, b).size() - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Sockets(type RequestHandler) {
            req_handler: RequestHandler
        }

        fn handle_request !RH(ref sockets: Sockets(RH)) {
            let req_handler = sockets.req_handler;
            req_handler();
        }

        fn HTTP(request?) {

            type HTTP = Sockets(typeof(fn request));
            return HTTP();
        }

        fn main() {
            mut res = -1;
            fn handler() res++;
            let http = HTTP(fn handler);
            handle_request(http);
            return res;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:20+4[0m:

[2m      | [0m
[2m      |             type HTTP = Sockets(typeof(fn request));[0m
[2m   14 | [0m            return [31;1mHTTP[0m();
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [94;1mHTTP[0m, matches multiple items in scope:

	[35;3mtype[0m [94;1mSockets[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Sockets(type RequestHandler) {

	    ... via [2m13:18+4[0m:
[2m   13 | [0m            type [31;1mHTTP[0m = Sockets(typeof(fn request));

	[35;3mfn[0m [94;1mHTTP[0m at [2m11:12+4[0m:
[2m   11 | [0m        fn [31;1mHTTP[0m(request?) {


        Solving [35;3mfn[0m [94;1mHTTP[0m([35;3m[][0m) at [2m11:12+4[0m
                [35;3mfn[0m [94;1mHTTP[0m([35;3m@150[0m) at [2m11:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m17:12+4[0m

========

        struct Sockets(type RequestHandler) {
            req_handler: RequestHandler
        }

        fn handle_request !RH(ref sockets: Sockets(RH)) {
            let req_handler = sockets.req_handler;
            req_handler();
        }

        fn HTTP(request?) {

            type HTTP = Sockets(typeof(fn request));
            return HTTP(fn request);
        }

        fn main() {
            mut res = -1;
            fn handler() res++;
            let http = HTTP(fn handler);
            handle_request(http);
            return res;
        }

---- <fail> ----
[2m[0m_0[2m.fu 14:20+4[0m:

[2m      | [0m
[2m      |             type HTTP = Sockets(typeof(fn request));[0m
[2m   14 | [0m            return [31;1mHTTP[0m(fn request);
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [94;1mHTTP[0m with args ([35;3mnocopy[0m [35;3m@150[0m), matches multiple items in scope:

	[35;3mtype[0m [94;1mSockets[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Sockets(type RequestHandler) {

	    ... via [2m13:18+4[0m:
[2m   13 | [0m            type [31;1mHTTP[0m = Sockets(typeof(fn request));

	[35;3mfn[0m [94;1mHTTP[0m at [2m11:12+4[0m:
[2m   11 | [0m        fn [31;1mHTTP[0m(request?) {


        Solving [35;3mfn[0m [94;1mHTTP[0m([35;3m@150[0m) at [2m11:12+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m17:12+4[0m

========

        struct Sockets(type RequestHandler) {
            req_handler: RequestHandler
        }

        fn handle_request !RH(ref sockets: Sockets(RH)) {
            let req_handler = sockets.req_handler;
            req_handler();
        }

        fn HTTP(request?) {

            shadow

            type HTTP = Sockets(typeof(fn request));
            return HTTP();
        }

        fn main() {
            mut res = -1;
            fn handler() res++;
            let http = HTTP(fn handler);
            handle_request(http);
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int handler_MbR9(/*1:1*/ int& res)
{
    return res++;
}

                                #ifndef DEF_handle_request_VMCqcAFi5Sf
                                #define DEF_handle_request_VMCqcAFi5Sf
inline static void handle_request_VMCq(/*3:3*/ int& res)
{
    handler_MbR9(res);
}
                                #endif

int fu_MAIN()
{
    int res = -1;
    handle_request_VMCq(res);
    return res;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        struct Sockets(type RequestHandler) {
            req_handler: RequestHandler
        }

        fn handle_request !RH(ref sockets: Sockets(RH)) {
            let req_handler = sockets.req_handler;
            req_handler();
        }

        fn HTTP(request?) {

            shadow

            type HTTP = Sockets(typeof(fn request));
            return HTTP(fn request);
        }

        fn main() {
            mut res = -1;
            fn handler() res++;
            let http = HTTP(fn handler);
            handle_request(http);
            return res;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int handler_MbR9(/*1:1*/ int& res)
{
    return res++;
}

                                #ifndef DEF_handle_request_VMCqcAFi5Sf
                                #define DEF_handle_request_VMCqcAFi5Sf
inline static void handle_request_VMCq(/*3:3*/ int& res)
{
    handler_MbR9(res);
}
                                #endif

int fu_MAIN()
{
    int res = -1;
    handle_request_VMCq(res);
    return res;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        struct CollideEverything {}
        noinline fn set_hash !T(ref slot: T, value: T) slot = value;
        using fn int(_: CollideEverything) 0;
        fn main() {
            mut hash: CollideEverything;
            set_hash(hash, hash);
            return hash;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int iNt_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return iNt_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        struct Collide {}
        struct HK(type Hash, type Key) { hash: Hash; key: Key }

        noinline fn set_hk <Hash, Key>(
            ref a: HK(:Hash, :Key), ref b: HK(:Hash, :Key), hash: Hash, key: Key)
        {
            a.hash = hash;
            b.key  = key;
        }

        using fn int(_: Collide) 2;
        fn main() {
            shadow type HK = HK(Hash: Collide, Key: int);
            mut hk = HK(Collide(), 3);
            set_hk(hk, hk, hk.hash, hk.key);
            return hk.hash.int + hk.key - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct HK_Wnor;

                                #ifndef DEF_HK_WnorJksuZId
                                #define DEF_HK_WnorJksuZId
struct HK_Wnor
{
                                // shape_hash:    4a7380be8151fdf9
                                // non_triv_mask: 0000000000000000
    int key;
    explicit operator bool() const noexcept
    {
        return false
            || key
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_set_hk_oCIOMYTgAhd
                                #define DEF_set_hk_oCIOMYTgAhd
inline static void set_hk_oCIO(/*F:F*/ HK_Wnor& b, const int key)
{
    b.key = key;
}
                                #endif

static int iNt_MbR9()
{
    return 2;
}

int fu_MAIN()
{
    HK_Wnor hk = HK_Wnor { 3 };
    set_hk_oCIO(hk, hk.key);
    return (iNt_MbR9() + hk.key) - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        struct Map(type Key, type Value, type Hash) {
            k: Key; v: Value; h: Hash
        }

        fn key !<Key>(ref map: Map(:Key, _, _)) map.k;

        fn main() {
            mut map: Map(int, u32, u64);
            return map.key;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>

struct Map_uzKH;

                                #ifndef DEF_Map_uzKHwIl0yB9
                                #define DEF_Map_uzKHwIl0yB9
struct Map_uzKH
{
                                // shape_hash:    8b8d0c2bd52f1ef6
                                // non_triv_mask: 0000000000000000
    int k;
    unsigned v;
    uint64_t h;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
            || h
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_key_k3xqTmyIPRi
                                #define DEF_key_k3xqTmyIPRi
inline static int key_k3xq(/*1:1*/ const Map_uzKH& map)
{
    return map.k;
}
                                #endif

int fu_MAIN()
{
    const Map_uzKH map {};
    return key_k3xq(map);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct SillyHash {}
        struct Map(type Key, 
                 type Value, type Hash = SillyHash) {}
        inline fn set !<Key, Hash>(ref map: Map(:Key, :Hash), key: Key) return []

        lax fn test(ref map)
            for (mut i = 0; i < 10; i++)
                map.set(i)

        fn main() {
            mut map: Map(int, int)
            test(map)
            return 0
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:21+3[0m:

[2m      |         lax fn test(ref map)[0m
[2m      |             for (mut i = 0; i < 10; i++)[0m
[2m    9 | [0m                map.[31;1mset[0m(i)
[2m      | [0m
[2m      |         fn main() {[0m

	Bad call to [94;1mset[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mMap[0m([35;3mi32[0m, [35;3mi32[0m, [94;1mSillyHash[0m), [35;3mmut[0m [35;3mref[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1mset[0m at [2m5:19+3[0m:
[2m    5 | [0m        inline fn [31;1mset[0m !<Key, Hash>(ref map: Map(:Key, :Hash), key: Key) return []

	    [35;3marg[0m [94;1mset[0m:[94;1mmap[0m:
	    Missing type argument for [35;3mtemplate[0m [94;1mMap[0m: [35;3marg[0m [94;1mValue[0m

        Solving [35;3mfn[0m [94;1mtest[0m([94;1mMap[0m) at [2m7:16+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m11:12+4[0m

========

        struct SillyHash {}
        struct Map(type Key, type Hash = SillyHash) {}
        inline fn set !<Key, Hash>(ref map: Map(:Key, :Hash), key: Key) return []

        lax fn test(ref map)
            for (mut i = 0; i < 10; i++)
                map.set(i)

        fn main() {
            mut map: Map(int, int)
            test(map)
            return 0
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        struct Hello(type T = uint) {} // missing F_TEMPLATE because of the default
        fn zero !T(ref h: Hello(T)) T();
        fn main() {
            mut h_i32: Hello(i32);
            mut h_i64: Hello(i64);

            mut v_i32: i32 = h_i32.zero;
            mut v_i64: i64 = h_i64.zero;

            if (v_i64 += v_i32)  return 1;

            mut hello: Hello(int);
            return hello.zero;
        }

---- <fail> ----
[2m[0m_0[2m.fu 11:23+2[0m:

[2m      |             mut v_i64: i64 = h_i64.zero;[0m
[2m      | [0m
[2m   11 | [0m            if (v_i64 [31;1m+=[0m v_i32)  return 1;
[2m      | [0m
[2m      |             mut hello: Hello(int);[0m

	Bad call to [94;1m+=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mi64[0m, [35;3mmut[0m [35;3mref[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m+=[0m at [2m../../../../../[0mprelude[2m 24:10+2[0m:
[2m   24 | [0minfix fn [31;1m+=[0m (mut ref a: <T>, b: T) case (T.is::arithmetic): &mut T __native;

	    [35;3marg[0m [94;1m+=[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3mi64[0m <-> [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        struct Hello(type T = uint) {} // missing F_TEMPLATE because of the default
        fn zero !T(ref h: Hello(T)) T();
        fn main() {
            mut h_i32: Hello(i32);
            mut h_i64: Hello(i64);

            mut v_i32: i32 = h_i32.zero;
            mut v_i64: i64 = h_i64.zero;

            if (v_i32 || v_i64)  return 1;

            mut hello: Hello(int);
            return hello.zero;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>


#ifndef fu_NO_fdefs

                                #ifndef DEF_zero_vp0IlFE3zwl
                                #define DEF_zero_vp0IlFE3zwl
inline static int zero_vp0I()
{
    return 0;
}
                                #endif

                                #ifndef DEF_zero_L0QW3yNt3Jb
                                #define DEF_zero_L0QW3yNt3Jb
inline static int64_t zero_L0QW()
{
    return 0ll;
}
                                #endif

int fu_MAIN()
{
    const int v_i32 = zero_vp0I();
    const int64_t v_i64 = zero_L0QW();
    if (v_i32 || v_i64)
        return 1;
    else
        return zero_vp0I();

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct DefaultHasher {}
        fn hash(_: DefaultHasher, value: int) value * 10;
        pub struct Map(type Hasher = DefaultHasher) { hasher: Hasher; data: int[] }
        inline fn hash(ref map: Map(_), value: int) map.hasher.hash(value);
        pub fn add(ref map: Map(_), value: int) map.data ~= map.hash(value);

        fn main() {
            mut map: _0::Map();
            map.add(10);
            return map.data.len == 1 && map.data[0] == 100 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct Map_pyUt;
int hash_MbR9(int);

                                #ifndef DEF_Map_pyUtEopQL83
                                #define DEF_Map_pyUtEopQL83
struct Map_pyUt
{
                                // shape_hash:    d0e868f945b37942
                                // non_triv_mask: 000a000000000000
    fu::vec<int> data;
    explicit operator bool() const noexcept
    {
        return false
            || data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_mhewST6LdE5
                                #define DEF_add_mhewST6LdE5
inline fu::view<int> add_mhew(/*3:3*/ Map_pyUt& map, const int value)
{
    return (map.data += hash_MbR9(value));
}
                                #endif

int fu_MAIN()
{
    Map_pyUt map {};
    add_mhew(map, 10);
    if ((map.data.size() == 1) && (map.data[0] == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

#ifndef fu_NO_fdefs

int hash_MbR9(const int value)
{
    return value * 10;
}

#endif

// N_SD_ExternPrivates

========

        struct Map(type Key, type Hasher) { hasher: Hasher }
        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)
        fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)

        struct Constant(c) { c: typeof(fn c) }
        fn hash(h: Constant(_), _) {
            let c = h.c
            return c
        }

        struct Noop {}
        fn hash(hasher: Noop, _) = 0

        fn main() {
            mut map: Map(u8, Constant(|| 1))
            return map.add(2) - 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___R3xIeRGTGgi
                                #define DEF___R3xIeRGTGgi
inline static int _R3xI()
{
    return 1;
}
                                #endif

                                #ifndef DEF_hash_Yrnwvkcxqg9
                                #define DEF_hash_Yrnwvkcxqg9
inline static int hash_Yrnw()
{
    return _R3xI();
}
                                #endif

                                #ifndef DEF_hash_c5BaVnbkwae
                                #define DEF_hash_c5BaVnbkwae
inline static int hash_c5Ba()
{
    return hash_Yrnw();
}
                                #endif

                                #ifndef DEF_add_PKs20rF91je
                                #define DEF_add_PKs20rF91je
inline static int add_PKs2()
{
    return hash_c5Ba();
}
                                #endif

int fu_MAIN()
{
    return add_PKs2() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct Map(type Key, type Hasher) { hasher: Hasher }
        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)
        fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)

        struct Noop {}
        fn hash(hasher: Noop, _) = 0

        struct Constant(c) { c: typeof(fn c) }
        fn hash(h: Constant(_), _) {
            let c = h.c
            return c
        }

        fn main() {
            mut map: Map(u8, Constant(|| 1))
            return map.add(2) - 1
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___R3xIeRGTGgi
                                #define DEF___R3xIeRGTGgi
inline static int _R3xI()
{
    return 1;
}
                                #endif

                                #ifndef DEF_hash_Yrnwvkcxqg9
                                #define DEF_hash_Yrnwvkcxqg9
inline static int hash_Yrnw()
{
    return _R3xI();
}
                                #endif

                                #ifndef DEF_hash_c5BaVnbkwae
                                #define DEF_hash_c5BaVnbkwae
inline static int hash_c5Ba()
{
    return hash_Yrnw();
}
                                #endif

                                #ifndef DEF_add_PKs20rF91je
                                #define DEF_add_PKs20rF91je
inline static int add_PKs2()
{
    return hash_c5Ba();
}
                                #endif

int fu_MAIN()
{
    return add_PKs2() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        pub struct Map(type Key, type Hasher) { hasher: Hasher }
        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)
        pub fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)

        pub struct Noop {}
        fn hash(hasher: Noop, _) = 0

        struct Constant(c) { c: typeof(fn c) }
        fn hash(h: Constant(_), _) {
            let c = h.c
            return c
        }

        pub fn visibility_a(mut map?: Map(u8, Constant(|| 1))) = map.add(2) - 1


        fn visibility_b(mut map?: _0::Map(u8, _0::Noop)) = map.add(2)
        fn main() = _0::visibility_a() || visibility_b()


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int visibility_a_MbR9();

#ifndef fu_NO_fdefs

                                #ifndef DEF_hash_OHgQmCWqtKf
                                #define DEF_hash_OHgQmCWqtKf
inline static int hash_OHgQ()
{
    return 0;
}
                                #endif

                                #ifndef DEF_hash_6pPxkhleaWb
                                #define DEF_hash_6pPxkhleaWb
inline static int hash_6pPx()
{
    return hash_OHgQ();
}
                                #endif

                                #ifndef DEF_add_hvZAlX0tkP0
                                #define DEF_add_hvZAlX0tkP0
inline int add_hvZA()
{
    return hash_6pPx();
}
                                #endif

static int visibility_b_LtD7()
{
    return add_hvZA();
}

int fu_MAIN()
{
    int _0;
    return (_0 = visibility_a_MbR9()) ? _0 : visibility_b_LtD7();
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

                                #ifndef DEF___R3xIeRGTGgi
                                #define DEF___R3xIeRGTGgi
inline static int _R3xI()
{
    return 1;
}
                                #endif

                                #ifndef DEF_hash_Yrnwvkcxqg9
                                #define DEF_hash_Yrnwvkcxqg9
inline static int hash_Yrnw()
{
    return _R3xI();
}
                                #endif

                                #ifndef DEF_hash_c5BaVnbkwae
                                #define DEF_hash_c5BaVnbkwae
inline static int hash_c5Ba()
{
    return hash_Yrnw();
}
                                #endif

                                #ifndef DEF_add_PKs20rF91je
                                #define DEF_add_PKs20rF91je
inline int add_PKs2()
{
    return hash_c5Ba();
}
                                #endif

int visibility_a_MbR9()
{
    return add_PKs2() - 1;
}

#endif

========

        pub struct Map(type Key, type Hasher) { hasher: Hasher }
        fn hash !Key(map: Map(:Key, _), key: Key) = map.hasher.hash(key)
        pub fn add !Key(ref map: Map(:Key, _), key: Key) = map.hash(key)

        pub struct Noop {}
        fn hash(hasher: Noop, _) = 0

        struct Constant(c) { c: typeof(fn c) }
        fn hash(h: Constant(_), _) {
            let c = h.c
            return c
        }

        pub fn visibility_a(mut map?: Map(u8, Constant(|| 1))) = map.add(2) - 1


        import _0
        fn visibility_b(mut map?: Map(u8, Noop)) = map.add(2)
        fn main() = visibility_a() || visibility_b()


---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int visibility_a_MbR9();

#ifndef fu_NO_fdefs

                                #ifndef DEF_hash_OHgQmCWqtKf
                                #define DEF_hash_OHgQmCWqtKf
inline static int hash_OHgQ()
{
    return 0;
}
                                #endif

                                #ifndef DEF_hash_6pPxkhleaWb
                                #define DEF_hash_6pPxkhleaWb
inline static int hash_6pPx()
{
    return hash_OHgQ();
}
                                #endif

                                #ifndef DEF_add_hvZAlX0tkP0
                                #define DEF_add_hvZAlX0tkP0
inline int add_hvZA()
{
    return hash_6pPx();
}
                                #endif

static int visibility_b_LtD7()
{
    return add_hvZA();
}

int fu_MAIN()
{
    int _0;
    return (_0 = visibility_a_MbR9()) ? _0 : visibility_b_LtD7();
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

                                #ifndef DEF___R3xIeRGTGgi
                                #define DEF___R3xIeRGTGgi
inline static int _R3xI()
{
    return 1;
}
                                #endif

                                #ifndef DEF_hash_Yrnwvkcxqg9
                                #define DEF_hash_Yrnwvkcxqg9
inline static int hash_Yrnw()
{
    return _R3xI();
}
                                #endif

                                #ifndef DEF_hash_c5BaVnbkwae
                                #define DEF_hash_c5BaVnbkwae
inline static int hash_c5Ba()
{
    return hash_Yrnw();
}
                                #endif

                                #ifndef DEF_add_PKs20rF91je
                                #define DEF_add_PKs20rF91je
inline int add_PKs2()
{
    return hash_c5Ba();
}
                                #endif

int visibility_a_MbR9()
{
    return add_PKs2() - 1;
}

#endif

========


        struct List(type X) { f: X };
        pub fn make_list(v: int) = List(int)(v);

        import _0;
        pub fn get_f(l: List(_)) l.f;

        fn main() _0::make_list(0)._1::get_f();

---- <fail> ----
[2m[0m_1[2m.fu 3:25+4[0m:

[2m      | [0m
[2m      |         import _0;[0m
[2m    3 | [0m        pub fn get_f(l: [31;1mList[0m(_)) l.f;
[2m      | [0m

	[94;1mList[0m is not defined here.

========


        pub 
        struct List(type X) { f: X };
        pub fn make_list(v: int) = List(int)(v);

        import _0;
        pub fn get_f(l: List(_)) l.f;

        fn main() _0::make_list(0)._1::get_f();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct List_DdXJ;
List_DdXJ make_list_MbR9(int);

                                #ifndef DEF_List_DdXJDBU1ju6
                                #define DEF_List_DdXJDBU1ju6
struct List_DdXJ
{
                                // shape_hash:    125b0ca485e449b4
                                // non_triv_mask: 0000000000000000
    int f;
    explicit operator bool() const noexcept
    {
        return false
            || f
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_get_f_eqC8wcK2gK7
                                #define DEF_get_f_eqC8wcK2gK7
inline int get_f_eqC8(/*1:1*/ const List_DdXJ& l)
{
    return l.f;
}
                                #endif

int fu_MAIN()
{
    return get_f_eqC8(make_list_MbR9(0));
}

#endif

int main() { return fu_MAIN(); }
struct List_DdXJ;

                                #ifndef DEF_List_DdXJDBU1ju6
                                #define DEF_List_DdXJDBU1ju6
struct List_DdXJ
{
                                // shape_hash:    125b0ca485e449b4
                                // non_triv_mask: 0000000000000000
    int f;
    explicit operator bool() const noexcept
    {
        return false
            || f
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

List_DdXJ make_list_MbR9(const int v)
{
    return List_DdXJ { v };
}

#endif

========

        struct Two(type T) { a: T; b: T };

        fn arr_of_two(x: int)               
            [ _0::Two(int)(x, x) ];         

        import _0;
        fn arr_of_2(x: int)                 
            [ Two(int)(x, x) ];             

        fn main() {
            mut sum = 0;
            fn sum !T(what: T)
                case (T -> _[])     what.each(.sum);
                default             sum += what.a + what.b;

            sum(_1::arr_of_two(2) ~ _2::arr_of_2(3));
            return sum == 10 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Two_0bja;
struct Two_0bja;
fu::vec<Two_0bja> arr_of_two_LtD7(int);
fu::vec<Two_0bja> arr_of_2_WLF9(int);

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sum_sHdIAIbGml7
                                #define DEF_sum_sHdIAIbGml7
inline static int sum_sHdI(/*3:3*/ const Two_0bja& what, /*3:3*/ int& sum)
{
    return (sum += (what.a + what.b));
}
                                #endif

                                #ifndef DEF___ZvrSek2MvWc
                                #define DEF___ZvrSek2MvWc
inline static int _ZvrS(/*3:3*/ const Two_0bja& _, /*3:3*/ int& sum)
{
    return sum_sHdI(_, sum);
}
                                #endif

                                #ifndef DEF_each_19XVOdPujei
                                #define DEF_each_19XVOdPujei
inline void each_19XV(/*7:7*/ fu::view<Two_0bja> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _ZvrS(a[i], sum);

}
                                #endif

                                #ifndef DEF_sum_Zvft4awkyk5
                                #define DEF_sum_Zvft4awkyk5
inline static void sum_Zvft(/*3:3*/ fu::view<Two_0bja> what, /*2:2*/ int& sum)
{
    each_19XV(what, sum);
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    sum_Zvft((arr_of_two_LtD7(2) + arr_of_2_WLF9(3)), sum);
    if (sum == 10)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_two_LtD7(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_2_WLF9(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif

========

        struct Two(type T) { a: T; b: T };

        fn arr_of_two(x: int)               
            [ _0::Two(int)(x, x) ];         

        import _0;
        fn arr_of_2(x: int)                 
            : Two(int)[] = [[ x, x ]];      

        fn main() {
            mut sum = 0;
            fn sum !T(what: T)
                case (T -> _[])     what.each(.sum);
                default             sum += what.a + what.b;

            sum(_1::arr_of_two(2) ~ _2::arr_of_2(3));
            return sum == 10 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Two_0bja;
struct Two_0bja;
fu::vec<Two_0bja> arr_of_two_LtD7(int);
fu::vec<Two_0bja> arr_of_2_WLF9(int);

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sum_sHdIAIbGml7
                                #define DEF_sum_sHdIAIbGml7
inline static int sum_sHdI(/*3:3*/ const Two_0bja& what, /*3:3*/ int& sum)
{
    return (sum += (what.a + what.b));
}
                                #endif

                                #ifndef DEF___ZvrSek2MvWc
                                #define DEF___ZvrSek2MvWc
inline static int _ZvrS(/*3:3*/ const Two_0bja& _, /*3:3*/ int& sum)
{
    return sum_sHdI(_, sum);
}
                                #endif

                                #ifndef DEF_each_19XVOdPujei
                                #define DEF_each_19XVOdPujei
inline void each_19XV(/*7:7*/ fu::view<Two_0bja> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _ZvrS(a[i], sum);

}
                                #endif

                                #ifndef DEF_sum_Zvft4awkyk5
                                #define DEF_sum_Zvft4awkyk5
inline static void sum_Zvft(/*3:3*/ fu::view<Two_0bja> what, /*2:2*/ int& sum)
{
    each_19XV(what, sum);
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    sum_Zvft((arr_of_two_LtD7(2) + arr_of_2_WLF9(3)), sum);
    if (sum == 10)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_two_LtD7(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_2_WLF9(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif

========

        struct Two(type T) { a: T; b: T };

        fn arr_of_two(x: int)               
            : _0::Two(int)[] = [[ x, x ]];  

        import _0;
        fn arr_of_2(x: int)                 
            [ Two(int)(x, x) ];             

        fn main() {
            mut sum = 0;
            fn sum !T(what: T)
                case (T -> _[])     what.each(.sum);
                default             sum += what.a + what.b;

            sum(_1::arr_of_two(2) ~ _2::arr_of_2(3));
            return sum == 10 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Two_0bja;
struct Two_0bja;
fu::vec<Two_0bja> arr_of_two_LtD7(int);
fu::vec<Two_0bja> arr_of_2_WLF9(int);

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sum_sHdIAIbGml7
                                #define DEF_sum_sHdIAIbGml7
inline static int sum_sHdI(/*3:3*/ const Two_0bja& what, /*3:3*/ int& sum)
{
    return (sum += (what.a + what.b));
}
                                #endif

                                #ifndef DEF___ZvrSek2MvWc
                                #define DEF___ZvrSek2MvWc
inline static int _ZvrS(/*3:3*/ const Two_0bja& _, /*3:3*/ int& sum)
{
    return sum_sHdI(_, sum);
}
                                #endif

                                #ifndef DEF_each_19XVOdPujei
                                #define DEF_each_19XVOdPujei
inline void each_19XV(/*7:7*/ fu::view<Two_0bja> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _ZvrS(a[i], sum);

}
                                #endif

                                #ifndef DEF_sum_Zvft4awkyk5
                                #define DEF_sum_Zvft4awkyk5
inline static void sum_Zvft(/*3:3*/ fu::view<Two_0bja> what, /*2:2*/ int& sum)
{
    each_19XV(what, sum);
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    sum_Zvft((arr_of_two_LtD7(2) + arr_of_2_WLF9(3)), sum);
    if (sum == 10)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_two_LtD7(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_2_WLF9(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif

========

        struct Two(type T) { a: T; b: T };

        fn arr_of_two(x: int)               
            : _0::Two(int)[] = [[ x, x ]];  

        import _0;
        fn arr_of_2(x: int)                 
            : Two(int)[] = [[ x, x ]];      

        fn main() {
            mut sum = 0;
            fn sum !T(what: T)
                case (T -> _[])     what.each(.sum);
                default             sum += what.a + what.b;

            sum(_1::arr_of_two(2) ~ _2::arr_of_2(3));
            return sum == 10 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct Two_0bja;
struct Two_0bja;
fu::vec<Two_0bja> arr_of_two_LtD7(int);
fu::vec<Two_0bja> arr_of_2_WLF9(int);

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sum_sHdIAIbGml7
                                #define DEF_sum_sHdIAIbGml7
inline static int sum_sHdI(/*3:3*/ const Two_0bja& what, /*3:3*/ int& sum)
{
    return (sum += (what.a + what.b));
}
                                #endif

                                #ifndef DEF___ZvrSek2MvWc
                                #define DEF___ZvrSek2MvWc
inline static int _ZvrS(/*3:3*/ const Two_0bja& _, /*3:3*/ int& sum)
{
    return sum_sHdI(_, sum);
}
                                #endif

                                #ifndef DEF_each_19XVOdPujei
                                #define DEF_each_19XVOdPujei
inline void each_19XV(/*7:7*/ fu::view<Two_0bja> a, /*7:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _ZvrS(a[i], sum);

}
                                #endif

                                #ifndef DEF_sum_Zvft4awkyk5
                                #define DEF_sum_Zvft4awkyk5
inline static void sum_Zvft(/*3:3*/ fu::view<Two_0bja> what, /*2:2*/ int& sum)
{
    each_19XV(what, sum);
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    sum_Zvft((arr_of_two_LtD7(2) + arr_of_2_WLF9(3)), sum);
    if (sum == 10)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_two_LtD7(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif
#include <fu/vec.h>

struct Two_0bja;

                                #ifndef DEF_Two_0bjaDoh1b3f
                                #define DEF_Two_0bjaDoh1b3f
struct Two_0bja
{
                                // shape_hash:    6d9eb67481faf4fa
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<Two_0bja> arr_of_2_WLF9(const int x)
{
    return fu::vec<Two_0bja> {{ Two_0bja { x, x } }};
}

#endif

========

        struct Some(type T) { some: T }
        fn wrap !T(v: T) Some(T)(v);

        fn map !T(v: Some(T), fn) {
            shadow let v =      
                fn(v);          

            return Some(typeof(v))(v);
        }

        fn Zero(sources: Some(string))
            sources;

        fn ZeroSame(alts: Some(Some(string)))
            alts.map(.Zero);

        fn ZeroSame(alts: Some(string))
            ZeroSame(alts.map(|x| wrap(x)));

        fn main() {
            let result = ZeroSame(wrap("Hello, World!"));
            return result.some.some.len - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:23+4[0m:

[2m      | [0m
[2m      |         fn ZeroSame(alts: Some(Some(string)))[0m
[2m   16 | [0m            alts.map(.[31;1mZero[0m);
[2m      | [0m
[2m      |         fn ZeroSame(alts: Some(string))[0m

	Bad call to [94;1mZero[0m with args ([35;3mstruct[0m [94;1mSome[0m([94;1mSome[0m([35;3mstring[0m))): 

	[35;3mfn[0m [94;1mZero[0m at [2m12:12+4[0m:
[2m   12 | [0m        fn [31;1mZero[0m(sources: Some(string))

	    [35;3marg[0m [94;1mZero[0m:[94;1msources[0m expects [35;3mstruct[0m [94;1mSome[0m([35;3mstring[0m), got [35;3mstruct[0m [94;1mSome[0m([94;1mSome[0m([35;3mstring[0m))

        Solving [35;3mfn[0m [94;1m_[0m([94;1mSome[0m) at [2m16:22+1[0m
                [35;3mfn[0m [94;1mmap[0m([94;1mSome[0m, [35;3m@1G0[0m) at [2m5:12+3[0m
                [35;3mfn[0m [94;1mZeroSame[0m([94;1mSome[0m) at [2m15:12+8[0m

========

        struct Some(type T) { some: T }
        fn wrap !T(v: T) Some(T)(v);

        fn map !T(v: Some(T), fn) {
            shadow let v =      
                fn(v.some);     

            return Some(typeof(v))(v);
        }

        fn Zero(sources: Some(string))
            sources;

        fn ZeroSame(alts: Some(Some(string)))
            alts.map(.Zero);

        fn ZeroSame(alts: Some(string))
            ZeroSame(alts.map(|x| wrap(x)));

        fn main() {
            let result = ZeroSame(wrap("Hello, World!"));
            return result.some.some.len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Some_CGyg;
struct Some_qXuE;

                                #ifndef DEF_Some_qXuEmD08eDf
                                #define DEF_Some_qXuEmD08eDf
struct Some_qXuE
{
                                // shape_hash:    c18d5b2a7157516b
                                // non_triv_mask: 0000800100000000
    fu::str some;
    explicit operator bool() const noexcept
    {
        return false
            || some
        ;
    }
};
                                #endif

                                #ifndef DEF_Some_CGyg1TfGDc8
                                #define DEF_Some_CGyg1TfGDc8
struct Some_CGyg
{
                                // shape_hash:    a43a75a71793e8f5
                                // non_triv_mask: 0040800100000000
    Some_qXuE some;
    explicit operator bool() const noexcept
    {
        return false
            || some
        ;
    }
};
                                #endif

                                #ifndef STR_M1K48y3AaFf
                                #define STR_M1K48y3AaFf
static const fu::str str_M1K48y3AaFf fu_INIT_PRIORITY(1001) { "Hello, World!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_wrap_YJyQXFrS1V6
                                #define DEF_wrap_YJyQXFrS1V6
inline static Some_qXuE wrap_YJyQ(/*1:1*/ fu::vec_range<char> v)
{
    return Some_qXuE { fu::str(v) };
}
                                #endif

                                #ifndef DEF___laXZmKd1npf
                                #define DEF___laXZmKd1npf
inline static Some_qXuE _laXZ(/*1:1*/ fu::vec_range<char> x)
{
    return wrap_YJyQ(x);
}
                                #endif

                                #ifndef DEF_map_1ktRxFI2Sqf
                                #define DEF_map_1ktRxFI2Sqf
inline static Some_CGyg map_1ktR(/*3:3*/ const Some_qXuE& v)
{
    /*MOV*/ Some_qXuE v_1 = _laXZ(v.some);
    return Some_CGyg { static_cast<Some_qXuE&&>(v_1) };
}
                                #endif

static const Some_qXuE& Zero_MbR9(/*1:1*/ const Some_qXuE& sources)
{
    return sources;
}

                                #ifndef DEF___zwTZ5TWGss2
                                #define DEF___zwTZ5TWGss2
inline static const Some_qXuE& _zwTZ(/*1:1*/ const Some_qXuE& _)
{
    return Zero_MbR9(_);
}
                                #endif

                                #ifndef DEF_map_qnKrlNqYlD7
                                #define DEF_map_qnKrlNqYlD7
inline static Some_CGyg map_qnKr(/*3:3*/ const Some_CGyg& v)
{
    const Some_qXuE& /*v*/ v_1 = _zwTZ(v.some);
    return Some_CGyg { Some_qXuE(v_1) };
}
                                #endif

static Some_CGyg ZeroSame_MbR9(/*1:1*/ const Some_CGyg& alts)
{
    return map_qnKr(alts);
}

static Some_CGyg ZeroSame_kGbb(/*1:1*/ const Some_qXuE& alts)
{
    return ZeroSame_MbR9(map_1ktR(alts));
}

int fu_MAIN()
{
    Some_CGyg result = ZeroSame_kGbb(wrap_YJyQ(str_M1K48y3AaFf));
    return result.some.some.size() - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Some(type T) { some: T }
        fn wrap !T(v: T) Some(T)(v);

        fn map !T(v: Some(T), fn) {
            shadow let v =      
                fn(v);          

            return Some(typeof(v))(v);
        }

        fn Zero(sources: Some(Some(string)))
            sources;

        fn ZeroSame(alts: Some(Some(Some(string))))
            alts.map(.Zero);

        fn ZeroSame(alts: Some(Some(string)))
            ZeroSame(alts.map(|x| wrap(x)));

        fn main() {
            let result = ZeroSame(wrap(wrap("Hello, World!")));
            return result.some.some.some.len - 13;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:23+4[0m:

[2m      | [0m
[2m      |         fn ZeroSame(alts: Some(Some(Some(string))))[0m
[2m   16 | [0m            alts.map(.[31;1mZero[0m);
[2m      | [0m
[2m      |         fn ZeroSame(alts: Some(Some(string)))[0m

	Bad call to [94;1mZero[0m with args ([35;3mstruct[0m [94;1mSome[0m([94;1mSome[0m([94;1mSome[0m([35;3mstring[0m)))): 

	[35;3mfn[0m [94;1mZero[0m at [2m12:12+4[0m:
[2m   12 | [0m        fn [31;1mZero[0m(sources: Some(Some(string)))

	    [35;3marg[0m [94;1mZero[0m:[94;1msources[0m expects [35;3mstruct[0m [94;1mSome[0m([94;1mSome[0m([35;3mstring[0m)), got [35;3mstruct[0m [94;1mSome[0m([94;1mSome[0m([94;1mSome[0m([35;3mstring[0m)))

        Solving [35;3mfn[0m [94;1m_[0m([94;1mSome[0m) at [2m16:22+1[0m
                [35;3mfn[0m [94;1mmap[0m([94;1mSome[0m, [35;3m@1K0[0m) at [2m5:12+3[0m
                [35;3mfn[0m [94;1mZeroSame[0m([94;1mSome[0m) at [2m15:12+8[0m

========

        struct Some(type T) { some: T }
        fn wrap !T(v: T) Some(T)(v);

        fn map !T(v: Some(T), fn) {
            shadow let v =      
                fn(v.some);     

            return Some(typeof(v))(v);
        }

        fn Zero(sources: Some(Some(string)))
            sources;

        fn ZeroSame(alts: Some(Some(Some(string))))
            alts.map(.Zero);

        fn ZeroSame(alts: Some(Some(string)))
            ZeroSame(alts.map(|x| wrap(x)));

        fn main() {
            let result = ZeroSame(wrap(wrap("Hello, World!")));
            return result.some.some.some.len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Some_7uAz;
struct Some_CGyg;
struct Some_qXuE;

                                #ifndef DEF_Some_qXuEmD08eDf
                                #define DEF_Some_qXuEmD08eDf
struct Some_qXuE
{
                                // shape_hash:    c18d5b2a7157516b
                                // non_triv_mask: 0000800100000000
    fu::str some;
    explicit operator bool() const noexcept
    {
        return false
            || some
        ;
    }
};
                                #endif

                                #ifndef DEF_Some_CGyg1TfGDc8
                                #define DEF_Some_CGyg1TfGDc8
struct Some_CGyg
{
                                // shape_hash:    a43a75a71793e8f5
                                // non_triv_mask: 0040800100000000
    Some_qXuE some;
    explicit operator bool() const noexcept
    {
        return false
            || some
        ;
    }
};
                                #endif

                                #ifndef DEF_Some_7uAzKxLmae3
                                #define DEF_Some_7uAzKxLmae3
struct Some_7uAz
{
                                // shape_hash:    349de3ed868ba952
                                // non_triv_mask: 8040800100000000
    Some_CGyg some;
    explicit operator bool() const noexcept
    {
        return false
            || some
        ;
    }
};
                                #endif

                                #ifndef STR_M1K48y3AaFf
                                #define STR_M1K48y3AaFf
static const fu::str str_M1K48y3AaFf fu_INIT_PRIORITY(1001) { "Hello, World!"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_wrap_YJyQXFrS1V6
                                #define DEF_wrap_YJyQXFrS1V6
inline static Some_qXuE wrap_YJyQ(/*1:1*/ fu::vec_range<char> v)
{
    return Some_qXuE { fu::str(v) };
}
                                #endif

                                #ifndef DEF_wrap_WBLgalh9Ozj
                                #define DEF_wrap_WBLgalh9Ozj
inline static Some_CGyg wrap_WBLg(/*1:1*/ const Some_qXuE& v)
{
    return Some_CGyg { Some_qXuE(v) };
}
                                #endif

                                #ifndef DEF___m5Bt17lAlkk
                                #define DEF___m5Bt17lAlkk
inline static Some_CGyg _m5Bt(/*1:1*/ const Some_qXuE& x)
{
    return wrap_WBLg(x);
}
                                #endif

                                #ifndef DEF_map_LcYvvjhwtja
                                #define DEF_map_LcYvvjhwtja
inline static Some_7uAz map_LcYv(/*3:3*/ const Some_CGyg& v)
{
    /*MOV*/ Some_CGyg v_1 = _m5Bt(v.some);
    return Some_7uAz { static_cast<Some_CGyg&&>(v_1) };
}
                                #endif

static const Some_CGyg& Zero_MbR9(/*1:1*/ const Some_CGyg& sources)
{
    return sources;
}

                                #ifndef DEF___ZSTZHf9N69d
                                #define DEF___ZSTZHf9N69d
inline static const Some_CGyg& _ZSTZ(/*1:1*/ const Some_CGyg& _)
{
    return Zero_MbR9(_);
}
                                #endif

                                #ifndef DEF_map_PJFJVBKe8Tf
                                #define DEF_map_PJFJVBKe8Tf
inline static Some_7uAz map_PJFJ(/*3:3*/ const Some_7uAz& v)
{
    const Some_CGyg& /*v*/ v_1 = _ZSTZ(v.some);
    return Some_7uAz { Some_CGyg(v_1) };
}
                                #endif

static Some_7uAz ZeroSame_MbR9(/*1:1*/ const Some_7uAz& alts)
{
    return map_PJFJ(alts);
}

static Some_7uAz ZeroSame_kGbb(/*1:1*/ const Some_CGyg& alts)
{
    return ZeroSame_MbR9(map_LcYv(alts));
}

int fu_MAIN()
{
    Some_7uAz result = ZeroSame_kGbb(wrap_WBLg(wrap_YJyQ(str_M1K48y3AaFf)));
    return result.some.some.some.size() - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Thing(type <Value>) { value: Value }

        fn woot(ref t: Thing(int) or Thing(uint), what)
            what(t.value);

        fn main() {
            mut t = _0::Thing(int)(11);
            t.woot(|ref v| v += v);
            return t.value - 22;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Thing_LxH9;

                                #ifndef DEF_Thing_LxH9EFlMqq1
                                #define DEF_Thing_LxH9EFlMqq1
struct Thing_LxH9
{
                                // shape_hash:    131ab282dddfc901
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___cTNL8IZpL41
                                #define DEF___cTNL8IZpL41
inline static int _cTNL(/*1:1*/ int& v)
{
    return (v += v);
}
                                #endif

                                #ifndef DEF_woot_VUScwob8fn6
                                #define DEF_woot_VUScwob8fn6
inline int woot_VUSc(/*3:3*/ Thing_LxH9& t)
{
    return _cTNL(t.value);
}
                                #endif

int fu_MAIN()
{
    Thing_LxH9 t = Thing_LxH9 { 11 };
    woot_VUSc(t);
    return t.value - 22;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Tuple(type <Left>, type <Right>) { left: Left; right: Right }

        fn woot(ref t: Tuple(<T>, Tuple(int, int)))
            t.right.left += t.right.right;

        fn main() {
            mut t = _0::Tuple(int, _0::Tuple(int, int))(0, _0::Tuple(int, int)(2, 3));
            t.woot();
            return t.right.left - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Tuple_9qvZ;
struct Tuple_ZUBf;

                                #ifndef DEF_Tuple_ZUBfHQnK2n1
                                #define DEF_Tuple_ZUBfHQnK2n1
struct Tuple_ZUBf
{
                                // shape_hash:    9d05172f1f11aff0
                                // non_triv_mask: 0000000000000000
    int left;
    int right;
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

                                #ifndef DEF_Tuple_9qvZxGxvii0
                                #define DEF_Tuple_9qvZxGxvii0
struct Tuple_9qvZ
{
                                // shape_hash:    97038b4cec900730
                                // non_triv_mask: 0000000000000000
    int left;
    Tuple_ZUBf right;
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_woot_Mx35KQjAxyf
                                #define DEF_woot_Mx35KQjAxyf
inline int woot_Mx35(/*1:1*/ Tuple_9qvZ& t)
{
    return (t.right.left += t.right.right);
}
                                #endif

int fu_MAIN()
{
    Tuple_9qvZ t = Tuple_9qvZ { {/*unused non-zst*/}, Tuple_ZUBf { 2, 3 } };
    woot_Mx35(t);
    return t.right.left - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(x: i32) {
            :OUTER {
                :INNER {
                    if (x > 1) break :OUTER;                    // Goto
                    if (x > 0) break :INNER;
                    return 2;
                }
                return 1;
            }
            return 0;
        }

        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{

    { {
        if (x > 1)
            goto BL_1;
        else
        {
            if (!(x > 0))
                return 2;

        };
        return 1;
      } BL_1:;
    };
    return 0;
}

int fu_MAIN()
{
    return ((test_MbR9(2) * 11) + ((test_MbR9(1) - 1) * 13)) + ((test_MbR9(0) - 2) * 17);
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32) {
            return {
                :BLOCK {
                    if (x & 1) break :BLOCK 1;
                    if (x & 2) return 2;
                    3
                }
            };
        }

        fn main() 4.test - 5.test - 6.test; // 3-1-2

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    if (x & 1)
        return 1;
    else if (x & 2)
        return 2;
    else
        return 3;

}

int fu_MAIN()
{
    return (test_MbR9(4) - test_MbR9(5)) - test_MbR9(6);
}

#endif

int main() { return fu_MAIN(); }

========

        fn brkif(mut x: i32)
        {
            :WOOT
            if (x & 1) {
                if (x & 2) x++;
                if (x & 4) break :WOOT;                         // Goto
                x *= x;
            }

            return x;
        }

        fn main()
            brkif(1) + brkif(3) * 10 + brkif(5) * 100 + brkif(9) * 1000
                == 81541 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int brkif_MbR9(int x)
{

    { {
        if (x & 1)
        {
            if (x & 2)
                x++;

            if (x & 4)
                goto BL_1;
            else
                x *= x;

        };
      } BL_1:;
    };
    return x;
}

int fu_MAIN()
{
    if ((((brkif_MbR9(1) + (brkif_MbR9(3) * 10)) + (brkif_MbR9(5) * 100)) + (brkif_MbR9(9) * 1000)) == 81541)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a: i32) {
            mut w = 3;
            :OUTER w += {                                       // GNUStmtExpr
                :INNER {
                    if (a & 1)  break :INNER;
                    else        break :OUTER;                   // Goto
                };
                5
            };
            return w;
        }
        fn main() 0.test + 1.test - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_MbR9(const int a)
{
    int w = 3;

    { {
        w += ((a & 1) ? 5 : (__extension__ (
        {
            goto BL_1;
            (void)0;
        }), fu::unreachable));
      } BL_1:;
    };
    return w;
}

int fu_MAIN()
{
    return (test_MbR9(0) + test_MbR9(1)) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn ifbrk(a: i32) {
            mut x = 0;
            if (a & 3) {
                x += a;

                :IF_LABEL
                if (a & 1) {
                    mut incr    = a & 4 ? a * 2
                                : a & 2 ? { break :IF_LABEL; }  // Goto
                                        : a;                    // GNUStmtExpr
                    x += incr;
                }
            }

            return x;
        }

        fn main() 1.ifbrk + 3.ifbrk * 10 + 5.ifbrk * 100 - 1532;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int ifbrk_MbR9(const int a)
{
    int x = 0;
    if (a & 3)
    { {
        x += a;
        if (a & 1)
        {
            const int incr = ((a & 4) ? (a * 2) : ((a & 2) ? (__extension__ (
            {
                goto BL_1;
                (void)0;
            }), fu::unreachable) : a));
            x += incr;
        };
      } BL_1:;
    };
    return x;
}

int fu_MAIN()
{
    return ((ifbrk_MbR9(1) + (ifbrk_MbR9(3) * 10)) + (ifbrk_MbR9(5) * 100)) - 1532;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(x: i32) {
            return {
                :BLOCK 2 * {
                    if (x) break :BLOCK 3;                      // GNUStmtExpr
                    1
                }
            };
        }

        fn main() = test(0) == 2 && test(1) == 3 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    return 2 * (x ? (__extension__ (
    {
        return 3;
        (void)0;
    }), fu::unreachable) : 1);
}

int fu_MAIN()
{
    if ((test_MbR9(0) == 2) && (test_MbR9(1) == 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn v(x: i32) {                                          // GNUStmtExpr
            return {
                :BLOCK                          5000 + { // *2:
                    if (x == 9) continue :BLOCK 2000;    //   - here
                    if (x == 8) return           300;
                    if (x == 7) break :BLOCK      40;

                    5                                    //   - and here!
                }
            }  // -----------------------------------
        }
        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int v_MbR9(const int x)
{
    return 5000 + ((x == 9) ? 2000 : ((x == 8) ? (__extension__ (
    {
        return 300;
        (void)0;
    }), fu::unreachable) : ((x == 7) ? (__extension__ (
    {
        return 40;
        (void)0;
    }), fu::unreachable) : 5)));
}

int fu_MAIN()
{
    return (((v_MbR9(9) + v_MbR9(8)) + v_MbR9(7)) + v_MbR9(6)) - 12345;
}

#endif

int main() { return fu_MAIN(); }

========

        pub fn test(x: i32[], y: i32[]) {
            let z = {
                :BLOCK {
                    mut w: i32[] = x;
                    if (y[0]) w ~= y;
                    if (w[0] != 17)
                        break :BLOCK w;
                    x
                }
            };

            return z[0] + z[z.len - 1];
        }

        fn main() test([ 1 ], [ 2 ]) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int test_MbR9(/*3:3*/ fu::vec_range<int> x, /*3:3*/ fu::view<int> y)
{
    fu::vec<int> w {};
    fu::view<int> /*w|x*/ z = (w = fu::vec<int>(x), (y[0] && ((w += y), 0)), ((w[0] != 17) ? w : x));
    return z[0] + z[(z.size() - 1)];
}

int fu_MAIN()
{
    return test_MbR9(fu::vec<int> {{ 1 }}, fu::view<int> {{ 2 }}) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn test(mut x: i32) {
            {
                x++;
                :CANT_FLATTEN { // naive block flattening
                                //  can damage this label
                    if (x & 1) break :CANT_FLATTEN;
                    return x;
                }
            }
            return x * 2;
        }

        fn main() test(1) + test(2) - 8;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(int x)
{

    {
        x++;
        if (!(x & 1))
            return x;

    };
    return x * 2;
}

int fu_MAIN()
{
    return (test_MbR9(1) + test_MbR9(2)) - 8;
}

#endif

int main() { return fu_MAIN(); }

========

        fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn Some(arr, fn) {
            arr.Each: |x| if (fn(x)) return x;
            return 0;
        }

        fn main() [ 1, 2, 3 ].Some(|v| v & 1 == 0) - 2;

        // EXPECT fu::view<int> {{ 1, 2, 3 }}

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___N1f4ulAmbz1
                                #define DEF___N1f4ulAmbz1
inline static bool _N1f4(const int v)
{
    return (v & 1) == 0;
}
                                #endif

                                #ifndef DEF_Some_g5GuTAeu4xj
                                #define DEF_Some_g5GuTAeu4xj
inline static int Some_g5Gu(/*3:3*/ fu::view<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        const int /*arr|static*/ x = arr[i];
        if (_N1f4(x))
            return x;

    };
    return 0;
}
                                #endif

int fu_MAIN()
{
    return Some_g5Gu(fu::view<int> {{ 1, 2, 3 }}) - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        fn outer() {
            mut sum = 0;

            inline fn inner(v: i32) {                           // GNUStmtExpr
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return :outer sum;
                }

                return v * 2;
            }

            mut x = 1;
            for (;;) x = inner(x);
        }

        fn main() outer - 42; // extra points for style

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int outer_MbR9()
{
    int sum = 0;
    int x = 1;
    for (; ; )
    {
        int BL_3_v;
        x = (__extension__ (
        {
            const int /*x*/ v = x;
            for (int i = 0; i < 10; i++)
            {
                sum += v;
                if (sum > 40)
                    return sum;

            };
            BL_3_v = ((v * 2));
            (void)0;
        }), BL_3_v);
    };
}

int fu_MAIN()
{
    return outer_MbR9() - 42;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        inline fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn main() {
            mut sum = 0;
            :OUTER [1, 2, 3, 4].Each(|x| {
                sum += x;
                for (mut i = 1; i--; ) // once
                    if (sum == 6) break :OUTER;                 // Goto
            });
            return sum - 6;
        }

        // !N_NonTrivAutoCopy

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;

    { {
        fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3, 4 }};
        for (int i = 0; i < arr.size(); i++)
        {
            const int /*arr|static*/ x = arr[i];
            sum += x;
            for (int i_1 = 1; i_1--; )
            {
                if (sum == 6)
                    goto BL_1;

            };
        };
      } BL_1:;
    };
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        inline fn hello(ref sum) {  //     when inlined into woot
            if (sum > 2) return;    //      the hello block now looks like an expr
            sum += 2;               // <-    with a diverging tail return here
        }

        fn woot(ref sum) hello(sum);

        fn main() {
            mut sum = -2;
            sum.woot();
            return sum;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_woot_w5hYzFtdTU3
                                #define DEF_woot_w5hYzFtdTU3
inline static void woot_w5hY(/*1:1*/ int& sum)
{
    if (!(sum > 2))
        sum += 2;

}
                                #endif

int fu_MAIN()
{
    int sum = -2;
    woot_w5hY(sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

========

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) break; });
            return x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_loop1d_RxWeL7zYO1b
                                #define DEF_loop1d_RxWeL7zYO1b
inline static void loop1d_RxWe(const int i0, const int i1, /*F:F*/ int& x)
{
    for (int i = i0; i < i1; i++)
    {
        const int /*i*/ i_1 = i;
        if ((x += i_1))
            return;

    };
}
                                #endif

int fu_MAIN()
{
    int x = 0;
    loop1d_RxWe(0, 10, x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) return x - 1; });
            return 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;

    {
        const int i0 = 0;
        const int i1 = 10;
        for (int i = i0; i < i1; i++)
        {
            const int /*i*/ i_1 = i;
            if ((x += i_1))
                return x - 1;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

========

        fn loop2d(x0, x1, y0, y1, fn) {
            for (mut y = y0; y < y1; y++)
            for (mut x = x0; x < x1; x++) fn(x, y);
        }

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_loop2d_cDHa2xg4l5f
                                #define DEF_loop2d_cDHa2xg4l5f
inline static void loop2d_cDHa(const int x0, const int x1, const int y0, const int y1, /*F3:F3*/ int& sum)
{
    for (int y = y0; y < y1; y++)
    {
        for (int x = x0; x < x1; x++)
        {
            const int /*x*/ x_1 = x;
            const int /*y*/ y_1 = y;
            if (y_1 < 11)
                sum++;
            else if (x_1 == 1)
                return;
            else
                sum += ((x_1 + 1) * y_1);

        };
    };
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    loop2d_cDHa(0, 10, 10, 12, sum);
    return sum - 21;
}

#endif

int main() { return fu_MAIN(); }

========

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn loop2d(x0, x1, y0, y1, fn)
            loop1d(y0, y1, |y|
                loop1d(x0, x1, |x|
                    fn (x, y)));

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_loop2d_OqiyjEea0vi
                                #define DEF_loop2d_OqiyjEea0vi
inline static void loop2d_Oqiy(const int x0, const int x1, const int y0, const int y1, /*F3:F3*/ int& sum)
{
    for (int i = y0; i < y1; i++)
    {
        const int /*i*/ y = i;
        for (int i_1 = x0; i_1 < x1; i_1++)
        {
            const int /*i_1*/ x = i_1;
            if (y < 11)
                sum++;
            else if (x == 1)
                return;
            else
                sum += ((x + 1) * y);

        };
    };
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    loop2d_Oqiy(0, 10, 10, 12, sum);
    return sum - 21;
}

#endif

int main() { return fu_MAIN(); }

========

        fn next(implicit ref sum: i32, lifetime: i32[..], locals_start: i32) {
            sum += lifetime.len;
            return lifetime[locals_start .. lifetime.len];
        }

        fn Lifetime_each(lifetime: i32[..], visit) {
            for (mut i = 0; i < lifetime.len; i++)
                visit(lifetime[i .. ]);
        }

        fn Lifetime_F_TODO_FIX_RRET(lifetime: i32[..], locals_start: i32) {
            Lifetime_each(:lifetime, visit: |l| {
                if (l)
                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);
            });
        }

        fn main() {
            let lifetime = [ 1, 2 ];
            implicit mut sum = 0;
            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);
            return sum - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

static void Lifetime_F_TODO_FIX_RRET_MbR9(fu::view<int>, int, int&);

#ifndef fu_NO_fdefs

static fu::view<int> next_MbR9(/*7:7*/ fu::view<int> lifetime, const int locals_start, /*6:6*/ int& sum)
{
    sum += lifetime.size();
    return fu::get_view(lifetime, locals_start, lifetime.size());
}

                                #ifndef DEF_visit_5H9Lyq3iZa3
                                #define DEF_visit_5H9Lyq3iZa3
inline static void visit_5H9L(/*7:7*/ fu::view<int> l, /*7:7*/ const int locals_start, /*6:4*/ int& sum)
{
    if (l)
    {
        fu::view<int> _0 {};
        (_0.ptr_reassign(next_MbR9(l, locals_start, sum)), Lifetime_F_TODO_FIX_RRET_MbR9(_0, locals_start, sum));
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_oVpPWm7yqwe
                                #define DEF_Lifetime_each_oVpPWm7yqwe
inline static void Lifetime_each_oVpP(/*F:F*/ fu::view<int> lifetime, /*F:F*/ const int locals_start, /*E:A*/ int& sum)
{
    for (int i = 0; i < lifetime.size(); i++)
    {
        visit_5H9L(fu::get_view(lifetime, i), locals_start, sum);
    };
}
                                #endif

static void Lifetime_F_TODO_FIX_RRET_MbR9(/*7:7*/ fu::view<int> lifetime, const int locals_start, /*4:4*/ int& sum)
{
    Lifetime_each_oVpP(lifetime, locals_start, sum);
}

int fu_MAIN()
{
    fu::vec<int> lifetime = fu::vec<int> {{ 1, 2 }};
    int sum = 0;
    Lifetime_F_TODO_FIX_RRET_MbR9(lifetime, 1, sum);
    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedCall, N_BckMustSeq

========

        fn next(implicit ref sum: i32, lifetime: i32[..], locals_start: i32) {
            sum += lifetime.len;
            return lifetime[locals_start .. lifetime.len];
        }

        fn Lifetime_each(lifetime: i32[..], visit) {
            for (mut i = 0; i < lifetime.len; i++)
                visit(lifetime[i .. lifetime.len]);
        }

        fn Lifetime_F_TODO_FIX_RRET(lifetime: i32[..], locals_start: i32) {
            Lifetime_each(:lifetime, visit: |l| {
                if (l)
                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);
            });
        }

        fn main() {
            let lifetime = [ 1, 2 ];
            implicit mut sum = 0;
            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);
            return sum - 4;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

static void Lifetime_F_TODO_FIX_RRET_MbR9(fu::view<int>, int, int&);

#ifndef fu_NO_fdefs

static fu::view<int> next_MbR9(/*7:7*/ fu::view<int> lifetime, const int locals_start, /*6:6*/ int& sum)
{
    sum += lifetime.size();
    return fu::get_view(lifetime, locals_start, lifetime.size());
}

                                #ifndef DEF_visit_5H9Lyq3iZa3
                                #define DEF_visit_5H9Lyq3iZa3
inline static void visit_5H9L(/*7:7*/ fu::view<int> l, /*7:7*/ const int locals_start, /*6:4*/ int& sum)
{
    if (l)
    {
        fu::view<int> _0 {};
        (_0.ptr_reassign(next_MbR9(l, locals_start, sum)), Lifetime_F_TODO_FIX_RRET_MbR9(_0, locals_start, sum));
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_QKxjx60tq8l
                                #define DEF_Lifetime_each_QKxjx60tq8l
inline static void Lifetime_each_QKxj(/*F:F*/ fu::view<int> lifetime, /*F:F*/ const int locals_start, /*E:A*/ int& sum)
{
    for (int i = 0; i < lifetime.size(); i++)
    {
        visit_5H9L(fu::get_view(lifetime, i, lifetime.size()), locals_start, sum);
    };
}
                                #endif

static void Lifetime_F_TODO_FIX_RRET_MbR9(/*7:7*/ fu::view<int> lifetime, const int locals_start, /*4:4*/ int& sum)
{
    Lifetime_each_QKxj(lifetime, locals_start, sum);
}

int fu_MAIN()
{
    fu::vec<int> lifetime = fu::vec<int> {{ 1, 2 }};
    int sum = 0;
    Lifetime_F_TODO_FIX_RRET_MbR9(lifetime, 1, sum);
    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedCall, N_BckMustSeq

========

        fn test(x: i32, ref odds: i32) {
            return x & 1 ? { odds++; x } : x + 1;
        }

        fn main() {
            let nums = [ 1, 2, 3 ];
            mut odds = 0;
            mut sum  = 0;
            for (mut i = 0; i < nums.len; i++)
                sum += test(nums[i], :odds);

            return odds != 2 ? 100
                 : sum  != 7 ? 200
                 : 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int test_MbR9(const int x, /*3:3*/ int& odds)
{
    if (x & 1)
    {
        odds++;
        return x;
    }
    else
        return x + 1;

}

int fu_MAIN()
{
    fu::vec<int> nums = fu::vec<int> {{ 1, 2, 3 }};
    int odds = 0;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++)
        sum += test_MbR9(nums[i], odds);

    if (odds != 2)
        return 100;
    else if (sum != 7)
        return 200;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref x: i32) {
            return {
                :BLOCK {
                    if (x & 1)  break :BLOCK x++;
                    else        break :BLOCK x * 2;
                }
            };
        }

        fn main() {
            mut x = 1;
            return test(x) == 1 && test(x) == 4 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ int& x)
{
    if (x & 1)
        return x++;
    else
        return x * 2;

}

int fu_MAIN()
{
    int x = 1;
    if ((test_MbR9(x) == 1) && (test_MbR9(x) == 4))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn PASS_borrowCheck(ref x: i32[]) {
            fn bck_node(add: i32) {
                for (mut i = 0; i < x.len; i++) {
                    x[i] *= x[i];
                    x[i] += add;
                }
            }

            bck_node(1);

            :SOLVE_AAR {
                if (x.len & 2)
                    bck_node(2);

                if (x.len & 1)
                    break :SOLVE_AAR;

                bck_node(3);
            }
        }

        fn main() {
            mut a = [ 1, 2, 3 ];
            mut b = [ 1, 2 ];
            PASS_borrowCheck(a);
            PASS_borrowCheck(b);
            return a[2] == 102 && b[1] == 732 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void bck_node_MbR9(const int add, /*3:3*/ fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
    {
        x.mutref(i) *= x[i];
        x.mutref(i) += add;
    };
}

static void PASS_borrowCheck_MbR9(/*1:1*/ fu::view_mut<int> x)
{
    bck_node_MbR9(1, x);
    if (x.size() & 2)
        bck_node_MbR9(2, x);

    if (!(x.size() & 1))
        bck_node_MbR9(3, x);

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> {{ 1, 2, 3 }};
    fu::vec<int> b = fu::vec<int> {{ 1, 2 }};
    PASS_borrowCheck_MbR9(a);
    PASS_borrowCheck_MbR9(b);
    if ((a[2] == 102) && (b[1] == 732))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn rev(arr, fn) {
            for (mut i = arr.len; i --> 0; ) {
                if (!arr[i])
                    break;

                fn(arr[i], i?: i);

            }
        }

        fn test(arr) {
            mut sum = 0;
            arr.rev: |x| {
                if (x & 1) continue;
                sum += x;
            }
            return sum;
        }

        fn main() {
            return test([2, 4, 6, 8]) == 20
                && test([2, 4, 7, 8]) == 14
                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___d7mDumVx1pk
                                #define DEF___d7mDumVx1pk
inline static void _d7mD(const int x, /*3:3*/ int& sum)
{
    if (!(x & 1))
        sum += x;

}
                                #endif

                                #ifndef DEF_rev_fCA97bwjh2h
                                #define DEF_rev_fCA97bwjh2h
inline static void rev_fCA9(/*7:7*/ fu::view<int> arr, /*6:6*/ int& sum)
{
    for (int i = arr.size(); i-- > 0; )
    {
        if (!arr[i])
            break;
        else
            _d7mD(arr[i], sum);

    };
}
                                #endif

                                #ifndef DEF_test_8LXMNZckkpg
                                #define DEF_test_8LXMNZckkpg
inline static int test_8LXM(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    rev_fCA9(arr, sum);
    return sum;
}
                                #endif

int fu_MAIN()
{
    if ((test_8LXM(fu::view<int> {{ 2, 4, 6, 8 }}) == 20) && (test_8LXM(fu::view<int> {{ 2, 4, 7, 8 }}) == 14) && (test_8LXM(fu::view<int> {{ 2, 4, 0, 8 }}) == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn rev(arr, fn) {
            for (mut i = arr.len; i --> 0; ) {
                if (!arr[i])
                    break;

                else
                    fn(arr[i], i?: i);

            }
        }

        fn test(arr) {
            mut sum = 0;
            arr.rev: |x| {
                if (x & 1) continue;
                sum += x;
            }
            return sum;
        }

        fn main() {
            return test([2, 4, 6, 8]) == 20
                && test([2, 4, 7, 8]) == 14
                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___d7mDumVx1pk
                                #define DEF___d7mDumVx1pk
inline static void _d7mD(const int x, /*3:3*/ int& sum)
{
    if (!(x & 1))
        sum += x;

}
                                #endif

                                #ifndef DEF_rev_fCA97bwjh2h
                                #define DEF_rev_fCA97bwjh2h
inline static void rev_fCA9(/*7:7*/ fu::view<int> arr, /*6:6*/ int& sum)
{
    for (int i = arr.size(); i-- > 0; )
    {
        if (!arr[i])
            break;
        else
            _d7mD(arr[i], sum);

    };
}
                                #endif

                                #ifndef DEF_test_8LXMNZckkpg
                                #define DEF_test_8LXMNZckkpg
inline static int test_8LXM(/*1:1*/ fu::view<int> arr)
{
    int sum = 0;
    rev_fCA9(arr, sum);
    return sum;
}
                                #endif

int fu_MAIN()
{
    if ((test_8LXM(fu::view<int> {{ 2, 4, 6, 8 }}) == 20) && (test_8LXM(fu::view<int> {{ 2, 4, 7, 8 }}) == 14) && (test_8LXM(fu::view<int> {{ 2, 4, 0, 8 }}) == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            fn exit(code: i32) { return :main code; }
            fn exitViaArgdef(what: i32 = exit(0)) = what;
            exitViaArgdef();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int code = 0;
    return code;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn main() {
            fn exit(code: i32) { return :main code; }
            fn exitViaArgdef(a: i32 = exit(0), b?) = a + b;
            exitViaArgdef()
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int code = 0;
    return code;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========


        fn test(mut x: i32) {
            fn loopInsideInlineArg(inline theLoop = {
                while (x) {
                    if (x & 1)  return x;
                    if (x & 2)  break;
                    if (x & 8)  return :test x * 100;
                    x /= 2;
                }
            }) {
                theLoop();
                return x * 10;
            }

            return loopInsideInlineArg() * 3;                   // GNUStmtExpr
        }

        fn main() {
            let a = test(5);
            let b = test(4);
            let c = test(16);
            return a == 5 && b == 60 && c == 800 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(int x)
{
    int BL_1_v;
    return (__extension__ (
    {
        while (x)
        {
            if (x & 1)
                return x;
            else if (x & 2)
                break;
            else if (x & 8)
                return x * 100;
            else
                x /= 2;

        };
        BL_1_v = ((x * 10));
        (void)0;
    }), BL_1_v) * 3;
}

int fu_MAIN()
{
    const int a = test_MbR9(5);
    const int b = test_MbR9(4);
    const int c = test_MbR9(16);
    if ((a == 5) && (b == 60) && (c == 800))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========


        inline                                                  // Goto

        fn test(mut x: i32) {
            fn loopInsideInlineArg(inline theLoop = {
                while (x) {
                    if (x & 1)  return x;
                    if (x & 2)  break;
                    if (x & 8)  return :test x * 100;
                    x /= 2;
                }
            }) {
                theLoop();
                return x * 10;
            }

            return loopInsideInlineArg() * 3;                   // GNUStmtExpr
        }

        fn main() {
            let a = test(5);
            let b = test(4);
            let c = test(16);
            return a == 5 && b == 60 && c == 800 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v;
    const int a = (__extension__ (
    { {
        int x = 5;
        int BL_2_v;
        BL_1_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_1_v = x; goto BL_1; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_1_v = (x * 100); goto BL_1; };
                }
                else
                    x /= 2;

            };
            BL_2_v = ((x * 10));
            (void)0;
        }), BL_2_v) * 3));
      } BL_1:;
        (void)0;
    }), BL_1_v);
    int BL_9_v;
    const int b = (__extension__ (
    { {
        int x = 4;
        int BL_10_v;
        BL_9_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_9_v = x; goto BL_9; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_9_v = (x * 100); goto BL_9; };
                }
                else
                    x /= 2;

            };
            BL_10_v = ((x * 10));
            (void)0;
        }), BL_10_v) * 3));
      } BL_9:;
        (void)0;
    }), BL_9_v);
    int BL_17_v;
    const int c = (__extension__ (
    { {
        int x = 16;
        int BL_18_v;
        BL_17_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_17_v = x; goto BL_17; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_17_v = (x * 100); goto BL_17; };
                }
                else
                    x /= 2;

            };
            BL_18_v = ((x * 10));
            (void)0;
        }), BL_18_v) * 3));
      } BL_17:;
        (void)0;
    }), BL_17_v);
    if ((a == 5) && (b == 60) && (c == 800))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn UnusedArgError(arr: i32[], fn)
            for (mut i = 0; i < arr.len; i++)
                fn(hello: arr[i], i?: i);

        fn main() {
            mut sum = 0;
            let arr = [ 1, 2, -3 ];
            arr.UnusedArgError: |lax i, hello|

                sum += arr[i];         

            return sum;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:41+5[0m:

[2m      |             mut sum = 0;[0m
[2m      |             let arr = [ 1, 2, -3 ];[0m
[2m    9 | [0m            arr.UnusedArgError: |lax i, [31;1mhello[0m|
[2m      | [0m
[2m      |                 sum += arr[i];         [0m

	Unused variable: [35;3marg[0m [94;1mhello[0m. Make it [35;3mlax[0m if this is intentional.

========

        fn UnusedArgError(arr: i32[], fn)
            for (mut i = 0; i < arr.len; i++)
                fn(hello: arr[i], i?: i);

        fn main() {
            mut sum = 0;
            let arr = [ 1, 2, -3 ];
            arr.UnusedArgError: |lax i, hello|

                sum += hello;          

            return sum;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___JwPlqSFtGDd
                                #define DEF___JwPlqSFtGDd
inline static int _JwPl(const int hello, /*7:7*/ int& sum)
{
    return (sum += hello);
}
                                #endif

                                #ifndef DEF_UnusedArgError_CSG7gUPbGnd
                                #define DEF_UnusedArgError_CSG7gUPbGnd
inline static void UnusedArgError_CSG7(/*7:7*/ fu::view<int> arr, /*6:6*/ int& sum)
{
    for (int i = 0; i < arr.size(); i++)
        _JwPl(arr[i], sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, -3 }};
    UnusedArgError_CSG7(arr, sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test() {     
            break;      
        }
        fn main() = test();

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+5[0m:

[2m      | [0m
[2m      |         fn test() {     [0m
[2m    3 | [0m            [31;1mbreak[0m;      
[2m      |         }[0m
[2m      |         fn main() = test();[0m

	Nothing to [35;3mbreak[0m from here.

	No surrounding loop or |code| block.

========

        fn test() {     
            return 0;   
        }
        fn main() = test();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

========

        fn test() {
            let hello = || {    
                break;          
            };

            return hello;
        }
        fn main() = test();

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:17+5[0m:

[2m      |         fn test() {[0m
[2m      |             let hello = || {    [0m
[2m    4 | [0m                [31;1mbreak[0m;          
[2m      |             };[0m
[2m      | [0m

	Nothing to [35;3mbreak[0m from here.

	No surrounding loop or |code| block.

========

        fn test() {
            let hello = || {    
                return 0;       
            };

            return hello;
        }
        fn main() = test();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

========

        fn run(action) action();
        fn test() {
            run: || {
                let hello = || {    
                    break;          
                };

                return hello;
            };
        }
        fn main() = test();

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:21+5[0m:

[2m      |             run: || {[0m
[2m      |                 let hello = || {    [0m
[2m    6 | [0m                    [31;1mbreak[0m;          
[2m      |                 };[0m
[2m      | [0m

	Nothing to [35;3mbreak[0m from here.

	No surrounding loop or |code| block.

========

        fn run(action) action();
        fn test() {
            run: || {
                let hello = || {    
                    return 0;       
                };

                return hello;
            };
        }
        fn main() = test();

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn test() {     
            continue;   
        }
        fn main() = test();

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+8[0m:

[2m      | [0m
[2m      |         fn test() {     [0m
[2m    3 | [0m            [31;1mcontinue[0m;   
[2m      |         }[0m
[2m      |         fn main() = test();[0m

	Nothing to [35;3mcontinue[0m from here.

	No surrounding loop or callsite: |code| block.

========

        fn main() {

            let lambda = |nil?| { return nil; } 

            fn test() return lambda + 11;       

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall, N_UnusedLet

========

        fn main() {

            let lambda = |nil?| { return nil; } 

            fn test() lambda + 11;              

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall, N_UnusedLet

========

        fn main() {

            let lambda = |nil?| { return nil; } 

            let test = || lambda + 11;          

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall, N_UnusedLet

========

        fn main() {

            let lambda = || { return 0; }       

            fn test() return lambda + 11;       

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========

        fn main() {

            let lambda = || { return 0; }       

            fn test() lambda + 11;              

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========

        fn main() {

            let lambda = || { return 0; }       

            let test = || lambda + 11;          

            return test + 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

========

        fn each(ref arr: i32[], even, odd)
            for (mut i = 0; i < arr.len; i++)
                if (!i) odd(i?: i, it?: arr[i]);
                else   even(i?: i, it?: arr[i]);

        fn main() {
            mut arr = [ 1, 2, 3 ];
            arr.each(odd: |ref it| it++, even: || { break; });

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_odd_4n9IRCewvq2
                                #define DEF_odd_4n9IRCewvq2
inline static int odd_4n9I(/*1:1*/ int& it)
{
    return it++;
}
                                #endif

                                #ifndef DEF_each_bpo0pOs6wed
                                #define DEF_each_bpo0pOs6wed
inline static void each_bpo0(/*7:7*/ fu::view_mut<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        if (!i)
            odd_4n9I(arr.mutref(i));
        else
            return;

    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3 }};
    each_bpo0(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct BitSet { _data: u8 };

        fn each(ref ._data, visit)
            if (_data) for (mut b = 0; b < 8; b++) {
                let mask = 1 << b.u8;
                let remove = || _data &= ~mask;
                if (_data & mask)
                    visit(b.int, ?:fn remove);
            }

        fn Lifetime_process(ref set: BitSet, fn)
            set.each: |locid, remove| {
                fn continue_keep() { continue; }
                fn(:locid, ?:fn continue_keep);
                remove();
            }

        fn main() {
            mut ls = BitSet(255.u8);
            ls.Lifetime_process: |locid, continue_keep|
                if (locid & 1)
                    continue_keep();

            return ls._data == 170 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

struct BitSet_qlWf;

                                #ifndef DEF_BitSet_qlWfsmPT870
                                #define DEF_BitSet_qlWfsmPT870
struct BitSet_qlWf
{
                                // shape_hash:    0eaf3a91ece87510
                                // non_triv_mask: 0000000000000000
    fu::u8 _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___KAvPRqkCp46
                                #define DEF___KAvPRqkCp46
inline static fu::u8 _KAvP(/*3:3*/ fu::u8& _data, /*3:3*/ const fu::u8 mask)
{
    return (_data &= fu::u8(~mask));
}
                                #endif

                                #ifndef DEF___FIkAg4GPaH0
                                #define DEF___FIkAg4GPaH0
inline static void _FIkA(const int locid, /*F:F*/ fu::u8& _data, /*F:F*/ const fu::u8 mask)
{
    if (!(locid & 1))
        _KAvP(_data, mask);

}
                                #endif

                                #ifndef DEF_each_SgsRYuT58Aa
                                #define DEF_each_SgsRYuT58Aa
inline static void each_SgsR(/*3:3*/ fu::u8& _data)
{
    if (_data)
    {
        for (int b = 0; b < 8; b++)
        {
            const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
            if (_data & mask)
                _FIkA(int(b), _data, mask);

        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_process_3wYftkGdatb
                                #define DEF_Lifetime_process_3wYftkGdatb
inline static void Lifetime_process_3wYf(/*3:3*/ BitSet_qlWf& set)
{
    each_SgsR(set._data);
}
                                #endif

int fu_MAIN()
{
    BitSet_qlWf ls = BitSet_qlWf { fu::u8(unsigned(255)) };
    Lifetime_process_3wYf(ls);
    if (ls._data == fu::u8(170u))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn hello(a) a * a;          // EXPECT (const int a)
        fn main() {
            mut a = 3;
            let b = hello(a);
            return b - 9;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_87TBE9BWG51
                                #define DEF_hello_87TBE9BWG51
inline static int hello_87TB(const int a)
{
    return a * a;
}
                                #endif

int fu_MAIN()
{
    const int a = 3;
    const int b = hello_87TB(a);
    return b - 9;
}

#endif

int main() { return fu_MAIN(); }

========

        struct AB { a: i32; b: i32; };
        fn sqr   (ref x: i32) x * x;
        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        // EXPECT const AB_kiW0&
        fn main() {
            mut ab = AB(3, 5);
            return ab.outer - 34;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct AB_kiW0;

                                #ifndef DEF_AB_kiW09mwmBnj
                                #define DEF_AB_kiW09mwmBnj
struct AB_kiW0
{
                                // shape_hash:    829fb7399a52db1e
                                // non_triv_mask: 0000000000000000
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int sqr_MbR9(/*1:1*/ const int x)
{
    return x * x;
}

static int outer_MbR9(/*1:1*/ const AB_kiW0& ab)
{
    return sqr_MbR9(ab.a) + sqr_MbR9(ab.b);
}

int fu_MAIN()
{
    const AB_kiW0 ab = AB_kiW0 { 3, 5 };
    return outer_MbR9(ab) - 34;
}

#endif

int main() { return fu_MAIN(); }

========

        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }



        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_kMCyJKGgHdh
                                #define STR_kMCyJKGgHdh
static const fu::str str_kMCyJKGgHdh fu_INIT_PRIORITY(1001) { "WORLD!"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::str ascii_lower_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    const int offset = (int(fu::u8('a')) - int(fu::u8('A')));
    /*MOV*/ fu::str res = fu::str(a);
    for (int i = 0; i < res.size(); i++)
    {
        const char /*res|static*/ c = res[i];
        if ((c >= 'A') && (c <= 'Z'))
            res.mutref(i) = char((int(fu::u8(c)) + offset));

    };
    return /*NRVO*/ res;
}

int fu_MAIN()
{
    return int(fu::u8(ascii_lower_MbR9(str_kMCyJKGgHdh)[2])) - int(fu::u8('r'));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }

        pub import _0;

        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

fu::str ascii_lower_MbR9(fu::vec_range<char>);

                                #ifndef STR_kMCyJKGgHdh
                                #define STR_kMCyJKGgHdh
static const fu::str str_kMCyJKGgHdh fu_INIT_PRIORITY(1002) { "WORLD!"_fu };
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8(ascii_lower_MbR9(str_kMCyJKGgHdh)[2])) - int(fu::u8('r'));
}

#endif

int main() { return fu_MAIN(); }
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

fu::str ascii_lower_MbR9(/*1:1*/ fu::vec_range<char> a)
{
    const int offset = (int(fu::u8('a')) - int(fu::u8('A')));
    /*MOV*/ fu::str res = fu::str(a);
    for (int i = 0; i < res.size(); i++)
    {
        const char /*res|static*/ c = res[i];
        if ((c >= 'A') && (c <= 'Z'))
            res.mutref(i) = char((int(fu::u8(c)) + offset));

    };
    return /*NRVO*/ res;
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn main() {
            mut a = [[ 7 ]];
            return a[0][0] - 7;        // EXPECT a[0][0]
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> {{ fu::vec<int> {{ 7 }} }};
    return a[0][0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        lax fn doNothing(pointlessArg: i32) {
            if (pointlessArg == 1)
                return;
        }

        fn main() {
            doNothing(1);
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedIfElse

========

        struct Target   { index: i32 };
        struct Overload { uni0n: i32[] };

        fn solve(all: Overload[], check: Target) {
            fn GET(t: Target) {
                if (t.index < 1 || t.index > all.len) throw("nope");
                return all[t.index - 1];
            }

            fn propagateType(t: Target) {
                if (t.GET.uni0n.has(t.index)) {}
                return t.index;
            }

            return propagateType(check);
        }

        fn main() solve([ Overload([ 1, 2, 3 ])], Target(1)) - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct Overload_1Wrg;
struct Target_HIBL;

                                #ifndef DEF_Overload_1Wrgl4c5x4h
                                #define DEF_Overload_1Wrgl4c5x4h
struct Overload_1Wrg
{
                                // shape_hash:    9494c103fe87cd6c
                                // non_triv_mask: 0028000000000000
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_HIBLg75MwS5
                                #define DEF_Target_HIBLg75MwS5
struct Target_HIBL
{
                                // shape_hash:    f4f61903a3b6b744
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_1Wrg& GET_MbR9(/*3:3*/ const Target_HIBL& t, /*3:3*/ fu::view<Overload_1Wrg> all)
{
    if ((t.index < 1) || (t.index > all.size()))
        fu::fail(fu::str("nope"_fu));
    else
        return all[(t.index - 1)];

}

static int propagateType_MbR9(/*3:3*/ const Target_HIBL& t, /*3:3*/ fu::view<Overload_1Wrg> all)
{
    GET_MbR9(t, all);
    return t.index;
}

static int solve_MbR9(/*3:3*/ fu::view<Overload_1Wrg> all, /*3:3*/ const Target_HIBL& check)
{
    return propagateType_MbR9(check, all);
}

int fu_MAIN()
{
    return solve_MbR9(fu::view<Overload_1Wrg> {{ Overload_1Wrg { fu::vec<int> {{ 1, 2, 3 }} } }}, Target_HIBL { 1 }) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedAndOr

========

        struct Overload     { args: Argument[]; };
        struct SolvedNode   { x: i32; };
        struct Argument     { default: SolvedNode; };

        pub fn test(overload: Overload, ref args: SolvedNode[])
        {
            let host_args = overload.args;          // EXPECT fu::view<Argument_5Ucf> /*overload*/ host_args

            args.resize(host_args.len);             // .len didnt relax its arg
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default;
                }
            }
        }

        fn main() {
            mut o: Overload;
            for (mut i = 0; i < 3; i++)
                o.args ~= Argument(default: SolvedNode(x: i));

            mut args: SolvedNode[];
            test(o, args);
            return args.len - args[args.len - 1].x - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat_one.h>

struct Overload_YJkh;
struct Argument_5Ucf;
struct SolvedNode_zSYP;

                                #ifndef DEF_SolvedNode_zSYPWEj07Hl
                                #define DEF_SolvedNode_zSYPWEj07Hl
struct SolvedNode_zSYP
{
                                // shape_hash:    fe197579dfb03bcf
                                // non_triv_mask: 0000000000000000
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_Overload_YJkheYgXtd7
                                #define DEF_Overload_YJkheYgXtd7
struct Overload_YJkh
{
                                // shape_hash:    ac8522e1dbbf0145
                                // non_triv_mask: 0040000000000010
    fu::vec<Argument_5Ucf> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_Argument_5Ucf8VaRb8f
                                #define DEF_Argument_5Ucf8VaRb8f
struct Argument_5Ucf
{
                                // shape_hash:    daaef306adcc040b
                                // non_triv_mask: 0000000000000000
    SolvedNode_zSYP dEfault;
    explicit operator bool() const noexcept
    {
        return false
            || dEfault
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void test_MbR9(/*3:3*/ const Overload_YJkh& overload, /*2:2*/ fu::vec_range_mut<SolvedNode_zSYP> args)
{
    fu::view<Argument_5Ucf> /*overload*/ host_args = overload.args;
    args.resize(host_args.size());
    for (int i = 0; i < args.size(); i++)
    {
        if (!args[i])
        {
            const Argument_5Ucf& /*host_args|static*/ host_arg = host_args[i];
            args.mutref(i) = SolvedNode_zSYP(host_arg.dEfault);
        };
    };
}

int fu_MAIN()
{
    Overload_YJkh o {};
    for (int i = 0; i < 3; i++)
    {
        o.args += Argument_5Ucf { SolvedNode_zSYP { i } };
    };
    fu::vec<SolvedNode_zSYP> args {};
    test_MbR9(o, args);
    return (args.size() - args[(args.size() - 1)].x) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        // !!!! The m_and_c_cant_alias_001 test obsoletes this,
        // !!!!  this is just detects what we definitely don't want to see -
        // !!!!   returning a reference into a temporary copy.
        //
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_002(ref m: S, c: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);

            let hey = m_and_c_cant_alias_002(mc, mc);

            return hey.len - 10;
        }

---- <fail> ----
[2m[0m_0[2m.fu 16:50+2[0m:

[2m      |             mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);[0m
[2m      | [0m
[2m   16 | [0m            let hey = m_and_c_cant_alias_002(mc, [31;1mmc[0m);
[2m      | [0m
[2m      |             return hey.len - 10;[0m

	At call to [35;3mfn[0m [94;1mm_and_c_cant_alias_002[0m, arguments:

	    2:	[35;3marg[0m [94;1mm_and_c_cant_alias_002[0m:[94;1mc[0m and
	    1:	[35;3mref arg[0m [94;1mm_and_c_cant_alias_002[0m:[94;1mm[0m

	    both alias:

	    [35;3mmut[0m [94;1mmc[0m at [2m14:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            mut [31;1mmc[0m  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
[2m      | [0m
[2m      |             let hey = m_and_c_cant_alias_002(mc, mc);[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3marg[0m [94;1mm_and_c_cant_alias_002[0m:[94;1mc[0m is ref-returned from [35;3mfn[0m [94;1mm_and_c_cant_alias_002[0m

	    [35;3mref arg[0m [94;1mm_and_c_cant_alias_002[0m:[94;1mm[0m is [31;1mref[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m13:12+4[0m

========

        // !!!! The m_and_c_cant_alias_001 test obsoletes this,
        // !!!!  this is just detects what we definitely don't want to see -
        // !!!!   returning a reference into a temporary copy.
        //
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_002(ref m: S, c: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);

            mut bc  = mc;
            let hey = m_and_c_cant_alias_002(mc, bc);

            return hey.len - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct S_quxf;

                                #ifndef DEF_S_quxfgLLsu5a
                                #define DEF_S_quxfgLLsu5a
struct S_quxf
{
                                // shape_hash:    a4490d5945002857
                                // non_triv_mask: 0048000000000000
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<int> m_and_c_cant_alias_002_kGbb(/*1:1*/ S_quxf& m, /*3:3*/ const S_quxf& c)
{
    m.hey.clear();
    return c.hey;
}

int fu_MAIN()
{
    S_quxf mc = S_quxf { fu::vec<int> {{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }} };
    S_quxf bc = mc;
    fu::view<int> /*bc*/ hey = m_and_c_cant_alias_002_kGbb(mc, bc);
    return hey.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        struct BitSet { _data: u8[]; }

        fn add_once(using ref _: BitSet, idx: i32): bool {
            let no_neg = idx < 0 ? -1 : 0;
            let bucket = idx / 8 | no_neg;
            let bit    = idx % 8;
            let mask   = 1 << bit.u8;

            ref entry = _data.grow_if_oob(bucket);
            if !(entry & mask) {
                entry |= mask;
                return true;
            }

            // Already there.
            return false;
        }

        type BitSet2D = BitSet[];

        fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool {
            return bs
                .grow_if_oob(i)
                .add_once(j);                                   // !*MustSeq
        }

        fn main() {
            mut bs: BitSet2D;
            bs.add_once(9, 9);
            return bs.len + 1000 * bs[9]._data.len - 2010;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(240) arc_count(1) ] ----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/vec_range.h>

struct BitSet_mmp7;

                                #ifndef DEF_BitSet_mmp7xBZ4kaf
                                #define DEF_BitSet_mmp7xBZ4kaf
struct BitSet_mmp7
{
                                // shape_hash:    6446e5a2f8d57a0b
                                // non_triv_mask: 0600000000000000
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_NpveYcY0ikd
                                #define DEF_grow_if_oob_NpveYcY0ikd
inline static BitSet_mmp7& grow_if_oob_Npve(/*3:3*/ fu::vec_range_mut<BitSet_mmp7> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_grow_if_oob_IKJqkhWG7x7
                                #define DEF_grow_if_oob_IKJqkhWG7x7
inline static fu::u8& grow_if_oob_IKJq(/*3:3*/ fu::vec_range_mut<fu::u8> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static bool add_once_MbR9(/*3:3*/ BitSet_mmp7& _, const int idx)
{
    const int no_neg = ((idx < 0) ? -1 : 0);
    const int bucket = ((idx / 8) | no_neg);
    const int bit = (idx % 8);
    const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(bit))));
    fu::u8& /*_|static*/ entry = grow_if_oob_IKJq(_._data, bucket);
    if (!fu::u8((entry & mask)))
    {
        entry |= mask;
        return true;
    }
    else
        return false;

}

static bool add_once_kGbb(/*7:7*/ fu::vec_range_mut<BitSet_mmp7> bs, const int i, const int j)
{
    return add_once_MbR9(grow_if_oob_Npve(bs, i), j);
}

int fu_MAIN()
{
    fu::vec<BitSet_mmp7> bs {};
    add_once_kGbb(bs, 9, 9);
    return (bs.size() + (1000 * bs[9]._data.size())) - 2010;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(mut _precedence = 0)
        {
            fn parseExpression(p1?: i32): i32 {
                if !((_precedence = p1))
                    return parseExpressionHead();

                return _precedence;
            }

            fn parseExpressionHead()
                parseExpression(_precedence * 101 + 1);

            return parseExpression();
        }

        fn main() = test() - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static int parseExpression_MbR9(int, int&);

#ifndef fu_NO_fdefs

static int parseExpressionHead_MbR9(/*1:1*/ int& _precedence)
{
    return parseExpression_MbR9(((_precedence * 101) + 1), _precedence);
}

static int parseExpression_MbR9(const int p1, /*3:3*/ int& _precedence)
{
    if (!(_precedence = p1))
        return parseExpressionHead_MbR9(_precedence);
    else
        return _precedence;

}

static int test_MbR9(int _precedence)
{
    return parseExpression_MbR9(0, _precedence);
}

int fu_MAIN()
{
    return test_MbR9(0) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

========

        struct Overload {
            is_var?: bool;
            lifetime?: i32[];
        }

        fn GET(implicit overloads: Overload[], idx: i32) {
            return overloads[idx];
        }


        fn Lifetime_each(mut lifetime: i32[], visit) {
            for (mut i = 0; i < lifetime.len; i++) {
                let r = lifetime[i];
                let o = GET(r);
                visit(:o, i?: i, lifetime?: lifetime);
            }
        }

        fn Lifetime_ascend(mut lifetime: i32[], visit) {
            Lifetime_each(:lifetime, visit: |o, shadow ref lifetime| {
                visit(o);
                lifetime ~= o.lifetime; // set::add
            });
        }

        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {
            Lifetime_ascend(:lifetime, visit: |o| {
                if (o.is_var)
                    return false; // ERR: propagateType(jump): h.ret_actual not available.
            });

            return true;
        }

        fn main() {
            let implicit overloads = [
                Overload,
                Overload(lifetime: [ 0 ]),
                Overload(lifetime: [ 1 ], is_var: true),
                Overload(lifetime: [ 1 ]),
                Overload(lifetime: [ 2 ]), /* the isvar */
                Overload(lifetime: [ 3 ]), /* the non-isvar */
            ];

            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);
            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);

            if (expect_false) return 20;
            if (!expect_true) return 10;
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(352) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_kngx;

                                #ifndef DEF_Overload_kngxMUWihad
                                #define DEF_Overload_kngxMUWihad
struct Overload_kngx
{
                                // shape_hash:    e5a8f1eced1a9599
                                // non_triv_mask: 0008000400000000
    bool is_var;
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || is_var
            || lifetime
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_kngx& GET_MbR9(const int idx, /*3:3*/ fu::view<Overload_kngx> overloads)
{
    return overloads[idx];
}

static bool Lifetime_allowsMutrefReturn_MbR9(/*3:3*/ fu::vec_range<int> lifetime, /*3:3*/ fu::view<Overload_kngx> overloads)
{

    {
        fu::vec_range<int> /*lifetime*/ lifetime_1 = lifetime;
        fu::vec<int> lifetime_2 = fu::vec<int>(lifetime_1);
        for (int i = 0; i < lifetime_2.size(); i++)
        {
            const int /*lifetime_2|static*/ r = lifetime_2[i];
            const Overload_kngx& /*overloads|static*/ o = GET_MbR9(r, overloads);
            if (o.is_var)
                return false;
            else
            {
                lifetime_2 += o.lifetime;
            };
        };
    };
    return true;
}

int fu_MAIN()
{
    fu::vec<Overload_kngx> overloads = fu::vec<Overload_kngx> {{ Overload_kngx{}, Overload_kngx { false, fu::vec<int> {{ 0 }} }, Overload_kngx { true, fu::vec<int> {{ 1 }} }, Overload_kngx { false, fu::vec<int> {{ 1 }} }, Overload_kngx { false, fu::vec<int> {{ 2 }} }, Overload_kngx { false, fu::vec<int> {{ 3 }} } }};
    const bool expect_false = Lifetime_allowsMutrefReturn_MbR9(fu::vec<int> {{ 4 }}, overloads);
    const bool expect_true = Lifetime_allowsMutrefReturn_MbR9(fu::vec<int> {{ 5 }}, overloads);
    if (expect_false)
        return 20;
    else if (!expect_true)
        return 10;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Overload {
            is_var?: bool;
            lifetime?: i32[];
        }

        fn GET(implicit overloads: Overload[], idx: i32) {
            return overloads[idx];
        }


        inline 
        fn Lifetime_each(mut lifetime: i32[], visit) {
            for (mut i = 0; i < lifetime.len; i++) {
                let r = lifetime[i];
                let o = GET(r);
                visit(:o, i?: i, lifetime?: lifetime);
            }
        }

        fn Lifetime_ascend(mut lifetime: i32[], visit) {
            Lifetime_each(:lifetime, visit: |o, shadow ref lifetime| {
                visit(o);
                lifetime ~= o.lifetime; // set::add
            });
        }

        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {
            Lifetime_ascend(:lifetime, visit: |o| {
                if (o.is_var)
                    return false; // ERR: propagateType(jump): h.ret_actual not available.
            });

            return true;
        }

        fn main() {
            let implicit overloads = [
                Overload,
                Overload(lifetime: [ 0 ]),
                Overload(lifetime: [ 1 ], is_var: true),
                Overload(lifetime: [ 1 ]),
                Overload(lifetime: [ 2 ]), /* the isvar */
                Overload(lifetime: [ 3 ]), /* the non-isvar */
            ];

            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);
            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);

            if (expect_false) return 20;
            if (!expect_true) return 10;
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(352) arc_count(2) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Overload_kngx;

                                #ifndef DEF_Overload_kngxMUWihad
                                #define DEF_Overload_kngxMUWihad
struct Overload_kngx
{
                                // shape_hash:    e5a8f1eced1a9599
                                // non_triv_mask: 0008000400000000
    bool is_var;
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || is_var
            || lifetime
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const Overload_kngx& GET_MbR9(const int idx, /*3:3*/ fu::view<Overload_kngx> overloads)
{
    return overloads[idx];
}

static bool Lifetime_allowsMutrefReturn_MbR9(/*3:3*/ fu::vec_range<int> lifetime, /*3:3*/ fu::view<Overload_kngx> overloads)
{

    {
        fu::vec_range<int> /*lifetime*/ lifetime_1 = lifetime;
        fu::vec<int> lifetime_2 = fu::vec<int>(lifetime_1);
        for (int i = 0; i < lifetime_2.size(); i++)
        {
            const int /*lifetime_2|static*/ r = lifetime_2[i];
            const Overload_kngx& /*overloads|static*/ o = GET_MbR9(r, overloads);
            if (o.is_var)
                return false;
            else
            {
                lifetime_2 += o.lifetime;
            };
        };
    };
    return true;
}

int fu_MAIN()
{
    fu::vec<Overload_kngx> overloads = fu::vec<Overload_kngx> {{ Overload_kngx{}, Overload_kngx { false, fu::vec<int> {{ 0 }} }, Overload_kngx { true, fu::vec<int> {{ 1 }} }, Overload_kngx { false, fu::vec<int> {{ 1 }} }, Overload_kngx { false, fu::vec<int> {{ 2 }} }, Overload_kngx { false, fu::vec<int> {{ 3 }} } }};
    const bool expect_false = Lifetime_allowsMutrefReturn_MbR9(fu::vec<int> {{ 4 }}, overloads);
    const bool expect_true = Lifetime_allowsMutrefReturn_MbR9(fu::vec<int> {{ 5 }}, overloads);
    if (expect_false)
        return 20;
    else if (!expect_true)
        return 10;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Overload { items: string[]; };

        fn Last(a: $T[])                    a[a.len - 1];
        fn arg_lets(overload: Overload)     overload.items[.. overload.items.len - 2];
        fn test(overload: Overload)         overload.arg_lets.Last.len;
        fn main()                           Overload([ "hello", "cruel", "world!" ]).test - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Overload_Etg6;

                                #ifndef DEF_Overload_Etg6lolYob5
                                #define DEF_Overload_Etg6lolYob5
struct Overload_Etg6
{
                                // shape_hash:    ecc8035edc9516c3
                                // non_triv_mask: 0004c00000000000
    fu::vec<fu::str> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<fu::str> arg_lets_kGbb(/*1:1*/ const Overload_Etg6& overload)
{
    return fu::get_view_start0(overload.items, (overload.items.size() - 2));
}

                                #ifndef DEF_Last_lPg0jsdpkFd
                                #define DEF_Last_lPg0jsdpkFd
inline static fu::vec_range<char> Last_lPg0(/*1:1*/ fu::view<fu::str> a)
{
    return a[(a.size() - 1)];
}
                                #endif

static int test_MbR9(/*1:1*/ const Overload_Etg6& overload)
{
    return Last_lPg0(arg_lets_kGbb(overload)).size();
}

int fu_MAIN()
{
    return test_MbR9(Overload_Etg6 { fu::vec<fu::str> {{ fu::str("hello"_fu), fu::str("cruel"_fu), fu::str("world!"_fu) }} }) - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        using inline fn GET(h: Helpers, implicit ref _helpers_data: HelpersData[]): HelpersData
            _helpers_data[h.index];
                                                            //////////////////
        fn isFnOrType(h: Helpers): bool                     // EXPECT fu::view
            !!(h.mask & (HM_Function | HM_Struct));         //////////////////

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];
            return Helpers(0).isFnOrType.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct HelpersData_kxk7;
struct Helpers_DyqV;

                                #ifndef DEF_HelpersData_kxk7Lbybno6
                                #define DEF_HelpersData_kxk7Lbybno6
struct HelpersData_kxk7
{
                                // shape_hash:    ab00989d418f67a4
                                // non_triv_mask: 0000000000000000
    short mask;
    explicit operator bool() const noexcept
    {
        return false
            || mask
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
                                // shape_hash:    340726173a03831e
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const short HM_Function = short((short(1) << short(3)));

static const short HM_Struct = short((short(1) << short(5)));

static bool isFnOrType_MbR9(/*3:3*/ const Helpers_DyqV& h, /*3:3*/ fu::view<HelpersData_kxk7> _helpers_data)
{
    return !!short((_helpers_data[h.index].mask & short((HM_Function | HM_Struct))));
}

int fu_MAIN()
{
    fu::vec<HelpersData_kxk7> _helpers_data = fu::vec<HelpersData_kxk7> {{ HelpersData_kxk7 { short(0) } }};
    return int(isFnOrType_MbR9(Helpers_DyqV { 0 }, _helpers_data));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];

            using inline fn GET(h: Helpers): HelpersData
                _helpers_data[h.index];
                                                            //////////////////
            fn isFnOrType(h: Helpers): bool                 // EXPECT fu::view
                !!(h.mask & (HM_Function | HM_Struct));     //////////////////

            return Helpers(0).isFnOrType.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct HelpersData_kxk7;
struct Helpers_DyqV;

                                #ifndef DEF_HelpersData_kxk7Lbybno6
                                #define DEF_HelpersData_kxk7Lbybno6
struct HelpersData_kxk7
{
                                // shape_hash:    ab00989d418f67a4
                                // non_triv_mask: 0000000000000000
    short mask;
    explicit operator bool() const noexcept
    {
        return false
            || mask
        ;
    }
};
                                #endif

                                #ifndef DEF_Helpers_DyqVC1yXPkj
                                #define DEF_Helpers_DyqVC1yXPkj
struct Helpers_DyqV
{
                                // shape_hash:    340726173a03831e
                                // non_triv_mask: 0000000000000000
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const short HM_Function = short((short(1) << short(3)));

static const short HM_Struct = short((short(1) << short(5)));

static bool isFnOrType_MbR9(/*3:3*/ const Helpers_DyqV& h, /*3:3*/ fu::view<HelpersData_kxk7> _helpers_data)
{
    return !!short((_helpers_data[h.index].mask & short((HM_Function | HM_Struct))));
}

int fu_MAIN()
{
    fu::vec<HelpersData_kxk7> _helpers_data = fu::vec<HelpersData_kxk7> {{ HelpersData_kxk7 { short(0) } }};
    return int(isFnOrType_MbR9(Helpers_DyqV { 0 }, _helpers_data));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

========

        pub fn ref(dest, item: $T, extras) {
            for (mut i = 0; i < dest.len; i++) {
                if (dest[i] >= item) {
                    if (dest[i] != item) {
                        dest.insert(i, item);
                        extras.insert(i, []);
                    }
                    return extras[i];
                }
            }

            dest.push(item);
            extras.push([]);
            return extras[extras.len - 1];
        }

        fn Map(lax k: $K, lax v: $V) struct {
            keys: $K[];
            vals: $V[];
        };

        fn ref(using ref _, key)
            _0::ref(
                || keys, key,
                || vals);

        fn main() {
            mut _map: _1::Map(string, string);

            fn upsert(k: string, v: string) _map._1::ref(k) = v;
            upsert("hello", "world");

            // Relaxer failed here while I was trying to get rid of F_REFs from specTypes.
            fn check(k: string) _map._1::ref(k) == "world" ? 0 : 1;
            return check("hello");
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

struct Map_VMIG;

                                #ifndef DEF_Map_VMIGQbNAY20
                                #define DEF_Map_VMIGQbNAY20
struct Map_VMIG
{
                                // shape_hash:    95dd75099603f800
                                // non_triv_mask: 0000c02000000000
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef STR_LCCnJta4Qr3
                                #define STR_LCCnJta4Qr3
static const fu::str str_LCCnJta4Qr3 fu_INIT_PRIORITY(1003) { "hello"_fu };
                                #endif

                                #ifndef STR_9VaFzJwl1w6
                                #define STR_9VaFzJwl1w6
static const fu::str str_9VaFzJwl1w6 fu_INIT_PRIORITY(1003) { "world"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5gtVj26DRV2
                                #define DEF___5gtVj26DRV2
inline static fu::view<fu::str> _5gtV(/*1:1*/ const Map_VMIG& _)
{
    return _.keys;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Ex3D_NQuX1RZ2ud4
                                #define DEF_x3Ex3D_NQuX1RZ2ud4
inline bool operator>=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF___jDEoAXdbOkc
                                #define DEF___jDEoAXdbOkc
inline static fu::vec<fu::str>& _jDEo(/*1:1*/ Map_VMIG& _)
{
    return _.keys;
}
                                #endif

                                #ifndef DEF___ywbZ13EKX33
                                #define DEF___ywbZ13EKX33
inline static fu::vec<fu::str>& _ywbZ(/*1:1*/ Map_VMIG& _)
{
    return _.vals;
}
                                #endif

                                #ifndef DEF___9PEhfQg6KP7
                                #define DEF___9PEhfQg6KP7
inline static fu::view_mut<fu::str> _9PEh(/*1:1*/ Map_VMIG& _)
{
    return _.vals;
}
                                #endif

                                #ifndef DEF___0LNfAxvCnLl
                                #define DEF___0LNfAxvCnLl
inline static fu::view<fu::str> _0LNf(/*1:1*/ const Map_VMIG& _)
{
    return _.vals;
}
                                #endif

                                #ifndef DEF_ref_oKMcJL0gwH4
                                #define DEF_ref_oKMcJL0gwH4
inline fu::vec_range_mut<char> ref_oKMc(/*F:F*/ fu::vec_range<char> item, /*F:F*/ Map_VMIG& _)
{
    for (int i = 0; i < _5gtV(_).size(); i++)
    {
        if ((_5gtV(_)[i] >= item))
        {
            if (_5gtV(_)[i] != item)
            {
                _jDEo(_).insert(i, fu::str(item));
                _ywbZ(_).insert(i, fu::str{});
            };
            return _9PEh(_).mutref(i);
        };
    };
    _jDEo(_).push(fu::str(item));
    _ywbZ(_).push(fu::str{});
    return _9PEh(_).mutref((_0LNf(_).size() - 1));
}
                                #endif

                                #ifndef DEF_ref_JIR1c9Pv9S8
                                #define DEF_ref_JIR1c9Pv9S8
inline fu::vec_range_mut<char> ref_JIR1(/*3:3*/ Map_VMIG& _, /*3:3*/ fu::vec_range<char> key)
{
    return ref_oKMc(key, _);
}
                                #endif

static fu::vec_range<char> upsert_sWmp(/*7:7*/ fu::vec_range<char> k, /*7:7*/ fu::vec_range<char> v, /*7:7*/ Map_VMIG& _map)
{
    return (ref_JIR1(_map, k) = fu::str(v));
}

                                #ifndef DEF_ref_j4TsUm0o6Va
                                #define DEF_ref_j4TsUm0o6Va
inline fu::vec_range<char> ref_j4Ts(/*F:F*/ fu::vec_range<char> item, /*F:F*/ Map_VMIG& _)
{
    for (int i = 0; i < _5gtV(_).size(); i++)
    {
        if ((_5gtV(_)[i] >= item))
        {
            if (_5gtV(_)[i] != item)
            {
                _jDEo(_).insert(i, fu::str(item));
                _ywbZ(_).insert(i, fu::str{});
            };
            return _0LNf(_)[i];
        };
    };
    _jDEo(_).push(fu::str(item));
    _ywbZ(_).push(fu::str{});
    return _0LNf(_)[(_0LNf(_).size() - 1)];
}
                                #endif

                                #ifndef DEF_ref_AA9gnHGBP1l
                                #define DEF_ref_AA9gnHGBP1l
inline fu::vec_range<char> ref_AA9g(/*3:3*/ Map_VMIG& _, /*3:3*/ fu::vec_range<char> key)
{
    return ref_j4Ts(key, _);
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static int check_WLF9(/*3:3*/ fu::vec_range<char> k, /*3:3*/ Map_VMIG& _map)
{
    if (ref_AA9g(_map, k) == "world"_view)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    Map_VMIG _map {};
    upsert_sWmp(str_LCCnJta4Qr3, str_9VaFzJwl1w6, _map);
    return check_WLF9(str_LCCnJta4Qr3, _map);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        fn useless_ref_lambda(ref sources: string[]) {
            fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck
            return src[1 .. src.len] ~ src[.. 1];
        }
        fn main() {
            mut sources = [ "ab" ];
            return useless_ref_lambda(sources) == "ba" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec_range<char> src_kGbb(/*1:1*/ fu::view<fu::str> sources)
{
    return sources[(sources.size() / 2)];
}

static fu::str useless_ref_lambda_MbR9(/*1:1*/ fu::view<fu::str> sources)
{
    return fu::get_view(src_kGbb(sources), 1, src_kGbb(sources).size()) + fu::get_view_start0(src_kGbb(sources), 1);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> sources = fu::vec<fu::str> {{ fu::str("ab"_fu) }};
    if (useless_ref_lambda_MbR9(sources) == "ba"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Node { items: Node[] };

        pure fn rec_useless_ref_simple(ref n: Node, offset: i32)
            offset < n.items.len
                ? rec_useless_ref_simple(:n, offset + 1)
                : offset;

        fn main() {
            mut n = Node([ Node(), Node() ]);
            return rec_useless_ref_simple(:n, 0) - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_zYlo;
static int rec_useless_ref_simple_MbR9(const Node_zYlo&, int);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rec_useless_ref_simple_MbR9(/*3:3*/ const Node_zYlo& n, const int offset)
{
    if (offset < n.items.size())
        return rec_useless_ref_simple_MbR9(n, (offset + 1));
    else
        return offset;

}

int fu_MAIN()
{
    Node_zYlo n = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} };
    return rec_useless_ref_simple_MbR9(n, 0) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

========

        struct Node { items: Node[]; };

        pure fn rec_useless_ref(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += rec_useless_ref(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node(), Node() ]);
            return rec_useless_ref(tree) - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>

struct Node_zYlo;
static int rec_useless_ref_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rec_useless_ref_MbR9(/*1:1*/ const Node_zYlo& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += rec_useless_ref_MbR9(n.items[i]);

    return ret;
}

int fu_MAIN()
{
    Node_zYlo tree = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} };
    return rec_useless_ref_MbR9(tree) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_UnusedCall

========

        struct Node { items: Node[]; };

        fn mrec_useless_ref_A(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ?      mrec_useless_ref_A(n.items[i])
                    : 50 * mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        pure fn mrec_useless_ref_B(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ? 10 * mrec_useless_ref_A(n.items[i])
                    :      mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node([ Node, Node ]), Node([ Node ]) ]);
            return mrec_useless_ref_A(tree) - 103;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>

struct Node_zYlo;
static int mrec_useless_ref_A_MbR9(const Node_zYlo&);
static int mrec_useless_ref_B_MbR9(const Node_zYlo&);

                                #ifndef DEF_Node_zYlotGgWUR1
                                #define DEF_Node_zYlotGgWUR1
struct Node_zYlo
{
                                // shape_hash:    fc6c04e1a88e6c51
                                // non_triv_mask: 4008000000000000
    fu::vec<Node_zYlo> items;
    Node_zYlo(const Node_zYlo&) = default;
    Node_zYlo(Node_zYlo&&) = default;
    Node_zYlo& operator=(Node_zYlo&&) = default;
    Node_zYlo& operator=(const Node_zYlo& selfrec) { return *this = Node_zYlo(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int mrec_useless_ref_B_MbR9(/*1:1*/ const Node_zYlo& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += ((i & 1) ? (10 * mrec_useless_ref_A_MbR9(n.items[i])) : mrec_useless_ref_B_MbR9(n.items[i]));

    return ret;
}

static int mrec_useless_ref_A_MbR9(/*1:1*/ const Node_zYlo& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += ((i & 1) ? mrec_useless_ref_A_MbR9(n.items[i]) : (50 * mrec_useless_ref_B_MbR9(n.items[i])));

    return ret;
}

int fu_MAIN()
{
    Node_zYlo tree = Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{}, Node_zYlo{} }} }, Node_zYlo { fu::vec<Node_zYlo> {{ Node_zYlo{} }} } }} };
    return mrec_useless_ref_A_MbR9(tree) - 103;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCall, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse

========

        fn Last(s: $T[])
            s.len ? s[s.len - 1] : throw("len == 0");

        struct Node { kind: string; items: Node[] }

        pure fn check(ref node: Node)
            node.kind != "block" ||
            node.items.Last.kind == "return";

        fn main() {
            mut node: Node;
            return node.check ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct Node_9RQE;

                                #ifndef DEF_Node_9RQENE18wjd
                                #define DEF_Node_9RQENE18wjd
struct Node_9RQE
{
                                // shape_hash:    fb0e33b5fb8f51b9
                                // non_triv_mask: 000080000000000c
    fu::str kind;
    fu::vec<Node_9RQE> items;
    Node_9RQE(const Node_9RQE&) = default;
    Node_9RQE(Node_9RQE&&) = default;
    Node_9RQE& operator=(Node_9RQE&&) = default;
    Node_9RQE& operator=(const Node_9RQE& selfrec) { return *this = Node_9RQE(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_Last_gK0hF72FD1b
                                #define DEF_Last_gK0hF72FD1b
inline static const Node_9RQE& Last_gK0h(/*1:1*/ fu::view<Node_9RQE> s)
{
    if (s.size())
        return s[(s.size() - 1)];
    else
        fu::fail(fu::str("len == 0"_fu));

}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool check_MbR9(/*1:1*/ const Node_9RQE& node)
{
    return (node.kind != "block"_view) || (Last_gK0h(node.items).kind == "return"_view);
}

int fu_MAIN()
{
    Node_9RQE node {};
    if (check_MbR9(node))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        fn relaxes_arr_to_slice_and_fails(ref arr) {
            arr.pop();
            return arr;
        }

        fn main() {
            mut arr = [ 1 ];
            relaxes_arr_to_slice_and_fails(arr);
            return arr.len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_relaxes_arr_to_slice_and_fails_s2hdDZ2bqid
                                #define DEF_relaxes_arr_to_slice_and_fails_s2hdDZ2bqid
inline static fu::view<int> relaxes_arr_to_slice_and_fails_s2hd(/*1:1*/ fu::vec_range_mut<int> arr)
{
    arr.pop();
    return arr;
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1 }};
    relaxes_arr_to_slice_and_fails_s2hd(arr);
    return arr.size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        type Context = string[];

        fn compile_snippets(sources: string[], fnames?: string[]): Context {
            return sources ~ fnames;
        }

        fn ZERO(implicit ref output: string, mut sources: string[]): Context {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                let idx = src.find('X');
                if (idx >= 0) {
                    let moduleA = src.slice(0, idx);
                    let moduleB = src[idx .. idx] ~ src[idx + 1 .. src.len];
                    let without = src[0   .. idx] ~ src[idx + 1 .. src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                    i--;
                }
            }

            let ctx = compile_snippets(:sources);
            output ~= sources.join(',') ~ ";";
            return ctx;
        }

        fn ZERO(src: string) ZERO(sources: [ src ]);

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "abc;ab,c;a,bc;a,b,c;" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(784) arc_count(7) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>

static fu::vec<fu::str> ZERO_MbR9(fu::vec<fu::str>&&, fu::vec_range_mut<char>);

                                #ifndef STR_bLfWjhiv6Ce
                                #define STR_bLfWjhiv6Ce
static const fu::str str_bLfWjhiv6Ce fu_INIT_PRIORITY(1001) { "aXbXc"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static fu::vec<fu::str> compile_snippets_MbR9(/*3:3*/ fu::view<fu::str> sources, /*3:3*/ fu::view<fu::str> fnames)
{
    return sources + fnames;
}

                                #ifndef DEF_join_RGgBgTHcISl
                                #define DEF_join_RGgBgTHcISl
inline fu::str join_RGgB(/*3:3*/ fu::view<fu::str> a, const char sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 1;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            res.mutref(size) = sep;
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::vec<fu::str> ZERO_MbR9(fu::vec<fu::str>&& sources, /*2:2*/ fu::vec_range_mut<char> output)
{
    for (int i = 0; i < sources.size(); i++)
    {
        fu::vec_range<char> /*sources|static*/ src = sources[i];
        const int idx = find_ZKsG(src, 'X');
        if ((idx >= 0))
        {
            /*MOV*/ fu::str moduleA = fu::str(fu::get_range(src, 0, idx));
            /*MOV*/ fu::str moduleB = (fu::get_view(src, idx, idx) + fu::get_view(src, (idx + 1), src.size()));
            /*MOV*/ fu::str without = (fu::get_view(src, 0, idx) + fu::get_view(src, (idx + 1), src.size()));
            sources.mutref(i) = without.destructive_move();
            ZERO_MbR9(fu::vec<fu::str>(sources), output);
            sources.mutref(i) = moduleA.destructive_move();
            sources.insert((i + 1), moduleB.destructive_move());
            i--;
        };
    };
    /*MOV*/ fu::vec<fu::str> ctx = compile_snippets_MbR9(sources, fu::view<fu::str>{});
    output += (join_RGgB(sources, ',') + ";"_view);
    return /*NRVO*/ ctx;
}

static fu::vec<fu::str> ZERO_kGbb(/*3:3*/ fu::vec_range<char> src, /*2:2*/ fu::vec_range_mut<char> output)
{
    return ZERO_MbR9(fu::vec<fu::str> {{ fu::str(src) }}, output);
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str output {};
    ZERO_kGbb(str_bLfWjhiv6Ce, output);
    if (output == "abc;ab,c;a,bc;a,b,c;"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_COWRestrict

========

        fn test(str: string) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

========

        fn test(str: byte[..]) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg    ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
        return fu::str(""_fu);

}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg    ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg   && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg   && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len  ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
        return fu::str(""_fu);

}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len  ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg      ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
        return fu::str(""_fu);

}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg      ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg     && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(""_view, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg     && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_MbR9(/*3:3*/ fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::view<char> /*static*/ share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_view;
    fu::str a = doesnt_copy_arg_MbR9(share, '!');
    fu::str b = doesnt_copy_arg_MbR9(share, '?');
    fu::str c = doesnt_copy_arg_MbR9(fu::view<char>{}, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn loop(ref cond, body)     
            do body();
            while (cond);           

        novec fn doesnt_copy_arg(ref nums: i32[]) {
            loop(nums): || {
                mut sum = 0;
                for (mut i = 0; i < nums.len; i++)
                    sum += nums[i]++;
                if (sum >= 10)
                    return sum;
            }
            return 0;
        }

        fn main() {
            mut nums: i32[];
            mut a = doesnt_copy_arg(nums);
            nums ~= 1;
            mut b = doesnt_copy_arg(nums);
            nums ~= 2;
            mut c = doesnt_copy_arg(nums);
            return a == 0 && b == 10 && c == 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int doesnt_copy_arg_MbR9(/*1:1*/ fu::view_mut<int> nums)
{
    do
    {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums.mutref(i)++;

        if ((sum >= 10))
            return sum;

    }
    while (nums);
    return 0;
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    const int a = doesnt_copy_arg_MbR9(nums);
    nums += 1;
    const int b = doesnt_copy_arg_MbR9(nums);
    nums += 2;
    const int c = doesnt_copy_arg_MbR9(nums);
    if ((a == 0) && (b == 10) && (c == 13))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn loop(ref cond, body)     
            while (cond) body();    

        novec fn doesnt_copy_arg(ref nums: i32[]) {
            loop(nums): || {
                mut sum = 0;
                for (mut i = 0; i < nums.len; i++)
                    sum += nums[i]++;
                if (sum >= 10)
                    return sum;
            }
            return 0;
        }

        fn main() {
            mut nums: i32[];
            mut a = doesnt_copy_arg(nums);
            nums ~= 1;
            mut b = doesnt_copy_arg(nums);
            nums ~= 2;
            mut c = doesnt_copy_arg(nums);
            return a == 0 && b == 10 && c == 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int doesnt_copy_arg_MbR9(/*1:1*/ fu::view_mut<int> nums)
{
    while (nums)
    {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums.mutref(i)++;

        if ((sum >= 10))
            return sum;

    };
    return 0;
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    const int a = doesnt_copy_arg_MbR9(nums);
    nums += 1;
    const int b = doesnt_copy_arg_MbR9(nums);
    nums += 2;
    const int c = doesnt_copy_arg_MbR9(nums);
    if ((a == 0) && (b == 10) && (c == 13))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        fn grow_if_oob !T(ref a: T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Target { modid: i32; index: i32 }
        struct Scope { overloads: Overload[]; extended: Extended[] };
        struct Overload { modid: i32 };
        struct Extended { min: i32; locals: Overload[] };

        fn create(ref scope: Scope, modid: i32): Target {
            ref overloads = modid
                ? scope.extended.grow_if_oob(modid).locals
                : scope.overloads;

            let target = Target(:modid, index: overloads.len + 1);
            overloads.push(Overload(:modid));
            return target;
        }

        fn main() {
            mut scope: Scope;
            scope.create(0);
            scope.create(1);
            return scope.overloads.len == 1
                && scope.extended .len == 2 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/vec_range.h>

struct Scope_P9YY;
struct Overload_6I6d;
struct Extended_JZ1E;
struct Target_84mq;

                                #ifndef DEF_Overload_6I6dBCuXR04
                                #define DEF_Overload_6I6dBCuXR04
struct Overload_6I6d
{
                                // shape_hash:    ee75a53ed8401ce2
                                // non_triv_mask: 0000000000000000
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_Extended_JZ1ELrzX1q9
                                #define DEF_Extended_JZ1ELrzX1q9
struct Extended_JZ1E
{
                                // shape_hash:    784501690ff08bd6
                                // non_triv_mask: 2800000000000000
    int min;
    fu::vec<Overload_6I6d> locals;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_Scope_P9YYq6n4fv0
                                #define DEF_Scope_P9YYq6n4fv0
struct Scope_P9YY
{
                                // shape_hash:    1176b791bd59ed50
                                // non_triv_mask: 2800200000040000
    fu::vec<Overload_6I6d> overloads;
    fu::vec<Extended_JZ1E> extended;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_84mqmNanZdi
                                #define DEF_Target_84mqmNanZdi
struct Target_84mq
{
                                // shape_hash:    8c9cdba7d3c0944d
                                // non_triv_mask: 0000000000000000
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_tfN9L1IYiU3
                                #define DEF_grow_if_oob_tfN9L1IYiU3
inline static Extended_JZ1E& grow_if_oob_tfN9(/*3:3*/ fu::vec_range_mut<Extended_JZ1E> a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static Target_84mq create_MbR9(/*3:3*/ Scope_P9YY& scope, const int modid)
{
    fu::vec<Overload_6I6d>& /*scope|static*/ overloads = (modid ? grow_if_oob_tfN9(scope.extended, modid).locals : scope.overloads);
    const Target_84mq target = Target_84mq { modid, (overloads.size() + 1) };
    overloads.push(Overload_6I6d { modid });
    return target;
}

int fu_MAIN()
{
    Scope_P9YY scope {};
    create_MbR9(scope, 0);
    create_MbR9(scope, 1);
    if ((scope.overloads.size() == 1) && (scope.extended.size() == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };

        struct TP { flags: TPFlags };

        fn doTrySpec(ref typeParams: TP[]) {
            fn useConsumedType(tp)
                tp.flags & (ArgSpec | Typename) == ArgSpec;

            typeParams.each: |ref tp|
                if (tp.useConsumedType)
                    tp.flags |= NeedsConsumed;
        }

        fn main() {
            mut typeParams: TP[] = [
                [ ArgSpec ],
                [ ArgSpec | Typename ],
                [ Typename ],
            ];

            doTrySpec(typeParams);

            mut count = 0;
            typeParams.each: |tp|
                if (tp.flags & NeedsConsumed)
                    count++;

            return count - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>

struct TP_PgA9;
typedef fu::u8 TPFlags_Izbi;

                                #ifndef DEF_TPFlags_Izbi
                                #define DEF_TPFlags_Izbi
inline constexpr TPFlags_Izbi TPFlags_Izbi_ArgSpec = TPFlags_Izbi(1u);
inline constexpr TPFlags_Izbi TPFlags_Izbi_Typename = TPFlags_Izbi(2u);
inline constexpr TPFlags_Izbi TPFlags_Izbi_NeedsConsumed = TPFlags_Izbi(4u);

inline constexpr TPFlags_Izbi MASK_TPFlags_Izbi
    = TPFlags_Izbi_ArgSpec
    | TPFlags_Izbi_Typename
    | TPFlags_Izbi_NeedsConsumed;
                                #endif

                                #ifndef DEF_TP_PgA9adXjjWf
                                #define DEF_TP_PgA9adXjjWf
struct TP_PgA9
{
                                // shape_hash:    b9e2a43e1824ba9b
                                // non_triv_mask: 0000000000000000
    TPFlags_Izbi flags;
    explicit operator bool() const noexcept
    {
        return false
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_useConsumedType_nIZlIBvlxVa
                                #define DEF_useConsumedType_nIZlIBvlxVa
inline static bool useConsumedType_nIZl(/*1:1*/ const TP_PgA9& tp)
{
    return TPFlags_Izbi((tp.flags & TPFlags_Izbi((TPFlags_Izbi_ArgSpec | TPFlags_Izbi_Typename)))) == TPFlags_Izbi_ArgSpec;
}
                                #endif

                                #ifndef DEF___Ix2SfmUiJB5
                                #define DEF___Ix2SfmUiJB5
inline static void _Ix2S(/*1:1*/ TP_PgA9& tp)
{
    if (useConsumedType_nIZl(tp))
        tp.flags |= TPFlags_Izbi_NeedsConsumed;

}
                                #endif

                                #ifndef DEF_each_fxOhfZLQmF5
                                #define DEF_each_fxOhfZLQmF5
inline void each_fxOh(/*3:3*/ fu::view_mut<TP_PgA9> a)
{
    for (int i = 0; i < a.size(); i++)
        _Ix2S(a.mutref(i));

}
                                #endif

static void doTrySpec_MbR9(/*1:1*/ fu::view_mut<TP_PgA9> typeParams)
{
    each_fxOh(typeParams);
}

                                #ifndef DEF___FpqS8bgHfP6
                                #define DEF___FpqS8bgHfP6
inline static void _FpqS(/*3:3*/ const TP_PgA9& tp, /*3:3*/ int& count)
{
    if (tp.flags & TPFlags_Izbi_NeedsConsumed)
        count++;

}
                                #endif

                                #ifndef DEF_each_8JNDHHlMoqi
                                #define DEF_each_8JNDHHlMoqi
inline void each_8JND(/*7:7*/ fu::view<TP_PgA9> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _FpqS(a[i], count);

}
                                #endif

int fu_MAIN()
{
    fu::vec<TP_PgA9> typeParams = fu::vec<TP_PgA9> {{ TP_PgA9 { TPFlags_Izbi_ArgSpec }, TP_PgA9 { TPFlags_Izbi((TPFlags_Izbi_ArgSpec | TPFlags_Izbi_Typename)) }, TP_PgA9 { TPFlags_Izbi_Typename } }};
    doTrySpec_MbR9(typeParams);
    int count = 0;
    each_8JND(typeParams, count);
    return count - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };

        struct TP { flags: TPFlags };

        fn doTrySpec(ref typeParams: TP[]) {
            fn useConsumedType(tp: TP)
                tp.flags & (ArgSpec | Typename) == ArgSpec;

            typeParams.each: |ref tp|
                if (tp.useConsumedType)
                    tp.flags |= NeedsConsumed;
        }

        fn main() {
            mut typeParams: TP[] = [
                [ ArgSpec ],
                [ ArgSpec | Typename ],
                [ Typename ],
            ];

            doTrySpec(typeParams);

            mut count = 0;
            typeParams.each: |tp|
                if (tp.flags & NeedsConsumed)
                    count++;

            return count - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>

struct TP_PgA9;
typedef fu::u8 TPFlags_Izbi;

                                #ifndef DEF_TPFlags_Izbi
                                #define DEF_TPFlags_Izbi
inline constexpr TPFlags_Izbi TPFlags_Izbi_ArgSpec = TPFlags_Izbi(1u);
inline constexpr TPFlags_Izbi TPFlags_Izbi_Typename = TPFlags_Izbi(2u);
inline constexpr TPFlags_Izbi TPFlags_Izbi_NeedsConsumed = TPFlags_Izbi(4u);

inline constexpr TPFlags_Izbi MASK_TPFlags_Izbi
    = TPFlags_Izbi_ArgSpec
    | TPFlags_Izbi_Typename
    | TPFlags_Izbi_NeedsConsumed;
                                #endif

                                #ifndef DEF_TP_PgA9adXjjWf
                                #define DEF_TP_PgA9adXjjWf
struct TP_PgA9
{
                                // shape_hash:    b9e2a43e1824ba9b
                                // non_triv_mask: 0000000000000000
    TPFlags_Izbi flags;
    explicit operator bool() const noexcept
    {
        return false
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool useConsumedType_MbR9(/*1:1*/ const TP_PgA9& tp)
{
    return TPFlags_Izbi((tp.flags & TPFlags_Izbi((TPFlags_Izbi_ArgSpec | TPFlags_Izbi_Typename)))) == TPFlags_Izbi_ArgSpec;
}

                                #ifndef DEF___3CsVq7QhFAi
                                #define DEF___3CsVq7QhFAi
inline static void _3CsV(/*1:1*/ TP_PgA9& tp)
{
    if (useConsumedType_MbR9(tp))
        tp.flags |= TPFlags_Izbi_NeedsConsumed;

}
                                #endif

                                #ifndef DEF_each_NNKrISKH52l
                                #define DEF_each_NNKrISKH52l
inline void each_NNKr(/*3:3*/ fu::view_mut<TP_PgA9> a)
{
    for (int i = 0; i < a.size(); i++)
        _3CsV(a.mutref(i));

}
                                #endif

static void doTrySpec_MbR9(/*1:1*/ fu::view_mut<TP_PgA9> typeParams)
{
    each_NNKr(typeParams);
}

                                #ifndef DEF___FpqS8bgHfP6
                                #define DEF___FpqS8bgHfP6
inline static void _FpqS(/*3:3*/ const TP_PgA9& tp, /*3:3*/ int& count)
{
    if (tp.flags & TPFlags_Izbi_NeedsConsumed)
        count++;

}
                                #endif

                                #ifndef DEF_each_8JNDHHlMoqi
                                #define DEF_each_8JNDHHlMoqi
inline void each_8JND(/*7:7*/ fu::view<TP_PgA9> a, /*7:6*/ int& count)
{
    for (int i = 0; i < a.size(); i++)
        _FpqS(a[i], count);

}
                                #endif

int fu_MAIN()
{
    fu::vec<TP_PgA9> typeParams = fu::vec<TP_PgA9> {{ TP_PgA9 { TPFlags_Izbi_ArgSpec }, TP_PgA9 { TPFlags_Izbi((TPFlags_Izbi_ArgSpec | TPFlags_Izbi_Typename)) }, TP_PgA9 { TPFlags_Izbi_Typename } }};
    doTrySpec_MbR9(typeParams);
    int count = 0;
    each_8JND(typeParams, count);
    return count - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn Map(type K, type V) struct {
            keys: K[];
            vals: V[];
        };

        fn ref !<K, V>(using ref _: Map(K, V), key: K) {
            for (mut i = 0; i < keys.len; i++)
                if (keys[i] == key)
                    return vals[i];

            keys.push(key);
            vals.push([]);
            return vals[vals.len - 1];
        }

        struct Type { using vtype: i32 };

        fn find_if_odd(ref map: Map(i32, Type), key: i32)
            key & 1
                ? map.ref(key)
                : key & 2 && throw("never");

        fn main() {
            mut map: Map(i32, Type);
            map.keys ~= 1;
            map.vals ~= Type(2);
            return find_if_odd(map, 1) - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>
#include <fu/vec/concat_one.h>

struct Map_M1d6;
struct Type_d8ML;

                                #ifndef DEF_Type_d8MLXbM7uph
                                #define DEF_Type_d8MLXbM7uph
struct Type_d8ML
{
                                // shape_hash:    51dc7c80c832ccac
                                // non_triv_mask: 0000000000000000
    int vtype;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
        ;
    }
};
                                #endif

                                #ifndef DEF_Map_M1d6VrNSW35
                                #define DEF_Map_M1d6VrNSW35
struct Map_M1d6
{
                                // shape_hash:    2e2da70d578eafa3
                                // non_triv_mask: 0008000040000000
    fu::vec<int> keys;
    fu::vec<Type_d8ML> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ref_WTBEjEMcMyk
                                #define DEF_ref_WTBEjEMcMyk
inline static const Type_d8ML& ref_WTBE(/*3:3*/ Map_M1d6& _, const int key)
{
    for (int i = 0; i < _.keys.size(); i++)
    {
        if (_.keys[i] == key)
            return _.vals[i];

    };
    _.keys.push(key);
    _.vals.push(Type_d8ML{});
    return _.vals[(_.vals.size() - 1)];
}
                                #endif

static int find_if_odd_MbR9(/*3:3*/ Map_M1d6& map, const int key)
{
    if (key & 1)
        return ref_WTBE(map, key).vtype;
    else if (key & 2)
        fu::fail(fu::str("never"_fu));
    else
        return 0;

}

int fu_MAIN()
{
    Map_M1d6 map {};
    map.keys += 1;
    map.vals += Type_d8ML { 2 };
    return find_if_odd_MbR9(map, 1) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        lax                         
        noinline                        
        fn longer(                  
            l: $T[..], r: $T[..],       
            pick!)
        {
            let longer = {                                      // GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      // Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",
                pick: |longer| { break longer; });

            return longer.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_longer_9TSITiJc13e
                                #define DEF_longer_9TSITiJc13e
inline static fu::view<char> longer_9TSI(/*7:7*/ fu::view<char> l, /*7:7*/ fu::view<char> r)
{
    fu::view<char> BL_1_v {};
    fu::view<char> /*l|r*/ longer = (__extension__ (
    { {
        for (; ; )
        {
            if (l.size() > r.size())
            {
                { BL_1_v.ptr_reassign(l); goto BL_1; };
            }
            else
            {
                { BL_1_v.ptr_reassign(r); goto BL_1; };
            };
        };
      } BL_1:;
        (void)0;
    }), BL_1_v);
    return longer;
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ longer = longer_9TSI("Hello"_view, " World!"_view);
    return longer.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedLet

========

        lax                         
        noinline                        
        fn longer(                  
            l: string, r: string,       
            pick!)
        {
            let longer = {                                      // GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      // Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",
                pick: |longer| { break longer; });

            return longer.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_longer_9TSITiJc13e
                                #define DEF_longer_9TSITiJc13e
inline static fu::view<char> longer_9TSI(/*7:7*/ fu::view<char> l, /*7:7*/ fu::view<char> r)
{
    fu::view<char> BL_1_v {};
    fu::view<char> /*l|r*/ longer = (__extension__ (
    { {
        for (; ; )
        {
            if (l.size() > r.size())
            {
                { BL_1_v.ptr_reassign(l); goto BL_1; };
            }
            else
            {
                { BL_1_v.ptr_reassign(r); goto BL_1; };
            };
        };
      } BL_1:;
        (void)0;
    }), BL_1_v);
    return longer;
}
                                #endif

int fu_MAIN()
{
    fu::view<char> /*static*/ longer = longer_9TSI("Hello"_view, " World!"_view);
    return longer.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedLet

========

        lax                         
        inline      // PointlessLocal   
        fn longer(                  
            l: $T[..], r: $T[..],       
            pick!)
        {
            let longer = {                                      // GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      // Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",
                pick: |longer| { break longer; });

            return longer.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    { {
        fu::view<char> /*static*/ l = "does"_view;
        fu::view<char> /*static*/ r = "nothing"_view;
        for (; ; )
        {
            if (l.size() > r.size())
                goto BL_1;
            else
                goto BL_1;

        };
      } BL_1:;
    };
    fu::view<char> longer_1 {};
    fu::view<char> l {};
    fu::view<char> r {};
    fu::view<char> BL_6_v {};
    fu::view<char> /*longer*/ longer = (l.ptr_reassign("Hello"_view), r.ptr_reassign(" World!"_view), longer_1.ptr_reassign((__extension__ (
    { {
        for (; ; )
        {
            if (l.size() > r.size())
            {
                { BL_6_v.ptr_reassign(l); goto BL_6; };
            }
            else
            {
                { BL_6_v.ptr_reassign(r); goto BL_6; };
            };
        };
      } BL_6:;
        (void)0;
    }), BL_6_v)), longer_1);
    return longer.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        lax                         
        inline      // PointlessLocal   
        fn longer(                  
            l: string, r: string,       
            pick!)
        {
            let longer = {                                      // GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      // Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",
                pick: |longer| { break longer; });

            return longer.len - 7;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    { {
        fu::view<char> /*static*/ l = "does"_view;
        fu::view<char> /*static*/ r = "nothing"_view;
        for (; ; )
        {
            if (l.size() > r.size())
                goto BL_1;
            else
                goto BL_1;

        };
      } BL_1:;
    };
    fu::view<char> longer_1 {};
    fu::view<char> l {};
    fu::view<char> r {};
    fu::view<char> BL_6_v {};
    fu::view<char> /*longer*/ longer = (l.ptr_reassign("Hello"_view), r.ptr_reassign(" World!"_view), longer_1.ptr_reassign((__extension__ (
    { {
        for (; ; )
        {
            if (l.size() > r.size())
            {
                { BL_6_v.ptr_reassign(l); goto BL_6; };
            }
            else
            {
                { BL_6_v.ptr_reassign(r); goto BL_6; };
            };
        };
      } BL_6:;
        (void)0;
    }), BL_6_v)), longer_1);
    return longer.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

========

        noinline fn longer(             
            l: byte[..], r: byte[..])   
        {
            return l.len > r.len ? l : r;
        }


        noinline fn strsqr(mut str: string, n: i32) {
            for (mut i = 1; i < n; i++) str ~= str;
            return str;
        }

        noinline fn mightConstCast() {
            return longer(
                "A---A".strsqr(4),
                "B-BB-B".strsqr(4));                            // ConstCast
        }

        fn main() {
            let longer = mightConstCast();
            shadow let longer = longer ~ longer;
            return longer.split("BB").len == 32 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 15:20+6[0m:

[2m      | [0m
[2m      |         noinline fn mightConstCast() {[0m
[2m   15 | [0m            return [31;1mlonger[0m(
[2m      |                 "A---A".strsqr(4),[0m
[2m      |                 "B-BB-B".strsqr(4));                            // ConstCast[0m

	An array value is needed, but cannot be copied or moved from a slice: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [32;3mtemp[0m [35;3mstring[0m

RelaxCopyResize [35;3mfn[0m [94;1mmightConstCast[0m at [2m14:21+14[0m

========

        noinline fn longer(             
            l: byte[..], r: byte[..])   
        {
            return l.len > r.len ? l : r;
        }

        pub import _0;
        noinline fn strsqr(mut str: string, n: i32) {
            for (mut i = 1; i < n; i++) str ~= str;
            return str;
        }

        noinline fn mightConstCast() {
            return longer(
                "A---A".strsqr(4),
                "B-BB-B".strsqr(4));                            // ConstCast
        }

        fn main() {
            let longer = mightConstCast();
            shadow let longer = longer ~ longer;
            return longer.split("BB").len == 32 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_1[2m.fu 8:20+6[0m:

[2m      | [0m
[2m      |         noinline fn mightConstCast() {[0m
[2m    8 | [0m            return [31;1mlonger[0m(
[2m      |                 "A---A".strsqr(4),[0m
[2m      |                 "B-BB-B".strsqr(4));                            // ConstCast[0m

	An array value is needed, but cannot be copied or moved from a slice: [35;3mnocopy[0m [35;3mconst[0m [35;3mref[0m [32;3mtemp[0m [35;3mstring[0m

RelaxCopyResize [35;3mfn[0m [94;1mmightConstCast[0m at [2m7:21+14[0m

========

        noinline fn longer(             
            l: $T[..],   r: $T[..])     
        {
            return l.len > r.len ? l : r;
        }


        noinline fn strsqr(mut str: string, n: i32) {
            for (mut i = 1; i < n; i++) str ~= str;
            return str;
        }

        noinline fn mightConstCast() {
            return longer(
                "A---A".strsqr(4),
                "B-BB-B".strsqr(4));                            // ConstCast
        }

        fn main() {
            let longer = mightConstCast();
            shadow let longer = longer ~ longer;
            return longer.split("BB").len == 32 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2416) arc_count(9) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str strsqr_MbR9(/*MOV*/ fu::str&& str, const int n)
{
    for (int i = 1; i < n; i++)
        str += fu::str(/*bck:vi 0*/ str);

    return str.destructive_move();
}

                                #ifndef DEF_longer_S1cbvvxVbc5
                                #define DEF_longer_S1cbvvxVbc5
inline static fu::vec_range<char> longer_S1cb(/*3:3*/ fu::vec_range<char> l, /*3:3*/ fu::vec_range<char> r)
{
    if (l.size() > r.size())
        return l;
    else
        return r;

}
                                #endif

static fu::str mightConstCast_MbR9()
{
    return longer_S1cb(strsqr_MbR9(fu::str("A---A"_fu), 4), strsqr_MbR9(fu::str("B-BB-B"_fu), 4)).const_cast_mut().destructive_move();
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    fu::str longer = mightConstCast_MbR9();
    fu::str longer_1 = (longer + longer);
    if (split_t3LL(longer_1, "BB"_view).size() == 32)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn longer(             
            l: $T[..],   r: $T[..])     
        {
            return l.len > r.len ? l : r;
        }

        pub import _0;
        noinline fn strsqr(mut str: string, n: i32) {
            for (mut i = 1; i < n; i++) str ~= str;
            return str;
        }

        noinline fn mightConstCast() {
            return longer(
                "A---A".strsqr(4),
                "B-BB-B".strsqr(4));                            // ConstCast
        }

        fn main() {
            let longer = mightConstCast();
            shadow let longer = longer ~ longer;
            return longer.split("BB").len == 32 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(2416) arc_count(9) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str strsqr_LtD7(/*MOV*/ fu::str&& str, const int n)
{
    for (int i = 1; i < n; i++)
        str += fu::str(/*bck:vi 0*/ str);

    return str.destructive_move();
}

                                #ifndef DEF_longer_S1cbvvxVbc5
                                #define DEF_longer_S1cbvvxVbc5
inline fu::vec_range<char> longer_S1cb(/*3:3*/ fu::vec_range<char> l, /*3:3*/ fu::vec_range<char> r)
{
    if (l.size() > r.size())
        return l;
    else
        return r;

}
                                #endif

static fu::str mightConstCast_LtD7()
{
    return longer_S1cb(strsqr_LtD7(fu::str("A---A"_fu), 4), strsqr_LtD7(fu::str("B-BB-B"_fu), 4)).const_cast_mut().destructive_move();
}

                                #ifndef DEF_find_ZKsG2FXrtpg
                                #define DEF_find_ZKsG2FXrtpg
inline int find_ZKsG(/*F:F*/ fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_find_7SLcWgAQSl4
                                #define DEF_find_7SLcWgAQSl4
inline int find_7SLc(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_ZKsG(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char /*needle|static*/ needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_BNNwXhPzgU8
                                #define DEF_find_BNNwXhPzgU8
inline int find_BNNw(/*F:F*/ fu::view<char> haystack, /*F:F*/ fu::view<char> needle, const int start)
{
    fu::view<char> /*haystack*/ slice = fu::get_view(haystack, start);
    const int res = find_7SLc(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF___eQwyLf8GPl6
                                #define DEF___eQwyLf8GPl6
inline static fu::view<fu::str> _eQwy(/*3:3*/ fu::vec_range<char> substr, /*3:3*/ fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}
                                #endif

                                #ifndef DEF_split_yvvq0ZGoCfa
                                #define DEF_split_yvvq0ZGoCfa
inline void split_yvvq(/*F:F*/ fu::vec_range<char> str, /*F:F*/ fu::view<char> sep, /*C:C*/ fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = find_BNNw(str, sep, last)) >= 0))
        {
            _eQwy(fu::get_range(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        _eQwy(fu::get_range(str, last), result);
    else
        _eQwy(str, result);

}
                                #endif

                                #ifndef DEF_split_t3LL2OMc5xa
                                #define DEF_split_t3LL2OMc5xa
inline fu::vec<fu::str> split_t3LL(/*3:3*/ fu::vec_range<char> str, /*3:3*/ fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_yvvq(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    fu::str longer = mightConstCast_LtD7();
    fu::str longer_1 = (longer + longer);
    if (split_t3LL(longer_1, "BB"_view).size() == 32)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target   { index: i32 }
        struct Lifetime { uni0n!: byte[] };
        type Type = Lifetime;

        fn is_ref(type: Type) = !!type;

        fn Lifetime_process(lifetime: Lifetime, each) {
            fn visit(shadow lifetime) {
                do {
                    fn continue_climb(mut parent: Lifetime) {
                        visit(parent);
                        continue;
                    }

                    each(lifetime, fn continue_climb);
                }
                while (false);
            }

            return visit(lifetime);
        }

        fn main() {
            fn Lifetime_climbType(lax lifetime: Lifetime) return [];

            mut count = 0;
            Lifetime_process([], each: |lifetime, continue_climb| {
                count++;

                lax let init = lifetime.Lifetime_climbType;
                if (init.is_ref)
                    continue_climb(init);
            });

            return count - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/default.h>

struct Lifetime_llCF;
inline static void visit_EE8f(int&);

                                #ifndef DEF_Lifetime_llCFAn7rdDl
                                #define DEF_Lifetime_llCFAn7rdDl
struct Lifetime_llCF
{
                                // shape_hash:    b1c42cfdca9a7fbf
                                // non_triv_mask: 0000808000000000
    fu::str uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool is_ref_MbR9(/*1:1*/ const Lifetime_llCF& type)
{
    return !!type;
}

                                #ifndef DEF_visit_EE8fsYLwDs5
                                #define DEF_visit_EE8fsYLwDs5
inline static void visit_EE8f(/*3:3*/ int& count)
{
    do
    {
        count++;
        if (is_ref_MbR9((*(Lifetime_llCF*)fu::NIL)))
            visit_EE8f(count);

    }
    while (false);
}
                                #endif

                                #ifndef DEF_Lifetime_process_KCUgiPrWB4k
                                #define DEF_Lifetime_process_KCUgiPrWB4k
inline static void Lifetime_process_KCUg(/*7:7*/ int& count)
{
    visit_EE8f(count);
}
                                #endif

int fu_MAIN()
{
    int count = 0;
    Lifetime_process_KCUg(count);
    return count - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_UnusedCall, N_UnusedIfElse, N_UnusedLet

========

        using flags Flags { A; B }

        fn parseExoticDecl(shadow mut flags: Flags) {
            if (flags) {
                fn add(flag) flags |= flag;
                return add(B);
            }

            return flags;
        }

        fn main() = parseExoticDecl(A).i32 - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Flags_Qpfn;

                                #ifndef DEF_Flags_Qpfn
                                #define DEF_Flags_Qpfn
inline constexpr Flags_Qpfn Flags_Qpfn_A = Flags_Qpfn(1u);
inline constexpr Flags_Qpfn Flags_Qpfn_B = Flags_Qpfn(2u);

inline constexpr Flags_Qpfn MASK_Flags_Qpfn
    = Flags_Qpfn_A
    | Flags_Qpfn_B;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_add_5Bsdb5RbDX2
                                #define DEF_add_5Bsdb5RbDX2
inline static Flags_Qpfn add_5Bsd(const Flags_Qpfn flag, /*3:3*/ Flags_Qpfn& flags)
{
    return (flags |= flag);
}
                                #endif

static Flags_Qpfn parseExoticDecl_MbR9(Flags_Qpfn flags)
{
    if (flags)
        return add_5Bsd(Flags_Qpfn_B, flags);
    else
        return flags;

}

int fu_MAIN()
{
    return int(parseExoticDecl_MbR9(Flags_Qpfn_A)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Node { items: string };

        pub fn solve(using ref _current_fn: Node, root) {
            fn solveNode(node) {
                if (_current_fn) {
                    fn outItems(back) items[items.len - back];
                    _current_fn.items ~= "! ";
                    return outItems(2);
                }

                _current_fn.items ~= node.items;
                return [];
            }

            return solveNode(root);
        }

        fn main() {
            mut n = Node("hello");
            return solve(n, n).i32 - '!'.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec/concat.h>

struct Node_qyrK;

                                #ifndef DEF_Node_qyrKVSOzWF9
                                #define DEF_Node_qyrKVSOzWF9
struct Node_qyrK
{
                                // shape_hash:    22a0e8a028165b07
                                // non_triv_mask: 0000800040000000
    fu::str items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_outItems_2MENI7Gb4f7
                                #define DEF_outItems_2MENI7Gb4f7
inline static char outItems_2MEN(const int back, /*3:3*/ const Node_qyrK& _current_fn)
{
    return _current_fn.items[(_current_fn.items.size() - back)];
}
                                #endif

                                #ifndef DEF_solveNode_IeymZPyXcm3
                                #define DEF_solveNode_IeymZPyXcm3
inline static char solveNode_Ieym(/*3:3*/ const Node_qyrK& node, /*2:2*/ Node_qyrK& _current_fn)
{
    if (_current_fn)
    {
        _current_fn.items += "! "_view;
        return outItems_2MEN(2, _current_fn);
    }
    else
    {
        _current_fn.items += node.items;
        return char{};
    };
}
                                #endif

                                #ifndef DEF_solve_5cGMnPUkqli
                                #define DEF_solve_5cGMnPUkqli
inline char solve_5cGM(/*1:1*/ Node_qyrK& _current_fn, /*3:3*/ const Node_qyrK& root)
{
    return solveNode_Ieym(root, _current_fn);
}
                                #endif

int fu_MAIN()
{
    Node_qyrK n = Node_qyrK { fu::str("hello"_fu) };
    return int(fu::u8(solve_5cGM(n, Node_qyrK(/*bck:vi 0*/ n)))) - int(fu::u8('!'));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Node { items: string };

        pure fn closure_of_explicit_ref_cant_relax(ref n) {
            fn solveNode(ref items) {
                fn outItems(back) items[items.len - back];
                if (n) return outItems(1);
                return [];
            }

            return solveNode(n.items);
        }

        fn main() {
            mut n = Node("hello");
            return closure_of_explicit_ref_cant_relax(n).i32 - 'o'.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>

struct Node_qyrK;

                                #ifndef DEF_Node_qyrKVSOzWF9
                                #define DEF_Node_qyrKVSOzWF9
struct Node_qyrK
{
                                // shape_hash:    22a0e8a028165b07
                                // non_triv_mask: 0000800040000000
    fu::str items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_outItems_jLFvdiJ0Msl
                                #define DEF_outItems_jLFvdiJ0Msl
inline static char outItems_jLFv(const int back, /*3:3*/ fu::view<char> items)
{
    return items[(items.size() - back)];
}
                                #endif

                                #ifndef DEF_solveNode_Fi03cnbGU33
                                #define DEF_solveNode_Fi03cnbGU33
inline static char solveNode_Fi03(/*3:3*/ fu::view<char> items, /*3:3*/ const Node_qyrK& n)
{
    if (n)
        return outItems_jLFv(1, items);
    else
    {
        return char{};
    };
}
                                #endif

                                #ifndef DEF_closure_of_explicit_ref_cant_relax_wfj6mn0NhOd
                                #define DEF_closure_of_explicit_ref_cant_relax_wfj6mn0NhOd
inline static char closure_of_explicit_ref_cant_relax_wfj6(/*1:1*/ const Node_qyrK& n)
{
    return solveNode_Fi03(n.items, n);
}
                                #endif

int fu_MAIN()
{
    Node_qyrK n = Node_qyrK { fu::str("hello"_fu) };
    return int(fu::u8(closure_of_explicit_ref_cant_relax_wfj6(n))) - int(fu::u8('o'));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Node { items: string };

        pure fn injected_args_ignore_relaxed_types(using ref n) {
            fn solveNode(lax _) {
                fn outItems(back) items[items.len - back];
                if (n) return outItems(1);
                return [];
            }

            return solveNode(0);
        }

        fn main() {
            mut n = Node("hello");
            return injected_args_ignore_relaxed_types(n).i32 - 'o'.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>
#include <fu/str.h>

struct Node_qyrK;

                                #ifndef DEF_Node_qyrKVSOzWF9
                                #define DEF_Node_qyrKVSOzWF9
struct Node_qyrK
{
                                // shape_hash:    22a0e8a028165b07
                                // non_triv_mask: 0000800040000000
    fu::str items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_outItems_2MENI7Gb4f7
                                #define DEF_outItems_2MENI7Gb4f7
inline static char outItems_2MEN(const int back, /*3:3*/ const Node_qyrK& n)
{
    return n.items[(n.items.size() - back)];
}
                                #endif

                                #ifndef DEF_solveNode_XeyxVbr4uf9
                                #define DEF_solveNode_XeyxVbr4uf9
inline static char solveNode_Xeyx(/*3:3*/ const Node_qyrK& n)
{
    if (n)
        return outItems_2MEN(1, n);
    else
    {
        return char{};
    };
}
                                #endif

                                #ifndef DEF_injected_args_ignore_relaxed_types_gzFbkTBVZuk
                                #define DEF_injected_args_ignore_relaxed_types_gzFbkTBVZuk
inline static char injected_args_ignore_relaxed_types_gzFb(/*1:1*/ const Node_qyrK& n)
{
    return solveNode_Xeyx(n);
}
                                #endif

int fu_MAIN()
{
    Node_qyrK n = Node_qyrK { fu::str("hello"_fu) };
    return int(fu::u8(injected_args_ignore_relaxed_types_gzFb(n))) - int(fu::u8('o'));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn blockTailHasLocals_but_blockTypeIsTemp_reduct(ref id: string) {
            fn ooeWrap(src) src && [];
            return id
                 ? ooeWrap((id = "") ~ (id = ""))
                 : "";
        }

        fn main() {
            mut id: string = "none of this does anything";
            return blockTailHasLocals_but_blockTypeIsTemp_reduct(:id).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_IBGkAVvGcv1
                                #define STR_IBGkAVvGcv1
static const fu::str str_IBGkAVvGcv1 fu_INIT_PRIORITY(1001) { "none of this does anything"_fu };
                                #endif

                                #ifndef STR_00000000000
                                #define STR_00000000000
static const fu::str str_00000000000 fu_INIT_PRIORITY(1001) { ""_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> blockTailHasLocals_but_blockTypeIsTemp_reduct_MbR9(/*1:1*/ fu::vec_range_mut<char> id)
{
    if (id)
    {

        {
            id = fu::str(""_fu);
            id = fu::str(""_fu);
        };
        return fu::vec_range<char>{};
    }
    else
        return str_00000000000;

}

int fu_MAIN()
{
    fu::str id = fu::str(str_IBGkAVvGcv1);
    return blockTailHasLocals_but_blockTypeIsTemp_reduct_MbR9(id).size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedIfElse

========

        fn blockTailHasLocals_but_blockTypeIsTemp_reduct(ref id: string) {
            fn ooeWrap(src) src && [];
            return id
                 ? ooeWrap((id = "") ~ (id = ""))
                 : "";
        }

        fn main() {
            mut id: string = "none of this does anything";
            return blockTailHasLocals_but_blockTypeIsTemp_reduct(:id).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/default.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_IBGkAVvGcv1
                                #define STR_IBGkAVvGcv1
static const fu::str str_IBGkAVvGcv1 fu_INIT_PRIORITY(1001) { "none of this does anything"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& blockTailHasLocals_but_blockTypeIsTemp_reduct_MbR9(/*1:1*/ fu::vec_range_mut<char> id)
{
    if (id)
    {

        {
            id = fu::str{};
            id = fu::str{};
        };
        return (*(fu::str*)fu::NIL);
    }
    else
        return (*(fu::str*)fu::NIL);

}

int fu_MAIN()
{
    fu::str id = fu::str(str_IBGkAVvGcv1);
    return blockTailHasLocals_but_blockTypeIsTemp_reduct_MbR9(id).size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedIfElse

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0)) ~ "" ~ (ARG(1)));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        return fu::str{};
    }
    else if (!id)
        return ""_view + id;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::vec_range_mut<char> def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::vec_range_mut<char> def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def = fu::str(""_fu);
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedArrlit, N_UnusedLet, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0)) ~ "" ~ (ARG(1)));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        return fu::str{};
    }
    else if (!id)
    {
        return fu::view<char>{} + id;
    }
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::str& def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::str& def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def {};
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_UnusedArrlit, N_UnusedLet, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0)) ~ "" ~ (ARG(1) = ""));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str(""_fu), fu::str(""_fu) }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        ARG_PxQF(1, item_src) = fu::str(""_fu);
        return fu::str{};
    }
    else if (!id)
        return ""_view + id;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::vec_range_mut<char> def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::vec_range_mut<char> def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def = fu::str(""_fu);
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0)) ~ "" ~ (ARG(1) = ""));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str{}, fu::str{} }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        ARG_PxQF(1, item_src) = fu::str{};
        return fu::str{};
    }
    else if (!id)
    {
        return fu::view<char>{} + id;
    }
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::str& def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::str& def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def {};
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0) = "") ~ "" ~ (ARG(1)));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str(""_fu), fu::str(""_fu) }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        ARG_PxQF(0, item_src) = fu::str(""_fu);
        return fu::str{};
    }
    else if (!id)
        return ""_view + id;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::vec_range_mut<char> def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::vec_range_mut<char> def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def = fu::str(""_fu);
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0) = "") ~ "" ~ (ARG(1)));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str{}, fu::str{} }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {
        ARG_PxQF(0, item_src) = fu::str{};
        return fu::str{};
    }
    else if (!id)
    {
        return fu::view<char>{} + id;
    }
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::str& def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::str& def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def {};
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0) = "") ~ "" ~ (ARG(1) = ""));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str(""_fu), fu::str(""_fu) }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {

        {
            ARG_PxQF(0, item_src) = fu::str(""_fu);
            ARG_PxQF(1, item_src) = fu::str(""_fu);
        };
        return fu::str{};
    }
    else if (!id)
        return ""_view + id;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::vec_range_mut<char> def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::vec_range_mut<char> def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def = fu::str(""_fu);
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0) = "") ~ "" ~ (ARG(1) = ""));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct SolvedNode_5CCD;

                                #ifndef DEF_SolvedNode_5CCDrzRRiBj
                                #define DEF_SolvedNode_5CCDrzRRiBj
struct SolvedNode_5CCD
{
                                // shape_hash:    9aff3d833cb1054e
                                // non_triv_mask: 0000840000200000
    fu::str value;
    fu::vec<SolvedNode_5CCD> items;
    SolvedNode_5CCD(const SolvedNode_5CCD&) = default;
    SolvedNode_5CCD(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(SolvedNode_5CCD&&) = default;
    SolvedNode_5CCD& operator=(const SolvedNode_5CCD& selfrec) { return *this = SolvedNode_5CCD(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_ARG_PxQF9LJuEl0
                                #define DEF_ARG_PxQF9LJuEl0
inline static fu::vec_range_mut<char> ARG_PxQF(const int i, /*3:3*/ fu::view_mut<fu::str> item_src)
{
    return item_src.mutref(i);
}
                                #endif

static fu::str cgCall_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    fu::vec<fu::str> item_src = fu::vec<fu::str> {{ fu::str{}, fu::str{} }};
    fu::view<char> /*node*/ id = node.value;
    if (id.size() & 1)
    {

        {
            ARG_PxQF(0, item_src) = fu::str{};
            ARG_PxQF(1, item_src) = fu::str{};
        };
        return fu::str{};
    }
    else if (!id)
    {
        return fu::view<char>{} + id;
    }
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___FeOteekDLya
                                #define DEF___FeOteekDLya
inline static fu::view<char> _FeOt(/*3:3*/ const SolvedNode_5CCD& item, /*2:2*/ fu::str& def)
{
    return (def += (item.value + cgCall_MbR9(item)));
}
                                #endif

                                #ifndef DEF_each_pvUBbsq4rna
                                #define DEF_each_pvUBbsq4rna
inline void each_pvUB(/*7:7*/ fu::view<SolvedNode_5CCD> a, /*6:6*/ fu::str& def)
{
    for (int i = 0; i < a.size(); i++)
        _FeOt(a[i], def);

}
                                #endif

static fu::str declareStruct_MbR9(/*1:1*/ const SolvedNode_5CCD& node)
{
    /*MOV*/ fu::str def {};
    each_pvUB(node.items, def);
    return /*NRVO*/ def;
}

static fu::str blockTailHasLocals_but_blockTypeIsTemp_MbR9(/*1:1*/ const SolvedNode_5CCD& root)
{
    return declareStruct_MbR9(root);
}

int fu_MAIN()
{
    return blockTailHasLocals_but_blockTypeIsTemp_MbR9(SolvedNode_5CCD { {/*unused non-zst*/}, fu::vec<SolvedNode_5CCD>{} }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode, N_RelaxRespec, N_UnusedCall, N_UnusedIfElse, N_COWRestrict

========

        struct Target { id: int };
        fn isLocal(t: Target) t.id & 1;
        fn parent(t: Target) Target(t.id & ~1);

        fn main() {
            struct SolverState { _scope: string };
            using mut ss: SolverState = [ "Hello" ];
            fn GETLocal(t: Target) = GET(t.parent) ~ ", world!";
            using fn GET(t: Target) = t.isLocal ? GETLocal(t) : _scope;
            let res: string = Target(1);
            return res == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct SolverState_Cfoe;
struct Target_gJfz;
static fu::str GET_MbR9(const Target_gJfz&, const SolverState_Cfoe&);

                                #ifndef DEF_SolverState_Cfoe1wbT4Ze
                                #define DEF_SolverState_Cfoe1wbT4Ze
struct SolverState_Cfoe
{
                                // shape_hash:    8033ca61f0e8a8ea
                                // non_triv_mask: 0010800000000000
    fu::str _scope;
    explicit operator bool() const noexcept
    {
        return false
            || _scope
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_gJfzaVayx7f
                                #define DEF_Target_gJfzaVayx7f
struct Target_gJfz
{
                                // shape_hash:    a1259c5d4d88120b
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int isLocal_MbR9(/*1:1*/ const Target_gJfz& t)
{
    return t.id & 1;
}

static Target_gJfz parent_MbR9(/*1:1*/ const Target_gJfz& t)
{
    return Target_gJfz { (t.id & ~1) };
}

static fu::str GETLocal_MbR9(/*3:3*/ const Target_gJfz& t, /*3:3*/ const SolverState_Cfoe& ss)
{
    return GET_MbR9(parent_MbR9(t), ss) + ", world!"_view;
}

static fu::str GET_MbR9(/*3:3*/ const Target_gJfz& t, /*3:3*/ const SolverState_Cfoe& ss)
{
    if (isLocal_MbR9(t))
        return GETLocal_MbR9(t, ss);
    else
        return fu::str(ss._scope);

}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    SolverState_Cfoe ss = SolverState_Cfoe { fu::str("Hello"_fu) };
    fu::str res = GET_MbR9(Target_gJfz { 1 }, ss);
    if (res == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Target { id: int }
        struct Overload { name: string };
        struct ClosureID { target: Target };
        inline fn globid(lax t) i32();

        fn parse(id!: string) {
            if (!id) throw("throw!");
            shadow let id = id[0].int;
            return ClosureID(Target(id));
        }

        fn zstHostArgsCanEndUpWithMismatchedArgVals(ref overloads: Overload[]) {
            fn strGET(id: string) GET(parse(:id).target);
            fn GET(t: Target) overloads[t.globid].name;
            return "0".strGET;
        }

        fn main() {
            mut overloads = [ Overload("Hello, world!") ];
            return overloads.zstHostArgsCanEndUpWithMismatchedArgVals().len - 13;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct Overload_BK87;
struct ClosureID_IfnY;
struct Target_gJfz;

                                #ifndef DEF_Overload_BK87DwUjMbc
                                #define DEF_Overload_BK87DwUjMbc
struct Overload_BK87
{
                                // shape_hash:    12d9a4e6c7efbfd8
                                // non_triv_mask: 0000800020000000
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_Target_gJfzaVayx7f
                                #define DEF_Target_gJfzaVayx7f
struct Target_gJfz
{
                                // shape_hash:    a1259c5d4d88120b
                                // non_triv_mask: 0000000000000000
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_ClosureID_IfnYdqVpQei
                                #define DEF_ClosureID_IfnYdqVpQei
struct ClosureID_IfnY
{
                                // shape_hash:    a9ecdb820c13274d
                                // non_triv_mask: 0000000000000000
    Target_gJfz target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static ClosureID_IfnY parse_MbR9(/*1:1*/ fu::view<char> id)
{
    if (!id)
        fu::fail(fu::str("throw!"_fu));
    else
    {
        const int id_1 = int(fu::u8(id[0]));
        return ClosureID_IfnY { Target_gJfz { id_1 } };
    };
}

static const fu::str& GET_kGbb(/*3:3*/ fu::view<Overload_BK87> overloads)
{
    return overloads[0].name;
}

static const fu::str& strGET_kGbb(/*3:3*/ fu::view<char> id, /*3:3*/ fu::view<Overload_BK87> overloads)
{
    return ((void) parse_MbR9(id), GET_kGbb(overloads));
}

static const fu::str& zstHostArgsCanEndUpWithMismatchedArgVals_kGbb(/*1:1*/ fu::view<Overload_BK87> overloads)
{
    return strGET_kGbb("0"_view, overloads);
}

int fu_MAIN()
{
    fu::vec<Overload_BK87> overloads = fu::vec<Overload_BK87> {{ Overload_BK87 { fu::str("Hello, world!"_fu) } }};
    return zstHostArgsCanEndUpWithMismatchedArgVals_kGbb(overloads).size() - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn FAIL(implicit side: string)
            throw(side);

        fn ensureArgSeq_argsLenMismatch(
            ref data: string, index: int)
        {
            fn strGET(id: string)
                id && intGET(id.len || FAIL());

            fn intGET(target: int)
                target > data.len
                    ? intGET(0).strGET
                    : data[target ..];

            return intGET(index);
        }

        fn main() {
            let implicit side = "Hello!";
            mut data = "Hello, World!";
            return ensureArgSeq_argsLenMismatch(data, 5).len - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

static fu::view<char> intGET_kGbb(int, fu::vec_range_mut<char>, fu::vec_range<char>);

                                #ifndef STR_YH7vqBEGuw9
                                #define STR_YH7vqBEGuw9
static const fu::str str_YH7vqBEGuw9 fu_INIT_PRIORITY(1001) { "Hello!"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*1:1*/ fu::vec_range<char> side)
{
    fu::fail(fu::str(side));
}

static fu::view<char> strGET_kGbb(/*7:7*/ fu::view<char> id, /*7:3*/ fu::vec_range_mut<char> data, /*7:7*/ fu::vec_range<char> side)
{
    int _0;
    return !id ? id : intGET_kGbb(((_0 = id.size()) ? _0 : FAIL_MbR9(side)), data, side);
}

static fu::view<char> intGET_kGbb(const int target, /*7:3*/ fu::vec_range_mut<char> data, /*7:7*/ fu::vec_range<char> side)
{
    if (target > data.size())
    {
        fu::view<char> _0 {};
        return (_0.ptr_reassign(intGET_kGbb(0, data, side)), strGET_kGbb(_0, data, side));
    }
    else
        return fu::get_view(data, target);

}

static fu::view<char> ensureArgSeq_argsLenMismatch_kGbb(/*7:3*/ fu::vec_range_mut<char> data, const int index, /*7:7*/ fu::vec_range<char> side)
{
    return intGET_kGbb(index, data, side);
}

int fu_MAIN()
{
    fu::vec_range<char> /*static*/ side = str_YH7vqBEGuw9;
    fu::str data = fu::str("Hello, World!"_fu);
    return ensureArgSeq_argsLenMismatch_kGbb(data, 5, side).size() - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        fn FAIL(implicit side: string)
            throw(side);

        fn ensureArgSeq_argsLenMismatch(
            ref data: string, index: int)
        {
            fn strGET(id: string)
                id && intGET(id.len || FAIL());

            fn intGET(target: int)
                target > data.len
                    ? intGET(0).strGET
                    : data[target ..];

            return intGET(index);
        }

        fn main() {
            let implicit side = "Hello!";
            mut data = "Hello, World!";
            return ensureArgSeq_argsLenMismatch(data, 5).len - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>

static fu::view<char> intGET_kGbb(int, fu::vec_range_mut<char>, fu::vec_range<char>);

                                #ifndef STR_YH7vqBEGuw9
                                #define STR_YH7vqBEGuw9
static const fu::str str_YH7vqBEGuw9 fu_INIT_PRIORITY(1001) { "Hello!"_fu };
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_MbR9(/*1:1*/ fu::vec_range<char> side)
{
    fu::fail(fu::str(side));
}

static fu::view<char> strGET_kGbb(/*7:7*/ fu::view<char> id, /*7:3*/ fu::vec_range_mut<char> data, /*7:7*/ fu::vec_range<char> side)
{
    int _0;
    return !id ? id : intGET_kGbb(((_0 = id.size()) ? _0 : FAIL_MbR9(side)), data, side);
}

static fu::view<char> intGET_kGbb(const int target, /*7:3*/ fu::vec_range_mut<char> data, /*7:7*/ fu::vec_range<char> side)
{
    if (target > data.size())
    {
        fu::view<char> _0 {};
        return (_0.ptr_reassign(intGET_kGbb(0, data, side)), strGET_kGbb(_0, data, side));
    }
    else
        return fu::get_view(data, target);

}

static fu::view<char> ensureArgSeq_argsLenMismatch_kGbb(/*7:3*/ fu::vec_range_mut<char> data, const int index, /*7:7*/ fu::vec_range<char> side)
{
    return intGET_kGbb(index, data, side);
}

int fu_MAIN()
{
    const fu::str& /*static*/ side = str_YH7vqBEGuw9;
    fu::str data = fu::str("Hello, World!"_fu);
    return ensureArgSeq_argsLenMismatch_kGbb(data, 5, side).size() - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            fn  a = u.a;                
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            ref                 
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*1:1*/ Unit_GNXY& u)
{
    fu::vec_range_mut<char> _0 {};
    return !(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range_mut(a_MbR9(u), 0, a_GL0m(u).size());
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::vec_range_mut<char> /*u*/ res = brokenAssignmentWantsStringGetsSlice_MbR9(u);
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            fn  a = u.a;                
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            mut // ConstCast    
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::vec_range<char> brokenAssignmentWantsStringGetsSlice_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    fu::vec_range<char> _0 {};
    return !(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size());
}

int fu_MAIN()
{
    /*MOV*/ Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::str res = brokenAssignmentWantsStringGetsSlice_kGbb(u).const_cast_mut().destructive_move();
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            ref a = u.a;                
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            ref                 
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*1:1*/ Unit_GNXY& u)
{
    fu::str& /*u*/ a = u.a;
    return !a ? a : fu::get_range_mut(a, 0, a.size());
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::vec_range_mut<char> /*u*/ res = brokenAssignmentWantsStringGetsSlice_MbR9(u);
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            ref a = u.a;                
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            mut // ConstCast    
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> brokenAssignmentWantsStringGetsSlice_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    const fu::str& /*u*/ a = u.a;
    return !a ? a : fu::get_range(a, 0, a.size());
}

int fu_MAIN()
{
    /*MOV*/ Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::str res = brokenAssignmentWantsStringGetsSlice_kGbb(u).const_cast_mut().destructive_move();
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            fn  a = u.b && u.a;         
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            ref                 
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*1:1*/ Unit_GNXY& u)
{
    fu::vec_range_mut<char> _0 {};
    return !(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range_mut(a_MbR9(u), 0, a_GL0m(u).size());
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::vec_range_mut<char> /*u*/ res = brokenAssignmentWantsStringGetsSlice_MbR9(u);
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            fn  a = u.b && u.a;         
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            mut // ConstCast    
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::vec_range<char> brokenAssignmentWantsStringGetsSlice_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    fu::vec_range<char> _0 {};
    return !(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size());
}

int fu_MAIN()
{
    /*MOV*/ Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res = brokenAssignmentWantsStringGetsSlice_kGbb(u).const_cast_mut().destructive_move();
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            ref a = u.b && u.a;         
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            ref                 
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*1:1*/ Unit_GNXY& u)
{
    fu::str& /*u*/ a = (!u.b ? u.b : u.a);
    return !a ? a : fu::get_range_mut(a, 0, a.size());
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::vec_range_mut<char> /*u*/ res = brokenAssignmentWantsStringGetsSlice_MbR9(u);
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit) {

            ref a = u.b && u.a;         
            return a && a[0 .. a.len];
        }

        fn main() {
            mut u = Unit("Hello", "world!");

            mut // ConstCast    
                res = brokenAssignmentWantsStringGetsSlice(:u);
            res ~= "!!";
            return res.len == 7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> brokenAssignmentWantsStringGetsSlice_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    const fu::str& /*u*/ a = (!u.b ? u.b : u.a);
    return !a ? a : fu::get_range(a, 0, a.size());
}

int fu_MAIN()
{
    /*MOV*/ Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res = brokenAssignmentWantsStringGetsSlice_kGbb(u).const_cast_mut().destructive_move();
    res += "!!"_view;
    if (res.size() == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(u: Unit, ref res: string) {

            fn  a = u.a;                
            res   = a && a[0 .. a.len];
        }

        fn main() {
            let u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ const Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::vec_range<char> _0 {};
    res = (!(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range(a_MbR9(u), 0, a_kGbb(u).size()));
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(u: Unit, ref res: string) {

            let a = u.a;                
            res   = a && a[0 .. a.len];
        }

        fn main() {
            let u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ const Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    const fu::str& /*u*/ a = u.a;
    res = (!a ? a : fu::get_range(a, 0, a.size()));
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), {/*unused non-zst*/} };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(u: Unit, ref res: string) {

            fn  a = u.b && u.a;         
            res   = a && a[0 .. a.len];
        }

        fn main() {
            let u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ const Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::vec_range<char> _0 {};
    res = (!(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range(a_MbR9(u), 0, a_kGbb(u).size()));
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(u: Unit, ref res: string) {

            let a = u.b && u.a;         
            res   = a && a[0 .. a.len];
        }

        fn main() {
            let u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ const Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    const fu::str& /*u*/ a = (!u.b ? u.b : u.a);
    res = (!a ? a : fu::get_range(a, 0, a.size()));
}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit, ref res: string) {

            fn  a = u.a;                
            res   = a && a[0 .. a.len];
            if (u.b)
                return a;

            return res;
        }

        fn main() {
            mut u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res).clear();
            return res.len == 5 && !u.a.len ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::vec_range<char> _0 {};
    res = (!(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size()));
    if (u.b)
        return a_MbR9(u);
    else
        return res;

}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res).clear();
    if ((res.size() == 5) && !u.a.size())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit, ref res: string) {

            ref a = u.a;                
            res   = a && a[0 .. a.len];
            if (u.b)
                return a;

            return res;
        }

        fn main() {
            mut u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res).clear();
            return res.len == 5 && !u.a.len ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::str& /*u*/ a = u.a;
    res = (!a ? a : fu::get_range(a, 0, a.size()));
    if (u.b)
        return a;
    else
        return res;

}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res).clear();
    if ((res.size() == 5) && !u.a.size())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit, ref res: string) {

            fn  a = u.b && u.a;         
            res   = a && a[0 .. a.len];
            if (u.b)
                return a;

            return res;
        }

        fn main() {
            mut u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res).clear();
            return res.len == 5 && !u.a.len ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::vec_range<char> _0 {};
    res = (!(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size()));
    if (u.b)
        return a_MbR9(u);
    else
        return res;

}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res).clear();
    if ((res.size() == 5) && !u.a.size())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref u: Unit, ref res: string) {

            ref a = u.b && u.a;         
            res   = a && a[0 .. a.len];
            if (u.b)
                return a;

            return res;
        }

        fn main() {
            mut u = Unit("Hello", "world!");
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:u, :res).clear();
            return res.len == 5 && !u.a.len ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ Unit_GNXY& u, /*2:2*/ fu::vec_range_mut<char> res)
{
    fu::str& /*u*/ a = (!u.b ? u.b : u.a);
    res = (!a ? a : fu::get_range(a, 0, a.size()));
    if (u.b)
        return a;
    else
        return res;

}

int fu_MAIN()
{
    Unit_GNXY u = Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) };
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(u, res).clear();
    if ((res.size() == 5) && !u.a.size())
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];           
                fn  a = u.a;                
                res   = a && a[0 .. a.len];
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ fu::view<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        fu::vec_range<char> _0 {};
        res = (!(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range(a_MbR9(u), 0, a_kGbb(u).size()));
    };
}

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];           
                let a = u.a;                
                res   = a && a[0 .. a.len];
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ fu::view<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        const fu::str& /*u*/ a = u.a;
        res = (!a ? a : fu::get_range(a, 0, a.size()));
    };
}

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];           
                fn  a = u.b && u.a;         
                res   = a && a[0 .. a.len];
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ fu::view<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        fu::vec_range<char> _0 {};
        res = (!(_0.ptr_reassign(a_MbR9(u))) ? _0 : fu::get_range(a_MbR9(u), 0, a_kGbb(u).size()));
    };
}

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];           
                let a = u.b && u.a;         
                res   = a && a[0 .. a.len];
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res);
            return res.len == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*3:3*/ fu::view<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        const fu::str& /*u*/ a = (!u.b ? u.b : u.a);
        res = (!a ? a : fu::get_range(a, 0, a.size()));
    };
}

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res);
    if (res.size() == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];           
                fn  a = u.a;                
                res   = a && a[0 .. a.len];
                if (u.b)
                    return a;
            }

            return res;
        }

        fn main() {
            mut units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res).clear();
            return res.len == 5 && units.all(|x| !x.a.len) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:1*/ fu::view_mut<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        Unit_GNXY& /*units|static*/ u = units.mutref(i);
        fu::vec_range<char> _0 {};
        res = (!(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size()));
        if (u.b)
            return a_MbR9(u);

    };
    return res;
}

                                #ifndef DEF___OCKeXCnhlt8
                                #define DEF___OCKeXCnhlt8
inline static bool _OCKe(/*1:1*/ const Unit_GNXY& x)
{
    return !x.a.size();
}
                                #endif

                                #ifndef DEF_all_aNoHxP1M8B5
                                #define DEF_all_aNoHxP1M8B5
inline bool all_aNoH(/*3:3*/ fu::view<Unit_GNXY> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Unit_GNXY& /*a|static*/ item = a[i];
        if (!_OCKe(item))
            return false;

    };
    return true;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res).clear();
    if ((res.size() == 5) && all_aNoH(units))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];           
                ref a = u.a;                
                res   = a && a[0 .. a.len];
                if (u.b)
                    return a;
            }

            return res;
        }

        fn main() {
            mut units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res).clear();
            return res.len == 5 && units.all(|x| !x.a.len) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:1*/ fu::view_mut<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        Unit_GNXY& /*units|static*/ u = units.mutref(i);
        fu::str& /*u*/ a = u.a;
        res = (!a ? a : fu::get_range(a, 0, a.size()));
        if (u.b)
            return a;

    };
    return res;
}

                                #ifndef DEF___OCKeXCnhlt8
                                #define DEF___OCKeXCnhlt8
inline static bool _OCKe(/*1:1*/ const Unit_GNXY& x)
{
    return !x.a.size();
}
                                #endif

                                #ifndef DEF_all_aNoHxP1M8B5
                                #define DEF_all_aNoHxP1M8B5
inline bool all_aNoH(/*3:3*/ fu::view<Unit_GNXY> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Unit_GNXY& /*a|static*/ item = a[i];
        if (!_OCKe(item))
            return false;

    };
    return true;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res).clear();
    if ((res.size() == 5) && all_aNoH(units))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];           
                fn  a = u.b && u.a;         
                res   = a && a[0 .. a.len];
                if (u.b)
                    return a;
            }

            return res;
        }

        fn main() {
            mut units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res).clear();
            return res.len == 5 && units.all(|x| !x.a.len) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::view<char> a_GL0m(/*1:1*/ const Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::str& a_MbR9(/*1:1*/ Unit_GNXY& u)
{
    return !u.b ? u.b : u.a;
}

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:1*/ fu::view_mut<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        Unit_GNXY& /*units|static*/ u = units.mutref(i);
        fu::vec_range<char> _0 {};
        res = (!(_0.ptr_reassign(a_kGbb(u))) ? _0 : fu::get_range(a_kGbb(u), 0, a_GL0m(u).size()));
        if (u.b)
            return a_MbR9(u);

    };
    return res;
}

                                #ifndef DEF___OCKeXCnhlt8
                                #define DEF___OCKeXCnhlt8
inline static bool _OCKe(/*1:1*/ const Unit_GNXY& x)
{
    return !x.a.size();
}
                                #endif

                                #ifndef DEF_all_aNoHxP1M8B5
                                #define DEF_all_aNoHxP1M8B5
inline bool all_aNoH(/*3:3*/ fu::view<Unit_GNXY> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Unit_GNXY& /*a|static*/ item = a[i];
        if (!_OCKe(item))
            return false;

    };
    return true;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res).clear();
    if ((res.size() == 5) && all_aNoH(units))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        struct Unit { a: string; b: string };

        fn brokenAssignmentWantsStringGetsSlice(ref units: Unit[], ref res: string) {
            for (mut i = 0; i < units.len; i++) {
                ref u = units[i];           
                ref a = u.b && u.a;         
                res   = a && a[0 .. a.len];
                if (u.b)
                    return a;
            }

            return res;
        }

        fn main() {
            mut units = [ Unit("Hello", "world!") ];
            mut res: string;
            brokenAssignmentWantsStringGetsSlice(:units, :res).clear();
            return res.len == 5 && units.all(|x| !x.a.len) ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range_mut<char> brokenAssignmentWantsStringGetsSlice_MbR9(/*3:1*/ fu::view_mut<Unit_GNXY> units, /*2:2*/ fu::vec_range_mut<char> res)
{
    for (int i = 0; i < units.size(); i++)
    {
        Unit_GNXY& /*units|static*/ u = units.mutref(i);
        fu::str& /*u*/ a = (!u.b ? u.b : u.a);
        res = (!a ? a : fu::get_range(a, 0, a.size()));
        if (u.b)
            return a;

    };
    return res;
}

                                #ifndef DEF___OCKeXCnhlt8
                                #define DEF___OCKeXCnhlt8
inline static bool _OCKe(/*1:1*/ const Unit_GNXY& x)
{
    return !x.a.size();
}
                                #endif

                                #ifndef DEF_all_aNoHxP1M8B5
                                #define DEF_all_aNoHxP1M8B5
inline bool all_aNoH(/*3:3*/ fu::view<Unit_GNXY> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const Unit_GNXY& /*a|static*/ item = a[i];
        if (!_OCKe(item))
            return false;

    };
    return true;
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world!"_fu) } }};
    fu::str res {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, res).clear();
    if ((res.size() == 5) && all_aNoH(units))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedLet

========

        struct Unit { a: string; b: string };

        fn bang(mut str: string)
            str[0 .. str.len] ~= (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                fn  a = u.a;        

                fn  b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*MOV*/ fu::str&& str)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((starts_ojop(str, "H"_view) ? ", "_view : "!"_view)), (fu::get_range_mut(str, 0, str.size()) += _0)).destructive_move();
}

static fu::view<char> b_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    fu::view<char> _0 {};
    return !(_0.ptr_reassign(a_kGbb(u))) ? _0 : u.b;
}

static const fu::str& b_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    const fu::str* _0;
    return !*(_0 = &(a_MbR9(u))) ? *_0 : u.b;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        aa.push((a_kGbb(u) ? bang_MbR9(fu::str(a_MbR9(u))) : fu::str{}));
        bb.push((b_kGbb(u) ? bang_MbR9(fu::str(b_MbR9(u))) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Unit { a: string; b: string };

        fn bang(mut str: string)
            str[0 .. str.len] ~= (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                fn  a = u.a;        

                let b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*MOV*/ fu::str&& str)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((starts_ojop(str, "H"_view) ? ", "_view : "!"_view)), (fu::get_range_mut(str, 0, str.size()) += _0)).destructive_move();
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        const fu::str* _0;
        const fu::str& /*u*/ b = (!*(_0 = &(a_MbR9(u))) ? *_0 : u.b);
        aa.push((a_kGbb(u) ? bang_MbR9(fu::str(a_MbR9(u))) : fu::str{}));
        bb.push((b ? bang_MbR9(fu::str(b)) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Unit { a: string; b: string };

        fn bang(mut str: string)
            str[0 .. str.len] ~= (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                let a = u.a;        

                fn  b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*MOV*/ fu::str&& str)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((starts_ojop(str, "H"_view) ? ", "_view : "!"_view)), (fu::get_range_mut(str, 0, str.size()) += _0)).destructive_move();
}

static fu::view<char> b_kGbb(/*3:3*/ const Unit_GNXY& u, /*3:3*/ fu::view<char> a)
{
    return !a ? a : u.b;
}

static const fu::str& b_MbR9(/*3:3*/ const Unit_GNXY& u, /*3:3*/ const fu::str& a)
{
    return !a ? a : u.b;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        const fu::str& /*u*/ a = u.a;
        aa.push((a ? bang_MbR9(fu::str(a)) : fu::str{}));
        bb.push((b_kGbb(u, a) ? bang_MbR9(fu::str(b_MbR9(u, a))) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Unit { a: string; b: string };

        fn bang(mut str: string)
            str[0 .. str.len] ~= (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                let a = u.a;        

                let b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*MOV*/ fu::str&& str)
{
    fu::view<char> _0 {};
    return (_0.ptr_reassign((starts_ojop(str, "H"_view) ? ", "_view : "!"_view)), (fu::get_range_mut(str, 0, str.size()) += _0)).destructive_move();
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        const fu::str& /*u*/ a = u.a;
        const fu::str& /*a|u*/ b = (!a ? a : u.b);
        aa.push((a ? bang_MbR9(fu::str(a)) : fu::str{}));
        bb.push((b ? bang_MbR9(fu::str(b)) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

========

        struct Unit { a: string; b: string };

        fn bang(str: string)
            str[0 .. str.len] ~ (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                fn  a = u.a;        

                fn  b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*1:1*/ fu::view<char> str)
{
    return fu::get_view(str, 0, str.size()) + (starts_ojop(str, "H"_view) ? ", "_view : "!"_view);
}

static fu::view<char> b_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    fu::view<char> _0 {};
    return !(_0.ptr_reassign(a_kGbb(u))) ? _0 : u.b;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        aa.push((a_kGbb(u) ? bang_MbR9(a_kGbb(u)) : fu::str{}));
        bb.push((b_kGbb(u) ? bang_MbR9(b_kGbb(u)) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn bang(str: string)
            str[0 .. str.len] ~ (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                fn  a = u.a;        

                let b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view<char> a_kGbb(/*1:1*/ const Unit_GNXY& u)
{
    return u.a;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*1:1*/ fu::view<char> str)
{
    return fu::get_view(str, 0, str.size()) + (starts_ojop(str, "H"_view) ? ", "_view : "!"_view);
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        fu::view<char> _0 {};
        fu::view<char> /*u*/ b = (!(_0.ptr_reassign(a_kGbb(u))) ? _0 : u.b);
        aa.push((a_kGbb(u) ? bang_MbR9(a_kGbb(u)) : fu::str{}));
        bb.push((b ? bang_MbR9(b) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn bang(str: string)
            str[0 .. str.len] ~ (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                let a = u.a;        

                fn  b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*1:1*/ fu::view<char> str)
{
    return fu::get_view(str, 0, str.size()) + (starts_ojop(str, "H"_view) ? ", "_view : "!"_view);
}

static fu::view<char> b_kGbb(/*3:3*/ const Unit_GNXY& u, /*3:3*/ fu::view<char> a)
{
    return !a ? a : u.b;
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        fu::view<char> /*u*/ a = u.a;
        aa.push((a ? bang_MbR9(a) : fu::str{}));
        bb.push((b_kGbb(u, a) ? bang_MbR9(b_kGbb(u, a)) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Unit { a: string; b: string };

        fn bang(str: string)
            str[0 .. str.len] ~ (str.starts(with: "H") ? ", " : "!");

        fn brokenAssignmentWantsStringGetsSlice(units: Unit[], ref aa: string[], ref bb: string[]) {
            for (mut i = 0; i < units.len; i++) {
                let u = units[i];

                let a = u.a;        

                let b = a && u.b;   

                aa.push(a && bang(a));
                bb.push(b && bang(b));
            }
        }

        fn main() {
            let units = [ Unit("Hello", "world") ];
            mut aa: string[];
            mut bb: string[];
            brokenAssignmentWantsStringGetsSlice(:units, :aa, :bb);
            return aa.join() ~ bb.join() == "Hello, world!" ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct Unit_GNXY;

                                #ifndef DEF_Unit_GNXYnVcHfV7
                                #define DEF_Unit_GNXYnVcHfV7
struct Unit_GNXY
{
                                // shape_hash:    4e06b0416280a4c5
                                // non_triv_mask: 0000800001000000
    fu::str a;
    fu::str b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_starts_ojopLVekF87
                                #define DEF_starts_ojopLVekF87
inline bool starts_ojop(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

static fu::str bang_MbR9(/*1:1*/ fu::view<char> str)
{
    return fu::get_view(str, 0, str.size()) + (starts_ojop(str, "H"_view) ? ", "_view : "!"_view);
}

static void brokenAssignmentWantsStringGetsSlice_MbR9(/*7:7*/ fu::view<Unit_GNXY> units, /*6:2*/ fu::vec_range_mut<fu::str> aa, /*6:4*/ fu::vec_range_mut<fu::str> bb)
{
    for (int i = 0; i < units.size(); i++)
    {
        const Unit_GNXY& /*units|static*/ u = units[i];
        fu::view<char> /*u*/ a = u.a;
        fu::view<char> /*a|u*/ b = (!a ? a : u.b);
        aa.push((a ? bang_MbR9(a) : fu::str{}));
        bb.push((b ? bang_MbR9(b) : fu::str{}));
    };
}

                                #ifndef DEF_join_QbuIaIZczPf
                                #define DEF_join_QbuIaIZczPf
inline fu::str join_QbuI(/*3:3*/ fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<Unit_GNXY> units = fu::vec<Unit_GNXY> {{ Unit_GNXY { fu::str("Hello"_fu), fu::str("world"_fu) } }};
    fu::vec<fu::str> aa {};
    fu::vec<fu::str> bb {};
    brokenAssignmentWantsStringGetsSlice_MbR9(units, aa, bb);
    if ((join_QbuI(aa) + join_QbuI(bb)) == "Hello, world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

========

        struct Type { vfacts: int };

        fn TEST_FunctionNarrowing(host: Type)
            TEST_Assignable(host, false);

        fn TEST_Assignable(mut host: Type, inline reason) {
            if (reason) host.vfacts = [];   
        }

        fn main() {
            let host = Type(1);
            TEST_FunctionNarrowing(host);
            return host.vfacts - 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:12+22[0m:

[2m      |         struct Type { vfacts: int };[0m
[2m      | [0m
[2m    4 | [0m        fn [31;1mTEST_FunctionNarrowing[0m(host: Type)
[2m      |             TEST_Assignable(host, false);[0m
[2m      | [0m

	[35;3mfn[0m [94;1mTEST_FunctionNarrowing[0m does nothing: returns void and has no effects. Make it [35;3mlax[0m if this is intentional.

========

        struct Type { vfacts: int };

        fn TEST_FunctionNarrowing(host: Type)
            TEST_Assignable(host, false);

        fn TEST_Assignable(mut host: Type, inline reason) {
            if (reason) host.vfacts = [];   
            return host;                    
        }

        fn main() {
            let host = Type(1);
            TEST_FunctionNarrowing(host);
            return host.vfacts - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_MMTA;

                                #ifndef DEF_Type_MMTAx0kvg83
                                #define DEF_Type_MMTAx0kvg83
struct Type_MMTA
{
                                // shape_hash:    c1c795556dbee742
                                // non_triv_mask: 0000000000000000
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Type_MMTA host = Type_MMTA { 1 };
    return host.vfacts - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        struct Type { vfacts: int };

        fn TEST_FunctionNarrowing(host: Type)
            TEST_Assignable(host, false);

        fn TEST_Assignable(mut host: Type, inline reason) {
            if (reason) host.vfacts = [];   
            return host;                    
        }

        fn main() {
            let host = Type(1);
            TEST_FunctionNarrowing(host);
            return host.vfacts - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_MMTA;

                                #ifndef DEF_Type_MMTAx0kvg83
                                #define DEF_Type_MMTAx0kvg83
struct Type_MMTA
{
                                // shape_hash:    c1c795556dbee742
                                // non_triv_mask: 0000000000000000
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Type_MMTA host = Type_MMTA { 1 };
    return host.vfacts - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        struct Type { vfacts: int };

        fn TEST_FunctionNarrowing(host: Type, inline reason) {
            shadow mut host = host;
            if (reason) host.vfacts = [];
            return host;
        }

        fn main() {
            let host = Type(1);
            TEST_FunctionNarrowing(host, false);
            return host.vfacts - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_MMTA;

                                #ifndef DEF_Type_MMTAx0kvg83
                                #define DEF_Type_MMTAx0kvg83
struct Type_MMTA
{
                                // shape_hash:    c1c795556dbee742
                                // non_triv_mask: 0000000000000000
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Type_MMTA host = Type_MMTA { 1 };

    {
        Type_MMTA host_1 = host;
        if (false)
            host_1.vfacts = 0;

    };
    return host.vfacts - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Type { vfacts: int };

        fn TEST_FunctionNarrowing(host: Type, inline reason) {
            shadow mut host = host;
            if (reason) host.vfacts = [];
            return host;
        }

        fn main() {
            let host = Type(1);
            TEST_FunctionNarrowing(host, false);
            return host.vfacts - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Type_MMTA;

                                #ifndef DEF_Type_MMTAx0kvg83
                                #define DEF_Type_MMTAx0kvg83
struct Type_MMTA
{
                                // shape_hash:    c1c795556dbee742
                                // non_triv_mask: 0000000000000000
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Type_MMTA host = Type_MMTA { 1 };
    return host.vfacts - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        struct Type { canon: string; vfacts: int }

        fn TEST_FunctionNarrowing(host: Type, guest: Type) {
            TEST_Assignable(host, guest, false)
        }

        fn TEST_Assignable(mut host: Type, guest: Type, inline reason: bool) {
            if (reason) host.vfacts = [];
            isAssignable(:host, :guest)
        }

        fn isAssignable(host: Type, guest: Type) {
            host == guest
        }

        fn main() TEST_FunctionNarrowing(Type(), Type()) ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Type_6c4t;

                                #ifndef DEF_Type_6c4tBuYTXs3
                                #define DEF_Type_6c4tBuYTXs3
struct Type_6c4t
{
                                // shape_hash:    6263ca34fd372682
                                // non_triv_mask: 0000800004000000
    fu::str canon;
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_UrONss6Qyg2
                                #define DEF_x3Cx3E_UrONss6Qyg2
inline int x3Cx3E_UrON(/*3:3*/ const Type_6c4t& a, /*3:3*/ const Type_6c4t& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.vfacts, b.vfacts)))
        return cmp;
    else if ((cmp = x3Cx3E_j5CR(a.canon, b.canon)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_7hkLMsC10Wi
                                #define DEF_x3Dx3D_7hkLMsC10Wi
inline bool operator==(/*3:3*/ const Type_6c4t& a, /*3:3*/ const Type_6c4t& b)
{
    return !x3Cx3E_UrON(a, b);
}
                                #endif

static bool isAssignable_MbR9(/*3:3*/ const Type_6c4t& host, /*3:3*/ const Type_6c4t& guest)
{
    return host == guest;
}

static bool TEST_FunctionNarrowing_MbR9(/*3:3*/ const Type_6c4t& host, /*3:3*/ const Type_6c4t& guest)
{
    Type_6c4t host_1 = host;
    if (false)
        host_1.vfacts = 0;

    return isAssignable_MbR9(host_1, guest);
}

int fu_MAIN()
{
    if (TEST_FunctionNarrowing_MbR9(Type_6c4t{}, Type_6c4t{}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Type { canon: string; vfacts: int }

        fn TEST_FunctionNarrowing(host: Type, guest: Type) {
            TEST_Assignable(host, guest, false)
        }

        fn TEST_Assignable(mut host: Type, guest: Type, inline reason: bool) {
            if (reason) host.vfacts = [];
            isAssignable(:host, :guest)
        }

        fn isAssignable(host: Type, guest: Type) {
            host == guest
        }

        fn main() TEST_FunctionNarrowing(Type(), Type()) ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>

struct Type_6c4t;

                                #ifndef DEF_Type_6c4tBuYTXs3
                                #define DEF_Type_6c4tBuYTXs3
struct Type_6c4t
{
                                // shape_hash:    6263ca34fd372682
                                // non_triv_mask: 0000800004000000
    fu::str canon;
    int vfacts;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || vfacts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_UrONss6Qyg2
                                #define DEF_x3Cx3E_UrONss6Qyg2
inline int x3Cx3E_UrON(/*3:3*/ const Type_6c4t& a, /*3:3*/ const Type_6c4t& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.vfacts, b.vfacts)))
        return cmp;
    else if ((cmp = x3Cx3E_j5CR(a.canon, b.canon)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_7hkLMsC10Wi
                                #define DEF_x3Dx3D_7hkLMsC10Wi
inline bool operator==(/*3:3*/ const Type_6c4t& a, /*3:3*/ const Type_6c4t& b)
{
    return !x3Cx3E_UrON(a, b);
}
                                #endif

static bool isAssignable_MbR9(/*3:3*/ const Type_6c4t& host, /*3:3*/ const Type_6c4t& guest)
{
    return host == guest;
}

static bool TEST_FunctionNarrowing_MbR9(/*3:3*/ const Type_6c4t& host, /*3:3*/ const Type_6c4t& guest)
{
    const Type_6c4t& /*host*/ host_1 = host;
    return isAssignable_MbR9(host_1, guest);
}

int fu_MAIN()
{
    if (TEST_FunctionNarrowing_MbR9(Type_6c4t{}, Type_6c4t{}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn no_fx() {
            mut res = 0;
            pragma clock(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        struct X { a: i32[]; b: i32[] };
        fn test(x: X, ref y: i32[])
            y ~= x.a;

        fn main() {
            mut x = X(
                [ no_fx(), 2, 3, 4, 5, 6, 7, 8 ],
                [ no_fx(), 3, 4, 5, 6, 7, 8, 9 ]);

            test(x, x.a);
            return x.a.len + no_fx * 1000 - 1016;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(336) arc_count(3) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>

struct X_ImXR;

                                #ifndef DEF_X_ImXRjktaigg
                                #define DEF_X_ImXRjktaigg
struct X_ImXR
{
                                // shape_hash:    4b3dd4b6abb3c6db
                                // non_triv_mask: 0008000000000100
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int no_fx_MbR9()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static fu::view<int> test_GL0m(/*3:3*/ const X_ImXR& x, /*2:2*/ fu::vec_range_mut<int> y)
{
    return (y += x.a);
}

int fu_MAIN()
{
    X_ImXR x = X_ImXR { fu::vec<int> {{ no_fx_MbR9(), 2, 3, 4, 5, 6, 7, 8 }}, {/*unused non-zst*/} };
    test_GL0m(X_ImXR(/*bck:vi 1*/ x), x.a);
    return (x.a.size() + (no_fx_MbR9() * 1000)) - 1016;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_UnusedArrlit

========

        struct A { a: X[] };
        struct B { b: X[] };
        struct C { c: X[] };
        struct X { a: A[]; b: B[]; c?: C[]; };

        fn GET(implicit ref x: X[], idx: int) {
            return x[idx];
        }

        fn DUPE(implicit ref x: X[], idx: int) {
            let src = GET(idx);
            let idx1 = x.len;

            x.grow(idx1 + 1)
            ref dest = x[idx1];
            dest.a = src.a;
            dest.b = src.b;
        }

        fn main() {
            implicit mut x = [ X([ A(), A() ], [ B(), B(), B() ], [ C(), C(), C(), C(), C() ]) ];
            DUPE(0);
            mut sum = 0;
            for (mut i = 0; i < x.len; i++) {
                shadow let x = x[i];
                sum *= x.a.len || 1; sum += x.a.len;
                sum *= x.b.len || 1; sum += x.b.len;
                sum *= x.c.len || 1; sum += x.c.len;
            }
            return sum - 309;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(448) arc_count(4) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>

struct X_S9a5;
struct A_b0O6;
struct B_4lY8;
struct C_wePR;

                                #ifndef DEF_A_b0O6nSZxs6l
                                #define DEF_A_b0O6nSZxs6l
struct A_b0O6
{
                                // shape_hash:    31e959b4a6d40d5f
                                // non_triv_mask: 0010904021080400
    fu::vec<X_S9a5> a;
    A_b0O6(const A_b0O6&) = default;
    A_b0O6(A_b0O6&&) = default;
    A_b0O6& operator=(A_b0O6&&) = default;
    A_b0O6& operator=(const A_b0O6& selfrec) { return *this = A_b0O6(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_B_4lY8ZqzmBA6
                                #define DEF_B_4lY8ZqzmBA6
struct B_4lY8
{
                                // shape_hash:    a154ca9436613cc4
                                // non_triv_mask: 0010904021080400
    fu::vec<X_S9a5> b;
    B_4lY8(const B_4lY8&) = default;
    B_4lY8(B_4lY8&&) = default;
    B_4lY8& operator=(B_4lY8&&) = default;
    B_4lY8& operator=(const B_4lY8& selfrec) { return *this = B_4lY8(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_C_wePRuqQ2IRf
                                #define DEF_C_wePRuqQ2IRf
struct C_wePR
{
                                // shape_hash:    84f3feef4a8fdc8b
                                // non_triv_mask: 0010904021080400
    fu::vec<X_S9a5> c;
    C_wePR(const C_wePR&) = default;
    C_wePR(C_wePR&&) = default;
    C_wePR& operator=(C_wePR&&) = default;
    C_wePR& operator=(const C_wePR& selfrec) { return *this = C_wePR(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || c
        ;
    }
};
                                #endif

                                #ifndef DEF_X_S9a5cAVGmg4
                                #define DEF_X_S9a5cAVGmg4
struct X_S9a5
{
                                // shape_hash:    4e2e7cc54124aa13
                                // non_triv_mask: 0010904021080400
    fu::vec<A_b0O6> a;
    fu::vec<B_4lY8> b;
    fu::vec<C_wePR> c;
    X_S9a5(const X_S9a5&) = default;
    X_S9a5(X_S9a5&&) = default;
    X_S9a5& operator=(X_S9a5&&) = default;
    X_S9a5& operator=(const X_S9a5& selfrec) { return *this = X_S9a5(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const X_S9a5& GET_kGbb(const int idx, /*3:3*/ fu::view<X_S9a5> x)
{
    return x[idx];
}

static void DUPE_MbR9(const int idx, /*3:3*/ fu::vec_range_mut<X_S9a5> x)
{
    const X_S9a5* __partcopy_ref;
    /*MOV*/ X_S9a5 src = (__partcopy_ref = &(GET_kGbb(idx, x)), X_S9a5 { fu::vec<A_b0O6>((*__partcopy_ref).a), fu::vec<B_4lY8>((*__partcopy_ref).b), {/*unused non-zst*/} });
    const int idx1 = x.size();
    x.grow((idx1 + 1));
    X_S9a5& /*x|static*/ dest = x.mutref(idx1);
    dest.a = src.a;
    dest.b = static_cast<fu::vec<B_4lY8>&&>(src.b);
}

int fu_MAIN()
{
    fu::vec<X_S9a5> x = fu::vec<X_S9a5> {{ X_S9a5 { fu::vec<A_b0O6> {{ A_b0O6{}, A_b0O6{} }}, fu::vec<B_4lY8> {{ B_4lY8{}, B_4lY8{}, B_4lY8{} }}, fu::vec<C_wePR> {{ C_wePR{}, C_wePR{}, C_wePR{}, C_wePR{}, C_wePR{} }} } }};
    DUPE_MbR9(0, x);
    int sum = 0;
    for (int i = 0; i < x.size(); i++)
    {
        const X_S9a5& /*x|static*/ x_1 = x[i];
        int _0;
        sum *= ((_0 = x_1.a.size()) ? _0 : 1);
        sum += x_1.a.size();
        int _1;
        sum *= ((_1 = x_1.b.size()) ? _1 : 1);
        sum += x_1.b.size();
        int _2;
        sum *= ((_2 = x_1.c.size()) ? _2 : 1);
        sum += x_1.c.size();
    };
    return sum - 309;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_TypeReopen, N_NonTrivAutoCopy, N_RelaxRespec

========

        noinline fn hello(x: i32) x;

        noinline fn hello(x: i32) x;

        fn main() 0._0::hello + 0._1::hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int hello_MbR9(int);
int hello_LtD7(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return hello_MbR9(0) + hello_LtD7(0);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int hello_MbR9(/*1:1*/ const int x)
{
    return x;
}

#endif

#ifndef fu_NO_fdefs

int hello_LtD7(/*1:1*/ const int x)
{
    return x;
}

#endif

========

        noinline fn hello(x) x;

        noinline fn hello(x) x;

        fn main() 0._0::hello + 0._1::hello;                    // DuplicateFunctions

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_0DCJaE9X1mk
                                #define DEF_hello_0DCJaE9X1mk
inline int hello_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

int fu_MAIN()
{
    return hello_0DCJ(0) + hello_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

========

        noinline fn hello(x: i32) x;

        noinline fn hello(x) x;

        fn main() 0._0::hello + 0._1::hello;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int hello_MbR9(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_0DCJaE9X1mk
                                #define DEF_hello_0DCJaE9X1mk
inline int hello_0DCJ(/*1:1*/ const int x)
{
    return x;
}
                                #endif

int fu_MAIN()
{
    return hello_MbR9(0) + hello_0DCJ(0);
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int hello_MbR9(/*1:1*/ const int x)
{
    return x;
}

#endif

========

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline int Each_D41D(int);
inline int Each_Wo11(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_D41D5FjX5e0
                                #define DEF_Each_D41D5FjX5e0
inline int Each_D41D(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_D41D((y / 2));

}
                                #endif

                                #ifndef DEF_Each_Wo119hC76Zg
                                #define DEF_Each_Wo119hC76Zg
inline int Each_Wo11(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_Wo11((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_D41D(100);
    const int b = Each_Wo11(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

========

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline int Each_D41D(int);
int Each_LtD7(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_D41D5FjX5e0
                                #define DEF_Each_D41D5FjX5e0
inline int Each_D41D(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_D41D((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_D41D(100);
    const int b = Each_LtD7(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve
int Each_LtD7(int);

#ifndef fu_NO_fdefs

int Each_LtD7(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_LtD7((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

========

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int Each_MbR9(int);
inline int Each_Wo11(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_Wo119hC76Zg
                                #define DEF_Each_Wo119hC76Zg
inline int Each_Wo11(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_Wo11((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_MbR9(100);
    const int b = Each_Wo11(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve
int Each_MbR9(int);

#ifndef fu_NO_fdefs

int Each_MbR9(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_MbR9((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

========

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int Each_MbR9(int);
int Each_LtD7(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = Each_MbR9(100);
    const int b = Each_LtD7(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }
int Each_MbR9(int);

#ifndef fu_NO_fdefs

int Each_MbR9(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_MbR9((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve
int Each_LtD7(int);

#ifndef fu_NO_fdefs

int Each_LtD7(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_LtD7((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

========

        fn find(keys: $T[], item: $T) {
            for (mut i = 0; i < keys.len; i++) {
                if (keys[i] >= item) {
                    if (keys[i] != item)
                        return -1;

                    return i;
                }
            }

            return -1;
        }

        fn Set(_: $K) struct { keys: $K[]; };

        fn has(using _, key)
            _0::find(keys, key) >= 0;

        fn use_Set(a: string) {
            mut set: _1::Set(string);
            set.keys ~= a;
            return set._1::has(a);
        }

        fn dont_use_Set(a: string, b: string) {
            mut keys: string[];
            keys ~= b;
            keys ~= a;
            return keys.find(a);
        }

        fn main() {
            if (!use_Set("a"))
                return -1;

            return dont_use_Set("a", "b") - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct Set_xo49;

                                #ifndef DEF_Set_xo49AlD8bt5
                                #define DEF_Set_xo49AlD8bt5
struct Set_xo49
{
                                // shape_hash:    91bd066510d48bf3
                                // non_triv_mask: 0000c02000000000
    fu::vec<fu::str> keys;
    explicit operator bool() const noexcept
    {
        return false
            || keys
        ;
    }
};
                                #endif

                                #ifndef STR_ujDub247BYe
                                #define STR_ujDub247BYe
static const fu::str str_ujDub247BYe fu_INIT_PRIORITY(1003) { "a"_fu };
                                #endif

                                #ifndef STR_GURXpaBTk07
                                #define STR_GURXpaBTk07
static const fu::str str_GURXpaBTk07 fu_INIT_PRIORITY(1003) { "b"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Ex3D_NQuX1RZ2ud4
                                #define DEF_x3Ex3D_NQuX1RZ2ud4
inline bool operator>=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return (x3Cx3E_j5CR(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_x21x3D_ZDMfM5XjHla
                                #define DEF_x21x3D_ZDMfM5XjHla
inline bool operator!=(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !!x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_find_YSPBlzy3oz6
                                #define DEF_find_YSPBlzy3oz6
inline int find_YSPB(/*3:3*/ fu::view<fu::str> keys, /*3:3*/ fu::view<char> item)
{
    for (int i = 0; i < keys.size(); i++)
    {
        if ((keys[i] >= item))
        {
            if (keys[i] != item)
                return -1;
            else
                return i;

        };
    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_WtKv6Kmb9K3
                                #define DEF_has_WtKv6Kmb9K3
inline bool has_WtKv(/*3:3*/ const Set_xo49& _, /*3:3*/ fu::view<char> key)
{
    return (find_YSPB(_.keys, key) >= 0);
}
                                #endif

static bool use_Set_WLF9(/*1:1*/ fu::vec_range<char> a)
{
    Set_xo49 set {};
    set.keys += fu::str(a);
    return has_WtKv(set, a);
}

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

                                #ifndef DEF_find_cVszpoH03s0
                                #define DEF_find_cVszpoH03s0
inline int find_cVsz(/*F:F*/ fu::view<fu::str> haystack, /*F:F*/ fu::view<char> needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static int dont_use_Set_WLF9(/*3:3*/ fu::vec_range<char> a, /*3:3*/ fu::vec_range<char> b)
{
    fu::vec<fu::str> keys {};
    keys += fu::str(b);
    keys += fu::str(a);
    return find_cVsz(keys, a);
}

int fu_MAIN()
{
    if (!use_Set_WLF9(str_ujDub247BYe))
        return -1;
    else
        return dont_use_Set_WLF9(str_ujDub247BYe, str_GURXpaBTk07) - 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy

========

        fn test(tokens: i32[]) {
            mut lidx = 0;
            mut sum  = 0;

            fn token(idx: i32, col!: i32)       = sum += idx * col;
            fn token(idx: i32)                  = token(:idx, col: lidx - idx);

            for (mut i = 0; i < tokens.len; i++)
                token(tokens[i]);

            return sum;
        }

        fn main() [ 1 ].test + 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int token_4wfu(const int idx, const int col, /*7:7*/ int& sum)
{
    return (sum += (idx * col));
}

static int token_miPE(const int idx, /*7:7*/ const int lidx, /*7:7*/ int& sum)
{
    return token_4wfu(idx, (lidx - idx), sum);
}

static int test_MbR9(/*1:1*/ fu::view<int> tokens)
{
    const int lidx = 0;
    int sum = 0;
    for (int i = 0; i < tokens.size(); i++)
        token_miPE(tokens[i], lidx, sum);

    return sum;
}

int fu_MAIN()
{
    return test_MbR9(fu::view<int> {{ 1 }}) + 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn sum_each(a, b, Each)     a.Each + b.Each;

        fn hello(x) {
            if (x & 1) {
                fn Each(y) y    ? y * Each(y - 1)
                                : 100;

                return sum_each(x, x, fn Each);
            }
            else {
                fn Each(y) y    ? y * Each(y - 1)
                                : 10000;

                return sum_each(x, x, fn Each);
            }
        }

        fn Each(y) y & 1    ? y
                            : y / 2 + Each(y / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
inline static int Each_kVZO(int);
inline static int Each_kdwo(int);
inline static int Each_D41D(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_kVZOK2qM0t5
                                #define DEF_Each_kVZOK2qM0t5
inline static int Each_kVZO(const int y)
{
    if (y)
        return y * Each_kVZO((y - 1));
    else
        return 100;

}
                                #endif

                                #ifndef DEF_sum_each_fxlSQYjV5Gj
                                #define DEF_sum_each_fxlSQYjV5Gj
inline int sum_each_fxlS(const int a, const int b)
{
    return Each_kVZO(a) + Each_kVZO(b);
}
                                #endif

                                #ifndef DEF_Each_kdwomPYPIVd
                                #define DEF_Each_kdwomPYPIVd
inline static int Each_kdwo(const int y)
{
    if (y)
        return y * Each_kdwo((y - 1));
    else
        return 10000;

}
                                #endif

                                #ifndef DEF_sum_each_eY00CaknSXb
                                #define DEF_sum_each_eY00CaknSXb
inline int sum_each_eY00(const int a, const int b)
{
    return Each_kdwo(a) + Each_kdwo(b);
}
                                #endif

                                #ifndef DEF_hello_y5vNyXjdee5
                                #define DEF_hello_y5vNyXjdee5
inline int hello_y5vN(const int x)
{
    if (x & 1)
        return sum_each_fxlS(x, x);
    else
        return sum_each_eY00(x, x);

}
                                #endif

                                #ifndef DEF_Each_D41D5FjX5e0
                                #define DEF_Each_D41D5FjX5e0
inline static int Each_D41D(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_D41D((y / 2));

}
                                #endif

int fu_MAIN()
{
    return ((hello_y5vN(1) - (2 * Each_D41D(100))) + hello_y5vN(2)) - (2 * Each_D41D(20000));
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

========

        fn a        = "aaa";
        fn shorter  = "bb";
        fn greater  = "aac";

        return a <> shorter == +1
            && a <> greater == -1 ? 0 : 101;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>


                                #ifndef STR_GpsDMzoqPze
                                #define STR_GpsDMzoqPze
static const fu::str str_GpsDMzoqPze fu_INIT_PRIORITY(1001) { "aaa"_fu };
                                #endif

                                #ifndef STR_ehu3xTBc59i
                                #define STR_ehu3xTBc59i
static const fu::str str_ehu3xTBc59i fu_INIT_PRIORITY(1001) { "bb"_fu };
                                #endif

                                #ifndef STR_5RMrrFTPIv1
                                #define STR_5RMrrFTPIv1
static const fu::str str_5RMrrFTPIv1 fu_INIT_PRIORITY(1001) { "aac"_fu };
                                #endif

#ifndef fu_NO_fdefs

static fu::vec_range<char> a_MbR9()
{
    return str_GpsDMzoqPze;
}

static fu::vec_range<char> shorter_MbR9()
{
    return str_ehu3xTBc59i;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

static fu::vec_range<char> greater_MbR9()
{
    return str_5RMrrFTPIv1;
}

int fu_MAIN()
{
    if ((x3Cx3E_j5CR(a_MbR9(), shorter_MbR9()) == +1) && (x3Cx3E_j5CR(a_MbR9(), greater_MbR9()) == -1))
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

========

        fn a        = "aaa";
        fn shorter  = "bb";
        fn greater  = "aac";

        return a <> shorter == +1
            && a <> greater == -1 ? 0 : 101;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>


                                #ifndef STR_GpsDMzoqPze
                                #define STR_GpsDMzoqPze
static const fu::str str_GpsDMzoqPze fu_INIT_PRIORITY(1001) { "aaa"_fu };
                                #endif

                                #ifndef STR_ehu3xTBc59i
                                #define STR_ehu3xTBc59i
static const fu::str str_ehu3xTBc59i fu_INIT_PRIORITY(1001) { "bb"_fu };
                                #endif

                                #ifndef STR_5RMrrFTPIv1
                                #define STR_5RMrrFTPIv1
static const fu::str str_5RMrrFTPIv1 fu_INIT_PRIORITY(1001) { "aac"_fu };
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& a_MbR9()
{
    return str_GpsDMzoqPze;
}

static const fu::str& shorter_MbR9()
{
    return str_ehu3xTBc59i;
}

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

static const fu::str& greater_MbR9()
{
    return str_5RMrrFTPIv1;
}

int fu_MAIN()
{
    if ((x3Cx3E_j5CR(a_MbR9(), shorter_MbR9()) == +1) && (x3Cx3E_j5CR(a_MbR9(), greater_MbR9()) == -1))
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

========

        fn &(a, b) {
            mut res = a;
            for (fieldname i: typeof(a)) res.i &= b.i;
            return res;
        }

        struct XY  { x: i32; y: i32 };
        struct UVW { u: i32; v: i32; w: i32 };

        import _0;

        fn main() {
            mut xy  =  XY(1, 2)    &  XY(2, 3);
            mut uvw = UVW(1, 2, 3) & UVW(2, 3, 4);
            return xy.y - uvw.v;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct XY_tqAU;
struct UVW_R24h;

                                #ifndef DEF_XY_tqAU3bUpwy1
                                #define DEF_XY_tqAU3bUpwy1
struct XY_tqAU
{
                                // shape_hash:    98dd1c419bc12221
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_UVW_R24hPrWzoH2
                                #define DEF_UVW_R24hPrWzoH2
struct UVW_R24h
{
                                // shape_hash:    90a0f6a1db9a27f1
                                // non_triv_mask: 0000000000000000
    int u;
    int v;
    int w;
    explicit operator bool() const noexcept
    {
        return false
            || u
            || v
            || w
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x26_xq4Z0GeYNT3
                                #define DEF_x26_xq4Z0GeYNT3
inline XY_tqAU operator&(/*3:3*/ const XY_tqAU& a, /*3:3*/ const XY_tqAU& b)
{
    XY_tqAU res = a;

    {
        res.x &= b.x;
        res.y &= b.y;
    };
    return res;
}
                                #endif

                                #ifndef DEF_x26_C92tcU3GOMe
                                #define DEF_x26_C92tcU3GOMe
inline UVW_R24h operator&(/*3:3*/ const UVW_R24h& a, /*3:3*/ const UVW_R24h& b)
{
    UVW_R24h res = a;

    {
        res.u &= b.u;
        res.v &= b.v;
        res.w &= b.w;
    };
    return res;
}
                                #endif

int fu_MAIN()
{
    const XY_tqAU xy = (XY_tqAU { 1, 2 } & XY_tqAU { 2, 3 });
    const UVW_R24h uvw = (UVW_R24h { 1, 2, 3 } & UVW_R24h { 2, 3, 4 });
    return xy.y - uvw.v;
}

#endif

int main() { return fu_MAIN(); }

========

        struct Projection { x: i32; y: i32 };
        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);
        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);

        import _0;

        fn main() {
            let p0 = Projection(a: 3,  4);
            let p1 = Projection(c: 20, 30);
            return p0.x + p1.x - 49;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Projection_ORgc;
Projection_ORgc Projection_MbR9(int, int);
Projection_ORgc Projection_kGbb(int, int);

                                #ifndef DEF_Projection_ORgcJ4da142
                                #define DEF_Projection_ORgcJ4da142
struct Projection_ORgc
{
                                // shape_hash:    87af9e9029bdc081
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Projection_ORgc p0 = Projection_MbR9(3, 4);
    const Projection_ORgc p1 = Projection_kGbb(20, 30);
    return (p0.x + p1.x) - 49;
}

#endif

int main() { return fu_MAIN(); }
struct Projection_ORgc;

                                #ifndef DEF_Projection_ORgcJ4da142
                                #define DEF_Projection_ORgcJ4da142
struct Projection_ORgc
{
                                // shape_hash:    87af9e9029bdc081
                                // non_triv_mask: 0000000000000000
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

Projection_ORgc Projection_MbR9(const int a, const int b)
{
    return Projection_ORgc { (a * a), (b * b) };
}

Projection_ORgc Projection_kGbb(const int c, const int d)
{
    return Projection_ORgc { (c + c), (d + d) };
}

#endif

========

        struct Woot { i: i32 };
        fn sqr(v) = mul(v, v);

        import _0;
        noinline fn mul(x: Woot, y: Woot) = x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);

        import _0;
        noinline fn mul(x: Woot, y: Woot) = 2 * x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);

        fn main() {
            let x = _0::Woot(2);
            let a = _1::use_sqr(x);
            let b = _2::use_sqr(x);
            return a == 4 && b == 8 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Woot_w3YG;
int mul_LtD7(const Woot_w3YG&, const Woot_w3YG&);
int mul_WLF9(const Woot_w3YG&, const Woot_w3YG&);

                                #ifndef DEF_Woot_w3YG0ozq80k
                                #define DEF_Woot_w3YG0ozq80k
struct Woot_w3YG
{
                                // shape_hash:    a33484804485af8e
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sqr_WAKbnbjJfC9
                                #define DEF_sqr_WAKbnbjJfC9
inline int sqr_WAKb(/*1:1*/ const Woot_w3YG& v)
{
    return mul_LtD7(v, v);
}
                                #endif

                                #ifndef DEF_sqr_h5NVigkI5vk
                                #define DEF_sqr_h5NVigkI5vk
inline int sqr_h5NV(/*1:1*/ const Woot_w3YG& v)
{
    return mul_WLF9(v, v);
}
                                #endif

int fu_MAIN()
{
    const Woot_w3YG x = Woot_w3YG { 2 };
    const int a = sqr_WAKb(x);
    const int b = sqr_h5NV(x);
    if ((a == 4) && (b == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
struct Woot_w3YG;

                                #ifndef DEF_Woot_w3YG0ozq80k
                                #define DEF_Woot_w3YG0ozq80k
struct Woot_w3YG
{
                                // shape_hash:    a33484804485af8e
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int mul_LtD7(/*3:3*/ const Woot_w3YG& x, /*3:3*/ const Woot_w3YG& y)
{
    return x.i * y.i;
}

#endif
struct Woot_w3YG;

                                #ifndef DEF_Woot_w3YG0ozq80k
                                #define DEF_Woot_w3YG0ozq80k
struct Woot_w3YG
{
                                // shape_hash:    a33484804485af8e
                                // non_triv_mask: 0000000000000000
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int mul_WLF9(/*3:3*/ const Woot_w3YG& x, /*3:3*/ const Woot_w3YG& y)
{
    return (2 * x.i) * y.i;
}

#endif

========

        noinline fn hey(a: int) a + 2;
        pub fn add2(a) a.hey;

        noinline fn hey(a: int) a + 3;
        pub fn add3(a) a.hey;

        fn main() (-5)._0::add2._1::add3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
int hey_MbR9(int);
int hey_LtD7(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_add2_PnkC69bPgi8
                                #define DEF_add2_PnkC69bPgi8
inline int add2_PnkC(const int a)
{
    return hey_MbR9(a);
}
                                #endif

                                #ifndef DEF_add3_qdlU6lQpwD1
                                #define DEF_add3_qdlU6lQpwD1
inline int add3_qdlU(const int a)
{
    return hey_LtD7(a);
}
                                #endif

int fu_MAIN()
{
    return add3_qdlU(add2_PnkC(-5));
}

#endif

int main() { return fu_MAIN(); }

#ifndef fu_NO_fdefs

int hey_MbR9(const int a)
{
    return a + 2;
}

#endif

// N_SD_ExternPrivates

#ifndef fu_NO_fdefs

int hey_LtD7(const int a)
{
    return a + 3;
}

#endif

// N_SD_ExternPrivates

========

        fn main() {
            type A = { struct Node { value?: int; items: Node[] }; Node };
            type B = { struct Node { items: Node[]; value?: uint }; Node };
            fn sum(a: A, b: B) a.items.len + b.items.len;
            return sum(A(items: [ A, A ]), B(items: [ B, B, B ])) - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct Node_ClDc;
struct Node_wziT;

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040000000100000
    int value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_wziT9xRZgu0
                                #define DEF_Node_wziT9xRZgu0
struct Node_wziT
{
                                // shape_hash:    a55e09ec9acffa50
                                // non_triv_mask: 0000104000000000
    fu::vec<Node_wziT> items;
    unsigned value;
    Node_wziT(const Node_wziT&) = default;
    Node_wziT(Node_wziT&&) = default;
    Node_wziT& operator=(Node_wziT&&) = default;
    Node_wziT& operator=(const Node_wziT& selfrec) { return *this = Node_wziT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int sum_MbR9(/*3:3*/ const Node_ClDc& a, /*3:3*/ const Node_wziT& b)
{
    return a.items.size() + b.items.size();
}

int fu_MAIN()
{
    return sum_MbR9(Node_ClDc { {/*unused non-zst*/}, fu::vec<Node_ClDc> {{ Node_ClDc{}, Node_ClDc{} }} }, Node_wziT { fu::vec<Node_wziT> {{ Node_wziT{}, Node_wziT{}, Node_wziT{} }}, {/*unused non-zst*/} }) - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

========

        struct Node { value: int; items: Node[] }
        fn sum_a(n: Node) n.value + n.items.len;

        struct Node { items: Node[]; value: uint }
        fn sum_b(n: Node) n.value.int + n.items.len;

        fn main() _0::sum_a(_0::Node(value: -11, [ _0::Node(), _0::Node() ]))
                + _1::sum_b(_1::Node(value: 0x6, [ _1::Node(), _1::Node(), _1::Node() ]));

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(224) arc_count(2) ] ----
#include <fu/vec.h>

struct Node_ClDc;
struct Node_wziT;
int sum_a_MbR9(const Node_ClDc&);
int sum_b_LtD7(const Node_wziT&);

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040000000100000
    int value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_Node_wziT9xRZgu0
                                #define DEF_Node_wziT9xRZgu0
struct Node_wziT
{
                                // shape_hash:    a55e09ec9acffa50
                                // non_triv_mask: 0000104000000000
    fu::vec<Node_wziT> items;
    unsigned value;
    Node_wziT(const Node_wziT&) = default;
    Node_wziT(Node_wziT&&) = default;
    Node_wziT& operator=(Node_wziT&&) = default;
    Node_wziT& operator=(const Node_wziT& selfrec) { return *this = Node_wziT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return sum_a_MbR9(Node_ClDc { -11, fu::vec<Node_ClDc> {{ Node_ClDc{}, Node_ClDc{} }} }) + sum_b_LtD7(Node_wziT { fu::vec<Node_wziT> {{ Node_wziT{}, Node_wziT{}, Node_wziT{} }}, 0x6u });
}

#endif

int main() { return fu_MAIN(); }
#include <fu/vec.h>

struct Node_ClDc;

                                #ifndef DEF_Node_ClDcVTVSxB1
                                #define DEF_Node_ClDcVTVSxB1
struct Node_ClDc
{
                                // shape_hash:    861f70e100883b21
                                // non_triv_mask: 0040000000100000
    int value;
    fu::vec<Node_ClDc> items;
    Node_ClDc(const Node_ClDc&) = default;
    Node_ClDc(Node_ClDc&&) = default;
    Node_ClDc& operator=(Node_ClDc&&) = default;
    Node_ClDc& operator=(const Node_ClDc& selfrec) { return *this = Node_ClDc(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int sum_a_MbR9(/*1:1*/ const Node_ClDc& n)
{
    return n.value + n.items.size();
}

#endif

// N_TypeRecursion, N_TypeResolve
#include <fu/vec.h>

struct Node_wziT;

                                #ifndef DEF_Node_wziT9xRZgu0
                                #define DEF_Node_wziT9xRZgu0
struct Node_wziT
{
                                // shape_hash:    a55e09ec9acffa50
                                // non_triv_mask: 0000104000000000
    fu::vec<Node_wziT> items;
    unsigned value;
    Node_wziT(const Node_wziT&) = default;
    Node_wziT(Node_wziT&&) = default;
    Node_wziT& operator=(Node_wziT&&) = default;
    Node_wziT& operator=(const Node_wziT& selfrec) { return *this = Node_wziT(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int sum_b_LtD7(/*1:1*/ const Node_wziT& n)
{
    return int(n.value) + n.items.size();
}

#endif

// N_TypeRecursion, N_TypeResolve

========

        pragma emit(`
            void ccIncrX2(int& a, int b) {
                a += b * 2;
            }
        `);

        fn main() {
            mut a = 0;
            pragma emit("ccIncrX2(", a, ", 5);");
            return a - 10;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
void ccIncrX2(int& a, int b) {
    a += b * 2;
}

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    ccIncrX2(a, 5);

    return a - 10;
}

#endif

int main() { return fu_MAIN(); }

========

        pragma emit("// needs newline");
        pragma emit(`
            namespace {
            }
        `);
        fn main() 0;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
// needs newline
namespace {
}

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(with_ints) {
            mut a = 0;
            mut b = 0;
            pragma emit(`
                for (;;) {
                    `b` += `a`++;
                    `with_ints(:a, :b)`;
                }
            `);                                                // GNUStmtExpr
        }

        fn main() {
            mut sum = 0;
            hello: |a, b| if (a + b > 3) return (sum = a + b) - 6;
            return 101;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;

    {
        int a = 0;
        int b = 0;
        for (;;) {
            b += a++;
            (__extension__ (
        {
            const int /*a*/ a_1 = a;
            const int /*b*/ b_1 = b;
            if ((a_1 + b_1) > 3)
                return (sum = (a_1 + b_1)) - 6;

        }));
        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(with_ints) {
            mut a = 0;
            mut b = 0;
            pragma emit(`
                for (;;) {
                    `b` += `a`++;
                    `with_ints(:a, :b)`;
                }
            `);                                                // GNUStmtExpr
        }

        fn main() {
            mut sum = 0;
            hello: |a, b| if ((sum = a + b) > 3) break;
            return sum - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_hello_Okex4mfKoGd
                                #define DEF_hello_Okex4mfKoGd
inline static void hello_Okex(/*3:3*/ int& sum)
{
    int a = 0;
    int b = 0;
    for (;;) {
        b += a++;
        (__extension__ (
    {
        const int /*a*/ a_1 = a;
        const int /*b*/ b_1 = b;
        if ((sum = (a_1 + b_1)) > 3)
            return;

    }));
    };
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    hello_Okex(sum);
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn hello(with_ints) {
            mut a = 0;
            mut b = 0;
            pragma emit(`
                for (;;) {
                    `b` += `a`++;
                    bool brk = `with_ints(:a, :b)`;
                    if (brk) break;
                }
            `);
        }

        fn main() {
            mut sum = 0;
            hello: |a, b| (sum = a + b) > 3;
            return sum - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF___dBZDvM5fMGc
                                #define DEF___dBZDvM5fMGc
inline static bool _dBZD(const int a, const int b, /*7:7*/ int& sum)
{
    return (sum = (a + b)) > 3;
}
                                #endif

                                #ifndef DEF_hello_T4X3I75QWbc
                                #define DEF_hello_T4X3I75QWbc
inline static void hello_T4X3(/*3:3*/ int& sum)
{
    int a = 0;
    int b = 0;
    for (;;) {
        b += a++;
        bool brk = _dBZD(a, b, sum);
        if (brk) break;
    };
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    hello_T4X3(sum);
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

========

        fn desc(a: i32, b: i32) b < a;

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(fn desc);
            return vals[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

static bool desc_MbR9(const int a, const int b)
{
    return b < a;
}

                                #ifndef DEF_sort_ua4VdV7PIPh
                                #define DEF_sort_ua4VdV7PIPh
inline static void sort_ua4V(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = desc_MbR9(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_CpoUckv2r9c
                                #define DEF_sort_CpoUckv2r9c
inline void sort_CpoU(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_ua4V(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> {{ 1, 2 }};
    sort_CpoU(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a: i32, b: i32| b < a);
            return vals[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___z1BxnUTWNPa
                                #define DEF___z1BxnUTWNPa
inline static bool _z1Bx(const int a, const int b)
{
    return b < a;
}
                                #endif

                                #ifndef DEF_sort_JYYtgh2woed
                                #define DEF_sort_JYYtgh2woed
inline static void sort_JYYt(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _z1Bx(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_Ha5GmKrBiie
                                #define DEF_sort_Ha5GmKrBiie
inline void sort_Ha5G(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_JYYt(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> {{ 1, 2 }};
    sort_Ha5G(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a, b| b < a);
            return vals[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___z1BxnUTWNPa
                                #define DEF___z1BxnUTWNPa
inline static bool _z1Bx(const int a, const int b)
{
    return b < a;
}
                                #endif

                                #ifndef DEF_sort_JYYtgh2woed
                                #define DEF_sort_JYYtgh2woed
inline static void sort_JYYt(/*1:1*/ fu::vec_range_mut<int> a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _z1Bx(l, r);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_Ha5GmKrBiie
                                #define DEF_sort_Ha5GmKrBiie
inline void sort_Ha5G(/*3:3*/ fu::vec_range_mut<int> a)
{
    sort_JYYt(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> {{ 1, 2 }};
    sort_Ha5G(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref vals: i32[], xor: i32)
            vals.sort(
                |a: i32, b: i32|
                    a^xor < b^xor);

        fn main() {
            mut vals = [ 1, 2 ];
            vals.test(xor: 3); // xor:3 descs 1 and 2.
            return vals[0] - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <algorithm>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___KdEIcIzAfnf
                                #define DEF___KdEIcIzAfnf
inline static bool _KdEI(const int a, const int b, /*7:7*/ const int xOr)
{
    return (a ^ xOr) < (b ^ xOr);
}
                                #endif

                                #ifndef DEF_sort_bNzV11BqKkl
                                #define DEF_sort_bNzV11BqKkl
inline static void sort_bNzV(/*3:1*/ fu::vec_range_mut<int> a, /*3:3*/ const int xOr)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _KdEI(l, r, xOr);
    return lt;
            });

}
                                #endif

                                #ifndef DEF_sort_V6JaJxt4gRl
                                #define DEF_sort_V6JaJxt4gRl
inline void sort_V6Ja(/*7:3*/ fu::vec_range_mut<int> a, /*7:7*/ const int xOr)
{
    sort_bNzV(a, xOr);
}
                                #endif

static void test_MbR9(/*3:3*/ fu::vec_range_mut<int> vals, const int xOr)
{
    sort_V6Ja(vals, xOr);
}

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> {{ 1, 2 }};
    test_MbR9(vals, 3);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];

            arr.par::each: |ref it| it *= 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----

========

        fn seq__each(ref a: $T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];
            mut sum = 0;


            arr.par::each: |ref it| 
                sum += it *= 2;                                 // PointlessMustSeq

            return sum - 2 - 4 - 6 - 8;
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:12+4[0m [2m8:17+3[0m:

[2m      |                 fn(a[i]);[0m
[2m      | [0m
[2m    6 | [0m        fn [31;1mmain[0m() {
[2m    7 | [0m            mut arr = [ 1, 2, 3, 4 ];
[2m    8 | [0m            mut [31;1msum[0m = 0;
[2m      | [0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m is not purectx, writes to [35;3minjected implicit mut ref arg[0m [94;1mmain:sum[0m:

            via [35;3mfn[0m [94;1mparallel_for[0m at [2m../lib/[0mpar[2m.fu 3:5+12[0m:

[2m      | [0m
[2m      | pub purectx fn each(ref arr: $T[..], visit, min!?: int)[0m
[2m    3 | [0m    [31;1mparallel_for[0m(:min, end: arr.len): |i|
[2m      |         visit(arr[i], i?: i);[0m
[2m      | [0m

            via [35;3mfn[0m [94;1m_[0m at [2m../lib/[0mpar[2m.fu 49:9+5[0m:

[2m      |         // And this magically still looks like a loop -[0m
[2m      |         //  no linear / affine nonsense etc.[0m
[2m   49 | [0m        [31;1mvisit[0m(i);
[2m      |     }[0m
[2m      | [0m

            via [35;3mfn[0m [94;1m_[0m at [2m../lib/[0mpar[2m.fu 4:9+5[0m:

[2m      | pub purectx fn each(ref arr: $T[..], visit, min!?: int)[0m
[2m      |     parallel_for(:min, end: arr.len): |i|[0m
[2m    4 | [0m        [31;1mvisit[0m(arr[i], i?: i);
[2m      | [0m
[2m      | pub purectx fn zip(ref arr: $T[..], ref barr: $U[..], visit, min!?: int)[0m

            via [35;3m__native[0m [94;1m+=[0m at [2m12:21+2[0m:

[2m      | [0m
[2m      |             arr.par::each: |ref it| [0m
[2m   12 | [0m                sum [31;1m+=[0m it *= 2;                                 // PointlessMustSeq
[2m      | [0m
[2m      |             return sum - 2 - 4 - 6 - 8;[0m


       RelaxMut [35;3mfn[0m [94;1meach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@130[0m, [35;3mi32[0m) at [2m../lib/[0mpar[2m.fu 2:16+4[0m
        Solving [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        fn seq__each(ref a: $T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];
            mut sum = 0;


            arr.seq__each: |ref it| 
                sum += it *= 2;                                 // PointlessMustSeq

            return sum - 2 - 4 - 6 - 8;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___FhdSPjNle1a
                                #define DEF___FhdSPjNle1a
inline static int _FhdS(/*3:1*/ int& it, /*3:3*/ int& sum)
{
    return (sum += (it *= 2));
}
                                #endif

                                #ifndef DEF_seq__each_RrhohOOEbza
                                #define DEF_seq__each_RrhohOOEbza
inline static void seq__each_Rrho(/*7:3*/ fu::view_mut<int> a, /*6:6*/ int& sum)
{
    for (int i = 0; i < a.size(); i++)
        _FhdS(a.mutref(i), sum);

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3, 4 }};
    int sum = 0;
    seq__each_Rrho(arr, sum);
    return (((sum - 2) - 4) - 6) - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARMustSeq

========

        fn seq__each(ref a: $T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];


            arr.par::each: |ref it| 
                if ((it *= 2) > 4)
                    break;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;
        }

---- <fail> ----
[2m../lib/[0mpar[2m.fu 26:7+6[0m:

[2m      | //   without function types with noflow & purectx assertions.[0m
[2m      | [0m
[2m   26 | [0mnovec [31;1mnoflow[0m nothrow fn parallel_for(min!, mut end!, visit)
[2m      | {[0m
[2m      |     mut start = end & 0;[0m

	[35;3mfn[0m [94;1mparallel_for[0m is not noflow: contains non-local control flow, jumping out to [35;3mfn[0m [94;1meach[0m.

        Solving [35;3mfn[0m [94;1meach[0m([35;3mi32[0m[35;3m[..][0m, [35;3m@130[0m, [35;3mi32[0m) at [2m../lib/[0mpar[2m.fu 2:16+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m6:12+4[0m

========

        fn seq__each(ref a: $T[..], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];


            arr.seq__each: |ref it| 
                if ((it *= 2) > 4)
                    break;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(112) arc_count(1) ] ----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_seq__each_2TlEiXTJsFk
                                #define DEF_seq__each_2TlEiXTJsFk
inline static void seq__each_2TlE(/*3:3*/ fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        int& /*a|static*/ it = a.mutref(i);
        if ((it *= 2) > 4)
            return;

    };
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> {{ 1, 2, 3, 4 }};
    seq__each_2TlE(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return (((sum - 2) - 4) - 6) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn test(ref arr: i32[])
            arr.par::each: |ref v, i| v += i;

        fn main() {
            let N = 1087 * 1091;

            mut orig: i32[];
            orig.resize(N);

            mut arr = orig;
            arr.test();

            if (arr.len != N || arr.len != orig.len)
                return 1;

            for (mut i = 0; i < N; i++)
                if (orig[i] != 0)
                    return 2;

            for (mut i = 0; i < N; i++)
                if (arr[i] != i)
                    return 3;

            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(16777184) arc_count(2) ] ----

========

        fn main() {
            let i: i8 = 0;

            return i;        
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:13+6[0m:

[2m      |             let i: i8 = 0;[0m
[2m      | [0m
[2m    5 | [0m            [31;1mreturn[0m i;        
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mi8[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            let i: i8 = 0;

            return i.i32;    
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 i = fu::i8(0);
    return int(i);
}

#endif

int main() { return fu_MAIN(); }

========

        primitive s32: i32;

        fn main() {
            let i: s32 = 0;

            return i;        
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:13+6[0m:

[2m      |             let i: s32 = 0;[0m
[2m      | [0m
[2m    7 | [0m            [31;1mreturn[0m i;        
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3mprimitive[0m [94;1ms32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        primitive s32: i32;

        fn main() {
            let i: s32 = 0;

            return i.i32;    
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int s32_O9oR;

                                #ifndef DEF_s32_O9oR
                                #define DEF_s32_O9oR
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s32_O9oR i = 0;
    return int(i);
}

#endif

int main() { return fu_MAIN(); }

========

        enum Enum { None = 0 };

        fn main() {
            let e = Enum.None;

            return e;        
        }

---- <fail> ----
[2m[0m_0[2m.fu 7:13+6[0m:

[2m      |             let e = Enum.None;[0m
[2m      | [0m
[2m    7 | [0m            [31;1mreturn[0m e;        
[2m      |         }[0m
[2m      | [0m

	[35;3mfn[0m [94;1mmain[0m: return type does not match annotation: expects [35;3mi32[0m, got [35;3menum[0m [94;1mEnum[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m4:12+4[0m

========

        enum Enum { None = 0 };

        fn main() {
            let e = Enum.None;

            return e.i32;    
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Enum_po89: fu::u8;

                                #ifndef DEF_Enum_po89
                                #define DEF_Enum_po89
enum Enum_po89: fu::u8
{
    Enum_po89_None = 0u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Enum_po89 e = Enum_po89_None;
    return int(e);
}

#endif

int main() { return fu_MAIN(); }

========

        using enum Test { A = 5; B; C };
        fn main()

            C - 7;      

---- <fail> ----
[2m[0m_0[2m.fu 5:15+1[0m:

[2m      |         fn main()[0m
[2m      | [0m
[2m    5 | [0m            C [31;1m-[0m 7;      
[2m      | [0m

	Bad call to [94;1m-[0m with args ([35;3menum[0m [94;1mTest[0m, [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m-[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mTest[0m <-> [35;3mi32[0m

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        using enum Test { A = 5; B; C };
        fn main()

            C - 7;      

---- <fail> ----
[2m[0m_0[2m.fu 5:15+1[0m:

[2m      |         fn main()[0m
[2m      | [0m
[2m    5 | [0m            C [31;1m-[0m 7;      
[2m      | [0m

	Bad call to [94;1m-[0m with args ([35;3menum[0m [94;1mTest[0m, [35;3malways-true[0m [35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    [35;3marg[0m [94;1m-[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mTest[0m <-> [35;3mi32[0m

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m3:12+4[0m

========

        using enum Test { A = 5; B; C };
        fn main()

            C.i32 - 7;  

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Test_5zg1: fu::u8;

                                #ifndef DEF_Test_5zg1
                                #define DEF_Test_5zg1
enum Test_5zg1: fu::u8
{
    Test_5zg1_A = 5u,
    Test_5zg1_B = 6u,
    Test_5zg1_C = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(Test_5zg1_C) - 7;
}

#endif

int main() { return fu_MAIN(); }

========

        using

        enum       Test: i32 { A1; A2; M5 = 5; A6 };

        fn main()
            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000
                == 6521 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
enum Test_Tlo8: int;

                                #ifndef DEF_Test_Tlo8
                                #define DEF_Test_Tlo8
enum Test_Tlo8: int
{
    Test_Tlo8_A1 = 1,
    Test_Tlo8_A2 = 2,
    Test_Tlo8_M5 = 5,
    Test_Tlo8_A6 = 6,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if ((((int(Test_Tlo8_A1) + (int(Test_Tlo8_A2) * 10)) + (int(Test_Tlo8_M5) * 100)) + (int(Test_Tlo8_A6) * 1000)) == 6521)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using

        primitive  Test: i32 { A1; A2; M5 = 5; A6 };

        fn main()
            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000
                == 6521 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int Test_Tlo8;

                                #ifndef DEF_Test_Tlo8
                                #define DEF_Test_Tlo8
inline constexpr Test_Tlo8 Test_Tlo8_A1 = 1;
inline constexpr Test_Tlo8 Test_Tlo8_A2 = 2;
inline constexpr Test_Tlo8 Test_Tlo8_M5 = 5;
inline constexpr Test_Tlo8 Test_Tlo8_A6 = 6;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if ((((int(Test_Tlo8_A1) + (int(Test_Tlo8_A2) * 10)) + (int(Test_Tlo8_M5) * 100)) + (int(Test_Tlo8_A6) * 1000)) == 6521)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using

        enum          Test: i32 { A; B };
        fn main() (B - A).i32 - 1;

---- <fail> ----
[2m[0m_0[2m.fu 5:22+1[0m:

[2m      | [0m
[2m      |         enum          Test: i32 { A; B };[0m
[2m    5 | [0m        fn main() (B [31;1m-[0m A).i32 - 1;
[2m      | [0m

	Bad call to [94;1m-[0m with args ([35;3menum[0m [94;1mTest[0m, [35;3menum[0m [94;1mTest[0m): 

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m (a: <T>, b: T) case (T.is::arithmetic): T __native;

	    No body pattern matched.

	[35;3mtemplate[0m [94;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m (a: <T>) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        using

        primitive     Test: i32 { A; B };
        fn main() (B - A).i32 - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int Test_Tlo8;

                                #ifndef DEF_Test_Tlo8
                                #define DEF_Test_Tlo8
inline constexpr Test_Tlo8 Test_Tlo8_A = 1;
inline constexpr Test_Tlo8 Test_Tlo8_B = 2;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((Test_Tlo8_B - Test_Tlo8_A)) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        enum EnumA: i32;
        enum EnumB: EnumA { Zero = 0 };
        fn main() EnumB.Zero.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
enum EnumB_e9Ox: int;

                                #ifndef DEF_EnumB_e9Ox
                                #define DEF_EnumB_e9Ox
enum EnumB_e9Ox: int
{
    EnumB_e9Ox_Zero = 0,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(EnumB_e9Ox_Zero);
}

#endif

int main() { return fu_MAIN(); }

========

        primitive PrimA: i32;
        using primitive PrimB: PrimA { Zero = 0; One };
        fn main() (One - 1).i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int PrimB_Hqfd;

                                #ifndef DEF_PrimB_Hqfd
                                #define DEF_PrimB_Hqfd
inline constexpr PrimB_Hqfd PrimB_Hqfd_Zero = 0;
inline constexpr PrimB_Hqfd PrimB_Hqfd_One = 1;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((PrimB_Hqfd_One - 1));
}

#endif

int main() { return fu_MAIN(); }

========

        primitive PrimA: i32;
        primitive PrimB: PrimA { Zero = 0; One };


        fn and_decr(ref prim: PrimB)
        {
            mut res = prim - 1;
            prim &&= res;
            return prim;
        }


        fn main() {
            mut r = PrimB.One;
            return r.and_decr.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int PrimB_Hqfd;

                                #ifndef DEF_PrimB_Hqfd
                                #define DEF_PrimB_Hqfd
inline constexpr PrimB_Hqfd PrimB_Hqfd_Zero = 0;
inline constexpr PrimB_Hqfd PrimB_Hqfd_One = 1;
                                #endif

#ifndef fu_NO_fdefs

static PrimB_Hqfd and_decr_kGbb(/*1:1*/ PrimB_Hqfd& prim)
{
    const PrimB_Hqfd res = (prim - 1);
    if (prim)
        prim = res;

    return prim;
}

int fu_MAIN()
{
    PrimB_Hqfd r = PrimB_Hqfd_One;
    return int(and_decr_kGbb(r));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        primitive PrimA: i32;
        primitive PrimB: PrimA { Zero = 0; One };


        fn and_decr(ref prim: PrimB)
            prim &&= prim - 1;


        fn main() {
            mut r = PrimB.One;
            return r.and_decr.i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int PrimB_Hqfd;

                                #ifndef DEF_PrimB_Hqfd
                                #define DEF_PrimB_Hqfd
inline constexpr PrimB_Hqfd PrimB_Hqfd_Zero = 0;
inline constexpr PrimB_Hqfd PrimB_Hqfd_One = 1;
                                #endif

#ifndef fu_NO_fdefs

static PrimB_Hqfd and_decr_kGbb(/*1:1*/ PrimB_Hqfd& prim)
{
    return !prim ? prim : (prim = (prim - 1));
}

int fu_MAIN()
{
    PrimB_Hqfd r = PrimB_Hqfd_One;
    return int(and_decr_kGbb(r));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        enum Hey { foo; };
        fn test(hey: Hey) hey.i32;
        fn main() test("foo") - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Hey_tbs3: fu::u8;

                                #ifndef DEF_Hey_tbs3
                                #define DEF_Hey_tbs3
enum Hey_tbs3: fu::u8
{
    Hey_tbs3_foo = 1u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_MbR9(const Hey_tbs3 hey)
{
    return int(hey);
}

int fu_MAIN()
{
    return test_MbR9(Hey_tbs3_foo) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        using enum Greet { hello; world };
        fn main()
            hello ~ " " ~ world == "hello world"                // DuplicateFunctions
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

enum Greet_w2E4: fu::u8;

                                #ifndef DEF_Greet_w2E4
                                #define DEF_Greet_w2E4
enum Greet_w2E4: fu::u8
{
    Greet_w2E4_hello = 1u,
    Greet_w2E4_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_str_pXMrwgVndkb
                                #define DEF_str_pXMrwgVndkb
inline fu::str str_pXMr(const Greet_w2E4 n)
{
    if (n == Greet_w2E4_hello)
        return fu::str("hello"_fu);
    else if (n == Greet_w2E4_world)
        return fu::str("world"_fu);

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (x7E_rA00(x7E_rA00(str_pXMr(Greet_w2E4_hello), " "_view), str_pXMr(Greet_w2E4_world)) == "hello world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum Greet { hello; world };
        fn woot(hi: Greet) hi == "hello";
        fn main() Greet.hello.woot ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Greet_w2E4: fu::u8;

                                #ifndef DEF_Greet_w2E4
                                #define DEF_Greet_w2E4
enum Greet_w2E4: fu::u8
{
    Greet_w2E4_hello = 1u,
    Greet_w2E4_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool woot_MbR9(const Greet_w2E4 hi)
{
    return hi == Greet_w2E4_hello;
}

int fu_MAIN()
{
    if (woot_MbR9(Greet_w2E4_hello))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using enum Greet { hello; world };
        fn h() Greet.hello;
        fn w() Greet.world;

        fn main()
            _0::h() ~ " " ~ _0::w() == "hello world"            // DuplicateFunctions
                ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

enum Greet_w2E4: fu::u8;
Greet_w2E4 h_MbR9();
Greet_w2E4 w_MbR9();

                                #ifndef DEF_Greet_w2E4
                                #define DEF_Greet_w2E4
enum Greet_w2E4: fu::u8
{
    Greet_w2E4_hello = 1u,
    Greet_w2E4_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_str_pXMrwgVndkb
                                #define DEF_str_pXMrwgVndkb
inline fu::str str_pXMr(const Greet_w2E4 n)
{
    if (n == Greet_w2E4_hello)
        return fu::str("hello"_fu);
    else if (n == Greet_w2E4_world)
        return fu::str("world"_fu);

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_rA003L6Quul
                                #define DEF_x7E_rA003L6Quul
inline fu::str x7E_rA00(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (x7E_rA00(x7E_rA00(str_pXMr(h_MbR9()), " "_view), str_pXMr(w_MbR9())) == "hello world"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }
#include <fu/int.h>

enum Greet_w2E4: fu::u8;

                                #ifndef DEF_Greet_w2E4
                                #define DEF_Greet_w2E4
enum Greet_w2E4: fu::u8
{
    Greet_w2E4_hello = 1u,
    Greet_w2E4_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

Greet_w2E4 h_MbR9()
{
    return Greet_w2E4_hello;
}

Greet_w2E4 w_MbR9()
{
    return Greet_w2E4_world;
}

#endif

========

        using enum _0 { A; B };

        fn test(x: ::_0) x.i32;
        fn main() "A".test - _0::A.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum _0_oA8l: fu::u8;

                                #ifndef DEF__0_oA8l
                                #define DEF__0_oA8l
enum _0_oA8l: fu::u8
{
    _0_oA8l_A = 1u,
    _0_oA8l_B = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_LtD7(const _0_oA8l x)
{
    return int(x);
}

int fu_MAIN()
{
    return test_LtD7(_0_oA8l_A) - int(_0_oA8l_A);
}

#endif

int main() { return fu_MAIN(); }

========

        enum _0 { A; B };

        fn test(x: ::_0 = "B") x.i32;
        fn main() test - ::_0.B.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum _0_oA8l: fu::u8;

                                #ifndef DEF__0_oA8l
                                #define DEF__0_oA8l
enum _0_oA8l: fu::u8
{
    _0_oA8l_A = 1u,
    _0_oA8l_B = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_LtD7(const _0_oA8l x)
{
    return int(x);
}

int fu_MAIN()
{
    return test_LtD7(_0_oA8l_B) - int(_0_oA8l_B);
}

#endif

int main() { return fu_MAIN(); }

========

        enum Enum { A = 0; B };
        fn inner(x: Enum) x.i32;
        fn outer(x: i32) inner(x & 1 ? "B" : "A");
        fn main() outer(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Enum_po89: fu::u8;

                                #ifndef DEF_Enum_po89
                                #define DEF_Enum_po89
enum Enum_po89: fu::u8
{
    Enum_po89_A = 0u,
    Enum_po89_B = 1u,
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_MbR9(const Enum_po89 x)
{
    return int(x);
}

static int outer_MbR9(const int x)
{
    return inner_MbR9(((x & 1) ? Enum_po89_B : Enum_po89_A));
}

int fu_MAIN()
{
    return outer_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

========

        using flags Flags { A; B; C; D };

        fn main() {
            mut flags = A | C;
            return flags.i32 == 5 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Flags_Qpfn;

                                #ifndef DEF_Flags_Qpfn
                                #define DEF_Flags_Qpfn
inline constexpr Flags_Qpfn Flags_Qpfn_A = Flags_Qpfn(1u);
inline constexpr Flags_Qpfn Flags_Qpfn_B = Flags_Qpfn(2u);
inline constexpr Flags_Qpfn Flags_Qpfn_C = Flags_Qpfn(4u);
inline constexpr Flags_Qpfn Flags_Qpfn_D = Flags_Qpfn(8u);

inline constexpr Flags_Qpfn MASK_Flags_Qpfn
    = Flags_Qpfn_A
    | Flags_Qpfn_B
    | Flags_Qpfn_C
    | Flags_Qpfn_D;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Flags_Qpfn flags = Flags_Qpfn((Flags_Qpfn_A | Flags_Qpfn_C));
    if (int(flags) == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        flags Flags: i32 { A; B };

        fn main() {
            mut hello = 5;
            mut world = hello.Flags;
            return world.i32 - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef int Flags_XBfK;

                                #ifndef DEF_Flags_XBfK
                                #define DEF_Flags_XBfK
inline constexpr Flags_XBfK Flags_XBfK_A = 1;
inline constexpr Flags_XBfK Flags_XBfK_B = 2;

inline constexpr Flags_XBfK MASK_Flags_XBfK
    = Flags_XBfK_A
    | Flags_XBfK_B;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int hello = 5;
    const Flags_XBfK world = Flags_XBfK((hello) & MASK_Flags_XBfK);
    return int(world) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        using flags Hey: u8 { A; B };
        fn main() {
            mut flags = A | B;
            flags &= ~B;
            return flags.i32 - 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

typedef fu::u8 Hey_tbs3;

                                #ifndef DEF_Hey_tbs3
                                #define DEF_Hey_tbs3
inline constexpr Hey_tbs3 Hey_tbs3_A = Hey_tbs3(1u);
inline constexpr Hey_tbs3 Hey_tbs3_B = Hey_tbs3(2u);

inline constexpr Hey_tbs3 MASK_Hey_tbs3
    = Hey_tbs3_A
    | Hey_tbs3_B;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    Hey_tbs3 flags = Hey_tbs3((Hey_tbs3_A | Hey_tbs3_B));
    flags &= Hey_tbs3(~Hey_tbs3_B);
    return int(flags) - 1;
}

#endif

int main() { return fu_MAIN(); }

========

        enum thing { i32; int; bool }

        // So the problem is the retval annotation for fn ==(template): bool
        //  fails to resolve as it conflicts with enumv from thing here.
        //
        // I'm not terribly sure what we want to do about it,
        //  it's the ambiguity thing again - template sees the enum on expansion,
        //   so it does kinda make sense for thing not to compile,
        //    otherwise imagine the original bool goes away,
        //     it'd fallback to the enumv here, which is exactly not what we want.
        //
        // Perhaps the scoping rules for templates don't make so much sense,
        //  if we didn't make everything from local scope visible
        //   they'll also compile faster.
        //
        fn isInt (k: thing) k == "i32" || k == "int";
        fn isBool(k: thing) k == "bool";
        fn main() isInt("i32") && isBool("bool") ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum thing_qSDg: fu::u8;

                                #ifndef DEF_thing_qSDg
                                #define DEF_thing_qSDg
enum thing_qSDg: fu::u8
{
    thing_qSDg_i32 = 1u,
    thing_qSDg_int = 2u,
    thing_qSDg_bool = 3u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool isInt_MbR9(const thing_qSDg k)
{
    return (k == thing_qSDg_i32) || (k == thing_qSDg_int);
}

static bool isBool_MbR9(const thing_qSDg k)
{
    return k == thing_qSDg_bool;
}

int fu_MAIN()
{
    if (isInt_MbR9(thing_qSDg_i32) && isBool_MbR9(thing_qSDg_bool))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum ID: u64 {
            // clang warned with -Wimplicitly-unsigned-literal
            CustomIDs = 0x8000_0000_0000_0000;
            BitmapFontAtlas;
        };

        fn main() {
            mut id: u64 = ID.BitmapFontAtlas.u64;
            // meawhile this outputted the underscores
            return id == 0x8000_0000_0000_0001 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>

enum ID_PBJH: uint64_t;

                                #ifndef DEF_ID_PBJH
                                #define DEF_ID_PBJH
enum ID_PBJH: uint64_t
{
    ID_PBJH_CustomIDs = 0x8000000000000000ull,
    ID_PBJH_BitmapFontAtlas = 9223372036854775809ull,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint64_t id = uint64_t(ID_PBJH_BitmapFontAtlas);
    if (id == 0x8000000000000001ull)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        using enum ID: u32 {
            SecondLast = 0xffff_fffe;
            Last;

            NoRoom; 
        };

        fn main() {
            return Last.u32 == 0xffff_ffff ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 2:15+4[0m:

[2m      | [0m
[2m    2 | [0m        using [31;1menum[0m ID: u32 {
[2m      |             SecondLast = 0xffff_fffe;[0m
[2m      |             Last;[0m

	Primitive range exhausted: requires 64 bits, got 32.

        Solving [35;3mtype[0m [94;1mID[0m

========

        using enum ID: u32 {
            SecondLast = 0xffff_fffe;
            Last;

        };

        fn main() {
            return Last.u32 == 0xffff_ffff ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
enum ID_8Es0: unsigned;

                                #ifndef DEF_ID_8Es0
                                #define DEF_ID_8Es0
enum ID_8Es0: unsigned
{
    ID_8Es0_SecondLast = 0xfffffffeu,
    ID_8Es0_Last = 4294967295u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (unsigned(ID_8Es0_Last) == 0xffffffffu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum ID: u64 {
            SecondLast = 0xffff_ffff_ffff_fffe;
            Last;

            NoRoom; 
        };

        fn main() {
            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 2:9+4[0m:

[2m      | [0m
[2m    2 | [0m        [31;1menum[0m ID: u64 {
[2m      |             SecondLast = 0xffff_ffff_ffff_fffe;[0m
[2m      |             Last;[0m

	Failed to auto-increment, range exhausted.

        Solving [35;3mtype[0m [94;1mID[0m

========

        enum ID: u64 {
            SecondLast = 0xffff_ffff_ffff_fffe;
            Last;

        };

        fn main() {
            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>

enum ID_PBJH: uint64_t;

                                #ifndef DEF_ID_PBJH
                                #define DEF_ID_PBJH
enum ID_PBJH: uint64_t
{
    ID_PBJH_SecondLast = 0xfffffffffffffffeull,
    ID_PBJH_Last = 18446744073709551615ull,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (uint64_t(ID_PBJH_Last) == 0xffffffffffffffffull)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

        fn main() = _0::ID.A.offset(
            _0::IDOffset.B) - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum ID_6nYM: fu::u8;
enum IDOffset_i8zK: fu::u8;
int offset_MbR9(ID_6nYM, IDOffset_i8zK);

                                #ifndef DEF_ID_6nYM
                                #define DEF_ID_6nYM
enum ID_6nYM: fu::u8
{
    ID_6nYM_A = 1u,
};
                                #endif

                                #ifndef DEF_IDOffset_i8zK
                                #define DEF_IDOffset_i8zK
enum IDOffset_i8zK: fu::u8
{
    IDOffset_i8zK_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return offset_MbR9(ID_6nYM_A, IDOffset_i8zK_B) - 11;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/int.h>

enum ID_6nYM: fu::u8;
enum IDOffset_i8zK: fu::u8;

                                #ifndef DEF_ID_6nYM
                                #define DEF_ID_6nYM
enum ID_6nYM: fu::u8
{
    ID_6nYM_A = 1u,
};
                                #endif

                                #ifndef DEF_IDOffset_i8zK
                                #define DEF_IDOffset_i8zK
enum IDOffset_i8zK: fu::u8
{
    IDOffset_i8zK_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int offset_MbR9(const ID_6nYM a, const IDOffset_i8zK b)
{
    return int(a) + int(b);
}

#endif

========

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

        fn main() = _0::ID.A.offset(
            _0::B) - 11;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum ID_6nYM: fu::u8;
enum IDOffset_i8zK: fu::u8;
int offset_MbR9(ID_6nYM, IDOffset_i8zK);

                                #ifndef DEF_ID_6nYM
                                #define DEF_ID_6nYM
enum ID_6nYM: fu::u8
{
    ID_6nYM_A = 1u,
};
                                #endif

                                #ifndef DEF_IDOffset_i8zK
                                #define DEF_IDOffset_i8zK
enum IDOffset_i8zK: fu::u8
{
    IDOffset_i8zK_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return offset_MbR9(ID_6nYM_A, IDOffset_i8zK_B) - 11;
}

#endif

int main() { return fu_MAIN(); }
#include <fu/int.h>

enum ID_6nYM: fu::u8;
enum IDOffset_i8zK: fu::u8;

                                #ifndef DEF_ID_6nYM
                                #define DEF_ID_6nYM
enum ID_6nYM: fu::u8
{
    ID_6nYM_A = 1u,
};
                                #endif

                                #ifndef DEF_IDOffset_i8zK
                                #define DEF_IDOffset_i8zK
enum IDOffset_i8zK: fu::u8
{
    IDOffset_i8zK_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int offset_MbR9(const ID_6nYM a, const IDOffset_i8zK b)
{
    return int(a) + int(b);
}

#endif

========

        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     
            x == "b";       

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 6:15+2[0m:

[2m      |         fn isAorB(x: ABC)[0m
[2m      |             x == "A" ||     [0m
[2m    6 | [0m            x [31;1m==[0m "b";       
[2m      | [0m
[2m      |         fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;[0m

	Bad call to [94;1m==[0m with args ([35;3menum[0m [94;1mABC[0m, [35;3mstring[0m): 

	[35;3mtemplate[0m [94;1m==[0m at [2m../../../../../[0mprelude[2m 829:10+2[0m:
[2m  829 | [0minfix fn [31;1m==[0m (a: <T>, b: T)

	    [35;3marg[0m [94;1m==[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mABC[0m <-> [35;3mstring[0m

        Solving [35;3mfn[0m [94;1misAorB[0m([94;1mABC[0m) at [2m4:12+6[0m

========

        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     
            x == "b";       

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;

---- <fail> ----
[2m[0m_0[2m.fu 6:15+2[0m:

[2m      |         fn isAorB(x: ABC)[0m
[2m      |             x == "A" ||     [0m
[2m    6 | [0m            x [31;1m==[0m "b";       
[2m      | [0m
[2m      |         fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;[0m

	Bad call to [94;1m==[0m with args ([35;3menum[0m [94;1mABC[0m, [35;3malways-true[0m [35;3mstring[0m): 

	[35;3mtemplate[0m [94;1m==[0m at [2m../../../../../[0mprelude[2m 829:10+2[0m:
[2m  829 | [0minfix fn [31;1m==[0m (a: <T>, b: T)

	    [35;3marg[0m [94;1m==[0m:[94;1mb[0m:
	    Incompatible types for [31;1mT[0m: [35;3menum[0m [94;1mABC[0m <-> [35;3mstring[0m

        Solving [35;3mfn[0m [94;1misAorB[0m([94;1mABC[0m) at [2m4:12+6[0m

========

        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     
            x == "B";       

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum ABC_UWCt: fu::u8;

                                #ifndef DEF_ABC_UWCt
                                #define DEF_ABC_UWCt
enum ABC_UWCt: fu::u8
{
    ABC_UWCt_A = 1u,
    ABC_UWCt_B = 2u,
    ABC_UWCt_C = 3u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool isAorB_MbR9(const ABC_UWCt x)
{
    return (x == ABC_UWCt_A) || (x == ABC_UWCt_B);
}

int fu_MAIN()
{
    if (isAorB_MbR9(ABC_UWCt_A) && isAorB_MbR9(ABC_UWCt_B) && !isAorB_MbR9(ABC_UWCt_C))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========


        enum Hello { str; b };


        fn main() {
            mut out = "str";
            return (out ~ "b").len - 4;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ out = "str"_view;
    return (out + "b"_view).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

========


        enum Hello { str; b };

        pub import _0;
        fn main() {
            mut out = "str";
            return (out ~ "b").len - 4;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ out = "str"_view;
    return (out + "b"_view).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

========


        using 
        enum Hello { str; b };


        fn main() {
            mut out = "str";
            return (out ~ "b").len - 4;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ out = "str"_view;
    return (out + "b"_view).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

========


        using 
        enum Hello { str; b };

        pub import _0;
        fn main() {
            mut out = "str";
            return (out ~ "b").len - 4;
        };

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::view<char> /*static*/ out = "str"_view;
    return (out + "b"_view).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

========

        enum world { world; };
        fn type_vs_value(type X) = "NO!";
        fn type_vs_value(str: string) = str ~ "!";
        fn hello(.type_vs_value) = "Hello " ~ type_vs_value;
        fn main() = hello("world") == "Hello world!" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str type_vs_value_MbR9(/*1:1*/ fu::view<char> str)
{
    return str + "!"_view;
}

                                #ifndef DEF_hello_faRytPz1N0l
                                #define DEF_hello_faRytPz1N0l
inline static fu::str hello_faRy(/*1:1*/ fu::view<char> type_vs_value)
{
    return "Hello "_view + type_vs_value;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (hello_faRy(type_vs_value_MbR9("world"_view)) == "Hello world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum world { world; };
        fn world(str: string) = str ~ "!";
        fn hello(.world) = "Hello " ~ world;
        fn main() = hello("world") == "Hello world!" ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str world_MbR9(/*1:1*/ fu::view<char> str)
{
    return str + "!"_view;
}

                                #ifndef DEF_hello_faRytPz1N0l
                                #define DEF_hello_faRytPz1N0l
inline static fu::str hello_faRy(/*1:1*/ fu::view<char> world)
{
    return "Hello "_view + world;
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

int fu_MAIN()
{
    if (hello_faRy(world_MbR9("world"_view)) == "Hello world!"_view)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum Kind { None; A };

        enum Kind { None; B };

        fn main() _0::Kind.A.i32 - _1::Kind.B.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum Kind_okcz: fu::u8;
enum Kind_jzbq: fu::u8;

                                #ifndef DEF_Kind_okcz
                                #define DEF_Kind_okcz
enum Kind_okcz: fu::u8
{
    Kind_okcz_None = 1u,
    Kind_okcz_A = 2u,
};
                                #endif

                                #ifndef DEF_Kind_jzbq
                                #define DEF_Kind_jzbq
enum Kind_jzbq: fu::u8
{
    Kind_jzbq_None = 1u,
    Kind_jzbq_B = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(Kind_okcz_A) - int(Kind_jzbq_B);
}

#endif

int main() { return fu_MAIN(); }

========

        using primitive Distance: f32 {
            Meter       = 1
            Kilometer   = 1000
        };

        fn main() Kilometer / Meter == Kilometer ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
typedef float Distance_fIcs;

                                #ifndef DEF_Distance_fIcs
                                #define DEF_Distance_fIcs
inline constexpr Distance_fIcs Distance_fIcs_Meter = 1.0f;
inline constexpr Distance_fIcs Distance_fIcs_Kilometer = 1000.0f;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if ((Distance_fIcs_Kilometer / Distance_fIcs_Meter) == Distance_fIcs_Kilometer)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        primitive LogicalIndent: u16 { Max = 0xffff };

        noinline fn test(ref li: LogicalIndent) {
            let prev = li;
            li = "Max";
            return prev < "Max";
        }

        fn main() {
            mut li: LogicalIndent;
            let a = test(li);
            let b = test(li);
            return a || !b ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <cstdint>

typedef uint16_t LogicalIndent_XtFB;

                                #ifndef DEF_LogicalIndent_XtFB
                                #define DEF_LogicalIndent_XtFB
inline constexpr LogicalIndent_XtFB LogicalIndent_XtFB_Max = LogicalIndent_XtFB(0xffffu);
                                #endif

#ifndef fu_NO_fdefs

static bool test_MbR9(/*1:1*/ LogicalIndent_XtFB& li)
{
    const LogicalIndent_XtFB /*li*/ prev = li;
    li = LogicalIndent_XtFB_Max;
    return prev < LogicalIndent_XtFB_Max;
}

int fu_MAIN()
{
    LogicalIndent_XtFB li {};
    const bool a = test_MbR9(li);
    const bool b = test_MbR9(li);
    if (a || !b)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        enum RunMode { None = 0; Normally; EnsureExecutableButDontRun }

        fn build(runmode: RunMode) runmode.i32;
        fn build(runmode: RunMode, bootstrap: bool)
            build(runmode: bootstrap
                ? runmode
                : runmode && "EnsureExecutableButDontRun");

        fn main() build("Normally", false) - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/int.h>

enum RunMode_KUve: fu::u8;

                                #ifndef DEF_RunMode_KUve
                                #define DEF_RunMode_KUve
enum RunMode_KUve: fu::u8
{
    RunMode_KUve_None = 0u,
    RunMode_KUve_Normally = 1u,
    RunMode_KUve_EnsureExecutableButDontRun = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static int build_MbR9(const RunMode_KUve runmode)
{
    return int(runmode);
}

static int build_kGbb(const RunMode_KUve runmode, const bool bootstrap)
{
    return build_MbR9((bootstrap ? runmode : (runmode ? RunMode_KUve_EnsureExecutableButDontRun : RunMode_KUve{})));
}

int fu_MAIN()
{
    return build_kGbb(RunMode_KUve_Normally, false) - 2;
}

#endif

int main() { return fu_MAIN(); }

========

        union union_ui {
            i: i32;
            u: u32;
        }

        fn main() {
            mut ui = union_ui(i: -1);
            return (ui.u - 0xffffffff).i32;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
union union_ui_Sjdk;

                                #ifndef DEF_union_ui_SjdkC48Z4wj
                                #define DEF_union_ui_SjdkC48Z4wj
union union_ui_Sjdk
{
                                // shape_hash:    4c8c19f626fd453e
                                // non_triv_mask: 0000000000000000
    int i;
    unsigned u;
    explicit operator bool() const noexcept
    {
        return false
            || i
            || u
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const union_ui_Sjdk ui = union_ui_Sjdk { -1 };
    return int((ui.u - 0xffffffffu));
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(a: int, b: int) a +% b;
        fn main() test(int.MIN, -1) - int.MAX;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_MIN_FUlTBoZvFa3
                                #define DEF_MIN_FUlTBoZvFa3
inline int MIN_FUlT()
{
    return -2147483648;
}
                                #endif

static int test_MbR9(const int a, const int b)
{
    return a + b;
}

                                #ifndef DEF_MAX_GzC5uMH53i1
                                #define DEF_MAX_GzC5uMH53i1
inline int MAX_GzC5()
{
    return 2147483647;
}
                                #endif

int fu_MAIN()
{
    return test_MbR9(MIN_FUlT(), -1) - MAX_GzC5();
}

#endif

int main() { return fu_MAIN(); }

========

        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }


        nothrow 
        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;

---- <fail> ----
[2m[0m_0[2m.fu 15:9+7[0m:

[2m      | [0m
[2m      | [0m
[2m   15 | [0m        [31;1mnothrow[0m 
[2m      |         fn doesnt_catch(mut z: i32) {[0m
[2m      |             if (z & 2)          return does_throw(z);[0m

	[35;3mfn[0m [94;1mdoesnt_catch[0m is not nothrow, throws here:

            via [35;3mfn[0m [94;1mdoes_throw[0m at [2m17:40+10[0m:

[2m      |         nothrow [0m
[2m      |         fn doesnt_catch(mut z: i32) {[0m
[2m   17 | [0m            if (z & 2)          return [31;1mdoes_throw[0m(z);
[2m      |             else                return does_catch(z);[0m
[2m      |         }[0m

            via [35;3m__native[0m [94;1m<fu/never.h> fu::fail[0m at [2m6:13+5[0m:

[2m      |             mut str = "";[0m
[2m      |             while (x--)         str ~= x;[0m
[2m    6 | [0m            [31;1mthrow[0m(str);
[2m      |         }[0m
[2m      | [0m


========

        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }


        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static int does_throw_MbR9(int x)
{
    if (x & 1)
        return x;
    else
    {
        /*MOV*/ fu::str str = fu::str(""_fu);
        while (x--)
            x7Ex3D_w1za(str, fu::i64dec(x));

        fu::fail(str.destructive_move());
    };
}

static int does_catch_MbR9(const int y)
{

    try
    {
        return does_throw_MbR9(y);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e.size();
    }
;
}

static int doesnt_catch_MbR9(const int z)
{
    if (z & 2)
        return does_throw_MbR9(z);
    else
        return does_catch_MbR9(z);

}

int fu_MAIN()
{
    return doesnt_catch_MbR9(1) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }


        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec_range.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_w1zac9Uldqj
                                #define DEF_x7Ex3D_w1zac9Uldqj
inline fu::view<char> x7Ex3D_w1za(/*1:1*/ fu::vec_range_mut<char> a, /*3:3*/ fu::view<char> b)
{
    return (a += b);
}
                                #endif

static int does_throw_MbR9(int x)
{
    if (x & 1)
        return x;
    else
    {
        /*MOV*/ fu::str str {};
        while (x--)
            x7Ex3D_w1za(str, fu::i64dec(x));

        fu::fail(static_cast<fu::str&&>(str));
    };
}

static int does_catch_MbR9(const int y)
{

    try
    {
        return does_throw_MbR9(y);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e.size();
    }
;
}

static int doesnt_catch_MbR9(const int z)
{
    if (z & 2)
        return does_throw_MbR9(z);
    else
        return does_catch_MbR9(z);

}

int fu_MAIN()
{
    return doesnt_catch_MbR9(1) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        fn has_fx() {
            mut res = 0;
            pragma output(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn not_dead_mutually_rec_a(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_b(x - 1);
                has_fx();
            }
        }

        fn not_dead_mutually_rec_b(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_a(x - 1);
                has_fx();
            }
        }

        fn main() {

            not_dead_mutually_rec_b(2); 
            return has_fx() - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static void not_dead_mutually_rec_b_MbR9(int);

#ifndef fu_NO_fdefs

static int has_fx_MbR9()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static void not_dead_mutually_rec_a_MbR9(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_b_MbR9((x - 1));
        has_fx_MbR9();
    };
}

static void not_dead_mutually_rec_b_MbR9(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_a_MbR9((x - 1));
        has_fx_MbR9();
    };
}

int fu_MAIN()
{
    not_dead_mutually_rec_b_MbR9(2);
    return has_fx_MbR9() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_UnusedCall, N_UnusedIfElse

========

        fn has_fx() {
            mut res = 0;
            pragma output(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn not_dead_mutually_rec_a(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_b(x - 1);
                has_fx();
            }
        }

        fn not_dead_mutually_rec_b(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_a(x - 1);
                has_fx();
            }
        }

        fn main() {

            not_dead_mutually_rec_a(2); 
            return has_fx() - 2;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
static void not_dead_mutually_rec_a_MbR9(int);

#ifndef fu_NO_fdefs

static int has_fx_MbR9()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static void not_dead_mutually_rec_b_MbR9(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_a_MbR9((x - 1));
        has_fx_MbR9();
    };
}

static void not_dead_mutually_rec_a_MbR9(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_b_MbR9((x - 1));
        has_fx_MbR9();
    };
}

int fu_MAIN()
{
    not_dead_mutually_rec_a_MbR9(2);
    return has_fx_MbR9() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_UnusedCall, N_UnusedIfElse

========

        fn no_fx() {
            mut res = 0;
            pragma clock(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn test(lax x: i32) {
            x & 1 && no_fx();
            x & 2 || no_fx();
            if (!no_fx) no_fx(); else no_fx();
            for (mut i = 1; i--> 0; no_fx()) no_fx();

            // the idea is that everything above should go,
            //  and just this one call to no_fx will remain.
            return no_fx();
        }

        fn main() = test(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int no_fx_MbR9()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static int test_MbR9()
{
    for (int i = 1; i-- > 0; );
    return no_fx_MbR9();
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse

========

        fn lex(src: string) {
            mut idx = 0;
            let end = src.len;
            while (idx < end) {
                let c = src[idx++]; // bug in discard(if) unused this var
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9') {
                    //
                }
                else {
                    idx--;
                    break;
                }
            }
            return idx;
        }

        fn main() = "hello!".lex - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int lex_MbR9(/*1:1*/ fu::view<char> src)
{
    int idx = 0;
    const int end = src.size();
    while (idx < end)
    {
        const char /*src|static*/ c = src[idx++];
        if (!(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')) || (c == '_') || ((c >= '0') && (c <= '9'))))
        {
            idx--;
            break;
        };
    };
    return idx;
}

int fu_MAIN()
{
    return lex_MbR9("hello!"_view) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        let se_global_false = false;                            // !DEV_DontFoldLiterals

        fn main() {
            if (se_global_false) return THIS_DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let se_global_false = false;                            // !DEV_DontFoldLiterals
        pub import _0;
        fn main() {
            if (se_global_false) return THIS_DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_se_global_false
                                #define DEF_se_global_false
inline constexpr bool se_global_false = false;
                                #endif

// N_SD_HasStaticInit

========

        let se_global_true = true;                              // !DEV_DontFoldLiterals

        fn main() {
            if (!se_global_true) return THIS_DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let se_global_true = true;                              // !DEV_DontFoldLiterals
        pub import _0;
        fn main() {
            if (!se_global_true) return THIS_DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_se_global_true
                                #define DEF_se_global_true
inline constexpr bool se_global_true = true;
                                #endif

// N_SD_HasStaticInit

========

        let se_global_let_from_closure = false;                 // !DEV_DontFoldLiterals

        fn main() {
            fn test() {
                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

========

        let se_global_let_from_closure = false;                 // !DEV_DontFoldLiterals
        pub import _0;
        fn main() {
            fn test() {
                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_LtD7()
{
    return 0;
}

int fu_MAIN()
{
    return test_LtD7();
}

#endif

int main() { return fu_MAIN(); }

                                #ifndef DEF_se_global_let_from_closure
                                #define DEF_se_global_let_from_closure
inline constexpr bool se_global_let_from_closure = false;
                                #endif

// N_SD_HasStaticInit

========

        fn main() {

            mut  se_local_let = false;                   // !DEV_DontFoldLiterals
            if (se_local_let) return THIS_DOESNT_EXIST();
            return 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 5:38+17[0m:

[2m      | [0m
[2m      |             mut  se_local_let = false;                   // !DEV_DontFoldLiterals[0m
[2m    5 | [0m            if (se_local_let) return [31;1mTHIS_DOESNT_EXIST[0m();
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [94;1mTHIS_DOESNT_EXIST[0m: [94;1mTHIS_DOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {

            let  se_local_let = false;                   // !DEV_DontFoldLiterals
            if (se_local_let) return THIS_DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }
        fn main() = Hello(true).v ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_W0FI;

                                #ifndef DEF_Hello_W0FI19uc5Ng
                                #define DEF_Hello_W0FI19uc5Ng
struct Hello_W0FI
{
                                // shape_hash:    ee95ae290a14593c
                                // non_triv_mask: 0000000000000000
    bool v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (Hello_W0FI { true }.v)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }

        fn main() {
            let yes = Hello(true);
            let no  = Hello(false);

            let expect_true = yes.v;
            let expect_false = no.v;

            if (!expect_true) return 20;
            if (expect_false) return 10;
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_W0FI;

                                #ifndef DEF_Hello_W0FI19uc5Ng
                                #define DEF_Hello_W0FI19uc5Ng
struct Hello_W0FI
{
                                // shape_hash:    ee95ae290a14593c
                                // non_triv_mask: 0000000000000000
    bool v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Hello_W0FI yes = Hello_W0FI { true };
    const Hello_W0FI no = Hello_W0FI { false };
    const bool /*yes*/ expect_true = yes.v;
    const bool /*no*/ expect_false = no.v;
    if (!expect_true)
        return 20;
    else if (expect_false)
        return 10;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {

            mut  se_closure_let = false;                 // !DEV_DontFoldLiterals
            fn test() {
                if (se_closure_let) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

---- <fail> ----
[2m[0m_0[2m.fu 6:44+17[0m:

[2m      |             mut  se_closure_let = false;                 // !DEV_DontFoldLiterals[0m
[2m      |             fn test() {[0m
[2m    6 | [0m                if (se_closure_let) return [31;1mTHIS_DOESNT_EXIST[0m();
[2m      |                 return 0;[0m
[2m      |             }[0m

	Bad call to [94;1mTHIS_DOESNT_EXIST[0m: [94;1mTHIS_DOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mtest[0m at [2m5:16+4[0m
                [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {

            let  se_closure_let = false;                 // !DEV_DontFoldLiterals
            fn test() {
                if (se_closure_let) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9()
{
    return 0;
}

int fu_MAIN()
{
    return test_MbR9();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_UnusedLet

========

        fn test(x: i32) {
            let val =                                       
                (x & 1 || { return 1 }) && { return 0 };    

            return UNREACHABLE(val);
        }

        fn main() test(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

========

        fn test(x: i32) {
            let val =                                       
                x & 1 && { return 0 } || { return 1 };      

            return UNREACHABLE(val);
        }

        fn main() test(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

========

        fn test(x: i32) {
            let val =                                       
                x & 1 ? { return 0 } : { return 1 };        

            return UNREACHABLE(val);
        }

        fn main() test(1);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_MbR9(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

========

        noinline fn alwaysFalse() false;
        fn main() alwaysFalse.i32;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static bool alwaysFalse_MbR9()
{
    return false;
}

int fu_MAIN()
{
    return int(alwaysFalse_MbR9());
}

#endif

int main() { return fu_MAIN(); }

========

        fn typeParamsMusntPickUpVFacts(x: i32) {
            let y = x || throw("x == 0"); // Now y is always true.
            if (y & 1) // & 1 is not always true though.
                return y * 10;
            else
                return y * 100;
        }

        fn main() typeParamsMusntPickUpVFacts(3)
                + typeParamsMusntPickUpVFacts(2)  == 230 ? 0 : 1 

---- <fail> ----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:17+1[0m:

[2m      | [0m
[2m      |         fn main() typeParamsMusntPickUpVFacts(3)[0m
[2m   11 | [0m                [31;1m+[0m typeParamsMusntPickUpVFacts(2)  == 230 ? 0 : 1 
[2m      | [0m

	Misleading whitespace: misrepresents operator precedence.

	Please parenthesize this expression to disambiguate,
		indent the stronger operator further to the right,
		or put the weaker operator on a new line.

========

        fn typeParamsMusntPickUpVFacts(x: i32) {
            let y = x || throw("x == 0"); // Now y is always true.
            if (y & 1) // & 1 is not always true though.
                return y * 10;
            else
                return y * 100;
        }

        fn main() typeParamsMusntPickUpVFacts(3)
                + typeParamsMusntPickUpVFacts(2) 
                    == 230 ? 0 : 1;              

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int typeParamsMusntPickUpVFacts_MbR9(const int x)
{
    const int /*x*/ y = (x ? x : fu::fail(fu::str("x == 0"_fu)));
    if (y & 1)
        return y * 10;
    else
        return y * 100;

}

int fu_MAIN()
{
    if ((typeParamsMusntPickUpVFacts_MbR9(3) + typeParamsMusntPickUpVFacts_MbR9(2)) == 230)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        fn test() 
                : never 
                    = [];

        fn main() {
            mut x: i32 = test();
            return x;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:23+2[0m:

[2m      |         fn test() [0m
[2m      |                 : never [0m
[2m    4 | [0m                    = [31;1m[][0m;
[2m      | [0m
[2m      |         fn main() {[0m

	[35;3mfn[0m [94;1mtest[0m: return type does not match annotation: expects [35;3mnever[0m, got [35;3m[][0m

        Solving [35;3mfn[0m [94;1mtest[0m at [2m2:12+4[0m

========

        fn test() 
                    = [];

        fn main() {
            mut x: i32 = test();
            return x;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    return x;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            return checkPalindrome(value, rev)
                && rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_APE0ITDuTed
                                #define STR_APE0ITDuTed
static const fu::str str_APE0ITDuTed fu_INIT_PRIORITY(1001) { "opera-arepo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkPalindrome_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static fu::str palindrome_MbR9(/*1:1*/ fu::vec_range<char> value)
{
    /*MOV*/ fu::str rev = fu::str(value);
    reverse_LDrI(rev);
    checkPalindrome_MbR9(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    fu::vec_range<char> /*static*/ n = str_APE0ITDuTed;
    return palindrome_MbR9(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            return checkPalindrome(value, rev)
                && rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_APE0ITDuTed
                                #define STR_APE0ITDuTed
static const fu::str str_APE0ITDuTed fu_INIT_PRIORITY(1001) { "opera-arepo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkPalindrome_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static fu::str palindrome_MbR9(/*1:1*/ fu::vec_range<char> value)
{
    /*MOV*/ fu::str rev = fu::str(value);
    reverse_LDrI(rev);
    checkPalindrome_MbR9(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    const fu::str& /*static*/ n = str_APE0ITDuTed;
    return palindrome_MbR9(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            checkPalindrome(value, rev);
            return rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_APE0ITDuTed
                                #define STR_APE0ITDuTed
static const fu::str str_APE0ITDuTed fu_INIT_PRIORITY(1001) { "opera-arepo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkPalindrome_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static fu::str palindrome_MbR9(/*1:1*/ fu::vec_range<char> value)
{
    /*MOV*/ fu::str rev = fu::str(value);
    reverse_LDrI(rev);
    checkPalindrome_MbR9(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    fu::vec_range<char> /*static*/ n = str_APE0ITDuTed;
    return palindrome_MbR9(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            checkPalindrome(value, rev);
            return rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>


                                #ifndef STR_APE0ITDuTed
                                #define STR_APE0ITDuTed
static const fu::str str_APE0ITDuTed fu_INIT_PRIORITY(1001) { "opera-arepo"_fu };
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_LDrImXqJ6tg
                                #define DEF_reverse_LDrImXqJ6tg
inline void reverse_LDrI(/*1:1*/ fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkPalindrome_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static fu::str palindrome_MbR9(/*1:1*/ fu::vec_range<char> value)
{
    /*MOV*/ fu::str rev = fu::str(value);
    reverse_LDrI(rev);
    checkPalindrome_MbR9(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    const fu::str& /*static*/ n = str_APE0ITDuTed;
    return palindrome_MbR9(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Node         { value: string };
        struct Target       { index: i32    };
        struct SolvedNode   { value: string };

        fn solve(n_root: Node)
        {
            fn solveNode(node: Node)
                return CallerNode(node.value);

            fn checkAssignable(host: string, guest: string)
                return host == guest || throw(":(");

            fn CallerNode(value: string) {

                return checkAssignable(value, n_root.value)
                    && SolvedNode(:value);

            }

            return solveNode(n_root);
        }

        fn main() {
            mut n = Node("hello!");
            return n.solve.value.len - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>

struct Node_dxT9;
struct SolvedNode_GgLX;

                                #ifndef DEF_Node_dxT9R9bbJg0
                                #define DEF_Node_dxT9R9bbJg0
struct Node_dxT9
{
                                // shape_hash:    f05568f186a84230
                                // non_triv_mask: 0008800000000000
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_GgLXxEVuHRg
                                #define DEF_SolvedNode_GgLXxEVuHRg
struct SolvedNode_GgLX
{
                                // shape_hash:    e3a9ebcb7565374c
                                // non_triv_mask: 0000800000000004
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkAssignable_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static SolvedNode_GgLX CallerNode_MbR9(/*3:3*/ fu::vec_range<char> value, /*3:3*/ const Node_dxT9& n_root)
{
    checkAssignable_MbR9(value, n_root.value);
    return SolvedNode_GgLX { fu::str(value) };
}

static SolvedNode_GgLX solveNode_MbR9(/*3:3*/ const Node_dxT9& node, /*3:3*/ const Node_dxT9& n_root)
{
    return CallerNode_MbR9(node.value, n_root);
}

static SolvedNode_GgLX solve_MbR9(/*1:1*/ const Node_dxT9& n_root)
{
    return solveNode_MbR9(n_root, n_root);
}

int fu_MAIN()
{
    Node_dxT9 n = Node_dxT9 { fu::str("hello!"_fu) };
    return solve_MbR9(n).value.size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Node         { value: string };
        struct Target       { index: i32    };
        struct SolvedNode   { value: string };

        fn solve(n_root: Node)
        {
            fn solveNode(node: Node)
                return CallerNode(node.value);

            fn checkAssignable(host: string, guest: string)
                return host == guest || throw(":(");

            fn CallerNode(value: string) {

                checkAssignable(value, n_root.value);
                return SolvedNode(:value);

            }

            return solveNode(n_root);
        }

        fn main() {
            mut n = Node("hello!");
            return n.solve.value.len - 6;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec_range.h>

struct Node_dxT9;
struct SolvedNode_GgLX;

                                #ifndef DEF_Node_dxT9R9bbJg0
                                #define DEF_Node_dxT9R9bbJg0
struct Node_dxT9
{
                                // shape_hash:    f05568f186a84230
                                // non_triv_mask: 0008800000000000
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

                                #ifndef DEF_SolvedNode_GgLXxEVuHRg
                                #define DEF_SolvedNode_GgLXxEVuHRg
struct SolvedNode_GgLX
{
                                // shape_hash:    e3a9ebcb7565374c
                                // non_triv_mask: 0000800000000004
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_YuqOPxIKAE3
                                #define DEF_x3Cx3E_YuqOPxIKAE3
inline int x3Cx3E_YuqO(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_j5CR7zKytVk
                                #define DEF_x3Cx3E_j5CR7zKytVk
inline int x3Cx3E_j5CR(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_YuqO(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_oVAS1y5c4ld
                                #define DEF_x3Dx3D_oVAS1y5c4ld
inline bool operator==(/*3:3*/ fu::view<char> a, /*3:3*/ fu::view<char> b)
{
    return !x3Cx3E_j5CR(a, b);
}
                                #endif

static bool checkAssignable_MbR9(/*3:3*/ fu::view<char> host, /*3:3*/ fu::view<char> guest)
{
    return (host == guest) || fu::fail(fu::str(":("_fu));
}

static SolvedNode_GgLX CallerNode_MbR9(/*3:3*/ fu::vec_range<char> value, /*3:3*/ const Node_dxT9& n_root)
{
    checkAssignable_MbR9(value, n_root.value);
    return SolvedNode_GgLX { fu::str(value) };
}

static SolvedNode_GgLX solveNode_MbR9(/*3:3*/ const Node_dxT9& node, /*3:3*/ const Node_dxT9& n_root)
{
    return CallerNode_MbR9(node.value, n_root);
}

static SolvedNode_GgLX solve_MbR9(/*1:1*/ const Node_dxT9& n_root)
{
    return solveNode_MbR9(n_root, n_root);
}

int fu_MAIN()
{
    Node_dxT9 n = Node_dxT9 { fu::str("hello!"_fu) };
    return solve_MbR9(n).value.size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

========

        struct Postdom { a: i32; b?: i32[] };

        fn clear(ref p: Postdom)
            for (fieldname i: Postdom)
                if (typeof(p.i) -> i32[])
                    p.i.clear();

        fn main() {
            mut a = Postdom(a: 3);
            mut b = Postdom(a: 3, b: [ 1 ]);
            if (a == b) return 1;
            b.clear();
            return a == b ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct Postdom_lmJu;

                                #ifndef DEF_Postdom_lmJuqxzl1q2
                                #define DEF_Postdom_lmJuqxzl1q2
struct Postdom_lmJu
{
                                // shape_hash:    de6703113fd0f2c1
                                // non_triv_mask: 0008000000020000
    int a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_2dTt6sLixsc
                                #define DEF_x3Cx3E_2dTt6sLixsc
inline int x3Cx3E_2dTt(/*3:3*/ const Postdom_lmJu& a, /*3:3*/ const Postdom_lmJu& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_odNT(a.a, b.a)))
        return cmp;
    else if ((cmp = x3Cx3E_2Y4m(a.b, b.b)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_bnZDyFubA0j
                                #define DEF_x3Dx3D_bnZDyFubA0j
inline bool operator==(/*3:3*/ const Postdom_lmJu& a, /*3:3*/ const Postdom_lmJu& b)
{
    return !x3Cx3E_2dTt(a, b);
}
                                #endif

static void clear_MbR9(/*1:1*/ Postdom_lmJu& p)
{
    p.b.clear();
}

int fu_MAIN()
{
    Postdom_lmJu a = Postdom_lmJu { 3, fu::vec<int>{} };
    Postdom_lmJu b = Postdom_lmJu { 3, fu::vec<int> {{ 1 }} };
    if (a == b)
        return 1;
    else
    {
        clear_MbR9(b);
        if (a == b)
            return 0;
        else
            return 1;

    };
}

#endif

int main() { return fu_MAIN(); }

========

        novec fn build(ref a: string, b: string) {
            let cmake       = false;                            // !DEV_DontFoldLiterals

            let OPAQUE      = a.len + b.len;
            let CMakeLists  = cmake && OPAQUE && (a ~= b);

            if (CMakeLists) DOESNT_EXIST();
            return CMakeLists;
        }

        fn main() {
            mut a = "hello, ";
            let b = "world!";
            return build(a, b).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static const fu::str& build_MbR9()
{
    const fu::str& /*zeroes*/ CMakeLists = (*(fu::str*)fu::NIL);
    return CMakeLists;
}

int fu_MAIN()
{
    return build_MbR9().size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

========

        novec fn build(ref a: string, b: string) {
            let cmake       = false;                            // !DEV_DontFoldLiterals

            let CMakeLists  = cmake && (a ~= b);

            if (CMakeLists) DOESNT_EXIST();
            return CMakeLists;
        }

        fn main() {
            mut a = "hello, ";
            let b = "world!";
            return build(a, b).len;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/str.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static const fu::str& build_MbR9()
{
    const fu::str& /*zeroes*/ CMakeLists = (*(fu::str*)fu::NIL);
    return CMakeLists;
}

int fu_MAIN()
{
    return build_MbR9().size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

========

        fn doesntSkipIfWithTrailingFalse(x: i32) {
            if (x && false)                                     // !DEV_DontFoldLiterals
                return DOESNT_EXIST;
            else
                return x;
        }

        fn main() = doesntSkipIfWithTrailingFalse(0);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int doesntSkipIfWithTrailingFalse_MbR9(/*1:1*/ const int x)
{
    return x;
}

int fu_MAIN()
{
    return doesntSkipIfWithTrailingFalse_MbR9(0);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedAndOr

========

        struct Hello { hello: int };
        fn what(who) {
            if (who.hello) DOESNT_EXIST;
            return 0;
        }

        fn main() what([]);

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_what_Db3b6XxkEp0
                                #define DEF_what_Db3b6XxkEp0
inline static int what_Db3b()
{
    return 0;
}
                                #endif

int fu_MAIN()
{
    return what_Db3b();
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            mut zero = 0; // zero++ must never happen
            (zero++) = { return :main zero; };
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int zero = 0;
    return zero;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn main() {
            mut zero = 0; // zero++ must never happen
            fn no_return() { return :main zero; }
            (zero++) = no_return();
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int zero = 0;
    return zero;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn takes_two_lambdas(inline a, inline b) a = b;

        fn main() {
            mut zero = 0; // zero++ must never happen
            takes_two_lambdas(zero++, { return :main zero });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int zero = 0;
    return zero;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn takes_two_lambdas(a, b) a() = b();

        fn main() {
            mut zero = 0; // zero++ must never happen
            takes_two_lambdas(|| zero++, || { return :main zero });
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int zero = 0;
    return zero;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

========

        fn main() {
            if (true) DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:23+12[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            if (true) [31;1mDOESNT_EXIST[0m(); // !DEV_DontFoldLiterals
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [94;1mDOESNT_EXIST[0m: [94;1mDOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            if (false) DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            if (1) DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:20+12[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            if (1) [31;1mDOESNT_EXIST[0m(); // !DEV_DontFoldLiterals
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [94;1mDOESNT_EXIST[0m: [94;1mDOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            if (0) DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            if ('0') DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:22+12[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            if ('0') [31;1mDOESNT_EXIST[0m(); // !DEV_DontFoldLiterals
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [94;1mDOESNT_EXIST[0m: [94;1mDOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            if ('\0') DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            if ("\0") DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:23+12[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            if ("\0") [31;1mDOESNT_EXIST[0m(); // !DEV_DontFoldLiterals
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [94;1mDOESNT_EXIST[0m: [94;1mDOESNT_EXIST[0m is not defined here.

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            if ("") DOESNT_EXIST(); // !DEV_DontFoldLiterals
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {
            if (int[]) DOESNT_EXIST();
            return 0;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        noinline fn add(ref a: i32, ref b: i32) a + b;
        fn main() = add(1, 2) - 3;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int add_MbR9(/*3:3*/ const int a, /*3:3*/ const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return add_MbR9(1, 2) - 3;
}

#endif

int main() { return fu_MAIN(); }

========

        fn PreIncr( 
                x) ++x;

        fn main() {
            mut res = -1;
            return PreIncr(res);
        }

---- <fail> ----
[2m[0m_0[2m.fu 3:20+2[0m:

[2m      | [0m
[2m      |         fn PreIncr( [0m
[2m    3 | [0m                x) [31;1m++[0mx;
[2m      | [0m
[2m      |         fn main() {[0m

	Bad call to [94;1m++[0m with args ([35;3mi32[0m): 

	[35;3mtemplate[0m [94;1m++[0m at [2m../../../../../[0mprelude[2m 18:11+2[0m:
[2m   18 | [0mprefix fn [31;1m++[0m (mut ref a: <T>) case (T.is::arithmetic): &mut T __native;

	    [35;3mref arg[0m [94;1ma[0m expects a mutref, got a ref to [35;3marg[0m [94;1mx[0m at [2m3:17+1[0m:

[2m      | [0m
[2m      |         fn PreIncr( [0m
[2m    3 | [0m                [31;1mx[0m) ++x;
[2m      | [0m
[2m      |         fn main() {[0m

	    ... which is not mutable.

        Solving [35;3mfn[0m [94;1mPreIncr[0m([35;3mi32[0m) at [2m2:12+7[0m
                [35;3mfn[0m [94;1mmain[0m at [2m5:12+4[0m

========

        fn PreIncr( 
            ref     
                x) ++x;

        fn main() {
            mut res = -1;
            return PreIncr(res);
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_PreIncr_COhcgc3Uuhk
                                #define DEF_PreIncr_COhcgc3Uuhk
inline static int PreIncr_COhc(/*1:1*/ int& x)
{
    return ++x;
}
                                #endif

int fu_MAIN()
{
    int res = -1;
    return PreIncr_COhc(res);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn val_keyword(val a, val b) {
            val c = a + b;
            return c;
        }

        fn main() val_keyword(2, 3) - 5;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_val_keyword_rtcdROglty0
                                #define DEF_val_keyword_rtcdROglty0
inline static int val_keyword_rtcd(const int a, const int b)
{
    const int c = (a + b);
    return c;
}
                                #endif

int fu_MAIN()
{
    return val_keyword_rtcd(2, 3) - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn val_keyword(const ref a, const ref b) {
            const ref c = a || b;
            return c;
        }

        fn main() val_keyword(2, 3) - 2;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

                                #ifndef DEF_val_keyword_B69atcU27D7
                                #define DEF_val_keyword_B69atcU27D7
inline static int val_keyword_B69a(/*3:3*/ const int a, /*3:3*/ const int b)
{
    const int /*a|b*/ c = (a ? a : b);
    return c;
}
                                #endif

int fu_MAIN()
{
    return val_keyword_B69a(2, 3) - 2;
}

#endif

int main() { return fu_MAIN(); }

========


        fn foreach_modify(    explicit_arg: int[], foreach)     
            for (mut i = explicit_arg.len; i --> 0; )
                foreach(explicit_arg[i], i?: i);

        fn main() {
            mut closure_arg = [ 2 ];
            closure_arg.foreach_modify: |item, ref i| {
                while (item > i) {
                    closure_arg.insert(i, i);
                    i++;
                }
            }

            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 9:25+14[0m:

[2m      |         fn main() {[0m
[2m      |             mut closure_arg = [ 2 ];[0m
[2m    9 | [0m            closure_arg.[31;1mforeach_modify[0m: |item, ref i| {
[2m      |                 while (item > i) {[0m
[2m      |                     closure_arg.insert(i, i);[0m

	At call to [35;3mfn[0m [94;1mforeach_modify[0m, arguments:

	    3:	[35;3minjected implicit ref arg[0m [94;1mforeach_modify[0m:[94;1mmain:closure_arg[0m and
	    1:	[35;3marg[0m [94;1mforeach_modify[0m:[94;1mexplicit_arg[0m

	    both alias:

	    [35;3mmut[0m [94;1mclosure_arg[0m at [2m8:17+11[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    8 | [0m            mut [31;1mclosure_arg[0m = [ 2 ];
[2m      |             closure_arg.foreach_modify: |item, ref i| {[0m
[2m      |                 while (item > i) {[0m

	Cannot resolve aliasing by a temporary copy:

	    [35;3minjected implicit ref arg[0m [94;1mforeach_modify[0m:[94;1mmain:closure_arg[0m is [31;1mimplicit[0m

	    [35;3marg[0m [94;1mforeach_modify[0m:[94;1mexplicit_arg[0m needs an explicit [35;3mref[0m or [35;3mval[0m for disambiguation:

		- Use [35;3mref[0m if you want [35;3marg[0m [94;1mexplicit_arg[0m to reflect changes made to the aliased injected arg.

		- Use [35;3mval[0m if you want [35;3marg[0m [94;1mexplicit_arg[0m to remain constant throughout [35;3mfn[0m [94;1mforeach_modify[0m

    BorrowCheck [35;3mfn[0m [94;1mmain[0m at [2m7:12+4[0m

========


        fn foreach_modify(ref explicit_arg: int[], foreach)     
            for (mut i = explicit_arg.len; i --> 0; )
                foreach(explicit_arg[i], i?: i);

        fn main() {
            mut closure_arg = [ 2 ];
            closure_arg.foreach_modify: |item, ref i| {
                while (item > i) {
                    closure_arg.insert(i, i);
                    i++;
                }
            }

            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___Q0BYhPwzU3j
                                #define DEF___Q0BYhPwzU3j
inline static void _Q0BY(const int item, /*7:3*/ int& i, /*7:5*/ fu::vec_range_mut<int> closure_arg)
{
    while (item > i)
    {
        closure_arg.insert(i, i);
        i++;
    };
}
                                #endif

                                #ifndef DEF_foreach_modify_xfPE2YPh9L5
                                #define DEF_foreach_modify_xfPE2YPh9L5
inline static void foreach_modify_xfPE(/*7:7*/ fu::vec_range<int> explicit_arg, /*7:6*/ fu::vec_range_mut<int> closure_arg)
{
    for (int i = explicit_arg.size(); i-- > 0; )
        _Q0BY(explicit_arg[i], i, closure_arg);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> closure_arg = fu::vec<int> {{ 2 }};
    foreach_modify_xfPE(closure_arg, closure_arg);
    if (closure_arg == fu::view<int> {{ 0, 1, 2 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========


        fn foreach_modify(ref explicit_arg: int[], foreach)     
            for (mut i = explicit_arg.len; i --> 0; )
                foreach(explicit_arg[i], i?: i);

        fn main() {
            mut closure_arg = [ 2 ];
            closure_arg.foreach_modify: |item, ref i| {
                while (item > i) {
                    closure_arg.insert(i, i);
                    i++;
                }
            }

            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec_range.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF___Q0BYhPwzU3j
                                #define DEF___Q0BYhPwzU3j
inline static void _Q0BY(const int item, /*7:3*/ int& i, /*7:5*/ fu::vec<int>& closure_arg)
{
    while (item > i)
    {
        closure_arg.insert(i, i);
        i++;
    };
}
                                #endif

                                #ifndef DEF_foreach_modify_xfPE2YPh9L5
                                #define DEF_foreach_modify_xfPE2YPh9L5
inline static void foreach_modify_xfPE(/*7:7*/ fu::vec_range<int> explicit_arg, /*7:6*/ fu::vec<int>& closure_arg)
{
    for (int i = explicit_arg.size(); i-- > 0; )
        _Q0BY(explicit_arg[i], i, closure_arg);

}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> closure_arg = fu::vec<int> {{ 2 }};
    foreach_modify_xfPE(closure_arg, closure_arg);
    if (closure_arg == fu::view<int> {{ 0, 1, 2 }})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_AARSoftRisk

========

        fn main() {
            lax let five = 5;
            ref x = 5;
            return x - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+1[0m:

[2m      |         fn main() {[0m
[2m      |             lax let five = 5;[0m
[2m    4 | [0m            ref [31;1mx[0m = 5;
[2m      |             return x - 5;[0m
[2m      |         }[0m

	Init expression is not a [31;1mref[0m: [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            lax let five = 5;
            ref x = 5;
            return x - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:17+1[0m:

[2m      |         fn main() {[0m
[2m      |             lax let five = 5;[0m
[2m    4 | [0m            ref [31;1mx[0m = 5;
[2m      |             return x - 5;[0m
[2m      |         }[0m

	Init expression is not a [31;1mref[0m: [35;3malways-true[0m [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {
            lax let five = 5;
            ref x = five;
            return x - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int five = 5;
    return five - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn main() {         
            let five = 5;   
            mut ref x = five;
            return x - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:21+1[0m:

[2m      |         fn main() {         [0m
[2m      |             let five = 5;   [0m
[2m    4 | [0m            mut ref [31;1mx[0m = five;
[2m      |             return x - 5;[0m
[2m      |         }[0m

	Init expression is not a [31;1mmut[0m ref: [35;3mconst[0m [35;3mref[0m [94;1mfive[0m [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {         
            let five = 5;   
            mut ref x = five;
            return x - 5;
        }

---- <fail> ----
[2m[0m_0[2m.fu 4:21+1[0m:

[2m      |         fn main() {         [0m
[2m      |             let five = 5;   [0m
[2m    4 | [0m            mut ref [31;1mx[0m = five;
[2m      |             return x - 5;[0m
[2m      |         }[0m

	Init expression is not a [31;1mmut[0m ref: [35;3malways-true[0m [35;3mconst[0m [35;3mref[0m [94;1mfive[0m [35;3mi32[0m

        Solving [35;3mfn[0m [94;1mmain[0m at [2m2:12+4[0m

========

        fn main() {         
            mut five = 5;   
            mut ref x = five;
            return x - 5;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int five = 5;
    return five - 5;
}

#endif

int main() { return fu_MAIN(); }

========

        fn test(ref x: int) {
            if ((y := x *= 2) > 10)
                return y * 2;
            else
                return y;
        }

        fn main() {
            mut x = 6;
            return test(x) == 24 && x == 12 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int test_MbR9(/*1:1*/ int& x)
{
    int y;
    if ((y = (x *= 2)) > 10)
        return y * 2;
    else
        return y;

}

int fu_MAIN()
{
    int x = 6;
    if ((test_MbR9(x) == 24) && (x == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: _[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: _[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= [];
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:57+2[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut thing: NonTriv;[0m
[2m   23 | [0m                for (mut j = 0; j < i; j++) thing.items [31;1m~=[0m [];
[2m      |                 things ~= thing;[0m
[2m      |             }[0m

	Ambiguous call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNonTriv[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	[35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");


        Solving [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: _[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: NonTriv[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= [];
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:57+2[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut thing: NonTriv;[0m
[2m   23 | [0m                for (mut j = 0; j < i; j++) thing.items [31;1m~=[0m [];
[2m      |                 things ~= thing;[0m
[2m      |             }[0m

	Ambiguous call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNonTriv[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	[35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");


        Solving [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: NonTriv[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: _[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= [];
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:57+2[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut thing: NonTriv;[0m
[2m   23 | [0m                for (mut j = 0; j < i; j++) thing.items [31;1m~=[0m [];
[2m      |                 things ~= thing;[0m
[2m      |             }[0m

	Ambiguous call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNonTriv[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	[35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");


        Solving [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: NonTriv[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: NonTriv[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= [];
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- <fail> ----
[2m[0m_0[2m.fu 23:57+2[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut thing: NonTriv;[0m
[2m   23 | [0m                for (mut j = 0; j < i; j++) thing.items [31;1m~=[0m [];
[2m      |                 things ~= thing;[0m
[2m      |             }[0m

	Ambiguous call to [94;1m~=[0m with args ([35;3mmut[0m [35;3mref[0m [35;3mstruct[0m [94;1mNonTriv[0m[35;3m[][0m, [35;3malways-false[0m [35;3mnocopy[0m [35;3m[][0m), matches multiple items in scope:

	[35;3m__native[0m [94;1m<fu/vec/concat_one.h> +=[0m at [2m../../../../../[0mprelude[2m 484:10+2[0m:
[2m  484 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[], mut b: T    ): &mut T[] __native("<fu/vec/concat_one.h>", "+=");

	[35;3m__native[0m [94;1m<fu/vec/concat.h> +=[0m at [2m../../../../../[0mprelude[2m 483:10+2[0m:
[2m  483 | [0minfix fn [31;1m~=[0m (mut ref a: <T>[],     b: T[..]): &mut T[] __native("<fu/vec/concat.h>",     "+=");


        Solving [35;3mfn[0m [94;1mmain[0m at [2m19:12+4[0m

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: _[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: _[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= NonTriv();
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1840) arc_count(13) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = default;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU& selfrec) { return *this = NonTriv_UeFU(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_pick_XN9F6YUjdx4
                                #define DEF_pick_XN9F6YUjdx4
inline static const NonTriv_UeFU& pick_XN9F(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    for (int i = 0; i < things.size(); i++)
    {
        const NonTriv_UeFU* thing;
        if ((*(thing = &(things[i]))).items.size() == id)
            return (*thing);

    };
    return (*(NonTriv_UeFU*)fu::NIL);
}
                                #endif

                                #ifndef DEF_test_2rO0qYGWyz4
                                #define DEF_test_2rO0qYGWyz4
inline static int test_2rO0(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    const NonTriv_UeFU* thing;
    if ((*(thing = &(pick_XN9F(things, id)))))
        return (*thing).items.size();
    else
        return -1;

}
                                #endif

int fu_MAIN()
{
    fu::vec<NonTriv_UeFU> things {};
    for (int i = 0; i < 10; i++)
    {
        /*MOV*/ NonTriv_UeFU thing {};
        for (int j = 0; j < i; j++)
        {
            thing.items += NonTriv_UeFU{};
        };
        things += static_cast<NonTriv_UeFU&&>(thing);
    };
    if ((test_2rO0(things, 11) == -1) && (test_2rO0(things, 7) == 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: _[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: NonTriv[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= NonTriv();
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1840) arc_count(13) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = default;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU& selfrec) { return *this = NonTriv_UeFU(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_pick_XN9F6YUjdx4
                                #define DEF_pick_XN9F6YUjdx4
inline static const NonTriv_UeFU& pick_XN9F(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    for (int i = 0; i < things.size(); i++)
    {
        const NonTriv_UeFU* thing;
        if ((*(thing = &(things[i]))).items.size() == id)
            return (*thing);

    };
    return (*(NonTriv_UeFU*)fu::NIL);
}
                                #endif

static int test_MbR9(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    const NonTriv_UeFU* thing;
    if ((*(thing = &(pick_XN9F(things, id)))))
        return (*thing).items.size();
    else
        return -1;

}

int fu_MAIN()
{
    fu::vec<NonTriv_UeFU> things {};
    for (int i = 0; i < 10; i++)
    {
        /*MOV*/ NonTriv_UeFU thing {};
        for (int j = 0; j < i; j++)
        {
            thing.items += NonTriv_UeFU{};
        };
        things += static_cast<NonTriv_UeFU&&>(thing);
    };
    if ((test_MbR9(things, 11) == -1) && (test_MbR9(things, 7) == 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: NonTriv[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: _[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= NonTriv();
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1840) arc_count(13) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = default;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU& selfrec) { return *this = NonTriv_UeFU(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NonTriv_UeFU& pick_MbR9(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    for (int i = 0; i < things.size(); i++)
    {
        const NonTriv_UeFU* thing;
        if ((*(thing = &(things[i]))).items.size() == id)
            return (*thing);

    };
    return (*(NonTriv_UeFU*)fu::NIL);
}

                                #ifndef DEF_test_O1JdF2ILnaj
                                #define DEF_test_O1JdF2ILnaj
inline static int test_O1Jd(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    const NonTriv_UeFU* thing;
    if ((*(thing = &(pick_MbR9(things, id)))))
        return (*thing).items.size();
    else
        return -1;

}
                                #endif

int fu_MAIN()
{
    fu::vec<NonTriv_UeFU> things {};
    for (int i = 0; i < 10; i++)
    {
        /*MOV*/ NonTriv_UeFU thing {};
        for (int j = 0; j < i; j++)
        {
            thing.items += NonTriv_UeFU{};
        };
        things += static_cast<NonTriv_UeFU&&>(thing);
    };
    if ((test_O1Jd(things, 11) == -1) && (test_O1Jd(things, 7) == 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct NonTriv { items: NonTriv[] };

        fn pick(ref things: NonTriv[], id: int) {
            for (mut i = 0; i < things.len; i++)
                if ((thing := things[i]).items.len == id)
                    return thing;

            return [];
        }

        fn test(ref things: NonTriv[], id: int) {
            if (let thing = pick(things, id))
                return thing.items.len;

            return -1;
        }

        fn main() {
            mut things: NonTriv[];
            for (mut i = 0; i < 10; i++) {
                mut thing: NonTriv;
                for (mut j = 0; j < i; j++) thing.items ~= NonTriv();
                things ~= thing;
            }

            return test(things, 11) == -1
                && test(things, 7)  ==  7 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(1840) arc_count(13) ] ----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct NonTriv_UeFU;

                                #ifndef DEF_NonTriv_UeFUDuItaWd
                                #define DEF_NonTriv_UeFUDuItaWd
struct NonTriv_UeFU
{
                                // shape_hash:    0b661d619e1d852a
                                // non_triv_mask: 0000000000001002
    fu::vec<NonTriv_UeFU> items;
    NonTriv_UeFU(const NonTriv_UeFU&) = default;
    NonTriv_UeFU(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(NonTriv_UeFU&&) = default;
    NonTriv_UeFU& operator=(const NonTriv_UeFU& selfrec) { return *this = NonTriv_UeFU(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const NonTriv_UeFU& pick_MbR9(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    for (int i = 0; i < things.size(); i++)
    {
        const NonTriv_UeFU* thing;
        if ((*(thing = &(things[i]))).items.size() == id)
            return (*thing);

    };
    return (*(NonTriv_UeFU*)fu::NIL);
}

static int test_MbR9(/*3:3*/ fu::view<NonTriv_UeFU> things, const int id)
{
    const NonTriv_UeFU* thing;
    if ((*(thing = &(pick_MbR9(things, id)))))
        return (*thing).items.size();
    else
        return -1;

}

int fu_MAIN()
{
    fu::vec<NonTriv_UeFU> things {};
    for (int i = 0; i < 10; i++)
    {
        /*MOV*/ NonTriv_UeFU thing {};
        for (int j = 0; j < i; j++)
        {
            thing.items += NonTriv_UeFU{};
        };
        things += static_cast<NonTriv_UeFU&&>(thing);
    };
    if ((test_MbR9(things, 11) == -1) && (test_MbR9(things, 7) == 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

========

        struct Container { value: int };
        fn visit(ref container: Container, fn) {
            fn(container.value);
        }

        fn main() {
            let c = Container(0);
            c.visit: |v| return v;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Container_tkpz;

                                #ifndef DEF_Container_tkpzHVEaxTd
                                #define DEF_Container_tkpzHVEaxTd
struct Container_tkpz
{
                                // shape_hash:    1d7e15887742ad1a
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const Container_tkpz c = Container_tkpz { 0 };
    const int /*c*/ v = c.value;
    return v;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

========

        struct Container { value: int };
        fn visit(ref container: Container, fn) {
            fn update(v: int) container.value = v;
            fn(container.value, ?:fn update);
        }

        fn init(mut c?: Container) {
            c.visit: |v, update| { update(v - 10) };
            return c;
        }

        fn main() {
            let c = init(Container(10));
            c.visit: |v| return v;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Container_tkpz;

                                #ifndef DEF_Container_tkpzHVEaxTd
                                #define DEF_Container_tkpzHVEaxTd
struct Container_tkpz
{
                                // shape_hash:    1d7e15887742ad1a
                                // non_triv_mask: 0000000000000000
    int value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_update_ZaomiQxziP7
                                #define DEF_update_ZaomiQxziP7
inline static int update_Zaom(const int v, /*3:3*/ Container_tkpz& container)
{
    return (container.value = v);
}
                                #endif

                                #ifndef DEF___eDyNjrHDIB9
                                #define DEF___eDyNjrHDIB9
inline static int _eDyN(const int v, /*7:7*/ Container_tkpz& container)
{
    return update_Zaom((v - 10), container);
}
                                #endif

                                #ifndef DEF_visit_OpIQrW0RQ4f
                                #define DEF_visit_OpIQrW0RQ4f
inline static void visit_OpIQ(/*3:3*/ Container_tkpz& container)
{
    _eDyN(container.value, container);
}
                                #endif

static Container_tkpz init_MbR9(Container_tkpz&& c)
{
    visit_OpIQ(c);
    return c;
}

int fu_MAIN()
{
    const Container_tkpz c = init_MbR9(Container_tkpz { 10 });
    const int /*c*/ v = c.value;
    return v;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

========

        struct RawSet { ints: int[] };

        fn each(using ref _: RawSet, fn) {
            for (mut i = ints.len; i --> 0; ) {
                fn remove() {
                    ints.splice(i, 1);
                    continue;
                }

                fn(ints[i], ?:fn remove);
            }
        }


        struct LocidSet { raw_set: RawSet };

        fn each(using ref _: LocidSet, offset: int, fn)
            raw_set.each: |item, remove|
                fn(item + offset, ?:fn remove);


        fn sum(locids: LocidSet, offset: int) {
            mut sum = 0;
            locids.each(:offset): |item| sum += item;
            return sum;
        }

        fn main() {
            mut locids = LocidSet(RawSet([ 1, 2, 3 ]));
            mut sum = locids.sum(offset: 10);

            locids.each(offset: 10): |item, remove| {
                if (item & 1) remove();
                sum -= item;
            }

            return locids.raw_set.ints == [ 2 ] && sum == 11 + 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct LocidSet_e9pQ;
struct RawSet_gj2H;

                                #ifndef DEF_RawSet_gj2HrXwegJ2
                                #define DEF_RawSet_gj2HrXwegJ2
struct RawSet_gj2H
{
                                // shape_hash:    aafd08648506ccf1
                                // non_triv_mask: 0008000000400000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidSet_e9pQCUKuMKa
                                #define DEF_LocidSet_e9pQCUKuMKa
struct LocidSet_e9pQ
{
                                // shape_hash:    0e7b2d29d51d34d7
                                // non_triv_mask: 0008000010400000
    RawSet_gj2H raw_set;
    explicit operator bool() const noexcept
    {
        return false
            || raw_set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int item, /*3:3*/ int& sum)
{
    return (sum += item);
}
                                #endif

                                #ifndef DEF___FboOmYhXz85
                                #define DEF___FboOmYhXz85
inline static int _FboO(const int item, /*F:F*/ const int offset, /*F:F*/ int& sum)
{
    return _5aAg((item + offset), sum);
}
                                #endif

                                #ifndef DEF_each_B9O8vVP02J9
                                #define DEF_each_B9O8vVP02J9
inline static void each_B9O8(/*F:F*/ const RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
        _FboO(_.ints[i], offset, sum);

}
                                #endif

                                #ifndef DEF_each_iyM8D1GPPg2
                                #define DEF_each_iyM8D1GPPg2
inline static void each_iyM8(/*F:F*/ const LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_B9O8(_.raw_set, offset, sum);
}
                                #endif

static int sum_MbR9(/*3:3*/ const LocidSet_e9pQ& locids, const int offset)
{
    int sum = 0;
    each_iyM8(locids, offset, sum);
    return sum;
}

                                #ifndef DEF_each_LSVEQGzaJqi
                                #define DEF_each_LSVEQGzaJqi
inline static void each_LSVE(/*F:3*/ RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
    {
        const int /*_|static*/ item = _.ints[i];
        const int item_1 = (item + offset);
        if (item_1 & 1)
            _.ints.splice(i, 1);
        else
            sum -= item_1;

    };
}
                                #endif

                                #ifndef DEF_each_G6pYyu44Evb
                                #define DEF_each_G6pYyu44Evb
inline static void each_G6pY(/*D:5*/ LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_LSVE(_.raw_set, offset, sum);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    LocidSet_e9pQ locids = LocidSet_e9pQ { RawSet_gj2H { fu::vec<int> {{ 1, 2, 3 }} } };
    int sum = sum_MbR9(locids, 10);
    each_G6pY(locids, 10, sum);
    if ((locids.raw_set.ints == fu::view<int> {{ 2 }}) && (sum == (11 + 13)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct RawSet { ints: int[] };

        fn each(using ref _: RawSet, fn) {
            for (mut i = ints.len; i --> 0; ) {
                fn remove() {
                    ints.splice(i, 1);
                    continue;
                }

                fn(ints[i], ?:fn remove);
            }
        }


        struct LocidSet { raw_set: RawSet };

        fn each(using ref _: LocidSet, offset: int, fn)
            raw_set.each: |item, remove|
                fn(item + offset, ?:fn remove);

        pub import _0;
        fn sum(locids: LocidSet, offset: int) {
            mut sum = 0;
            locids.each(:offset): |item| sum += item;
            return sum;
        }

        fn main() {
            mut locids = LocidSet(RawSet([ 1, 2, 3 ]));
            mut sum = locids.sum(offset: 10);

            locids.each(offset: 10): |item, remove| {
                if (item & 1) remove();
                sum -= item;
            }

            return locids.raw_set.ints == [ 2 ] && sum == 11 + 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct LocidSet_e9pQ;
struct RawSet_gj2H;

                                #ifndef DEF_RawSet_gj2HrXwegJ2
                                #define DEF_RawSet_gj2HrXwegJ2
struct RawSet_gj2H
{
                                // shape_hash:    aafd08648506ccf1
                                // non_triv_mask: 0008000000400000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidSet_e9pQCUKuMKa
                                #define DEF_LocidSet_e9pQCUKuMKa
struct LocidSet_e9pQ
{
                                // shape_hash:    0e7b2d29d51d34d7
                                // non_triv_mask: 0008000010400000
    RawSet_gj2H raw_set;
    explicit operator bool() const noexcept
    {
        return false
            || raw_set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int item, /*3:3*/ int& sum)
{
    return (sum += item);
}
                                #endif

                                #ifndef DEF___FboOmYhXz85
                                #define DEF___FboOmYhXz85
inline static int _FboO(const int item, /*F:F*/ const int offset, /*F:F*/ int& sum)
{
    return _5aAg((item + offset), sum);
}
                                #endif

                                #ifndef DEF_each_B9O8vVP02J9
                                #define DEF_each_B9O8vVP02J9
inline void each_B9O8(/*F:F*/ const RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
        _FboO(_.ints[i], offset, sum);

}
                                #endif

                                #ifndef DEF_each_iyM8D1GPPg2
                                #define DEF_each_iyM8D1GPPg2
inline void each_iyM8(/*F:F*/ const LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_B9O8(_.raw_set, offset, sum);
}
                                #endif

static int sum_LtD7(/*3:3*/ const LocidSet_e9pQ& locids, const int offset)
{
    int sum = 0;
    each_iyM8(locids, offset, sum);
    return sum;
}

                                #ifndef DEF_each_LSVEQGzaJqi
                                #define DEF_each_LSVEQGzaJqi
inline void each_LSVE(/*F:3*/ RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
    {
        const int /*_|static*/ item = _.ints[i];
        const int item_1 = (item + offset);
        if (item_1 & 1)
            _.ints.splice(i, 1);
        else
            sum -= item_1;

    };
}
                                #endif

                                #ifndef DEF_each_G6pYyu44Evb
                                #define DEF_each_G6pYyu44Evb
inline void each_G6pY(/*D:5*/ LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_LSVE(_.raw_set, offset, sum);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    LocidSet_e9pQ locids = LocidSet_e9pQ { RawSet_gj2H { fu::vec<int> {{ 1, 2, 3 }} } };
    int sum = sum_LtD7(locids, 10);
    each_G6pY(locids, 10, sum);
    if ((locids.raw_set.ints == fu::view<int> {{ 2 }}) && (sum == (11 + 13)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct RawSet { ints: int[] };

        fn each(using ref _: RawSet, fn) {
            for (mut i = ints.len; i --> 0; ) {
                fn remove() {
                    ints.splice(i, 1);
                    continue;
                }

                fn(ints[i], ?:fn remove);
            }
        }

        pub import _0;
        struct LocidSet { raw_set: RawSet };

        fn each(using ref _: LocidSet, offset: int, fn)
            raw_set.each: |item, remove|
                fn(item + offset, ?:fn remove);


        fn sum(locids: LocidSet, offset: int) {
            mut sum = 0;
            locids.each(:offset): |item| sum += item;
            return sum;
        }

        fn main() {
            mut locids = LocidSet(RawSet([ 1, 2, 3 ]));
            mut sum = locids.sum(offset: 10);

            locids.each(offset: 10): |item, remove| {
                if (item & 1) remove();
                sum -= item;
            }

            return locids.raw_set.ints == [ 2 ] && sum == 11 + 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct LocidSet_e9pQ;
struct RawSet_gj2H;

                                #ifndef DEF_RawSet_gj2HrXwegJ2
                                #define DEF_RawSet_gj2HrXwegJ2
struct RawSet_gj2H
{
                                // shape_hash:    aafd08648506ccf1
                                // non_triv_mask: 0008000000400000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidSet_e9pQCUKuMKa
                                #define DEF_LocidSet_e9pQCUKuMKa
struct LocidSet_e9pQ
{
                                // shape_hash:    0e7b2d29d51d34d7
                                // non_triv_mask: 0008000010400000
    RawSet_gj2H raw_set;
    explicit operator bool() const noexcept
    {
        return false
            || raw_set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int item, /*3:3*/ int& sum)
{
    return (sum += item);
}
                                #endif

                                #ifndef DEF___FboOmYhXz85
                                #define DEF___FboOmYhXz85
inline static int _FboO(const int item, /*F:F*/ const int offset, /*F:F*/ int& sum)
{
    return _5aAg((item + offset), sum);
}
                                #endif

                                #ifndef DEF_each_B9O8vVP02J9
                                #define DEF_each_B9O8vVP02J9
inline void each_B9O8(/*F:F*/ const RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
        _FboO(_.ints[i], offset, sum);

}
                                #endif

                                #ifndef DEF_each_iyM8D1GPPg2
                                #define DEF_each_iyM8D1GPPg2
inline static void each_iyM8(/*F:F*/ const LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_B9O8(_.raw_set, offset, sum);
}
                                #endif

static int sum_LtD7(/*3:3*/ const LocidSet_e9pQ& locids, const int offset)
{
    int sum = 0;
    each_iyM8(locids, offset, sum);
    return sum;
}

                                #ifndef DEF_each_LSVEQGzaJqi
                                #define DEF_each_LSVEQGzaJqi
inline void each_LSVE(/*F:3*/ RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
    {
        const int /*_|static*/ item = _.ints[i];
        const int item_1 = (item + offset);
        if (item_1 & 1)
            _.ints.splice(i, 1);
        else
            sum -= item_1;

    };
}
                                #endif

                                #ifndef DEF_each_G6pYyu44Evb
                                #define DEF_each_G6pYyu44Evb
inline static void each_G6pY(/*D:5*/ LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_LSVE(_.raw_set, offset, sum);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    LocidSet_e9pQ locids = LocidSet_e9pQ { RawSet_gj2H { fu::vec<int> {{ 1, 2, 3 }} } };
    int sum = sum_LtD7(locids, 10);
    each_G6pY(locids, 10, sum);
    if ((locids.raw_set.ints == fu::view<int> {{ 2 }}) && (sum == (11 + 13)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        struct RawSet { ints: int[] };

        fn each(using ref _: RawSet, fn) {
            for (mut i = ints.len; i --> 0; ) {
                fn remove() {
                    ints.splice(i, 1);
                    continue;
                }

                fn(ints[i], ?:fn remove);
            }
        }

        pub import _0;
        struct LocidSet { raw_set: RawSet };

        fn each(using ref _: LocidSet, offset: int, fn)
            raw_set.each: |item, remove|
                fn(item + offset, ?:fn remove);

        pub import _1;
        fn sum(locids: LocidSet, offset: int) {
            mut sum = 0;
            locids.each(:offset): |item| sum += item;
            return sum;
        }

        fn main() {
            mut locids = LocidSet(RawSet([ 1, 2, 3 ]));
            mut sum = locids.sum(offset: 10);

            locids.each(offset: 10): |item, remove| {
                if (item & 1) remove();
                sum -= item;
            }

            return locids.raw_set.ints == [ 2 ] && sum == 11 + 13 ? 0 : 1;
        }

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
#include <fu/vec.h>
#include <fu/view.h>

struct LocidSet_e9pQ;
struct RawSet_gj2H;

                                #ifndef DEF_RawSet_gj2HrXwegJ2
                                #define DEF_RawSet_gj2HrXwegJ2
struct RawSet_gj2H
{
                                // shape_hash:    aafd08648506ccf1
                                // non_triv_mask: 0008000000400000
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_LocidSet_e9pQCUKuMKa
                                #define DEF_LocidSet_e9pQCUKuMKa
struct LocidSet_e9pQ
{
                                // shape_hash:    0e7b2d29d51d34d7
                                // non_triv_mask: 0008000010400000
    RawSet_gj2H raw_set;
    explicit operator bool() const noexcept
    {
        return false
            || raw_set
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF___5aAgpq5aUK5
                                #define DEF___5aAgpq5aUK5
inline static int _5aAg(const int item, /*3:3*/ int& sum)
{
    return (sum += item);
}
                                #endif

                                #ifndef DEF___FboOmYhXz85
                                #define DEF___FboOmYhXz85
inline static int _FboO(const int item, /*F:F*/ const int offset, /*F:F*/ int& sum)
{
    return _5aAg((item + offset), sum);
}
                                #endif

                                #ifndef DEF_each_B9O8vVP02J9
                                #define DEF_each_B9O8vVP02J9
inline void each_B9O8(/*F:F*/ const RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
        _FboO(_.ints[i], offset, sum);

}
                                #endif

                                #ifndef DEF_each_iyM8D1GPPg2
                                #define DEF_each_iyM8D1GPPg2
inline void each_iyM8(/*F:F*/ const LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_B9O8(_.raw_set, offset, sum);
}
                                #endif

static int sum_WLF9(/*3:3*/ const LocidSet_e9pQ& locids, const int offset)
{
    int sum = 0;
    each_iyM8(locids, offset, sum);
    return sum;
}

                                #ifndef DEF_each_LSVEQGzaJqi
                                #define DEF_each_LSVEQGzaJqi
inline void each_LSVE(/*F:3*/ RawSet_gj2H& _, /*F:F*/ const int offset, /*F:A*/ int& sum)
{
    for (int i = _.ints.size(); i-- > 0; )
    {
        const int /*_|static*/ item = _.ints[i];
        const int item_1 = (item + offset);
        if (item_1 & 1)
            _.ints.splice(i, 1);
        else
            sum -= item_1;

    };
}
                                #endif

                                #ifndef DEF_each_G6pYyu44Evb
                                #define DEF_each_G6pYyu44Evb
inline void each_G6pY(/*D:5*/ LocidSet_e9pQ& _, const int offset, /*D:C*/ int& sum)
{
    each_LSVE(_.raw_set, offset, sum);
}
                                #endif

                                #ifndef DEF_x3Cx3E_odNTdyipeEj
                                #define DEF_x3Cx3E_odNTdyipeEj
inline int x3Cx3E_odNT(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2Y4mQlK2igg
                                #define DEF_x3Cx3E_2Y4mQlK2igg
inline int x3Cx3E_2Y4m(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    int cmp = x3Cx3E_odNT(a.size(), b.size());
    bool quick {};
    quick = a.m_data == b.m_data || cmp;
    if (quick)
        return cmp;
    else
    {
        for (int i = 0; (i < a.size()) && !cmp; i++)
            cmp = x3Cx3E_odNT(a[i], b[i]);

        return cmp;
    };
}
                                #endif

                                #ifndef DEF_x3Dx3D_6FHvHhhLe8k
                                #define DEF_x3Dx3D_6FHvHhhLe8k
inline bool operator==(/*3:3*/ fu::view<int> a, /*3:3*/ fu::view<int> b)
{
    return !x3Cx3E_2Y4m(a, b);
}
                                #endif

int fu_MAIN()
{
    LocidSet_e9pQ locids = LocidSet_e9pQ { RawSet_gj2H { fu::vec<int> {{ 1, 2, 3 }} } };
    int sum = sum_WLF9(locids, 10);
    each_G6pY(locids, 10, sum);
    if ((locids.raw_set.ints == fu::view<int> {{ 2 }}) && (sum == (11 + 13)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

========

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn validate_looks_pure() {
            pretend_pure(1);
            return pretend_pure(2);
        }

        fn main() validate_looks_pure() == 102 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int pretend_pure_MbR9(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int validate_looks_pure_MbR9()
{
    return pretend_pure_MbR9(2);
}

int fu_MAIN()
{
    if (validate_looks_pure_MbR9() == 102)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

========

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn licm_loop_preheader(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++)
            on enter {
                let must_hoist = pretend_pure(n);
            }
            then {
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_loop_preheader(2) == 204 ? 0 : 1;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----

#ifndef fu_NO_fdefs

static int pretend_pure_MbR9(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int licm_loop_preheader_MbR9(const int n)
{
    int res = 0;
    int must_hoist;

    {
        int i = 0;
        if (i < n)
        {
            must_hoist = pretend_pure_MbR9(n);
            do
                res += must_hoist;
            while (i++, (i < n));
        };
    };
    return res;
}

int fu_MAIN()
{
    if (licm_loop_preheader_MbR9(2) == 204)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

========

        struct Hello { v: i32 }
        test a_simple_test() {

            assert(!!Hello().v)     
        }

        fn main() _0::Hello().v;

---- <fail> ----
Testsuite failed: _0.fu

   TEST a_simple_test ...
Assertion failed: (!!Hello_KlJ1{}.v), function a_simple_test_MbR9, file 5460066b67d20cdb-1287.cpp, line 36.

	Generated code:

#include <fu/mem/arc.cpp>

// TODO modularize this, we don't want parfor & hotswap
//  unless your project uses them, we could use pragma sources()
//   or a new pragma runtime() for this.

#include <fu/decstr.cpp>
#include <fu/never.cpp>
#include <fu/print.cpp>
#include <fu/mem/memswap.cpp>

#include <dl/hotswap.cpp>
#include <par/parfor.cpp>

                                #ifdef fu_TESTSUITE
#undef NDEBUG
                                #endif
#include <stdio.h>
#include <fu/assert.h>

                                #ifdef fu_TESTSUITE
struct Hello_KlJ1;
                                #endif
                                #ifdef fu_TESTSUITE
                                #endif
                                #ifdef fu_TESTSUITE

                                #ifndef DEF_Hello_KlJ1P9gU4Jf
                                #define DEF_Hello_KlJ1P9gU4Jf
struct Hello_KlJ1
{
                                // shape_hash:    00870afca4dde27b
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif
                                #endif

#ifndef fu_NO_fdefs
                                #ifdef fu_TESTSUITE

void a_simple_test_MbR9()
{
    fu_ASSERT(!!Hello_KlJ1{}.v);
}
                                #endif

#endif

                                #ifdef fu_TESTSUITE
int main()
{
    puts("   TEST a_simple_test ...");
    a_simple_test_MbR9();
    puts("    ... a_simple_test OK\n");

    return 0;
}
                                #endif

   EXIT code: 6
========

        struct Hello { v: i32 }
        test a_simple_test() {

            assert(!Hello().v)      
        }

        fn main() _0::Hello().v;

---- [ status(0) uniq_bytes(0) uniq_count(0) arc_bytes(0) arc_count(0) ] ----
struct Hello_KlJ1;

                                #ifndef DEF_Hello_KlJ1P9gU4Jf
                                #define DEF_Hello_KlJ1P9gU4Jf
struct Hello_KlJ1
{
                                // shape_hash:    00870afca4dde27b
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return Hello_KlJ1{}.v;
}

#endif

int main() { return fu_MAIN(); }
                                #ifdef fu_TESTSUITE
#undef NDEBUG
                                #endif
#include <stdio.h>
#include <fu/assert.h>

                                #ifdef fu_TESTSUITE
struct Hello_KlJ1;
                                #endif
                                #ifdef fu_TESTSUITE
                                #endif
                                #ifdef fu_TESTSUITE

                                #ifndef DEF_Hello_KlJ1P9gU4Jf
                                #define DEF_Hello_KlJ1P9gU4Jf
struct Hello_KlJ1
{
                                // shape_hash:    00870afca4dde27b
                                // non_triv_mask: 0000000000000000
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif
                                #endif

#ifndef fu_NO_fdefs
                                #ifdef fu_TESTSUITE

void a_simple_test_MbR9()
{
    fu_ASSERT(!Hello_KlJ1{}.v);
}
                                #endif

#endif

                                #ifdef fu_TESTSUITE
int main()
{
    puts("   TEST a_simple_test ...");
    a_simple_test_MbR9();
    puts("    ... a_simple_test OK\n");

    return 0;
}
                                #endif

========
