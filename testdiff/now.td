
        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };
        fn main() {
            infix fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i); // its hard to defend this -
            _0::template_add(HasInt(1), HasInt(2)).i - 3;       //  the thing above works but this doesn't.
        }                                                       //   given the autoshadowing, we might just want to allow everything.

-----
TODO: [0m_0[2m.fu 2:33+1[0m:

[2m      | [0m
[2m    2 | [0m        fn template_add(a, b) a [31;1m+[0m b;
[2m      | [0m

	Bad call to [34;1m+[0m with args (HasInt copy, HasInt copy): 

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    No body pattern matched.

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mtemplate_add[0m(HasInt, HasInt) at [2m[0m_0[2m.fu 2:12+12[0m
                [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----


        // TODO remove this, currently gets repeatedly
        //  rebuilt & rejected because of -Werror
        pragma emit(`#pragma GCC diagnostic ignored "-Wpragmas"`);
        pragma emit(`#pragma GCC diagnostic ignored "-Winfinite-recursion"`);

        fn infRec(x: i32) {
            if (x > 1)
                return infRec(x - 1);
            else                        <fail infinite recur X:X>
                return infRec(x + 1);   <pass/>
                return x;               </fail>
        }

        fn main() infRec(1);

-----
TODO: <fail> mismatch:

    Expected error keyword:
        [31;1mX:X[0m from pattern <fail[31;1m infinite recur X:X[0m>

    ... not present in error message:

   EXIT code: 4

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu


	Generated code:

#include <fu/never.h>

[[noreturn]] static fu::never infRec_1WsbUdat(int);
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Winfinite-recursion"

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never infRec_1WsbUdat(const int x)
{
    if (x > 1)
        infRec_1WsbUdat((x - 1));
    else
        infRec_1WsbUdat((x + 1));

}

[[noreturn]] fu::never fu_MAIN()
{
    infRec_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        struct Ephemeral {
            id:             i32;
            scope_skip?:    Ephemeral[];
        };

        struct SolverState {
            _scope_skip:    Ephemeral[];
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint
            eph.scope_skip = <alt>s._scope_skip<alt/>indirect_copy(s._scope_skip)</alt>;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.len - 3;
        }

        noinline fn indirect_copy!<T>(arr: T[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
TODO: [0m_0[2m.fu 14:46+11[0m:

[2m      |         fn snap(i: i32, ref s: SolverState) {[0m
[2m      |             ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint[0m
[2m   14 | [0m            eph.scope_skip = indirect_copy(s.[31;1m_scope_skip[0m);
[2m      |             return eph;[0m
[2m      |         }[0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m30:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   30 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1meph[0m at [2m13:17+3[0m:

[2m      | [0m
[2m      |         fn snap(i: i32, ref s: SolverState) {[0m
[2m   13 | [0m            ref [31;1meph[0m        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint
[2m      |             eph.scope_skip = indirect_copy(s._scope_skip);[0m
[2m      |             return eph;[0m

	Both refer to: [35;1mref arg[0m [34;1ms[0m at [2m12:29+1[0m:

[2m      |         };[0m
[2m      | [0m
[2m   12 | [0m        fn snap(i: i32, ref [31;1ms[0m: SolverState) {
[2m      |             ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint[0m
[2m      |             eph.scope_skip = indirect_copy(s._scope_skip);[0m


RelaxCopyResize [35;1mfn[0m [34;1msnap[0m(i32, SolverState) at [2m12:12+4[0m

-----

        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        return x["hello"] - x["world"] + 1;

-----
TODO: [0m_0[2m.fu 5:19+1[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut x: Map[31;1m([0mstring, i32);
[2m      | [0m
[2m      |         x["hello"] = 1;[0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, i32 copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        let b = "hello world";
        mut offset = 0;

        fn pop(): string {
            mut a = "";

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a ~= c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;

-----
TODO: [0m_0[2m.fu 5:19+1[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut x: Map[31;1m([0mstring, i32);
[2m      | [0m
[2m      |         x["hello"] = 1;[0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, i32 copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        fn test(a = 3, b = a * 2) a + b;
        fn main() test + test(a: -1) * 3;

-----
TODO: [0m_0[2m.fu 3:19+4[0m:

[2m      | [0m
[2m      |         fn test(a = 3, b = a * 2) a + b;[0m
[2m    3 | [0m        fn main() [31;1mtest[0m + test(a: -1) * 3;
[2m      | [0m

	No implicit [31;1m`1111[0m: i32 copy in scope, needed to call [35;1marg[0m [34;1ma[0m:


        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn solve(root: Node)
        {
            mut _t_bool: Type;

            fn createBool(value: string, type = t_bool)
                return SolvedNode(:value, :type);

            fn solveNode(node: Node)
                return node.kind == "bool"
                    && createBool(:node.value);

            fn t_bool()
                return _t_bool ||= Type("t_bool");

            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>

struct s_SolvedNode;
struct s_Type;
struct s_Node;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str value;
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || value
            || type
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str kind;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static s_Type& t_bool_bxx8eI2b(s_Type& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = s_Type { "t_bool"_fu });
}

static s_SolvedNode createBool_FmeucPGh(const fu::str& value, const s_Type& type)
{
    return s_SolvedNode { fu::str(value), s_Type(type) };
}

static s_SolvedNode solveNode_D4K66ckX(const s_Node& node, s_Type& _t_bool)
{
    if (node.kind == "bool"_fu)
        return createBool_FmeucPGh(node.value, t_bool_bxx8eI2b(_t_bool));
    else
    {
        return s_SolvedNode{};
    };
}

static s_SolvedNode solve_SAaFebif(const s_Node& root)
{
    s_Type _t_bool {};
    return solveNode_D4K66ckX(root, _t_bool);
}

int fu_MAIN()
{
    s_SolvedNode s = solve_SAaFebif(s_Node { "bool"_fu, "Hello!"_fu });
    if ((s.value == "Hello!"_fu) && (s.type.canon == "t_bool"_fu))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedImplicit

-----

        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn solve(root: Node)
        {
            mut _t_bool: Type;

            fn createBool(value: string, type = t_bool)
                return SolvedNode(:value, :type);

            fn solveNode(node: Node)
                return node.kind == "bool"
                    && createBool(:node.value);
    <alt>
            fn solveNode(canon: string)
                return Type(:canon);

            fn t_bool()
                return _t_bool ||= solveNode("t_bool");
    <alt/>
            fn t_bool()
                return _t_bool ||= Type("t_bool");
    </alt>
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 15:34+1[0m:

[2m      |             fn solveNode(node: Node)[0m
[2m      |                 return node.kind == "bool"[0m
[2m   15 | [0m                    && createBool[31;1m([0m:node.value);
[2m      | [0m
[2m      |             fn solveNode(canon: string)[0m

	Bad call to [34;1mcreateBool[0m with args (string copy resize): 

	[35;1mfn[0m [34;1mprep createBool[0m at [2m10:16+10[0m:
[2m   10 | [0m            fn [31;1mcreateBool[0m(value: string, type = t_bool)

	    Declaration cycle, signature not yet available.

	    To fix this, you might need to shuffle functions around
		until every dependency (type annot or arg default expr)
		of [35;1mfn[0m [34;1mprep createBool[0m is declared above it.

	    This borders on a compiler bug, sorry about it,
		we gotta come up with a better solve order algorithm.

        Solving [35;1mfn[0m [34;1msolveNode[0m(Node) at [2m13:16+9[0m
                [35;1mfn[0m [34;1mt_bool[0m at [2m20:16+6[0m
                [35;1mfn[0m [34;1msolve[0m(Node) at [2m6:12+5[0m

-----

        mut m: Map(string, string);
        mut g = 0;

        m["hello"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g;

-----
TODO: [0m_0[2m.fu 5:19+1[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut m: Map[31;1m([0mstring, string);
[2m      |         mut g = 0;[0m
[2m      | [0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, string copy resize Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        mut m: Map(string, string);
        mut g = 0;

        m["_not_hello_"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g - 1;

-----
TODO: [0m_0[2m.fu 5:19+1[0m:

[2m      | fn main(): i32 {[0m
[2m      | [0m
[2m    5 | [0m        mut m: Map[31;1m([0mstring, string);
[2m      |         mut g = 0;[0m
[2m      | [0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, string copy resize Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);

            test(ab.a, ab.b);

            return ab.b - 5;
        }

-----
struct s_AB;

                                #ifndef DEF_s_AB
                                #define DEF_s_AB
struct s_AB
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_qg01zOoD(int& a, int& b)
{
    a += b;
    b += a;
}

int fu_MAIN()
{
    s_AB ab = s_AB { 1, 2 };
    test_qg01zOoD(ab.a, ab.b);
    return ab.b - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);

            ref a = ab.a;
            test(a, ab.b);

            return ab.b - 5;
        }

-----
struct s_AB;

                                #ifndef DEF_s_AB
                                #define DEF_s_AB
struct s_AB
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_qg01zOoD(int& a, int& b)
{
    a += b;
    b += a;
}

int fu_MAIN()
{
    s_AB ab = s_AB { 1, 2 };
    int& /*ab*/ a = ab.a;
    test_qg01zOoD(a, ab.b);
    return ab.b - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);
            <alt>
            ref a = ab.a;
            ref b = ab.b;
            test(a, b);
            <alt/>
            ref a = ab.a;
            test(a, ab.b);
            <alt/>
            test(ab.a, ab.b);
            </alt>
            return ab.b - 5;
        }

-----
TODO: [0m_0[2m.fu 14:21+1[0m:

[2m      |             ref a = ab.a;[0m
[2m      |             ref b = ab.b;[0m
[2m   14 | [0m            test(a, [31;1mb[0m);
[2m      | [0m
[2m      |             return ab.b - 5;[0m

	At call to [35;1mfn[0m [34;1mtest[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mtest[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1mtest[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mab[0m at [2m10:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   10 | [0m            mut [31;1mab[0m = AB(1, 2);
[2m      | [0m
[2m      |             ref a = ab.a;[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mtest[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mtest[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m9:12+4[0m

-----

        struct Helper { vars: i32[]; };

        fn test(ref _helpers: Helper[], helpers_idx: i32) {
            ref old = _helpers[helpers_idx - 1].vars;
            ref new = _helpers[helpers_idx    ].vars;
            new    ~= old[helpers_idx];
        }

        fn main() {
            mut helpers = [ Helpers([ 1, 2 ]), Helpers([ 4, 8 ]) ];
            test(helpers, 1);
            return helpers[1][2] - 2;
        }

-----
TODO: [0m_0[2m.fu 7:23+3[0m:

[2m      |             ref old = _helpers[helpers_idx - 1].vars;[0m
[2m      |             ref new = _helpers[helpers_idx    ].vars;[0m
[2m    7 | [0m            new    ~= [31;1mold[0m[helpers_idx];
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mold[0m, reference invalidated by write to [35;1mref arg[0m [34;1m_helpers[0m at [2m6:31+1[0m:

[2m      |         fn test(ref _helpers: Helper[], helpers_idx: i32) {[0m
[2m      |             ref old = _helpers[helpers_idx - 1].vars;[0m
[2m    6 | [0m            ref new = _helpers[31;1m[[0mhelpers_idx    ].vars;
[2m      |             new    ~= old[helpers_idx];[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
.mutref[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(Helper[:], i32) at [2m4:12+4[0m

-----

        nocopy struct Woot {
            x: i32[];
            y: i32[];
        };

        fn test(ref w: Woot) {
            ref x = w.x;
            //*F
            ref y = w.x;
            /*/
            ref y = w.y;
            //*/
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w: Woot;
            test(w);
            return w.x.len;
        }

-----
TODO: [0m_0[2m.fu 15:13+1[0m:

[2m      |             //*/[0m
[2m      |             y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let[0m
[2m   15 | [0m            [31;1mx[0m ~= y;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mx[0m, reference invalidated by write to [35;1mref[0m [34;1my[0m at [2m14:15+2[0m:

[2m      |             ref y = w.y;[0m
[2m      |             //*/[0m
[2m   14 | [0m            y [31;1m~=[0m y; // <- DONT RESOLVE BY COPY! ref can relax to let
[2m      |             x ~= y;[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(Woot) at [2m7:12+4[0m

-----

        nocopy struct Woot {
            x: i32[];
            y: i32[];
        };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;
            //*F
            ref y = w1.x;
            /*/
            ref y = w1.y;
            //*/
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }

-----
TODO: [0m_0[2m.fu 20:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut w: Woot;[0m
[2m   20 | [0m            test(w, [31;1mw[0m);
[2m      |             return w.x.len;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mtest[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mtest[0m:[34;1mw1[0m and
	    1:	[35;1mref arg[0m [34;1mtest[0m:[34;1mw0[0m

	    both alias:

	    [35;1mvar[0m [34;1mw[0m at [2m19:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   19 | [0m            mut [31;1mw[0m: Woot;
[2m      |             test(w, w);[0m
[2m      |             return w.x.len;[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mtest[0m:[34;1mw1[0m is non-copyable: Woot mutref

	    [35;1mref arg[0m [34;1mtest[0m:[34;1mw0[0m is non-copyable: Woot mutref

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m18:12+4[0m

-----


        struct X { items: i32[]; };
        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static
        fn main() popfirst([ X() ]).items.len;

-----
#include <fu/vec.h>

struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_X popfirst_bTLmtFWO(fu::vec<s_X>&& arr)
{
    return s_X(arr[0]);
}

int fu_MAIN()
{
    return popfirst_bTLmtFWO(fu::vec<s_X> { fu::slate<1, s_X> { s_X{} } }).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        <alt>
        nocopy
        </alt>
        struct X { items: i32[]; };
        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static
        fn main() popfirst([ X() ]).items.len;

-----
TODO: [0m_0[2m.fu 6:38+1[0m:

[2m      | [0m
[2m      |         struct X { items: i32[]; };[0m
[2m    6 | [0m        fn popfirst(mut arr: X[]) arr[31;1m[[0m0]; // mcom_BlockReturn after relax: arr[] adds 'static
[2m      |         fn main() popfirst([ X() ]).items.len;[0m
[2m      | [0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1m__native[0m [34;1m[][0m) -> X { 2 }

RelaxCopyResize [35;1mfn[0m [34;1mpopfirst[0m(X[:]) at [2m6:12+8[0m

-----

        fn Swap(ref arr: i32[], x: i32, y: i32)
            swap(arr[x], arr[y]);

        fn main() {
            mut a = [ 1, 2 ];
            a.Swap(0, 1);
            return a[0] - 2 == 0 && a[1] - 1 == 0 ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 3:17+1[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            swap[31;1m([0marr[x], arr[y]);
[2m      | [0m
[2m      |         fn main() {[0m

	At call to [35;1m__native[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m, binding for [35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1ma[0m (arg #0) at [2m3:21+1[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            swap(arr[31;1m[[0mx], arr[y]);
[2m      | [0m
[2m      |         fn main() {[0m

	... invalidated by subsequent write to [35;1mref arg[0m [34;1marr[0m upon evaluation of [35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1mb[0m (arg #1) at [2m3:29+1[0m:

[2m      | [0m
[2m      |         fn Swap(ref arr: i32[], x: i32, y: i32)[0m
[2m    3 | [0m            swap(arr[x], arr[31;1m[[0my]);
[2m      | [0m
[2m      |         fn main() {[0m

	At call to [35;1m__native[0m [34;1m
.mutref[0m

    BorrowCheck [35;1mfn[0m [34;1mSwap[0m(i32[:], i32, i32) at [2m2:12+4[0m

-----

        fn hello(ref arr: i32[], ref item: i32)
            arr ~= ++item;

        fn ret_last(ref arr: i32[])
            arr[arr.len - 1];

        fn concat_self_ret_last(ref arr: i32[])
            ret_last(arr ~= arr)

        fn main() {
            mut arr = [ 1, 2, 3 ];
            hello(arr, concat_self_ret_last(arr));
            return ret_last(arr) - 4;
        }

-----
TODO: [0m_0[2m.fu 13:18+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            hello[31;1m([0marr, concat_self_ret_last(arr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mhello[0m, binding for [35;1mref arg[0m [34;1mhello[0m:[34;1marr[0m (arg #0) at [2m13:19+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            hello([31;1marr[0m, concat_self_ret_last(arr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	... invalidated by subsequent write to [35;1mvar[0m [34;1marr[0m upon evaluation of [35;1mref arg[0m [34;1mhello[0m:[34;1mitem[0m (arg #1) at [2m13:44+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 1, 2, 3 ];[0m
[2m   13 | [0m            hello(arr, concat_self_ret_last[31;1m([0marr));
[2m      |             return ret_last(arr) - 4;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mconcat_self_ret_last[0m
            via [35;1mfn[0m [34;1mret_last[0m at [2m9:21+1[0m:

[2m      | [0m
[2m      |         fn concat_self_ret_last(ref arr: i32[])[0m
[2m    9 | [0m            ret_last[31;1m([0marr ~= arr)
[2m      | [0m
[2m      |         fn main() {[0m

            via [35;1m__native[0m [34;1m
.mutref[0m at [2m6:16+1[0m:

[2m      | [0m
[2m      |         fn ret_last(ref arr: i32[])[0m
[2m    6 | [0m            arr[31;1m[[0marr.len - 1];
[2m      | [0m
[2m      |         fn concat_self_ret_last(ref arr: i32[])[0m


    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m11:12+4[0m

-----

        fn track_last_loop_confusion(mut a: string, mut b: string)
        {
            for (mut i = 0; i < 6; i++) {
                a ~= a; // foil smallstring opti
                b ~= b; //  both are 64 chars long
            }

            ref x = a.len == 64 ? b : a;
            ref y = b.len == 64 ? x : a; // y points to b two refs deep

            mut result = b; // <-- BROKEN MOVE FROM b HERE

            // once
            for (mut i = result.len / 64; i --> 0; ) {
                y ~= y;         // now 128, ensures y not a view
                result ~= y;    // for a total of 192
            }

            return result;
        }

        fn main() {
            mut res = track_last_loop_confusion("a", "b");
            return res.len == 192 ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 12:26+1[0m:

[2m      |             ref y = b.len == 64 ? x : a; // y points to b two refs deep[0m
[2m      | [0m
[2m   12 | [0m            mut result = [31;1mb[0m; // <-- BROKEN MOVE FROM b HERE
[2m      | [0m
[2m      |             // once[0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mx[0m at [2m9:17+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m    9 | [0m            ref [31;1mx[0m = a.len == 64 ? b : a;
[2m      |             ref y = b.len == 64 ? x : a; // y points to b two refs deep[0m
[2m      | [0m

	Both refer to: [35;1marg[0m [34;1mb[0m at [2m2:57+1[0m:

[2m      | [0m
[2m    2 | [0m        fn track_last_loop_confusion(mut a: string, mut [31;1mb[0m: string)
[2m      |         {[0m
[2m      |             for (mut i = 0; i < 6; i++) {[0m


RelaxCopyResize [35;1mfn[0m [34;1mtrack_last_loop_confusion[0m(string, string) at [2m2:12+25[0m

-----

        struct BINOP {
            P: Map(string, i32);
        };

        fn setupOperators(): BINOP
        {
            mut out: BINOP;

            fn binop(op: string)
                out.P[op] = 7;

            binop(",");

            return out;
        }

        shadow let BINOP = setupOperators();
        let P_COMMA = BINOP.P[","] || assert();

        fn main() P_COMMA - 7;

-----
TODO: [0m_0[2m.fu 3:19+1[0m:

[2m      | [0m
[2m      |         struct BINOP {[0m
[2m    3 | [0m            P: Map[31;1m([0mstring, i32);
[2m      |         };[0m
[2m      | [0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, i32 copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mtype[0m [34;1mBINOP[0m

-----

        struct ValueType { modid: i32; };
        struct Type { using vtype: ValueType; };
        struct Target { modid: i32; index: i32; };
        struct Overload { name: string; id: string; };

        fn GET(target: Target): Overload =
            Overload(
                name: "N" ~ target.index,
                  id: "I" ~ target.index);

        fn main() {
            mut specs: Map(string, Target);

            fn setSpec(mangle: string) {
                ref t = specs[mangle] ||= Target;

                // This template should start expanding on GET(target).name,
                //  which should conflict with overload name.
                fn name(shadow target)
                    GET(target) <fail ambig>
                        .name;  <pass/>
                        .id;    </fail>

                return t.name;
            }

            return setSpec("hey").len - 2;
        }

-----
TODO: <fail> mismatch:

    Expected error keyword:
        [31;1mambig[0m from pattern <fail[31;1m ambig[0m>

    ... not present in error message:

[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 13:27+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   13 | [0m            mut specs: Map[31;1m([0mstring, Target);
[2m      | [0m
[2m      |             fn setSpec(mangle: string) {[0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, Target copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m12:12+4[0m

-----

        fn setupOperators(P_PREFIX_UNARY) // <- template
        {
            struct BINOP {
                PRECEDENCE:     Map(string, i32);
                RIGHT_TO_LEFT:  Map(i32,   bool);
            };

            mut out: BINOP; // <- no BINOP in scope
            mut precedence = P_PREFIX_UNARY;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT[precedence] = rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE[ops[i]] = precedence;
            }

            binop([ "|>" ]);

            //
            return out;
        }

        let BINOP = setupOperators(-1);

        fn main() {
            let precedence = BINOP.PRECEDENCE["|>"];
            return precedence;
        }

-----
TODO: [0m_0[2m.fu 5:36+1[0m:

[2m      |         {[0m
[2m      |             struct BINOP {[0m
[2m    5 | [0m                PRECEDENCE:     Map[31;1m([0mstring, i32);
[2m      |                 RIGHT_TO_LEFT:  Map(i32,   bool);[0m
[2m      |             };[0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, i32 copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mtype[0m [34;1mBINOP_0FVaFei3hMb[0m
                [35;1mfn[0m [34;1msetupOperators[0m(i32) at [2m2:12+14[0m

-----

        struct Context
        {
            fuzzy: Map(string, string);
            files: string[];
        }

        fn resolveFile(
            implicit ctx: &mut Context,
            from: string, name: string): string
        {
            let path    = from ~ name;
            let cached  = ctx.fuzzy[path];
            if (cached)
                return cached == "" ? "" : cached;

            fn tryResolve(): string
            {
                let exists = file::size(path) >= 0;
                if (exists)
                    return path;

                return "";
            };

            let resolve = tryResolve();
            ctx.fuzzy[path] = resolve || "";
            return resolve;
        }

        pub fn resolveFile(
            implicit ctx: &mut Context,
            path: string): string
        {
            let fuzzy = path.find('');
            if (fuzzy > 0)
            {
                let from = path.slice(0, fuzzy);
                let name = path.slice(fuzzy + 1);
                if (from && name && !name.has(''))
                {
                    let res = resolveFile(:from, :name);
                    if (res)
                        return res;

                    // Tests have the files prepopulated,
                    //  we only pay the cost of lookup when about to fail compile.
                    let prepopulated = from ~ name;
                    if (ctx.files.has(prepopulated))
                        return prepopulated;
                }
            }

            return path;
        }

        fn main() {
            implicit mut ctx: Context;
            return resolveFile("a").len - 1;
        }

-----
TODO: [0m_0[2m.fu 4:23+1[0m:

[2m      |         struct Context[0m
[2m      |         {[0m
[2m    4 | [0m            fuzzy: Map[31;1m([0mstring, string);
[2m      |             files: string[];[0m
[2m      |         }[0m

	Bad call to [34;1mMap[0m with args (string copy resize Typename, string copy resize Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mtype[0m [34;1mContext[0m

-----

        fn inline_args_and_closures(inline nums: i32[]) {       ;; GNUStmtExpr
            mut sum: i32;
            noinline fn woot(z: i32)                // previously a new woot was emitter
                for (mut i = 0; i < nums.len; i++)  //  with the nums expr inlined,
                    sum += nums[i] & z;             //   now nums doesnt inline inside woot

            for (mut i = 0; i < nums.len; i++) {
                if (i > 0) woot(nums[i] & nums[i - 1]);         ;; PointlessMustSeq
                if (i > 1) woot(nums[i] & nums[i - 2]);
            }

            return sum;
        }

        fn main() {
            mut x = 0;
            let res = inline_args_and_closures([ x++, x++, x++ ]);
            return x == 93 && res == 290 ? 0 : 1;
        }

-----
TODO:    EXIT code: 256

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu


	Generated code:

#include <fu/view.h>


#ifndef fu_NO_fdefs

static void woot_0PEGCjEV(const int z, fu::view<int> nums, int& sum)
{
    for (int i = 0; i < nums.size(); i++)
        sum += (nums[i] & z);

}

int fu_MAIN()
{
    // Hoisted:
    int sum;

    int x = 0;
    int BL_1_v {};
    const int /*sum*/ res = (__extension__ (
    {
        sum =  {};
        for (int i = 0; i < (fu::slate<3, int> { x++, x++, x++ }).size(); i++)
        {
            if (i > 0)
            {
                int _0 {};
                int _1 {};
                (_1 = (_0 = (fu::slate<3, int> { x++, x++, x++ })[i], (_0 & (fu::slate<3, int> { x++, x++, x++ })[(i - 1)])), woot_0PEGCjEV(_1, (fu::slate<3, int> { x++, x++, x++ }), sum));
            };
            if (i > 1)
            {
                int _2 {};
                int _3 {};
                (_3 = (_2 = (fu::slate<3, int> { x++, x++, x++ })[i], (_2 & (fu::slate<3, int> { x++, x++, x++ })[(i - 2)])), woot_0PEGCjEV(_3, (fu::slate<3, int> { x++, x++, x++ }), sum));
            };
        };
        BL_1_v = (sum);
    (void)0;}), BL_1_v);
    if ((x == 93) && (res == 290))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_PSc96W3T(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    profile_PSc96W3T(2, module);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    profile_dhWSYT8z(3, module);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_PSc96W3T(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    profile_PSc96W3T(2, module);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    profile_dhWSYT8z(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_PSc96W3T(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    profile_PSc96W3T(2, module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    profile_dhWSYT8z(3, module);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_PSc96W3T(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    profile_PSc96W3T(2, module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    profile_dhWSYT8z(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_CjMEcNHu(s_Module& module)
{
    return (module.events = 1);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    l_1_0_CjMEcNHu(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        propagateType_23bnk5q3(module);
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };

        <alt>
        inline   <alt/>
        noinline </alt>
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }

        <alt>
        inline   <alt/>
        noinline </alt>
        fn propagateType(implicit ref module: Module) {
                        /// force-template, weird relax order
            profile(2, |lax unused?| module.events = 1);
        }               ///////////

        <alt>
        inline   <alt/>
        noinline </alt>
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 16:24+1[0m:

[2m      |         fn propagateType(implicit ref module: Module) {[0m
[2m      |                         /// force-template, weird relax order[0m
[2m   16 | [0m            profile(2, [31;1m|[0mlax unused?| module.events = 1);
[2m      |         }               ///////////[0m
[2m      | [0m

	COMPILER BUG:

	ScopeSkip_push: bad args.

       RelaxMut [35;1mfn[0m [34;1mrunAllPasses[0m at [2m21:12+12[0m

-----

        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       ;; N_BckMustSeq
            return (items[0] - 101).i32;
        }

-----
TODO: Expected note not listed: [31;1mN_BckMustSeq[0m in:

        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       // N_BckMustSeq
            return (items[0] - 101).i32;
        }


Output is:

#include <cstdint>
#include <fu/vec.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static bool rellocate_osaBkvcI(fu::vec<int64_t>& a)
{
    for (int i = 0; i < 6; i++)
        a += fu::vec<int64_t>(a);

    return !!a.size();
}

static int64_t& x2Bx3D_5e0baHCO(int64_t& a, const bool b)
{
    return (a += (b ? 100ll : 0ll));
}

int fu_MAIN()
{
    fu::vec<int64_t> items = fu::vec<int64_t> { fu::slate<4, int64_t> { int64_t(1), int64_t(2), int64_t(3), int64_t(4) } };
    x2Bx3D_5e0baHCO(items.mutref(0), rellocate_osaBkvcI(items));
    return int((items[0] - 101ll));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            struct Node {};
    <alt>
            fn evalTypeAnnot(node: Node) =
                return !!node;
    <alt/>
            fn evalTypeAnnot(node: Node): bool =
                return node && [];
    </alt>
            fn trySolveTypeParams(node: Node): bool =   <fail actual return void does not match annot bool 9:21+6>
                let expect = evalTypeAnnot(node);       <pass/>
                             evalTypeAnnot(node);       </fail>

            return trySolveTypeParams([]) && 0;
        }

-----
TODO: <fail> mismatch:

    Expected error keyword:
        [31;1mvoid[0m from pattern <fail[31;1m actual return void does not match annot bool 9:21+6[0m>

    ... not present in error message:

[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:29+2[0m:

[2m      | [0m
[2m      |             fn evalTypeAnnot(node: Node): bool =[0m
[2m    6 | [0m                return node [31;1m&&[0m [];
[2m      | [0m
[2m      |             fn trySolveTypeParams(node: Node): bool =   [0m

	Actual return type does not match annotation: bool copy <- Node copy

        Solving [35;1mfn[0m [34;1mevalTypeAnnot[0m(Node) at [2m5:16+13[0m
                [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        pub fn pairs(a: Map($K, $V), fn) {
            let k = a.keys;
            let v = a.values;
            for (mut i = 0; i < k.len; i++)
                fn(k[i], v[i]);
        }

        fn main() {
            mut map: Map(i32, i32);
            map[1] = 2;
            map[3] = 4;

            mut sum = 0;
            map.pairs(|k, v| sum += k + v * 100);
            return sum - 604;
        }

-----
TODO: [0m_0[2m.fu 10:25+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   10 | [0m            mut map: Map[31;1m([0mi32, i32);
[2m      |             map[1] = 2;[0m
[2m      |             map[3] = 4;[0m

	Bad call to [34;1mMap[0m with args (i32 copy Typename, i32 copy Typename): [34;1mMap[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m9:12+4[0m

-----

        struct ScopeSkip {
            min: i32;
            max: i32;
        };

        fn main() {
            let a = 1;
            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.
            mut t: ScopeSkip; t = x.min && [ x.min, a ];
            return a + t.min + t.max;
        }

-----
TODO: [0m_0[2m.fu 9:41+1[0m:

[2m      |         fn main() {[0m
[2m      |             let a = 1;[0m
[2m    9 | [0m            mut x: ScopeSkip; x = []; x [31;1m=[0m [ -2, 0 ]; // Inference fail.
[2m      |             mut t: ScopeSkip; t = x.min && [ x.min, a ];[0m
[2m      |             return a + t.min + t.max;[0m

	Bad call to [34;1m=[0m with args (ScopeSkip mutref copy, i32[] copy resize AlwaysTrue): 

	[35;1mtemplate[0m [34;1m=[0m at [2m../../../../../[0mprelude[2m 165:12+1[0m:
[2m  165 | [0minfix fn   [31;1m=[0m !T(ref a: T,    mut b: T): &mut T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: ScopeSkip copy { #0 #1 } Typename <-> i32[] copy resize { #0 } Typename

        Solving [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        fn setupOperators(i: i32) {
            <alt>
            struct sB { hey: i32; };
            struct BINOP { i: sB; };
            <alt/>
            fn sB(_: $T) struct { hey: $T; };
            struct BINOP { i: sB(i32); };
            </alt>
            return BINOP([ i ]); // Inference fail.
        }

        fn main() setupOperators(0).i.hey;

-----
TODO: [0m_0[2m.fu 7:25+1[0m:

[2m      |             struct BINOP { i: sB(i32); };[0m
[2m      | [0m
[2m    7 | [0m            return BINOP[31;1m([0m[ i ]); // Inference fail.
[2m      |         }[0m
[2m      | [0m

	Bad call to [34;1mBINOP[0m with args (i32[] copy resize AlwaysTrue): 

	[35;1mtype[0m [34;1mBINOP[0m at [2m5:13+6[0m:
[2m    5 | [0m            [31;1mstruct[0m BINOP { i: sB(i32); };

	    [35;1marg[0m [34;1mi[0m expects sB_R1UhomuA6F6 copy, got i32[] copy resize AlwaysTrue

        Solving [35;1mfn[0m [34;1msetupOperators[0m(i32) at [2m2:12+14[0m

-----

        // When you pass this, delete the test above, they're the same.
        //  The slice() should relax to a get_view, which doesnt need annot to be a string.
        //   We generally want to remove the distinction between slice(a,b) and [a:b] altogether.
        //
        let NOTES = [ "AAA", "BBB", "CCC" ];
        novec fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
        fn main() what("!BBB") - 1;

-----
TODO: [0m_0[2m.fu 7:9+5[0m:

[2m      |         //[0m
[2m      |         let NOTES = [ "AAA", "BBB", "CCC" ];[0m
[2m    7 | [0m        [31;1mnovec[0m fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
[2m      |         fn main() what("!BBB") - 1;[0m
[2m      | [0m

	[35;1mfn[0m [34;1mwhat[0m is not novec, [35;1marg[0m [34;1mannot[0m is string copy resize:

            via [35;1m__native[0m [34;1m
<fu/vec/slice.h>
fu::slice[0m at [2m7:60+1[0m:

[2m      |         //[0m
[2m      |         let NOTES = [ "AAA", "BBB", "CCC" ];[0m
[2m    7 | [0m        novec fn what(annot: string) NOTES.find(annot.slice[31;1m([0m1, annot.len));
[2m      |         fn main() what("!BBB") - 1;[0m
[2m      | [0m


-----

        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;

-----

#ifndef fu_NO_fdefs

static int A_1WsbUdat(const int x)
{
    return x;
}

static int B_1WsbUdat(const int x)
{
    return A_1WsbUdat(x);
}

int fu_MAIN()
{
    return A_1WsbUdat(0) + B_1WsbUdat(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;

-----

#ifndef fu_NO_fdefs

static int A_1WsbUdat(const int x)
{
    return x;
}

static int B_1WsbUdat(const int x)
{
    return A_1WsbUdat(x);
}

int fu_MAIN()
{
    return A_1WsbUdat(0) + B_1WsbUdat(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn check(a, b, compare! = |aa, bb| aa <> bb)
            compare(a, b);

        fn main() check(0, 0);

-----
TODO: [0m_0[2m.fu 5:24+1[0m:

[2m      |             compare(a, b);[0m
[2m      | [0m
[2m    5 | [0m        fn main() check[31;1m([0m0, 0);
[2m      | [0m

	COMPILER BUG:

	tryMatch: about to implicit-bind a non-implicit argument: `compare: @130`.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn a_len(a: [$T]) a.len; // a conversion could navigate this here
        struct Test { using a: i32[]; };
        fn main() Test.a_len;

-----
TODO: [0m_0[2m.fu 4:24+5[0m:

[2m      |         fn a_len(a: [$T]) a.len; // a conversion could navigate this here[0m
[2m      |         struct Test { using a: i32[]; };[0m
[2m    4 | [0m        fn main() Test.[31;1ma_len[0m;
[2m      | [0m

	Bad call to [34;1ma_len[0m with args (Test copy Typename): 

	[35;1mtemplate[0m [34;1ma_len[0m at [2m2:12+5[0m:
[2m    2 | [0m        fn [31;1ma_len[0m(a: [$T]) a.len; // a conversion could navigate this here

	    [35;1marg[0m [34;1ma[0m:
	    Not sliceable: Test copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct CodegenOutput { using src: string; };

        fn test(ref str: string, out: CodegenOutput) {
            str ~= out && "b";
            return str ~ out;
        }

        fn main() {
            mut str = "a";
            return str.test(CodegenOutput("what")).len - 6; // "abwhat".len;
        }

-----
TODO: [0m_0[2m.fu 6:24+1[0m:

[2m      |         fn test(ref str: string, out: CodegenOutput) {[0m
[2m      |             str ~= out && "b";[0m
[2m    6 | [0m            return str [31;1m~[0m out;
[2m      |         }[0m
[2m      | [0m

	Bad call to [34;1m~[0m with args (string mutref copy resize, CodegenOutput copy): 

	[35;1mtemplate[0m [34;1m~[0m at [2m../../../../../[0mprelude[2m 373:10+1[0m:
[2m  373 | [0minfix fn [31;1m~[0m  !T(    a.str, b: [byte]) a ~ b;

	    Cannot match [35;1marg[0m [34;1ma[0m autocall [34;1mstr[0m: 

		[35;1mref arg[0m [34;1mstr[0m at [2m4:21+3[0m:
[2m    4 | [0m        fn test(ref [31;1mstr[0m: string, out: CodegenOutput) {

		    Wrong number of arguments: expects 0, got 1.

		[35;1mtemplate[0m [34;1mstr[0m at [2m../../../../../[0mprelude[2m 376:4+3[0m:
[2m  376 | [0mfn [31;1mstr[0m !T(n: T)

		    No body pattern matched.

	[35;1mtemplate[0m [34;1m~[0m at [2m../../../../../[0mprelude[2m 372:10+1[0m:
[2m  372 | [0minfix fn [31;1m~[0m  !T(    a: [byte], b.str) a ~ b;

	    Cannot match [35;1marg[0m [34;1mb[0m autocall [34;1mstr[0m: 

		[35;1mref arg[0m [34;1mstr[0m at [2m4:21+3[0m:
[2m    4 | [0m        fn test(ref [31;1mstr[0m: string, out: CodegenOutput) {

		    Wrong number of arguments: expects 0, got 1.

		[35;1mtemplate[0m [34;1mstr[0m at [2m../../../../../[0mprelude[2m 376:4+3[0m:
[2m  376 | [0mfn [31;1mstr[0m !T(n: T)

		    No body pattern matched.

	[35;1mtemplate[0m [34;1m
<fu/vec/concat_one.h>
+[0m at [2m../../../../../[0mprelude[2m 352:10+1[0m:
[2m  352 | [0minfix fn [31;1m~[0m !T(a:  T  , b: T[:]): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;1marg[0m [34;1mb[0m:
	    Not sliceable: CodegenOutput copy

	[35;1mtemplate[0m [34;1m
<fu/vec/concat_one.h>
+[0m at [2m../../../../../[0mprelude[2m 351:10+1[0m:
[2m  351 | [0minfix fn [31;1m~[0m !T(a: T[:], b:  T  ): T[] __native("<fu/vec/concat_one.h>", "+");

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: byte Typename <-> CodegenOutput Typename

	[35;1mtemplate[0m [34;1m
<fu/vec/concat.h>
+[0m at [2m../../../../../[0mprelude[2m 350:10+1[0m:
[2m  350 | [0minfix fn [31;1m~[0m !T(a: T[:], b: T[:]): T[] __native("<fu/vec/concat.h>",     "+");

	    [35;1marg[0m [34;1mb[0m:
	    Not sliceable: CodegenOutput copy

	[35;1mtemplate[0m [34;1m~[0m at [2m../../../../../[0mprelude[2m 37:11+1[0m:
[2m   37 | [0mprefix fn [31;1m~[0m !T(a: T) case (T.is::bitfield): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mtest[0m(string, CodegenOutput) at [2m4:12+4[0m

-----

        struct A { a: i32 };
        struct B { b: i32 };

        // Currently this would have to be named fn A -
        //  because we match by type *name*, instead of
        //   attempting conversions to type A.
        //
        // We want to replace match-by-name by tryConvert.
        //
        using fn A2B(a: A): B = [ a.a + 3 ];

        fn main() A(2).b - 5;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B A2B_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a + 3) };
}

int fu_MAIN()
{
    return A2B_7Nh2jNsJ(s_A { 2 }).b - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32 };
        struct B { b: i32 };

        // Currently this would have to be named fn A -
        //  because we match by type *name*, instead of
        //   attempting conversions to type A.
        //
        // We want to replace match-by-name by tryConvert.
        //
        using fn A2B(a: A): B = [ a.a + 3 ];

        fn main() A(2)<alt>.B</alt>.b - 5;

-----
TODO: [0m_0[2m.fu 13:24+1[0m:

[2m      |         using fn A2B(a: A): B = [ a.a + 3 ];[0m
[2m      | [0m
[2m   13 | [0m        fn main() A(2).[31;1mB[0m.b - 5;
[2m      | [0m

	Bad call to [34;1mB[0m with args (A copy): 

	[35;1mtype[0m [34;1mB[0m at [2m3:9+6[0m:
[2m    3 | [0m        [31;1mstruct[0m B { b: i32 };

	    [35;1marg[0m [34;1mb[0m expects i32 copy, got A copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn Wrap(type T) =
            struct { value!: T };

        infix fn => !<A, B>
            (from: Wrap(A), lax _: Wrap(B)): Into =
                [ Into(from.value) + 4 ];
    <alt>
        fn main() =
            (7.u32 => Wrap(int)).value - 14;
    <alt/>
        fn main() {
            type T = Wrap(int);
            return T(7.u32).value - 14;
        }
    </alt>

-----
TODO: [0m_0[2m.fu 11:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             type T = Wrap(int);[0m
[2m   11 | [0m            return T[31;1m([0m7.u32).value - 14;
[2m      |         }[0m
[2m      | [0m

	Bad call to [34;1mT[0m with args (u32 copy): 

	[35;1mtype[0m [34;1mWrap_95BJOojOc45[0m at [2m3:13+6[0m:
[2m    3 | [0m            [31;1mstruct[0m { value!: T };

	    [35;1marg[0m [34;1mvalue[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m9:12+4[0m

-----

        fn count_args!T (
            <alt>
            inline
            </alt>
            v[]: T[]) = v.len;

        fn main() = count_args(
            hello?: "ignore me",
            1, 2, 3,
            world?: "ignore me too")
                == 3 ? 0 : 1;

-----
TODO: [0m_0[2m.fu 6:31+1[0m:

[2m      |             v[]: T[]) = v.len;[0m
[2m      | [0m
[2m    6 | [0m        fn main() = count_args[31;1m([0m
[2m      |             hello?: "ignore me",[0m
[2m      |             1, 2, 3,[0m

	Bad call to [34;1mcount_args[0m with args (string copy resize AlwaysTrue, i32 copy AlwaysTrue, i32 copy AlwaysTrue, i32 copy AlwaysTrue, string copy resize AlwaysTrue): 

	[35;1mtemplate[0m [34;1mcount_args[0m at [2m2:12+10[0m:
[2m    2 | [0m        fn [31;1mcount_args[0m!T (

	    Optional argument ambiguity, not all optional arguments provided, and not all callsite arguments used. Cannot distinguish from a typo. [TODO LIST MISSING ARGS]

        Solving [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        inline fn parseStuff(x: i32) descend(x);                ;; GNUStmtExpr

        inline fn descend(x: i32) {
            fn inner() x & 1 ? parseStuff(x / 2) : x;
            return inner();
        }

        fn main() parseStuff(5) == 2 ? 0 : 1;

-----
TODO: [0m_0[2m.fu 6:25+1[0m:

[2m      |         inline fn descend(x: i32) {[0m
[2m      |             fn inner() x & 1 ? parseStuff(x / 2) : x;[0m
[2m    6 | [0m            return inner[31;1m([0m);
[2m      |         }[0m
[2m      | [0m

	COMPILER BUG:

	[35;1mcall[0m([35;1mfn[0m [34;1minner[0m) -> i32 copy { [35;1mcall[0m([35;1mvar[0m [34;1mx[0m) -> i32 copy } [35;1mfn[0m [34;1minner[0m: host_args.len (0) != args.len (1):
		Ai32
		[35;1mfn[0m [34;1minner[0m at [2m5:16+5[0m:
[2m    5 | [0m            fn [31;1minner[0m() x & 1 ? parseStuff(x / 2) : x;


        Solving [35;1mfn[0m [34;1minner[0m at [2m5:16+5[0m
                [35;1minline[0m [34;1mdescend[0m(i32) at [2m4:19+7[0m

-----

        struct Overload { name: string };
        struct Target { globid: i32 };

        fn solve(overloads: Overload[], target: Target, BUG)
        {
            using fn GET(t: Target)
                overloads[t.globid];

            fn BUG2(topic: string)
                BUG(topic);

            fn relaxBlockVar(t: Target)
                BUG2(t.name.BUG2);

            return target.relaxBlockVar();
        }

        fn main() {
            try
                solve([ Overload("hello") ], Target(0), fn throw);
            catch (e)
                return e == "hello" ? 0 : 1;

            return 2;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Overload;
struct s_Target;

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int globid;
    explicit operator bool() const noexcept
    {
        return false
            || globid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Overload& GET_4jlr2fM3(const s_Target& t, fu::view<s_Overload> overloads)
{
    return overloads[t.globid];
}

[[noreturn]] static fu::never BUG2_GwinvDrb(const fu::str& topic)
{
    fu::fail(fu::str(topic));
}

[[noreturn]] static fu::never relaxBlockVar_lflkTFCv(const s_Target& t, fu::view<s_Overload> overloads)
{
    BUG2_GwinvDrb(GET_4jlr2fM3(t, overloads).name);
}

[[noreturn]] inline static fu::never solve_sP0BeFBF(fu::view<s_Overload> overloads, const s_Target& target)
{
    relaxBlockVar_lflkTFCv(target, overloads);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
    {
        solve_sP0BeFBF((fu::slate<1, s_Overload> { s_Overload { "hello"_fu } }), s_Target { 0 });
    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "hello"_fu)
            return 0;
        else
            return 1;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall, N_NonTrivAutoCopy

-----

        struct Overload { name: string };
        struct Target { globid: i32 };

        fn solve(overloads: Overload[], target: Target, BUG)
        {
            using fn GET(t: Target)
                overloads[t.globid];

            fn BUG2(<alt>inline </alt>topic: string)
                BUG(topic);

            fn relaxBlockVar(t: Target)
                BUG2(t.name.BUG2);

            return target.relaxBlockVar();
        }

        fn main() {
            try
                solve([ Overload("hello") ], Target(0), fn throw);
            catch (e)
                return e == "hello" ? 0 : 1;

            return 2;
        }

-----
TODO: [0m_0[2m.fu 11:20+1[0m:

[2m      | [0m
[2m      |             fn BUG2(inline topic: string)[0m
[2m   11 | [0m                BUG[31;1m([0mtopic);
[2m      | [0m
[2m      |             fn relaxBlockVar(t: Target)[0m

	COMPILER BUG:

	[35;1mcall[0m([35;1m__native[0m [34;1m
<fu/never.h>
fu::fail[0m) -> never { [35;1mblock[0m -> never { [35;1mcall[0m([35;1m__native[0m [34;1m
<fu/never.h>
fu::fail[0m) -> never { [35;1mcall[0m([35;1mfield[0m [34;1mname[0m) -> string copy resize { [35;1mcall[0m([35;1mfn[0m [34;1mGET[0m) -> Overload copy { 2 } } } } } [35;1m__native[0m [34;1m
<fu/never.h>
fu::fail[0m: Arg #0, [34;1mreason[0m not assignable to host_arg: string copy resize { #0 } <- never { }

        Solving [35;1mfn[0m [34;1mrelaxBlockVar[0m(Target) at [2m13:16+13[0m
                [35;1mfn[0m [34;1msolve[0m(Overload[:], Target, @010) at [2m5:12+5[0m
                [35;1mfn[0m [34;1mmain[0m at [2m19:12+4[0m

-----

        fn test(x: i32)
        {
            fn mayExitTest() {
                return x & 1 ? { return :test x * x; }          // GNUStmtExpr
                             : x * 2;
            }

            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {
                return y * x;
            }

            return x & 2 ? mayExitTestFromDefarg()
                         : mayExitTestFromDefarg(x * 2);
        }

        fn main() {
            return test(3) == 9 && test(4) == 32 ? 0 : 1;
        }

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 2)
    {
        fu::never BL_2_v {};
        const int y = ((x & 1) ? (__extension__ (
        {
            return x * x;
        (void)0;}), static_cast<fu::never&&>(BL_2_v)) : (x * 2));
        return y * x;
    }
    else
    {
        const int y = (x * 2);
        return y * x;
    };
}

int fu_MAIN()
{
    if ((test_1WsbUdat(3) == 9) && (test_1WsbUdat(4) == 32))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32)
        {
            fn mayExitTest() {
                return x & 1 ? { return :test x * x; }          // GNUStmtExpr
                             : x * 2;
            }

            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {
                return y * x;
            }

            return x & 2 ? mayExitTestFromDefarg()
                         : mayExitTestFromDefarg(x * 2);
        }

        fn main() {
            return test(3) == 9 && test(4) == 32 ? 0 : 1;
        }

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 2)
    {
        fu::never BL_2_v {};
        const int y = ((x & 1) ? (__extension__ (
        {
            return x * x;
        (void)0;}), static_cast<fu::never&&>(BL_2_v)) : (x * 2));
        return y * x;
    }
    else
    {
        const int y = (x * 2);
        return y * x;
    };
}

int fu_MAIN()
{
    if ((test_1WsbUdat(3) == 9) && (test_1WsbUdat(4) == 32))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test() {
            <fail nothing to break>
            break;   <pass/></fail>
            return 0;
        }
        fn main() = test();

-----
TODO: <fail> mismatch:

    Expected error keyword:
        [31;1mnothing[0m from pattern <fail[31;1m nothing to break[0m>

    ... not present in error message:

[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:13+5[0m:

[2m      |         fn test() {[0m
[2m      | [0m
[2m    4 | [0m            [31;1mbreak[0m;   
[2m      |             return 0;[0m
[2m      |         }[0m

	No label `` in scope.

        Solving [35;1mfn[0m [34;1mtest[0m at [2m2:12+4[0m

-----

        fn test() {
            let hello = || {
                <fail nothing to break>
                break;   <pass/></fail>
                return 0;
            };

            return hello;
        }
        fn main() = test();

-----
TODO: <fail> mismatch:

    Expected error keyword:
        [31;1mnothing[0m from pattern <fail[31;1m nothing to break[0m>

    ... not present in error message:

[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:25+1[0m:

[2m      |             return hello;[0m
[2m      |         }[0m
[2m   11 | [0m        fn main() = test[31;1m([0m);
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- void

        Solving [35;1mfn[0m [34;1mmain[0m at [2m11:12+4[0m

-----

        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_001(ref m!: S, c!: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn test(ref mc: S) {
            return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c!
        }                                               //  But can be made to work by creating an intermediate copyvar
                                                        //   and move-returning from there.
        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
            let hey = test(mc);
            return hey.len - 10;
        }

-----
TODO: [0m_0[2m.fu 10:51+2[0m:

[2m      | [0m
[2m      |         fn test(ref mc: S) {[0m
[2m   10 | [0m            return m_and_c_cant_alias_001(m:mc, c:[31;1mmc[0m);  // Can't return a ref into c!
[2m      |         }                                               //  But can be made to work by creating an intermediate copyvar[0m
[2m      |                                                         //   and move-returning from there.[0m

	At call to [35;1mfn[0m [34;1mm_and_c_cant_alias_001[0m, arguments:

	    2:	[35;1marg[0m [34;1mm_and_c_cant_alias_001[0m:[34;1mc[0m and
	    1:	[35;1mref arg[0m [34;1mm_and_c_cant_alias_001[0m:[34;1mm[0m

	    both alias:

	    [35;1mref arg[0m [34;1mmc[0m at [2m9:21+2[0m:

[2m      |         }[0m
[2m      | [0m
[2m    9 | [0m        fn test(ref [31;1mmc[0m: S) {
[2m      |             return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c![0m
[2m      |         }                                               //  But can be made to work by creating an intermediate copyvar[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1marg[0m [34;1mm_and_c_cant_alias_001[0m:[34;1mc[0m is ref-returned from [35;1mfn[0m [34;1mm_and_c_cant_alias_001[0m

	    [35;1mref arg[0m [34;1mm_and_c_cant_alias_001[0m:[34;1mm[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(S) at [2m9:12+4[0m

-----

        struct Overload { items: string[]; };

        // This is a bit borderline -
        //  the problem here is that a: $T[] doesn't relax to a: [$T] (not during prep) -
        //   so we don't match at all. Still, that's what's written -
        //    perhaps regular fns are what doesn't behave correctly,
        //     since their relax can create ambiguity?
        //
        fn last(a: $T[])                    a[a.len - 1];
        fn arg_lets(overload: Overload)     overload.items[0 : overload.items.len - 2];
        fn test(overload: Overload)         overload.arg_lets.last.len;
        fn main()                           Overload([ "hello", "cruel", "world!" ]).test - 5;

-----
TODO: [0m_0[2m.fu 12:63+4[0m:

[2m      |         fn last(a: $T[])                    a[a.len - 1];[0m
[2m      |         fn arg_lets(overload: Overload)     overload.items[0 : overload.items.len - 2];[0m
[2m   12 | [0m        fn test(overload: Overload)         overload.arg_lets.[31;1mlast[0m.len;
[2m      |         fn main()                           Overload([ "hello", "cruel", "world!" ]).test - 5;[0m
[2m      | [0m

	Bad call to [34;1mlast[0m with args (string[:]): 

	[35;1mtemplate[0m [34;1mlast[0m at [2m10:12+4[0m:
[2m   10 | [0m        fn [31;1mlast[0m(a: $T[])                    a[a.len - 1];

	    [35;1marg[0m [34;1ma[0m:
	    Not an array: string[:]

        Solving [35;1mfn[0m [34;1mtest[0m(Overload) at [2m12:12+4[0m

-----

        fn useless_ref_lambda(ref sources: string[]) {
            fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck
            return src[1 : src.len] ~ src[0 : 1];
        }
        fn main() {
            mut sources = [ "ab" ];
            return useless_ref_lambda(sources) == "ba" ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 4:23+1[0m:

[2m      |         fn useless_ref_lambda(ref sources: string[]) {[0m
[2m      |             fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck[0m
[2m    4 | [0m            return src[31;1m[[0m1 : src.len] ~ src[0 : 1];
[2m      |         }[0m
[2m      |         fn main() {[0m

	At call to [35;1m__native[0m [34;1m
<fu/view.h>
fu::get_view[0m, binding for [35;1marg[0m [34;1m
<fu/view.h>
fu::get_view[0m:[34;1ma[0m (arg #0) at [2m4:20+3[0m:

[2m      |         fn useless_ref_lambda(ref sources: string[]) {[0m
[2m      |             fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck[0m
[2m    4 | [0m            return [31;1msrc[0m[1 : src.len] ~ src[0 : 1];
[2m      |         }[0m
[2m      |         fn main() {[0m

	... invalidated by subsequent write to [35;1mref arg[0m [34;1msources[0m upon evaluation of [35;1marg[0m [34;1m
<fu/view.h>
fu::get_view[0m:[34;1mend[0m (arg #2) at [2m4:28+3[0m:

[2m      |         fn useless_ref_lambda(ref sources: string[]) {[0m
[2m      |             fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck[0m
[2m    4 | [0m            return src[1 : [31;1msrc[0m.len] ~ src[0 : 1];
[2m      |         }[0m
[2m      |         fn main() {[0m

	At call to [35;1mfn[0m [34;1msrc[0m
            via [35;1m__native[0m [34;1m
.mutref[0m at [2m3:29+1[0m:

[2m      | [0m
[2m      |         fn useless_ref_lambda(ref sources: string[]) {[0m
[2m    3 | [0m            fn src = sources[31;1m[[0msources.len / 2]; // didn't relax the ref, failed bck
[2m      |             return src[1 : src.len] ~ src[0 : 1];[0m
[2m      |         }[0m


    BorrowCheck [35;1mfn[0m [34;1museless_ref_lambda[0m(string[:]) at [2m2:12+18[0m

-----

        fn relaxes_arr_to_slice_and_fails(ref arr) {
            arr.pop();
            return arr;
        }

        fn main() {
            mut arr = [ 1 ];
            relaxes_arr_to_slice_and_fails(arr);
            return arr.len;
        }

-----
TODO: [0m_0[2m.fu 3:20+1[0m:

[2m      | [0m
[2m      |         fn relaxes_arr_to_slice_and_fails(ref arr) {[0m
[2m    3 | [0m            arr.pop[31;1m([0m);
[2m      |             return arr;[0m
[2m      |         }[0m

	Bad call to [34;1mpop[0m with args (i32[:] mutref): 

	[35;1mtemplate[0m [34;1m
.pop()[0m at [2m../../../../../[0mprelude[2m 220:7+3[0m:
[2m  220 | [0mfn    [31;1mpop[0m !T(ref a: T[]): void __native(".pop()");

	    [35;1marg[0m [34;1ma[0m:
	    Not an array: i32[:]

        Solving [35;1mfn[0m [34;1mrelaxes_arr_to_slice_and_fails[0m(i32[:]) at [2m2:12+30[0m
RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        fn test(str: string) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }

-----
TODO:    EXIT code: 25856

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/lib/mem.fu
/Users/hdachev/fu/__tests__/_0.fu


	Generated code:

#include <fu/str.h>
#include <fu/view.h>
#include <fu/mem/arc.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_T9i966y9wQg
                                #define DEF_find_T9i966y9wQg
inline int find_T9i966y9(fu::view<char> a, const char b, int start)
{
    start = ((start > 0) ? start : 0);
    for (int i = start; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

inline static int& l_1_0_nRBVjBmj(fu::view<char> piece, int& res)
{
    return (res *= piece.size());
}

                                #ifndef DEF_split_Vxio1Y1Lox3
                                #define DEF_split_Vxio1Y1Lox3
inline void split_Vxio1Y1L(const fu::str& str, const char sep, int& res)
{
    int last = 0;
    int next = 0;
    const int N = 1;
    while (((next = find_T9i966y9(str, sep, last)) >= 0))
    {
        l_1_0_nRBVjBmj(fu::slice(str, last, next), res);
        last = (next + N);
    };
    if (last)
        l_1_0_nRBVjBmj(fu::slice(str, last), res);
    else
        l_1_0_nRBVjBmj(str, res);

}
                                #endif

static int test_7XPhwW5a(const fu::str& str)
{
    int res = 1;
    split_Vxio1Y1L(str, '/', res);
    return res;
}

int fu_MAIN()
{
    const int res = test_7XPhwW5a("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc"_fu);
    if (fu_ARC::ALLOC_STAT_COUNT() != 0)
        return 101;
    else if (res == 196608)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Empty {};

        fn main() {
            mut e = [ Empty(), Empty() ];
            fn GET(idx: i32) e.len > idx && e[idx];
            return GET(0) == GET(1) ? 0 : 1;
        }

-----
TODO: [0m_0[2m.fu 5:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1me[0m = [ Empty(), Empty() ];
[2m      |             fn GET(idx: i32) e.len > idx && e[idx];[0m
[2m      |             return GET(0) == GET(1) ? 0 : 1;[0m

	THIS IS A COMPILER BUG.

	CODEGEN FAIL:

	cg: We generate invalid c++ for void[]

-----

        struct Target   { index: i32 }
        struct Lifetime { uni0n!: byte[] };
        type Type = Lifetime;

        fn is_ref(type: Type) = !!type;

        fn Lifetime_process(lifetime: Lifetime, each) {
            fn visit(shadow lifetime) {
                do {
                    fn continue_climb(mut parent: Lifetime) {
                        visit(parent);
                        continue;
                    }

                    each(lifetime, fn continue_climb);
                }
                while (false);
            }

            return visit(lifetime);
        }

        fn main() {
            fn Lifetime_climbType(lax lifetime: Lifetime) return [];

            mut count = 0;
            Lifetime_process([], each: |lifetime, continue_climb| {
                count++;

                let init = lifetime.Lifetime_climbType;
                if (init.is_ref)
                    continue_climb(init);
            });

            return count - 1;
        }

-----
TODO: [0m_0[2m.fu 33:35+1[0m:

[2m      |                 let init = lifetime.Lifetime_climbType;[0m
[2m      |                 if (init.is_ref)[0m
[2m   33 | [0m                    continue_climb[31;1m([0minit);
[2m      |             });[0m
[2m      | [0m

	COMPILER BUG:

	Inliner botching the argdef type of [35;1marg[0m [34;1mparent[0m:

		Expect: Lifetime mutref copy
		Actual: zeroes mutref

        Solving [35;1mfn[0m [34;1ml_1_0[0m(Lifetime, @1F0) at [2m28:40+1[0m
                [35;1mfn[0m [34;1mvisit[0m(Lifetime, i32) at [2m9:16+5[0m
                [35;1mfn[0m [34;1mcontinue_climb[0m(Lifetime) at [2m11:24+14[0m
                [35;1mfn[0m [34;1mvisit[0m(Lifetime) at [2m9:16+5[0m
                [35;1mfn[0m [34;1mLifetime_process[0m(Lifetime, @190) at [2m8:12+16[0m
                [35;1mfn[0m [34;1mmain[0m at [2m24:12+4[0m

-----

        fn sum_each(a, b)       // Same as above,
            a.Each + b.Each;    //  but we don't explicitly pass the fn Each in.

        fn hello(x) {
            if (x & 1) {
                fn Each(a) a    ? a * Each(a - 1)   // These get ignored?
                                : 100;              //  sum_each goes and selects the one from _1.

                return sum_each(x, x);
            }
            else {
                fn Each(b) b    ? b * Each(b - 1)
                                : 10000;

                return sum_each(x, x);
            }
        }

        fn Each(c) c & 1    ? c
                            : c / 2 + Each(c / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);

-----
TODO:    EXIT code: 65024

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu
/Users/hdachev/fu/__tests__/_1.fu


	Generated code:

inline static int Each_pN1agSgZ(int);

#ifndef fu_NO_fdefs

inline static int Each_pN1agSgZ(const int c)
{
    if (c & 1)
        return c;
    else
        return (c / 2) + Each_pN1agSgZ((c / 2));

}

                                #ifndef DEF_sum_each_hwGp0ETuJOb
                                #define DEF_sum_each_hwGp0ETuJOb
inline int sum_each_hwGp0ETu(const int a, const int b)
{
    return Each_pN1agSgZ(a) + Each_pN1agSgZ(b);
}
                                #endif

                                #ifndef DEF_hello_1WsbUdatf7c
                                #define DEF_hello_1WsbUdatf7c
inline int hello_1WsbUdat(const int x)
{
    if (x & 1)
        return sum_each_hwGp0ETu(x, x);
    else
        return sum_each_hwGp0ETu(x, x);

}
                                #endif

int fu_MAIN()
{
    return ((hello_1WsbUdat(1) - (2 * Each_pN1agSgZ(100))) + hello_1WsbUdat(2)) - (2 * Each_pN1agSgZ(20000));
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        struct Woot { i: i32 };
        fn sqr(v) = mul(v, v);

        import _0;
        noinline fn mul(x: Woot, y: Woot) = x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);

        import _0;
        noinline fn mul(x: Woot, y: Woot) = 2 * x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);

        fn main() {
            let x = _0::Woot(2);
            let a = _1::use_sqr(x);
            let b = _2::use_sqr(x);
            return a == 4 && b == 8 ? 0 : 1;
        }

-----
TODO:    EXIT code: 256

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu
/Users/hdachev/fu/__tests__/_1.fu
/Users/hdachev/fu/__tests__/_2.fu
/Users/hdachev/fu/__tests__/_3.fu


	Generated code:

struct s_Woot;

                                #ifndef DEF_s_Woot
                                #define DEF_s_Woot
struct s_Woot
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int mul_dpS7nOtr(const s_Woot& x, const s_Woot& y)
{
    return x.i * y.i;
}

#endif
struct s_Woot;

                                #ifndef DEF_s_Woot
                                #define DEF_s_Woot
struct s_Woot
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int mul_faoQfGc4(const s_Woot& x, const s_Woot& y)
{
    return (2 * x.i) * y.i;
}

#endif
struct s_Woot;
int mul_dpS7nOtr(const s_Woot&, const s_Woot&);
int mul_faoQfGc4(const s_Woot&, const s_Woot&);

                                #ifndef DEF_s_Woot
                                #define DEF_s_Woot
struct s_Woot
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_sqr_o0XqpYKp0se
                                #define DEF_sqr_o0XqpYKp0se
inline int sqr_o0XqpYKp(const s_Woot& v)
{
    return mul_dpS7nOtr(v, v);
}
                                #endif

                                #ifndef DEF_sqr_o0XqpYKp0se
                                #define DEF_sqr_o0XqpYKp0se
inline int sqr_o0XqpYKp(const s_Woot& v)
{
    return mul_faoQfGc4(v, v);
}
                                #endif

int fu_MAIN()
{
    const s_Woot x = s_Woot { 2 };
    const int a = sqr_o0XqpYKp(x);
    const int b = sqr_o0XqpYKp(x);
    if ((a == 4) && (b == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn apply(num: i32, func: fn (i32): i32) = func(num);
        fn main()                               = apply([1], |i| i - 1);

-----
TODO: [0m_0[2m.fu 2:42+1[0m:

[2m      | [0m
[2m    2 | [0m        fn apply(num: i32, func: fn (i32)[31;1m:[0m i32) = func(num);
[2m      |         fn main()                               = apply([1], |i| i - 1);[0m
[2m      | [0m

	Expected [35;1mop[0m [34;1m,[0m
	     got [35;1mop[0m [34;1m:[0m

-----

        enum Test { A; B = A; C; };
        fn main() Test.C.i32 - 1;

-----
TODO: [0m_0[2m.fu 2:28+1[0m:

[2m      | [0m
[2m    2 | [0m        enum Test { A; B = [31;1mA[0m; C; };
[2m      |         fn main() Test.C.i32 - 1;[0m
[2m      | [0m

	Bad call to [34;1mA[0m: [34;1mA[0m is not defined here.

        Solving [35;1mtype[0m [34;1mTest[0m

-----

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn licm_hoist_var(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++) {
                let must_hoist = pretend_pure(n);
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_hoist_var(2) == 204 ? 0 : 1;

-----
TODO:    EXIT code: 256

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu


	Generated code:


#ifndef fu_NO_fdefs

static int pretend_pure_U8dxWspX(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int licm_hoist_var_72skkfd5(const int n)
{
    int res = 0;
    for (int i = 0; i < n; i++)
    {
        const int must_hoist = pretend_pure_U8dxWspX(n);
        res += must_hoist;
    };
    return res;
}

int fu_MAIN()
{
    if (licm_hoist_var_72skkfd5(2) == 204)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        fn main(): i32 {}               

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:12+4[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mmain[0m(): i32 {}               
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- void

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----


        fn main(): i32 { return 0; }    

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----


        fn test(): i32 {}               
        fn main() test();

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:12+4[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mtest[0m(): i32 {}               
[2m      |         fn main() test();[0m
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- void

        Solving [35;1mfn[0m [34;1mtest[0m at [2m3:12+4[0m

-----


        fn test(): i32 { return 0; }    
        fn main() test();

-----

#ifndef fu_NO_fdefs

static int test_H9fhQUVP()
{
    return 0;
}

int fu_MAIN()
{
    return test_H9fhQUVP();
}

#endif

int main() { return fu_MAIN(); }

-----

        return 1 - 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 1 - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        return 
                        3 

-----
   EXIT code: 768

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu


	Generated code:


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        return 
                        0 

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        return 0

            || throw("TESTERR")


-----
   EXIT code: 6

	COMPILER BUG or INCORRECT TESTCASE:

/Users/hdachev/fu/__tests__/_0.fu


	Generated code:

#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] fu::never fu_MAIN()
{
    fu::fail("TESTERR"_fu);
}

#endif

int main() { return fu_MAIN(); }

-----

        return 0


-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);

-----

#ifndef fu_NO_fdefs

static int sum_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return sum_qoaTQFTa(1, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);

-----

#ifndef fu_NO_fdefs

static int sum_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return sum_qoaTQFTa(1, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);

-----

#ifndef fu_NO_fdefs

static int sign_4CEH3Gw7(const int a)
{
    if (a > 0)
        return 1;
    else if (a < 0)
        return -1;
    else
        return 0;

}

int fu_MAIN()
{
    return (sign_4CEH3Gw7(7) + sign_4CEH3Gw7(-3)) + sign_4CEH3Gw7(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);

-----

#ifndef fu_NO_fdefs

static int sign_4CEH3Gw7(const int a)
{
    if (a > 0)
        return 1;
    else
        return -2;

}

int fu_MAIN()
{
    return (sign_4CEH3Gw7(10) * 2) + sign_4CEH3Gw7(-5);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);

-----

#ifndef fu_NO_fdefs

static int sign_4CEH3Gw7(const int a)
{
    if (a > 0)
        return 1;
    else
        return -2;

}

int fu_MAIN()
{
    return (sign_4CEH3Gw7(10) * 2) + sign_4CEH3Gw7(-5);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn main() {
            let  i = -1;
            let sb = i.i8;
            let  b = i.u8;

            return sb == -1 && b == 255 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int i = -1;
    const fu::i8 sb = fu::i8(i);
    const fu::u8 b = fu::u8(unsigned(i));
    if ((sb == fu::i8(-1)) && (b == fu::u8(255u)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let sb = (-1).i8;
            let  i =  sb.i32;
            let  u =  sb.u32;

            return i == -1 && u.i32 == 255 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 sb = fu::i8(-1);
    const int i = int(sb);
    const unsigned u = unsigned(fu::u8(sb));
    if ((i == -1) && (int(u) == 255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let b = byte(200);
            let i = b.i32;
            return i == 200 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char b = char(200);
    const int i = int(fu::u8(b));
    if (i == 200)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        mut arr = [ 0 ];
        return arr[0];

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 0 } };
    return arr[0];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        let a = 3;
        mut b = a;
        b++;
        return b - (a + 1);

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 3;
    int b = a;
    b++;
    return b - (a + 1);
}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int i = 0; i < 10; i++)
        sum++;

    return (sum * 2) - 20;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int i = 10; i-- > 0; )
        sum--;

    return (sum * 2) + 20;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;

-----

#ifndef fu_NO_fdefs

static int decr_kgImUQvq(int& num)
{
    return num--;
}

int fu_MAIN()
{
    int res = 0;
    decr_kgImUQvq(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn decr(ref num: i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;

-----

#ifndef fu_NO_fdefs

static int decr_kgImUQvq(int& num)
{
    return num--;
}

int fu_MAIN()
{
    int res = 0;
    decr_kgImUQvq(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;

-----

#ifndef fu_NO_fdefs

static int decr_EJhRWC6k(int& res)
{
    return res--;
}

int fu_MAIN()
{
    int res = 0;
    decr_EJhRWC6k(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;

-----

#ifndef fu_NO_fdefs

static void decr_kgImUQvq(int& num)
{
    num--;
}

int fu_MAIN()
{
    int res = 0;
    decr_kgImUQvq(res);
    return res + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum++;

    return sum - 15;
}

#endif

int main() { return fu_MAIN(); }

-----


        let sum = 0;        
        while (sum < 15)
            sum++;

        return sum - 15;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:16+2[0m:

[2m      |         let sum = 0;        [0m
[2m      |         while (sum < 15)[0m
[2m    8 | [0m            sum[31;1m++[0m;
[2m      | [0m
[2m      |         return sum - 15;[0m

	Bad call to [34;1mpostfix++[0m with args (i32 copy AlwaysFalse): 

	[35;1mtemplate[0m [34;1mpostfix++[0m at [2m../../../../../[0mprelude[2m 21:12+2[0m:
[2m   21 | [0mpostfix fn [31;1m++[0m !T(ref a: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1ma[0m:
	    Not a mutref: i32 copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----


        mut sum = 0;        
        while (sum < 15)
            sum++;

        return sum - 15;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum++;

    return sum - 15;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    while (sum < 15)
        sum += 2;

    return sum - 16;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut i = 5;
        mut sum = 0;
        while (let x = i--) sum += x - i;
        return sum - 5;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 5;
    int sum = 0;
    while (const int x = i--)
        sum += (x - i);

    return sum - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);

-----

#ifndef fu_NO_fdefs

static int named_qoaTQFTa(const int a, const int b)
{
    return a - (b * 2);
}

int fu_MAIN()
{
    return named_qoaTQFTa(6, 3);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);

-----

#ifndef fu_NO_fdefs

static int named_qoaTQFTa(const int a, const int b)
{
    return a - (b * 2);
}

static int other_1ZXMHcnJ(const int a, const int b)
{
    return named_qoaTQFTa(a, b);
}

int fu_MAIN()
{
    return other_1ZXMHcnJ(6, 3);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ret_only_arg(a) a;

        fn main() 0.ret_only_arg;

-----

#ifndef fu_NO_fdefs

inline static int ret_only_arg_rgx2eiBu(const int a)
{
    return a;
}

int fu_MAIN()
{
    return ret_only_arg_rgx2eiBu(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ret_only_arg(a) a;

-----

-----

        fn ret_only_arg(a) a;
        pub import _0;
        fn main() 0.ret_only_arg;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_ret_only_arg_rgx2eiBuuy6
                                #define DEF_ret_only_arg_rgx2eiBuuy6
inline int ret_only_arg_rgx2eiBu(const int a)
{
    return a;
}
                                #endif

int fu_MAIN()
{
    return ret_only_arg_rgx2eiBu(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_xbEj0oOd(const s_Range& r)
{
    return r.max - r.min;
}

int fu_MAIN()
{
    return size_xbEj0oOd(s_Range { 14, 21 }) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Range r = s_Range { 1, 2 };
    r.min++;
    return r.max - r.min;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Range {
            min: i32;
            max: i32;
        }


        let r =             
            Range(1, 2);

        r.min++;
        return r.max - r.min;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 14:14+2[0m:

[2m      |             Range(1, 2);[0m
[2m      | [0m
[2m   14 | [0m        r.min[31;1m++[0m;
[2m      |         return r.max - r.min;[0m
[2m      | [0m

	Bad call to [34;1mpostfix++[0m with args (i32 copy): 

	[35;1mtemplate[0m [34;1mpostfix++[0m at [2m../../../../../[0mprelude[2m 21:12+2[0m:
[2m   21 | [0mpostfix fn [31;1m++[0m !T(ref a: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1ma[0m:
	    Not a mutref: i32 copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct Range {
            min: i32;
            max: i32;
        }


        mut r =             
            Range(1, 2);

        r.min++;
        return r.max - r.min;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Range r = s_Range { 1, 2 };
    r.min++;
    return r.max - r.min;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Range {
            r_min: i32;
            r_max: i32;
        }

        fn size(using r: Range)
            r_max - r_min;

        return size(Range(14, 21)) - 7;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int r_min;
    int r_max;
    explicit operator bool() const noexcept
    {
        return false
            || r_min
            || r_max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_xbEj0oOd(const s_Range& r)
{
    return r.r_max - r.r_min;
}

int fu_MAIN()
{
    return size_xbEj0oOd(s_Range { 14, 21 }) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X {
            a: i32;
        }

        fn test(using x: X, b: i32) a + b;
        fn hey(using x: X) test(-1);

        return X(1).hey;

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_YmHioYnV(const s_X& x, const int b)
{
    return x.a + b;
}

static int hey_yYeWDNZS(const s_X& x)
{
    return test_YmHioYnV(x, -1);
}

int fu_MAIN()
{
    return hey_yYeWDNZS(s_X { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;

-----
struct s_Player;
struct s_Pos;

                                #ifndef DEF_s_Pos
                                #define DEF_s_Pos
struct s_Pos
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Player
                                #define DEF_s_Player
struct s_Player
{
    s_Pos pos;
    explicit operator bool() const noexcept
    {
        return false
            || pos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int dist_e7Ydy0Qk(const s_Player& p, const s_Player& other)
{
    return p.pos.x - other.pos.x;
}

int fu_MAIN()
{
    const s_Player a = s_Player { s_Pos { 10 } };
    const s_Player b = s_Player { s_Pos { 4 } };
    return dist_e7Ydy0Qk(a, b) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using left: A, using right: B)

            x + z; 

        fn main() test(A(1, 1), B(-1, -1));

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:13+1[0m:

[2m      |         fn test(using left: A, using right: B)[0m
[2m      | [0m
[2m    6 | [0m            [31;1mx[0m + z; 
[2m      | [0m
[2m      |         fn main() test(A(1, 1), B(-1, -1));[0m

	Ambiguous call to [31;1mx[0m, matches multiple items in scope:

	[35;1mfield[0m [34;1mx[0m at [2m3:20+1[0m:
[2m    3 | [0m        struct B { [31;1mx[0m: i32; z: i32; };

	    [35;1musing[0m [35;1marg[0m [34;1mright[0m at [2m4:32+5[0m:
[2m    4 | [0m        fn test(using left: A, [31;1musing[0m [31;1mright[0m: B)

	[35;1mfield[0m [34;1mx[0m at [2m2:20+1[0m:
[2m    2 | [0m        struct A { [31;1mx[0m: i32; y: i32; };

	    [35;1musing[0m [35;1marg[0m [34;1mleft[0m at [2m4:17+5[0m:
[2m    4 | [0m        fn test([31;1musing[0m [31;1mleft[0m: A, using right: B)


        Solving [35;1mfn[0m [34;1mtest[0m(A, B) at [2m4:12+4[0m

-----

        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using left: A, using right: B)

            y + z; 

        fn main() test(A(1, 1), B(-1, -1));

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int x;
    int z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_1JIngwUk(const s_A& left, const s_B& right)
{
    return left.y + right.z;
}

int fu_MAIN()
{
    return test_1JIngwUk(s_A { {}, 1 }, s_B { {}, -1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct CurrentFn {
            parent_idx: i32;
            using RoR?: CurrentFn_ResetOnResolve; // not yet populated
        };

        struct CurrentFn_ResetOnResolve {
            ret_count: i32;
        };

        fn test(f: CurrentFn) f.parent_idx - f.ret_count;
        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));

-----
struct s_CurrentFn_ResetOnResolve;
struct s_CurrentFn;

                                #ifndef DEF_s_CurrentFn_ResetOnResolve
                                #define DEF_s_CurrentFn_ResetOnResolve
struct s_CurrentFn_ResetOnResolve
{
    int ret_count;
    explicit operator bool() const noexcept
    {
        return false
            || ret_count
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    int parent_idx;
    s_CurrentFn_ResetOnResolve RoR;
    explicit operator bool() const noexcept
    {
        return false
            || parent_idx
            || RoR
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_ve5QIykf(const s_CurrentFn& f)
{
    return f.parent_idx - f.RoR.ret_count;
}

int fu_MAIN()
{
    return test_ve5QIykf(s_CurrentFn { 1, s_CurrentFn_ResetOnResolve { 1 } });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct HasPredicate {
            true kind   : string;
            items       : i32;
        };

        fn main() {
            let isTrue  = HasPredicate("let", 0);
            let isFalse = HasPredicate("",    1);
            return isTrue && !isFalse ? 0 : 1;
        }

-----
#include <fu/str.h>

struct s_HasPredicate;

                                #ifndef DEF_s_HasPredicate
                                #define DEF_s_HasPredicate
struct s_HasPredicate
{
    fu::str kind;
    int items;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_HasPredicate isTrue = s_HasPredicate { "let"_fu, 0 };
    s_HasPredicate isFalse = s_HasPredicate { ""_fu, 1 };
    if (isTrue && !isFalse)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Stuff { name: string };

        fn shadowsStructMember(using stuff: Stuff, other: string) {
            shadow let name = other || name;
            return name;
        }

        fn main() = shadowsStructMember(Stuff("a"), "bb").len - 2;

-----
#include <fu/str.h>

struct s_Stuff;

                                #ifndef DEF_s_Stuff
                                #define DEF_s_Stuff
struct s_Stuff
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& shadowsStructMember_J7hvlixX(const s_Stuff& stuff, const fu::str& other)
{
    const fu::str& /*other|stuff*/ name = (other ? other : stuff.name);
    return name;
}

int fu_MAIN()
{
    return shadowsStructMember_J7hvlixX(s_Stuff { "a"_fu }, "bb"_fu).size() - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn call_with_using_and_explicit_arg(x: i32, y: i32) = x + 7*y;
        fn main () {
            using let y = 1;
            return call_with_using_and_explicit_arg(x: 2) - 9;
        }

-----

#ifndef fu_NO_fdefs

static int call_with_using_and_explicit_arg_UXsyOHvH(const int x, const int y)
{
    return x + (7 * y);
}

int fu_MAIN()
{
    const int y = 1;
    return call_with_using_and_explicit_arg_UXsyOHvH(2, y) - 9;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn call_with_using_explicit_and_trailing(x: i32, y: i32, m: i32) = (x + 7*y) * m;
        fn main () {
            using let x = 1;
            return call_with_using_explicit_and_trailing(y: 2, 3) - 45;
        }

-----

#ifndef fu_NO_fdefs

static int call_with_using_explicit_and_trailing_zfsbqbH2(const int x, const int y, const int m)
{
    return (x + (7 * y)) * m;
}

int fu_MAIN()
{
    const int x = 1;
    return call_with_using_explicit_and_trailing_zfsbqbH2(x, 2, 3) - 45;
}

#endif

int main() { return fu_MAIN(); }

-----


        trivial
        struct Node { items: Node[]; };

        fn main() {
            mut n: Node;
            return n.items.len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+5[0m:

[2m      | [0m
[2m      |         trivial[0m
[2m    4 | [0m        struct Node { [31;1mitems[0m: Node[]; };
[2m      | [0m
[2m      |         fn main() {[0m

	Struct is not [35;1mtrivial[0m because of non-trivial member [34;1mitems[0m

        Solving [35;1mtype[0m [34;1mNode[0m

-----


        struct Node { items: Node[]; };

        fn main() {
            mut n: Node;
            return n.items.len;
        }

-----
#include <fu/vec.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Node n {};
    return n.items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        struct Other { using w: Node };

        struct Node {

            v: Other;          
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:30+1[0m:

[2m      | [0m
[2m    2 | [0m        struct Other { using [31;1mw[0m: Node };
[2m      | [0m
[2m      |         struct Node {[0m

	Type [31;1mOther[0m is self-recursive:

		via [35;1mfield[0m [34;1mv[0m at [2m6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Other;          
[2m      |         };[0m
[2m      | [0m


        Solving [35;1mtype[0m [34;1mOther[0m

-----

        struct Other { using w: Node };

        struct Node {

            v: Node;           
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Node;           
[2m      |         };[0m
[2m      | [0m

	Type [31;1mNode[0m is self-recursive:

		via [35;1mfield[0m [34;1mv[0m at [2m6:13+1[0m:

[2m      |         struct Node {[0m
[2m      | [0m
[2m    6 | [0m            [31;1mv[0m: Node;           
[2m      |         };[0m
[2m      | [0m


        Solving [35;1mtype[0m [34;1mNode[0m
                [35;1mtype[0m [34;1mOther[0m

-----

        struct Other { using w: Node };

        struct Node {

            v: i32;            
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }

-----
struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Node node {};
    if (node.v)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn sqr(implicit ref b: i32) {
            return b *= b;
        }

        fn main() {
            struct Hey {
                implicit a: i32;
                implicit b: i32;
            };

            using mut hey = Hey(10, 20);
            sqr();
            return hey.a == 10 && hey.b == 400 ? 0 : 1;
        }

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& sqr_azdBgL8V(int& b)
{
    return (b *= b);
}

int fu_MAIN()
{
    s_Hey hey = s_Hey { 10, 20 };
    sqr_azdBgL8V(hey.b);
    if ((hey.a == 10) && (hey.b == 400))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn sqr(implicit ref b: i32) {
            return b *= b;
        }

-----

#ifndef fu_NO_fdefs

int& sqr_azdBgL8V(int& b)
{
    return (b *= b);
}

#endif

-----

        fn sqr(implicit ref b: i32) {
            return b *= b;
        }
        pub import _0;
        fn main() {
            struct Hey {
                implicit a: i32;
                implicit b: i32;
            };

            using mut hey = Hey(10, 20);
            sqr();
            return hey.a == 10 && hey.b == 400 ? 0 : 1;
        }

-----
struct s_Hey;
int& sqr_azdBgL8V(int&);

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Hey hey = s_Hey { 10, 20 };
    sqr_azdBgL8V(hey.b);
    if ((hey.a == 10) && (hey.b == 400))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {

            mut y: x;                   
            y += x;
            return y;
        }

        fn main() test(2) - 4;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:20+1[0m:

[2m      |         fn test(x: i32) {[0m
[2m      | [0m
[2m    4 | [0m            mut y: [31;1mx[0m;                   
[2m      |             y += x;[0m
[2m      |             return y;[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m2:12+4[0m

-----

        fn test(x: i32) {

            mut y = x;                  
            y += x;
            return y;
        }

        fn main() test(2) - 4;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    int y = x;
    y += x;
    return y;
}

int fu_MAIN()
{
    return test_1WsbUdat(2) - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hey { v: i32 }

        fn test(x: Hey) {

            mut y: Hey(1);              
            y.v += x.v;
            return y;
        }

        fn main() test(Hey(2)).v - 3;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:23+1[0m:

[2m      |         fn test(x: Hey) {[0m
[2m      | [0m
[2m    6 | [0m            mut y: Hey[31;1m([0m1);              
[2m      |             y.v += x.v;[0m
[2m      |             return y;[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mfn[0m [34;1mtest[0m(Hey) at [2m4:12+4[0m

-----

        struct Hey { v: i32 }

        fn test(x: Hey) {

            mut y = Hey(1);             
            y.v += x.v;
            return y;
        }

        fn main() test(Hey(2)).v - 3;

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Hey test_YAsHP9KI(const s_Hey& x)
{
    s_Hey y = s_Hey { 1 };
    y.v += x.v;
    return y;
}

int fu_MAIN()
{
    return test_YAsHP9KI(s_Hey { 2 }).v - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        let x = 3;
        return x / 2 - 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 3;
    return (x / 2) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hey(a) a * a;
        fn main = 0.hey;

-----

#ifndef fu_NO_fdefs

inline static int hey_rgx2eiBu(const int a)
{
    return a * a;
}

int fu_MAIN()
{
    return hey_rgx2eiBu(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;

-----

#ifndef fu_NO_fdefs

inline static int div3by_zC7VUDzR(const int a)
{
    return 3 / a;
}

int fu_MAIN()
{
    return div3by_zC7VUDzR(2) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn div3by(a) 3 / a;
        return div3by(2) - 1;

-----

#ifndef fu_NO_fdefs

inline static int div3by_zC7VUDzR(const int a)
{
    return 3 / a;
}

int fu_MAIN()
{
    return div3by_zC7VUDzR(2) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn add3(a: i32, b = 3) a + b;
        fn main() add3(-3);

-----

#ifndef fu_NO_fdefs

static int add3_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return add3_hwGp0ETu(-3, 3);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn add3(a: $T, b = 3) a + b;
        struct v1 { x: i32; };
        fn +(a: v1, b: i32) v1(a.x + b);
        fn main() add3(2.v1).x - 5;

-----
struct s_v1;

                                #ifndef DEF_s_v1
                                #define DEF_s_v1
struct s_v1
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_v1 operator+(const s_v1& a, const int b)
{
    return s_v1 { (a.x + b) };
}

inline static s_v1 add3_HKCyv55L(const s_v1& a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return add3_HKCyv55L(s_v1 { 2 }, 3).x - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn mul_ab_init(a: $T, b = 0) a*b;
        fn main() mul_ab_init(1);

-----

#ifndef fu_NO_fdefs

inline static int mul_ab_init_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

int fu_MAIN()
{
    return mul_ab_init_hwGp0ETu(1, 0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn mul_ab_annot_init(a: $T, b: $T = 0) a*b;
        fn main() mul_ab_annot_init(1);

-----

#ifndef fu_NO_fdefs

inline static int mul_ab_annot_init_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

int fu_MAIN()
{
    return mul_ab_annot_init_hwGp0ETu(1, 0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn mul_ab_opt(a: $T, b?: $T) a*b;
        fn main() mul_ab_opt(1);

-----

#ifndef fu_NO_fdefs

inline static int mul_ab_opt_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

int fu_MAIN()
{
    return mul_ab_opt_hwGp0ETu(1, 0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ab(a, b) a + b*2;
        fn main() ab(b: 1, a: -2);

-----

#ifndef fu_NO_fdefs

inline static int ab_hwGp0ETu(const int a, const int b)
{
    return a + (b * 2);
}

int fu_MAIN()
{
    return ab_hwGp0ETu(-2, 1);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct yi32 { y: i32; };
        fn add_s_vy(v, s) s + v.y;
        fn main() add_s_vy(v: yi32(1), -1);

-----
struct s_yi32;

                                #ifndef DEF_s_yi32
                                #define DEF_s_yi32
struct s_yi32
{
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int add_s_vy_goqMdvjG(const s_yi32& v, const int s)
{
    return s + v.y;
}

int fu_MAIN()
{
    return add_s_vy_goqMdvjG(s_yi32 { 1 }, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct xi32 { x: i32; };
        fn add_s_vx(s, v) s + v.x; // <- args reordered
        fn main() add_s_vx(v: xi32(1), -1);

-----
struct s_xi32;

                                #ifndef DEF_s_xi32
                                #define DEF_s_xi32
struct s_xi32
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int add_s_vx_J4OY2oSc(const int s, const s_xi32& v)
{
    return s + v.x;
}

int fu_MAIN()
{
    return add_s_vx_J4OY2oSc(-1, s_xi32 { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ab(a, b = 0, c = 0) a + b*2 + c*3;
        fn main() ab(3, c: -1);

-----

#ifndef fu_NO_fdefs

inline static int ab_S3uH54Qk(const int a, const int b, const int c)
{
    return (a + (b * 2)) + (c * 3);
}

int fu_MAIN()
{
    return ab_S3uH54Qk(3, 0, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ab(a, b = -1) a + b*2;
        fn main() ab(3.0, -1.5).i32;

-----

#ifndef fu_NO_fdefs

inline static double ab_U75fvsW2(const double a, const double b)
{
    return a + (b * 2.0);
}

int fu_MAIN()
{
    return int(ab_U75fvsW2(3.0, -1.5));
}

#endif

int main() { return fu_MAIN(); }

-----

        let NEG_ONE_FIVE = -1.5;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(3, NEG_ONE_FIVE).i32;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_NEG_ONE_FIVE
                                #define DEF_NEG_ONE_FIVE
inline constexpr double NEG_ONE_FIVE = -1.5;
                                #endif

inline static double ab_U75fvsW2(const double a, const double b)
{
    return a + (b * 2.0);
}

int fu_MAIN()
{
    return int(ab_U75fvsW2(3.0, NEG_ONE_FIVE));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let TWO = 2.0;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(TWO).i32;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_TWO
                                #define DEF_TWO
inline constexpr double TWO = 2.0;
                                #endif

inline static double ab_U75fvsW2(const double a, const double b)
{
    return a + (b * 2.0);
}

int fu_MAIN()
{
    return int(ab_U75fvsW2(TWO, -1.0));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn self_rec_template(x: $T): $T
            x > 0 ? self_rec_template(x / 2 - 5) : x;

        fn main()
            self_rec_template(7) + 2;

-----
inline static int self_rec_template_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int self_rec_template_1WsbUdat(const int x)
{
    if (x > 0)
        return self_rec_template_1WsbUdat(((x / 2) - 5));
    else
        return x;

}

int fu_MAIN()
{
    return self_rec_template_1WsbUdat(7) + 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;
        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;
        fn main() ab_rec(11) + 200;

-----
inline static int ab_rec_rgx2eiBu(int);

#ifndef fu_NO_fdefs

inline static int ba_rec_rgx2eiBu(const int a)
{
    if (a)
        return ab_rec_rgx2eiBu((a - 7));
    else
        return -200;

}

inline static int ab_rec_rgx2eiBu(const int a)
{
    if (a)
        return ba_rec_rgx2eiBu((a - 2));
    else
        return -100;

}

int fu_MAIN()
{
    return ab_rec_rgx2eiBu(11) + 200;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn main() {
            let a = 1;
            fn add1(b) a + b;
            return 2.add1 - 3;
        }

-----

#ifndef fu_NO_fdefs

inline static int add1_YPDgoc8D(const int b, const int a)
{
    return a + b;
}

int fu_MAIN()
{
    const int a = 1;
    return add1_YPDgoc8D(2, a) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn MAP(a: [$T], fn) {               // !N_DeadCode
            mut res: typeof( fn($T) )[];
            res.grow_junk(a.len);
            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);
            return res;
        }

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> [$U]) a.MAP(fn clone);
        default {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };
        pub struct ModuleOutputs { deps: Scope[]; };

        pub fn test(a: ModuleOutputs) {
            let b = a.clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_ModuleOutputs;
struct s_Scope;

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    int x;
    s_Scope(const s_Scope&) = delete;
    s_Scope(s_Scope&&) = default;
    s_Scope& operator=(const s_Scope&) = delete;
    s_Scope& operator=(s_Scope&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOutputs
                                #define DEF_s_ModuleOutputs
struct s_ModuleOutputs
{
    fu::vec<s_Scope> deps;
    s_ModuleOutputs(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs(s_ModuleOutputs&&) = default;
    s_ModuleOutputs& operator=(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs& operator=(s_ModuleOutputs&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || deps
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_clone_rgx2eiBuuy6
                                #define DEF_clone_rgx2eiBuuy6
inline int clone_rgx2eiBu(const int a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_VZYffNibLX7
                                #define DEF_clone_VZYffNibLX7
inline s_Scope clone_VZYffNib(const s_Scope& a)
{
    /*MOV*/ s_Scope res {};
    res.x = clone_rgx2eiBu(a.x);
    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_MAP_7YSWl25zYqg
                                #define DEF_MAP_7YSWl25zYqg
inline fu::vec<s_Scope> MAP_7YSWl25z(fu::view<s_Scope> a)
{
    /*MOV*/ fu::vec<s_Scope> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = clone_VZYffNib(a[i]);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_clone_z6AtuhZdhNd
                                #define DEF_clone_z6AtuhZdhNd
inline fu::vec<s_Scope> clone_z6AtuhZd(fu::view<s_Scope> a)
{
    return MAP_7YSWl25z(a);
}
                                #endif

                                #ifndef DEF_clone_NFhH0TJoYDb
                                #define DEF_clone_NFhH0TJoYDb
inline s_ModuleOutputs clone_NFhH0TJo(const s_ModuleOutputs& a)
{
    /*MOV*/ s_ModuleOutputs res {};
    res.deps = clone_z6AtuhZd(a.deps);
    return /*NRVO*/ res;
}
                                #endif

int test_NFhH0TJo(const s_ModuleOutputs& a)
{
    s_ModuleOutputs b = clone_NFhH0TJo(a);
    return a.deps.size() - b.deps.size();
}

int fu_MAIN()
{
    return test_NFhH0TJo(s_ModuleOutputs{});
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X { a: i32; };
        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;
        fn hey(using x: X) add_uxa_b_inline(-1);
        return X(1).hey;

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hey_yYeWDNZS(const s_X& x)
{
    const int b = -1;
    return x.a + b;
}

int fu_MAIN()
{
    return hey_yYeWDNZS(s_X { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X { a: i32; };
        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;
        fn hey(using x: X) add_uxa_b_template(-1);
        return X(1).hey;

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int add_uxa_b_template_ZfEKdHzu(const s_X& x, const int b)
{
    return x.a + b;
}

static int hey_yYeWDNZS(const s_X& x)
{
    return add_uxa_b_template_ZfEKdHzu(x, -1);
}

int fu_MAIN()
{
    return hey_yYeWDNZS(s_X { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        fn incr(a) a++;
        fn main() {
            mut a = 1;
            incr: || a;
            return a - 2;
        }

-----

#ifndef fu_NO_fdefs

static int& l_1_0_y1jV3SX3(int& a)
{
    return a;
}

inline static int incr_zrokyJtF(int& a)
{
    return l_1_0_y1jV3SX3(a)++;
}

int fu_MAIN()
{
    int a = 1;
    incr_zrokyJtF(a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn inl_lies(x: u32): i32 = x;
        fn main() 0.inl_lies ? 1 : 0;                           ;; PointlessLocal

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:43+1[0m:

[2m      | [0m
[2m    2 | [0m        inline fn inl_lies(x: u32): i32 = [31;1mx[0m;
[2m      |         fn main() 0.inl_lies ? 1 : 0;                           // PointlessLocal[0m
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- u32 copy

        Solving [35;1mfn[0m [34;1minl_lies[0m(u32) at [2m2:19+8[0m

-----

        inline fn inl_lies(x: u32) = x;
        fn main() 0.inl_lies ? 1 : 0;                           // PointlessLocal

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    // Hoisted:
    unsigned x;

    if ((x = 0u, x))
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn what(ref x: i32, ref y: i32) {

            let z = y;   
            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),
        }                //  we ignore the 'ref' part in type patterns,
                         //   so we only notice later when checking the spec
        fn main() {
            mut a = 1; mut b = 0; what(a, b);
            return a;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:17+1[0m:

[2m      | [0m
[2m      |             let z = y;   [0m
[2m    5 | [0m            swap[31;1m([0mx, z);  // swap is defined(ref x: $T, ref y: $T),
[2m      |         }                //  we ignore the 'ref' part in type patterns,[0m
[2m      |                          //   so we only notice later when checking the spec[0m

	Bad call to [34;1mswap[0m with args (i32 mutref copy, i32 copy): 

	[35;1mtemplate[0m [34;1m
<fu/vec/view_swap.h>
fu::view_swap[0m at [2m../../../../../[0mprelude[2m 367:4+4[0m:
[2m  367 | [0mfn [31;1mswap[0m !T(ref a: T[:], i: int, j: int): void __native("<fu/vec/view_swap.h>", "fu::view_swap");

	    Wrong number of arguments: expects 3, got 2.

	[35;1mtemplate[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m at [2m../../../../../[0mprelude[2m 169:4+4[0m:
[2m  169 | [0mfn [31;1mswap[0m !T(ref a: T, ref b: T): void __native(

	    [35;1marg[0m [34;1mb[0m:
	    Not a mutref: i32 copy

        Solving [35;1mfn[0m [34;1mwhat[0m(i32, i32) at [2m2:12+4[0m

-----

        fn what(ref x: i32, ref y: i32) {

            ref z = y;   
            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),
        }                //  we ignore the 'ref' part in type patterns,
                         //   so we only notice later when checking the spec
        fn main() {
            mut a = 1; mut b = 0; what(a, b);
            return a;
        }

-----
#include <utility>


#ifndef fu_NO_fdefs

static void what_DSvw0ZaL(int& x, int& y)
{
    std::swap(x, y);
}

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    what_DSvw0ZaL(a, b);
    return a;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn any(a, b) a || b;
        fn main() any(0, []);

-----

#ifndef fu_NO_fdefs

inline static int any_CmhOujht(const int a)
{
    return a ? a : 0;
}

int fu_MAIN()
{
    return any_CmhOujht(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn both(a, b) a && b;
        fn main() both(1, []);

-----

#ifndef fu_NO_fdefs

void fu_MAIN()
{
    return;
}

#endif

int main() { return fu_MAIN(), 0; }

// N_UnusedCall, N_UnusedAndOr

-----

        fn either(a, b) a ? a : b;
        fn main() either(0, []);

-----

#ifndef fu_NO_fdefs

inline static int either_CmhOujht(const int a)
{
    if (a)
        return a;
    else
        return 0;

}

int fu_MAIN()
{
    return either_CmhOujht(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn both_same_type(_, y) =
            typeof(y) -> $T;

        fn main()   = both_same_type(1.u32, 1.i32) ? 1
                    : both_same_type(1.i32, 1.i32) ? 0
                    : 2;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:26+1[0m:

[2m      | [0m
[2m      |         fn both_same_type(_, y) =[0m
[2m    3 | [0m            typeof(y) -> [31;1m$[0mT;
[2m      | [0m
[2m      |         fn main()   = both_same_type(1.u32, 1.i32) ? 1[0m

	Bad call to [34;1m$T[0m: [34;1m$T[0m is not defined here.

        Solving [35;1mfn[0m [34;1mboth_same_type[0m(u32, i32) at [2m2:12+14[0m
                [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn both_same_type(_: $T, y) =
            typeof(y) -> $T;

        fn main()   = both_same_type(1.u32, 1.i32) ? 1
                    : both_same_type(1.i32, 1.i32) ? 0
                    : 2;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn arrof !T(lax _: T[], type U)
            case (T -> U)   true;
            default         false;

        fn main() {
            mut a: i32[];
            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

-----

        fn main() {
            mut x: i32 = 0;
            return (typeof(x) -> &mut i32).i32 - 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(true) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        fn work(visit) visit(1, 2);
        fn main() work: |_, _| return 0;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        fn each(ref moot: u32) moot++;

        fn Lifetime_process(lt: string, each) {
            for (mut i = 0; i < lt.len; i++) {
                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude
                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,
                                             // ^^^^ /////   resulting in a new mangle on each go.
                each(climb: fn climb, lt.slice(i, lt.len));
            }
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= " " ~ lt;
                if (let init = lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == " abc ab a b bc b c" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void Lifetime_process_ORW5THM5(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

static void climb_Kf5AzLh0(fu::str&& parent, fu::str& result)
{
    Lifetime_process_ORW5THM5(parent, result);
}

inline static void l_1_0_pww2o411(const fu::str& lt, fu::str& result)
{
    result += (" "_fu + lt);
    if (/*MOV*/ fu::str init = fu::slice(lt, 0, (lt.size() - 1)))
        climb_Kf5AzLh0(static_cast<fu::str&&>(init), result);

}

inline static void Lifetime_process_ORW5THM5(const fu::str& lt, fu::str& result)
{
    for (int i = 0; i < lt.size(); i++)
        l_1_0_pww2o411(fu::slice(lt, i, lt.size()), result);

}

static void climb_29tMYhWq(fu::str&& parent, fu::str& result)
{
    Lifetime_process_ORW5THM5(parent, result);
}

inline static void l_1_0_mC1rOBVj(const fu::str& lt, fu::str& result)
{
    result += (" "_fu + lt);
    if (/*MOV*/ fu::str init = fu::slice(lt, 0, (lt.size() - 1)))
        climb_29tMYhWq(static_cast<fu::str&&>(init), result);

}

inline static void Lifetime_process_jQX9aGR7(const fu::str& lt, fu::str& result)
{
    for (int i = 0; i < lt.size(); i++)
        l_1_0_mC1rOBVj(fu::slice(lt, i, lt.size()), result);

}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_jQX9aGR7("abc"_fu, result);
    if (result == " abc ab a b bc b c"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        pub fn identity(dont_leak_me) dont_leak_me;

-----

-----

        pub fn identity(dont_leak_me) dont_leak_me;

        let dont_leak_me = 1;
        fn main() _0::identity(dont_leak_me * 2) - 2;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_dont_leak_me
                                #define DEF_dont_leak_me
inline constexpr int dont_leak_me = 1;
                                #endif

                                #ifndef DEF_identity_a8GrU83kAO6
                                #define DEF_identity_a8GrU83kAO6
inline int identity_a8GrU83k(const int dont_leak_me)
{
    return dont_leak_me;
}
                                #endif

int fu_MAIN()
{
    return identity_a8GrU83k((dont_leak_me * 2)) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;
        let dont_leak_me = 1;
        fn main() inl_id_leak(dont_leak_me * 2) - 2;            // PointlessLocal

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_dont_leak_me
                                #define DEF_dont_leak_me
inline constexpr int dont_leak_me = 1;
                                #endif

int fu_MAIN()
{
    // Hoisted:
    int dont_leak_me;

    return (dont_leak_me = (::dont_leak_me * 2), dont_leak_me) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit, N_SD_ExternPrivates

-----

        let static = 1;
        fn template(arg) static + arg;
        let arg = 7;                        // <- template shouldn't see this
        let result = template(arg / -4);    // <- when specializing here
        fn main() result;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_arg
                                #define DEF_arg
inline constexpr int arg = 7;
                                #endif

                                #ifndef DEF_static
                                #define DEF_static
inline constexpr int sTatic = 1;
                                #endif

inline static int tEmplate_TQKdZnfn(const int arg)
{
    return sTatic + arg;
}

static const int result = tEmplate_TQKdZnfn((arg / -4));

int fu_MAIN()
{
    return result;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn main() {
            let static = 1;
            fn template(arg) static + arg;
            let arg = 7; // same here, except we're in a fn.
            return template(arg / -4);
        }

-----

#ifndef fu_NO_fdefs

inline static int tEmplate_FwnjMJ8b(const int arg, const int sTatic)
{
    return sTatic + arg;
}

int fu_MAIN()
{
    const int sTatic = 1;
    const int arg = 7;
    return tEmplate_FwnjMJ8b((arg / -4), sTatic);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn template_add(a, b) a + b;

-----

-----

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };

        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);
        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;

-----
struct s_HasInt;

                                #ifndef DEF_s_HasInt
                                #define DEF_s_HasInt
struct s_HasInt
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_HasInt operator+(const s_HasInt& a, const s_HasInt& b)
{
    return s_HasInt { (a.i + b.i) };
}

                                #ifndef DEF_template_add_XE8HIvbfRZg
                                #define DEF_template_add_XE8HIvbfRZg
inline s_HasInt template_add_XE8HIvbf(const s_HasInt& a, const s_HasInt& b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return template_add_XE8HIvbf(s_HasInt { 1 }, s_HasInt { 2 }).i - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn template_add(a, b) a + b;

-----

-----

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };

-----

-----

        fn template_add(a, b) a + b;

        struct HasInt { i: i32 };
        pub import _1;
        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);
        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;

-----
struct s_HasInt;

                                #ifndef DEF_s_HasInt
                                #define DEF_s_HasInt
struct s_HasInt
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_HasInt operator+(const s_HasInt& a, const s_HasInt& b)
{
    return s_HasInt { (a.i + b.i) };
}

                                #ifndef DEF_template_add_XE8HIvbfRZg
                                #define DEF_template_add_XE8HIvbfRZg
inline s_HasInt template_add_XE8HIvbf(const s_HasInt& a, const s_HasInt& b)
{
    return a + b;
}
                                #endif

int fu_MAIN()
{
    return template_add_XE8HIvbf(s_HasInt { 1 }, s_HasInt { 2 }).i - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);

-----
static int outer_gxK8vPkQ(int);

#ifndef fu_NO_fdefs

static int inner_vnk4p5KO(const int i)
{
    if (i > 0)
        return outer_gxK8vPkQ((i - 1));
    else
        return 0;

}

static int outer_gxK8vPkQ(const int i)
{
    return 2 * inner_vnk4p5KO(i);
}

int fu_MAIN()
{
    return outer_gxK8vPkQ(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn test(one: i32) {
            let zero = one - 1;
            let two  = one * 2;


            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;

-----
static int outer_fhJA7Yvq(int, int, int, int);

#ifndef fu_NO_fdefs

static int inner_QMLv5Fix(const int i, const int one, const int zero, const int two)
{
    if (i > zero)
        return outer_fhJA7Yvq((i - one), one, zero, two);
    else
        return zero;

}

static int outer_fhJA7Yvq(const int i, const int one, const int zero, const int two)
{
    return two * inner_QMLv5Fix(i, one, zero, two);
}

static int test_QzqjZbJI(const int one)
{
    const int zero = (one - 1);
    const int two = (one * 2);
    return outer_fhJA7Yvq(one, one, zero, two) + ((two - one) * 17);
}

int fu_MAIN()
{
    return test_QzqjZbJI(1) - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn test(one: i32) {
            let zero = one - 1;
            let two  = one * 2;


            inline 
            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;

-----
static int outer_fhJA7Yvq(int, int, int, int);

#ifndef fu_NO_fdefs

static int outer_fhJA7Yvq(const int i, const int one, const int zero, const int two)
{
    return two * ((i > zero) ? outer_fhJA7Yvq((i - one), one, zero, two) : zero);
}

static int test_QzqjZbJI(const int one)
{
    const int zero = (one - 1);
    const int two = (one * 2);
    return outer_fhJA7Yvq(one, one, zero, two) + ((two - one) * 17);
}

int fu_MAIN()
{
    return test_QzqjZbJI(1) - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;

-----
static int outer_cZIi5x0V(int, int);

#ifndef fu_NO_fdefs

static int inner_fiZQh1P1(const int i, const int x)
{
    return outer_cZIi5x0V((i - 1), x);
}

static int outer_cZIi5x0V(const int i, const int x)
{
    if (i > 0)
        return inner_fiZQh1P1(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_cZIi5x0V(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn inner_noret(i: i32)
            outer_noret(i - 1);

        fn outer_noret(implicit x: i32, i: i32)
            i > 0   ? inner_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_noret(1) - 7;

-----
static int outer_noret_cZIi5x0V(int, int);

#ifndef fu_NO_fdefs

static int inner_noret_fiZQh1P1(const int i, const int x)
{
    return outer_noret_cZIi5x0V((i - 1), x);
}

static int outer_noret_cZIi5x0V(const int i, const int x)
{
    if (i > 0)
        return inner_noret_fiZQh1P1(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_noret_cZIi5x0V(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        inline fn inner_inl(i: i32): i32
            outer_inl(i - 1);

        fn outer_inl(implicit x: i32, i: i32): i32
            i > 0   ? inner_inl(i)
                    : x + i;

        let implicit x = 7;
        return outer_inl(1) - 7;

-----
static int outer_inl_cZIi5x0V(int, int);

#ifndef fu_NO_fdefs

static int outer_inl_cZIi5x0V(const int i, const int x)
{
    if (i > 0)
        return outer_inl_cZIi5x0V((i - 1), x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_inl_cZIi5x0V(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn inner_templ(i): i32
            outer_templ(i - 1);

        fn outer_templ(implicit x: i32, i): i32
            i > 0   ? inner_templ(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ(1) - 7;

-----
inline static int outer_templ_DqAkaqXX(int, int);

#ifndef fu_NO_fdefs

inline static int inner_templ_OCnHhNNl(const int i, const int x)
{
    return outer_templ_DqAkaqXX((i - 1), x);
}

inline static int outer_templ_DqAkaqXX(const int i, const int x)
{
    if (i > 0)
        return inner_templ_OCnHhNNl(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_templ_DqAkaqXX(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn inner_templ_noret(i)
            outer_templ_noret(i - 1);

        fn outer_templ_noret(implicit x: i32, i)
            i > 0   ? inner_templ_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ_noret(1) - 7;

-----
inline static int outer_templ_noret_DqAkaqXX(int, int);

#ifndef fu_NO_fdefs

inline static int inner_templ_noret_OCnHhNNl(const int i, const int x)
{
    return outer_templ_noret_DqAkaqXX((i - 1), x);
}

inline static int outer_templ_noret_DqAkaqXX(const int i, const int x)
{
    if (i > 0)
        return inner_templ_noret_OCnHhNNl(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_templ_noret_DqAkaqXX(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);

-----
static int outer_fiZQh1P1(int, int);

#ifndef fu_NO_fdefs

static int inner_cZIi5x0V(const int i, const int x)
{
    return outer_fiZQh1P1((i - (2 * x)), x);
}

static int outer_fiZQh1P1(const int i, const int x)
{
    if (i > 0)
        return inner_cZIi5x0V(i, x);
    else
        return 2 * i;

}

int fu_MAIN()
{
    const int x = 3;
    return outer_fiZQh1P1(6, x);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn has_implicit(implicit i: i32, add: i32): i32
            i + add;

        inline fn injects_implicit_while_inlined(): i32
            has_implicit(1); // broken by no ss.declash

        fn main() {
            let implicit i = 2;
            return injects_implicit_while_inlined() - 3;
        }

-----

#ifndef fu_NO_fdefs

static int has_implicit_aGNjbRpq(const int add, const int i)
{
    return i + add;
}

int fu_MAIN()
{
    const int i = 2;
    return has_implicit_aGNjbRpq(1, i) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn outer_inl(i: i32): i32
            i > 0   ? inner_inl(i)
                    : 2 * i;

        fn inner_inl(implicit x: i32, i: i32): i32
            outer_inl(i - 2 * x); // broken by no ss.declash

        let implicit x = 3;
        return outer_inl(6);

-----
static int inner_inl_cZIi5x0V(int, int);

#ifndef fu_NO_fdefs

static int inner_inl_cZIi5x0V(const int i, const int x)
{
    const int i_1 = (i - (2 * x));
    if (i_1 > 0)
        return inner_inl_cZIi5x0V(i_1, x);
    else
        return 2 * i_1;

}

int fu_MAIN()
{
    const int x = 3;
    const int i = 6;
    if (i > 0)
        return inner_inl_cZIi5x0V(i, x);
    else
        return 2 * i;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn outer_templ(i): i32
            i > 0   ? inner_templ(i)
                    : 2 * i;

        fn inner_templ(implicit x: i32, i): i32
            outer_templ(i - 2 * x);

        let implicit x = 3;
        return outer_templ(6);

-----
inline static int outer_templ_oIbIj47x(int, int);

#ifndef fu_NO_fdefs

inline static int inner_templ_cXfHOBAp(const int i, const int x)
{
    return outer_templ_oIbIj47x((i - (2 * x)), x);
}

inline static int outer_templ_oIbIj47x(const int i, const int x)
{
    if (i > 0)
        return inner_templ_cXfHOBAp(i, x);
    else
        return 2 * i;

}

int fu_MAIN()
{
    const int x = 3;
    return outer_templ_oIbIj47x(6, x);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        fn inner(i: i32): i32
            outer(i - 1);

        let implicit x = 7;
        return outer(1) - 7;

-----
static int outer_y45MBzZX(int, int);

#ifndef fu_NO_fdefs

static int inner_Npkmth2H(const int i, const int x)
{
    return outer_y45MBzZX((i - 1), x);
}

static int outer_y45MBzZX(const int i, const int x)
{
    if (i > 0)
        return inner_Npkmth2H(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_y45MBzZX(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn outer(implicit x: i32, i: i32)
            i > 0   ? inner(i)
                    : x + i;

        fn noret(i: i32) = outer(i);

        fn template(i) = i & 1 ? outer(i) : noret(i);

        fn inner(i: i32): i32
            template(i - 1);

        fn main() {
            let implicit x = 7;
            return outer(1) - 7;
        }

-----
static int outer_JoKfhnhH(int, int);

#ifndef fu_NO_fdefs

static int noret_XRPvIBMQ(const int i, const int x)
{
    return outer_JoKfhnhH(i, x);
}

inline static int tEmplate_XRPvIBMQ(const int i, const int x)
{
    if (i & 1)
        return outer_JoKfhnhH(i, x);
    else
        return noret_XRPvIBMQ(i, x);

}

static int inner_XRPvIBMQ(const int i, const int x)
{
    return tEmplate_XRPvIBMQ((i - 1), x);
}

static int outer_JoKfhnhH(const int i, const int x)
{
    if (i > 0)
        return inner_XRPvIBMQ(i, x);
    else
        return x + i;

}

int fu_MAIN()
{
    const int x = 7;
    return outer_JoKfhnhH(1, x) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_1(call_self = false): i32
            = !call_self ? returns_x : calls_self_1 * 2;

        let implicit x = 7;
        return calls_self_1(true) - 14;

-----
static int calls_self_1_R1uU3beJ(bool, int);

#ifndef fu_NO_fdefs

static int returns_x_ivU7bd4O(const int x)
{
    return x;
}

static int calls_self_1_R1uU3beJ(const bool call_self, const int x)
{
    if (!call_self)
        return returns_x_ivU7bd4O(x);
    else
        return calls_self_1_R1uU3beJ(false, x) * 2;

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_1_R1uU3beJ(true, x) - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_2(call_self = false): i32
            = call_self ? calls_self_2 * 3 : returns_x;

        let implicit x = 7;
        return calls_self_2(true) - 21;

-----
static int calls_self_2_R1uU3beJ(bool, int);

#ifndef fu_NO_fdefs

static int returns_x_ivU7bd4O(const int x)
{
    return x;
}

static int calls_self_2_R1uU3beJ(const bool call_self, const int x)
{
    if (call_self)
        return calls_self_2_R1uU3beJ(false, x) * 3;
    else
        return returns_x_ivU7bd4O(x);

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_2_R1uU3beJ(true, x) - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_3(call_self = false): i32
        {
            let add = 1; // <- this wasnt visible
            fn do_call_self(mul: i32 = 0)
                = calls_self_3 * mul + add;

            return call_self ? do_call_self(4) : returns_x;
        }

        let implicit x = 7;
        return calls_self_3(true) - 29;

-----
static int calls_self_3_R1uU3beJ(bool, int);

#ifndef fu_NO_fdefs

static int do_call_self_GKmRN27n(const int mul, const int add, const int x)
{
    return (calls_self_3_R1uU3beJ(false, x) * mul) + add;
}

static int returns_x_ivU7bd4O(const int x)
{
    return x;
}

static int calls_self_3_R1uU3beJ(const bool call_self, const int x)
{
    const int add = 1;
    if (call_self)
        return do_call_self_GKmRN27n(4, add, x);
    else
        return returns_x_ivU7bd4O(x);

}

int fu_MAIN()
{
    const int x = 7;
    return calls_self_3_R1uU3beJ(true, x) - 29;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn noret_x(implicit x: i32) x;

        fn templ_calls_self_2(call_self): i32
            = call_self ? templ_calls_self_2(false) * 3 : noret_x;

        fn main() {
            let implicit x = 7;
            return templ_calls_self_2(true) - 21;
        }

-----
inline static int templ_calls_self_2_rjx9YxYo(bool, int);

#ifndef fu_NO_fdefs

static int noret_x_1WsbUdat(const int x)
{
    return x;
}

inline static int templ_calls_self_2_rjx9YxYo(const bool call_self, const int x)
{
    if (call_self)
        return templ_calls_self_2_rjx9YxYo(false, x) * 3;
    else
        return noret_x_1WsbUdat(x);

}

int fu_MAIN()
{
    const int x = 7;
    return templ_calls_self_2_rjx9YxYo(true, x) - 21;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_xbEj0oOd(const s_Range& r)
{
    return r.max - r.min;
}

static int test_fwJRfWgj(const s_Range& r)
{
    return size_xbEj0oOd(r);
}

int fu_MAIN()
{
    const s_Range r = s_Range { 14, 21 };
    return test_fwJRfWgj(r) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;

-----
struct s_Range;

                                #ifndef DEF_s_Range
                                #define DEF_s_Range
struct s_Range
{
    int min;
    int max;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || max
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int size_xbEj0oOd(const s_Range& r)
{
    return r.max - r.min;
}

static int inner_fwJRfWgj(const s_Range& r)
{
    return size_xbEj0oOd(r);
}

static int outer_GlILXiYX(const s_Range& r)
{
    return inner_fwJRfWgj(r);
}

int fu_MAIN()
{
    const s_Range r = s_Range { 14, 21 };
    return outer_GlILXiYX(r) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let a = 1;
            let b = 2;
            let c = 3;

            fn depth1(x: i32) {
                fn depth2(y: i32) {
                    return sibling1(x + y + b);
                }

                return depth2(x + a);
            }

            fn sibling1(z: i32): i32 {
                return z + c;
            }

            return depth1(0) - 6;
        }

-----

#ifndef fu_NO_fdefs

static int sibling1_dG4Tgwni(const int z, const int c)
{
    return z + c;
}

static int depth2_uez94itn(const int y, const int x, const int b, const int c)
{
    return sibling1_dG4Tgwni(((x + y) + b), c);
}

static int depth1_8garyT7W(const int x, const int a, const int b, const int c)
{
    return depth2_uez94itn((x + a), x, b, c);
}

int fu_MAIN()
{
    const int a = 1;
    const int b = 2;
    const int c = 3;
    return depth1_8garyT7W(0, a, b, c) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn goto0(x): i32 = x ? goto0(x / 2) : 0;
        fn main() goto0(1);

-----
inline static int goto0_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int goto0_1WsbUdat(const int x)
{
    if (x)
        return goto0_1WsbUdat((x / 2));
    else
        return 0;

}

int fu_MAIN()
{
    return goto0_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn goto0(x) x ? goto0(x / 2) : 0;
        fn main() goto0(1);

-----
inline static int goto0_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int goto0_1WsbUdat(const int x)
{
    if (x)
        return goto0_1WsbUdat((x / 2));
    else
        return 0;

}

int fu_MAIN()
{
    return goto0_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above
        fn main() goto0(1);

-----
inline static int goto0_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int goto0_1WsbUdat(const int x)
{
    if (x)
        return goto0_1WsbUdat((x / 2));
    else
        return x;

}

int fu_MAIN()
{
    return goto0_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]
        fn main() goto0(1);

-----
inline static int goto0_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int goto0_1WsbUdat(const int x)
{
    if (x)
        return goto0_1WsbUdat((x / 2));
    else
        return 0;

}

int fu_MAIN()
{
    return goto0_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn ref_a(ref a: i32) a;

        fn main() {
            mut a: i32;
            ref r = ref_a(a);
            r++;
            return a - 1;
        }

-----

#ifndef fu_NO_fdefs

static int& ref_a_wQ3JO5Ij(int& a)
{
    return a;
}

int fu_MAIN()
{
    int a {};
    int& /*a*/ r = ref_a_wQ3JO5Ij(a);
    r++;
    return a - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ref_a_or_ref_b(ref a: i32, ref b: i32)
            a || b;

        fn main() {
            mut a: i32;
            mut b: i32;
            ref a_or_b = ref_a_or_ref_b(a, b);
            a_or_b++;
            return b - 1;
        }

-----

#ifndef fu_NO_fdefs

static int& ref_a_or_ref_b_qg01zOoD(int& a, int& b)
{
    return a ? a : b;
}

int fu_MAIN()
{
    int a {};
    int b {};
    int& /*b|a*/ a_or_b = ref_a_or_ref_b_qg01zOoD(a, b);
    a_or_b++;
    return b - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn impl(implicit ref _impl: i32) _impl;
        fn arg_or_impl(ref arg: i32) arg || impl;
        fn main() {
            implicit mut _impl: i32;
            mut arg: i32;
            ref ref = arg_or_impl(arg);
            return arg - ref;
        }

-----

#ifndef fu_NO_fdefs

static int& impl_0rNvuzyC(int& _impl)
{
    return _impl;
}

static int& arg_or_impl_JTrVyJuw(int& arg, int& _impl)
{
    return arg ? arg : impl_0rNvuzyC(_impl);
}

int fu_MAIN()
{
    int _impl {};
    int arg {};
    const int /*arg|_impl*/ ref = arg_or_impl_JTrVyJuw(arg, _impl);
    return arg - ref;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {
            if (x == 0) return a;
            if (x == 1) return b;
            return hello(b, a, x / 17);
        }

        fn main() {
            mut a = [1, 2, 3];
            mut b = [4, 5, 6];
            hello(a, b, 397)[1] *= 5;
            return b[1] - 25;
        }

-----
#include <fu/vec.h>

static fu::vec<int>& hello_PYdO6GKG(fu::vec<int>&, fu::vec<int>&, int);

#ifndef fu_NO_fdefs

static fu::vec<int>& hello_PYdO6GKG(fu::vec<int>& a, fu::vec<int>& b, const int x)
{
    if (x == 0)
        return a;
    else if (x == 1)
        return b;
    else
        return hello_PYdO6GKG(b, a, (x / 17));

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<3, int> { 4, 5, 6 } };
    hello_PYdO6GKG(a, b, 397).mutref(1) *= 5;
    return b[1] - 25;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                ZERO( --x ); // Same as below but without the unused 'y' thing,
                sum += x;    //  everything works because the call to ZERO isnt really unconditional,
            }                //   and if it were, then the never return would actually be correct.
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 11;
        }

-----
void ZERO_I60tVEg6(int, int&);

#ifndef fu_NO_fdefs

void ZERO_I60tVEg6(int x, int& sum)
{
    while (x)
    {
        ZERO_I60tVEg6(--x, sum);
        sum += x;
    };
}

int fu_MAIN()
{
    int sum = 0;
    ZERO_I60tVEg6(4, sum);
    return sum - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                let y = x / 2;
                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,
                ZERO(   y ); //  meaning y remains unused here on first solve.
                sum += x;
            }
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 12;
        }

-----
void ZERO_I60tVEg6(int, int&);

#ifndef fu_NO_fdefs

void ZERO_I60tVEg6(int x, int& sum)
{
    while (x)
    {
        const int y = (x / 2);
        ZERO_I60tVEg6(--x, sum);
        ZERO_I60tVEg6(y, sum);
        sum += x;
    };
}

int fu_MAIN()
{
    int sum = 0;
    ZERO_I60tVEg6(4, sum);
    return sum - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_UnusedCall, N_UnusedLet

-----

        struct Node {
            items: Node[];
        }

        fn solve(root: Node)
        {
            fn solveBlock(node: Node) {
                let items = solveNodes(node.items);
                return solveBlock(items);                       // ConstCast
            }

            fn solveBlock(items: i32[]) {
                if (!Lifetime_allowsMutrefReturn(items))
                    throw("Nope!");

                return items;
            }

            fn solveNode(node: Node, implicit ref next: i32) {
                if (!node.items)
                    return [ next++ ];

                let implicit CTX = node.items.len; // <- this shows up as an closure-arg with an outdated revision
                return solveBlock(node);
            }

            fn Lifetime_each(items, visit)
                for (mut i = items.len; i --> 0; )
                    visit(items[i]);

            fn Lifetime_allowsMutrefReturn(items: i32[]) {
                Lifetime_each(:items, visit: |item, implicit CTX: i32| {
                    if (item == CTX)
                        return false;
                });

                return true;
            }

            fn solveNodes(nodes: Node[]) {
                mut result: i32[];
                for (mut i = 0; i < nodes.len; i++)
                    result ~= solveNode(nodes[i]);

                return result;
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut next = 0;

            let solve = solve(Node([
                Node([ Node ]),
                Node(),
            ]));

            return solve.len - 2;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct s_Node;
static fu::vec<int> solveNode_RQvseiJY(const s_Node&, int&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> solveNodes_sl2JRp1C(fu::view<s_Node> nodes, int& next)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < nodes.size(); i++)
        result += solveNode_RQvseiJY(nodes[i], next);

    return /*NRVO*/ result;
}

static bool Lifetime_allowsMutrefReturn_2Fg7iks6(fu::view<int> items, const int CTX)
{
    for (int i = items.size(); i-- > 0; )
    {
        const int /*items|static*/ item = items[i];
        if (item == CTX)
            return false;

    };
    return true;
}

static const fu::vec<int>& solveBlock_yFXpp6fX(const fu::vec<int>& items, const int CTX)
{
    if (!Lifetime_allowsMutrefReturn_2Fg7iks6(items, CTX))
        fu::fail("Nope!"_fu);
    else
        return items;

}

static fu::vec<int> solveBlock_SYr2k8qk(const s_Node& node, const int CTX, int& next)
{
    /*MOV*/ fu::vec<int> items = solveNodes_sl2JRp1C(node.items, next);
    return static_cast<fu::vec<int>&&>(const_cast<fu::vec<int>&>(solveBlock_yFXpp6fX(items, CTX)));
}

static fu::vec<int> solveNode_RQvseiJY(const s_Node& node, int& next)
{
    if (!node.items)
    {
        return fu::vec<int> { fu::slate<1, int> { next++ } };
    }
    else
    {
        const int CTX = node.items.size();
        return solveBlock_SYr2k8qk(node, CTX, next);
    };
}

static fu::vec<int> solve_StKiOaNj(const s_Node& root, int& next)
{
    return solveNode_RQvseiJY(root, next);
}

int fu_MAIN()
{
    int next = 0;
    fu::vec<int> solve = solve_StKiOaNj(s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } }, s_Node{} } } }, next);
    return solve.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_UnusedCall, N_UnusedLet

-----

        fn woot(implicit x: i32) = x;

        fn main() {


            return woot() - 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:24+1[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            return woot[31;1m([0m) - 2;
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mx[0m: i32 copy in scope, needed to call [35;1mfn[0m [34;1mwoot[0m:

            because of [35;1mimplicit arg[0m [34;1mx[0m at [2m2:26+1[0m:

[2m      | [0m
[2m    2 | [0m        fn woot(implicit [31;1mx[0m: i32) = x;
[2m      | [0m
[2m      |         fn main() {[0m


        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        fn woot(implicit x: i32) = x;

        fn main() {

            let implicit x = 2;

            return woot() - 2;
        }

-----

#ifndef fu_NO_fdefs

static int woot_1WsbUdat(const int x)
{
    return x;
}

int fu_MAIN()
{
    const int x = 2;
    return woot_1WsbUdat(x) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----


        fn woot(implicit y: i32) = y;


        fn hey() {
            let implicit x = 2;
            return woot() - 2;
        }

        let here = hey();
        fn main() = here;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:23+1[0m:

[2m      |         }[0m
[2m      | [0m
[2m   11 | [0m        let here = hey[31;1m([0m);
[2m      |         fn main() = here;[0m
[2m      | [0m

	No implicit [31;1my[0m: i32 copy in scope, needed to call [35;1mfn[0m [34;1mhey[0m:

            because of call to [35;1mfn[0m [34;1mwoot[0m at [2m8:24+1[0m:

[2m      |         fn hey() {[0m
[2m      |             let implicit x = 2;[0m
[2m    8 | [0m            return woot[31;1m([0m) - 2;
[2m      |         }[0m
[2m      | [0m

            because of [35;1mimplicit arg[0m [34;1my[0m at [2m3:26+1[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn woot(implicit [31;1my[0m: i32) = y;
[2m      | [0m
[2m      | [0m


-----


        fn woot(implicit x: i32) = x;


        fn hey() {
            let implicit x = 2;
            return woot() - 2;
        }

        let here = hey();
        fn main() = here;

-----

#ifndef fu_NO_fdefs

static int woot_1WsbUdat(const int x)
{
    return x;
}

static int hey_H9fhQUVP()
{
    const int x = 2;
    return woot_1WsbUdat(x) - 2;
}

static const int here = hey_H9fhQUVP();

int fu_MAIN()
{
    return here;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn main() {
            mut x = +1;
            mut y: typeof(x) = -x;
            return x + y;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = +1;
    const int y = -x;
    return x + y;
}

#endif

int main() { return fu_MAIN(); }

-----

        // N_UnusedImplicit
        fn dont_inject_my_implicit_args(implicit unused_implicit_arg: i32) {
            return unused_implicit_arg;
        }

        fn not_extern() {
            mut x: typeof(dont_inject_my_implicit_args) = 2;
            return x;
        }

        fn not_extern(mut x: typeof(dont_inject_my_implicit_args)) {
            return x;
        }

        fn main() {
            return not_extern() + not_extern(-2);
        }

-----

#ifndef fu_NO_fdefs

static int not_extern_H9fhQUVP()
{
    const int x = 2;
    return x;
}

static int not_extern_1WsbUdat(const int x)
{
    return x;
}

int fu_MAIN()
{
    return not_extern_H9fhQUVP() + not_extern_1WsbUdat(-2);
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit

-----

        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {

            x *= 3;             
        }

        fn main() {
            mut x = 7;
            implicit forgot_to_use = 3;
            mustwarn_unused_implicit(x);
            return x == forgot_to_use * 7 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:46+13[0m:

[2m      | [0m
[2m    2 | [0m        fn mustwarn_unused_implicit(implicit [31;1mforgot_to_use[0m: i32, ref x: i32) {
[2m      | [0m
[2m      |             x *= 3;             [0m

	Unused variable: [35;1mimplicit arg[0m [34;1mforgot_to_use[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1mmustwarn_unused_implicit[0m(i32, i32) at [2m2:12+24[0m

-----

        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {

            x *= forgot_to_use; 
        }

        fn main() {
            mut x = 7;
            implicit forgot_to_use = 3;
            mustwarn_unused_implicit(x);
            return x == forgot_to_use * 7 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void mustwarn_unused_implicit_QFT6B3af(int& x, const int forgot_to_use)
{
    x *= forgot_to_use;
}

int fu_MAIN()
{
    int x = 7;
    const int forgot_to_use = 3;
    mustwarn_unused_implicit_QFT6B3af(x, forgot_to_use);
    if (x == (forgot_to_use * 7))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn log_append(implicit ref log_out: string, str: string)
            log_out ~= str;

        let VERBOSE = false;

        fn verbose(implicit ref log_events: i32, inline stuff: string)
        {
            if (VERBOSE) log_append(stuff);
            log_events++;
        }

        fn main() {

            implicit     mut log_out: string; 

            implicit mut log_events: i32;
            verbose("Hello!");
            verbose("World!");

            return log_events == 2 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 15:30+7[0m:

[2m      |         fn main() {[0m
[2m      | [0m
[2m   15 | [0m            implicit     mut [31;1mlog_out[0m: string; 
[2m      | [0m
[2m      |             implicit mut log_events: i32;[0m

	Unused variable: [35;1mimplicit[0m [34;1mlog_out[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn log_append(implicit ref log_out: string, str: string)
            log_out ~= str;

        let VERBOSE = false;

        fn verbose(implicit ref log_events: i32, inline stuff: string)
        {
            if (VERBOSE) log_append(stuff);
            log_events++;
        }

        fn main() {

            implicit lax mut log_out: string; 

            implicit mut log_events: i32;
            verbose("Hello!");
            verbose("World!");

            return log_events == 2 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int log_events {};
    log_events++;
    log_events++;
    if (log_events == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet, N_SD_HasStaticInit

-----

        struct NeverImported { x: i32 };
        fn wrap(x: i32) NeverImported(x * 10);

-----
struct s_NeverImported;

                                #ifndef DEF_s_NeverImported
                                #define DEF_s_NeverImported
struct s_NeverImported
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_NeverImported wrap_1WsbUdat(const int x)
{
    return s_NeverImported { (x * 10) };
}

#endif

-----

        struct NeverImported { x: i32 };
        fn wrap(x: i32) NeverImported(x * 10);

        fn rec(y: i32)
            if (y < 0)  return _0::wrap(rec(y + 7).x);
            else        return _0::wrap(y);

        fn main() rec(-2).x - 500;

-----
struct s_NeverImported;
static s_NeverImported rec_KIoFi8dU(int);
s_NeverImported wrap_1WsbUdat(int);

                                #ifndef DEF_s_NeverImported
                                #define DEF_s_NeverImported
struct s_NeverImported
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_NeverImported rec_KIoFi8dU(const int y)
{
    if (y < 0)
        return wrap_1WsbUdat(rec_KIoFi8dU((y + 7)).x);
    else
        return wrap_1WsbUdat(y);

}

int fu_MAIN()
{
    return rec_KIoFi8dU(-2).x - 500;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        fn wantsImplicit(implicit ref x: i32) = x++;

        fn main() {
  
            return _0::wantsImplicit();
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 4:37+1[0m:

[2m      |         fn main() {[0m
[2m      |   [0m
[2m    4 | [0m            return _0::wantsImplicit[31;1m([0m);
[2m      |         }[0m
[2m      | [0m

	No implicit [31;1mx[0m: i32 mutref copy in scope, needed to call [35;1mfn[0m [34;1mwantsImplicit[0m:

            because of [35;1mimplicit ref arg[0m [34;1mx[0m at [2m[0m_0[2m.fu 2:39+1[0m:

[2m      | [0m
[2m    2 | [0m        fn wantsImplicit(implicit ref [31;1mx[0m: i32) = x++;
[2m      | [0m


        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn wantsImplicit(implicit ref x: i32) = x++;

-----

#ifndef fu_NO_fdefs

int wantsImplicit_3JeKX2Qj(int& x)
{
    return x++;
}

#endif

-----

        fn wantsImplicit(implicit ref x: i32) = x++;

        fn main() {

            implicit mut x: i32 = 0;            
            return _0::wantsImplicit();
        }

-----
int wantsImplicit_3JeKX2Qj(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;
    return wantsImplicit_3JeKX2Qj(x);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;

        import _0;
        import _2;
        fn solvePrelude(d: i32) {

            return cleanID(d) + 5;
        }

        let CTX_PRELUDE =
            solvePrelude(7);

        fn main() =
            CTX_PRELUDE - 17;

-----
[2m/Users/hdachev/fu/__tests__/[0m_3[2m.fu 10:25+1[0m:

[2m      | [0m
[2m      |         let CTX_PRELUDE =[0m
[2m   10 | [0m            solvePrelude[31;1m([0m7);
[2m      | [0m
[2m      |         fn main() =[0m

	No implicit [31;1ma[0m: TokenIdx copy in scope, needed to call [35;1mfn[0m [34;1msolvePrelude[0m:

            because of call to [35;1mfn[0m [34;1mcleanID[0m at [2m6:27+1[0m:

[2m      |         fn solvePrelude(d: i32) {[0m
[2m      | [0m
[2m    6 | [0m            return cleanID[31;1m([0md) + 5;
[2m      |         }[0m
[2m      | [0m

            because of call to [35;1mfn[0m [34;1mfail[0m at [2m[0m_2[2m.fu 4:17+1[0m:

[2m      |         import _1;[0m
[2m      |         fn cleanID(c: i32) =[0m
[2m    4 | [0m            fail[31;1m([0mc) + 3;
[2m      | [0m

            because of [35;1mimplicit arg[0m [34;1ma[0m at [2m[0m_1[2m.fu 3:26+1[0m:

[2m      | [0m
[2m      |         import _0;[0m
[2m    3 | [0m        fn fail(implicit [31;1ma[0m: TokenIdx, b: i32) =
[2m      |             a.id + b;[0m
[2m      | [0m


-----

        struct TokenIdx { id: i32 };

-----

-----

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

-----
struct s_TokenIdx;

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fail_onpgTnTy(const int b, const s_TokenIdx& a)
{
    return a.id + b;
}

#endif

-----

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;

-----
struct s_TokenIdx;
int fail_onpgTnTy(int, const s_TokenIdx&);

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int cleanID_0dJN3HVl(const int c, const s_TokenIdx& a)
{
    return fail_onpgTnTy(c, a) + 3;
}

#endif

-----

        struct TokenIdx { id: i32 };

        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;

        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;

        import _0;
        import _2;
        fn solvePrelude(d: i32) {

            let implicit a: TokenIdx = TokenIdx(2);                 
            return cleanID(d) + 5;
        }

        let CTX_PRELUDE =
            solvePrelude(7);

        fn main() =
            CTX_PRELUDE - 17;

-----
struct s_TokenIdx;
int cleanID_0dJN3HVl(int, const s_TokenIdx&);

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int solvePrelude_UTb5P48Y(const int d)
{
    const s_TokenIdx a = s_TokenIdx { 2 };
    return cleanID_0dJN3HVl(d, a) + 5;
}

static const int CTX_PRELUDE = solvePrelude_UTb5P48Y(7);

int fu_MAIN()
{
    return CTX_PRELUDE - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    let climb = fn visit;                               

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void visit_1tOba2Pk(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

inline static void l_1_0_eBfIwE5a(const fu::str& lt, fu::str& result)
{
    result += lt;
    if (fu::str init = (lt ? fu::slice(lt, 0, (lt.size() - 1)) : fu::str{}))
        visit_1tOba2Pk(init, result);

}

inline static void visit_1tOba2Pk(const fu::str& chars, fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        l_1_0_eBfIwE5a(fu::slice(chars, i, chars.size()), result);

}

inline static void Lifetime_process_rce9yCET(const fu::str& lt, fu::str& result)
{
    visit_1tOba2Pk(lt, result);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_rce9yCET("abc"_fu, result);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_RelaxRespec

-----

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent: string) visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void visit_1tOba2Pk(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

static void climb_dfI9cHdl(fu::str&& parent, fu::str& result)
{
    visit_1tOba2Pk(parent, result);
}

inline static void l_1_0_qrf17yCI(const fu::str& lt, fu::str& result)
{
    result += lt;
    if (/*MOV*/ fu::str init = (lt ? fu::slice(lt, 0, (lt.size() - 1)) : fu::str{}))
        climb_dfI9cHdl(static_cast<fu::str&&>(init), result);

}

inline static void visit_1tOba2Pk(const fu::str& chars, fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        l_1_0_qrf17yCI(fu::slice(chars, i, chars.size()), result);

}

inline static void Lifetime_process_rce9yCET(const fu::str& lt, fu::str& result)
{
    visit_1tOba2Pk(lt, result);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_rce9yCET("abc"_fu, result);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent: string)   visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void visit_1tOba2Pk(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

inline static void l_1_0_qrf17yCI(const fu::str& lt, fu::str& result)
{
    result += lt;
    if (fu::str init = (lt ? fu::slice(lt, 0, (lt.size() - 1)) : fu::str{}))
    {
        const fu::str& /*init*/ parent = init;
        visit_1tOba2Pk(parent, result);
    };
}

inline static void visit_1tOba2Pk(const fu::str& chars, fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        l_1_0_qrf17yCI(fu::slice(chars, i, chars.size()), result);

}

inline static void Lifetime_process_rce9yCET(const fu::str& lt, fu::str& result)
{
    visit_1tOba2Pk(lt, result);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_rce9yCET("abc"_fu, result);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    noinline fn climb(mut parent)         visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void visit_1tOba2Pk(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

inline static void climb_lY4c6831(const fu::str& parent, fu::str& result)
{
    visit_1tOba2Pk(parent, result);
}

inline static void l_1_0_27jAYUDF(const fu::str& lt, fu::str& result)
{
    result += lt;
    if (fu::str init = (lt ? fu::slice(lt, 0, (lt.size() - 1)) : fu::str{}))
        climb_lY4c6831(init, result);

}

inline static void visit_1tOba2Pk(const fu::str& chars, fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        l_1_0_27jAYUDF(fu::slice(chars, i, chars.size()), result);

}

inline static void Lifetime_process_rce9yCET(const fu::str& lt, fu::str& result)
{
    visit_1tOba2Pk(lt, result);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_rce9yCET("abc"_fu, result);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   
                    inline fn climb(mut parent)           visit(parent);

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

inline static void visit_1tOba2Pk(const fu::str&, fu::str&);

#ifndef fu_NO_fdefs

inline static void l_1_0_27jAYUDF(const fu::str& lt, fu::str& result)
{
    result += lt;
    if (fu::str init = (lt ? fu::slice(lt, 0, (lt.size() - 1)) : fu::str{}))
    {
        const fu::str& /*init*/ parent = init;
        visit_1tOba2Pk(parent, result);
    };
}

inline static void visit_1tOba2Pk(const fu::str& chars, fu::str& result)
{
    for (int i = 0; i < chars.size(); i++)
        l_1_0_27jAYUDF(fu::slice(chars, i, chars.size()), result);

}

inline static void Lifetime_process_rce9yCET(const fu::str& lt, fu::str& result)
{
    visit_1tOba2Pk(lt, result);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str result = ""_fu;
    Lifetime_process_rce9yCET("abc"_fu, result);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec

-----

        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here

                type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 28:33+1[0m:

[2m      |                 let h       = Scope_lookupLabel(node.value);[0m
[2m      |                 let n_expr  = node.items && node.items[0];[0m
[2m   28 | [0m                return solveNode[31;1m([0mn_expr, type: h.ret_actual);
[2m      |             }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1msolveNode[0m, arguments:

	    3:	[35;1minjected implicit ref arg[0m [34;1msolveNode[0m:[34;1m_helpers[0m and
	    2:	[35;1marg[0m [34;1msolveNode[0m:[34;1mtype[0m

	    both alias:

	    [35;1minjected implicit ref arg[0m [34;1m_helpers[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1minjected implicit ref arg[0m [34;1msolveNode[0m:[34;1m_helpers[0m is [31;1mimplicit[0m

	    [35;1marg[0m [34;1msolveNode[0m:[34;1mtype[0m is ref-returned from [35;1mfn[0m [34;1msolveNode[0m

    BorrowCheck [35;1mfn[0m [34;1msolveJump[0m(Node, Helpers[:]) at [2m25:16+9[0m
        Solving [35;1mfn[0m [34;1mtest[0m(Node, Helpers[:]) at [2m10:12+4[0m

-----

        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here

                mut

                type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec/concat.h>

struct s_Helpers;
struct s_Type;
enum s_Kind: fu::u8;
struct s_Node;
static s_Type solveNode_u6vWaUXE(const s_Node&, s_Type&&, fu::vec<s_Helpers>&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    fu::str id;
    s_Type ret_actual;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || ret_actual
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Kind
                                #define DEF_s_Kind
enum s_Kind: fu::u8
{
    s_Kind_return = 1u,
    s_Kind_expr = 2u,
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Kind kind;
    fu::str value;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static s_Helpers& Scope_lookupLabel_2H2k9HCX(fu::view<char> id, fu::view_mut<s_Helpers> _helpers)
{
    for (int i = 0; i < _helpers.size(); i++)
    {
        s_Helpers& /*_helpers|static*/ item = _helpers.mutref(i);
        if (item.id == id)
            return item;

    };
    fu::fail((("No label '"_fu + id) + "' in scope."_fu));
}

static s_Type solveJump_dVZ8uLqZ(const s_Node& node, fu::vec<s_Helpers>& _helpers)
{
    const s_Helpers& /*_helpers|static*/ h = Scope_lookupLabel_2H2k9HCX(node.value, _helpers);
    const s_Node& /*node|static*/ n_expr = (node.items ? node.items[0] : (*(const s_Node*)fu::NIL));
    return solveNode_u6vWaUXE(n_expr, s_Type(h.ret_actual), _helpers);
}

static void Scope_pop_xt8Y0jMV(fu::vec<s_Helpers>& _helpers)
{
    if (_helpers)
        _helpers.pop();

}

static s_Type solveNode_u6vWaUXE(const s_Node& node, /*MOV*/ s_Type&& type, fu::vec<s_Helpers>& _helpers)
{
    if (node.kind == s_Kind_return)
        return solveJump_dVZ8uLqZ(node, _helpers);
    else
    {
        Scope_pop_xt8Y0jMV(_helpers);
        return static_cast<s_Type&&>(type);
    };
}

static s_Type test_4i7PNV8b(const s_Node& root, fu::vec<s_Helpers>&& _helpers)
{
    return solveNode_u6vWaUXE(root, s_Type{}, _helpers);
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<s_Helpers> _helpers = fu::vec<s_Helpers> { fu::slate<2, s_Helpers> { s_Helpers { "hello"_fu, s_Type { "Hello"_fu } }, s_Helpers { "world"_fu, s_Type { "World"_fu } } } };
    s_Type res = test_4i7PNV8b(s_Node { s_Kind_return, "world"_fu, fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { s_Kind_expr, "hello"_fu, fu::vec<s_Node>{} } } } }, static_cast<fu::vec<s_Helpers>&&>(_helpers));
    if (res.canon == "World"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

-----

        let x = 1;

        fn test(): &i32
            x;

        return test - 1;

-----

#ifndef fu_NO_fdefs

static int test_EJhRWC6k(const int x)
{
    return x;
}

int fu_MAIN()
{
    const int x = 1;
    return test_EJhRWC6k(x) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        let a = 1;
        let x: &i32 = a;

        return a - x;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    return a - a;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const s_Test test = s_Test { a };
    return test.x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    int b = a;
    b++;
    const int /*a*/ c = (a = b);
    return a - c;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_GN5AlByM(fu::view<int> view)
{
    int sum = 0;
    for (int i = 0; i < view.size(); i++)
        sum += view[i];

    return sum - 15;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
    arr.push(5);
    return test_GN5AlByM(arr);
}

#endif

int main() { return fu_MAIN(); }

-----

        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_GN5AlByM(fu::view<int> view)
{
    int sum = 0;
    for (int i = 0; i < view.size(); i++)
        sum += view[i];

    return sum - 15;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
    arr.push(5);
    return test_GN5AlByM(arr);
}

#endif

int main() { return fu_MAIN(); }

-----

        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 5;
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { -5 } };
    arr.push(x);
    return arr[0] + arr[1];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----


        let x = [ named: 0 ]; 
        return x[0];

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:17+1[0m:

[2m      | [0m
[2m      | [0m
[2m    6 | [0m        let x = [31;1m[[0m named: 0 ]; 
[2m      |         return x[0];[0m
[2m      | [0m

	TODO: solveArrlit: tryMatch by [ argnames: ... ] without function name.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----


        let x = [        0 ]; 
        return x[0];

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> { fu::slate<1, int> { 0 } };
    return x[0];
}

#endif

int main() { return fu_MAIN(); }

-----

        mut other: i32[][];
        mut arr:   i32[][];
        for (mut i = 4; i --> 0; )
        {
            arr.resize(i);

            // fill up with non small vecs so we can check alloc counts
            for (shadow mut i = 0; i < arr.len; i++)
                arr[i] ||= [ i, i, i, i, i, i, i, i ]; // defeat small vec

            // now this convers the "Last chance to do nothing" opti -
            //  noop resize a shared vec.
            other = arr;
            arr.resize(other.len || i);
        }
        return other.len;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::vec<int>> other {};
    fu::vec<fu::vec<int>> arr {};
    for (int i = 4; i-- > 0; )
    {
        arr.resize(i);
        for (int i_1 = 0; i_1 < arr.size(); i_1++)
        {
            fu::vec<int>& /*arr|static*/ a = arr.mutref(i_1);
            if (!(a))
            {
                a = fu::vec<int> { fu::slate<8, int> { i_1, i_1, i_1, i_1, i_1, i_1, i_1, i_1 } };
            };
        };
        other = arr;
        int _0 {};
        arr.resize(((_0 = other.size()) ? _0 : i));
    };
    return other.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zero    = nums[nums.len / 2];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:41+4[0m:

[2m      | [0m
[2m      |             ref zero    = nums[nums.len / 2];[0m
[2m    8 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m24:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   24 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mzero[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      | [0m

	Both refer to: [35;1mvar[0m [34;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = indirect_copy(nums);
            ref zero    = nums[nums.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = indirect_copy_h4KCgcmy(nums);
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = nums;
            ref zero    = nums[nums.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes { nums };
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            ref zero    = nums[nums.len / 2];
            let woot    = OPAQUE && nums;


            let allOnes = <alt>OPAQUE && woot<alt/>indirect_copy(OPAQUE && woot)</alt>;

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 13:48+2[0m:

[2m      | [0m
[2m      | [0m
[2m   13 | [0m            let allOnes = indirect_copy(OPAQUE [31;1m&&[0m woot);
[2m      | [0m
[2m      |             zero = 0;[0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m28:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   28 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mzero[0m at [2m9:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m    9 | [0m            ref [31;1mzero[0m    = nums[nums.len / 2];
[2m      |             let woot    = OPAQUE && nums;[0m
[2m      | [0m

	Both refer to: [35;1mvar[0m [34;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            let woot    = OPAQUE && nums;
            ref zero    = nums[nums.len / 2];


            let allOnes = indirect_copy(OPAQUE && woot);

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    fu::vec<int> woot { (OPAQUE ? nums : (*(const fu::vec<int>*)fu::NIL)) };
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    fu::vec<int> allOnes = indirect_copy_h4KCgcmy((OPAQUE ? woot : (*(const fu::vec<int>*)fu::NIL)));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];


            let woot    = OPAQUE && nums;
            ref zero    = nums[nums.len / 2];


            let allOnes = OPAQUE && woot;

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    fu::vec<int> woot { (OPAQUE ? nums : (*(const fu::vec<int>*)fu::NIL)) };
    int& /*nums|static*/ zero = nums.mutref((nums.size() / 2));
    fu::vec<int> allOnes { (OPAQUE ? woot : (*(const fu::vec<int>*)fu::NIL)) };
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:41+4[0m:

[2m      | [0m
[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m   11 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m28:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   28 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m

	Both refer to: [35;1mvar[0m [34;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:41+4[0m:

[2m      |             ref woot    = nums[nums.len / 2];[0m
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m   12 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m28:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   28 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mwoot[0m at [2m10:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            ref [31;1mwoot[0m    = nums[nums.len / 2];
[2m      |             ref zero    = OPAQUE ? woot : other;[0m
[2m      |             let allOnes = indirect_copy(nums);[0m

	Both refer to: [35;1mvar[0m [34;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            let allOnes = indirect_copy(nums);
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    int other = 0;
    fu::vec<int> allOnes = indirect_copy_h4KCgcmy(nums);
    int& /*nums|static*/ woot = nums.mutref((nums.size() / 2));
    int& /*woot|other*/ zero = (OPAQUE ? woot : other);
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;


            let allOnes = nums;
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    const bool OPAQUE = (nums.size() == (100 * nums[(nums.size() / 2)]));
    int other = 0;
    fu::vec<int> allOnes { nums };
    int& /*nums|static*/ woot = nums.mutref((nums.size() / 2));
    int& /*woot|other*/ zero = (OPAQUE ? woot : other);
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    return cow_after_ref_J2YA7ftx(allOnes, zero);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_indirect_J2YA7ftx(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    return cow_after_ref_J2YA7ftx(allOnes, zero);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_indirect_J2YA7ftx(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_J2YA7ftx(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_J2YA7ftx(fu::view<int> allOnes, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_J2YA7ftx(static_cast<fu::vec<int>&&>(_0), nums.mutref((nums.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    return cow_after_ref_FsjHIIf2(zero, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_indirect_FsjHIIf2(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    return cow_after_ref_FsjHIIf2(zero, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_indirect_FsjHIIf2(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_FsjHIIf2(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zero: nums[nums.len / 2], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_FsjHIIf2(int& zero, fu::view<int> allOnes)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < allOnes.size(); i++)
    {
        if (allOnes[i] == 1)
            o++;

    };
    if ((zero == 0) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_FsjHIIf2(nums.mutref((nums.size() / 2)), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            ref zeroes  = nums[10:20];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:41+4[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[10:20];[0m
[2m    8 | [0m            let allOnes = indirect_copy([31;1mnums[0m);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m30:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   30 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mzeroes[0m at [2m7:17+6[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            ref [31;1mzeroes[0m  = nums[10:20];
[2m      |             let allOnes = indirect_copy(nums);[0m
[2m      | [0m

	Both refer to: [35;1mvar[0m [34;1mnums[0m at [2m3:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1mnums[0m: i32[];
[2m      |             for (mut i = 0; i < 100; i++) nums ~= 1;[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = indirect_copy(nums);
            ref zeroes  = nums[10:20];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes = indirect_copy_h4KCgcmy(nums);
    fu::view_mut<int> /*nums*/ zeroes = fu::get_view_mut(nums, 10, 20);
    for (int i_1 = 0; i_1 < zeroes.size(); i_1++)
        zeroes.mutref(i_1) = 0;

    int o = 0;
    for (int i_2 = 0; i_2 < allOnes.size(); i_2++)
    {
        if (allOnes[i_2] == 1)
            o++;

    };
    int z = 0;
    for (int i_3 = 0; i_3 < zeroes.size(); i_3++)
    {
        if (!zeroes[i_3])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;


            let allOnes = nums;
            ref zeroes  = nums[10:20];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> allOnes { nums };
    fu::view_mut<int> /*nums*/ zeroes = fu::get_view_mut(nums, 10, 20);
    for (int i_1 = 0; i_1 < zeroes.size(); i_1++)
        zeroes.mutref(i_1) = 0;

    int o = 0;
    for (int i_2 = 0; i_2 < allOnes.size(); i_2++)
    {
        if (allOnes[i_2] == 1)
            o++;

    };
    int z = 0;
    for (int i_3 = 0; i_3 < zeroes.size(); i_3++)
    {
        if (!zeroes[i_3])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10:20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    return cow_after_ref_hzGmwhF5(allOnes, zeroes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_indirect_hzGmwhF5(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10:20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    return cow_after_ref_hzGmwhF5(allOnes, zeroes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_indirect_hzGmwhF5(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10:20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_hzGmwhF5(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10:20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_hzGmwhF5(fu::view<int> allOnes, fu::view_mut<int> zeroes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_hzGmwhF5(static_cast<fu::vec<int>&&>(_0), fu::get_view_mut(nums, 10, 20)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10:20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    return cow_after_ref_1ZAm0biu(zeroes, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_indirect_1ZAm0biu(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref_indirect(  
                zeroes: nums[10:20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    return cow_after_ref_1ZAm0biu(zeroes, allOnes);
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_indirect_1ZAm0biu(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10:20], allOnes: indirect_copy(nums));
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int cow_after_ref_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = indirect_copy_h4KCgcmy(nums), cow_after_ref_1ZAm0biu(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----


        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])

        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;


            return cow_after_ref(           
                zeroes: nums[10:20], allOnes: nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int cow_after_ref_1ZAm0biu(fu::view_mut<int> zeroes, fu::view<int> allOnes)
{
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((z == 10) && (o == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> nums {};
    for (int i = 0; i < 100; i++)
        nums += 1;

    fu::vec<int> _0 {};
    return (_0 = fu::vec<int>(nums), cow_after_ref_1ZAm0biu(fu::get_view_mut(nums, 10, 20), static_cast<fu::vec<int>&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_BckMustSeq

-----

        fn test(ref nums: i32[][])
        {

            ref zeroes  = nums[nums.len / 2];
            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:45+1[0m:

[2m      | [0m
[2m      |             ref zeroes  = nums[nums.len / 2];[0m
[2m    6 | [0m            mut allOnes = indirect_copy(nums[31;1m[[0mnums.len / 2]);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m36:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   36 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mzeroes[0m at [2m5:17+6[0m:

[2m      |         {[0m
[2m      | [0m
[2m    5 | [0m            ref [31;1mzeroes[0m  = nums[nums.len / 2];
[2m      |             mut allOnes = indirect_copy(nums[nums.len / 2]);[0m
[2m      | [0m

	Both refer to: [35;1mref arg[0m [34;1mnums[0m at [2m2:21+4[0m:

[2m      | [0m
[2m    2 | [0m        fn test(ref [31;1mnums[0m: i32[][])
[2m      |         {[0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mtest[0m(i32[][:]) at [2m2:12+4[0m

-----

        fn test(ref nums: i32[][])
        {

            mut allOnes = indirect_copy(nums[nums.len / 2]);
            ref zeroes  = nums[nums.len / 2];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static int test_5aMNXPqB(fu::view_mut<fu::vec<int>> nums)
{
    fu::vec<int> allOnes = indirect_copy_h4KCgcmy(nums[(nums.size() / 2)]);
    fu::view_mut<int> /*nums|static*/ zeroes = nums.mutref((nums.size() / 2));
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((o == 10) && (z == 10))
        return 0;
    else
        return 10;

}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> nums {};
    for (int i = 0; i < 4; i++)
    {
        nums += fu::vec<int> { fu::slate<10, int> { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
    };
    return test_5aMNXPqB(nums);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(ref nums: i32[][])
        {

            mut allOnes = nums[nums.len / 2];
            ref zeroes  = nums[nums.len / 2];


            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int test_5aMNXPqB(fu::view_mut<fu::vec<int>> nums)
{
    fu::vec<int> allOnes { nums[(nums.size() / 2)] };
    fu::view_mut<int> /*nums|static*/ zeroes = nums.mutref((nums.size() / 2));
    for (int i = 0; i < zeroes.size(); i++)
        zeroes.mutref(i) = 0;

    int o = 0;
    for (int i_1 = 0; i_1 < allOnes.size(); i_1++)
    {
        if (allOnes[i_1] == 1)
            o++;

    };
    int z = 0;
    for (int i_2 = 0; i_2 < zeroes.size(); i_2++)
    {
        if (!zeroes[i_2])
            z++;

    };
    if ((o == 10) && (z == 10))
        return 0;
    else
        return 10;

}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> nums {};
    for (int i = 0; i < 4; i++)
    {
        nums += fu::vec<int> { fu::slate<10, int> { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
    };
    return test_5aMNXPqB(nums);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            ref zero    = orig.ones[orig.ones.len / 2];
            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 15:41+4[0m:

[2m      | [0m
[2m      |             ref zero    = orig.ones[orig.ones.len / 2];[0m
[2m   15 | [0m            let all     = indirect_copy([31;1morig[0m);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1mtv[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m via [35;1mfn[0m [34;1mindirect_copy[0m at [2m34:40+1[0m:

[2m      | [0m
[2m      |         noinline fn indirect_copy(tv: TwoVecs)[0m
[2m   34 | [0m            TwoVecs(ones: indirect_copy[31;1m([0mtv.ones),
[2m      |                     twos: indirect_copy(tv.twos));[0m
[2m      | [0m

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m40:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   40 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mzero[0m at [2m14:17+4[0m:

[2m      | [0m
[2m      | [0m
[2m   14 | [0m            ref [31;1mzero[0m    = orig.ones[orig.ones.len / 2];
[2m      |             let all     = indirect_copy(orig);[0m
[2m      | [0m

	Both refer to: [35;1mvar[0m [34;1morig[0m at [2m7:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    7 | [0m            mut [31;1morig[0m: TwoVecs;
[2m      |             for (mut i = 0; i < 100; i++) {[0m
[2m      |                 orig.ones ~= 1;[0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            let all     = indirect_copy(orig);
            ref zero    = orig.ones[orig.ones.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static s_TwoVecs indirect_copy_TwJCM2yq(const s_TwoVecs& tv)
{
    return s_TwoVecs { indirect_copy_h4KCgcmy(tv.ones), indirect_copy_h4KCgcmy(tv.twos) };
}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs all = indirect_copy_TwJCM2yq(orig);
    int& /*orig|static*/ zero = orig.ones.mutref((orig.ones.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < all.ones.size(); i_1++)
    {
        if (all.ones[i_1] == 1)
            o++;

    };
    int t = 0;
    for (int i_2 = 0; i_2 < all.twos.size(); i_2++)
    {
        if (all.twos[i_2] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            let all     = orig;
            ref zero    = orig.ones[orig.ones.len / 2];


            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs all { orig };
    int& /*orig|static*/ zero = orig.ones.mutref((orig.ones.size() / 2));
    zero = 0;
    int o = 0;
    for (int i_1 = 0; i_1 < all.ones.size(); i_1++)
    {
        if (all.ones[i_1] == 1)
            o++;

    };
    int t = 0;
    for (int i_2 = 0; i_2 < all.twos.size(); i_2++)
    {
        if (all.twos[i_2] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static s_TwoVecs indirect_copy_TwJCM2yq(const s_TwoVecs& tv)
{
    return s_TwoVecs { indirect_copy_h4KCgcmy(tv.ones), indirect_copy_h4KCgcmy(tv.twos) };
}

static int cow_after_ref_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    return cow_after_ref_yJXpfmaH(all, zero);
}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = indirect_copy_TwJCM2yq(orig), cow_after_ref_indirect_yJXpfmaH(static_cast<s_TwoVecs&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    return cow_after_ref_yJXpfmaH(all, zero);
}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = s_TwoVecs(orig), cow_after_ref_indirect_yJXpfmaH(static_cast<s_TwoVecs&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static s_TwoVecs indirect_copy_TwJCM2yq(const s_TwoVecs& tv)
{
    return s_TwoVecs { indirect_copy_h4KCgcmy(tv.ones), indirect_copy_h4KCgcmy(tv.twos) };
}

static int cow_after_ref_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = indirect_copy_TwJCM2yq(orig), cow_after_ref_yJXpfmaH(static_cast<s_TwoVecs&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_yJXpfmaH(const s_TwoVecs& all, int& zero)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = s_TwoVecs(orig), cow_after_ref_yJXpfmaH(static_cast<s_TwoVecs&&>(_0), orig.ones.mutref((orig.ones.size() / 2))));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static s_TwoVecs indirect_copy_TwJCM2yq(const s_TwoVecs& tv)
{
    return s_TwoVecs { indirect_copy_h4KCgcmy(tv.ones), indirect_copy_h4KCgcmy(tv.twos) };
}

static int cow_after_ref_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    return cow_after_ref_lKXTIJRx(zero, all);
}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = indirect_copy_TwJCM2yq(orig), cow_after_ref_indirect_lKXTIJRx(orig.ones.mutref((orig.ones.size() / 2)), static_cast<s_TwoVecs&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref_indirect(  
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

static int cow_after_ref_indirect_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    return cow_after_ref_lKXTIJRx(zero, all);
}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = s_TwoVecs(orig), cow_after_ref_indirect_lKXTIJRx(orig.ones.mutref((orig.ones.size() / 2)), static_cast<s_TwoVecs&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: indirect_copy(orig));
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> indirect_copy_h4KCgcmy(const fu::vec<int>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<int>(arr);

}

static s_TwoVecs indirect_copy_TwJCM2yq(const s_TwoVecs& tv)
{
    return s_TwoVecs { indirect_copy_h4KCgcmy(tv.ones), indirect_copy_h4KCgcmy(tv.twos) };
}

static int cow_after_ref_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = indirect_copy_TwJCM2yq(orig), cow_after_ref_lKXTIJRx(orig.ones.mutref((orig.ones.size() / 2)), static_cast<s_TwoVecs&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };


        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)

        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }


            return cow_after_ref(           
                zero: orig.ones[orig.ones.len / 2], all: orig);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_TwoVecs;

                                #ifndef DEF_s_TwoVecs
                                #define DEF_s_TwoVecs
struct s_TwoVecs
{
    fu::vec<int> ones;
    fu::vec<int> twos;
    explicit operator bool() const noexcept
    {
        return false
            || ones
            || twos
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int cow_after_ref_lKXTIJRx(int& zero, const s_TwoVecs& all)
{
    zero = 0;
    int o = 0;
    for (int i = 0; i < all.ones.size(); i++)
    {
        if (all.ones[i] == 1)
            o++;

    };
    int t = 0;
    for (int i_1 = 0; i_1 < all.twos.size(); i_1++)
    {
        if (all.twos[i_1] == 2)
            t++;

    };
    if ((zero == 0) && (o == 100) && (t == 100))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    s_TwoVecs orig {};
    for (int i = 0; i < 100; i++)
    {
        orig.ones += 1;
        orig.twos += 2;
    };
    s_TwoVecs _0 {};
    return (_0 = s_TwoVecs(orig), cow_after_ref_lKXTIJRx(orig.ones.mutref((orig.ones.size() / 2)), static_cast<s_TwoVecs&&>(_0)));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            ref x = arr[0];
            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:38+3[0m:

[2m      | [0m
[2m      |             ref x = arr[0];[0m
[2m   20 | [0m            mut barr = indirect_copy([31;1marr[0m);
[2m      | [0m
[2m      | [0m

	[35;1marg[0m [34;1mindirect_copy[0m:[34;1marr[0m to [35;1mfn[0m [34;1mindirect_copy[0m is indirectly copied from:

            in [35;1mfn[0m [34;1mindirect_copy[0m at [2m31:19+3[0m:

[2m      |             arr.len & 1[0m
[2m      |                 ? arr[: arr.len / 2] ~ arr[arr.len / 2 :][0m
[2m   31 | [0m                : [31;1marr[0m; // <- we take this branch
[2m      | [0m

	... but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mx[0m at [2m19:17+1[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref [31;1mx[0m = arr[0];
[2m      |             mut barr = indirect_copy(arr);[0m
[2m      | [0m

	Both refer to: [35;1mvar[0m [34;1marr[0m at [2m16:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m15:12+4[0m

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            mut barr = indirect_copy(arr);
            ref x = arr[0];


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> indirect_copy_aCqFLaD4(const fu::vec<fu::vec<int>>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<fu::vec<int>>(arr);

}

static void test_jbzDlsNs(fu::vec<fu::vec<int>>& barr, fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> { fu::slate<1, int> { 0 } };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_Nbgdqibxz40
                                #define DEF_x3Cx3E_Nbgdqibxz40
inline int x3Cx3E_Nbgdqibx(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_fMp33mLs(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_Nbgdqibxz40
                                #define DEF_x3Dx3D_Nbgdqibxz40
inline bool operator==(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_Nbgdqibx(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 0, 1, 2, 3, 4, 5, 6, 7 } }, fu::vec<int> { fu::slate<8, int> { 8, 9, 10, 11, 12, 13, 14, 15 } } } };
    fu::vec<fu::vec<int>> barr = indirect_copy_aCqFLaD4(arr);
    fu::view_mut<int> /*arr|static*/ x = arr.mutref(0);
    test_jbzDlsNs(barr, x);
    if (barr == (fu::slate<3, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 1, 2, 3, 4, 5, 6, 7, 8 } }, fu::vec<int> { fu::slate<8, int> { 9, 10, 11, 12, 13, 14, 15, 16 } }, fu::vec<int> { fu::slate<1, int> { 0 } } }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];


            mut barr = arr;
            ref x = arr[0];


            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_jbzDlsNs(fu::vec<fu::vec<int>>& barr, fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> { fu::slate<1, int> { 0 } };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_Nbgdqibxz40
                                #define DEF_x3Cx3E_Nbgdqibxz40
inline int x3Cx3E_Nbgdqibx(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_fMp33mLs(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_Nbgdqibxz40
                                #define DEF_x3Dx3D_Nbgdqibxz40
inline bool operator==(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_Nbgdqibx(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 0, 1, 2, 3, 4, 5, 6, 7 } }, fu::vec<int> { fu::slate<8, int> { 8, 9, 10, 11, 12, 13, 14, 15 } } } };
    fu::vec<fu::vec<int>> barr { arr };
    fu::view_mut<int> /*arr|static*/ x = arr.mutref(0);
    test_jbzDlsNs(barr, x);
    if (barr == (fu::slate<3, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 1, 2, 3, 4, 5, 6, 7, 8 } }, fu::vec<int> { fu::slate<8, int> { 9, 10, 11, 12, 13, 14, 15, 16 } }, fu::vec<int> { fu::slate<1, int> { 0 } } }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;
            ref x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mouter[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mouter[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1mouter[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mouter[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mouter[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m27:12+4[0m

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            ref x = a[0];
            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 30:35+3[0m:

[2m      |             mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];[0m
[2m      | [0m
[2m   30 | [0m            let barr = outer(arr, [31;1marr[0m);
[2m      |             return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mouter[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mouter[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1mouter[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1marr[0m at [2m28:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   28 | [0m            mut [31;1marr[0m: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];
[2m      | [0m
[2m      |             let barr = outer(arr, arr);[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mouter[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mouter[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m27:12+4[0m

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = indirect_copy(b);
            mut x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> indirect_copy_aCqFLaD4(const fu::vec<fu::vec<int>>& arr)
{
    if (arr.size() & 1)
        return fu::get_view_start0(arr, (arr.size() / 2)) + fu::get_view(arr, (arr.size() / 2));
    else
        return fu::vec<fu::vec<int>>(arr);

}

static void test_jbzDlsNs(fu::vec<fu::vec<int>>& barr, fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> { fu::slate<1, int> { 0 } };
}

static fu::vec<fu::vec<int>> outer_GYjUUiAd(fu::view<fu::vec<int>> a, const fu::vec<fu::vec<int>>& b)
{
    /*MOV*/ fu::vec<fu::vec<int>> barr = indirect_copy_aCqFLaD4(b);
    fu::vec<int> x { a[0] };
    test_jbzDlsNs(barr, x);
    return /*NRVO*/ barr;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_Nbgdqibxz40
                                #define DEF_x3Cx3E_Nbgdqibxz40
inline int x3Cx3E_Nbgdqibx(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_fMp33mLs(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_Nbgdqibxz40
                                #define DEF_x3Dx3D_Nbgdqibxz40
inline bool operator==(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_Nbgdqibx(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 0, 1, 2, 3, 4, 5, 6, 7 } }, fu::vec<int> { fu::slate<8, int> { 8, 9, 10, 11, 12, 13, 14, 15 } } } };
    fu::vec<fu::vec<int>> barr = outer_GYjUUiAd(arr, arr);
    if (barr == (fu::slate<3, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 1, 2, 3, 4, 5, 6, 7, 8 } }, fu::vec<int> { fu::slate<8, int> { 9, 10, 11, 12, 13, 14, 15, 16 } }, fu::vec<int> { fu::slate<1, int> { 0 } } }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {

            mut barr = b;
            mut x = a[0];


            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_jbzDlsNs(fu::vec<fu::vec<int>>& barr, fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
        x.mutref(i) += 2;

    for (int i_1 = 0; i_1 < barr.size(); i_1++)
    {
        fu::view_mut<int> /*barr|static*/ b = barr.mutref(i_1);
        for (int j = 0; j < b.size(); j++)
            b.mutref(j) += 1;

    };
    barr += fu::vec<int> { fu::slate<1, int> { 0 } };
}

static fu::vec<fu::vec<int>> outer_GYjUUiAd(fu::view<fu::vec<int>> a, const fu::vec<fu::vec<int>>& b)
{
    /*MOV*/ fu::vec<fu::vec<int>> barr { b };
    fu::vec<int> x { a[0] };
    test_jbzDlsNs(barr, x);
    return /*NRVO*/ barr;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_Nbgdqibxz40
                                #define DEF_x3Cx3E_Nbgdqibxz40
inline int x3Cx3E_Nbgdqibx(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_fMp33mLs(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_Nbgdqibxz40
                                #define DEF_x3Dx3D_Nbgdqibxz40
inline bool operator==(fu::view<fu::vec<int>> a, fu::view<fu::vec<int>> b)
{
    return !x3Cx3E_Nbgdqibx(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::vec<int>> arr = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 0, 1, 2, 3, 4, 5, 6, 7 } }, fu::vec<int> { fu::slate<8, int> { 8, 9, 10, 11, 12, 13, 14, 15 } } } };
    fu::vec<fu::vec<int>> barr = outer_GYjUUiAd(arr, arr);
    if (barr == (fu::slate<3, fu::vec<int>> { fu::vec<int> { fu::slate<8, int> { 1, 2, 3, 4, 5, 6, 7, 8 } }, fu::vec<int> { fu::slate<8, int> { 9, 10, 11, 12, 13, 14, 15, 16 } }, fu::vec<int> { fu::slate<1, int> { 0 } } }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        // This one unrelated to COW but variation of test above.

        struct ScopeSkip { // When first, we complain about recursive types
            left:           Ephemeral[];
            right:          Ephemeral[];
        };

        struct Ephemeral { // When first, we cg declarations in the wrong order
            id:             i32;
            scope_skip?:    ScopeSkip;
        };


        struct SolverState {
            _scope_skip:    ScopeSkip;
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            mut scope_skip  = s._scope_skip;
            ref eph         = s._ephs[i];
            eph.scope_skip  = scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: ScopeSkip(
                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                    [ Ephemeral(4), Ephemeral(5) ]
                ),
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.left.len - 3;
        }

-----
#include <fu/vec.h>

struct s_SolverState;
struct s_ScopeSkip;
struct s_Ephemeral;

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    fu::vec<s_Ephemeral> left;
    fu::vec<s_Ephemeral> right;
    s_ScopeSkip(const s_ScopeSkip&) = default;
    s_ScopeSkip(s_ScopeSkip&&) = default;
    s_ScopeSkip& operator=(s_ScopeSkip&&) = default;
    s_ScopeSkip& operator=(const s_ScopeSkip& selfrec) { return *this = s_ScopeSkip(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverState
                                #define DEF_s_SolverState
struct s_SolverState
{
    s_ScopeSkip _scope_skip;
    fu::vec<s_Ephemeral> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Ephemeral
                                #define DEF_s_Ephemeral
struct s_Ephemeral
{
    int id;
    s_ScopeSkip scope_skip;
    s_Ephemeral(const s_Ephemeral&) = default;
    s_Ephemeral(s_Ephemeral&&) = default;
    s_Ephemeral& operator=(s_Ephemeral&&) = default;
    s_Ephemeral& operator=(const s_Ephemeral& selfrec) { return *this = s_Ephemeral(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Ephemeral& snap_wyGcteP8(const int i, s_SolverState& s)
{
    /*MOV*/ s_ScopeSkip scope_skip { s._scope_skip };
    s_Ephemeral& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = static_cast<s_ScopeSkip&&>(scope_skip);
    return eph;
}

int fu_MAIN()
{
    s_SolverState s = s_SolverState { s_ScopeSkip { fu::vec<s_Ephemeral> { fu::slate<3, s_Ephemeral> { s_Ephemeral { 1, s_ScopeSkip{} }, s_Ephemeral { 2, s_ScopeSkip{} }, s_Ephemeral { 3, s_ScopeSkip{} } } }, fu::vec<s_Ephemeral> { fu::slate<2, s_Ephemeral> { s_Ephemeral { 4, s_ScopeSkip{} }, s_Ephemeral { 5, s_ScopeSkip{} } } } }, fu::vec<s_Ephemeral> { fu::slate<1, s_Ephemeral> { s_Ephemeral { 4, s_ScopeSkip{} } } } };
    return snap_wyGcteP8(0, s).scope_skip.left.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_NonTrivAutoCopy

-----

        // This one unrelated to COW but variation of test above.

        struct Ephemeral { // When first, we cg declarations in the wrong order
            id:             i32;
            scope_skip?:    ScopeSkip;
        };

        struct ScopeSkip { // When first, we complain about recursive types
            left:           Ephemeral[];
            right:          Ephemeral[];
        };


        struct SolverState {
            _scope_skip:    ScopeSkip;
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            mut scope_skip  = s._scope_skip;
            ref eph         = s._ephs[i];
            eph.scope_skip  = scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: ScopeSkip(
                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                    [ Ephemeral(4), Ephemeral(5) ]
                ),
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.left.len - 3;
        }

-----
#include <fu/vec.h>

struct s_SolverState;
struct s_ScopeSkip;
struct s_Ephemeral;

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    fu::vec<s_Ephemeral> left;
    fu::vec<s_Ephemeral> right;
    s_ScopeSkip(const s_ScopeSkip&) = default;
    s_ScopeSkip(s_ScopeSkip&&) = default;
    s_ScopeSkip& operator=(s_ScopeSkip&&) = default;
    s_ScopeSkip& operator=(const s_ScopeSkip& selfrec) { return *this = s_ScopeSkip(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || left
            || right
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverState
                                #define DEF_s_SolverState
struct s_SolverState
{
    s_ScopeSkip _scope_skip;
    fu::vec<s_Ephemeral> _ephs;
    explicit operator bool() const noexcept
    {
        return false
            || _scope_skip
            || _ephs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Ephemeral
                                #define DEF_s_Ephemeral
struct s_Ephemeral
{
    int id;
    s_ScopeSkip scope_skip;
    s_Ephemeral(const s_Ephemeral&) = default;
    s_Ephemeral(s_Ephemeral&&) = default;
    s_Ephemeral& operator=(s_Ephemeral&&) = default;
    s_Ephemeral& operator=(const s_Ephemeral& selfrec) { return *this = s_Ephemeral(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || scope_skip
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Ephemeral& snap_wyGcteP8(const int i, s_SolverState& s)
{
    /*MOV*/ s_ScopeSkip scope_skip { s._scope_skip };
    s_Ephemeral& /*s|static*/ eph = s._ephs.mutref(i);
    eph.scope_skip = static_cast<s_ScopeSkip&&>(scope_skip);
    return eph;
}

int fu_MAIN()
{
    s_SolverState s = s_SolverState { s_ScopeSkip { fu::vec<s_Ephemeral> { fu::slate<3, s_Ephemeral> { s_Ephemeral { 1, s_ScopeSkip{} }, s_Ephemeral { 2, s_ScopeSkip{} }, s_Ephemeral { 3, s_ScopeSkip{} } } }, fu::vec<s_Ephemeral> { fu::slate<2, s_Ephemeral> { s_Ephemeral { 4, s_ScopeSkip{} }, s_Ephemeral { 5, s_ScopeSkip{} } } } }, fu::vec<s_Ephemeral> { fu::slate<1, s_Ephemeral> { s_Ephemeral { 4, s_ScopeSkip{} } } } };
    return snap_wyGcteP8(0, s).scope_skip.left.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_NonTrivAutoCopy

-----

        struct Node { items: Node[] };

        fn unwrap_all(ref nodes: Node[]) {
            for (mut i = 0; i < nodes.len; i++) {
                ref n = nodes[i];
                if (n.items)        // cannotCOW false pos
                    n = n.items[0]; //  copy(n.items[0]) <- ref n
            }                       //   via parent nodes
        }

        fn count(nodes: Node[]) {
            mut N = nodes.len;
            for (mut i = 0; i < nodes.len; i++)
                N += nodes[i].items.count;
            return N;
        }

        fn main() {
            mut nodes = [ Node([ Node() ]) ];
            nodes.unwrap_all();
            return nodes.count - 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Node;
static int count_uasvP1Fu(fu::view<s_Node>);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void unwrap_all_dOS5piIC(fu::view_mut<s_Node> nodes)
{
    for (int i = 0; i < nodes.size(); i++)
    {
        s_Node& /*nodes|static*/ n = nodes.mutref(i);
        if (n.items)
            n = n.items[0];

    };
}

static int count_uasvP1Fu(fu::view<s_Node> nodes)
{
    int N = nodes.size();
    for (int i = 0; i < nodes.size(); i++)
        N += count_uasvP1Fu(nodes[i].items);

    return N;
}

int fu_MAIN()
{
    fu::vec<s_Node> nodes = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } } } };
    unwrap_all_dOS5piIC(nodes);
    return count_uasvP1Fu(nodes) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {
            ref either = (a || b)[0];

            if (either.len & 1 == 0)
                either ~= 1;
            else
                b = a;

        }

        fn arr(n: i32) {
            mut arr: i32[];
            for (mut i = 1; i <= n; i++) arr ~= i;
            return arr;
        }

        fn check(arr: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum;
        }

        fn check(arr: i32[][]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);
            return sum;
        }

        fn main() {
            mut a = [ arr( 8), arr( 9) ];
            mut b = [ arr(10), arr(11) ];

            conditionalCopyOrWrite(:a, :b);

            return check(a) == 3600 + 45 + 100
                && check(b) == 5500 + 66
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> arr_72skkfd5(const int n)
{
    /*MOV*/ fu::vec<int> arr {};
    for (int i = 1; (i <= n); i++)
        arr += i;

    return /*NRVO*/ arr;
}

static void conditionalCopyOrWrite_Exhwu17i(fu::vec<fu::vec<int>>& a, fu::vec<fu::vec<int>>& b)
{
    fu::vec<int>& /*b|a|static*/ either = (a ? a : b).mutref(0);
    if ((either.size() & 1) == 0)
        either += 1;
    else
        b = a;

}

static int check_VgLKCq8Z(fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

static int check_oPTBrrQi(fu::view<fu::vec<int>> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum = ((sum * 100) + check_VgLKCq8Z(arr[i]));

    return sum;
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { arr_72skkfd5(8), arr_72skkfd5(9) } };
    fu::vec<fu::vec<int>> b = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { arr_72skkfd5(10), arr_72skkfd5(11) } };
    conditionalCopyOrWrite_Exhwu17i(a, b);
    if ((check_oPTBrrQi(a) == ((3600 + 45) + 100)) && (check_oPTBrrQi(b) == (5500 + 66)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

-----

        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {
            ref either = (a || b)[0];

            if (either.len & 1)
                b = a;              // <- no issue here
            else                    //  either only written to
                either ~= 1;        //   if copy never created.

        }

        fn arr(n: i32) {
            mut arr: i32[];
            for (mut i = 1; i <= n; i++) arr ~= i;
            return arr;
        }

        fn check(arr: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum;
        }

        fn check(arr: i32[][]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);
            return sum;
        }

        fn main() {
            mut a = [ arr( 8), arr( 9) ];
            mut b = [ arr(10), arr(11) ];

            conditionalCopyOrWrite(:a, :b);

            return check(a) == 3600 + 45 + 100
                && check(b) == 5500 + 66
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> arr_72skkfd5(const int n)
{
    /*MOV*/ fu::vec<int> arr {};
    for (int i = 1; (i <= n); i++)
        arr += i;

    return /*NRVO*/ arr;
}

static void conditionalCopyOrWrite_Exhwu17i(fu::vec<fu::vec<int>>& a, fu::vec<fu::vec<int>>& b)
{
    fu::vec<int>& /*b|a|static*/ either = (a ? a : b).mutref(0);
    if (either.size() & 1)
        b = a;
    else
        either += 1;

}

static int check_VgLKCq8Z(fu::view<int> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum;
}

static int check_oPTBrrQi(fu::view<fu::vec<int>> arr)
{
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum = ((sum * 100) + check_VgLKCq8Z(arr[i]));

    return sum;
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { arr_72skkfd5(8), arr_72skkfd5(9) } };
    fu::vec<fu::vec<int>> b = fu::vec<fu::vec<int>> { fu::slate<2, fu::vec<int>> { arr_72skkfd5(10), arr_72skkfd5(11) } };
    conditionalCopyOrWrite_Exhwu17i(a, b);
    if ((check_oPTBrrQi(a) == ((3600 + 45) + 100)) && (check_oPTBrrQi(b) == (5500 + 66)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_COWRestrict

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            result.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateThenCopy(a, a);
            return 1000 * a.count + b.count - 2004;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static int count_RRGh8JLk(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode mutateThenCopy_sG4q9JNK(s_SolvedNode& callsite, const s_SolvedNode& root)
{
    callsite.items += s_SolvedNode(callsite);
    /*MOV*/ s_SolvedNode result { root };
    result.items += s_SolvedNode(root);
    return /*NRVO*/ result;
}

inline static int& l_1_0_YxYlvGTT(const s_SolvedNode& item, int& c)
{
    return (c += count_RRGh8JLk(item));
}

                                #ifndef DEF_each_o0WuElfhJcc
                                #define DEF_each_o0WuElfhJcc
inline void each_o0WuElfh(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_YxYlvGTT(a[i], c);

}
                                #endif

static int count_RRGh8JLk(const s_SolvedNode& node)
{
    int c = 1;
    each_o0WuElfh(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode a {};
    s_SolvedNode b = mutateThenCopy_sG4q9JNK(a, a);
    return ((1000 * count_RRGh8JLk(a)) + count_RRGh8JLk(b)) - 2004;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                result.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopy();
            return 1000 * a.count + b.count - 2004;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static int count_vhRzRYQj(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode copyRoot_V6uTIUa3(const s_SolvedNode& root)
{
    /*MOV*/ s_SolvedNode result { root };
    result.items += s_SolvedNode(root);
    return /*NRVO*/ result;
}

static s_SolvedNode bck_call_v4791KqX(s_SolvedNode& callsite, const s_SolvedNode& root)
{
    callsite.items += s_SolvedNode(callsite);
    return copyRoot_V6uTIUa3(root);
}

static s_SolvedNode mutateThenCopy_TPa3SuED(s_SolvedNode& root)
{
    return bck_call_v4791KqX(root, root);
}

inline static int& l_1_0_lhp832eR(const s_SolvedNode& item, int& c)
{
    return (c += count_vhRzRYQj(item));
}

                                #ifndef DEF_each_RUZR11FMC4b
                                #define DEF_each_RUZR11FMC4b
inline void each_RUZR11FM(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_lhp832eR(a[i], c);

}
                                #endif

static int count_vhRzRYQj(const s_SolvedNode& node)
{
    int c = 1;
    each_RUZR11FM(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode a {};
    s_SolvedNode b = mutateThenCopy_TPa3SuED(a);
    return ((1000 * count_vhRzRYQj(a)) + count_vhRzRYQj(b)) - 2004;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            root.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateCopyMutate(a, a);
            return 1000 * a.count + b.count - 4002;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static int count_RRGh8JLk(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode mutateCopyMutate_FmcyGD65(s_SolvedNode& callsite, s_SolvedNode& root)
{
    callsite.items += s_SolvedNode(callsite);
    /*MOV*/ s_SolvedNode result { root };
    root.items += s_SolvedNode(root);
    return /*NRVO*/ result;
}

inline static int& l_1_0_YxYlvGTT(const s_SolvedNode& item, int& c)
{
    return (c += count_RRGh8JLk(item));
}

                                #ifndef DEF_each_o0WuElfhJcc
                                #define DEF_each_o0WuElfhJcc
inline void each_o0WuElfh(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_YxYlvGTT(a[i], c);

}
                                #endif

static int count_RRGh8JLk(const s_SolvedNode& node)
{
    int c = 1;
    each_o0WuElfh(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode a {};
    s_SolvedNode b = mutateCopyMutate_FmcyGD65(a, a);
    return ((1000 * count_RRGh8JLk(a)) + count_RRGh8JLk(b)) - 4002;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk, N_COWRestrict

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                root.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateCopyMutate();
            return 1000 * a.count + b.count - 4002;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static int count_vhRzRYQj(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode copyRoot_V6uTIUa3(s_SolvedNode& root)
{
    /*MOV*/ s_SolvedNode result { root };
    root.items += s_SolvedNode(root);
    return /*NRVO*/ result;
}

static s_SolvedNode bck_call_v4791KqX(s_SolvedNode& callsite, s_SolvedNode& root)
{
    callsite.items += s_SolvedNode(callsite);
    return copyRoot_V6uTIUa3(root);
}

static s_SolvedNode mutateCopyMutate_TPa3SuED(s_SolvedNode& root)
{
    return bck_call_v4791KqX(root, root);
}

inline static int& l_1_0_lhp832eR(const s_SolvedNode& item, int& c)
{
    return (c += count_vhRzRYQj(item));
}

                                #ifndef DEF_each_RUZR11FMC4b
                                #define DEF_each_RUZR11FMC4b
inline void each_RUZR11FM(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_lhp832eR(a[i], c);

}
                                #endif

static int count_vhRzRYQj(const s_SolvedNode& node)
{
    int c = 1;
    each_RUZR11FM(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode a {};
    s_SolvedNode b = mutateCopyMutate_TPa3SuED(a);
    return ((1000 * count_vhRzRYQj(a)) + count_vhRzRYQj(b)) - 4002;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk, N_COWRestrict

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopyAfterRecursion(ref root: SolvedNode) {
            fn mutateThenCopy(ref callsite: SolvedNode) {
                callsite.items ~= callsite;

                mut result = root;
                result.items ~= root;
                return result;
            }

            fn indirectRecursion(ref node: SolvedNode) {
                ref items = node.items;

                // The root copies made at the end of each bck_node call
                //  would indeed be invalid if they survived,
                //   but they get return-discarded here.
                for (mut i = items.len; i --> 1; )
                    bck_node(items[i]);                         // !N_COWRestrict
                                                                // PointlessMustSeq
                return items && bck_node(items[0]);
            }

            fn bck_node(ref node: SolvedNode)
                node.items
                    ? indirectRecursion(node)
                    : mutateThenCopy(node);

            return bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopyAfterRecursion();
            return 1000 * a.count + b.count - 2004;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static s_SolvedNode bck_node_IilWTsic(s_SolvedNode&, const s_SolvedNode&);
static int count_cKTAcYKk(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode indirectRecursion_jsNmAv3h(s_SolvedNode& node, const s_SolvedNode& root)
{
    fu::view_mut<s_SolvedNode> /*node*/ items = node.items;
    for (int i = items.size(); i-- > 1; )
        bck_node_IilWTsic(items.mutref(i), root);

    if (items)
        return bck_node_IilWTsic(items.mutref(0), root);
    else
    {
        return s_SolvedNode{};
    };
}

static s_SolvedNode mutateThenCopy_6IrvCldG(s_SolvedNode& callsite, const s_SolvedNode& root)
{
    callsite.items += s_SolvedNode(callsite);
    /*MOV*/ s_SolvedNode result { root };
    result.items += s_SolvedNode(root);
    return /*NRVO*/ result;
}

static s_SolvedNode bck_node_IilWTsic(s_SolvedNode& node, const s_SolvedNode& root)
{
    if (node.items)
        return indirectRecursion_jsNmAv3h(node, root);
    else
        return mutateThenCopy_6IrvCldG(node, root);

}

static s_SolvedNode mutateThenCopyAfterRecursion_TPa3SuED(s_SolvedNode& root)
{
    return bck_node_IilWTsic(root, root);
}

inline static int& l_1_0_rjLVniZF(const s_SolvedNode& item, int& c)
{
    return (c += count_cKTAcYKk(item));
}

                                #ifndef DEF_each_QnxWqxAxsy1
                                #define DEF_each_QnxWqxAxsy1
inline void each_QnxWqxAx(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_rjLVniZF(a[i], c);

}
                                #endif

static int count_cKTAcYKk(const s_SolvedNode& node)
{
    int c = 1;
    each_QnxWqxAx(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode a {};
    s_SolvedNode b = mutateThenCopyAfterRecursion_TPa3SuED(a);
    return ((1000 * count_cKTAcYKk(a)) + count_cKTAcYKk(b)) - 2004;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARMustSeq, N_AARSoftRisk

-----

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            ref  items = node.items;

            for (mut i = items.len; i --> 0; ) {
                <alt>
                if (i)      escape = root;
                else        items[i].items ~= escape;
                <alt/>
                if (i == 0) items[i].items ~= escape;
                else        escape = root;
                </alt>
            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 27:46+4[0m:

[2m      | [0m
[2m      |             mut root = Node([ Node, Node ]);[0m
[2m   27 | [0m            obtuseEscapeOnNextLoopIter(root, [31;1mroot[0m);
[2m      | [0m
[2m      |             // Now root should be:[0m

	At call to [35;1mfn[0m [34;1mobtuseEscapeOnNextLoopIter[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mobtuseEscapeOnNextLoopIter[0m:[34;1mroot[0m and
	    1:	[35;1mref arg[0m [34;1mobtuseEscapeOnNextLoopIter[0m:[34;1mnode[0m

	    both alias:

	    [35;1mvar[0m [34;1mroot[0m at [2m26:17+4[0m:

[2m      |             }[0m
[2m      | [0m
[2m   26 | [0m            mut [31;1mroot[0m = Node([ Node, Node ]);
[2m      |             obtuseEscapeOnNextLoopIter(root, root);[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mobtuseEscapeOnNextLoopIter[0m:[34;1mroot[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mobtuseEscapeOnNextLoopIter[0m:[34;1mnode[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m19:12+4[0m

-----

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            fn   items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i == 0) items[i].items ~= escape;
                else        escape = root;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_Node;
static int count_nMOLx2l4(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<s_Node>& items_V6uTIUa3(s_Node& node)
{
    return node.items;
}

static void obtuseEscapeOnNextLoopIter_Ir8CrzQG(s_Node& node, const s_Node& root)
{
    s_Node escape {};
    for (int i = items_V6uTIUa3(node).size(); i-- > 0; )
    {
        if (i == 0)
            items_V6uTIUa3(node).mutref(i).items += s_Node(escape);
        else
            escape = root;

    };
}

inline static int& l_1_0_8L3Fh70S(const s_Node& item, int& c)
{
    return (c += count_nMOLx2l4(item));
}

                                #ifndef DEF_each_U2ZCnV8MeJ7
                                #define DEF_each_U2ZCnV8MeJ7
inline void each_U2ZCnV8M(fu::view<s_Node> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_8L3Fh70S(a[i], c);

}
                                #endif

static int count_nMOLx2l4(const s_Node& node)
{
    int c = 1;
    each_U2ZCnV8M(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_Node root = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } };
    obtuseEscapeOnNextLoopIter_Ir8CrzQG(root, root);
    return count_nMOLx2l4(root) - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk, N_COWRestrict

-----

        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;

            fn   items = node.items;

            for (mut i = items.len; i --> 0; ) {

                if (i)      escape = root;
                else        items[i].items ~= escape;

            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_Node;
static int count_OwW7KKG1(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<s_Node>& items_V6uTIUa3(s_Node& node)
{
    return node.items;
}

static void obtuseEscapeOnNextLoopIter_Ir8CrzQG(s_Node& node, const s_Node& root)
{
    s_Node escape {};
    for (int i = items_V6uTIUa3(node).size(); i-- > 0; )
    {
        if (i)
            escape = root;
        else
            items_V6uTIUa3(node).mutref(i).items += s_Node(escape);

    };
}

inline static int& l_1_0_gLcgP0K9(const s_Node& item, int& c)
{
    return (c += count_OwW7KKG1(item));
}

                                #ifndef DEF_each_y11L1IRvh55
                                #define DEF_each_y11L1IRvh55
inline void each_y11L1IRv(fu::view<s_Node> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_gLcgP0K9(a[i], c);

}
                                #endif

static int count_OwW7KKG1(const s_Node& node)
{
    int c = 1;
    each_y11L1IRv(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_Node root = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } };
    obtuseEscapeOnNextLoopIter_Ir8CrzQG(root, root);
    return count_OwW7KKG1(root) - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_UnusedImplicit, N_AARSoftRisk, N_COWRestrict

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {
            if (a.items.len & 1) {
                ref items = a.items;
                for (mut i = 0; i < items.len; i++)
                    cowAfterConditionalWithLoop(items[i], b);
            }

            a.items ~= b;
        }

        fn main() {
            mut x = SolvedNode([ SolvedNode ]);

            ref y = x;  
            cowAfterConditionalWithLoop(x, y);                  ;; N_COWRestrict

            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            return x.count == 6 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:44+1[0m:

[2m      | [0m
[2m      |             ref y = x;  [0m
[2m   20 | [0m            cowAfterConditionalWithLoop(x, [31;1my[0m);                  // N_COWRestrict
[2m      | [0m
[2m      |             fn count(node: SolvedNode) {[0m

	At call to [35;1mfn[0m [34;1mcowAfterConditionalWithLoop[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mcowAfterConditionalWithLoop[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1mcowAfterConditionalWithLoop[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mx[0m at [2m17:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mx[0m = SolvedNode([ SolvedNode ]);
[2m      | [0m
[2m      |             ref y = x;  [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mcowAfterConditionalWithLoop[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mcowAfterConditionalWithLoop[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m16:12+4[0m

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {
            if (a.items.len & 1) {
                ref items = a.items;
                for (mut i = 0; i < items.len; i++)
                    cowAfterConditionalWithLoop(items[i], b);
            }

            a.items ~= b;
        }

        fn main() {
            mut x = SolvedNode([ SolvedNode ]);

            mut y = x;  
            cowAfterConditionalWithLoop(x, y);                  // N_COWRestrict

            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            return x.count == 6 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static void cowAfterConditionalWithLoop_f5Xb8T4M(s_SolvedNode&, const s_SolvedNode&);
static int count_EdVPHFqP(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void cowAfterConditionalWithLoop_f5Xb8T4M(s_SolvedNode& a, const s_SolvedNode& b)
{
    if (a.items.size() & 1)
    {
        fu::view_mut<s_SolvedNode> /*a*/ items = a.items;
        for (int i = 0; i < items.size(); i++)
            cowAfterConditionalWithLoop_f5Xb8T4M(items.mutref(i), b);

    };
    a.items += s_SolvedNode(b);
}

inline static int& l_1_0_Kjx2VrTc(const s_SolvedNode& item, int& c)
{
    return (c += count_EdVPHFqP(item));
}

                                #ifndef DEF_each_mwjbyvBqMtk
                                #define DEF_each_mwjbyvBqMtk
inline void each_mwjbyvBq(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_Kjx2VrTc(a[i], c);

}
                                #endif

static int count_EdVPHFqP(const s_SolvedNode& node)
{
    int c = 1;
    each_mwjbyvBq(node.items, c);
    return c;
}

int fu_MAIN()
{
    s_SolvedNode x = s_SolvedNode { fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode{} } } };
    s_SolvedNode y { x };
    cowAfterConditionalWithLoop_f5Xb8T4M(x, y);
    if (count_EdVPHFqP(x) == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_COWRestrict

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)
        {
            fn fail(reason: string)
                reason.len & 1 && throw("odd: " ~ reason)
                               || throw(reason);

            fn bck_node(ref node: SolvedNode) {
                ref items = node.items;
                for (mut i = 0; i < items.len; i++) {
                    ref item = items[i];
                    bck_node(item);

                    if (item.items.len > 1) {
                        escape = root;

                        if (escape.items.len > 3)       
                            fail("#" ~ escape.items.len);
                    }
                }

                node.items ~= node;
            }

            bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut escape: SolvedNode;
            mut a = SolvedNode([ SolvedNode ]);
            a.copiesRootBeforeThrow(:escape);

            let C0 = a.count;
            if (C0 != 6)            return 1;

            try {
                a.copiesRootBeforeThrow(:escape);
            }
            catch (e) {
                a.items ~= SolvedNode(); // escape !== a
                let C1 = a.count;
                let C2 = escape.count;
                if (C1 != 11)           return 2;
                if (C2 != 10)           return 3;
                else if (e != "#2")     return 4;
                else                    return 0;
            }

            return 5;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 29:21+1[0m:

[2m      |             }[0m
[2m      | [0m
[2m   29 | [0m            bck_node[31;1m([0mroot);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mbck_node[0m, arguments:

	    2:	[35;1minjected implicit arg[0m [34;1mbck_node[0m:[34;1mcopiesRootBeforeThrow:root[0m and
	    1:	[35;1mref arg[0m [34;1mbck_node[0m:[34;1mnode[0m

	    both alias:

	    [35;1mref arg[0m [34;1mroot[0m at [2m6:38+4[0m:

[2m      |         };[0m
[2m      | [0m
[2m    6 | [0m        fn copiesRootBeforeThrow(ref [31;1mroot[0m: SolvedNode, ref escape: SolvedNode)
[2m      |         {[0m
[2m      |             fn fail(reason: string)[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1minjected implicit arg[0m [34;1mbck_node[0m:[34;1mcopiesRootBeforeThrow:root[0m is [31;1mimplicit[0m

	    [35;1mref arg[0m [34;1mbck_node[0m:[34;1mnode[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mcopiesRootBeforeThrow[0m(SolvedNode, SolvedNode) at [2m6:12+21[0m

-----

        struct SolvedNode {
            items: SolvedNode[];
        };

        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)
        {
            fn fail(reason: string)
                reason.len & 1 && throw("odd: " ~ reason)
                               || throw(reason);

            fn bck_node(ref node: SolvedNode) {
                ref items = node.items;
                for (mut i = 0; i < items.len; i++) {
                    ref item = items[i];
                    bck_node(item);

                    if (item.items.len > 1) {
                        escape = root;

                        if (true)                       
                            fail("#" ~ escape.items.len);
                    }
                }

                node.items ~= node;
            }

            bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut escape: SolvedNode;
            mut a = SolvedNode([ SolvedNode ]);
            a.copiesRootBeforeThrow(:escape);

            let C0 = a.count;
            if (C0 != 6)            return 1;

            try {
                a.copiesRootBeforeThrow(:escape);
            }
            catch (e) {
                a.items ~= SolvedNode(); // escape !== a
                let C1 = a.count;
                let C2 = escape.count;
                if (C1 != 11)           return 2;
                if (C2 != 10)           return 3;
                else if (e != "#2")     return 4;
                else                    return 0;
            }

            return 5;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_SolvedNode;
static void bck_node_9g7pjZz9(s_SolvedNode&, const s_SolvedNode&, s_SolvedNode&);
static int count_byBd7ehL(const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_XrjF32xy(const fu::str& reason)
{
    if (reason.size() & 1)
        fu::fail(("odd: "_fu + reason));
    else
        fu::fail(fu::str(reason));

}

static void bck_node_9g7pjZz9(s_SolvedNode& node, const s_SolvedNode& root, s_SolvedNode& escape)
{
    fu::view_mut<s_SolvedNode> /*node*/ items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        s_SolvedNode& /*items|static*/ item = items.mutref(i);
        bck_node_9g7pjZz9(item, root, escape);
        if (item.items.size() > 1)
        {
            escape = root;
            fail_XrjF32xy(x7E_gCeFmDFw("#"_fu, fu::i64dec(escape.items.size())));
        };
    };
    node.items += s_SolvedNode(node);
}

static void copiesRootBeforeThrow_3xjBOvYI(s_SolvedNode& root, s_SolvedNode& escape)
{
    bck_node_9g7pjZz9(root, root, escape);
}

inline static int& l_1_0_PJiJ2xwq(const s_SolvedNode& item, int& c)
{
    return (c += count_byBd7ehL(item));
}

                                #ifndef DEF_each_nurxQb3Nked
                                #define DEF_each_nurxQb3Nked
inline void each_nurxQb3N(fu::view<s_SolvedNode> a, int& c)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_PJiJ2xwq(a[i], c);

}
                                #endif

static int count_byBd7ehL(const s_SolvedNode& node)
{
    int c = 1;
    each_nurxQb3N(node.items, c);
    return c;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_SolvedNode escape {};
    s_SolvedNode a = s_SolvedNode { fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode{} } } };
    copiesRootBeforeThrow_3xjBOvYI(a, escape);
    const int C0 = count_byBd7ehL(a);
    if (C0 != 6)
        return 1;
    else
    {

        try
        {
            copiesRootBeforeThrow_3xjBOvYI(a, escape);
        }
        catch (const std::exception& o_0)
        {
            fu::str e = fu::to_str(o_0.what());

        {
            a.items += s_SolvedNode{};
            const int C1 = count_byBd7ehL(a);
            const int C2 = count_byBd7ehL(escape);
            if (C1 != 11)
                return 2;
            else if (C2 != 10)
                return 3;
            else if (e != "#2"_fu)
                return 4;
            else
                return 0;

        }
        }
;
        return 5;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedImplicit, N_AARSoftRisk, N_COWRestrict

-----

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {
        <flip>
            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;
        <flip/>
            mut ret = a;
        </flip>
            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            ref  bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 21:56+1[0m:

[2m      |             ref  bytes = a.ints.view(of: byte);[0m
[2m      | [0m
[2m   21 | [0m            let b = copyInts_then_mutateBytes(:bytes, :[31;1ma[0m);
[2m      | [0m
[2m      |             mut sum = 0;[0m

	A copy is needed, but COW will break due to pre-existing mutref: [35;1mref[0m [34;1mbytes[0m at [2m19:18+5[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ref  [31;1mbytes[0m = a.ints.view(of: byte);
[2m      | [0m
[2m      |             let b = copyInts_then_mutateBytes(:bytes, :a);[0m

	Both refer to: [35;1mvar[0m [34;1ma[0m at [2m16:17+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   16 | [0m            mut [31;1ma[0m = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);
[2m      | [0m
[2m      | [0m


RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m15:12+4[0m

-----

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            mut ret = a;

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            fn   bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_A;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view_mut<char> bytes_kKCgCRDz(s_A& a)
{
    return fu::view_of_mut<char>(a.ints);
}

static s_A copyInts_then_mutateBytes_Au30LyeY(fu::view_mut<char> bytes, const s_A& a)
{
    /*MOV*/ s_A ret { a };
    for (int i = 0; i < bytes.size(); i++)
        bytes.mutref(i) = char(0);

    ret.ints.pop();
    return /*NRVO*/ ret;
}

int fu_MAIN()
{
    s_A a = s_A { fu::vec<int> { fu::slate<10, int> { 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 } } };
    s_A _0 {};
    s_A b = (_0 = s_A(a), copyInts_then_mutateBytes_Au30LyeY(bytes_kKCgCRDz(a), static_cast<s_A&&>(_0)));
    int sum = 0;
    for (int i = 0; i < b.ints.size(); i++)
        sum += b.ints[i];

    return sum - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedCall, N_BckMustSeq, N_COWRestrict

-----

        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {

            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;

            mut ret = a;

            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);


            fn   bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_A;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::view_mut<char> bytes_kKCgCRDz(s_A& a)
{
    return fu::view_of_mut<char>(a.ints);
}

static s_A copyInts_then_mutateBytes_Au30LyeY(fu::view_mut<char> bytes, const s_A& a)
{
    for (int i = 0; i < bytes.size(); i++)
        bytes.mutref(i) = char(0);

    /*MOV*/ s_A ret { a };
    ret.ints.pop();
    return /*NRVO*/ ret;
}

int fu_MAIN()
{
    s_A a = s_A { fu::vec<int> { fu::slate<10, int> { 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 } } };
    s_A _0 {};
    s_A b = (_0 = s_A(a), copyInts_then_mutateBytes_Au30LyeY(bytes_kKCgCRDz(a), static_cast<s_A&&>(_0)));
    int sum = 0;
    for (int i = 0; i < b.ints.size(); i++)
        sum += b.ints[i];

    return sum - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedCall, N_BckMustSeq

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.push(5);
        if ((arr0[1] + arr0[4] - arr0[5]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.push(5);
        if ((arr1[1] + arr1[4] - arr1[5]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.push(5);
        if ((arr2[1] + arr2[4] - arr2[5]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.push(5);
        if (((arr0[1] + arr0[4]) - arr0[5]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.push(5);
        if (((arr1[1] + arr1[4]) - arr1[5]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.push(5);
        if (((orig[1] + orig[4]) - orig[5]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(5, 5);
        if ((arr0[1] + arr0[4] - arr0[5]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(5, 5);
        if ((arr1[1] + arr1[4] - arr1[5]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(5, 5);
        if ((arr2[1] + arr2[4] - arr2[5]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.insert(5, 5);
        if (((arr0[1] + arr0[4]) - arr0[5]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.insert(5, 5);
        if (((arr1[1] + arr1[4]) - arr1[5]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(5, 5);
        if (((orig[1] + orig[4]) - orig[5]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.pop();
        if ((arr0[1] + arr0[3] - arr0.len) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.pop();
        if ((arr1[1] + arr1[3] - arr1.len) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.pop();
        if ((arr2[1] + arr2[3] - arr2.len) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.pop();
        if (((arr0[1] + arr0[3]) - arr0.size()) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.pop();
        if (((arr1[1] + arr1[3]) - arr1.size()) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.pop();
        if (((orig[1] + orig[3]) - orig.size()) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.splice(4, 1);
        if ((arr0[1] + arr0[3] - arr0.len) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.splice(4, 1);
        if ((arr1[1] + arr1[3] - arr1.len) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.splice(4, 1);
        if ((arr2[1] + arr2[3] - arr2.len) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.splice(4, 1);
        if (((arr0[1] + arr0[3]) - arr0.size()) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.splice(4, 1);
        if (((arr1[1] + arr1[3]) - arr1.size()) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.splice(4, 1);
        if (((orig[1] + orig[3]) - orig.size()) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.unshift(5);
        if ((arr0[2] + arr0[5] - arr0[0]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.unshift(5);
        if ((arr1[2] + arr1[5] - arr1[0]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.unshift(5);
        if ((arr2[2] + arr2[5] - arr2[0]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.unshift(5);
        if (((arr0[2] + arr0[5]) - arr0[0]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.unshift(5);
        if (((arr1[2] + arr1[5]) - arr1[0]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.unshift(5);
        if (((orig[2] + orig[5]) - orig[0]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(0, 5);
        if ((arr0[2] + arr0[5] - arr0[0]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(0, 5);
        if ((arr1[2] + arr1[5] - arr1[0]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(0, 5);
        if ((arr2[2] + arr2[5] - arr2[0]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.insert(0, 5);
        if (((arr0[2] + arr0[5]) - arr0[0]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.insert(0, 5);
        if (((arr1[2] + arr1[5]) - arr1[0]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(0, 5);
        if (((orig[2] + orig[5]) - orig[0]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.shift();
        if ((arr0[0] + arr0[2] - arr0[3]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.shift();
        if ((arr1[0] + arr1[2] - arr1[3]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.shift();
        if ((arr2[0] + arr2[2] - arr2[3]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.shift();
        if (((arr0[0] + arr0[2]) - arr0[3]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.shift();
        if (((arr1[0] + arr1[2]) - arr1[3]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.shift();
        if (((orig[0] + orig[2]) - orig[3]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,4];
        arr0.insert(1, 5);
        if ((arr0[2] + arr0[5] - arr0[1]) != 0) return 13;
    }

    mut orig = [0,1,2,3,4];

    {
        mut arr1 = orig;
        arr1.insert(1, 5);
        if ((arr1[2] + arr1[5] - arr1[1]) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.insert(1, 5);
        if ((arr2[2] + arr2[5] - arr2[1]) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };
        arr0.insert(1, 5);
        if (((arr0[2] + arr0[5]) - arr0[1]) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 4 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.insert(1, 5);
        if (((arr1[2] + arr1[5]) - arr1[1]) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.insert(1, 5);
        if (((orig[2] + orig[5]) - orig[1]) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


    {
        mut arr0 = [0,1,2,3,100];
        arr0.splice(1, 3);
        if ((arr0.len + arr0[0] + arr0[1] - 102) != 0) return 13;
    }

    mut orig = [0,1,2,3,100];

    {
        mut arr1 = orig;
        arr1.splice(1, 3);
        if ((arr1.len + arr1[0] + arr1[1] - 102) != 0) return 17;
    }

    {
        ref arr2 = orig;
        if (arr2.len != 5) return 38;
        arr2.splice(1, 3);
        if ((arr2.len + arr2[0] + arr2[1] - 102) != 0) return 23;
    }

    return 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{

    {
        fu::vec<int> arr0 = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 100 } };
        arr0.splice(1, 3);
        if ((((arr0.size() + arr0[0]) + arr0[1]) - 102) != 0)
            return 13;

    };
    fu::vec<int> orig = fu::vec<int> { fu::slate<5, int> { 0, 1, 2, 3, 100 } };

    {
        fu::vec<int> arr1 { orig };
        arr1.splice(1, 3);
        if ((((arr1.size() + arr1[0]) + arr1[1]) - 102) != 0)
            return 17;

    };
    if (orig.size() != 5)
        return 38;
    else
    {
        orig.splice(1, 3);
        if ((((orig.size() + orig[0]) + orig[1]) - 102) != 0)
            return 23;

    };
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        let OPERATORS = [ "+", "-", "*", "/" ];

        fn main()
            OPERATORS[2] == "*" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<fu::str> OPERATORS fu_INIT_PRIORITY(1001) = fu::vec<fu::str> { fu::slate<4, fu::str> { "+"_fu, "-"_fu, "*"_fu, "/"_fu } };

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if (OPERATORS[2] == "*"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;

-----
#include <fu/vec.h>

struct s_X;
struct s_Y;

                                #ifndef DEF_s_Y
                                #define DEF_s_Y
struct s_Y
{
    bool b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    fu::vec<s_Y> y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<s_X> x {};
    x.push(s_X { fu::vec<s_Y> { fu::slate<1, s_Y> { s_Y { true } } } });
    return (x.size() + (x[0].y.size() * 2)) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct SelfRec { x: SelfRec[]; };
        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

-----
#include <fu/vec.h>

struct s_SelfRec;

                                #ifndef DEF_s_SelfRec
                                #define DEF_s_SelfRec
struct s_SelfRec
{
    fu::vec<s_SelfRec> x;
    s_SelfRec(const s_SelfRec&) = default;
    s_SelfRec(s_SelfRec&&) = default;
    s_SelfRec& operator=(s_SelfRec&&) = default;
    s_SelfRec& operator=(const s_SelfRec& selfrec) { return *this = s_SelfRec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_SelfRec { fu::vec<s_SelfRec> { fu::slate<1, s_SelfRec> { s_SelfRec{} } } }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        struct ABRec { x: BARec[]; };
        struct BARec { x: ABRec[]; };
        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

-----
#include <fu/vec.h>

struct s_BARec;
struct s_ABRec;

                                #ifndef DEF_s_ABRec
                                #define DEF_s_ABRec
struct s_ABRec
{
    fu::vec<s_BARec> x;
    s_ABRec(const s_ABRec&) = default;
    s_ABRec(s_ABRec&&) = default;
    s_ABRec& operator=(s_ABRec&&) = default;
    s_ABRec& operator=(const s_ABRec& selfrec) { return *this = s_ABRec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BARec
                                #define DEF_s_BARec
struct s_BARec
{
    fu::vec<s_ABRec> x;
    s_BARec(const s_BARec&) = default;
    s_BARec(s_BARec&&) = default;
    s_BARec& operator=(s_BARec&&) = default;
    s_BARec& operator=(const s_BARec& selfrec) { return *this = s_BARec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_ABRec { fu::vec<s_BARec> { fu::slate<1, s_BARec> { s_BARec{} } } }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen

-----

        struct ABRec { x: BARec[]; y: ABBARec[]; };
        struct BARec { x: ABRec[]; y: ABBARec[]; };
        struct ABBARec { x: ABRec[]; y: BARec[]; };
        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor

-----
#include <fu/vec.h>

struct s_BARec;
struct s_ABRec;
struct s_ABBARec;

                                #ifndef DEF_s_ABRec
                                #define DEF_s_ABRec
struct s_ABRec
{
    fu::vec<s_BARec> x;
    fu::vec<s_ABBARec> y;
    s_ABRec(const s_ABRec&) = default;
    s_ABRec(s_ABRec&&) = default;
    s_ABRec& operator=(s_ABRec&&) = default;
    s_ABRec& operator=(const s_ABRec& selfrec) { return *this = s_ABRec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BARec
                                #define DEF_s_BARec
struct s_BARec
{
    fu::vec<s_ABRec> x;
    fu::vec<s_ABBARec> y;
    s_BARec(const s_BARec&) = default;
    s_BARec(s_BARec&&) = default;
    s_BARec& operator=(s_BARec&&) = default;
    s_BARec& operator=(const s_BARec& selfrec) { return *this = s_BARec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ABBARec
                                #define DEF_s_ABBARec
struct s_ABBARec
{
    fu::vec<s_ABRec> x;
    fu::vec<s_BARec> y;
    s_ABBARec(const s_ABBARec&) = default;
    s_ABBARec(s_ABBARec&&) = default;
    s_ABBARec& operator=(s_ABBARec&&) = default;
    s_ABBARec& operator=(const s_ABBARec& selfrec) { return *this = s_ABBARec(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_ABRec { fu::vec<s_BARec> { fu::slate<1, s_BARec> { s_BARec{} } }, {} }.x.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_UnusedCall, N_UnusedArrlit

-----

        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sort_RLEM4CuK8dj
                                #define DEF_sort_RLEM4CuK8dj
inline void sort_RLEM4CuK(fu::vec<int>& a)
{
    auto* data = a.data_mut();
    std::sort(data, data + a.size());

}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<6, int> { 7, 1, 5, 3, 99, -13 } };
    sort_RLEM4CuK(a);
    return ((a[0] + a[1]) + a[3]) + a[4];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];

-----
#include <fu/vec.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<4, int> { 0, 1, 2, 3 } };
    fu::vec<int> b = fu::slice(a, 1, 3);
    return b.size() - b[1];
}

#endif

int main() { return fu_MAIN(); }

-----

        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];

-----
#include <fu/vec.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<4, int> { 0, 1, 2, 3 } };
    fu::vec<int> b = fu::slice(a, 1);
    return b.size() - b[2];
}

#endif

int main() { return fu_MAIN(); }

-----

        fn collectDedupes(mut vals) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sort_RLEM4CuK8dj
                                #define DEF_sort_RLEM4CuK8dj
inline void sort_RLEM4CuK(fu::vec<int>& a)
{
    auto* data = a.data_mut();
    std::sort(data, data + a.size());

}
                                #endif

inline static int collectDedupes_ccs08Y4P(fu::vec<int>&& vals)
{
    sort_RLEM4CuK(vals);
    return vals[0];
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 0 } };
    return collectDedupes_ccs08Y4P(static_cast<fu::vec<int>&&>(vals));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn collectDedupes(mut vals: i32[]) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sort_RLEM4CuK8dj
                                #define DEF_sort_RLEM4CuK8dj
inline void sort_RLEM4CuK(fu::vec<int>& a)
{
    auto* data = a.data_mut();
    std::sort(data, data + a.size());

}
                                #endif

static int collectDedupes_ccs08Y4P(fu::vec<int>&& vals)
{
    sort_RLEM4CuK(vals);
    return vals[0];
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 0 } };
    return collectDedupes_ccs08Y4P(static_cast<fu::vec<int>&&>(vals));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn sort01(ref arr: [$T]) {
            mut tmp: $T;
            if (arr[0] > arr[1]) {
                swap(arr[0], tmp);
                swap(arr[1], tmp);
            }
        }

        fn collectDedupes(mut vals) {
            vals.sort01();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }

-----
#include <utility>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static void sort01_YDgjL7oA(fu::view_mut<int> arr)
{
    int tmp {};
    if (arr[0] > arr[1])
    {
        std::swap(arr.mutref(0), tmp);
        std::swap(arr.mutref(1), tmp);
    };
}

inline static int collectDedupes_2sEUUg3k(fu::vec<int>&& vals)
{
    sort01_YDgjL7oA(vals);
    return vals[0];
}

int fu_MAIN()
{
    /*MOV*/ fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 0 } };
    return collectDedupes_2sEUUg3k(static_cast<fu::vec<int>&&>(vals));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        mut str = "hello ";
        str ~= "world";

        return str.len - 11;

-----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str str = "hello "_fu;
    str += "world"_fu;
    return str.size() - 11;
}

#endif

int main() { return fu_MAIN(); }

-----

        let str = "hello " ~ "world";

        return str.starts(with: "hel")
             ? str  .ends(with: "rld")
             ? str.len - 11
             : 171
             : 173;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_starts_t2TApdnqRc8
                                #define DEF_starts_t2TApdnqRc8
inline bool starts_t2TApdnq(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_ends_t2TApdnqRc8
                                #define DEF_ends_t2TApdnqRc8
inline bool ends_t2TApdnq(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

int fu_MAIN()
{
    fu::str str = ("hello "_fu + "world"_fu);
    if (starts_t2TApdnq(str, "hel"_fu))
    {
        if (ends_t2TApdnq(str, "rld"_fu))
            return str.size() - 11;
        else
            return 171;

    }
    else
        return 173;

}

#endif

int main() { return fu_MAIN(); }

-----

        let str = "a" ~ 1710010;

        return str == "a1710010"
             ? 0 : 101;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str = x7E_gCeFmDFw("a"_fu, fu::i64dec(1710010));
    if (str == "a1710010"_fu)
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

-----

        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str str = "hello world"_fu;
    fu::str cpy = ""_fu;
    for (int i = 0; i < str.size(); i++)
        cpy += str[i];

    return (cpy.size() - 11) + ((cpy == str) ? 0 : 1);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        return "hello world".find("world")
             - 2 * [1, 7, 13, 14, 19].find(14);

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/find.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_wxSKDW5VMoc
                                #define DEF_find_wxSKDW5VMoc
inline int find_wxSKDW5V(fu::view<int> a, const int b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

int fu_MAIN()
{
    return fu::lfind("hello world"_fu, "world"_fu) - (2 * find_wxSKDW5V((fu::slate<5, int> { 1, 7, 13, 14, 19 }), 14));
}

#endif

int main() { return fu_MAIN(); }

-----

        return ("hello world".has("world") ? 1 : 0)
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/find.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_has_wxSKDW5VMoc
                                #define DEF_has_wxSKDW5VMoc
inline bool has_wxSKDW5V(fu::view<int> a, const int b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return true;

    };
    return false;
}
                                #endif

int fu_MAIN()
{
    return ((fu::has("hello world"_fu, "world"_fu) ? 1 : 0) + (has_wxSKDW5V((fu::slate<4, int> { 1, 14, 96, 2 }), 14) ? 2 : 0)) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        let hw = "hello world!";
        let a = hw.slice(6, 6 + 5);
        let b = hw.substr(6, 5);
        return a == b && a == "world" ? a.len - 5 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str hw = "hello world!"_fu;
    fu::str a = fu::slice(hw, 6, (6 + 5));
    fu::str b = fu::substr(hw, 6, 5);
    if ((a == b) && (a == "world"_fu))
        return a.size() - 5;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

inline static fu::vec<fu::str>& l_0_0_WNUkCqZ3(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_nFb7U3wbV7b
                                #define DEF_split_nFb7U3wbV7b
inline void split_nFb7U3wb(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_WNUkCqZ3(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_WNUkCqZ3(fu::slice(str, last), result);
    else
        l_0_0_WNUkCqZ3(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_nFb7U3wb(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static int test_4jEYVeYJ(const fu::str& item)
{
    if (item == join_jCe9HYtv(split_e8WhGmUq(item, " "_fu), " "_fu))
        return 0;
    else
        return item.size();

}

int fu_MAIN()
{
    fu::vec<fu::str> tests = fu::vec<fu::str> { fu::slate<9, fu::str> { ""_fu, " "_fu, "  "_fu, "hey you duders"_fu, " hey you duders"_fu, "hey you duders "_fu, "  hey you duders "_fu, "  hey you  duders "_fu, "  hey you  duders  "_fu } };
    int sum = 0;
    for (int i = 0; i < tests.size(); i++)
        sum += test_4jEYVeYJ(tests[i]);

    return sum;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn main() {
            let sj = "heelloo"  .split("ee").join("e")
                                .split('o').join("o!")
                                .split("he").join();

            return sj == "llo!o!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

inline static fu::vec<fu::str>& l_0_0_d9PInYd9(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_Myq5dmO0vH6
                                #define DEF_split_Myq5dmO0vH6
inline void split_Myq5dmO0(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_d9PInYd9(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_d9PInYd9(fu::slice(str, last), result);
    else
        l_0_0_d9PInYd9(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_Myq5dmO0(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_find_T9i966y9wQg
                                #define DEF_find_T9i966y9wQg
inline int find_T9i966y9(fu::view<char> a, const char b, int start)
{
    start = ((start > 0) ? start : 0);
    for (int i = start; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

inline static fu::vec<fu::str>& l_0_0_sodmVHgW(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_G97w0IE0lB6
                                #define DEF_split_G97w0IE0lB6
inline void split_G97w0IE0(const fu::str& str, const char sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = 1;
    while (((next = find_T9i966y9(str, sep, last)) >= 0))
    {
        l_0_0_sodmVHgW(fu::slice(str, last, next), result);
        last = (next + N);
    };
    if (last)
        l_0_0_sodmVHgW(fu::slice(str, last), result);
    else
        l_0_0_sodmVHgW(str, result);

}
                                #endif

                                #ifndef DEF_split_42u6frOYgx6
                                #define DEF_split_42u6frOYgx6
inline fu::vec<fu::str> split_42u6frOY(const fu::str& str, const char sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_G97w0IE0(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_join_6LmAXnK0Otg
                                #define DEF_join_6LmAXnK0Otg
inline fu::str join_6LmAXnK0(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str sj = join_6LmAXnK0(split_e8WhGmUq(join_jCe9HYtv(split_42u6frOY(join_jCe9HYtv(split_e8WhGmUq("heelloo"_fu, "ee"_fu), "e"_fu), 'o'), "o!"_fu), "he"_fu));
    if (sj == "llo!o!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn main() '\e'.i32 - 27
             ||   '\0'.i32
             || '\x11'.i32 - 17
             || '\xaA'.i32 - 170;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int _0 {};
    return (_0 = (int(fu::u8('\x1B')) - 27)) ? _0 : (_0 = int(fu::u8('\x00'))) ? _0 : (_0 = (int(fu::u8('\x11')) - 17)) ? _0 : (int(fu::u8('\xAA')) - 170);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()     // '
            'c
            '       
                .i32 - 99;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()     // '[0m
[2m    3 | [0m            [31;1m'c[0m
[2m      |             '       [0m
[2m      |                 .i32 - 99;[0m

	Unterminated char literal.

-----

        fn main()   
            'c      
                .i32 - 99;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m'c[0m      
[2m      |                 .i32 - 99;[0m
[2m      | [0m

	Unterminated char literal.

-----

        fn main()   
            'c'     
                .i32 - 99;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8('c')) - 99;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()   
            'cb'    
                .i32 - 99;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+4[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m'cb'[0m    
[2m      |                 .i32 - 99;[0m
[2m      | [0m

	Invalid char literal, not single byte: 2 bytes long.

-----

        fn main()   
            'c'     
                .i32 - 99;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8('c')) - 99;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()     // "
            "c
            "       
                [0].i32 - 99;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()     // "[0m
[2m    3 | [0m            [31;1m"c[0m
[2m      |             "       [0m
[2m      |                 [0].i32 - 99;[0m

	Unterminated double-quote string literal.

	Use backticks around multiline strings.

-----

        fn main()   
            "c      
                [0].i32 - 99;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+2[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m"c[0m      
[2m      |                 [0].i32 - 99;[0m
[2m      | [0m

	Unterminated double-quote string literal.

	Use backticks around multiline strings.

-----

        fn main()   
            `c
            `      
                [0].i32 - 99;

-----
#include <fu/int.h>
#include <fu/str.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8("c\n            "_fu[0])) - 99;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()                           
            "\u{ffffff}".u32               
            ;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:14+10[0m:

[2m      | [0m
[2m      |         fn main()                           [0m
[2m    3 | [0m            "[31;1m\u{ffffff}[0m".u32               
[2m      |             ;[0m
[2m      | [0m

	Invalid \u-escape: bad code point.

-----

        fn main()                           
            "\u{042e}" == "Ю"  ? 0 : 1     
            ;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if ("\xD0\xAE"_fu == "\xD0\xAE"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut hello = "hello";
            mut olleh = hello;
            olleh.reverse();
            return olleh == "olleh" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/view_swap.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_5Wk4dJRAXFe
                                #define DEF_reverse_5Wk4dJRAXFe
inline void reverse_5Wk4dJRA(fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    /*MOV*/ fu::str hello = "hello"_fu;
    fu::str olleh = static_cast<fu::str&&>(hello);
    reverse_5Wk4dJRA(olleh);
    if (olleh == "olleh"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main()
            "hello".replace(all: "h", with: "H") == "Hello" &&
            "hello".replace(all: 'e', with: 'E') == "hEllo" &&
            "hello".replace(all: "l", with: 'L') == "heLLo" &&
            "hello".replace(all: 'o', with: "O") == "hellO" &&
            "hello".replace(all: "l", with:  []) == "heo"
                ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_replace_t9kb9bFxF28
                                #define DEF_replace_t9kb9bFxF28
inline fu::str replace_t9kb9bFx(const fu::str& str, fu::view<char> all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = fu::lfind(str, all, last)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_find_T9i966y9wQg
                                #define DEF_find_T9i966y9wQg
inline int find_T9i966y9(fu::view<char> a, const char b, int start)
{
    start = ((start > 0) ? start : 0);
    for (int i = start; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_replace_z4kqv8Gu68d
                                #define DEF_replace_z4kqv8Gu68d
inline fu::str replace_z4kqv8Gu(const fu::str& str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_T9i966y9(str, all, last)) >= 0))
        {

            {
                fu::str substr = fu::slice(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_eRkMSnTRRHc
                                #define DEF_replace_eRkMSnTRRHc
inline fu::str replace_eRkMSnTR(const fu::str& str, fu::view<char> all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = fu::lfind(str, all, last)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_xsEwM8N89P6
                                #define DEF_replace_xsEwM8N89P6
inline fu::str replace_xsEwM8N8(const fu::str& str, const char all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_T9i966y9(str, all, last)) >= 0))
        {

            {
                fu::str substr = fu::slice(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_replace_KzhDsAOfzK1
                                #define DEF_replace_KzhDsAOfzK1
inline fu::str replace_KzhDsAOf(const fu::str& str, fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = fu::lfind(str, all, last)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last, next);
                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    if ((replace_t9kb9bFx("hello"_fu, "h"_fu, "H"_fu) == "Hello"_fu) && (replace_z4kqv8Gu("hello"_fu, 'e', 'E') == "hEllo"_fu) && (replace_eRkMSnTR("hello"_fu, "l"_fu, 'L') == "heLLo"_fu) && (replace_xsEwM8N8("hello"_fu, 'o', "O"_fu) == "hellO"_fu) && (replace_KzhDsAOf("hello"_fu, "l"_fu) == "heo"_fu))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedAndOr, N_UnusedLet

-----

        fn cnct(a: string, b: string) a ~ b;

        fn main()
            cnct( 
                a: "hello, "`world!
` 
            ).len - 14;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:29+9[0m:

[2m      |         fn main()[0m
[2m      |             cnct( [0m
[2m    6 | [0m                a: "hello, "[31;1m`world![0m
[2m      | ` [0m
[2m      |             ).len - 14;[0m

	Missing comma before `world!
`.

-----

        fn cnct(a: string, b: string) a ~ b;

        fn main()
            cnct( 
                a: "hello, ", `world!
` 
            ).len - 14;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str cnct_xagds2ks(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}

int fu_MAIN()
{
    return cnct_xagds2ks("hello, "_fu, "world!\n"_fu).size() - 14;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() ("" ~ "").len;

-----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return (""_fu + ""_fu).size();
}

#endif

int main() { return fu_MAIN(); }

-----

        let empty_str = "";

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_empty_str
                                #define DEF_empty_str
extern const fu::str empty_str fu_INIT_PRIORITY(1001) = ""_fu;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let empty_str = "";

        fn main() = _0::empty_str.len;

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_empty_str
                                #define DEF_empty_str
extern const fu::str empty_str;
                                #endif

int fu_MAIN()
{
    return empty_str.size();
}

#endif

int main() { return fu_MAIN(); }

-----

        let empty_str = "";
        let empty_str_ref = empty_str;

-----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_empty_str
                                #define DEF_empty_str
extern const fu::str empty_str fu_INIT_PRIORITY(1001) = ""_fu;
                                #endif

                                #ifndef DEF_empty_str_ref
                                #define DEF_empty_str_ref
extern const fu::static_ref<fu::str> /*static*/ empty_str_ref fu_INIT_PRIORITY(1001) = empty_str;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let empty_str = "";
        let empty_str_ref = empty_str;

        fn main() = _0::empty_str_ref.len;

-----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_empty_str_ref
                                #define DEF_empty_str_ref
extern const fu::static_ref<fu::str> /*static*/ empty_str_ref;
                                #endif

int fu_MAIN()
{
    return empty_str_ref.ref.size();
}

#endif

int main() { return fu_MAIN(); }

-----

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_str_ref = non_empty_str;

-----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_non_empty_str
                                #define DEF_non_empty_str
extern const fu::str non_empty_str fu_INIT_PRIORITY(1001) = "This is a non-empty string that's too long for small string opti."_fu;
                                #endif

                                #ifndef DEF_non_empty_str_ref
                                #define DEF_non_empty_str_ref
extern const fu::static_ref<fu::str> /*static*/ non_empty_str_ref fu_INIT_PRIORITY(1001) = non_empty_str;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_str_ref = non_empty_str;

        fn main() = _0::non_empty_str_ref.len - 65;

-----
#include <fu/str.h>
#include <fu/static_ref.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_non_empty_str_ref
                                #define DEF_non_empty_str_ref
extern const fu::static_ref<fu::str> /*static*/ non_empty_str_ref;
                                #endif

int fu_MAIN()
{
    return non_empty_str_ref.ref.size() - 65;
}

#endif

int main() { return fu_MAIN(); }

-----

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_slice = non_empty_str[5:];

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_non_empty_str
                                #define DEF_non_empty_str
extern const fu::str non_empty_str fu_INIT_PRIORITY(1001) = "This is a non-empty string that's too long for small string opti."_fu;
                                #endif

                                #ifndef DEF_non_empty_slice
                                #define DEF_non_empty_slice
extern const fu::view<char> /*static*/ non_empty_slice fu_INIT_PRIORITY(1001) = fu::get_view(non_empty_str, 5);
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_slice = non_empty_str[5:];

        fn main() = _0::non_empty_slice.len - 60;

-----
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_non_empty_slice
                                #define DEF_non_empty_slice
extern const fu::view<char> /*static*/ non_empty_slice;
                                #endif

int fu_MAIN()
{
    return non_empty_slice.size() - 60;
}

#endif

int main() { return fu_MAIN(); }

-----

        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
        {
            let a0 = mem::ALLOC_STAT_COUNT();
            strA.slice(0, 26) == "0123456789abcdef0123456789" || throw("bad slice");

            let a1 = mem::ALLOC_STAT_COUNT();
            a0 == a1 || throw("did alloc");

            return 0;
        }

-----

-----

        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::str strA fu_INIT_PRIORITY(1001) = "0123456789abcdef0123456789ABCDEF"_fu;

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if (fu::slice(strA, 26, 32) == "ABCDEF"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn test(a = 1, b = 2) a + b;
        return test() - 3;

-----

#ifndef fu_NO_fdefs

static int test_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_qoaTQFTa(1, 2) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a = 1, b = 2) a + b;
        return test(b: -1);

-----

#ifndef fu_NO_fdefs

static int test_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_qoaTQFTa(1, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a = 1, b = 2) a + b;
        return test(-2);

-----

#ifndef fu_NO_fdefs

static int test_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_qoaTQFTa(-2, 2);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Test t = s_Test { 1, 0 };
    return (t.a - 1) + (t.b * 7);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.b;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Test t = s_Test { {}, 0 };
    return t.b;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a?: i32; b?: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Test t = s_Test { 1, 0 };
    return (t.a - 1) + (t.b * 7);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a?: i32; b?: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Test t = s_Test { 0, 1 };
    return (t.b - 1) + (t.a * 7);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { x?: i32; };
        fn hey() Test();
        return hey.x;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test hey_hpa9AihZ()
{
    return s_Test{};
}

int fu_MAIN()
{
    return hey_hpa9AihZ().x;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { x?: i32; };
        fn hey(y: i32 = 0)
            y   ? Test(1)
                : Test();

        return hey.x;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test hey_2f3gLeWN(const int y)
{
    if (y)
    {
        return s_Test { 1 };
    }
    else
    {
        return s_Test{};
    };
}

int fu_MAIN()
{
    return hey_2f3gLeWN(0).x;
}

#endif

int main() { return fu_MAIN(); }

-----


        fn test(a = "hello") a.len;     
        fn main() test(-1);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+1[0m:

[2m      | [0m
[2m      |         fn test(a = "hello") a.len;     [0m
[2m    4 | [0m        fn main() test[31;1m([0m-1);
[2m      | [0m

	Bad call to [34;1mtest[0m with args (i32 copy AlwaysTrue): 

	[35;1mfn[0m [34;1mtest[0m at [2m3:12+4[0m:
[2m    3 | [0m        fn [31;1mtest[0m(a = "hello") a.len;     

	    [35;1marg[0m [34;1mtest[0m:[34;1ma[0m expects string, got i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----


        fn test(a = 0) a + 1;           
        fn main() test(-1);

-----

#ifndef fu_NO_fdefs

static int test_rgx2eiBu(const int a)
{
    return a + 1;
}

int fu_MAIN()
{
    return test_rgx2eiBu(-1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn woot(ref a: i32, ref b: i32) {
            ref c = a || b;
            fn arg_defaulted_to_closure(ref x = c)
                x *= 2;

            arg_defaulted_to_closure( );
            arg_defaulted_to_closure(a);
            arg_defaulted_to_closure(b);
        }

        fn main() {
            mut a = 1;
            mut b = 1;
            woot(a, b);
            return a == 4 && b == 2 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int& arg_defaulted_to_closure_oXXet1v7(int& x)
{
    return (x *= 2);
}

static void woot_qg01zOoD(int& a, int& b)
{
    int& /*b|a*/ c = (a ? a : b);
    arg_defaulted_to_closure_oXXet1v7(c);
    arg_defaulted_to_closure_oXXet1v7(a);
    arg_defaulted_to_closure_oXXet1v7(b);
}

int fu_MAIN()
{
    int a = 1;
    int b = 1;
    woot_qg01zOoD(a, b);
    if ((a == 4) && (b == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit

-----

        fn test(ref a: i32, mut incr: i32) {
            fn woot(ref x, ref b = a) { // 'a' closes over here!
                if (x & 1) {
                    x /= 2;
                    return test(x, b);
                }
                return b += x;
            }

            return woot(incr);
        }

        fn main() {
            mut x = 10;
            return test(x, 5) == 12 ? 0 : 1;
        }

-----
static int test_QCeV7U2n(int&, int);

#ifndef fu_NO_fdefs

inline static int woot_5UMJCVLf(int& x, int& b)
{
    if (x & 1)
    {
        x /= 2;
        return test_QCeV7U2n(x, b);
    }
    else
        return (b += x);

}

static int test_QCeV7U2n(int& a, int incr)
{
    return woot_5UMJCVLf(incr, a);
}

int fu_MAIN()
{
    int x = 10;
    if (test_QCeV7U2n(x, 5) == 12)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedImplicit

-----

        fn test(ref a: i32, mut incr: i32) {
            fn woot(ref x, ref b = a) { // 'a' closes over here!
                if (x & 1) {
                    x /= 2;
                    return test(x, b);
                }
                return b += x;
            }

            return woot(incr, a);
        }

        fn main() {
            mut x = 10;
            return test(x, 5) == 12 ? 0 : 1;
        }

-----
static int test_QCeV7U2n(int&, int);

#ifndef fu_NO_fdefs

inline static int woot_5UMJCVLf(int& x, int& b)
{
    if (x & 1)
    {
        x /= 2;
        return test_QCeV7U2n(x, b);
    }
    else
        return (b += x);

}

static int test_QCeV7U2n(int& a, int incr)
{
    return woot_5UMJCVLf(incr, a);
}

int fu_MAIN()
{
    int x = 10;
    if (test_QCeV7U2n(x, 5) == 12)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_UnusedImplicit

-----

        struct Arg { name: string };
        fn main() {
            let arg = Arg(id: "hey");
            return arg.name.len - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:26+1[0m:

[2m      |         struct Arg { name: string };[0m
[2m      |         fn main() {[0m
[2m    4 | [0m            let arg = Arg[31;1m([0mid: "hey");
[2m      |             return arg.name.len - 3;[0m
[2m      |         }[0m

	Bad call to [34;1mArg[0m with args (string copy resize AlwaysTrue): 

	[35;1mtype[0m [34;1mArg[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Arg { name: string };

	    Explicit named argument mismatch: no arg [31;1mid[0m.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        struct Arg { name: string };
        fn main() {
            let arg = Arg(name: "hey");
            return arg.name.len - 3;
        }

-----
#include <fu/str.h>

struct s_Arg;

                                #ifndef DEF_s_Arg
                                #define DEF_s_Arg
struct s_Arg
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Arg arg = s_Arg { "hey"_fu };
    return arg.name.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);         // GNUStmtExpr
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int uses_implicit_6gX0LZBm(int& sum)
{
    return sum++;
}

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int /*sum*/ hello = sum;
        const int defaulted_argument = uses_implicit_6gX0LZBm(sum);
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

-----

#ifndef fu_NO_fdefs

int uses_implicit_6gX0LZBm(int& sum)
{
    return sum++;
}

#endif

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }
        pub import _0;
        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);         // GNUStmtExpr
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----
int uses_implicit_6gX0LZBm(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int /*sum*/ hello = sum;
        const int defaulted_argument = uses_implicit_6gX0LZBm(sum);
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

-----

#ifndef fu_NO_fdefs

int uses_implicit_6gX0LZBm(int& sum)
{
    return sum++;
}

#endif

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        pub import _0;
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);         // GNUStmtExpr
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----
int uses_implicit_6gX0LZBm(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int /*sum*/ hello = sum;
        const int defaulted_argument = uses_implicit_6gX0LZBm(sum);
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }

-----

#ifndef fu_NO_fdefs

int uses_implicit_6gX0LZBm(int& sum)
{
    return sum++;
}

#endif

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        pub import _0;
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }

-----

-----

        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        pub import _0;
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }
        pub import _1;
        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);         // GNUStmtExpr
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----
int uses_implicit_6gX0LZBm(int&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int /*sum*/ hello = sum;
        const int defaulted_argument = uses_implicit_6gX0LZBm(sum);
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;              // GNUStmtExpr
            return a == 4 && res == 12 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    int BL_1_v {};
    int _0 {};
    const int res = (_0 = (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };              // GNUStmtExpr
            return a == 4 && res == 9 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    int _0 {};
    int BL_1_v {};
    const int res = (_0 = a, (_0 * (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;
            return ooe_block_arg(:z, :a);
        }

        fn ooe_block_arg(ref z: i32, ref a: i32) {

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;              // GNUStmtExpr
            return a == 4 && res == 12 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

static int ooe_block_arg_Ejw0A1j4(int& z, int& a)
{
    int BL_1_v {};
    int _0 {};
    const int res = (_0 = (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    return ooe_block_arg_Ejw0A1j4(z, a);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            mut z = 0;
            mut a = 3;
            return ooe_block_arg(:z, :a);
        }

        fn ooe_block_arg(ref z: i32, ref a: i32) {

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };              // GNUStmtExpr
            return a == 4 && res == 9 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

static int ooe_block_arg_Ejw0A1j4(int& z, int& a)
{
    int _0 {};
    int BL_1_v {};
    const int res = (_0 = a, (_0 * (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int z = 0;
    int a = 3;
    return ooe_block_arg_Ejw0A1j4(z, a);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            return ooe_block_arg(z: 0, a: 3);
        }

        fn ooe_block_arg(mut z: i32, mut a: i32) {

                        // N_BckMustSeq

            let res = { ref x = z || a; x++ } * a;              // GNUStmtExpr
            return a == 4 && res == 12 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

static int ooe_block_arg_sLlauPKS(int z, int a)
{
    int BL_1_v {};
    int _0 {};
    const int res = (_0 = (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), (_0 * a));
    if ((a == 4) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return ooe_block_arg_sLlauPKS(0, 3);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {

            return ooe_block_arg(z: 0, a: 3);
        }

        fn ooe_block_arg(mut z: i32, mut a: i32) {

                        // N_BckMustSeq

            let res = a * { ref x = z || a; x++ };              // GNUStmtExpr
            return a == 4 && res == 9 ? 0 : 1;

        }

-----

#ifndef fu_NO_fdefs

static int ooe_block_arg_sLlauPKS(int z, int a)
{
    int _0 {};
    int BL_1_v {};
    const int res = (_0 = a, (_0 * (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v)));
    if ((a == 4) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return ooe_block_arg_sLlauPKS(0, 3);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello) {
                let res = hello * { ref x = z || a; x++ };      // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

inline static int ooe_closure_kjkohYPJ(int& hello, int& a, int& z)
{
    int _0 {};
    int BL_1_v {};
    const int res = (_0 = hello, (_0 * (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v)));
    hello += 10;
    return res;
}

static int test_297uVI80(int& a, int& z)
{
    const int res = ooe_closure_kjkohYPJ(a, a, z);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = hello * { ref x = z || a; x++ };      // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int ooe_closure_HKFPLdGE(int& hello, int& a, int& z)
{
    int _0 {};
    int BL_1_v {};
    const int res = (_0 = hello, (_0 * (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v)));
    hello += 10;
    return res;
}

static int test_297uVI80(int& a, int& z)
{
    const int res = ooe_closure_HKFPLdGE(a, a, z);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello) {
                let res = hello * { ref x = z || a; x++ };      // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int test_297uVI80(int& a, int& z)
{
    // Hoisted:
    int res_1;

    int _0 {};
    int BL_1_v {};
    const int /*res*/ res = (res_1 = (_0 = a, (_0 * (__extension__ (
    {
        int& /*z|a*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v))), (a += 10), res_1);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = hello * { ref x = z || a; x++ };      // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int test_297uVI80(int& a, int& z)
{
    // Hoisted:
    int res_1;

    int _0 {};
    int BL_1_v {};
    const int /*res*/ res = (res_1 = (_0 = a, (_0 * (__extension__ (
    {
        int& /*z|a*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v))), (a += 10), res_1);
    if ((a == 14) && (res == 9))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello) {
                let res = mul({ ref x = z || a; x++ }, hello);  // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int mul_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

inline static int ooe_closure_8p4Th1sz(int& hello, int& a, int& z)
{
    int BL_1_v {};
    int _0 {};
    const int res = (_0 = (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), mul_hwGp0ETu(_0, hello));
    hello += 10;
    return res;
}

static int test_297uVI80(int& a, int& z)
{
    const int res = ooe_closure_8p4Th1sz(a, a, z);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            noinline                                            // N_AARMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = mul({ ref x = z || a; x++ }, hello);  // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int mul_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

static int ooe_closure_7EH7A9l1(int& hello, int& a, int& z)
{
    int BL_1_v {};
    int _0 {};
    const int res = (_0 = (__extension__ (
    {
        int& /*a|z*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), mul_hwGp0ETu(_0, hello));
    hello += 10;
    return res;
}

static int test_297uVI80(int& a, int& z)
{
    const int res = ooe_closure_7EH7A9l1(a, a, z);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello) {
                let res = mul({ ref x = z || a; x++ }, hello);  // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int mul_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

static int test_297uVI80(int& a, int& z)
{
    // Hoisted:
    int res_1;

    int BL_1_v {};
    int _0 {};
    const int /*res*/ res = (res_1 = (_0 = (__extension__ (
    {
        int& /*z|a*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), mul_hwGp0ETu(_0, a)), (a += 10), res_1);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {

            inline                                              // N_BckMustSeq

            fn ooe_closure(ref hello: i32) {
                let res = mul({ ref x = z || a; x++ }, hello);  // GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }

-----

#ifndef fu_NO_fdefs

static int mul_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

static int test_297uVI80(int& a, int& z)
{
    // Hoisted:
    int res_1;

    int BL_1_v {};
    int _0 {};
    const int /*res*/ res = (res_1 = (_0 = (__extension__ (
    {
        int& /*z|a*/ x = (z ? z : a);
        BL_1_v = (x++);
    (void)0;}), BL_1_v), mul_hwGp0ETu(_0, a)), (a += 10), res_1);
    if ((a == 14) && (res == 12))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    int a = 3;
    int z = 0;
    return test_297uVI80(a, z);
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        inline fn uses_implicit_inside() {
            inline fn uses_implicit(implicit ref sum: i32) {
                return sum++;
            }

            return uses_implicit;
        }


        // N_BckMustSeq

        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int inline_implicit_from_defarg_fYHCO5cn(const int hello, const int defaulted_argument)
{
    return hello * defaulted_argument;
}

int fu_MAIN()
{
    int sum = 3;
    int _0 {};
    const int res = (_0 = sum, inline_implicit_from_defarg_fYHCO5cn(_0, sum++));
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_BckMustSeq

-----

        inline fn uses_implicit_inside() {
            inline fn uses_implicit(implicit ref sum: i32) {
                return sum++;
            }

            return uses_implicit;
        }


        inline                                                  // GNUStmtExpr

        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int /*sum*/ hello = sum;
        const int defaulted_argument = sum++;
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn uses_implicit(implicit ref sum: i32) = sum++;
        inline fn uses_implicit_inside() = uses_implicit;


        // N_BckMustSeq

        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)
            hello * defaulted_argument;

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(hello: sum);
            return sum == 4 && res == 12 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int inline_implicit_from_defarg_Zavn5aLy(const int defaulted_argument, const int hello)
{
    return hello * defaulted_argument;
}

int fu_MAIN()
{
    int sum = 3;
    int _0 {};
    const int res = (_0 = sum++, inline_implicit_from_defarg_Zavn5aLy(_0, sum));
    if ((sum == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_BckMustSeq

-----

        inline fn uses_implicit(implicit ref sum: i32) = sum++;
        inline fn uses_implicit_inside() = uses_implicit;


        inline                                                  // GNUStmtExpr

        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)
            hello * defaulted_argument;

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(hello: sum);
            return sum == 4 && res == 12 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 3;
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int defaulted_argument = sum++;
        const int /*sum*/ hello = sum;
        BL_1_v = ((hello * defaulted_argument));
    (void)0;}), BL_1_v);
    if ((sum == 4) && (res == 12))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            struct Type { canon: string };

            mut _lookups: int;
            mut _t_bool: Type;

            fn t_bool() {
                return _t_bool ||= Scope_lookupType("bool");
            }

            fn Scope_lookupType(canon: string) {
                _lookups++;
                return Type(:canon);
            }

            fn check(a, b = t_bool) {
                return a.canon.len + b.canon.len;
            }

            return check(t_bool) + _lookups - 9;
        }

-----
#include <fu/str.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type Scope_lookupType_gXhOB0bJ(const fu::str& canon, int& _lookups)
{
    _lookups++;
    return s_Type { fu::str(canon) };
}

static s_Type& t_bool_cBgsJZQs(int& _lookups, s_Type& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_gXhOB0bJ("bool"_fu, _lookups));
}

inline static int check_WAwhnP3q(const s_Type& a, const s_Type& b)
{
    return a.canon.size() + b.canon.size();
}

int fu_MAIN()
{
    int _lookups {};
    s_Type _t_bool {};
    s_Type _0 {};
    int _1 {};
    return (_1 = (_0 = s_Type(t_bool_cBgsJZQs(_lookups, _t_bool)), check_WAwhnP3q(static_cast<s_Type&&>(_0), t_bool_cBgsJZQs(_lookups, _t_bool))), (_1 + _lookups)) - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedImplicit, N_BckMustSeq

-----

        fn main() {
            struct Type { canon: string };

            mut _lookups: int;
            mut _t_bool: Type;

            fn t_bool() {
                return _t_bool ||= Scope_lookupType("bool");
            }

            fn Scope_lookupType(canon: string) {
                _lookups++;
                return Type(:canon);
            }

            fn check(a: Type, b = t_bool) {
                return a.canon.len + b.canon.len;
            }

            return check(t_bool) + _lookups - 9;
        }

-----
#include <fu/str.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type Scope_lookupType_gXhOB0bJ(const fu::str& canon, int& _lookups)
{
    _lookups++;
    return s_Type { fu::str(canon) };
}

static s_Type& t_bool_cBgsJZQs(int& _lookups, s_Type& _t_bool)
{
    return _t_bool ? _t_bool : (_t_bool = Scope_lookupType_gXhOB0bJ("bool"_fu, _lookups));
}

static int check_7oRxVliA(const s_Type& a, const s_Type& b)
{
    return a.canon.size() + b.canon.size();
}

int fu_MAIN()
{
    int _lookups {};
    s_Type _t_bool {};
    s_Type _0 {};
    int _1 {};
    return (_1 = (_0 = s_Type(t_bool_cBgsJZQs(_lookups, _t_bool)), check_7oRxVliA(static_cast<s_Type&&>(_0), t_bool_cBgsJZQs(_lookups, _t_bool))), (_1 + _lookups)) - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedImplicit, N_BckMustSeq

-----

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;
            woot(hello: |one| res += one);
            woot(world: |two| res += two);
            return res - 3;
        }

-----

#ifndef fu_NO_fdefs

inline static int& l_1_0_347rfI5l(const int one, int& res)
{
    return (res += one);
}

inline static void woot_ZtgI3b6I(int& res)
{
    l_1_0_347rfI5l(1, res);
}

inline static int& l_1_1_gOsXXHJr(const int two, int& res)
{
    return (res += two);
}

inline static void woot_8fqxnXyw(int& res)
{
    l_1_1_gOsXXHJr(2, res);
}

int fu_MAIN()
{
    int res = 0;
    woot_ZtgI3b6I(res);
    woot_8fqxnXyw(res);
    return res - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;

            woot(hello: |one| res += one, hello: |one| res += one); 
            return res - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:17+1[0m:

[2m      |             mut res = 0;[0m
[2m      | [0m
[2m   10 | [0m            woot[31;1m([0mhello: |one| res += one, hello: |one| res += one); 
[2m      |             return res - 3;[0m
[2m      |         }[0m

	Bad call to [34;1mwoot[0m with args (@130, @140): 

	[35;1mtemplate[0m [34;1mwoot[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mwoot[0m(hello!?, world!?) {

	    Duplicate explicitly named arguments: [31;1m2[0m args named [31;1mhello[0m.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;

            woot(hello: |one| res += one, world: |two| res += two); 
            return res - 3;
        }

-----

#ifndef fu_NO_fdefs

inline static int& l_1_0_EZ0ytt4B(const int one, int& res)
{
    return (res += one);
}

inline static int& l_1_1_9Ff4Tb9Q(const int two, int& res)
{
    return (res += two);
}

inline static void woot_wYm3KyBI(int& res)
{
    l_1_0_EZ0ytt4B(1, res);
    l_1_1_9Ff4Tb9Q(2, res);
}

int fu_MAIN()
{
    int res = 0;
    woot_wYm3KyBI(res);
    return res - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        let s = 7;
        return s ? 0 : 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let s = 0;
        return s ? 1 : 0;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let s = "hello";
        return s ? 0 : 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let s = "";
        return s ? 1 : 0;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let s = [ 4 ];
        return s ? 0 : 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedArrlit, N_UnusedLet

-----

        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> s = fu::vec<int> { fu::slate<1, int> { 4 } };
    s.pop();
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;

-----
struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_S s = s_S { 1 };
    if (s)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;

-----
struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_S s {};
    if (s)
        return 1;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 0;
        :OUTER for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    // Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int y = 1; y < 10; y++)
    { {
        sum += (y * 10);
        for (int x = 1; x < 10; x++)
        {
            sum += x;
            if (y == 1)
                goto BL_2;
            else if (x == 2)
                goto LL_1;

        };
      } BL_2:;
    } LL_1:;

    return sum - 34;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn for_fn(mut i: i32, n: i32, visit)
            for (; i < n; i++)
                visit(i);

        mut sum = 0;
        :OUTER for_fn(1, 10): |y| // same as above but via helper fn
        {
            sum += y * 10; // 10, 20
            for_fn(1, 10): |x|
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    // Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;

    { {
        int i = 1;
        const int n = 10;
        for (; i < n; i++)
        { {
            sum += (i * 10);
            int i_1 = 1;
            const int n_1 = 10;
            for (; i_1 < n_1; i_1++)
            {
                sum += i_1;
                if (i == 1)
                    goto BL_3;
                else if (i_1 == 2)
                    goto BL_1;

            };
          } BL_3:;
        };
      } BL_1:;
    };
    return sum - 34;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn twice(what)
            for (mut i = 0; i < 2; i++)
                what(i);

        mut x = 0;
        :TWICE twice: |i| {
            x += i;
            if (!x++) continue :TWICE;
        }

        return x - 3;

-----

#ifndef fu_NO_fdefs

inline static void l_1_0_OCnHhNNl(const int i, int& x)
{
    x += i;
    x++;
}

inline static void twice_8sxh8x42(int& x)
{
    for (int i = 0; i < 2; i++)
        l_1_0_OCnHhNNl(i, x);

}

int fu_MAIN()
{
    int x = 0;
    twice_8sxh8x42(x);
    return x - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedIfElse

-----

        fn twice(what)
            for (mut i = 0; i < 2; i++)
                what(i);

        mut x = 0;
        :TWICE twice: |i: int| {
            x += i;
            if (!x++) continue :TWICE;
        }

        return x - 3;

-----

#ifndef fu_NO_fdefs

static void l_1_0_Npkmth2H(const int i, int& x)
{
    x += i;
    x++;
}

inline static void twice_ET2Zwun6(int& x)
{
    for (int i = 0; i < 2; i++)
        l_1_0_Npkmth2H(i, x);

}

int fu_MAIN()
{
    int x = 0;
    twice_ET2Zwun6(x);
    return x - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedIfElse

-----

        mut sum = 0;
        :OUTER for (mut x = 0;; x++) {
            for (mut y = 0; y < x; y++) {
                if (y & 1 && !(x & 1))
                    continue :OUTER;                            // Goto

                sum += x;
            }

            sum += x * 1000 + 100;
            if (x > 1) // EXPECT break;
                break; // anon
        }

        // x=0:           + 0100
        // x=1: 1         + 1100
        // x=2: 2
        // x=3: 3 + 3 + 3 + 3100 break
        return sum - 4312;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;
    for (int x = 0; ; x++)
    { {
        for (int y = 0; y < x; y++)
        {
            if ((y & 1) && !(x & 1))
                goto BL_2;
            else
                sum += x;

        };
        sum += ((x * 1000) + 100);
        if (x > 1)
            break;

      } BL_2:;
    };
    return sum - 4312;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(ref sum: i32) {
            :FIRST {
                if (sum & 1)
                    break:
                        FIRST;
                sum++;
            }
            :SECOND {
                if (sum & 1)
                    break:

                        FIRST;      
                sum++;

                if (sum & 2)
                    break:
                        SECOND;
                sum++;
            }
        }

        fn main() {
            mut sum = 0;
            test(sum);
            return sum - 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:21+5[0m:

[2m      |             :SECOND {[0m
[2m      |                 if (sum & 1)[0m
[2m   11 | [0m                    [31;1mbreak[0m:
[2m      | [0m
[2m      |                         FIRST;      [0m

	No label `FIRST` in scope.

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m2:12+4[0m

-----

        fn test(ref sum: i32) {
            :FIRST {
                if (sum & 1)
                    break:
                        FIRST;
                sum++;
            }
            :SECOND {
                if (sum & 1)
                    break:

                        SECOND;     
                sum++;

                if (sum & 2)
                    break:
                        SECOND;
                sum++;
            }
        }

        fn main() {
            mut sum = 0;
            test(sum);
            return sum - 1;
        }

-----

#ifndef fu_NO_fdefs

static void test_6gX0LZBm(int& sum)
{
    if (!(sum & 1))
        sum++;

    if (!(sum & 1))
    {
        sum++;
        if (!(sum & 2))
            sum++;

    };
}

int fu_MAIN()
{
    int sum = 0;
    test_6gX0LZBm(sum);
    return sum - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        let x = "hello";
        lax let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str x = "hello"_fu;
    if (x == "hello"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str y = "world"_fu;
    fu::view<char> /*y*/ w = y;
    if (w == "world"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let x = "hello";
        lax let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str x = "hello"_fu;
    fu::view<char> /*x*/ w = x;
    if (w == "hello"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y;

        return w == "world" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str x = "hello"_fu;
    fu::str y = "world"_fu;
    fu::vec<int> arr {};
    fu::view<char> _0 {};
    fu::view<char> /*y|x|static*/ w = ((_0 = (arr ? x : fu::view<char>{})) ? static_cast<fu::view<char>&&>(_0) : y);
    if (w == "world"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str x = "hello"_fu;
    fu::str y = "world"_fu;
    fu::vec<int> arr {};
    fu::view<char> _0 {};
    fu::view<char> /*y|x|static*/ w = ((_0 = (arr ? x : fu::view<char>{})) ? static_cast<fu::view<char>&&>(_0) : y);
    if (w == "world"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn what(a: i32) {
            a == 2 || a & 1 || throw("what1");
            a  > 1 && a & 1 && throw("what2");
            a  > 0 && a & 3 || throw("what3");
            return a + 4;
        }
        fn main() 1.what - 2.what + 1;

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int what_rgx2eiBu(const int a)
{
    if ((a == 2) || (a & 1))
    {
        if ((a > 1) && (a & 1))
            fu::fail("what2"_fu);
        else if ((a > 0) && (a & 3))
            return a + 4;
        else
            fu::fail("what3"_fu);

    }
    else
        fu::fail("what1"_fu);

}

int fu_MAIN()
{
    return (what_rgx2eiBu(1) - what_rgx2eiBu(2)) + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn gen(len: i32) {
            mut res: i32[];
            for (mut i = 0; i < len; i++) res ~= i;
            return res;
        }
        fn test(len: i32) {
            let x = [-5, +5];
            let y = len.gen && x;
            return x[y.len / 2];
        }
        fn main() 0.test + 1.test;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::vec<int> gen_FSBKx7dC(const int len)
{
    /*MOV*/ fu::vec<int> res {};
    for (int i = 0; i < len; i++)
        res += i;

    return /*NRVO*/ res;
}

static int test_FSBKx7dC(const int len)
{
    fu::vec<int> x = fu::vec<int> { fu::slate<2, int> { -5, +5 } };
    fu::view<int> /*x|static*/ y = (gen_FSBKx7dC(len) ? x : fu::view<int>{});
    return x[(y.size() / 2)];
}

int fu_MAIN()
{
    return test_FSBKx7dC(0) + test_FSBKx7dC(1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;

        fn test(ref init: string, ref annot: string)
            init.is_mutref && annot ||
            init.is_never  && annot || throw("noreturn");

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot).len - 4;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static bool is_mutref_wXYhzr6X(fu::view<char> t)
{
    return t.size() == 6;
}

static bool is_never_wXYhzr6X(fu::view<char> t)
{
    return t.size() == 5;
}

static const fu::str& test_klFHbzhU(fu::view<char> init, const fu::str& annot)
{
    const fu::str* _0;
    return *(_0 = &((is_mutref_wXYhzr6X(init) ? annot : (*(const fu::str*)fu::NIL)))) ? *_0 : *(_0 = &((is_never_wXYhzr6X(init) ? annot : (*(const fu::str*)fu::NIL)))) ? *_0 : fu::fail("noreturn"_fu);
}

int fu_MAIN()
{
    fu::str annot = "hey!"_fu;
    fu::str init = "woot!"_fu;
    return test_klFHbzhU(init, annot).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(mut init: string) {
            init.len && init || throw("noreturn");
            return init.len;
        }

        fn main() test("woot!") - 5;

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_BCNf2Lz4(fu::str&& init)
{
    if (init.size() && init)
        return init.size();
    else
        fu::fail("noreturn"_fu);

}

int fu_MAIN()
{
    return test_BCNf2Lz4("woot!"_fu) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;
        let F_ARG = 1;

        fn test(ref init: string, ref annot: string, mut flags: i32) {
            init.is_mutref  || init.is_never  && annot
                            || !init && flags & F_ARG
                            || throw("noreturn");
            return flags;
        }

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot, 0);
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static bool is_mutref_wXYhzr6X(fu::view<char> t)
{
    return t.size() == 6;
}

static bool is_never_wXYhzr6X(fu::view<char> t)
{
    return t.size() == 5;
}

                                #ifndef DEF_F_ARG
                                #define DEF_F_ARG
inline constexpr int F_ARG = 1;
                                #endif

static int test_CviYR6rh(fu::view<char> init, fu::view<char> annot, const int flags)
{
    if (is_mutref_wXYhzr6X(init) || (is_never_wXYhzr6X(init) && annot) || (!init && (flags & F_ARG)))
        return flags;
    else
        fu::fail("noreturn"_fu);

}

int fu_MAIN()
{
    fu::str annot = "hey!"_fu;
    fu::str init = "woot!"_fu;
    return test_CviYR6rh(init, annot, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn a(a)  a ?  a : [];   // ifs used cons-type to seed alt-type
        fn b(b) !b ? [] : b;    //  which works for 'a', but not for 'b'.
        fn main() 1.a - 1.b;

-----

#ifndef fu_NO_fdefs

inline static int a_rgx2eiBu(const int a)
{
    if (a)
        return a;
    else
    {
        return int{};
    };
}

inline static int b_urWHdJ0x(const int b)
{
    if (!b)
    {
        return int{};
    }
    else
        return b;

}

int fu_MAIN()
{
    return a_rgx2eiBu(1) - b_urWHdJ0x(1);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Type { i: i32 };
        fn is_mutref (t: Type) !!(t.i & 3);
        fn is_ref    (t: Type) !!(t.i & 1);
        fn clear_refs(t: Type) Type(t.i &~ 3);

        fn tryClearRefs(t: Type, mutref?: bool): Type =     // type-hints vs type-assertions:
            (mutref ? t.is_mutref : t.is_ref)               //  solveBlocks used within '&&' and '?'
                && clear_refs(t);                           //   so the '?' complained 'bool' doesnt assign to 'Type'

        fn main() {
            let a = tryClearRefs(Type(6), true);
            let b = tryClearRefs(Type(6), false);
            return a.i + b.i - 4;
        }

-----
struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool is_mutref_4vx5myXl(const s_Type& t)
{
    return !!(t.i & 3);
}

static bool is_ref_4vx5myXl(const s_Type& t)
{
    return !!(t.i & 1);
}

static s_Type clear_refs_4vx5myXl(const s_Type& t)
{
    return s_Type { (t.i & ~3) };
}

static s_Type tryClearRefs_YoJMSH1u(const s_Type& t, const bool mutref)
{
    if ((mutref ? is_mutref_4vx5myXl(t) : is_ref_4vx5myXl(t)))
        return clear_refs_4vx5myXl(t);
    else
    {
        return s_Type{};
    };
}

int fu_MAIN()
{
    const s_Type a = tryClearRefs_YoJMSH1u(s_Type { 6 }, true);
    const s_Type b = tryClearRefs_YoJMSH1u(s_Type { 6 }, false);
    return (a.i + b.i) - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ambig_or(x: i32, y: f32)
            "Hello: " ~
       // So it happened that at some point I had an 'a || b'
                    (x || y)                         //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.

        fn main() {
            mut res = ambig_or(1, 2);
            return res == "Hello: 1" ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:24+2[0m:

[2m      |             "Hello: " ~[0m
[2m      |        // So it happened that at some point I had an 'a || b'[0m
[2m    5 | [0m                    (x [31;1m||[0m y)                         //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
[2m      |                 ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.[0m
[2m      | [0m

	Ambiguous ||, incompatible operands in a non-bool context: i32 copy || f32 copy

        Solving [35;1mfn[0m [34;1mambig_or[0m(i32, f32) at [2m2:12+8[0m

-----

        fn ambig_or(x: i32, y: f32)
            "Hello: " ~
       //  where a and b were of the same type used in string concat like this,
                    (x || y.i32)                     //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.

        fn main() {
            mut res = ambig_or(1, 2);
            return res == "Hello: 1" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str ambig_or_MuEjcBdq(const int x, const float y)
{
    return x7E_gCeFmDFw("Hello: "_fu, fu::i64dec((x ? x : int(y))));
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = ambig_or_MuEjcBdq(1, 2.0f);
    if (res == "Hello: 1"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn unambig_or(b: bool, i: i32, f: f32)        // But currently the thinking is that so long as one operand is a bool
            i || f || b;                              //  the whole thing should weaken to (!!a || !!b) instead of erroring out.

        fn main() = unambig_or(false, 0, 0).i32;

-----

#ifndef fu_NO_fdefs

static bool unambig_or_nW5lSW1s(const bool b, const int i, const float f)
{
    return i || f || b;
}

int fu_MAIN()
{
    return int(unambig_or_nW5lSW1s(false, 0, 0.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn unambig_or(b: bool, i: i32, f: f32)  
            b || i || f;                              //  the whole thing should weaken to (!!a || !!b) instead of erroring out.

        fn main() = unambig_or(false, 0, 0).i32;

-----

#ifndef fu_NO_fdefs

static bool unambig_or_nW5lSW1s(const bool b, const int i, const float f)
{
    return b || i || f;
}

int fu_MAIN()
{
    return int(unambig_or_nW5lSW1s(false, 0, 0.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node { items: Node[] };

        fn isFieldChain(arg: Node) {
            if (arg.items.len > 1)
                return false;

            return !arg.items || isFieldChain(arg.items[0]);
        }

        fn main() {
            let empty       = Node();
            let chain       = Node([ Node ]);
            let not_chain   = Node([ Node, Node ]);

            return empty.isFieldChain
                && chain.isFieldChain
                && !not_chain.isFieldChain ? 0 : 1;
        }

-----
#include <fu/vec.h>

struct s_Node;
static bool isFieldChain_cDDflnRw(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool isFieldChain_cDDflnRw(const s_Node& arg)
{
    if (arg.items.size() > 1)
        return false;
    else
        return !arg.items || isFieldChain_cDDflnRw(arg.items[0]);

}

int fu_MAIN()
{
    s_Node empty = s_Node{};
    s_Node chain = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } };
    s_Node not_chain = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } };
    if (isFieldChain_cDDflnRw(empty) && isFieldChain_cDDflnRw(chain) && !isFieldChain_cDDflnRw(not_chain))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        fn underconcat(dedupe: string, sighash: string)
            dedupe && sighash
                ? dedupe ~ '_' ~ sighash
                : dedupe || sighash;

        fn main() {
            let a   = underconcat("a", "");
            let b   = underconcat("", "b");
            let c   = underconcat("", "");
            let ab  = underconcat("a", "b");

            let res = a ~ "," ~ b ~ "," ~ c ~ "," ~ ab;
            return res == "a,b,,a_b" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str underconcat_dCj8GcDI(const fu::str& dedupe, const fu::str& sighash)
{
    if (dedupe && sighash)
        return (dedupe + '_') + sighash;
    else
        return fu::str((dedupe ? dedupe : sighash));

}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str a = underconcat_dCj8GcDI("a"_fu, ""_fu);
    fu::str b = underconcat_dCj8GcDI(""_fu, "b"_fu);
    fu::str c = underconcat_dCj8GcDI(""_fu, ""_fu);
    fu::str ab = underconcat_dCj8GcDI("a"_fu, "b"_fu);
    fu::str res = ((((((a + ","_fu) + b) + ","_fu) + c) + ","_fu) + ab);
    if (res == "a,b,,a_b"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----


        inline    // GNUStmtExpr
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> BL_1_v {};
    if ((__extension__ (
    {
        const int x = 2;
        BL_1_v = (fu::vec<int> { fu::slate<2, int> { x, x } });
    (void)0;}), static_cast<fu::vec<int>&&>(BL_1_v)) && !fu::vec<int>{})
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----


        noinline                
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

inline static fu::vec<int> twiceUnlessEmpty_1WsbUdat(const int x)
{
    if (x)
    {
        return fu::vec<int> { fu::slate<2, int> { x, x } };
    }
    else
    {
        return fu::vec<int>{};
    };
}

int fu_MAIN()
{
    if (twiceUnlessEmpty_1WsbUdat(2) && !twiceUnlessEmpty_1WsbUdat(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(ref str) {
            str ~= "world";
  
        }

        fn main() {
            mut str = "hello, ";
            if (!hello(str)) str ~= "!";
            return str.len - 13;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:17+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut str = "hello, ";[0m
[2m    9 | [0m            if ([31;1m![0mhello(str)) str ~= "!";
[2m      |             return str.len - 13;[0m
[2m      |         }[0m

	Condition is void, returned from [35;1mfn[0m [34;1mhello[0m at [2m2:12+5[0m:

[2m      | [0m
[2m    2 | [0m        fn [31;1mhello[0m(ref str) {
[2m      |             str ~= "world";[0m
[2m      |   [0m


        Solving [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        fn hello(ref str) {
            str ~= "world";

            return str.len & 1;                     
        }

        fn main() {
            mut str = "hello, ";
            if (!hello(str)) str ~= "!";
            return str.len - 13;
        }

-----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

inline static int hello_RLhriYuE(fu::str& str)
{
    str += "world"_fu;
    return str.size() & 1;
}

int fu_MAIN()
{
    fu::str str = "hello, "_fu;
    if (!hello_RLhriYuE(str))
        str += "!"_fu;

    return str.size() - 13;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {

            if (x > 1) let y = 20;      

            return x + y;
        }

        fn main() test(7) - 27;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:24+1[0m:

[2m      |             if (x > 1) let y = 20;      [0m
[2m      | [0m
[2m    6 | [0m            return x + [31;1my[0m;
[2m      |         }[0m
[2m      | [0m

	Bad call to [34;1my[0m: [34;1my[0m is not defined here.

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m2:12+4[0m

-----

        fn test(x: i32) {

            let y = x > 1 && 20;        

            return x + y;
        }

        fn main() test(7) - 27;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    const int y = ((x > 1) ? 20 : 0);
    return x + y;
}

int fu_MAIN()
{
    return test_1WsbUdat(7) - 27;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {

            if (x > 1)
            let y = 20;                 

            return x + y;
        }

        fn main() test(7) - 27;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:13+3[0m:

[2m      | [0m
[2m      |             if (x > 1)[0m
[2m    5 | [0m            [31;1mlet[0m y = 20;                 
[2m      | [0m
[2m      |             return x + y;[0m

	Misleading indent at `let`: expected more than 13, got 13.

-----

        fn test(x: i32) {

            let y = x > 1 && 20;        

            return x + y;
        }

        fn main() test(7) - 27;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    const int y = ((x > 1) ? 20 : 0);
    return x + y;
}

int fu_MAIN()
{
    return test_1WsbUdat(7) - 27;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut i = 7;
        i ||= 11;
        return i - 7;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 7;
    if (!(i))
        i = 11;

    return i - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut i = 0;
        i ||= 11;
        return i - 11;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int i = 0;
    if (!(i))
        i = 11;

    return i - 11;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut a = 1;
        mut b = 0;
        a ||= ++b;
        return  b;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    if (!(a))
        a = ++b;

    return b;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut CHANGE = false;
        CHANGE ||= true;
        return CHANGE.i32 - 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    bool CHANGE = false;
    if (!(CHANGE))
        CHANGE = true;

    return int(CHANGE) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn and_incr(ref x: i32, v: i32)
            x &&= x + v;

        fn main() {
            mut x: i32 = 0;
            and_incr(x, 10);
            return x;
        }

-----

#ifndef fu_NO_fdefs

static int& and_incr_k4voilsX(int& x, const int v)
{
    return !x ? x : (x = (x + v));
}

int fu_MAIN()
{
    int x = 0;
    and_incr_k4voilsX(x, 10);
    return x;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();

        t.test;             
        return t.x - 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:9+6[0m:

[2m      | [0m
[2m      |         t.test;             [0m
[2m   10 | [0m        [31;1mreturn[0m t.x - 1;
[2m      | [0m
[2m      | }[0m

	Orphan pure-looking expression.

-----

        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();

        t.test();           
        return t.x - 1;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_giKJ96Uf(s_Test& t)
{
    return t.x++;
}

int fu_MAIN()
{
    s_Test t = s_Test{};
    test_giKJ96Uf(t);
    return t.x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        {
            {
                return 0;
            }
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        {

        {
            return 0;
        }

        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:9+1[0m:

[2m      |         {[0m
[2m      | [0m
[2m    7 | [0m        [31;1m{[0m
[2m      |             return 0;[0m
[2m      |         }[0m

	Inconsistent indent at `{`: expected more than 9, got 9. Block starts on line 5.

-----

        {

            {
                return 0;
            }

        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        {
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        {
            return 0;

       }


-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:1+1[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m[31;1m}[0m
[2m      | [0m

	Inconsistent indent at closing `}`: expected 8, got 7. Block starts on line 5.

-----

        {
            return 0;

        }


-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        {
            return 0;

         }


-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:1+1[0m:

[2m      | [0m
[2m      | [0m
[2m   11 | [0m[31;1m}[0m
[2m      | [0m

	Inconsistent indent at closing `}`: expected 8, got 9. Block starts on line 5.

-----

        {
            return 0;

        }


-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        let y = [ 1 ];              ;; TODO fu::slate<1, int> y
        let 
            z = [ 2 ];              ;; TODO fu::slate<1, int> z

        return y[0] - 1

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:13+1[0m:

[2m      |         let y = [ 1 ];              // TODO fu::slate<1, int> y[0m
[2m      |         let [0m
[2m    7 | [0m            [31;1mz[0m = [ 2 ];              // TODO fu::slate<1, int> z
[2m      | [0m
[2m      |         return y[0] - 1[0m

	Unused variable: [35;1mvar[0m [34;1mz[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        let y = [ 1 ];              // TODO fu::slate<1, int> y
        let lax
            z = [ 2 ];              // TODO fu::slate<1, int> z

        return y[0] - 1

-----
;; TODO fu::slate<1, int> y
;; TODO fu::slate<1, int> z

#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> y = fu::vec<int> { fu::slate<1, int> { 1 } };
    return y[0] - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedArrlit, N_UnusedLet

-----

        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,

            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:13+1[0m:

[2m      |         fn hello(a: string,[0m
[2m      | [0m
[2m    5 | [0m            [31;1mb[0m: string)
[2m      |                 a && fail(a) ? b : a;[0m
[2m      | [0m

	Unused variable: [35;1marg[0m [34;1mb[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1mhello[0m(string, string) at [2m3:12+5[0m

-----

        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,
lax
            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never fail_INJ0JhEX(fu::view<char> a)
{
    fu::fail(("hey: "_fu + a));
}

static const fu::str& hello_pRs8PWrV(const fu::str& a)
{
    if (a)
        fail_INJ0JhEX(a);
    else
        return a;

}

int fu_MAIN()
{
    return hello_pRs8PWrV(""_fu).size();
}

#endif

int main() { return fu_MAIN(); }

-----

        fn incr(ref x: i32) x++;
        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {
            return a.incr

            +

                b.incr;
        }

        fn main() {
            mut a = 0; mut b = 0;
            lints_ambig_expr_indent(a, b);
            return a - b;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:23+1[0m:

[2m      |             +[0m
[2m      | [0m
[2m    8 | [0m                b.incr[31;1m;[0m
[2m      |         }[0m
[2m      | [0m

	Ambiguous indent at `+`: expected more than 13, got 13

-----

        fn incr(ref x: i32) x++;
        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {
            return a.incr

              +

                b.incr;
        }

        fn main() {
            mut a = 0; mut b = 0;
            lints_ambig_expr_indent(a, b);
            return a - b;
        }

-----

#ifndef fu_NO_fdefs

static int incr_3JeKX2Qj(int& x)
{
    return x++;
}

static int lints_ambig_expr_indent_qg01zOoD(int& a, int& b)
{
    int _0 {};
    return (_0 = incr_3JeKX2Qj(a), (_0 + incr_3JeKX2Qj(b)));
}

int fu_MAIN()
{
    int a = 0;
    int b = 0;
    lints_ambig_expr_indent_qg01zOoD(a, b);
    return a - b;
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

-----

        fn lints_ambig_jump_semis(mut x: i32) {

            return
            x;

        }

        fn main() 0.lints_ambig_jump_semis;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:13+1[0m:

[2m      | [0m
[2m      |             return[0m
[2m    5 | [0m            [31;1mx[0m;
[2m      | [0m
[2m      |         }[0m

	Ambiguous indent at `x`: expected more than 13, got 13

-----

        fn lints_ambig_jump_semis(mut x: i32) {

            return x;

        }

        fn main() 0.lints_ambig_jump_semis;

-----

#ifndef fu_NO_fdefs

static int lints_ambig_jump_semis_1WsbUdat(const int x)
{
    return x;
}

int fu_MAIN()
{
    return lints_ambig_jump_semis_1WsbUdat(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || 
                              a = A(incr(a));     //  this was an honest mistake.

        fn main() { mut v = 0; return A(v) - 1; }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:45+1[0m:

[2m      |         fn incr(ref a: i32) ++a;[0m
[2m      |         fn A(ref a: i32) a || [0m
[2m    4 | [0m                              a = A(incr(a))[31;1m;[0m     //  this was an honest mistake.
[2m      | [0m
[2m      |         fn main() { mut v = 0; return A(v) - 1; }[0m

	Unparenthesized `or` on the left side of an `=`.

-----

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a ||  // Lint should complain here,
                             (a = A(incr(a)));    //  this was an honest mistake.

        fn main() { mut v = 0; return A(v) - 1; }

-----
static int& A_wQ3JO5Ij(int&);

#ifndef fu_NO_fdefs

static int& incr_wQ3JO5Ij(int& a)
{
    return ++a;
}

static int& A_wQ3JO5Ij(int& a)
{
    return a ? a : (a = A_wQ3JO5Ij(incr_wQ3JO5Ij(a)));
}

int fu_MAIN()
{
    int v = 0;
    return A_wQ3JO5Ij(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn test(is_mutref: bool, args: i32[], ref sum: i32) {

            if (is_mutref)
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];

            else
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 2)
                        sum += args[i];
        }

        fn main() {
            mut sum = 0;
            test(true , [ 1,  2,  3  ], sum);
            test(false, [ 11, 22, 33 ], sum);
            return sum - 1 - 3 - 11 - 22;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:17+3[0m:

[2m      | [0m
[2m      |             else[0m
[2m   10 | [0m                [31;1mfor[0m (mut i = 0; i < args.len; i++)
[2m      |                     if (args[i] & 2)[0m
[2m      |                         sum += args[i];[0m

	Inconsistent indent at `else`: expected 21, got 13. `if` starts on line 6.

-----

        fn test(is_mutref: bool, args: i32[], ref sum: i32) {

            if (is_mutref) {
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];
            }

            else
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 2)
                        sum += args[i];
        }

        fn main() {
            mut sum = 0;
            test(true , [ 1,  2,  3  ], sum);
            test(false, [ 11, 22, 33 ], sum);
            return sum - 1 - 3 - 11 - 22;
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_Y2dNte5o(const bool is_mutref, fu::view<int> args, int& sum)
{
    if (is_mutref)
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (args[i] & 1)
                sum += args[i];

        };
    }
    else
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (args[i] & 2)
                sum += args[i];

        };
    };
}

int fu_MAIN()
{
    int sum = 0;
    test_Y2dNte5o(true, (fu::slate<3, int> { 1, 2, 3 }), sum);
    test_Y2dNte5o(false, (fu::slate<3, int> { 11, 22, 33 }), sum);
    return (((sum - 1) - 3) - 11) - 22;
}

#endif

int main() { return fu_MAIN(); }

-----

        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()   
            -1.0    
                .abs;

        fn main() test ? 0 : 7;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 22:18+3[0m:

[2m      |         fn test()   [0m
[2m      |             -1.0    [0m
[2m   22 | [0m                .[31;1mabs[0m;
[2m      | [0m
[2m      |         fn main() test ? 0 : 7;[0m

	Here the unary -/+ separates from the numeric literal, and wraps around the whole expression. Please parenthesize explicitly to make this obvious.

-----

        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()   
            (-1.0)  
                .abs;

        fn main() test ? 0 : 7;

-----
#include <cmath>


#ifndef fu_NO_fdefs

static double test_H9fhQUVP()
{
    return std::fabs(-1.0);
}

int fu_MAIN()
{
    if (test_H9fhQUVP())
        return 0;
    else
        return 7;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn id(x) = x;
        fn main() {
            return id(
                0 +

               0  
            );
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:16+1[0m:

[2m      |                 0 +[0m
[2m      | [0m
[2m    7 | [0m               [31;1m0[0m  
[2m      |             );[0m
[2m      |         }[0m

	Ambiguous indent at `0`: expected more than 17, got 16

-----

        fn id(x) = x;
        fn main() {
            return id(
                0 +

                0 
            );
        }

-----

#ifndef fu_NO_fdefs

inline static int id_1WsbUdat(const int x)
{
    return x;
}

int fu_MAIN()
{
    return id_1WsbUdat((0 + 0));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |
                    _?|
                {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |
                    _?| {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |_?|
                {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(

                stuff: |_?| {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedLet

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {

            doStuff(stuff: ||
                {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn doStuff(stuff) {
            stuff();
        }

        fn main() {

            doStuff(stuff: || {

                    return 0;
                });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        noinline fn test(ref a: i32, ref b: i32) {
            return (++a) + 10 * (++b);                          // N_AARMustSeq
        }

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            ref y = x;
            let z = test(x, y);

            return x == 2 && z == 21 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_qg01zOoD(int& a, int& b)
{
    int _0 {};
    return (_0 = ++a, (_0 + (10 * ++b)));
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_qg01zOoD(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        noinline fn test(ref a: i32, ref b: i32) {
            return (++a) + 10 * (++b);                          // N_AARMustSeq
        }

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            let z = test(x, x);

            return x == 2 && z == 21 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_qg01zOoD(int& a, int& b)
{
    int _0 {};
    return (_0 = ++a, (_0 + (10 * ++b)));
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_qg01zOoD(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        noinline fn test_inner(ref a: i32, ref b: i32)
            (++a) + 10 * (++b);                                 // N_AARMustSeq

        noinline fn test_outer(ref a: i32, ref b: i32)
            test_inner(a, b);

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            ref y = x;
            let z = test_outer(x, y);

            return x == 2 && z == 21 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_inner_qg01zOoD(int& a, int& b)
{
    int _0 {};
    return (_0 = ++a, (_0 + (10 * ++b)));
}

static int test_outer_qg01zOoD(int& a, int& b)
{
    return test_inner_qg01zOoD(a, b);
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_outer_qg01zOoD(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        noinline fn test_inner(ref a: i32, ref b: i32)
            (++a) + 10 * (++b);                                 // N_AARMustSeq

        noinline fn test_outer(ref a: i32, ref b: i32)
            test_inner(a, b);

        fn main() {                                             // N_AARSoftRisk
            mut x = 0;

            let z = test_outer(x, x);

            return x == 2 && z == 21 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_inner_qg01zOoD(int& a, int& b)
{
    int _0 {};
    return (_0 = ++a, (_0 + (10 * ++b)));
}

static int test_outer_qg01zOoD(int& a, int& b)
{
    return test_inner_qg01zOoD(a, b);
}

int fu_MAIN()
{
    int x = 0;
    const int z = test_outer_qg01zOoD(x, x);
    if ((x == 2) && (z == 21))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq, N_AARSoftRisk

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) {

                a ~= 1; // Invalidates 'b'.

            }
            b++;
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:13+1[0m:

[2m      | [0m
[2m      |             }[0m
[2m    9 | [0m            [31;1mb[0m++;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mb[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m6:19+2[0m:

[2m      |             if (a.len & 1) {[0m
[2m      | [0m
[2m    6 | [0m                a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      | [0m
[2m      |             }[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) {

                b++;

            }
            b++;
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_bJzechqP(fu::view_mut<int> a)
{
    int& /*a|static*/ b = a.mutref(0);
    if (a.size() & 1)
        b++;

    b++;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_bJzechqP(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        nocopy struct nci32 { i: i32; };

        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;
        fn main() {
            mut x = nci32(0);

            ref y = x;                        

            return test(x, y);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:28+1[0m:

[2m      |             ref y = x;                        [0m
[2m      | [0m
[2m   10 | [0m            return test(x, [31;1my[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mtest[0m, arguments:

	    2:	[35;1marg[0m [34;1mtest[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1mtest[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mx[0m at [2m6:17+1[0m:

[2m      |         noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;[0m
[2m      |         fn main() {[0m
[2m    6 | [0m            mut [31;1mx[0m = nci32(0);
[2m      | [0m
[2m      |             ref y = x;                        [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1marg[0m [34;1mtest[0m:[34;1mb[0m is non-copyable: nci32

	    [35;1mref arg[0m [34;1mtest[0m:[34;1ma[0m is non-copyable: nci32 mutref

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        nocopy struct nci32 { i: i32; };

        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;
        fn main() {
            mut x = nci32(0);

            let y = nci32(0);                 

            return test(x, y);
        }

-----
struct s_nci32;

                                #ifndef DEF_s_nci32
                                #define DEF_s_nci32
struct s_nci32
{
    int i;
    s_nci32(const s_nci32&) = delete;
    s_nci32(s_nci32&&) = default;
    s_nci32& operator=(const s_nci32&) = delete;
    s_nci32& operator=(s_nci32&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_YWSAktXM(s_nci32& a, const s_nci32& b)
{
    int _0 {};
    return (_0 = a.i++) ? _0 : b.i;
}

int fu_MAIN()
{
    s_nci32 x = s_nci32 { 0 };
    s_nci32 y = s_nci32 { 0 };
    return test_YWSAktXM(x, y);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) { // Lets be extra sure here.

                a ~= 1; // Invalidates 'b'.
                b++;

            }
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:17+1[0m:

[2m      | [0m
[2m      |                 a ~= 1; // Invalidates 'b'.[0m
[2m    7 | [0m                [31;1mb[0m++;
[2m      | [0m
[2m      |             }[0m

	Cannot access [35;1mref[0m [34;1mb[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m6:19+2[0m:

[2m      |             if (a.len & 1) { // Lets be extra sure here.[0m
[2m      | [0m
[2m    6 | [0m                a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      |                 b++;[0m
[2m      | [0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) { // Lets be extra sure here.

                b++;
                a ~= 1;

            }
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_RUAdctTw(fu::vec<int>& a)
{
    int& /*a|static*/ b = a.mutref(0);
    if (a.size() & 1)
    {
        b++;
        a += 1;
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_RUAdctTw(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                b++; // Same thing but reordered as a loop.
                if (a.len & 3) {

                    a ~= 1; // Invalidates 'b'.

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 105;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:23+2[0m:

[2m      |                 if (a.len & 3) {[0m
[2m      | [0m
[2m    9 | [0m                    a [31;1m~=[0m 1; // Invalidates 'b'.
[2m      | [0m
[2m      |                 }[0m

	Write to [35;1mref arg[0m [34;1ma[0m at call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m invalidates the use of [35;1mref[0m [34;1mb[0m at [2m6:17+1[0m:

[2m      |             for (mut i = 2; i --> 0; )[0m
[2m      |             {[0m
[2m    6 | [0m                [31;1mb[0m++; // Same thing but reordered as a loop.
[2m      |                 if (a.len & 3) {[0m
[2m      | [0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                b++; // Same thing but reordered as a loop.
                if (a.len & 3) {

                    b++;

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 105;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_RUAdctTw(fu::vec<int>& a)
{
    int& /*a|static*/ b = a.mutref(0);
    for (int i = 2; i-- > 0; )
    {
        b++;
        if (a.size() & 3)
            b++;

    };
    a += 100;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_RUAdctTw(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 105;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                if (i & 1) {
                    b += 2; // Same thing but reordered as a loop.
                }
                else {

                    a ~= 1; // Invalidates 'b', same as a above, but now in an if/else -

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 106;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:23+2[0m:

[2m      |                 else {[0m
[2m      | [0m
[2m   11 | [0m                    a [31;1m~=[0m 1; // Invalidates 'b', same as a above, but now in an if/else -
[2m      | [0m
[2m      |                 }[0m

	Write to [35;1mref arg[0m [34;1ma[0m at call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m invalidates the use of [35;1mref[0m [34;1mb[0m at [2m7:21+1[0m:

[2m      |             {[0m
[2m      |                 if (i & 1) {[0m
[2m    7 | [0m                    [31;1mb[0m += 2; // Same thing but reordered as a loop.
[2m      |                 }[0m
[2m      |                 else {[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                if (i & 1) {
                    b += 2; // Same thing but reordered as a loop.
                }
                else {
 //  got the used-in-a-loop stuff wrong when switching to cant_invalidate.
                    b += 3;

                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 106;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_RUAdctTw(fu::vec<int>& a)
{
    int& /*a|static*/ b = a.mutref(0);
    for (int i = 2; i-- > 0; )
    {
        if (i & 1)
            b += 2;
        else
            b += 3;

    };
    a += 100;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_RUAdctTw(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 106;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        // both args alias, but there's no risk of inval.
        noinline fn incr_a_or_b(ref a: i32, ref b: i32)
            (a || b)++;

        fn main() {
            mut Z = 0;
            mut A = 1;
            mut B = 0;

            incr_a_or_b(Z, B); // incr B, now 1
            incr_a_or_b(A, B); // incr A, now 2
            incr_a_or_b(B, B); // incr _target, now 2 // alias!

            return (100*A + B) - 202;
        }

-----

#ifndef fu_NO_fdefs

static int incr_a_or_b_qg01zOoD(int& a, int& b)
{
    return (a ? a : b)++;
}

int fu_MAIN()
{
    int Z = 0;
    int A = 1;
    int B = 0;
    incr_a_or_b_qg01zOoD(Z, B);
    incr_a_or_b_qg01zOoD(A, B);
    incr_a_or_b_qg01zOoD(B, B);
    return ((100 * A) + B) - 202;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            ref c = a || b;
            return ++++c - 3; // double mutation of a union
        }

-----
struct s_V;

                                #ifndef DEF_s_V
                                #define DEF_s_V
struct s_V
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_V A = s_V { 1 };
    int& /*A*/ a = A.v;
    int& /*A*/ b = A.v;
    int& /*b|a*/ c = (a ? a : b);
    return ++++c - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            return ++++(a || b) - 3; // same, without a helper var
        }

-----
struct s_V;

                                #ifndef DEF_s_V
                                #define DEF_s_V
struct s_V
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_V A = s_V { 1 };
    int& /*A*/ a = A.v;
    int& /*A*/ b = A.v;
    return ++++(a ? a : b) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct V { v: i32; w?: i32; ww?: i32; };

        fn main() {
            mut A: V = [ 1 ];
            mut B: V = [ 1 ];


            ref aa = A.v || A.w; 

            ref bb = B.v || B.w;
            ++++bb;

            ref a = A.v || A.ww;
            ref b = B.v || B.ww;

            ref c = a || b;
            ++++c;

            return aa - 3; // same, without a helper var
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:20+2[0m:

[2m      |             ++++c;[0m
[2m      | [0m
[2m   20 | [0m            return [31;1maa[0m - 3; // same, without a helper var
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1maa[0m, reference invalidated by write to [35;1mref[0m [34;1mc[0m at [2m18:15+2[0m:

[2m      | [0m
[2m      |             ref c = a || b;[0m
[2m   18 | [0m            ++[31;1m++[0mc;
[2m      | [0m
[2m      |             return aa - 3; // same, without a helper var[0m

	At call to [35;1m__native[0m [34;1m++[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct V { v: i32; w?: i32; ww?: i32; };

        fn main() {
            mut A: V = [ 1 ];
            mut B: V = [ 1 ];


            fn  aa = A.v || A.w; 

            ref bb = B.v || B.w;
            ++++bb;

            ref a = A.v || A.ww;
            ref b = B.v || B.ww;

            ref c = a || b;
            ++++c;

            return aa - 3; // same, without a helper var
        }

-----
struct s_V;

                                #ifndef DEF_s_V
                                #define DEF_s_V
struct s_V
{
    int v;
    int w;
    int ww;
    explicit operator bool() const noexcept
    {
        return false
            || v
            || w
            || ww
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& aa_fwJRfWgj(s_V& A)
{
    return A.v ? A.v : A.w;
}

int fu_MAIN()
{
    s_V A = s_V { 1, 0, 0 };
    s_V B = s_V { 1, 0, 0 };
    int& /*B*/ bb = (B.v ? B.v : B.w);
    ++++bb;
    int& /*A*/ a = (A.v ? A.v : A.ww);
    int& /*B*/ b = (B.v ? B.v : B.ww);
    int& /*b|a*/ c = (a ? a : b);
    ++++c;
    return aa_fwJRfWgj(A) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        // a can alias b
        // c can alias d
        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd(ab, cd, ab, cd); 

            return ab - cd;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:27+2[0m:

[2m      | [0m
[2m      | [0m
[2m   16 | [0m            ab_cd(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab - cd;[0m

	At call to [35;1mfn[0m [34;1mab_cd[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mab_cd[0m:[34;1mc[0m and
	    1:	[35;1mref arg[0m [34;1mab_cd[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mab[0m at [2m12:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   12 | [0m            mut [31;1mab[0m = 0;
[2m      |             mut cd = 0;[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mab_cd[0m:[34;1mc[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mab_cd[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m11:12+4[0m

-----

        // a can alias b
        // c can alias d
        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd(ab, ab, cd, cd); 

            return ab - cd;
        }

-----

#ifndef fu_NO_fdefs

static void ab_cd_5cUzcLQk(int& a, int& b, int& c, int& d)
{
    int& /*b|a*/ ab = (a ? a : b);
    int& /*d|c*/ cd = (c ? c : d);
    ++++ab;
    ++++cd;
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    ab_cd_5cUzcLQk(ab, ab, cd, cd);
    return ab - cd;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X { i: i32; j: i32; };
        // a can alias b
        // c can alias d
        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {
            ref ab = a || b;
            defer {
                ref abi = j ? ab.j : ab.i;
                ++++abi;
            }
            ref cd = c || d;
            ref cdi = j ? cd.j : cd.i;
            ++++cdi;
        }

        fn main() {
            mut ab = X(0, 0);
            mut cd = X(0, 0);


            ab_cd_defer(ab, cd, ab, cd); 

            return ab.i - cd.i;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 21:33+2[0m:

[2m      | [0m
[2m      | [0m
[2m   21 | [0m            ab_cd_defer(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab.i - cd.i;[0m

	At call to [35;1mfn[0m [34;1mab_cd_defer[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mab_cd_defer[0m:[34;1mc[0m and
	    1:	[35;1mref arg[0m [34;1mab_cd_defer[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mab[0m at [2m17:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut [31;1mab[0m = X(0, 0);
[2m      |             mut cd = X(0, 0);[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mab_cd_defer[0m:[34;1mc[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mab_cd_defer[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m16:12+4[0m

-----

        struct X { i: i32; j: i32; };
        // a can alias b
        // c can alias d
        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {
            ref ab = a || b;
            defer {
                ref abi = j ? ab.j : ab.i;
                ++++abi;
            }
            ref cd = c || d;
            ref cdi = j ? cd.j : cd.i;
            ++++cdi;
        }

        fn main() {
            mut ab = X(0, 0);
            mut cd = X(0, 0);


            ab_cd_defer(ab, ab, cd, cd); 

            return ab.i - cd.i;
        }

-----
#include <fu/defer.h>

struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int i;
    int j;
    explicit operator bool() const noexcept
    {
        return false
            || i
            || j
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void ab_cd_defer_aiqOD4PA(s_X& a, s_X& b, s_X& c, s_X& d, const bool j)
{
    s_X& /*b|a*/ ab = (a ? a : b);
    fu_DEFER(
    {
        int& /*ab*/ abi = (j ? ab.j : ab.i);
        ++++abi;
    });
    s_X& /*d|c*/ cd = (c ? c : d);
    int& /*cd*/ cdi = (j ? cd.j : cd.i);
    ++++cdi;
}

int fu_MAIN()
{
    s_X ab = s_X { 0, 0 };
    s_X cd = s_X { 0, 0 };
    ab_cd_defer_aiqOD4PA(ab, ab, cd, cd, false);
    return ab.i - cd.i;
}

#endif

int main() { return fu_MAIN(); }

-----

        // a can alias b
        // c can alias d
        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)
            ab_cd_inner(a, b, c, d);

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd_outer(ab, cd, ab, cd); 

            return ab - cd;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 19:33+2[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            ab_cd_outer(ab, cd, [31;1mab[0m, cd); 
[2m      | [0m
[2m      |             return ab - cd;[0m

	At call to [35;1mfn[0m [34;1mab_cd_outer[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mab_cd_outer[0m:[34;1mc[0m and
	    1:	[35;1mref arg[0m [34;1mab_cd_outer[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mab[0m at [2m15:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   15 | [0m            mut [31;1mab[0m = 0;
[2m      |             mut cd = 0;[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mab_cd_outer[0m:[34;1mc[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mab_cd_outer[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m14:12+4[0m

-----

        // a can alias b
        // c can alias d
        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)
            ab_cd_inner(a, b, c, d);

        fn main() {
            mut ab = 0;
            mut cd = 0;


            ab_cd_outer(ab, ab, cd, cd); 

            return ab - cd;
        }

-----

#ifndef fu_NO_fdefs

static void ab_cd_inner_5cUzcLQk(int& a, int& b, int& c, int& d)
{
    int& /*b|a*/ ab = (a ? a : b);
    int& /*d|c*/ cd = (c ? c : d);
    ++++ab;
    ++++cd;
}

static void ab_cd_outer_5cUzcLQk(int& a, int& b, int& c, int& d)
{
    ab_cd_inner_5cUzcLQk(a, b, c, d);
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    ab_cd_outer_5cUzcLQk(ab, ab, cd, cd);
    return ab - cd;
}

#endif

int main() { return fu_MAIN(); }

-----

        // a can alias b
        // c can alias d
        // e can alias f
        // g can alias h
        noinline fn abcd_efgh(
            ref a: i32, ref b: i32, ref c: i32, ref d: i32,
            ref e: i32, ref f: i32, ref g: i32, ref h: i32)
        {
            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;
            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;
            ++++abcd; ++++ab; ++++cd;
            ++++efgh; ++++ef; ++++gh;
        }

        fn main() {
            mut ab = 0; mut cd = 0;
            mut ef = 0; mut gh = 0;


            abcd_efgh(ab, ab, cd, gh, ef, ef, cd, gh); 

            return (ab + cd) - (ef + gh);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 21:47+2[0m:

[2m      | [0m
[2m      | [0m
[2m   21 | [0m            abcd_efgh(ab, ab, cd, gh, ef, ef, [31;1mcd[0m, gh); 
[2m      | [0m
[2m      |             return (ab + cd) - (ef + gh);[0m

	At call to [35;1mfn[0m [34;1mabcd_efgh[0m, arguments:

	    7:	[35;1mref arg[0m [34;1mabcd_efgh[0m:[34;1mg[0m and
	    3:	[35;1mref arg[0m [34;1mabcd_efgh[0m:[34;1mc[0m

	    both alias:

	    [35;1mvar[0m [34;1mcd[0m at [2m17:29+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   17 | [0m            mut ab = 0; mut [31;1mcd[0m = 0;
[2m      |             mut ef = 0; mut gh = 0;[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mabcd_efgh[0m:[34;1mg[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mabcd_efgh[0m:[34;1mc[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m16:12+4[0m

-----

        // a can alias b
        // c can alias d
        // e can alias f
        // g can alias h
        noinline fn abcd_efgh(
            ref a: i32, ref b: i32, ref c: i32, ref d: i32,
            ref e: i32, ref f: i32, ref g: i32, ref h: i32)
        {
            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;
            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;
            ++++abcd; ++++ab; ++++cd;
            ++++efgh; ++++ef; ++++gh;
        }

        fn main() {
            mut ab = 0; mut cd = 0;
            mut ef = 0; mut gh = 0;


            abcd_efgh(ab, ab, cd, cd, ef, ef, gh, gh); 

            return (ab + cd) - (ef + gh);
        }

-----

#ifndef fu_NO_fdefs

static void abcd_efgh_ZqWAnUmX(int& a, int& b, int& c, int& d, int& e, int& f, int& g, int& h)
{
    int& /*b|a*/ ab = (a ? a : b);
    int& /*d|c*/ cd = (c ? c : d);
    int& /*cd|ab*/ abcd = (ab ? ab : cd);
    int& /*f|e*/ ef = (e ? e : f);
    int& /*h|g*/ gh = (g ? g : h);
    int& /*gh|ef*/ efgh = (ef ? ef : gh);
    ++++abcd;
    ++++ab;
    ++++cd;
    ++++efgh;
    ++++ef;
    ++++gh;
}

int fu_MAIN()
{
    int ab = 0;
    int cd = 0;
    int ef = 0;
    int gh = 0;
    abcd_efgh_ZqWAnUmX(ab, ab, cd, cd, ef, ef, gh, gh);
    return (ab + cd) - (ef + gh);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {
            ref x = a || b; ++x;
            ref y = b || a; ++y;                                // N_AARSoftRisk
        }

        fn main() {
            mut a = 0;


            ref b = a;
            incr_a_or_b_and_b_or_a(a, b);


            return a - 2;
        }

-----

#ifndef fu_NO_fdefs

static void incr_a_or_b_and_b_or_a_qg01zOoD(int& a, int& b)
{
    int& /*b|a*/ x = (a ? a : b);
    ++x;
    int& /*b|a*/ y = (b ? b : a);
    ++y;
}

int fu_MAIN()
{
    int a = 0;
    incr_a_or_b_and_b_or_a_qg01zOoD(a, a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {
            ref x = a || b; ++x;
            ref y = b || a; ++y;                                // N_AARSoftRisk
        }

        fn main() {
            mut a = 0;


            incr_a_or_b_and_b_or_a(a, a);


            return a - 2;
        }

-----

#ifndef fu_NO_fdefs

static void incr_a_or_b_and_b_or_a_qg01zOoD(int& a, int& b)
{
    int& /*b|a*/ x = (a ? a : b);
    ++x;
    int& /*b|a*/ y = (b ? b : a);
    ++y;
}

int fu_MAIN()
{
    int a = 0;
    incr_a_or_b_and_b_or_a_qg01zOoD(a, a);
    return a - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        // same as below -
        //  but using a helper variable
        //   which provides a "name" for the outcome of a|b.
        noinline fn incr_a_or_b_by2_via_x(ref a: i32, ref b: i32) {
            ref x = a || b;
            ++++x;
        }

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2_via_x(Z, B); // incr B, now 2
            incr_a_or_b_by2_via_x(A, B); // incr A, now 4
            incr_a_or_b_by2_via_x(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }

-----

#ifndef fu_NO_fdefs

static void incr_a_or_b_by2_via_x_qg01zOoD(int& a, int& b)
{
    int& /*b|a*/ x = (a ? a : b);
    ++++x;
}

int fu_MAIN()
{
    int Z = 0;
    int A = 2;
    int B = 0;
    incr_a_or_b_by2_via_x_qg01zOoD(Z, B);
    incr_a_or_b_by2_via_x_qg01zOoD(A, B);
    incr_a_or_b_by2_via_x_qg01zOoD(B, B);
    return ((100 * A) + B) - 404;
}

#endif

int main() { return fu_MAIN(); }

-----

        // same as above -
        //  but notice we increment twice, which breaks current setup.
        noinline fn incr_a_or_b_by2(ref a: i32, ref b: i32)
            ++++(a || b);

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2(Z, B); // incr B, now 2
            incr_a_or_b_by2(A, B); // incr A, now 4
            incr_a_or_b_by2(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }

-----

#ifndef fu_NO_fdefs

static int& incr_a_or_b_by2_qg01zOoD(int& a, int& b)
{
    return ++++(a ? a : b);
}

int fu_MAIN()
{
    int Z = 0;
    int A = 2;
    int B = 0;
    incr_a_or_b_by2_qg01zOoD(Z, B);
    incr_a_or_b_by2_qg01zOoD(A, B);
    incr_a_or_b_by2_qg01zOoD(B, B);
    return ((100 * A) + B) - 404;
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn alias(ref arr: i32[], ref item: i32) {
            arr ~= 1;
            return item;
        }

        fn main() {
            mut a = [ 0 ];

            ref c = alias(a, a[0]);

            return c++;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:26+1[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = alias[31;1m([0ma, a[0]);
[2m      | [0m
[2m      |             return c++;[0m

	At call to [35;1mfn[0m [34;1malias[0m, binding for [35;1mref arg[0m [34;1malias[0m:[34;1marr[0m (arg #0) at [2m10:27+1[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = alias([31;1ma[0m, a[0]);
[2m      | [0m
[2m      |             return c++;[0m

	... invalidated by subsequent write to [35;1mvar[0m [34;1ma[0m upon evaluation of [35;1mref arg[0m [34;1malias[0m:[34;1mitem[0m (arg #1) at [2m10:31+1[0m:

[2m      |             mut a = [ 0 ];[0m
[2m      | [0m
[2m   10 | [0m            ref c = alias(a, a[31;1m[[0m0]);
[2m      | [0m
[2m      |             return c++;[0m

	At call to [35;1m__native[0m [34;1m
.mutref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        noinline fn alias(ref arr: i32[], ref item: i32) {
            arr ~= 1;
            return item;
        }

        fn main() {
            mut a = [ 0 ];

            mut b = [ 0 ];
            ref c = alias(a, b[0]);

            return c++;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& alias_yBXh9oDq(fu::vec<int>& arr, int& item)
{
    arr += 1;
    return item;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 0 } };
    int& /*b|static*/ c = alias_yBXh9oDq(a, b.mutref(0));
    return c++;
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            ref cc = bb || aa;     // Mustn't compile.
            return cc;
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:28+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    7 | [0m            ref cc = bb || [31;1maa[0m;     // Mustn't compile.
[2m      |             return cc;[0m
[2m      |         }[0m

	Cannot access [35;1mref[0m [34;1maa[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m6:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    6 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             ref cc = bb || aa;     // Mustn't compile.[0m
[2m      |             return cc;[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:], i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            ref cc = bb || aa;     // Mustn't compile.
            return cc;
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& aa_y1jV3SX3(fu::view_mut<int> a)
{
    return a.mutref(0);
}

static int& test_xS2yPxA8(fu::vec<int>& a, fu::view_mut<int> b)
{
    int& /*b|static*/ bb = b.mutref(0);
    a += 1;
    int& /*bb|a|static*/ cc = (bb ? bb : aa_y1jV3SX3(a));
    return cc;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 0 } };
    return test_xS2yPxA8(a, b);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return bb || aa;       // Same as above, but no explicit binding.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:26+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    7 | [0m            return bb || [31;1maa[0m;       // Same as above, but no explicit binding.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1maa[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m6:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    6 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return bb || aa;       // Same as above, but no explicit binding.[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:], i32[:]) at [2m2:21+4[0m

-----

        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return bb || aa;       // Same as above, but no explicit binding.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& aa_y1jV3SX3(fu::view_mut<int> a)
{
    return a.mutref(0);
}

static int& test_xS2yPxA8(fu::vec<int>& a, fu::view_mut<int> b)
{
    int& /*b|static*/ bb = b.mutref(0);
    a += 1;
    return bb ? bb : aa_y1jV3SX3(a);
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 0 } };
    return test_xS2yPxA8(a, b);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn noop(x) x;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return noop(bb || aa); // Same as above, but bound at callsite.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:31+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    8 | [0m            return noop(bb || [31;1maa[0m); // Same as above, but bound at callsite.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1maa[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m7:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    7 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return noop(bb || aa); // Same as above, but bound at callsite.[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:], i32[:]) at [2m3:21+4[0m

-----

        noinline fn noop(x) x;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn  aa() a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return noop(bb || aa); // Same as above, but bound at callsite.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& aa_hpa9AihZ(fu::view_mut<int> a)
{
    return a.mutref(0);
}

inline static int& noop_3JeKX2Qj(int& x)
{
    return x;
}

static int& test_xS2yPxA8(fu::vec<int>& a, fu::view_mut<int> b)
{
    int& /*b|static*/ bb = b.mutref(0);
    a += 1;
    return noop_3JeKX2Qj((bb ? bb : aa_hpa9AihZ(a)));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 0 } };
    return test_xS2yPxA8(a, b);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn either(a, b) a || b;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            ref aa = a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return either(bb, aa); // For completeness.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:31+2[0m:

[2m      | [0m
[2m      |             ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.[0m
[2m    8 | [0m            return either(bb, [31;1maa[0m); // For completeness.
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1maa[0m, reference invalidated by write to [35;1mref arg[0m [34;1ma[0m at [2m7:30+2[0m:

[2m      |             ref aa = a[0]; [0m
[2m      | [0m
[2m    7 | [0m            ref bb = b[0]; a [31;1m~=[0m 1; // Invalidates 'aa' if ref.
[2m      |             return either(bb, aa); // For completeness.[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:], i32[:]) at [2m3:21+4[0m

-----

        noinline fn either(a, b) a || b;
        noinline fn test(ref a: i32[], ref b: i32[]) {

            fn aa()  a[0]; 

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return either(bb, aa); // For completeness.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int& aa_hpa9AihZ(fu::view_mut<int> a)
{
    return a.mutref(0);
}

inline static int& either_qg01zOoD(int& a, int& b)
{
    return a ? a : b;
}

static int& test_xS2yPxA8(fu::vec<int>& a, fu::view_mut<int> b)
{
    int& /*b|static*/ bb = b.mutref(0);
    a += 1;
    return either_qg01zOoD(bb, aa_hpa9AihZ(a));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 0 } };
    return test_xS2yPxA8(a, b);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn what(ref cond: i32, ref cons: i32)
            cond && (cons += 1);

        fn main() {
            mut x = 1;
            return what(x, x) - 2;
        }

-----

#ifndef fu_NO_fdefs

static int& what_SlQuFZGA(int& cond, int& cons)
{
    return !cond ? cond : (cons += 1);
}

int fu_MAIN()
{
    int x = 1;
    return what_SlQuFZGA(x, x) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Target {
            overload: i32[];
            extended: i32[];
        };

        noinline fn which(ref t: Target, i: i32) i & 1
            ? t.overload
            : t.extended;

        fn test(ref target: Target)
        {
            ref overload = target.which(target.overload.len);
            ref extended = target.which(target.overload.len + 1);

            mut change = false;
            if (overload)
            {
                for (mut i = 0; i < overload.len; i++)
                {
                    let a = overload[i];
                    let b = extended[i];
                    if (a != b)
                    {
                        change = true;
                        break;
                    }
                }
            }

            if (change)
            {
                extended[0] = 3;

                shadow ref overload = target.which(target.overload.len);
                overload[0] = 5; // Said write to overload invalidates ext on next loop iter.
            }
        }

        fn main()
        {
            mut target = Target([ 0 ], [ 1 ]);
            target.test();
            return target.overload[0] * 10 + target.extended[0] * 100 - 350;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    fu::vec<int> overload;
    fu::vec<int> extended;
    explicit operator bool() const noexcept
    {
        return false
            || overload
            || extended
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int>& which_O8uJhtsf(s_Target& t, const int i)
{
    if (i & 1)
        return t.overload;
    else
        return t.extended;

}

static void test_JQNw9E8B(s_Target& target)
{
    fu::view<int> /*target*/ overload = which_O8uJhtsf(target, target.overload.size());
    fu::view_mut<int> /*target*/ extended = which_O8uJhtsf(target, (target.overload.size() + 1));
    bool change = false;
    if (overload)
    {
        for (int i = 0; i < overload.size(); i++)
        {
            const int /*overload|static*/ a = overload[i];
            const int /*extended|static*/ b = extended[i];
            if (a != b)
            {
                change = true;
                break;
            };
        };
    };
    if (change)
    {
        extended.mutref(0) = 3;
        fu::view_mut<int> /*target*/ overload_1 = which_O8uJhtsf(target, target.overload.size());
        overload_1.mutref(0) = 5;
    };
}

int fu_MAIN()
{
    s_Target target = s_Target { fu::vec<int> { fu::slate<1, int> { 0 } }, fu::vec<int> { fu::slate<1, int> { 1 } } };
    test_JQNw9E8B(target);
    return ((target.overload[0] * 10) + (target.extended[0] * 100)) - 350;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn outer() {
            mut sum = 0;
            mut x = 1;
            for (;;) {      // bck complained that the write to 'x' at the end
                let v = x;  //  invalidates use of 'v' on next loop iter here, which is not true
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return sum;
                }

                x = v * 2;
            }
        }

        fn main() outer - 42;

-----

#ifndef fu_NO_fdefs

static int outer_H9fhQUVP()
{
    int sum = 0;
    int x = 1;
    for (; ; )
    {
        const int /*x*/ v = x;
        for (int i = 0; i < 10; i++)
        {
            sum += v;
            if (sum > 40)
                return sum;

        };
        x = (v * 2);
    };
}

int fu_MAIN()
{
    return outer_H9fhQUVP() - 42;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn append_self(ref a: i32[])
        {
            let b = a;
            a ~= b; // b narrowed down to a slice which is non-copyable
                    //  but it (unfortunately) wanted to copy to a temp.
        }

        fn main() {
            mut arr = [1, 2];
            arr.append_self();
            return arr[2] + arr[3] - 3;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static void append_self_RUAdctTw(fu::vec<int>& a)
{
    fu::vec<int> b { a };
    a += b;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    append_self_RUAdctTw(arr);
    return (arr[2] + arr[3]) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn but_is_it_pure(ref x: i32) {

            return x++; 
        }
        pure fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:9+4[0m:

[2m      |             return x++; [0m
[2m      |         }[0m
[2m    6 | [0m        [31;1mpure[0m fn pure_fn(ref a: i32, ref b: i32) {
[2m      |             ref x = a || b;[0m
[2m      |             return but_is_it_pure(x);[0m

	[35;1mfn[0m [34;1mpure_fn[0m is not pure, writes to [35;1mref arg[0m [34;1ma[0m:

            via [35;1mfn[0m [34;1mbut_is_it_pure[0m at [2m8:34+1[0m:

[2m      |         pure fn pure_fn(ref a: i32, ref b: i32) {[0m
[2m      |             ref x = a || b;[0m
[2m    8 | [0m            return but_is_it_pure[31;1m([0mx);
[2m      |         }[0m
[2m      |         fn main() {[0m

            via [35;1m__native[0m [34;1mpostfix++[0m at [2m4:21+2[0m:

[2m      |         fn but_is_it_pure(ref x: i32) {[0m
[2m      | [0m
[2m    4 | [0m            return x[31;1m++[0m; 
[2m      |         }[0m
[2m      |         pure fn pure_fn(ref a: i32, ref b: i32) {[0m


-----

        fn but_is_it_pure(ref x: i32) {

            return x;   
        }
        pure fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }

-----

#ifndef fu_NO_fdefs

static int& but_is_it_pure_3JeKX2Qj(int& x)
{
    return x;
}

static int& pure_fn_qg01zOoD(int& a, int& b)
{
    int& /*b|a*/ x = (a ? a : b);
    return but_is_it_pure_3JeKX2Qj(x);
}

int fu_MAIN()
{
    int x = 0;
    int y = 0;
    return pure_fn_qg01zOoD(x, y);
}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn inner(ref x: i32, n: i32) {
            return outer(x, n);
        }

        noinline fn report_write_here(ref x: i32, n: i32) {

            return x += n;                             
        }

        noinline fn outer(ref x: i32, n: i32) {
            if (n & 3) {
                if (n & 2)
                    return inner(x, n / 2);
                else
                    return report_write_here(x, n);
            }
            else {
                return inner(x, n + 1);
            }
        }

        pure fn not_pure(ref x: i32, n: i32) {
            return outer(x, n);
        }

        fn main() {
            mut x = 0;
            return not_pure(x, 0) == 1 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 23:9+4[0m:

[2m      |         }[0m
[2m      | [0m
[2m   23 | [0m        [31;1mpure[0m fn not_pure(ref x: i32, n: i32) {
[2m      |             return outer(x, n);[0m
[2m      |         }[0m

	[35;1mfn[0m [34;1mnot_pure[0m is not pure, writes to [35;1mref arg[0m [34;1mx[0m:

            via [35;1mfn[0m [34;1mouter[0m at [2m24:25+1[0m:

[2m      | [0m
[2m      |         pure fn not_pure(ref x: i32, n: i32) {[0m
[2m   24 | [0m            return outer[31;1m([0mx, n);
[2m      |         }[0m
[2m      | [0m

            via [35;1mfn[0m [34;1mreport_write_here[0m at [2m16:45+1[0m:

[2m      |                     return inner(x, n / 2);[0m
[2m      |                 else[0m
[2m   16 | [0m                    return report_write_here[31;1m([0mx, n);
[2m      |             }[0m
[2m      |             else {[0m

            via [35;1m__native[0m [34;1m+=[0m at [2m8:22+2[0m:

[2m      |         noinline fn report_write_here(ref x: i32, n: i32) {[0m
[2m      | [0m
[2m    8 | [0m            return x [31;1m+=[0m n;                             
[2m      |         }[0m
[2m      | [0m


-----

        noinline fn inner(ref x: i32, n: i32) {
            return outer(x, n);
        }

        noinline fn report_write_here(ref x: i32, n: i32) {

            return x + n;                              
        }

        noinline fn outer(ref x: i32, n: i32) {
            if (n & 3) {
                if (n & 2)
                    return inner(x, n / 2);
                else
                    return report_write_here(x, n);
            }
            else {
                return inner(x, n + 1);
            }
        }

        pure fn not_pure(ref x: i32, n: i32) {
            return outer(x, n);
        }

        fn main() {
            mut x = 0;
            return not_pure(x, 0) == 1 ? 0 : 1;
        }

-----
static int outer_wxomPhrI(int, int);

#ifndef fu_NO_fdefs

static int inner_wxomPhrI(const int x, const int n)
{
    return outer_wxomPhrI(x, n);
}

static int report_write_here_wxomPhrI(const int x, const int n)
{
    return x + n;
}

static int outer_wxomPhrI(const int x, const int n)
{
    if (n & 3)
    {
        if (n & 2)
            return inner_wxomPhrI(x, (n / 2));
        else
            return report_write_here_wxomPhrI(x, n);

    }
    else
        return inner_wxomPhrI(x, (n + 1));

}

static int not_pure_wxomPhrI(const int x, const int n)
{
    return outer_wxomPhrI(x, n);
}

int fu_MAIN()
{
    const int x = 0;
    if (not_pure_wxomPhrI(x, 0) == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info ? i : [];
                }

                return reason;
            }

            return fail.len;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_vuSW0Q9ulEj
                                #define DEF_x7Ex3D_vuSW0Q9ulEj
inline fu::str& x7Ex3D_vuSW0Q9u(fu::str& a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_9snJx10P(/*MOV*/ fu::str&& reason, fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_vuSW0Q9u(reason, fu::i64dec((info ? i : int{})));
    };
    return static_cast<fu::str&&>(reason);
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_9snJx10P(""_fu, _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info && i;
                }

                return reason;
            }

            return fail.len;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_vuSW0Q9ulEj
                                #define DEF_x7Ex3D_vuSW0Q9ulEj
inline fu::str& x7Ex3D_vuSW0Q9u(fu::str& a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_9snJx10P(/*MOV*/ fu::str&& reason, fu::view<fu::str> _info)
{
    for (int i = _info.size(); i-- > 0; )
    {
        fu::view<char> /*_info|static*/ info = _info[i];
        x7Ex3D_vuSW0Q9u(reason, fu::i64dec((info ? i : 0)));
    };
    return static_cast<fu::str&&>(reason);
}

int fu_MAIN()
{
    fu::vec<fu::str> _info {};
    return fail_9snJx10P(""_fu, _info).size();
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info ? ("" ~ info) : [];
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_9snJx10P(/*MOV*/ fu::str&& reason, fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_gCeFmDFw(""_fu, fu::i64dec(info)) : fu::str{});
    return static_cast<fu::str&&>(reason);
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> { fu::slate<1, int> { 101 } };
    return fail_9snJx10P(""_fu, _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && ("" ~ info);
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str fail_9snJx10P(/*MOV*/ fu::str&& reason, fu::view<int> _info)
{
    const int /*_info|static*/ info = _info[0];
    reason += (info ? x7E_gCeFmDFw(""_fu, fu::i64dec(info)) : fu::str{});
    return static_cast<fu::str&&>(reason);
}

int fu_MAIN()
{
    fu::vec<int> _info = fu::vec<int> { fu::slate<1, int> { 101 } };
    return fail_9snJx10P(""_fu, _info).size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_H(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_H(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }

-----
#include <fu/vec.h>

struct s_Helpers;

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    fu::vec<int> row;
    explicit operator bool() const noexcept
    {
        return false
            || row
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void solveNode_H_iOgUc5R3(const s_Helpers& h, fu::vec<s_Helpers>& _helpers, int& N)
{
    while (N % h.row[(h.row.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static int solveJump_PztAjfdB(fu::vec<s_Helpers>& _helpers, int& N, const int row)
{
    solveNode_H_iOgUc5R3(s_Helpers(_helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_GL8iXq9a(fu::vec<s_Helpers>& _helpers, int N, const int row)
{
    return solveJump_PztAjfdB(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<s_Helpers> _helpers = fu::vec<s_Helpers> { fu::slate<1, s_Helpers> { s_Helpers { fu::vec<int> { fu::slate<5, int> { 1, 2, 3, 4, 5 } } } } };
    return test_GL8iXq9a(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_HH_inner(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveNode_HH(h: Helpers) {
                return solveNode_HH_inner(h);
            }

            fn solveJump() {
                solveNode_HH(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }

-----
#include <fu/vec.h>

struct s_Helpers;

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    fu::vec<int> row;
    explicit operator bool() const noexcept
    {
        return false
            || row
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void solveNode_HH_inner_iOgUc5R3(const s_Helpers& h, fu::vec<s_Helpers>& _helpers, int& N)
{
    while (N % h.row[(h.row.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static void solveNode_HH_lRIoAutN(const s_Helpers& h, fu::vec<s_Helpers>& _helpers, int& N)
{
    solveNode_HH_inner_iOgUc5R3(h, _helpers, N);
}

static int solveJump_2UgSo2z7(fu::vec<s_Helpers>& _helpers, int& N, const int row)
{
    solveNode_HH_lRIoAutN(s_Helpers(_helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_GL8iXq9a(fu::vec<s_Helpers>& _helpers, int N, const int row)
{
    return solveJump_2UgSo2z7(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<s_Helpers> _helpers = fu::vec<s_Helpers> { fu::slate<1, s_Helpers> { s_Helpers { fu::vec<int> { fu::slate<5, int> { 1, 2, 3, 4, 5 } } } } };
    return test_GL8iXq9a(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        fn test(ref _helpers: i32[][], mut N: i32, row: i32)
        {
            fn solveNode_a(h: i32[]) {
                while (N % h[h.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_a(_helpers[row]); // We've relaxed to a view, which bck can't copy
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [[ 1, 2, 3, 4, 5 ]];
            return test(_helpers, row: 0, N: 4)
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void solveNode_a_vmc3mWFF(fu::view<int> h, fu::vec<fu::vec<int>>& _helpers, int& N)
{
    while (N % h[(h.size() - 1)])
    {
        N--;
        _helpers.grow((_helpers.size() * 2));
    };
}

static int solveJump_nOBcBwB8(fu::vec<fu::vec<int>>& _helpers, int& N, const int row)
{
    solveNode_a_vmc3mWFF(fu::vec<int>(_helpers[row]), _helpers, N);
    return _helpers.size();
}

static int test_53eyWNAt(fu::vec<fu::vec<int>>& _helpers, int N, const int row)
{
    return solveJump_nOBcBwB8(_helpers, N, row) - ((((1 * 2) * 2) * 2) * 2);
}

int fu_MAIN()
{
    fu::vec<fu::vec<int>> _helpers = fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<5, int> { 1, 2, 3, 4, 5 } } } };
    return test_53eyWNAt(_helpers, 4, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(args: &mut Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //

            ref  badref = args[0];

            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }       // oct2021: now latest issue here is that
                //  this gets bcked AFTER jump lifetimes are unwound
                //   and it all looks as if everything's fine (lt badref == lt args).

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 14:20+6[0m:

[2m      | [0m
[2m      |             args = [ Arg(11) ]; // INVALIDATE badref.[0m
[2m   14 | [0m            return [31;1mbadref[0m;
[2m      |         }       // oct2021: now latest issue here is that[0m
[2m      |                 //  this gets bcked AFTER jump lifetimes are unwound[0m

	Cannot access [35;1mref[0m [34;1mbadref[0m, reference invalidated by write to [35;1mref arg[0m [34;1margs[0m at [2m13:18+1[0m:

[2m      |             ref  badref = args[0];[0m
[2m      | [0m
[2m   13 | [0m            args [31;1m=[0m [ Arg(11) ]; // INVALIDATE badref.
[2m      |             return badref;[0m
[2m      |         }       // oct2021: now latest issue here is that[0m

	At call to [35;1m__native[0m [34;1m=[0m

    BorrowCheck [35;1mfn[0m [34;1mmutargs[0m(Arg[:]) at [2m5:12+7[0m

-----

        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(args: &mut Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //

            mut  badref = args[0];

            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }       // oct2021: now latest issue here is that
                //  this gets bcked AFTER jump lifetimes are unwound
                //   and it all looks as if everything's fine (lt badref == lt args).

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }

-----
#include <fu/vec.h>

struct s_Arg;

                                #ifndef DEF_s_Arg
                                #define DEF_s_Arg
struct s_Arg
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Arg mutargs_S6Y3oX4D(fu::vec<s_Arg>& args)
{
    const s_Arg badref { args[0] };
    args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { 11 } } };
    return badref;
}

int fu_MAIN()
{
    fu::vec<s_Arg> args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { 7 } } };
    return mutargs_S6Y3oX4D(args).i - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg)
            i[i.len - 1] * 4;

        fn mutargs(args: &mut Arg[]) {

            ref  badref = args[0];

            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            return witharg(badref);
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:28+6[0m:

[2m      | [0m
[2m      |             args = [ Arg([ 11 ]) ]; // INVALIDATE badref.[0m
[2m   12 | [0m            return witharg([31;1mbadref[0m);
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mbadref[0m, reference invalidated by write to [35;1mref arg[0m [34;1margs[0m at [2m11:18+1[0m:

[2m      |             ref  badref = args[0];[0m
[2m      | [0m
[2m   11 | [0m            args [31;1m=[0m [ Arg([ 11 ]) ]; // INVALIDATE badref.
[2m      |             return witharg(badref);[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m=[0m

    BorrowCheck [35;1mfn[0m [34;1mmutargs[0m(Arg[:]) at [2m7:12+7[0m

-----

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg)
            i[i.len - 1] * 4;

        fn mutargs(args: &mut Arg[]) {

            let  badref = args[0];

            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            return witharg(badref);
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

-----
#include <fu/vec.h>

struct s_Arg;

                                #ifndef DEF_s_Arg
                                #define DEF_s_Arg
struct s_Arg
{
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int witharg_KR184vch(const s_Arg& a)
{
    return a.i[(a.i.size() - 1)] * 4;
}

static int mutargs_S6Y3oX4D(fu::vec<s_Arg>& args)
{
    s_Arg badref { args[0] };
    args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { fu::vec<int> { fu::slate<1, int> { 11 } } } } };
    return witharg_KR184vch(badref);
}

int fu_MAIN()
{
    fu::vec<s_Arg> args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { fu::vec<int> { fu::slate<1, int> { 7 } } } } };
    return mutargs_S6Y3oX4D(args) - 28;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg, x: i32)
            i[i.len - 1] * x;

        fn mutargs(args: &mut Arg[]) {

            ref  badref = args[0];

            for (mut i = 0;; i++) {
                let ret = witharg(badref, i * 4);
                if (ret)
                    return ret;

                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            }
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:22+1[0m:

[2m      |                     return ret;[0m
[2m      | [0m
[2m   16 | [0m                args [31;1m=[0m [ Arg([ 11 ]) ]; // INVALIDATE badref.
[2m      |             }[0m
[2m      |         }[0m

	Write to [35;1mref arg[0m [34;1margs[0m at call to [35;1m__native[0m [34;1m=[0m invalidates the use of [35;1mref[0m [34;1mbadref[0m at [2m12:35+6[0m:

[2m      | [0m
[2m      |             for (mut i = 0;; i++) {[0m
[2m   12 | [0m                let ret = witharg([31;1mbadref[0m, i * 4);
[2m      |                 if (ret)[0m
[2m      |                     return ret;[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mmutargs[0m(Arg[:]) at [2m7:12+7[0m

-----

        struct Arg { i: i32[]; };

        fn witharg(using a: Arg, x: i32)
            i[i.len - 1] * x;

        fn mutargs(args: &mut Arg[]) {

            let  badref = args[0];

            for (mut i = 0;; i++) {
                let ret = witharg(badref, i * 4);
                if (ret)
                    return ret;

                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            }
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }

-----
#include <fu/vec.h>

struct s_Arg;

                                #ifndef DEF_s_Arg
                                #define DEF_s_Arg
struct s_Arg
{
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int witharg_CgKPuOJi(const s_Arg& a, const int x)
{
    return a.i[(a.i.size() - 1)] * x;
}

static int mutargs_S6Y3oX4D(fu::vec<s_Arg>& args)
{
    s_Arg badref { args[0] };
    for (int i = 0; ; i++)
    {
        const int ret = witharg_CgKPuOJi(badref, (i * 4));
        if (ret)
            return ret;
        else
        {
            args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { fu::vec<int> { fu::slate<1, int> { 11 } } } } };
        };
    };
}

int fu_MAIN()
{
    fu::vec<s_Arg> args = fu::vec<s_Arg> { fu::slate<1, s_Arg> { s_Arg { fu::vec<int> { fu::slate<1, int> { 7 } } } } };
    return mutargs_S6Y3oX4D(args) - 28;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(ref woot: i32[], x: i32, y: i32) {
            ref b = woot[y];
            ref a = woot[x]; // the 'shadow ref' below ...
            if (a == 1) {


                a += 1;
            }
            else {
                b += 1; // ... and this should ignore cond write above.
            }
        }

        fn main() {
            mut x = [ -1, +1 ];
            test(x, 0, 1);
            return x[1] - 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:17+1[0m:

[2m      |             }[0m
[2m      |             else {[0m
[2m   11 | [0m                [31;1mb[0m += 1; // ... and this should ignore cond write above.
[2m      |             }[0m
[2m      |         }[0m

	Cannot access [35;1mref[0m [34;1mb[0m, reference invalidated by write to [35;1mref arg[0m [34;1mwoot[0m at [2m4:25+1[0m:

[2m      |         fn test(ref woot: i32[], x: i32, y: i32) {[0m
[2m      |             ref b = woot[y];[0m
[2m    4 | [0m            ref a = woot[31;1m[[0mx]; // the 'shadow ref' below ...
[2m      |             if (a == 1) {[0m
[2m      | [0m

	At call to [35;1m__native[0m [34;1m
.mutref[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32[:], i32, i32) at [2m2:12+4[0m

-----

        fn test(ref woot: i32[], x: i32, y: i32) {
            ref b = woot[y];
            ref a = woot[x]; // the 'shadow ref' below ...
            if (a == 1) {

                shadow ref a = woot[x]; // ... should relax 'ref a' above to a let ...

                a += 1;
            }
            else {
                b += 1; // ... and this should ignore cond write above.
            }
        }

        fn main() {
            mut x = [ -1, +1 ];
            test(x, 0, 1);
            return x[1] - 2;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void test_261qzVQg(fu::view_mut<int> woot, const int x, const int y)
{
    int& /*woot|static*/ b = woot.mutref(y);
    const int /*woot|static*/ a = woot[x];
    if (a == 1)
    {
        int& /*woot|static*/ a_1 = woot.mutref(x);
        a_1 += 1;
    }
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> { fu::slate<2, int> { -1, +1 } };
    test_261qzVQg(x, 0, 1);
    return x[1] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(ref a: i32[], ref b: i32[]) {

            if (a[0] == 1)

                a ~= 1;
            else
                b ~= 1;
        }

        fn main() {
            mut x = [ 1 ];
            test(x, x);
            return x.len - 2;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_Kwiy5QEk(fu::vec<int>& a, fu::vec<int>& b)
{
    if (a[0] == 1)
        a += 1;
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_Kwiy5QEk(x, x);
    return x.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(ref a: i32[], ref b: i32[]) {

            if (a[0]++ == 1)                                    // N_AARSoftRisk

                a ~= 1;
            else
                b ~= 1;
        }

        fn main() {
            mut x = [ 1 ];
            test(x, x);
            return x.len - 2;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void test_Kwiy5QEk(fu::vec<int>& a, fu::vec<int>& b)
{
    if (a.mutref(0)++ == 1)
        a += 1;
    else
        b += 1;

}

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> { fu::slate<1, int> { 1 } };
    test_Kwiy5QEk(x, x);
    return x.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        fn indexIntoImplicit(j: i32, implicit strings: string[]) strings[j];

        fn selfRecurBeforeImplicitDep(x: i32)
        {
            // On second solve we're talking about a region, but the argnode is gone.
            fn T(i: i32) selfRecurBeforeImplicitDep(i / 2);
            if (x > 1) return T(x);
            return indexIntoImplicit(x);
        }

        fn main() {
            let implicit strings = [ "a", "b" ];
            return selfRecurBeforeImplicitDep(2) == "b" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

static const fu::str& selfRecurBeforeImplicitDep_BG4BMnQN(int, fu::view<fu::str>);

#ifndef fu_NO_fdefs

static const fu::str& T_pfGNahhF(const int i, fu::view<fu::str> strings)
{
    return selfRecurBeforeImplicitDep_BG4BMnQN((i / 2), strings);
}

static const fu::str& indexIntoImplicit_ObQUd120(const int j, fu::view<fu::str> strings)
{
    return strings[j];
}

static const fu::str& selfRecurBeforeImplicitDep_BG4BMnQN(const int x, fu::view<fu::str> strings)
{
    if (x > 1)
        return T_pfGNahhF(x, strings);
    else
        return indexIntoImplicit_ObQUd120(x, strings);

}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> strings = fu::vec<fu::str> { fu::slate<2, fu::str> { "a"_fu, "b"_fu } };
    if (selfRecurBeforeImplicitDep_BG4BMnQN(2, strings) == "b"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----


        nocopy                 
        struct Type       { canon: string; };
        struct SolvedNode {  type: Type;   };

        fn solved(type: Type, implicit ref out: SolvedNode[]) {
            out.grow(out.len * 100 + 1);

            ref tail = out[out.len - 1];
            tail.type.canon = type.canon;
            return tail;
        }

        fn createMap(a: Type, b: Type): Type {
            return Type(a.canon ~ b.canon);
        }

        fn evalTypeAnnot(nodes: string[]): SolvedNode
        {
            fn T(i: i32)
                evalTypeAnnot([ nodes[i] ]).type;

            // Each T() call should invalidate the results from previous T() calls -
            //  so this shouldn't compile if Type is nocopy.
            if (nodes.len > 1)
                return solved(createMap(T(0), T(1)));           ;; PointlessMustSeq

            return solved(Type(nodes[0]));
        }

        fn main() {
            implicit mut out: SolvedNode[];
            let annot = evalTypeAnnot([ "a", "b" ]);
            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 27:40+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved(createMap[31;1m([0mT(0), T(1)));           // PointlessMustSeq
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	At call to [35;1mfn[0m [34;1mcreateMap[0m, binding for [35;1marg[0m [34;1mcreateMap[0m:[34;1ma[0m (arg #0) at [2m27:42+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved(createMap(T[31;1m([0m0), T(1)));           // PointlessMustSeq
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	... invalidated by subsequent write to [35;1minjected implicit ref arg[0m [34;1mout[0m upon evaluation of [35;1marg[0m [34;1mcreateMap[0m:[34;1mb[0m (arg #1) at [2m27:48+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved(createMap(T(0), T[31;1m([0m1)));           // PointlessMustSeq
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

	At call to [35;1mfn[0m [34;1mT[0m
            via [35;1mfn[0m [34;1mevalTypeAnnot[0m at [2m22:30+1[0m:

[2m      |         {[0m
[2m      |             fn T(i: i32)[0m
[2m   22 | [0m                evalTypeAnnot[31;1m([0m[ nodes[i] ]).type;
[2m      | [0m
[2m      |             // Each T() call should invalidate the results from previous T() calls -[0m

            via [35;1mfn[0m [34;1msolved[0m at [2m27:30+1[0m:

[2m      |             //  so this shouldn't compile if Type is nocopy.[0m
[2m      |             if (nodes.len > 1)[0m
[2m   27 | [0m                return solved[31;1m([0mcreateMap(T(0), T(1)));           // PointlessMustSeq
[2m      | [0m
[2m      |             return solved(Type(nodes[0]));[0m

            via [35;1m__native[0m [34;1m
.grow[0m at [2m8:21+1[0m:

[2m      | [0m
[2m      |         fn solved(type: Type, implicit ref out: SolvedNode[]) {[0m
[2m    8 | [0m            out.grow[31;1m([0mout.len * 100 + 1);
[2m      | [0m
[2m      |             ref tail = out[out.len - 1];[0m


    BorrowCheck [35;1mfn[0m [34;1mevalTypeAnnot[0m(string[:], SolvedNode[]) at [2m19:12+13[0m
        Solving [35;1mfn[0m [34;1mmain[0m at [2m32:12+4[0m

-----


        struct Type       { canon: string; };
        struct SolvedNode {  type: Type;   };

        fn solved(type: Type, implicit ref out: SolvedNode[]) {
            out.grow(out.len * 100 + 1);

            ref tail = out[out.len - 1];
            tail.type.canon = type.canon;
            return tail;
        }

        fn createMap(a: Type, b: Type): Type {
            return Type(a.canon ~ b.canon);
        }

        fn evalTypeAnnot(nodes: string[]): SolvedNode
        {
            fn T(i: i32)
                evalTypeAnnot([ nodes[i] ]).type;

            // Each T() call should invalidate the results from previous T() calls -
            //  so this shouldn't compile if Type is nocopy.
            if (nodes.len > 1)
                return solved(createMap(T(0), T(1)));           // PointlessMustSeq

            return solved(Type(nodes[0]));
        }

        fn main() {
            implicit mut out: SolvedNode[];
            let annot = evalTypeAnnot([ "a", "b" ]);
            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct s_SolvedNode;
struct s_Type;
static s_SolvedNode& evalTypeAnnot_eFtMR6Tg(fu::view<fu::str>, fu::vec<s_SolvedNode>&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type& T_MlgsT0c8(const int i, fu::view<fu::str> nodes, fu::vec<s_SolvedNode>& out)
{
    return evalTypeAnnot_eFtMR6Tg((fu::slate<1, fu::str> { fu::str(nodes[i]) }), out).type;
}

static s_Type createMap_NB8CuMcL(const s_Type& a, const s_Type& b)
{
    return s_Type { (a.canon + b.canon) };
}

static s_SolvedNode& solved_TBWrGO61(const s_Type& type, fu::vec<s_SolvedNode>& out)
{
    out.grow(((out.size() * 100) + 1));
    s_SolvedNode& /*out|static*/ tail = out.mutref((out.size() - 1));
    tail.type.canon = type.canon;
    return tail;
}

static s_SolvedNode& evalTypeAnnot_eFtMR6Tg(fu::view<fu::str> nodes, fu::vec<s_SolvedNode>& out)
{
    if (nodes.size() > 1)
    {
        s_Type _0 {};
        return solved_TBWrGO61((_0 = s_Type(T_MlgsT0c8(0, nodes, out)), createMap_NB8CuMcL(static_cast<s_Type&&>(_0), T_MlgsT0c8(1, nodes, out))), out);
    }
    else
    {
        return solved_TBWrGO61(s_Type { fu::str(nodes[0]) }, out);
    };
}

int fu_MAIN()
{
    fu::vec<s_SolvedNode> out {};
    const s_SolvedNode& /*out|static*/ annot = evalTypeAnnot_eFtMR6Tg((fu::slate<2, fu::str> { "a"_fu, "b"_fu }), out);
    if ((out.size() == 10101) && (annot.type.canon.size() == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_BckMustSeq

-----

        fn main() {
            mut x = 0;
            let s = ++x + ++x;
            return s - 3; // Not 4! one arg must invalidate
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;
    int _0 {};
    const int s = (_0 = ++x, (_0 + ++x));
    return s - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----


        nocopy 
        struct X { x: i32; }
        fn sum(a: X, b: X) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn main() {
            mut x: X;
            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 14:23+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return sum[31;1m([0mx.incr, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1msum[0m, binding for [35;1marg[0m [34;1msum[0m:[34;1ma[0m (arg #0) at [2m14:26+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return sum(x.[31;1mincr[0m, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;1mvar[0m [34;1mx[0m upon evaluation of [35;1marg[0m [34;1msum[0m:[34;1mb[0m (arg #1) at [2m14:34+4[0m:

[2m      |         fn main() {[0m
[2m      |             mut x: X;[0m
[2m   14 | [0m            return sum(x.incr, x.[31;1mincr[0m) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mincr[0m
            via [35;1m__native[0m [34;1mpostfix++[0m at [2m8:16+2[0m:

[2m      | [0m
[2m      |         fn incr(ref x: X) {[0m
[2m    8 | [0m            x.x[31;1m++[0m;
[2m      |             return x;[0m
[2m      |         }[0m


    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m12:12+4[0m

-----


        struct X { x: i32; }
        fn sum(a: X, b: X) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn main() {
            mut x: X;
            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_X& incr_vF9rn5QP(s_X& x)
{
    x.x++;
    return x;
}

static int sum_ySwjHX04(const s_X& a, const s_X& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    s_X x {};
    s_X _0 {};
    return (_0 = s_X(incr_vF9rn5QP(x)), sum_ySwjHX04(static_cast<s_X&&>(_0), incr_vF9rn5QP(x))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----


        nocopy 
        struct X { x: i32; }
        struct Y { y: X;   }

        fn x(y: Y) y.y.x;
        fn sum(a, b) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn incr(ref y: Y) {
            y.y.x++;
            return y;
        }

        fn main() {
            mut x: Y;
            ref y = x.y;
            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 23:23+1[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return sum[31;1m([0my.incr, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1msum[0m, binding for [35;1marg[0m [34;1msum[0m:[34;1ma[0m (arg #0) at [2m23:26+4[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return sum(y.[31;1mincr[0m, x.incr) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;1mvar[0m [34;1mx[0m upon evaluation of [35;1marg[0m [34;1msum[0m:[34;1mb[0m (arg #1) at [2m23:34+4[0m:

[2m      |             mut x: Y;[0m
[2m      |             ref y = x.y;[0m
[2m   23 | [0m            return sum(y.incr, x.[31;1mincr[0m) - 3; // Not 4! one arg must invalidate
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mincr[0m
            via [35;1m__native[0m [34;1mpostfix++[0m at [2m16:18+2[0m:

[2m      | [0m
[2m      |         fn incr(ref y: Y) {[0m
[2m   16 | [0m            y.y.x[31;1m++[0m;
[2m      |             return y;[0m
[2m      |         }[0m


    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m20:12+4[0m

-----


        struct X { x: i32; }
        struct Y { y: X;   }

        fn x(y: Y) y.y.x;
        fn sum(a, b) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn incr(ref y: Y) {
            y.y.x++;
            return y;
        }

        fn main() {
            mut x: Y;
            ref y = x.y;
            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }

-----
struct s_Y;
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Y
                                #define DEF_s_Y
struct s_Y
{
    s_X y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_X& incr_vF9rn5QP(s_X& x)
{
    x.x++;
    return x;
}

static s_Y& incr_MIVW3AfO(s_Y& y)
{
    y.y.x++;
    return y;
}

static int x_DFHZEc6V(const s_Y& y)
{
    return y.y.x;
}

inline static int sum_u7EPR8y9(const s_X& a, const s_Y& b)
{
    return a.x + x_DFHZEc6V(b);
}

int fu_MAIN()
{
    s_Y x {};
    s_X& /*x*/ y = x.y;
    s_X _0 {};
    return (_0 = s_X(incr_vF9rn5QP(y)), sum_u7EPR8y9(static_cast<s_X&&>(_0), incr_MIVW3AfO(x))) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----


        nocopy 
        struct X { x: i32; };

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn +=(a: X, b: X) {
            // Notice, this is not a real +=,
            //  just checking the order of eval here.
            return a.x + b.x;
        }

        fn test(ref x: X, ref y: X) {
            ref xy = y || x;
            return x.incr += xy.incr; // <- xy invalidated by x.incr
        }

        fn main() {
            mut x: X;
            mut y: X;
            return test(x, y) - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 19:27+2[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.incr [31;1m+=[0m xy.incr; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1m+=[0m, binding for [35;1marg[0m [34;1m+=[0m:[34;1mb[0m (arg #1) at [2m19:33+4[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.incr += xy.[31;1mincr[0m; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	... invalidated by subsequent write to [35;1mref arg[0m [34;1mx[0m upon evaluation of [35;1marg[0m [34;1m+=[0m:[34;1ma[0m (arg #0) at [2m19:22+4[0m:

[2m      |         fn test(ref x: X, ref y: X) {[0m
[2m      |             ref xy = y || x;[0m
[2m   19 | [0m            return x.[31;1mincr[0m += xy.incr; // <- xy invalidated by x.incr
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mincr[0m
            via [35;1m__native[0m [34;1mpostfix++[0m at [2m7:16+2[0m:

[2m      | [0m
[2m      |         fn incr(ref x: X) {[0m
[2m    7 | [0m            x.x[31;1m++[0m;
[2m      |             return x;[0m
[2m      |         }[0m


    BorrowCheck [35;1mfn[0m [34;1mtest[0m(X, X) at [2m17:12+4[0m

-----


        struct X { x: i32; };

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn +=(a: X, b: X) {
            // Notice, this is not a real +=,
            //  just checking the order of eval here.
            return a.x + b.x;
        }

        fn test(ref x: X, ref y: X) {
            ref xy = y || x;
            return x.incr += xy.incr; // <- xy invalidated by x.incr
        }

        fn main() {
            mut x: X;
            mut y: X;
            return test(x, y) - 3;
        }

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_X& incr_vF9rn5QP(s_X& x)
{
    x.x++;
    return x;
}

static int operator+=(const s_X& a, const s_X& b)
{
    return a.x + b.x;
}

static int test_IbQlRgVG(s_X& x, s_X& y)
{
    s_X& /*y|x*/ xy = (y ? y : x);
    return (incr_vF9rn5QP(x) += s_X(incr_vF9rn5QP(xy)));
}

int fu_MAIN()
{
    s_X x {};
    s_X y {};
    return test_IbQlRgVG(x, y) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct AB { a: i32[][]; b: i32[][]; };

        fn problematic_moves(mut ab: AB) {
            ref ra = ab.a;
            return ra.len & 1 ? ra[0] : ab.b[0];
        }

        fn main() {
            mut ab = AB(
                [[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]],
                [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]);

            mut pick = ab.problematic_moves;
            return pick[9] - ab.a[0][9];
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_AB;

                                #ifndef DEF_s_AB
                                #define DEF_s_AB
struct s_AB
{
    fu::vec<fu::vec<int>> a;
    fu::vec<fu::vec<int>> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> problematic_moves_EbMDJut9(s_AB&& ab)
{
    fu::view<fu::vec<int>> /*ab*/ ra = ab.a;
    if (ra.size() & 1)
        return fu::vec<int>(ra[0]);
    else
        return fu::vec<int>(ab.b[0]);

}

int fu_MAIN()
{
    s_AB ab = s_AB { fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<10, int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } } } }, fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<10, int> { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 } } } } };
    fu::vec<int> pick = problematic_moves_EbMDJut9(s_AB(ab));
    return pick[9] - ab.a[0][9];
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----


        nocopy 
        struct NC { x: i32; y: i32 };

        fn wants_val(mut a: NC) {
            a.x++;
            a.y++;
            return a;
        }

        fn incr_by(mut a: NC, b: NC) {
            a.x += b.x;
            a.y += b.y;
            return a;
        }

        fn main() {
            mut v = NC(-1, -1);
            mut w = wants_val(v);
            return (w || v).x + 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:31+1[0m:

[2m      |         fn main() {[0m
[2m      |             mut v = NC(-1, -1);[0m
[2m   20 | [0m            mut w = wants_val([31;1mv[0m);
[2m      |             return (w || v).x + 1;[0m
[2m      |         }[0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1mvar[0m [34;1mv[0m) -> NC

RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m18:12+4[0m

-----


        struct NC { x: i32; y: i32 };

        fn wants_val(mut a: NC) {
            a.x++;
            a.y++;
            return a;
        }

        fn incr_by(mut a: NC, b: NC) {
            a.x += b.x;
            a.y += b.y;
            return a;
        }

        fn main() {
            mut v = NC(-1, -1);
            mut w = wants_val(v);
            return (w || v).x + 1;
        }

-----
struct s_NC;

                                #ifndef DEF_s_NC
                                #define DEF_s_NC
struct s_NC
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_NC wants_val_e9Kxw8kj(s_NC&& a)
{
    a.x++;
    a.y++;
    return a;
}

int fu_MAIN()
{
    const s_NC v = s_NC { -1, -1 };
    const s_NC w = wants_val_e9Kxw8kj(s_NC(v));
    return (w ? w : v).x + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct SolvedNode {
            items: SolvedNode[];
        };

        fn test(mut a: SolvedNode, mut b: SolvedNode) {

            ref n = a.items ? a : b;

            return n;
        }

        fn main() test([], []).items.len;

-----
#include <fu/vec.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = delete;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode&) = delete;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode test_zL3Fmi05(/*MOV*/ s_SolvedNode&& a, /*MOV*/ s_SolvedNode&& b)
{
    /*MOV*/ s_SolvedNode& /*b|a*/ n = (a.items ? a : b);
    return static_cast<s_SolvedNode&&>(n);
}

int fu_MAIN()
{
    return test_zL3Fmi05(s_SolvedNode{}, s_SolvedNode{}).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        nocopy struct SolvedNode {
            items: SolvedNode[];
        };

        fn test(mut a: SolvedNode, mut b: SolvedNode) {

            ref n = a || b;

            return n;
        }

        fn main() test([], []).items.len;

-----
#include <fu/vec.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = delete;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode&) = delete;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode test_zL3Fmi05(/*MOV*/ s_SolvedNode&& a, /*MOV*/ s_SolvedNode&& b)
{
    /*MOV*/ s_SolvedNode& /*b|a*/ n = (a ? a : b);
    return static_cast<s_SolvedNode&&>(n);
}

int fu_MAIN()
{
    return test_zL3Fmi05(s_SolvedNode{}, s_SolvedNode{}).items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----


        nocopy            
        struct SolvedNode { len: i32; }

        fn createBlock(mut last: SolvedNode) {
            let tail     = last || last;
            let unwrap   = tail || tail;
            last.len--;
            return unwrap;
        }

        fn main() {
            return createBlock([]).len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:20+6[0m:

[2m      |             let unwrap   = tail || tail;[0m
[2m      |             last.len--;[0m
[2m   10 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1munwrap[0m, reference invalidated by write to [35;1marg[0m [34;1mlast[0m at [2m9:21+2[0m:

[2m      |             let tail     = last || last;[0m
[2m      |             let unwrap   = tail || tail;[0m
[2m    9 | [0m            last.len[31;1m--[0m;
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1mpostfix--[0m

    BorrowCheck [35;1mfn[0m [34;1mcreateBlock[0m(SolvedNode) at [2m6:12+11[0m

-----


        struct SolvedNode { len: i32; }

        fn createBlock(mut last: SolvedNode) {
            let tail     = last || last;
            let unwrap   = tail || tail;
            last.len--;
            return unwrap;
        }

        fn main() {
            return createBlock([]).len;
        }

-----
struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int len;
    explicit operator bool() const noexcept
    {
        return false
            || len
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode createBlock_vffDWlNj(s_SolvedNode&& last)
{
    const s_SolvedNode& /*last*/ tail = (last ? last : last);
    const s_SolvedNode unwrap { (tail ? tail : tail) };
    last.len--;
    return unwrap;
}

int fu_MAIN()
{
    return createBlock_vffDWlNj(s_SolvedNode{}).len;
}

#endif

int main() { return fu_MAIN(); }

-----


        nocopy            
        struct SolvedNode { items: SolvedNode[] };

        fn popAndOr(ref node: SolvedNode) {
            let N = node.items.len;

            let pop = node.items[N - 1];
            if (N > 2) {
                node.items.pop();
            }
            else {
                let head = node.items[0];
                node = head;
            }

            return pop;
        }

        fn main() {
            mut a = SolvedNode([ SolvedNode, SolvedNode ]);
            let b = a.popAndOr();
            return a.items.len + b.items.len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:20+3[0m:

[2m      |             }[0m
[2m      | [0m
[2m   18 | [0m            return [31;1mpop[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1mpop[0m, reference invalidated by write to [35;1mref arg[0m [34;1mnode[0m at [2m15:22+1[0m:

[2m      |             else {[0m
[2m      |                 let head = node.items[0];[0m
[2m   15 | [0m                node [31;1m=[0m head;
[2m      |             }[0m
[2m      | [0m

	At call to [35;1m__native[0m [34;1m=[0m

    BorrowCheck [35;1mfn[0m [34;1mpopAndOr[0m(SolvedNode) at [2m6:12+8[0m

-----


        struct SolvedNode { items: SolvedNode[] };

        fn popAndOr(ref node: SolvedNode) {
            let N = node.items.len;

            let pop = node.items[N - 1];
            if (N > 2) {
                node.items.pop();
            }
            else {
                let head = node.items[0];
                node = head;
            }

            return pop;
        }

        fn main() {
            mut a = SolvedNode([ SolvedNode, SolvedNode ]);
            let b = a.popAndOr();
            return a.items.len + b.items.len;
        }

-----
#include <fu/vec.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode popAndOr_zJaDGh6i(s_SolvedNode& node)
{
    const int N = node.items.size();
    /*MOV*/ s_SolvedNode pop { node.items[(N - 1)] };
    if (N > 2)
        node.items.pop();
    else
    {
        const s_SolvedNode& /*node|static*/ head = node.items[0];
        node = head;
    };
    return /*NRVO*/ pop;
}

int fu_MAIN()
{
    s_SolvedNode a = s_SolvedNode { fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode{}, s_SolvedNode{} } } };
    s_SolvedNode b = popAndOr_zJaDGh6i(a);
    return a.items.size() + b.items.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----


        nocopy            
        struct Items {
            len: i32;
        }

        struct SolvedNode {
            items: Items;
        }

        struct Nodes {
            last: SolvedNode;
        }

        fn pop(ref n: Nodes) {
            n.last.items.len--;
        }

        fn createBlock(mut items: Nodes) {
            let tail = items.last;
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock(Nodes(SolvedNode([]))).len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 24:20+6[0m:

[2m      |             let unwrap = tail.items;[0m
[2m      |             items.pop();[0m
[2m   24 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1munwrap[0m, reference invalidated by write to [35;1marg[0m [34;1mitems[0m at [2m23:22+1[0m:

[2m      |             let tail = items.last;[0m
[2m      |             let unwrap = tail.items;[0m
[2m   23 | [0m            items.pop[31;1m([0m);
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mpop[0m
            via [35;1m__native[0m [34;1mpostfix--[0m at [2m17:29+2[0m:

[2m      | [0m
[2m      |         fn pop(ref n: Nodes) {[0m
[2m   17 | [0m            n.last.items.len[31;1m--[0m;
[2m      |         }[0m
[2m      | [0m


    BorrowCheck [35;1mfn[0m [34;1mcreateBlock[0m(Nodes) at [2m20:12+11[0m

-----


        struct Items {
            len: i32;
        }

        struct SolvedNode {
            items: Items;
        }

        struct Nodes {
            last: SolvedNode;
        }

        fn pop(ref n: Nodes) {
            n.last.items.len--;
        }

        fn createBlock(mut items: Nodes) {
            let tail = items.last;
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock(Nodes(SolvedNode([]))).len;
        }

-----
struct s_Items;
struct s_SolvedNode;
struct s_Nodes;

                                #ifndef DEF_s_Items
                                #define DEF_s_Items
struct s_Items
{
    int len;
    explicit operator bool() const noexcept
    {
        return false
            || len
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    s_Items items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Nodes
                                #define DEF_s_Nodes
struct s_Nodes
{
    s_SolvedNode last;
    explicit operator bool() const noexcept
    {
        return false
            || last
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void pop_mrO1BsFb(s_Nodes& n)
{
    n.last.items.len--;
}

static s_Items createBlock_SUp8GUir(s_Nodes&& items)
{
    const s_SolvedNode& /*items*/ tail = items.last;
    const s_Items unwrap { tail.items };
    pop_mrO1BsFb(items);
    return unwrap;
}

int fu_MAIN()
{
    return createBlock_SUp8GUir(s_Nodes { s_SolvedNode { s_Items{} } }).len;
}

#endif

int main() { return fu_MAIN(); }

-----


        nocopy            
        struct SolvedNode {
            items: SolvedNode[];
        };

        // Reducing the thing below.
        fn createBlock(mut items: SolvedNode[]) {
            let tail = items[items.len - 1];
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock([ SolvedNode ]).len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 13:20+6[0m:

[2m      |             let unwrap = tail.items;[0m
[2m      |             items.pop();[0m
[2m   13 | [0m            return [31;1munwrap[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1munwrap[0m, reference invalidated by write to [35;1marg[0m [34;1mitems[0m at [2m12:22+1[0m:

[2m      |             let tail = items[items.len - 1];[0m
[2m      |             let unwrap = tail.items;[0m
[2m   12 | [0m            items.pop[31;1m([0m);
[2m      |             return unwrap;[0m
[2m      |         }[0m

	At call to [35;1m__native[0m [34;1m
.pop()[0m

    BorrowCheck [35;1mfn[0m [34;1mcreateBlock[0m(SolvedNode[:]) at [2m9:12+11[0m

-----


        struct SolvedNode {
            items: SolvedNode[];
        };

        // Reducing the thing below.
        fn createBlock(mut items: SolvedNode[]) {
            let tail = items[items.len - 1];
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock([ SolvedNode ]).len;
        }

-----
#include <fu/vec.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<s_SolvedNode> createBlock_9LAOKZxi(fu::vec<s_SolvedNode>&& items)
{
    const s_SolvedNode& /*items|static*/ tail = items[(items.size() - 1)];
    /*MOV*/ fu::vec<s_SolvedNode> unwrap { tail.items };
    items.pop();
    return /*NRVO*/ unwrap;
}

int fu_MAIN()
{
    return createBlock_9LAOKZxi(fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode{} } }).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----


        nocopy            
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as below but mut.
        fn createBlock(mut items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items;
                items.pop();
                return unwrap;
            }

            return [];
        }

        fn main() {
            return createBlock([]).len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:24+6[0m:

[2m      |                 let unwrap = tail.items;[0m
[2m      |                 items.pop();[0m
[2m   18 | [0m                return [31;1munwrap[0m;
[2m      |             }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1munwrap[0m, reference invalidated by write to [35;1marg[0m [34;1mitems[0m at [2m17:26+1[0m:

[2m      | [0m
[2m      |                 let unwrap = tail.items;[0m
[2m   17 | [0m                items.pop[31;1m([0m);
[2m      |                 return unwrap;[0m
[2m      |             }[0m

	At call to [35;1m__native[0m [34;1m
.pop()[0m

    BorrowCheck [35;1mfn[0m [34;1mcreateBlock[0m(SolvedNode[:]) at [2m10:12+11[0m

-----


        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as below but mut.
        fn createBlock(mut items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items;
                items.pop();
                return unwrap;
            }

            return [];
        }

        fn main() {
            return createBlock([]).len;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str kind;
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static fu::vec<s_SolvedNode> createBlock_9LAOKZxi(fu::vec<s_SolvedNode>&& items)
{
    if (items.size())
    {
        for (; ; )
        {
            const s_SolvedNode& /*items|static*/ tail = items[(items.size() - 1)];
            if (tail.kind != "block"_fu)
                break;
            else
            {
                /*MOV*/ fu::vec<s_SolvedNode> unwrap { tail.items };
                items.pop();
                return /*NRVO*/ unwrap;
            };
        };
    };
    return fu::vec<s_SolvedNode>{};
}

int fu_MAIN()
{
    return createBlock_9LAOKZxi(fu::vec<s_SolvedNode>{}).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----


        nocopy            
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as above but ref.
        fn createBlock(ref items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1];
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items; // unwrap needs to copy here
                items.pop(); ////////////// <- nuked here, but ignored!
                return unwrap;
            }

            return [];
        }

        fn main() {
            mut items: SolvedNode[];
            return createBlock(items).len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:24+6[0m:

[2m      |                 let unwrap = tail.items; // unwrap needs to copy here[0m
[2m      |                 items.pop(); ////////////// <- nuked here, but ignored![0m
[2m   18 | [0m                return [31;1munwrap[0m;
[2m      |             }[0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1munwrap[0m, reference invalidated by write to [35;1mref arg[0m [34;1mitems[0m at [2m17:26+1[0m:

[2m      | [0m
[2m      |                 let unwrap = tail.items; // unwrap needs to copy here[0m
[2m   17 | [0m                items.pop[31;1m([0m); ////////////// <- nuked here, but ignored!
[2m      |                 return unwrap;[0m
[2m      |             }[0m

	At call to [35;1m__native[0m [34;1m
.pop()[0m

    BorrowCheck [35;1mfn[0m [34;1mcreateBlock[0m(SolvedNode[:]) at [2m10:12+11[0m

-----


        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as above but ref.
        fn createBlock(ref items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1];
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items; // unwrap needs to copy here
                items.pop(); ////////////// <- nuked here, but ignored!
                return unwrap;
            }

            return [];
        }

        fn main() {
            mut items: SolvedNode[];
            return createBlock(items).len;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str kind;
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static fu::vec<s_SolvedNode> createBlock_5BRdZ2v0(fu::vec<s_SolvedNode>& items)
{
    if (items.size())
    {
        for (; ; )
        {
            const s_SolvedNode& /*items|static*/ tail = items[(items.size() - 1)];
            if (tail.kind != "block"_fu)
                break;
            else
            {
                /*MOV*/ fu::vec<s_SolvedNode> unwrap { tail.items };
                items.pop();
                return /*NRVO*/ unwrap;
            };
        };
    };
    return fu::vec<s_SolvedNode>{};
}

int fu_MAIN()
{
    fu::vec<s_SolvedNode> items {};
    return createBlock_5BRdZ2v0(items).size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(ref a: i32[]) = a.swap(0, 1);

        fn main() {
            mut nums = [1, 2];
            nums.test();
            return nums.len == 2 && nums[0] == 2 && nums[1] == 1
                 ? 0
                 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_swap.h>


#ifndef fu_NO_fdefs

static void test_bJzechqP(fu::view_mut<int> a)
{
    fu::view_swap(a, 0, 1);
}

int fu_MAIN()
{
    fu::vec<int> nums = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    test_bJzechqP(nums);
    if ((nums.size() == 2) && (nums[0] == 2) && (nums[1] == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(ref arg: i32[]) {
            let encloses_unchanged = arg;

            fn closure()
                for (mut i = 0; i < arg.len; i++)
                    arg[i] += encloses_unchanged[i];

            closure();
            if (arg.len & 1)
                closure();
        }

        fn main() {
            mut a = [ 3 ];
            test(a);
            return a[0] - 9;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void closure_ijszdsuy(fu::view_mut<int> arg, fu::view<int> encloses_unchanged)
{
    for (int i = 0; i < arg.size(); i++)
        arg.mutref(i) += encloses_unchanged[i];

}

static void test_r1wKWx3Z(fu::vec<int>& arg)
{
    fu::vec<int> encloses_unchanged { arg };
    closure_ijszdsuy(arg, encloses_unchanged);
    if (arg.size() & 1)
        closure_ijszdsuy(arg, encloses_unchanged);

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 3 } };
    test_r1wKWx3Z(a);
    return a[0] - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        inline fn must_not_return_ref_or_view(ref x: i32[][]) {
            let y = x[100];
            x.shrink(y.len);
            return y;
        }

        fn main() {
            mut arr: i32[][];
            arr.grow(101);
            arr[100] = [ 7 ]
            return arr.must_not_return_ref_or_view()[0] - 7;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    // Hoisted:
    fu::vec<int> y {};

    fu::vec<fu::vec<int>> arr {};
    arr.grow(101);
    arr.mutref(100) = fu::vec<int> { fu::slate<1, int> { 7 } };
    return (y =  { arr[100] }, arr.shrink(y.size()), y)[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct HasVec { x: i32[] };
        inline fn last(x: i32[]) x[x.len - 1];                  // GNUStmtExpr


        fn will_return_value(ref x: HasVec) {
            let bck_will_cpy = x;

            let vec0 = bck_will_cpy.x;
            if (bck_will_cpy.x.len & 1)
                return vec0;

            x.x ~= x.x.len;
            let vec1 = bck_will_cpy.x;
            return vec1;
        }

        fn main() {
            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            return will_return_value(x).last/*9*/ - x.x.last/*10*/ + 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_HasVec;

                                #ifndef DEF_s_HasVec
                                #define DEF_s_HasVec
struct s_HasVec
{
    fu::vec<int> x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<int> will_return_value_13lUjxco(s_HasVec& x)
{
    /*MOV*/ s_HasVec bck_will_cpy { x };
    /*MOV*/ fu::vec<int>& /*bck_will_cpy*/ vec0 = bck_will_cpy.x;
    if (bck_will_cpy.x.size() & 1)
        return static_cast<fu::vec<int>&&>(vec0);
    else
    {
        x.x += x.x.size();
        /*MOV*/ fu::vec<int>& /*bck_will_cpy*/ vec1 = bck_will_cpy.x;
        return static_cast<fu::vec<int>&&>(vec1);
    };
}

int fu_MAIN()
{
    // Hoisted:
    fu::vec<int> x_1 {};

    s_HasVec x = s_HasVec { fu::vec<int> { fu::slate<10, int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } } };
    int _0 {};
    int BL_1_v {};
    return (_0 = (x_1 = will_return_value_13lUjxco(x), x_1[(x_1.size() - 1)]), (_0 - (__extension__ (
    {
        fu::view<int> /*x*/ x_2 = x.x;
        BL_1_v = (x_2[(x_2.size() - 1)]);
    (void)0;}), BL_1_v))) + 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct HasVec { x: i32[] };
        inline fn last(x: i32[]) x[x.len - 1];                  // GNUStmtExpr


        inline                                                  // GNUStmtExpr
                                                                // PointlessLocal

        fn will_return_value(ref x: HasVec) {
            let bck_will_cpy = x;

            let vec0 = bck_will_cpy.x;
            if (bck_will_cpy.x.len & 1)
                return vec0;

            x.x ~= x.x.len;
            let vec1 = bck_will_cpy.x;
            return vec1;
        }

        fn main() {
            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            return will_return_value(x).last/*9*/ - x.x.last/*10*/ + 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_HasVec;

                                #ifndef DEF_s_HasVec
                                #define DEF_s_HasVec
struct s_HasVec
{
    fu::vec<int> x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    // Hoisted:
    s_HasVec bck_will_cpy {};

    s_HasVec x = s_HasVec { fu::vec<int> { fu::slate<10, int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } } };
    int BL_1_v {};
    int _0 {};
    int BL_4_v {};
    return (_0 = (__extension__ (
    {
        fu::view<int> BL_2_v {};
        fu::view<int> /*vec1|vec0*/ x_1 = (__extension__ (
        {
            bck_will_cpy =  { x };
            fu::view<int> /*bck_will_cpy*/ vec0 = bck_will_cpy.x;
            fu::view<int> BL_3_v {};
            BL_2_v = (((bck_will_cpy.x.size() & 1) ? vec0 : (__extension__ (
            {
                x.x += x.x.size();
                fu::view<int> /*bck_will_cpy*/ vec1 = bck_will_cpy.x;
                BL_3_v = (vec1);
            (void)0;}), static_cast<fu::view<int>&&>(BL_3_v))));
        (void)0;}), static_cast<fu::view<int>&&>(BL_2_v));
        BL_1_v = (x_1[(x_1.size() - 1)]);
    (void)0;}), BL_1_v), (_0 - (__extension__ (
    {
        fu::view<int> /*x*/ x_2 = x.x;
        BL_4_v = (x_2[(x_2.size() - 1)]);
    (void)0;}), BL_4_v))) + 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        fn PASS_borrowCheck_incr_a_ret_b(ref a: i32, ref b: i32) {
            a++;        // we're done writing to a before
            return b;   //  EXTRA DRAMA: we dont cg const refs for primitives right now
        }

        fn main() {
            mut x = 5;
            PASS_borrowCheck_incr_a_ret_b(x, x);
            return x - 6;
        }

-----

#ifndef fu_NO_fdefs

static int& PASS_borrowCheck_incr_a_ret_b_qg01zOoD(int& a, int& b)
{
    a++;
    return b;
}

int fu_MAIN()
{
    int x = 5;
    PASS_borrowCheck_incr_a_ret_b_qg01zOoD(x, x);
    return x - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        fn PASS_borrowCheck_reduct(ref a: i32, ref b: i32[])
        {
            // If this were (ref!b a, ref b):
            //
            // When a points into b:
            //  - a++ read ok, write ok
            //   - b read ok, write ok + invalidates a
            //    - a not usable from here on
            //
            // The point is we should be able to deduce this automatically,
            //  if nothing a-related is used after b gets used for the first time,
            //   then we're fine if b aliases a ...
            //
            // ... EXCEPT that's if b doesn't acceptTempCopies -
            //  meaning it's either F_IMPLICIT or F_REF -
            //   otherwise there's ambiguity.
            //
            a++;
            b ~= 10;
        }

        fn main() {
            mut arr = [ 9 ];
            PASS_borrowCheck_reduct(arr[0], arr);               // PointlessMustSeq
            return arr[0] - arr[1];
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void PASS_borrowCheck_reduct_QOxWjrNo(int& a, fu::vec<int>& b)
{
    a++;
    b += 10;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 9 } };
    PASS_borrowCheck_reduct_QOxWjrNo(arr.mutref(0), arr);
    return arr[0] - arr[1];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq, N_AARSoftRisk

-----

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        fn PASS_borrowCheck(ref root: Node) {
            mut n: i32;
            fn count(id: i32)
                traverse(root): |i|
                    if (i.id == id)
                        n++;

            fn check(ref node: Node) {
                if (node.items)
                    for (mut i = 0; i < node.items.len; i++)
                        check(node.items[i]);                   // PointlessMustSeq
                else
                    count(node.id++);
            }

            check(root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

-----
#include <fu/vec.h>

struct s_Node;
static void check_hoO9g1WG(s_Node&, const s_Node&, int&);
inline static void traverse_oY1L1zjI(const s_Node&, int, int&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int id;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static void l_1_0_w9p5xQgp(const s_Node& i, const int id, int& n)
{
    if (i.id == id)
        n++;

}

inline static void traverse_oY1L1zjI(const s_Node& node, const int id, int& n)
{
    l_1_0_w9p5xQgp(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_oY1L1zjI(node.items[i], id, n);

}

static void count_5blOLqJz(const int id, const s_Node& root, int& n)
{
    traverse_oY1L1zjI(root, id, n);
}

static void check_hoO9g1WG(s_Node& node, const s_Node& root, int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_hoO9g1WG(node.items.mutref(i), root, n);

    else
        count_5blOLqJz(node.id++, root, n);

}

static int PASS_borrowCheck_udfwGr55(s_Node& root)
{
    int n {};
    check_hoO9g1WG(root, root, n);
    return n;
}

int fu_MAIN()
{
    s_Node tree = s_Node { 0, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 2, fu::vec<s_Node>{} } } } };
    return PASS_borrowCheck_udfwGr55(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

-----

        fn check(implicit root: i32[], node: i32[])
            root.len - node.len;

        fn PASS_borrowCheck(        
                     root: i32[])   
                check(root);

        fn main()
            [ 1, 2, 3 ].PASS_borrowCheck();

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:41+1[0m:

[2m      | [0m
[2m      |         fn main()[0m
[2m   10 | [0m            [ 1, 2, 3 ].PASS_borrowCheck[31;1m([0m);
[2m      | [0m

	No implicit [31;1mroot[0m: i32[:] in scope, needed to call [35;1mfn[0m [34;1mPASS_borrowCheck[0m:

            because of call to [35;1mfn[0m [34;1mcheck[0m at [2m7:22+1[0m:

[2m      |         fn PASS_borrowCheck(        [0m
[2m      |                      root: i32[])   [0m
[2m    7 | [0m                check[31;1m([0mroot);
[2m      | [0m
[2m      |         fn main()[0m

            because of [35;1mimplicit arg[0m [34;1mroot[0m at [2m2:27+4[0m:

[2m      | [0m
[2m    2 | [0m        fn check(implicit [31;1mroot[0m: i32[], node: i32[])
[2m      |             root.len - node.len;[0m
[2m      | [0m

        Possible candidate in [35;1mfn[0m [34;1mPASS_borrowCheck[0m: [31;1mNOT implicit [0m[35;1marg[0m [34;1mroot[0m at [2m6:22+4[0m:

[2m      | [0m
[2m      |         fn PASS_borrowCheck(        [0m
[2m    6 | [0m                     [31;1mroot[0m: i32[])   
[2m      |                 check(root);[0m
[2m      | [0m


        Solving [35;1mfn[0m [34;1mmain[0m at [2m9:12+4[0m

-----

        fn check(implicit root: i32[], node: i32[])
            root.len - node.len;

        fn PASS_borrowCheck(        
            implicit root: i32[])   
                check(root);

        fn main()
            [ 1, 2, 3 ].PASS_borrowCheck();

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int check_kkQWSQZw(fu::view<int> node, fu::view<int> root)
{
    return root.size() - node.size();
}

static int PASS_borrowCheck_dqqxWlfh(fu::view<int> root)
{
    return check_kkQWSQZw(root, root);
}

int fu_MAIN()
{
    return PASS_borrowCheck_dqqxWlfh((fu::slate<3, int> { 1, 2, 3 }));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but not a closure.
        fn count(id: i32, implicit root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        fn check(ref node: Node) {
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(node.items[i]);                   // PointlessMustSeq
            else
                count(node.id++);
        }

        fn PASS_borrowCheck(implicit ref root: Node) {
            implicit mut n: i32;
            check(root); // <- Usage intersection failure: Node & Node
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

-----
#include <fu/vec.h>

struct s_Node;
static void check_gpvkcOvr(s_Node&, int&, const s_Node&);
inline static void traverse_oY1L1zjI(const s_Node&, int, int&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int id;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static void l_1_0_w9p5xQgp(const s_Node& i, const int id, int& n)
{
    if (i.id == id)
        n++;

}

inline static void traverse_oY1L1zjI(const s_Node& node, const int id, int& n)
{
    l_1_0_w9p5xQgp(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_oY1L1zjI(node.items[i], id, n);

}

static void count_fHNoj12y(const int id, const s_Node& root, int& n)
{
    traverse_oY1L1zjI(root, id, n);
}

static void check_gpvkcOvr(s_Node& node, int& n, const s_Node& root)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_gpvkcOvr(node.items.mutref(i), n, root);

    else
        count_fHNoj12y(node.id++, root, n);

}

static int PASS_borrowCheck_udfwGr55(s_Node& root)
{
    int n {};
    check_gpvkcOvr(root, n, root);
    return n;
}

int fu_MAIN()
{
    s_Node tree = s_Node { 0, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 2, fu::vec<s_Node>{} } } } };
    return PASS_borrowCheck_udfwGr55(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

-----

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but no implicits.
        fn count(id: i32, ref root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        // AAR: check(ref node, ref root) accepted,
        //       but (ref root, ref node) rejected.

        fn check(ref node: Node, ref root: Node) { 
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(:root, node.items[i]);                // PointlessMustSeq
            else
                count(:root, node.id++);
        }

        fn PASS_borrowCheck(ref root: Node) {
            implicit mut n: i32;
            check(:root, root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

-----
#include <fu/vec.h>

struct s_Node;
static void check_AoghKeFN(s_Node&, const s_Node&, int&);
inline static void traverse_oY1L1zjI(const s_Node&, int, int&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int id;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static void l_1_0_w9p5xQgp(const s_Node& i, const int id, int& n)
{
    if (i.id == id)
        n++;

}

inline static void traverse_oY1L1zjI(const s_Node& node, const int id, int& n)
{
    l_1_0_w9p5xQgp(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_oY1L1zjI(node.items[i], id, n);

}

static void count_fHNoj12y(const int id, const s_Node& root, int& n)
{
    traverse_oY1L1zjI(root, id, n);
}

static void check_AoghKeFN(s_Node& node, const s_Node& root, int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_AoghKeFN(node.items.mutref(i), root, n);

    else
        count_fHNoj12y(node.id++, root, n);

}

static int PASS_borrowCheck_udfwGr55(s_Node& root)
{
    int n {};
    check_AoghKeFN(root, root, n);
    return n;
}

int fu_MAIN()
{
    s_Node tree = s_Node { 0, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 2, fu::vec<s_Node>{} } } } };
    return PASS_borrowCheck_udfwGr55(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

-----

        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but no implicits.
        fn count(id: i32, ref root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        // AAR: check(ref node, ref root) accepted,
        //       but (ref root, ref node) rejected.

        fn check(ref root: Node, ref node: Node) { 
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(:root, node.items[i]);                // PointlessMustSeq
            else
                count(:root, node.id++);
        }

        fn PASS_borrowCheck(ref root: Node) {
            implicit mut n: i32;
            check(:root, root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }

-----
#include <fu/vec.h>

struct s_Node;
static void check_dwGwJWsX(const s_Node&, s_Node&, int&);
inline static void traverse_oY1L1zjI(const s_Node&, int, int&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int id;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || id
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static void l_1_0_w9p5xQgp(const s_Node& i, const int id, int& n)
{
    if (i.id == id)
        n++;

}

inline static void traverse_oY1L1zjI(const s_Node& node, const int id, int& n)
{
    l_1_0_w9p5xQgp(node, id, n);
    for (int i = 0; i < node.items.size(); i++)
        traverse_oY1L1zjI(node.items[i], id, n);

}

static void count_fHNoj12y(const int id, const s_Node& root, int& n)
{
    traverse_oY1L1zjI(root, id, n);
}

static void check_dwGwJWsX(const s_Node& root, s_Node& node, int& n)
{
    if (node.items)
        for (int i = 0; i < node.items.size(); i++)
            check_dwGwJWsX(root, node.items.mutref(i), n);

    else
        count_fHNoj12y(node.id++, root, n);

}

static int PASS_borrowCheck_udfwGr55(s_Node& root)
{
    int n {};
    check_dwGwJWsX(root, root, n);
    return n;
}

int fu_MAIN()
{
    s_Node tree = s_Node { 0, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 2, fu::vec<s_Node>{} } } } };
    return PASS_borrowCheck_udfwGr55(tree) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_AARSoftRisk

-----

        pub fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn grow_if_oob_to_len_from_self(ref arr: i32[], idx: i32)
            arr.grow_if_oob(arr[idx]); // i was F_REF for some reason

        fn main() {
            mut arr = [3];
            arr.grow_if_oob_to_len_from_self(0) = 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 5;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_grow_if_oob_goXQqclcyN1
                                #define DEF_grow_if_oob_goXQqclcyN1
inline int& grow_if_oob_goXQqclc(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

int& grow_if_oob_to_len_from_self(fu::vec<int>& arr, const int idx)
{
    return grow_if_oob_goXQqclc(arr, arr[idx]);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 3 } };
    grow_if_oob_to_len_from_self(arr, 0) = 2;
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 5;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_ExternPrivates

-----

        fn used_in_a_loop__invalidated__by_new_var(
            ref arr: i32[], ref barr: i32[], ref carr: i32[])
        {
            ref head = arr[arr.len - 1];
            for (mut i = 0; i < arr.len; i++) {
                head += arr.len;
                let head_cpy = head + 0;
                ref barrcarr = barr || carr;
                barrcarr.resize(head_cpy);
            }
        }

        fn main() {
            mut arr = [ 1 ];


            ref barr = arr; 

            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);
            return barr.len == 2 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:58+4[0m:

[2m      |             ref barr = arr; [0m
[2m      | [0m
[2m   20 | [0m            used_in_a_loop__invalidated__by_new_var(arr, [31;1mbarr[0m, barr);
[2m      |             return barr.len == 2 ? 0 : 1;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mused_in_a_loop__invalidated__by_new_var[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mused_in_a_loop__invalidated__by_new_var[0m:[34;1mbarr[0m and
	    1:	[35;1mref arg[0m [34;1mused_in_a_loop__invalidated__by_new_var[0m:[34;1marr[0m

	    both alias:

	    [35;1mvar[0m [34;1marr[0m at [2m15:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   15 | [0m            mut [31;1marr[0m = [ 1 ];
[2m      | [0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mused_in_a_loop__invalidated__by_new_var[0m:[34;1mbarr[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mused_in_a_loop__invalidated__by_new_var[0m:[34;1marr[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m14:12+4[0m

-----

        fn used_in_a_loop__invalidated__by_new_var(
            ref arr: i32[], ref barr: i32[], ref carr: i32[])
        {
            ref head = arr[arr.len - 1];
            for (mut i = 0; i < arr.len; i++) {
                head += arr.len;
                let head_cpy = head + 0;
                ref barrcarr = barr || carr;
                barrcarr.resize(head_cpy);
            }
        }

        fn main() {
            mut arr = [ 1 ];


            mut barr = arr; 

            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);
            return barr.len == 2 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void used_in_a_loop__invalidated__by_new_var_YEBteqOz(fu::view_mut<int> arr, fu::vec<int>& barr, fu::vec<int>& carr)
{
    int& /*arr|static*/ head = arr.mutref((arr.size() - 1));
    for (int i = 0; i < arr.size(); i++)
    {
        head += arr.size();
        const int head_cpy = (head + 0);
        fu::vec<int>& /*carr|barr*/ barrcarr = (barr ? barr : carr);
        barrcarr.resize(head_cpy);
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 1 } };
    fu::vec<int> barr { arr };
    used_in_a_loop__invalidated__by_new_var_YEBteqOz(arr, barr, barr);
    if (barr.size() == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_AARSoftRisk

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];


            ref x = brr[0];               

            return two_writes_in_an_arg(arr, brr, x);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:51+1[0m:

[2m      |             ref x = brr[0];               [0m
[2m      | [0m
[2m   20 | [0m            return two_writes_in_an_arg(arr, brr, [31;1mx[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mtwo_writes_in_an_arg[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m and
	    2:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mbrr[0m

	    both alias:

	    [35;1mvar[0m [34;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr = [ 0, 1, 2, 3 ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m = [ 0, 2, 4, 6 ];
[2m      | [0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mbrr[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];


            mut x = 0;                    

            return two_writes_in_an_arg(arr, brr, x);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& grow_if_oob_goXQqclc(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static int& assign_CgkjrkbI(const int what, int& to)
{
    return (to = what);
}

static int& two_writes_in_an_arg_XZcL6MM4(fu::vec<int>& arr, fu::vec<int>& brr, int& x)
{
    return assign_CgkjrkbI((x ? grow_if_oob_goXQqclc(arr, 10) : grow_if_oob_goXQqclc(brr, 10)), x);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 0, 1, 2, 3 } };
    fu::vec<int> brr = fu::vec<int> { fu::slate<4, int> { 0, 2, 4, 6 } };
    int x = 0;
    return two_writes_in_an_arg_XZcL6MM4(arr, brr, x);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         <flip>
            mut zero = 0;
            mut empty: i32[];               <flip/>
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       </flip>


            ref x = brr[0];                 

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 25:58+8[0m:

[2m      |             ref opaque_brr  = brr.len > arr.len ? empty : brr;[0m
[2m      | [0m
[2m   25 | [0m            return two_writes_in_an_arg(arr, opaque_brr, [31;1mopaque_x[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mtwo_writes_in_an_arg[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m and
	    2:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mbrr[0m

	    both alias:

	    [35;1mvar[0m [34;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {                         [0m
[2m      |             mut arr = [ 0, 1, 2, 3 ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m = [ 0, 2, 4, 6 ];       
[2m      |             mut zero = 0;[0m
[2m      |             mut empty: i32[];               [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mbrr[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       
            mut zero = 0;
            mut empty: i32[];               


            mut x = 0;                      

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& grow_if_oob_goXQqclc(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static int& assign_CgkjrkbI(const int what, int& to)
{
    return (to = what);
}

static int& two_writes_in_an_arg_XZcL6MM4(fu::vec<int>& arr, fu::vec<int>& brr, int& x)
{
    return assign_CgkjrkbI((x ? grow_if_oob_goXQqclc(arr, 10) : grow_if_oob_goXQqclc(brr, 10)), x);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 0, 1, 2, 3 } };
    fu::vec<int> brr = fu::vec<int> { fu::slate<4, int> { 0, 2, 4, 6 } };
    int zero = 0;
    fu::vec<int> empty {};
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec<int>& /*empty|brr*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_XZcL6MM4(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         
            mut zero = 0;
            mut empty: i32[];               
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       


            mut x = 0;                      

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& grow_if_oob_goXQqclc(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static int& assign_CgkjrkbI(const int what, int& to)
{
    return (to = what);
}

static int& two_writes_in_an_arg_XZcL6MM4(fu::vec<int>& arr, fu::vec<int>& brr, int& x)
{
    return assign_CgkjrkbI((x ? grow_if_oob_goXQqclc(arr, 10) : grow_if_oob_goXQqclc(brr, 10)), x);
}

int fu_MAIN()
{
    int zero = 0;
    fu::vec<int> empty {};
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 0, 1, 2, 3 } };
    fu::vec<int> brr = fu::vec<int> { fu::slate<4, int> { 0, 2, 4, 6 } };
    int x = 0;
    int& /*x|zero*/ opaque_x = ((brr.size() > arr.size()) ? zero : x);
    fu::vec<int>& /*brr|empty*/ opaque_brr = ((brr.size() > arr.size()) ? empty : brr);
    return two_writes_in_an_arg_XZcL6MM4(arr, opaque_brr, opaque_x);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node { items: Node[] };

        fn main() {
            mut root = Node([
                Node([ Node, Node ])
            ]);


            swap(root.items[0], root);   // this is fine

            return root.items.len - 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:33+4[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            swap(root.items[0], [31;1mroot[0m);   // this is fine
[2m      | [0m
[2m      |             return root.items.len - 2;[0m

	At call to [35;1m__native[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m, arguments:

	    2:	[35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mroot[0m at [2m5:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    5 | [0m            mut [31;1mroot[0m = Node([
[2m      |                 Node([ Node, Node ])[0m
[2m      |             ]);[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1m
hacks/soft_risk
<utility>
std::swap[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct Node { items: Node[] };

        fn main() {
            mut root = Node([
                Node([ Node, Node ])
            ]);

 // write to root invalidates root.items[0]
            root = root.items[0];        // this is fine

            return root.items.len - 2;
        }

-----
#include <fu/vec.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Node root = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } } } } };
    root = root.items[0];
    return root.items.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref to: i32, ref what: i32) to = what;

        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])
            assign( to: x,  what: arr.grow_if_oob(10)           ;; !N_BckMustSeq
                               || brr.grow_if_oob(10));         ;; !N_MoveMustSeq

        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {
            two_writes_in_an_arg(

                    x || arr[0],              
                    :arr, :brr);

            return x;
        }

        fn main() {
            mut arr = [ 0 ];
            mut brr = [ 0 ];
            mut x   = 0;

            return test(:x, :arr, :brr);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 17:22+3[0m:

[2m      | [0m
[2m      |                     x || arr[0],              [0m
[2m   17 | [0m                    :[31;1marr[0m, :brr);
[2m      | [0m
[2m      |             return x;[0m

	At call to [35;1mfn[0m [34;1mtwo_writes_in_an_arg[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1marr[0m and
	    1:	[35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m

	    both alias:

	    [35;1mref arg[0m [34;1marr[0m at [2m13:33+3[0m:

[2m      |                                || brr.grow_if_oob(10));         // !N_MoveMustSeq[0m
[2m      | [0m
[2m   13 | [0m        fn test(ref x: i32, ref [31;1marr[0m: i32[], ref brr: i32[]) {
[2m      |             two_writes_in_an_arg([0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1marr[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mtwo_writes_in_an_arg[0m:[34;1mx[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(i32, i32[:], i32[:]) at [2m13:12+4[0m

-----

        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref to: i32, ref what: i32) to = what;

        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])
            assign( to: x,  what: arr.grow_if_oob(10)           // !N_BckMustSeq
                               || brr.grow_if_oob(10));         // !N_MoveMustSeq

        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {
            two_writes_in_an_arg(

                    x,                        
                    :arr, :brr);

            return x;
        }

        fn main() {
            mut arr = [ 0 ];
            mut brr = [ 0 ];
            mut x   = 0;

            return test(:x, :arr, :brr);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& grow_if_oob_goXQqclc(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static int& assign_zqf78Zce(int& to, const int what)
{
    return (to = what);
}

static int& two_writes_in_an_arg_7Y8BGljy(int& x, fu::vec<int>& arr, fu::vec<int>& brr)
{
    int _0 {};
    return assign_zqf78Zce(x, ((_0 = grow_if_oob_goXQqclc(arr, 10)) ? _0 : grow_if_oob_goXQqclc(brr, 10)));
}

static int& test_7Y8BGljy(int& x, fu::vec<int>& arr, fu::vec<int>& brr)
{
    two_writes_in_an_arg_7Y8BGljy(x, arr, brr);
    return x;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::vec<int> brr = fu::vec<int> { fu::slate<1, int> { 0 } };
    int x = 0;
    return test_7Y8BGljy(x, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];


            ref item = brr[0]; 

            return writes_to_two_args(:item, :arr, :brr);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 15:53+3[0m:

[2m      |             ref item = brr[0]; [0m
[2m      | [0m
[2m   15 | [0m            return writes_to_two_args(:item, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mwrites_to_two_args[0m, arguments:

	    3:	[35;1mref arg[0m [34;1mwrites_to_two_args[0m:[34;1mbrr[0m and
	    1:	[35;1mref arg[0m [34;1mwrites_to_two_args[0m:[34;1mitem[0m

	    both alias:

	    [35;1mvar[0m [34;1mbrr[0m at [2m10:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   10 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mwrites_to_two_args[0m:[34;1mbrr[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mwrites_to_two_args[0m:[34;1mitem[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m8:12+4[0m

-----

        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];


            mut item = brr[0]; 

            return writes_to_two_args(:item, :arr, :brr);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& writes_to_two_args_85QkSBY2(int& item, fu::vec<int>& arr, fu::vec<int>& brr)
{
    fu::vec<int>& /*brr|arr*/ arrbrr = (arr ? arr : brr);
    arrbrr.resize((100 + arrbrr.size()));
    return (item += arrbrr.size());
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int>{};
    fu::vec<int> brr = fu::vec<int> { fu::slate<1, int> { -101 } };
    int item = brr[0];
    return writes_to_two_args_85QkSBY2(item, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            ref item = left || right;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            ref right = brr[0]; 

            return reads_from_two_args(:left, :right, :arr, :brr);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:62+3[0m:

[2m      |             ref right = brr[0]; [0m
[2m      | [0m
[2m   18 | [0m            return reads_from_two_args(:left, :right, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mreads_from_two_args[0m, arguments:

	    4:	[35;1mref arg[0m [34;1mreads_from_two_args[0m:[34;1mbrr[0m and
	    2:	[35;1mref arg[0m [34;1mreads_from_two_args[0m:[34;1mright[0m

	    both alias:

	    [35;1mvar[0m [34;1mbrr[0m at [2m11:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   11 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      |             mut left = 0;[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mreads_from_two_args[0m:[34;1mbrr[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mreads_from_two_args[0m:[34;1mright[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m9:12+4[0m

-----

        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            ref item = left || right;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            mut right = brr[0]; 

            return reads_from_two_args(:left, :right, :arr, :brr);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& reads_from_two_args_XcqSeNuo(int& left, int& right, fu::vec<int>& arr, fu::vec<int>& brr)
{
    fu::vec<int>& /*brr|arr*/ arrbrr = (arr ? arr : brr);
    int& /*right|left*/ item = (left ? left : right);
    arrbrr.resize((100 + arrbrr.size()));
    return (item += arrbrr.size());
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int>{};
    fu::vec<int> brr = fu::vec<int> { fu::slate<1, int> { -101 } };
    int left = 0;
    int right = brr[0];
    return reads_from_two_args_XcqSeNuo(left, right, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn grow(ref arr: i32[], by!n: i32) {
            arr.resize(arr.len + n);
            return arr;
        }

        fn incr__ltr_oee(ref what: i32, by: i32)
            what += by;

        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])
            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            ref right = brr[0]; 

            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 22:75+3[0m:

[2m      |             ref right = brr[0]; [0m
[2m      | [0m
[2m   22 | [0m            return reads_from_two_args__single_expr(:left, :right, :arr, :[31;1mbrr[0m);
[2m      |         }[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mreads_from_two_args__single_expr[0m, arguments:

	    4:	[35;1mref arg[0m [34;1mreads_from_two_args__single_expr[0m:[34;1mbrr[0m and
	    2:	[35;1mref arg[0m [34;1mreads_from_two_args__single_expr[0m:[34;1mright[0m

	    both alias:

	    [35;1mvar[0m [34;1mbrr[0m at [2m15:17+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut arr: i32[] = [      ];[0m
[2m   15 | [0m            mut [31;1mbrr[0m: i32[] = [ -101 ];
[2m      | [0m
[2m      |             mut left = 0;[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mreads_from_two_args__single_expr[0m:[34;1mbrr[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mreads_from_two_args__single_expr[0m:[34;1mright[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn grow(ref arr: i32[], by!n: i32) {
            arr.resize(arr.len + n);
            return arr;
        }

        fn incr__ltr_oee(ref what: i32, by: i32)
            what += by;

        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])
            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;


            mut right = brr[0]; 

            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static fu::vec<int>& grow_9qWG4AFx(fu::vec<int>& arr, const int n)
{
    arr.resize((arr.size() + n));
    return arr;
}

static int& incr__ltr_oee_m2WdF2cF(int& what, const int by)
{
    return (what += by);
}

static int& reads_from_two_args__single_expr_XcqSeNuo(int& left, int& right, fu::vec<int>& arr, fu::vec<int>& brr)
{
    return incr__ltr_oee_m2WdF2cF((left ? left : right), grow_9qWG4AFx((arr ? arr : brr), 100).size());
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int>{};
    fu::vec<int> brr = fu::vec<int> { fu::slate<1, int> { -101 } };
    int left = 0;
    int right = brr[0];
    return reads_from_two_args__single_expr_XcqSeNuo(left, right, arr, brr);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut arr = [ 1,1,1,1,1 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(view, fn) {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |i| sum += 
                            (i *= 2)            ;

            return sum - 10;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:17+5[0m:

[2m      |             }[0m
[2m      | [0m
[2m   16 | [0m            arr.[31;1mveach[0m: |i| sum += 
[2m      |                             (i *= 2)            ;[0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mveach[0m, arguments:

	    3:	[35;1minjected implicit ref arg[0m [34;1mveach[0m:[34;1mmain:arr[0m and
	    1:	[35;1mref arg[0m [34;1mveach[0m:[34;1mview[0m

	    both alias:

	    [35;1mvar[0m [34;1marr[0m at [2m3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            mut [31;1marr[0m = [ 1,1,1,1,1 ];
[2m      |             mut sum = 0;[0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1minjected implicit ref arg[0m [34;1mveach[0m:[34;1mmain:arr[0m is [31;1mimplicit[0m

	    [35;1mref arg[0m [34;1mveach[0m:[34;1mview[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut arr = [ 1,1,1,1,1 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(view, fn) {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |i| sum += 
                            (i  * 2)            ;

            return sum - 10;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_Y1bpls16(const int i, int& sum)
{
    return (sum += (i * 2));
}

inline static void veach_c7i4DSUt(fu::view<int> view, fu::vec<int>& arr, int& sum)
{
    for (int i = 0; i < view.size(); i++)
    {
        l_1_0_Y1bpls16(view[i], sum);
        arr += fu::vec<int>(arr);
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<5, int> { 1, 1, 1, 1, 1 } };
    int sum = 0;
    veach_c7i4DSUt(fu::vec<int>(arr), arr, sum);
    return sum - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }

        import _0;

        fn ensureParsed(fname: string) {
            let module = getModule(fname);
            if (!module.in)
                return getFile(fname).len

                    || module.in.len;


            return module.in.len;
        }

        fn main() {
            implicit mut ctx: Context;
            return ensureParsed("a") - 4;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 9:24+6[0m:

[2m      |                 return getFile(fname).len[0m
[2m      | [0m
[2m    9 | [0m                    || [31;1mmodule[0m.in.len;
[2m      | [0m
[2m      | [0m

	Cannot access [35;1mvar[0m [34;1mmodule[0m, reference invalidated by write to [35;1minjected implicit arg[0m [34;1mctx[0m at [2m7:31+1[0m:

[2m      |             let module = getModule(fname);[0m
[2m      |             if (!module.in)[0m
[2m    7 | [0m                return getFile[31;1m([0mfname).len
[2m      | [0m
[2m      |                     || module.in.len;[0m

	At call to [35;1mfn[0m [34;1mgetFile[0m
            via [35;1m__native[0m [34;1m
.mutref[0m at [2m[0m_0[2m.fu 14:39+1[0m:

[2m      |             for (mut i = 0; i < ctx.modules.len; i++)[0m
[2m      |                 if (ctx.modules[i].fname == fname)[0m
[2m   14 | [0m                    return ctx.modules[31;1m[[0mi].in;
[2m      | [0m
[2m      |             ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');[0m


    BorrowCheck [35;1mfn[0m [34;1mensureParsed[0m(string) at [2m4:12+12[0m

-----

        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_Context;
struct s_Module;

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::vec<s_Module> modules;
    s_Context(const s_Context&) = delete;
    s_Context(s_Context&&) = default;
    s_Context& operator=(const s_Context&) = delete;
    s_Context& operator=(s_Context&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    fu::str in;
    fu::str fname;
    s_Module(const s_Module&) = delete;
    s_Module(s_Module&&) = default;
    s_Module& operator=(const s_Module&) = delete;
    s_Module& operator=(s_Module&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || in
            || fname
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

fu::str& getFile_g17PqWkK(const fu::str& fname, s_Context& ctx)
{
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        if (ctx.modules[i].fname == fname)
            return ctx.modules.mutref(i).in;

    };
    ctx.modules += s_Module { (((fname + '\n') + fname) + '\n'), fu::str(fname) };
    return ctx.modules.mutref((ctx.modules.size() - 1)).in;
}

const s_Module& getModule_2tm7WLS5(fu::view<char> fname, const s_Context& ctx)
{
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    };
    return (*(const s_Module*)fu::NIL);
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\n' ~ fname ~ '\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }

        import _0;

        fn ensureParsed(fname: string) {
            let module = getModule(fname);
            if (!module.in)
                return getFile(fname).len

                    || throw(fname);


            return module.in.len;
        }

        fn main() {
            implicit mut ctx: Context;
            return ensureParsed("a") - 4;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Context;
struct s_Module;
const s_Module& getModule_2tm7WLS5(fu::view<char>, const s_Context&);
fu::str& getFile_g17PqWkK(const fu::str&, s_Context&);

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::vec<s_Module> modules;
    s_Context(const s_Context&) = delete;
    s_Context(s_Context&&) = default;
    s_Context& operator=(const s_Context&) = delete;
    s_Context& operator=(s_Context&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    fu::str in;
    fu::str fname;
    s_Module(const s_Module&) = delete;
    s_Module(s_Module&&) = default;
    s_Module& operator=(const s_Module&) = delete;
    s_Module& operator=(s_Module&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || in
            || fname
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int ensureParsed_hVgfwcpy(const fu::str& fname, s_Context& ctx)
{
    const s_Module& /*ctx|static*/ module = getModule_2tm7WLS5(fname, ctx);
    if (!module.in)
    {
        int _0 {};
        return (_0 = getFile_g17PqWkK(fname, ctx).size()) ? _0 : fu::fail(fu::str(fname));
    }
    else
        return module.in.size();

}

int fu_MAIN()
{
    s_Context ctx {};
    return ensureParsed_hVgfwcpy("a"_fu, ctx) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        nocopy struct NCThing {
            items: i32[];
        };

        fn mut_in_loop_before_break(ref thing: NCThing) {
            mut sum = 0;

            ref items = thing.items;
            for (mut i = 0; i < items.len; i++)
            {
                sum += items[i];
                if (sum > 10)
                {
                    thing = NCThing();

                    if (sum > 20)                                   
                        break;
                }

                items[i] *= 2;
            }

            return sum;
        }

        fn main() {
            mut thing = NCThing([ 10 ]);
            return mut_in_loop_before_break(thing)
                 + mut_in_loop_before_break(thing)
                 - 30
                 + thing.items.len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 15:27+1[0m:

[2m      |                 if (sum > 10)[0m
[2m      |                 {[0m
[2m   15 | [0m                    thing [31;1m=[0m NCThing();
[2m      | [0m
[2m      |                     if (sum > 20)                                   [0m

	Write to [35;1mref arg[0m [34;1mthing[0m at call to [35;1m__native[0m [34;1m=[0m invalidates the use of [35;1mref[0m [34;1mitems[0m at [2m10:33+5[0m:

[2m      | [0m
[2m      |             ref items = thing.items;[0m
[2m   10 | [0m            for (mut i = 0; i < [31;1mitems[0m.len; i++)
[2m      |             {[0m
[2m      |                 sum += items[i];[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mmut_in_loop_before_break[0m(NCThing) at [2m6:12+24[0m

-----

        nocopy struct NCThing {
            items: i32[];
        };

        fn mut_in_loop_before_break(ref thing: NCThing) {
            mut sum = 0;

            ref items = thing.items;
            for (mut i = 0; i < items.len; i++)
            {
                sum += items[i];
                if (sum > 10)
                {
                    thing = NCThing();

                    if (true)                                       
                        break;
                }

                items[i] *= 2;
            }

            return sum;
        }

        fn main() {
            mut thing = NCThing([ 10 ]);
            return mut_in_loop_before_break(thing)
                 + mut_in_loop_before_break(thing)
                 - 30
                 + thing.items.len;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_NCThing;

                                #ifndef DEF_s_NCThing
                                #define DEF_s_NCThing
struct s_NCThing
{
    fu::vec<int> items;
    s_NCThing(const s_NCThing&) = delete;
    s_NCThing(s_NCThing&&) = default;
    s_NCThing& operator=(const s_NCThing&) = delete;
    s_NCThing& operator=(s_NCThing&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int mut_in_loop_before_break_9fP2ZbCu(s_NCThing& thing)
{
    int sum = 0;
    fu::view_mut<int> /*thing*/ items = thing.items;
    for (int i = 0; i < items.size(); i++)
    {
        sum += items[i];
        if (sum > 10)
        {
            thing = s_NCThing{};
            break;
        }
        else
            items.mutref(i) *= 2;

    };
    return sum;
}

int fu_MAIN()
{
    s_NCThing thing = s_NCThing { fu::vec<int> { fu::slate<1, int> { 10 } } };
    int _0 {};
    int _1 {};
    return (_1 = ((_0 = mut_in_loop_before_break_9fP2ZbCu(thing), (_0 + mut_in_loop_before_break_9fP2ZbCu(thing))) - 30), (_1 + thing.items.size()));
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec, N_BckMustSeq

-----

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            ref x = xy.x;                                   

            pragma emit(`
                `xy`.x++;
            `);

            return x - 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 13:20+1[0m:

[2m      |             `);[0m
[2m      | [0m
[2m   13 | [0m            return [31;1mx[0m - 1;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mx[0m, reference invalidated by write to [35;1mvar[0m [34;1mxy[0m at [2m10:18+2[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m   10 | [0m                `[31;1mxy[0m`.x++;
[2m      |             `);[0m
[2m      | [0m

	via pragma [34;1memit[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            fn  x = xy.x;                                   

            pragma emit(`
                `xy`.x++;
            `);

            return x - 1;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& x_V6uTIUa3(s_XY& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    s_XY xy {};

                xy.x++;

    return x_V6uTIUa3(xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            ref x = xy.x;                  

            while (!x)
                pragma emit(`
                    `xy`.x++;
                `);

            return xy.x - 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:22+2[0m:

[2m      |             while (!x)[0m
[2m      |                 pragma emit(`[0m
[2m   11 | [0m                    `[31;1mxy[0m`.x++;
[2m      |                 `);[0m
[2m      | [0m

	Write to [35;1mvar[0m [34;1mxy[0m invalidates the use of [35;1mref[0m [34;1mx[0m at [2m9:21+1[0m:

[2m      |             ref x = xy.x;                  [0m
[2m      | [0m
[2m    9 | [0m            while (![31;1mx[0m)
[2m      |                 pragma emit(`[0m
[2m      |                     `xy`.x++;[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;

            fn  x = xy.x;                  

            while (!x)
                pragma emit(`
                    `xy`.x++;
                `);

            return xy.x - 1;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& x_V6uTIUa3(s_XY& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    s_XY xy {};
    while (!x_V6uTIUa3(xy))

                    xy.x++;
;
    return xy.x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct XY { x: i32; y: i32 };

        fn bckErr_fromPragmaEmit(ref xy: XY) {
            pragma emit(`
                `xy`.x++;
            `);
        }

        fn main() {
            mut xy: XY;

            ref x = xy.x;        

            bckErr_fromPragmaEmit(xy);
            return x - 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:20+1[0m:

[2m      | [0m
[2m      |             bckErr_fromPragmaEmit(xy);[0m
[2m   16 | [0m            return [31;1mx[0m - 1;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mx[0m, reference invalidated by write to [35;1mvar[0m [34;1mxy[0m at [2m15:34+1[0m:

[2m      |             ref x = xy.x;        [0m
[2m      | [0m
[2m   15 | [0m            bckErr_fromPragmaEmit[31;1m([0mxy);
[2m      |             return x - 1;[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mbckErr_fromPragmaEmit[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m10:12+4[0m

-----

        struct XY { x: i32; y: i32 };

        fn bckErr_fromPragmaEmit(ref xy: XY) {
            pragma emit(`
                `xy`.x++;
            `);
        }

        fn main() {
            mut xy: XY;

            fn  x = xy.x;        

            bckErr_fromPragmaEmit(xy);
            return x - 1;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void bckErr_fromPragmaEmit_dW0JKsNh(s_XY& xy)
{

                xy.x++;

}

static int& x_fwJRfWgj(s_XY& xy)
{
    return xy.x;
}

int fu_MAIN()
{
    s_XY xy {};
    bckErr_fromPragmaEmit_dW0JKsNh(xy);
    return x_fwJRfWgj(xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct XY { x: i32; y: i32 };

        fn test(ref xy: XY, ref zw: XY) {

            ref x = xy.x;                                   

            pragma emit(`
                `xy || zw`.x++;
            `);

            return x;
        }

        fn main() {
            mut xy: XY;
            return test(xy, xy) - 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:20+1[0m:

[2m      |             `);[0m
[2m      | [0m
[2m   12 | [0m            return [31;1mx[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mx[0m, reference invalidated by write to [35;1mref arg[0m [34;1mxy[0m at [2m9:21+2[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m    9 | [0m                `xy [31;1m||[0m zw`.x++;
[2m      |             `);[0m
[2m      | [0m

	via pragma [34;1memit[0m

    BorrowCheck [35;1mfn[0m [34;1mtest[0m(XY, XY) at [2m4:12+4[0m

-----

        struct XY { x: i32; y: i32 };

        fn test(ref xy: XY, ref zw: XY) {

            fn  x = xy.x;                                   

            pragma emit(`
                `xy || zw`.x++;
            `);

            return x;
        }

        fn main() {
            mut xy: XY;
            return test(xy, xy) - 1;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& x_fwJRfWgj(s_XY& xy)
{
    return xy.x;
}

static int& test_nxSke1hP(s_XY& xy, s_XY& zw)
{

                (xy ? xy : zw).x++;

    return x_fwJRfWgj(xy);
}

int fu_MAIN()
{
    s_XY xy {};
    return test_nxSke1hP(xy, xy) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_AARSoftRisk

-----

        struct Ext { ext: Ext[] };

        fn EXT(implicit ext: Ext[], a: i32) ext[a];

        fn EXT_insert(implicit ref ext: Ext[], a: i32) {
            ext.insert(a, Ext());
            return ext[a];
        }

        fn solveTypedef(a: i32, b: i32) EXT_insert(a) = EXT(b);

        fn main() {
            implicit mut ext = [ Ext([ Ext, Ext ]) ];

            for (mut i = 0; i < 128; i++)
                solveTypedef(0, 0);

            return ext[0].ext.len == 2 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Ext;

                                #ifndef DEF_s_Ext
                                #define DEF_s_Ext
struct s_Ext
{
    fu::vec<s_Ext> ext;
    s_Ext(const s_Ext&) = default;
    s_Ext(s_Ext&&) = default;
    s_Ext& operator=(s_Ext&&) = default;
    s_Ext& operator=(const s_Ext& selfrec) { return *this = s_Ext(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || ext
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Ext& EXT_WEILL3SL(const int a, fu::view<s_Ext> ext)
{
    return ext[a];
}

static s_Ext& EXT_insert_Gaxvo5ZX(const int a, fu::vec<s_Ext>& ext)
{
    ext.insert(a, s_Ext{});
    return ext.mutref(a);
}

static s_Ext& solveTypedef_qpe9E4C5(const int a, const int b, fu::vec<s_Ext>& ext)
{
    return (EXT_insert_Gaxvo5ZX(a, ext) = s_Ext(EXT_WEILL3SL(b, ext)));
}

int fu_MAIN()
{
    fu::vec<s_Ext> ext = fu::vec<s_Ext> { fu::slate<1, s_Ext> { s_Ext { fu::vec<s_Ext> { fu::slate<2, s_Ext> { s_Ext{}, s_Ext{} } } } } };
    for (int i = 0; i < 128; i++)
        solveTypedef_qpe9E4C5(0, 0, ext);

    if (ext[0].ext.size() == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn ints(implicit ref _ints: i32[]) _ints;
        fn sum (implicit ref _sum:  i32)   _sum;

        // while trying to sort implicit args i noticed tests didnt catch
        //  args getting reordered but AAR masks not updating
        //   this tries to reproduce the same thing
        fn flippedInjectedArgsWithBrokenAARMasks()
            if (sum) // the point of this is to inject _sum before _ints
                for (mut i = ints.len; i --> 0; )
                    ints.push(sum);

        fn main() {
            implicit mut _ints: i32[] = [ 0 ];

            implicit ref _sum = _ints[0];


            flippedInjectedArgsWithBrokenAARMasks();
            return ints[0];
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 19:50+1[0m:

[2m      | [0m
[2m      | [0m
[2m   19 | [0m            flippedInjectedArgsWithBrokenAARMasks[31;1m([0m);
[2m      |             return ints[0];[0m
[2m      |         }[0m

	At call to [35;1mfn[0m [34;1mflippedInjectedArgsWithBrokenAARMasks[0m, arguments:

	    2:	[35;1minjected implicit ref arg[0m [34;1mflippedInjectedArgsWithBrokenAARMasks[0m:[34;1m_sum[0m and
	    1:	[35;1minjected implicit ref arg[0m [34;1mflippedInjectedArgsWithBrokenAARMasks[0m:[34;1m_ints[0m

	    both alias:

	    [35;1mimplicit[0m [34;1m_ints[0m at [2m14:26+5[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            implicit mut [31;1m_ints[0m: i32[] = [ 0 ];
[2m      | [0m
[2m      |             implicit ref _sum = _ints[0];[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1minjected implicit ref arg[0m [34;1mflippedInjectedArgsWithBrokenAARMasks[0m:[34;1m_sum[0m is [31;1mimplicit[0m

	    [35;1minjected implicit ref arg[0m [34;1mflippedInjectedArgsWithBrokenAARMasks[0m:[34;1m_ints[0m is [31;1mimplicit[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn ints(implicit ref _ints: i32[]) _ints;
        fn sum (implicit ref _sum:  i32)   _sum;

        // while trying to sort implicit args i noticed tests didnt catch
        //  args getting reordered but AAR masks not updating
        //   this tries to reproduce the same thing
        fn flippedInjectedArgsWithBrokenAARMasks()
            if (sum) // the point of this is to inject _sum before _ints
                for (mut i = ints.len; i --> 0; )
                    ints.push(sum);

        fn main() {
            implicit mut _ints: i32[] = [ 0 ];

            implicit mut _sum = 0;


            flippedInjectedArgsWithBrokenAARMasks();
            return ints[0];
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int& sum_mjwKrs6g(int& _sum)
{
    return _sum;
}

static fu::vec<int>& ints_RTajYs0X(fu::vec<int>& _ints)
{
    return _ints;
}

static void flippedInjectedArgsWithBrokenAARMasks_A8RzI0lh(fu::vec<int>& _ints, int& _sum)
{
    if (sum_mjwKrs6g(_sum))
        for (int i = ints_RTajYs0X(_ints).size(); i-- > 0; )
            ints_RTajYs0X(_ints).push(sum_mjwKrs6g(_sum));
;
}

int fu_MAIN()
{
    fu::vec<int> _ints = fu::vec<int> { fu::slate<1, int> { 0 } };
    int _sum = 0;
    flippedInjectedArgsWithBrokenAARMasks_A8RzI0lh(_ints, _sum);
    return ints_RTajYs0X(_ints)[0];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Node {
            nodes: Node[];
        };

        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {
            for (mut i = 0; i < 100; i++)
                willPush.nodes ~= pushWhat;
        }

        noinline fn clear_and_return_ref_to_self(ref node: Node) {
            node.nodes.clear();
            return node;
        }

        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {
            return append_a_onto_b_100_times(
                // indexes inside, should crash
                willPush.nodes[0],
                // empties the nodes
                clear_and_return_ref_to_self(willEmpty));
        }

        fn main() {
            mut willEmpty: Node = [[ Node() ]];


            crash_if_b_refs_into_a(willEmpty, willEmpty);


            return willEmpty.nodes.len == 0 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 28:47+9[0m:

[2m      | [0m
[2m      | [0m
[2m   28 | [0m            crash_if_b_refs_into_a(willEmpty, [31;1mwillEmpty[0m);
[2m      | [0m
[2m      | [0m

	At call to [35;1mfn[0m [34;1mcrash_if_b_refs_into_a[0m, arguments:

	    2:	[35;1mref arg[0m [34;1mcrash_if_b_refs_into_a[0m:[34;1mwillPush[0m and
	    1:	[35;1mref arg[0m [34;1mcrash_if_b_refs_into_a[0m:[34;1mwillEmpty[0m

	    both alias:

	    [35;1mvar[0m [34;1mwillEmpty[0m at [2m25:17+9[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   25 | [0m            mut [31;1mwillEmpty[0m: Node = [[ Node() ]];
[2m      | [0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1mcrash_if_b_refs_into_a[0m:[34;1mwillPush[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1mcrash_if_b_refs_into_a[0m:[34;1mwillEmpty[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m24:12+4[0m

-----

        struct Node {
            nodes: Node[];
        };

        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {
            for (mut i = 0; i < 100; i++)
                willPush.nodes ~= pushWhat;
        }

        noinline fn clear_and_return_ref_to_self(ref node: Node) {
            node.nodes.clear();
            return node;
        }

        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {
            return append_a_onto_b_100_times(
                // indexes inside, should crash
                willPush.nodes[0],
                // empties the nodes
                clear_and_return_ref_to_self(willEmpty));
        }

        fn main() {
            mut willEmpty: Node = [[ Node() ]];


            mut willPush = willEmpty;
            crash_if_b_refs_into_a(willEmpty, willPush);


            return willEmpty.nodes.len == 0 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> nodes;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Node& clear_and_return_ref_to_self_koyApVmb(s_Node& node)
{
    node.nodes.clear();
    return node;
}

static void append_a_onto_b_100_times_DG2MHRHo(s_Node& willPush, const s_Node& pushWhat)
{
    for (int i = 0; i < 100; i++)
        willPush.nodes += s_Node(pushWhat);

}

static void crash_if_b_refs_into_a_b1UlEZhp(s_Node& willEmpty, s_Node& willPush)
{
    const s_Node* _0;
    (_0 = &(clear_and_return_ref_to_self_koyApVmb(willEmpty)), append_a_onto_b_100_times_DG2MHRHo(willPush.nodes.mutref(0), *_0));
}

int fu_MAIN()
{
    s_Node willEmpty = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } };
    s_Node willPush { willEmpty };
    crash_if_b_refs_into_a_b1UlEZhp(willEmpty, willPush);
    if (willEmpty.nodes.size() == 0)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_AARMustSeq, N_COWRestrict

-----

        struct Node { nodes: Node[] };

        noinline fn soft_risk_inner(ref a: Node, ref b: Node)
            for (mut i = 0; i < 100; i++)
                a.nodes ~= b;

        noinline fn soft_risk_outer(ref a: Node, ref b: Node)
            soft_risk_inner(a, b.nodes[0]);

        fn main() {
            mut root = Node([ Node ]);


            soft_risk_outer(root, root);    

            return root.nodes.len == 101 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 15:35+4[0m:

[2m      | [0m
[2m      | [0m
[2m   15 | [0m            soft_risk_outer(root, [31;1mroot[0m);    
[2m      | [0m
[2m      |             return root.nodes.len == 101 ? 0 : 1;[0m

	At call to [35;1mfn[0m [34;1msoft_risk_outer[0m, arguments:

	    2:	[35;1mref arg[0m [34;1msoft_risk_outer[0m:[34;1mb[0m and
	    1:	[35;1mref arg[0m [34;1msoft_risk_outer[0m:[34;1ma[0m

	    both alias:

	    [35;1mvar[0m [34;1mroot[0m at [2m12:17+4[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   12 | [0m            mut [31;1mroot[0m = Node([ Node ]);
[2m      | [0m
[2m      | [0m

	Can't resolve aliasing by a temporary copy:

	    [35;1mref arg[0m [34;1msoft_risk_outer[0m:[34;1mb[0m is [31;1mref[0m

	    [35;1mref arg[0m [34;1msoft_risk_outer[0m:[34;1ma[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m11:12+4[0m

-----

        struct Node { nodes: Node[] };

        noinline fn soft_risk_inner(ref a: Node, ref b: Node)
            for (mut i = 0; i < 100; i++)
                a.nodes ~= b;

        noinline fn soft_risk_outer(ref a: Node, ref b: Node)
            soft_risk_inner(a, b.nodes[0]);

        fn main() {
            mut root = Node([ Node ]);


            mut cpy = root;
            soft_risk_outer(root, cpy);     

            return root.nodes.len == 101 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> nodes;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void soft_risk_inner_Io4ErUeR(s_Node& a, const s_Node& b)
{
    for (int i = 0; i < 100; i++)
        a.nodes += s_Node(b);

}

static void soft_risk_outer_IfykyfS6(s_Node& a, const s_Node& b)
{
    soft_risk_inner_Io4ErUeR(a, b.nodes[0]);
}

int fu_MAIN()
{
    s_Node root = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } };
    s_Node cpy { root };
    soft_risk_outer_IfykyfS6(root, cpy);
    if (root.nodes.size() == 101)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        struct ScopeItem { k: string; v: i32 };

        fn dequalify_andGetScope(ref id: string, implicit locals: ScopeItem[], implicit globals: ScopeItem[]) {
            if (id.ends(with: "g")) {
                id.pop();
                return globals;
            }

            return locals;
        }

        fn solveAddrOfFn(mut id: string) {
            fn visitScope(items: ScopeItem[]) {
                items.each: |item|
                    if (item.k == id)
                        return item.v;

                return -1;
            }

            // on gcc visitScope:id bound to a slice before mutation
            return visitScope(dequalify_andGetScope(id));       // N_BckMustSeq
        }

        fn main() {
            let implicit locals  = [ ScopeItem("a", 1), ScopeItem("b", 2), ScopeItem("c", 3) ];
            let implicit globals = [ ScopeItem("a", 10), ScopeItem("b", 20), ScopeItem("c", 30) ];
            let result = solveAddrOfFn("a") + solveAddrOfFn("bg");
            return result == 21 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_ScopeItem;

                                #ifndef DEF_s_ScopeItem
                                #define DEF_s_ScopeItem
struct s_ScopeItem
{
    fu::str k;
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_ends_t2TApdnqRc8
                                #define DEF_ends_t2TApdnqRc8
inline bool ends_t2TApdnq(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

static const fu::vec<s_ScopeItem>& dequalify_andGetScope_5oEMRhR1(fu::str& id, const fu::vec<s_ScopeItem>& locals, const fu::vec<s_ScopeItem>& globals)
{
    if (ends_t2TApdnq(id, "g"_fu))
    {
        id.pop();
        return globals;
    }
    else
        return locals;

}

static int visitScope_YxdmSKN3(fu::view<s_ScopeItem> items, fu::view<char> id)
{
    for (int i = 0; i < items.size(); i++)
    {
        const s_ScopeItem& /*items|static*/ item = items[i];
        if (item.k == id)
            return item.v;

    };
    return -1;
}

static int solveAddrOfFn_5rvWxAwL(fu::str&& id, const fu::vec<s_ScopeItem>& globals, const fu::vec<s_ScopeItem>& locals)
{
    fu::view<s_ScopeItem> _0 {};
    return (_0 = dequalify_andGetScope_5oEMRhR1(id, locals, globals), visitScope_YxdmSKN3(static_cast<fu::view<s_ScopeItem>&&>(_0), id));
}

int fu_MAIN()
{
    fu::vec<s_ScopeItem> locals = fu::vec<s_ScopeItem> { fu::slate<3, s_ScopeItem> { s_ScopeItem { "a"_fu, 1 }, s_ScopeItem { "b"_fu, 2 }, s_ScopeItem { "c"_fu, 3 } } };
    fu::vec<s_ScopeItem> globals = fu::vec<s_ScopeItem> { fu::slate<3, s_ScopeItem> { s_ScopeItem { "a"_fu, 10 }, s_ScopeItem { "b"_fu, 20 }, s_ScopeItem { "c"_fu, 30 } } };
    const int result = (solveAddrOfFn_5rvWxAwL("a"_fu, globals, locals) + solveAddrOfFn_5rvWxAwL("bg"_fu, globals, locals));
    if (result == 21)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

-----

        fn cmp_ooe(mut stuff: i32[], ref needSort: bool) {
            mut result: i32[] = [];
            mut last = -1;
            for (mut i = 0; i < stuff.len; i++) {
                let t = stuff[i];
                if !(t & 1) continue;
                if (last > (last = t)) needSort = true;
                result ~= t;
            }

            if (needSort) result.sort();
            return result;
        }

        fn checksum(stuff: i32[]) {
            mut result = 0;
            for (mut i = 0; i < stuff.len; i++) {
                result *= stuff[i];
                result += stuff[i];
            }
            return result;
        }

        fn main() {
            mut needSort = false;
            let aa = checksum(cmp_ooe([1, 2, 3, 4, 5], :needSort));
            let bb = !needSort
                  && checksum(cmp_ooe([7, 4, 3, 2, 1], :needSort));

            return needSort ? aa * 100 + bb - 3549 : 1;
        }

-----
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_sort_RLEM4CuK8dj
                                #define DEF_sort_RLEM4CuK8dj
inline void sort_RLEM4CuK(fu::vec<int>& a)
{
    auto* data = a.data_mut();
    std::sort(data, data + a.size());

}
                                #endif

static fu::vec<int> cmp_ooe_Uoo3j2QV(fu::vec<int>&& stuff, bool& needSort)
{
    /*MOV*/ fu::vec<int> result {};
    int last = -1;
    for (int i = 0; i < stuff.size(); i++)
    {
        const int /*stuff|static*/ t = stuff[i];
        if (!(!(t & 1)))
        {
            int _0 {};
            if ((_0 = last, (_0 > (last = t))))
                needSort = true;

            result += t;
        };
    };
    if (needSort)
        sort_RLEM4CuK(result);

    return /*NRVO*/ result;
}

static int checksum_wBhgqTFU(fu::view<int> stuff)
{
    int result = 0;
    for (int i = 0; i < stuff.size(); i++)
    {
        result *= stuff[i];
        result += stuff[i];
    };
    return result;
}

int fu_MAIN()
{
    bool needSort = false;
    const int aa = checksum_wBhgqTFU(cmp_ooe_Uoo3j2QV(fu::vec<int> { fu::slate<5, int> { 1, 2, 3, 4, 5 } }, needSort));
    const int bb = (!needSort ? checksum_wBhgqTFU(cmp_ooe_Uoo3j2QV(fu::vec<int> { fu::slate<5, int> { 7, 4, 3, 2, 1 } }, needSort)) : 0);
    if (needSort)
        return ((aa * 100) + bb) - 3549;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

-----

        fn clearAndReturn(ref a: i32[]) {
            a.clear();
            return a;
        }


        fn refOOE(b: i32[], ref a: i32[]) 
            a ~= b;

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
            refOOE(a: clearAndReturn(ints), b: ints);
            return ints.len - 10;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec<int>& clearAndReturn_RUAdctTw(fu::vec<int>& a)
{
    a.clear();
    return a;
}

static fu::vec<int>& refOOE_b6BHpeNi(fu::view<int> b, fu::vec<int>& a)
{
    return (a += b);
}

int fu_MAIN()
{
    fu::vec<int> ints = fu::vec<int> { fu::slate<10, int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } };
    fu::vec<int> _0 {};
    (_0 = fu::vec<int>(ints), refOOE_b6BHpeNi(static_cast<fu::vec<int>&&>(_0), clearAndReturn_RUAdctTw(ints)));
    return ints.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        fn clearAndReturn(ref a: i32[]) {
            a.clear();
            return a;
        }


        fn refOOE(ref a: i32[], b: i32[]) 
            a ~= b;

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
            refOOE(a: clearAndReturn(ints), b: ints);
            return ints.len - 10;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::vec<int>& clearAndReturn_RUAdctTw(fu::vec<int>& a)
{
    a.clear();
    return a;
}

static fu::vec<int>& refOOE_tPQwHJmw(fu::vec<int>& a, fu::view<int> b)
{
    return (a += b);
}

int fu_MAIN()
{
    fu::vec<int> ints = fu::vec<int> { fu::slate<10, int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } };
    fu::vec<int> _0 {};
    (_0 = fu::vec<int>(ints), refOOE_tPQwHJmw(clearAndReturn_RUAdctTw(ints), static_cast<fu::vec<int>&&>(_0)));
    return ints.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq

-----

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                nodes = nodes.map(|lax n| Node(zero));


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_Node;
struct s_Type;
inline int x3Cx3E_PIVYC7gZ(const s_Type&, const s_Type&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<s_Type> nontriv;
    s_Type(const s_Type&) = default;
    s_Type(s_Type&&) = default;
    s_Type& operator=(s_Type&&) = default;
    s_Type& operator=(const s_Type& selfrec) { return *this = s_Type(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Type one fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<1, s_Type> { s_Type{} } } };

static const s_Type two fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type{}, s_Type{} } } };

static const s_Type zero fu_INIT_PRIORITY(1001) = s_Type{};

inline static s_Node l_1_0_r1BHdeLP()
{
    return s_Node { s_Type(zero) };
}

                                #ifndef DEF_map_YiRZ3E3g9Ca
                                #define DEF_map_YiRZ3E3g9Ca
inline fu::vec<s_Node> map_YiRZ3E3g(fu::view<s_Node> a)
{
    /*MOV*/ fu::vec<s_Node> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = l_1_0_r1BHdeLP();

    return /*NRVO*/ res;
}
                                #endif

static void propagateType_IawFyjUI(const s_Node& node, const s_Type& slot, fu::vec<s_Node>& nodes)
{
    const s_Type& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    nodes = map_YiRZ3E3g(nodes);
    nodes += s_Node { s_Type(slot_1) };
}

static void solve_6q3k3znx(fu::vec<s_Node>& nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const s_Node& /*nodes|static*/ node = nodes[i];
        propagateType_IawFyjUI(node, s_Type(node.type), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_qxz6ATUlKC7
                                #define DEF_x3Cx3E_qxz6ATUlKC7
inline int x3Cx3E_qxz6ATUl(fu::view<s_Type> a, fu::view<s_Type> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_PIVYC7gZ(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_PIVYC7gZczf
                                #define DEF_x3Cx3E_PIVYC7gZczf
inline int x3Cx3E_PIVYC7gZ(const s_Type& a, const s_Type& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_qxz6ATUl(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_PIVYC7gZczf
                                #define DEF_x3Dx3D_PIVYC7gZczf
inline bool operator==(const s_Type& a, const s_Type& b)
{
    return !x3Cx3E_PIVYC7gZ(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Node> nodes = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { s_Type(one) } } };
    solve_6q3k3znx(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

-----

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                nodes = nodes.map(|lax n| Node(zero));


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type.nontriv.len == 0 ? zero : node.type
                    //              missing copy around ^^^^^^^^^
                    //      alt-1: wrong result, alt-2: segfault
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_Node;
struct s_Type;
inline int x3Cx3E_PIVYC7gZ(const s_Type&, const s_Type&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<s_Type> nontriv;
    s_Type(const s_Type&) = default;
    s_Type(s_Type&&) = default;
    s_Type& operator=(s_Type&&) = default;
    s_Type& operator=(const s_Type& selfrec) { return *this = s_Type(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Type one fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<1, s_Type> { s_Type{} } } };

static const s_Type zero fu_INIT_PRIORITY(1001) = s_Type{};

static const s_Type two fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type{}, s_Type{} } } };

inline static s_Node l_1_0_r1BHdeLP()
{
    return s_Node { s_Type(zero) };
}

                                #ifndef DEF_map_YiRZ3E3g9Ca
                                #define DEF_map_YiRZ3E3g9Ca
inline fu::vec<s_Node> map_YiRZ3E3g(fu::view<s_Node> a)
{
    /*MOV*/ fu::vec<s_Node> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = l_1_0_r1BHdeLP();

    return /*NRVO*/ res;
}
                                #endif

static void propagateType_IawFyjUI(const s_Node& node, const s_Type& slot, fu::vec<s_Node>& nodes)
{
    const s_Type& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    nodes = map_YiRZ3E3g(nodes);
    nodes += s_Node { s_Type(slot_1) };
}

static void solve_6q3k3znx(fu::vec<s_Node>& nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const s_Node& /*nodes|static*/ node = nodes[i];
        propagateType_IawFyjUI(node, s_Type(((node.type.nontriv.size() == 0) ? zero : node.type)), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_qxz6ATUlKC7
                                #define DEF_x3Cx3E_qxz6ATUlKC7
inline int x3Cx3E_qxz6ATUl(fu::view<s_Type> a, fu::view<s_Type> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_PIVYC7gZ(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_PIVYC7gZczf
                                #define DEF_x3Cx3E_PIVYC7gZczf
inline int x3Cx3E_PIVYC7gZ(const s_Type& a, const s_Type& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_qxz6ATUl(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_PIVYC7gZczf
                                #define DEF_x3Dx3D_PIVYC7gZczf
inline bool operator==(const s_Type& a, const s_Type& b)
{
    return !x3Cx3E_PIVYC7gZ(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Node> nodes = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { s_Type(one) } } };
    solve_6q3k3znx(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall, N_SD_HasStaticInit

-----

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                for (mut i = 0; i < nodes.len; i++)
                    nodes[i].type = zero;


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_Node;
struct s_Type;
inline int x3Cx3E_PIVYC7gZ(const s_Type&, const s_Type&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<s_Type> nontriv;
    s_Type(const s_Type&) = default;
    s_Type(s_Type&&) = default;
    s_Type& operator=(s_Type&&) = default;
    s_Type& operator=(const s_Type& selfrec) { return *this = s_Type(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Type one fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<1, s_Type> { s_Type{} } } };

static const s_Type two fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type{}, s_Type{} } } };

static const s_Type zero fu_INIT_PRIORITY(1001) = s_Type{};

static void propagateType_IawFyjUI(const s_Node& node, const s_Type& slot, fu::vec<s_Node>& nodes)
{
    const s_Type& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    for (int i = 0; i < nodes.size(); i++)
        nodes.mutref(i).type = s_Type(zero);

    nodes += s_Node { s_Type(slot_1) };
}

static void solve_6q3k3znx(fu::vec<s_Node>& nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const s_Node& /*nodes|static*/ node = nodes[i];
        propagateType_IawFyjUI(node, s_Type(node.type), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_qxz6ATUlKC7
                                #define DEF_x3Cx3E_qxz6ATUlKC7
inline int x3Cx3E_qxz6ATUl(fu::view<s_Type> a, fu::view<s_Type> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_PIVYC7gZ(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_PIVYC7gZczf
                                #define DEF_x3Cx3E_PIVYC7gZczf
inline int x3Cx3E_PIVYC7gZ(const s_Type& a, const s_Type& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_qxz6ATUl(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_PIVYC7gZczf
                                #define DEF_x3Dx3D_PIVYC7gZczf
inline bool operator==(const s_Type& a, const s_Type& b)
{
    return !x3Cx3E_PIVYC7gZ(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Node> nodes = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { s_Type(one) } } };
    solve_6q3k3znx(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

-----

        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;


                for (mut i = 0; i < nodes.len; i++)
                    nodes[i].type = zero;


                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,

                    node.type.nontriv.len == 0 ? zero : node.type
                    //              missing copy around ^^^^^^^^^
                    //      alt-1: wrong result, alt-2: segfault
);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_Node;
struct s_Type;
inline int x3Cx3E_PIVYC7gZ(const s_Type&, const s_Type&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<s_Type> nontriv;
    s_Type(const s_Type&) = default;
    s_Type(s_Type&&) = default;
    s_Type& operator=(s_Type&&) = default;
    s_Type& operator=(const s_Type& selfrec) { return *this = s_Type(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || nontriv
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Type one fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<1, s_Type> { s_Type{} } } };

static const s_Type zero fu_INIT_PRIORITY(1001) = s_Type{};

static const s_Type two fu_INIT_PRIORITY(1001) = s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type{}, s_Type{} } } };

static void propagateType_IawFyjUI(const s_Node& node, const s_Type& slot, fu::vec<s_Node>& nodes)
{
    const s_Type& /*slot|static*/ slot_1 = ((node.type.nontriv.size() == 2) ? two : slot);
    for (int i = 0; i < nodes.size(); i++)
        nodes.mutref(i).type = s_Type(zero);

    nodes += s_Node { s_Type(slot_1) };
}

static void solve_6q3k3znx(fu::vec<s_Node>& nodes)
{
    for (int i = nodes.size(); i-- > 0; )
    {
        const s_Node& /*nodes|static*/ node = nodes[i];
        propagateType_IawFyjUI(node, s_Type(((node.type.nontriv.size() == 0) ? zero : node.type)), nodes);
    };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_qxz6ATUlKC7
                                #define DEF_x3Cx3E_qxz6ATUlKC7
inline int x3Cx3E_qxz6ATUl(fu::view<s_Type> a, fu::view<s_Type> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_PIVYC7gZ(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_PIVYC7gZczf
                                #define DEF_x3Cx3E_PIVYC7gZczf
inline int x3Cx3E_PIVYC7gZ(const s_Type& a, const s_Type& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_qxz6ATUl(a.nontriv, b.nontriv)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_PIVYC7gZczf
                                #define DEF_x3Dx3D_PIVYC7gZczf
inline bool operator==(const s_Type& a, const s_Type& b)
{
    return !x3Cx3E_PIVYC7gZ(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Node> nodes = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { s_Type(one) } } };
    solve_6q3k3znx(nodes);
    if ((nodes.size() == 2) && (nodes[0].type == zero) && (nodes[1].type == one))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

-----

        nocopy struct NC { x: i32 };

        noinline fn add(a: i32, b: i32)
            a + b;

        noinline fn test(a: NC, ref b: NC)
            add(10 * a.x, ++b.x);                               // N_AARMustSeq

        fn main() {
            mut nc = NC(1);
            return test(nc, nc) - 12;
        }

-----
struct s_NC;

                                #ifndef DEF_s_NC
                                #define DEF_s_NC
struct s_NC
{
    int x;
    s_NC(const s_NC&) = delete;
    s_NC(s_NC&&) = default;
    s_NC& operator=(const s_NC&) = delete;
    s_NC& operator=(s_NC&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int add_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

static int test_62ty8EDQ(const s_NC& a, s_NC& b)
{
    int _0 {};
    return (_0 = (10 * a.x), add_hwGp0ETu(_0, ++b.x));
}

int fu_MAIN()
{
    s_NC nc = s_NC { 1 };
    return test_62ty8EDQ(nc, nc) - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

-----

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_nested_loop_after_break(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {
                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        // write followed by inner-loop break -
                        //  not on the same path as the use of first below ...
                        n.children ~= Node(i);


                        break;                                              
                    }

                    // ... which will be used again on next outer-loop iter.
                    first.value += sum;
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_nested_loop_after_break(n);
            return sum - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 23:21+5[0m:

[2m      | [0m
[2m      |                     // ... which will be used again on next outer-loop iter.[0m
[2m   23 | [0m                    [31;1mfirst[0m.value += sum;
[2m      |                 }[0m
[2m      |             }[0m

	Cannot access [35;1mref[0m [34;1mfirst[0m, reference invalidated by write to [35;1mref arg[0m [34;1mn[0m at [2m16:36+2[0m:

[2m      |                         // write followed by inner-loop break -[0m
[2m      |                         //  not on the same path as the use of first below ...[0m
[2m   16 | [0m                        n.children [31;1m~=[0m Node(i);
[2m      | [0m
[2m      | [0m

	At call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m

    BorrowCheck [35;1mfn[0m [34;1mused_in_a_nested_loop_after_break[0m(Node) at [2m4:21+33[0m

-----

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_nested_loop_after_break(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {
                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        // write followed by inner-loop break -
                        //  not on the same path as the use of first below ...
                        n.children ~= Node(i);


                        return sum;                                         
                    }

                    // ... which will be used again on next outer-loop iter.
                    first.value += sum;
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_nested_loop_after_break(n);
            return sum - 3;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int value;
    fu::vec<s_Node> children;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || children
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int used_in_a_nested_loop_after_break_7VyH5pQ0(s_Node& n)
{
    s_Node& /*n|static*/ first = n.children.mutref(0);
    int sum = 0;
    for (int i = 0; i < n.children.size(); i++)
    {
        for (int i_1 = 0; i_1 < n.children.size(); i_1++)
        {
            sum += n.children[i_1].value;
            if (sum & 1)
            {
                n.children += s_Node { i_1, fu::vec<s_Node>{} };
                return sum;
            }
            else
                first.value += sum;

        };
    };
    return sum;
}

int fu_MAIN()
{
    s_Node n = s_Node { {}, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 1, fu::vec<s_Node>{} } } } };
    const int sum = used_in_a_nested_loop_after_break_7VyH5pQ0(n);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

-----

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_preceding_nested_loop(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {

                for (shadow mut i = 0; i < n.children.len; i++)
                    first.children ~= Node(i);

                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        n.children ~= Node(i);


                        break;          
                    }
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_preceding_nested_loop(n);
            return sum - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:36+2[0m:

[2m      | [0m
[2m      |                     if (sum & 1) {[0m
[2m   18 | [0m                        n.children [31;1m~=[0m Node(i);
[2m      | [0m
[2m      | [0m

	Write to [35;1mref arg[0m [34;1mn[0m at call to [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m invalidates the use of [35;1mref[0m [34;1mfirst[0m at [2m12:21+5[0m:

[2m      | [0m
[2m      |                 for (shadow mut i = 0; i < n.children.len; i++)[0m
[2m   12 | [0m                    [31;1mfirst[0m.children ~= Node(i);
[2m      | [0m
[2m      |                 for (shadow mut i = 0; i < n.children.len; i++) {[0m

	... on next loop iteration.

	Written

    BorrowCheck [35;1mfn[0m [34;1mused_in_a_preceding_nested_loop[0m(Node) at [2m4:21+31[0m

-----

        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_preceding_nested_loop(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {

                for (shadow mut i = 0; i < n.children.len; i++)
                    first.children ~= Node(i);

                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        n.children ~= Node(i);


                        return sum;     
                    }
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_preceding_nested_loop(n);
            return sum - 3;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int value;
    fu::vec<s_Node> children;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || children
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int used_in_a_preceding_nested_loop_7VyH5pQ0(s_Node& n)
{
    s_Node& /*n|static*/ first = n.children.mutref(0);
    int sum = 0;
    for (int i = 0; i < n.children.size(); i++)
    {
        for (int i_1 = 0; i_1 < n.children.size(); i_1++)
        {
            first.children += s_Node { i_1, fu::vec<s_Node>{} };
        };
        for (int i_2 = 0; i_2 < n.children.size(); i_2++)
        {
            sum += n.children[i_2].value;
            if (sum & 1)
            {
                n.children += s_Node { i_2, fu::vec<s_Node>{} };
                return sum;
            };
        };
    };
    return sum;
}

int fu_MAIN()
{
    s_Node n = s_Node { {}, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { 2, fu::vec<s_Node>{} }, s_Node { 1, fu::vec<s_Node>{} } } } };
    const int sum = used_in_a_preceding_nested_loop_7VyH5pQ0(n);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

-----

        noinline fn used_after_break_from_block(ref arr: i32[])
        {

            ref  first = arr[0];

            :BLOCK {
                if (first & 2) {
                    if (first & 1) {
                        arr.clear();
                        break :BLOCK;                           ;; Goto
                    }

                    first++;
                }
            }

            return first;
        }

        fn main() {
            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];
            return used_after_break_from_block(arr) - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:20+5[0m:

[2m      |             }[0m
[2m      | [0m
[2m   18 | [0m            return [31;1mfirst[0m;
[2m      |         }[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mfirst[0m, reference invalidated by write to [35;1mref arg[0m [34;1marr[0m at [2m10:34+1[0m:

[2m      |                 if (first & 2) {[0m
[2m      |                     if (first & 1) {[0m
[2m   10 | [0m                        arr.clear[31;1m([0m);
[2m      |                         break :BLOCK;                           // Goto[0m
[2m      |                     }[0m

	At call to [35;1m__native[0m [34;1m
.clear()[0m

    BorrowCheck [35;1mfn[0m [34;1mused_after_break_from_block[0m(i32[:]) at [2m2:21+27[0m

-----

        noinline fn used_after_break_from_block(ref arr: i32[])
        {

            mut  first = arr[0];

            :BLOCK {
                if (first & 2) {
                    if (first & 1) {
                        arr.clear();
                        break :BLOCK;                           // Goto
                    }

                    first++;
                }
            }

            return first;
        }

        fn main() {
            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];
            return used_after_break_from_block(arr) - 3;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int used_after_break_from_block_WH6ZD5dJ(fu::vec<int>& arr)
{
    int first = arr[0];

    { {
        if (first & 2)
        {
            if (first & 1)
            {
                arr.clear();
                goto BL_1;
            }
            else
                first++;

        };
      } BL_1:;
    };
    return first;
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<16, int> { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 } };
    return used_after_break_from_block_WH6ZD5dJ(arr) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn Last(ref arr: i32[])
            arr[arr.len - 1];

        fn Push(ref arr: i32[]) {
            arr.push([]);
            return arr.Last;
        }

        fn Assign(ref b: i32, ref into: i32)
            into = ++b;

        fn main() {
            mut arr = [ 1, 2, 3 ];


            ref  b = arr.Last;

            for (mut i = 0; i < 10; i++) {
                mut tmp: i32;
                Assign(tmp = b, into: Push(arr));
            }

            return arr.Last - 13;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 21:43+1[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut tmp: i32;[0m
[2m   21 | [0m                Assign(tmp = b, into: Push[31;1m([0marr));
[2m      |             }[0m
[2m      | [0m

	Write to [35;1mvar[0m [34;1marr[0m at call to [35;1mfn[0m [34;1mPush[0m invalidates the use of [35;1mref[0m [34;1mb[0m at [2m21:30+1[0m:

[2m      |             for (mut i = 0; i < 10; i++) {[0m
[2m      |                 mut tmp: i32;[0m
[2m   21 | [0m                Assign(tmp = [31;1mb[0m, into: Push(arr));
[2m      |             }[0m
[2m      | [0m

	... on next loop iteration.

	Written
            via [35;1m__native[0m [34;1m
.push[0m at [2m6:21+1[0m:

[2m      | [0m
[2m      |         fn Push(ref arr: i32[]) {[0m
[2m    6 | [0m            arr.push[31;1m([0m[]);
[2m      |             return arr.Last;[0m
[2m      |         }[0m


    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        fn Last(ref arr: i32[])
            arr[arr.len - 1];

        fn Push(ref arr: i32[]) {
            arr.push([]);
            return arr.Last;
        }

        fn Assign(ref b: i32, ref into: i32)
            into = ++b;

        fn main() {
            mut arr = [ 1, 2, 3 ];


            fn   b = arr.Last;

            for (mut i = 0; i < 10; i++) {
                mut tmp: i32;
                Assign(tmp = b, into: Push(arr));
            }

            return arr.Last - 13;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& Last_YDgjL7oA(fu::view_mut<int> arr)
{
    return arr.mutref((arr.size() - 1));
}

static int& b_ce6QP2J1(fu::view_mut<int> arr)
{
    return Last_YDgjL7oA(arr);
}

static int& Push_WH6ZD5dJ(fu::vec<int>& arr)
{
    arr.push(int{});
    return Last_YDgjL7oA(arr);
}

static int& Assign_U0vtgPFs(int& b, int& into)
{
    return (into = ++b);
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    for (int i = 0; i < 10; i++)
    {
        int tmp {};
        int* _0;
        (_0 = &((tmp = b_ce6QP2J1(arr))), Assign_U0vtgPFs(*_0, Push_WH6ZD5dJ(arr)));
    };
    return Last_YDgjL7oA(arr) - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        fn main() {
            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];

            ref  item4 = arr[4];

            mut out = 7;

            pragma emit(`
                `arr` = {};
                `out` = `item4`;
            `);

            return out * 2 - 8;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:26+5[0m:

[2m      |             pragma emit(`[0m
[2m      |                 `arr` = {};[0m
[2m   11 | [0m                `out` = `[31;1mitem4[0m`;
[2m      |             `);[0m
[2m      | [0m

	Cannot access [35;1mref[0m [34;1mitem4[0m, reference invalidated by write to [35;1mvar[0m [34;1marr[0m at [2m10:18+3[0m:

[2m      | [0m
[2m      |             pragma emit(`[0m
[2m   10 | [0m                `[31;1marr[0m` = {};
[2m      |                 `out` = `item4`;[0m
[2m      |             `);[0m

	via pragma [34;1memit[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];

            let  item4 = arr[4];

            mut out = 7;

            pragma emit(`
                `arr` = {};
                `out` = `item4`;
            `);

            return out * 2 - 8;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<12, int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 } };
    const int /*arr|static*/ item4 = arr[4];
    int out = 7;

                arr = {};
                out = item4;

    return (out * 2) - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct A { ints: i32[] };
        struct B { a0: A; a1: A };

        noinline fn either(ref a: B) a.a0 || a.a1;

        fn main() {
            mut b0 = B( A([ 1, 2, 3, 4, 5, 6, 7, 8 ]),
                        A([ 9, 10, 11, 12, 13, 14, 15, 16 ]));

            let b1 = b0;

            ref a0 = either(b0);
            a0.ints.clear();
            a0.ints ~= 1;

            return    1 * b0.a0.ints.len +   10 * b0.a1.ints.len
                 +  100 * b1.a0.ints.len + 1000 * b1.a1.ints.len
                 - 8881;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>

struct s_B;
struct s_A;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<int> ints;
    explicit operator bool() const noexcept
    {
        return false
            || ints
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    s_A a0;
    s_A a1;
    explicit operator bool() const noexcept
    {
        return false
            || a0
            || a1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_A& either_GeozodtX(s_B& a)
{
    return a.a0 ? a.a0 : a.a1;
}

int fu_MAIN()
{
    s_B b0 = s_B { s_A { fu::vec<int> { fu::slate<8, int> { 1, 2, 3, 4, 5, 6, 7, 8 } } }, s_A { fu::vec<int> { fu::slate<8, int> { 9, 10, 11, 12, 13, 14, 15, 16 } } } };
    s_B b1 { b0 };
    s_A& /*b0*/ a0 = either_GeozodtX(b0);
    a0.ints.clear();
    a0.ints += 1;
    return ((((1 * b0.a0.ints.size()) + (10 * b0.a1.ints.size())) + (100 * b1.a0.ints.size())) + (1000 * b1.a1.ints.size())) - 8881;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || throw("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

struct s_TokenIdx;
inline static void visit_KWXdMUSw(const fu::str&, fu::str&, s_TokenIdx&);

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_Fgne1sRD(const fu::str& reason, const s_TokenIdx& _here)
{
    fu::fail(fu::str((_here ? reason : (*(const fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_uR7YCiUh(fu::str&& reason, fu::view<char> backtrack, s_TokenIdx& _here)
{
    if (backtrack)
    {
        _here = s_TokenIdx{};
    };
    FAIL_Fgne1sRD(reason, _here);
}

static fu::str climbWhat_r36ypdm5(/*MOV*/ fu::str&& str, s_TokenIdx& _here)
{
    if (str)
    {
        str.pop();
        return static_cast<fu::str&&>(str);
    }
    else
    {
        fail_uR7YCiUh("here-1"_fu, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_HMz2Ic2Y(fu::view<char> lt)
{
    return !!lt;
}

inline static void visit_KWXdMUSw(const fu::str& chars, fu::str& result, s_TokenIdx& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            /*MOV*/ fu::str lt = fu::slice(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_r36ypdm5(static_cast<fu::str&&>(lt), _here);
            if (opaque_bool_check_HMz2Ic2Y(init))
            {
                const fu::str& /*init*/ parent = init;
                visit_KWXdMUSw(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            fu::fail("here-0"_fu);

    };
}

inline static void Lifetime_process_XRxyX0et(const fu::str& lt, fu::str& result, s_TokenIdx& _here)
{
    visit_KWXdMUSw(lt, result, _here);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_TokenIdx _here {};
    fu::str result = ""_fu;
    Lifetime_process_XRxyX0et("abc"_fu, result, _here);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || FAIL("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>

struct s_TokenIdx;
inline static void visit_KWXdMUSw(const fu::str&, fu::str&, s_TokenIdx&);

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || tokidx
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never FAIL_Fgne1sRD(const fu::str& reason, const s_TokenIdx& _here)
{
    fu::fail(fu::str((_here ? reason : (*(const fu::str*)fu::NIL))));
}

[[noreturn]] static fu::never fail_uR7YCiUh(fu::str&& reason, fu::view<char> backtrack, s_TokenIdx& _here)
{
    if (backtrack)
    {
        _here = s_TokenIdx{};
    };
    FAIL_Fgne1sRD(reason, _here);
}

static fu::str climbWhat_r36ypdm5(/*MOV*/ fu::str&& str, s_TokenIdx& _here)
{
    if (str)
    {
        str.pop();
        return static_cast<fu::str&&>(str);
    }
    else
    {
        fail_uR7YCiUh("here-1"_fu, fu::view<char>{}, _here);
    };
}

static bool opaque_bool_check_HMz2Ic2Y(fu::view<char> lt)
{
    return !!lt;
}

inline static void visit_KWXdMUSw(const fu::str& chars, fu::str& result, s_TokenIdx& _here)
{
    for (int i = 0; i < chars.size(); i++)
    {

        {
            /*MOV*/ fu::str lt = fu::slice(chars, i, chars.size());
            result += lt;
            fu::str init = climbWhat_r36ypdm5(static_cast<fu::str&&>(lt), _here);
            if (opaque_bool_check_HMz2Ic2Y(init))
            {
                const fu::str& /*init*/ parent = init;
                visit_KWXdMUSw(parent, result, _here);
                continue;
            };
        };
        if (!(i == (chars.size() - 1)))
            FAIL_Fgne1sRD("here-0"_fu, _here);

    };
}

inline static void Lifetime_process_XRxyX0et(const fu::str& lt, fu::str& result, s_TokenIdx& _here)
{
    visit_KWXdMUSw(lt, result, _here);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_TokenIdx _here {};
    fu::str result = ""_fu;
    Lifetime_process_XRxyX0et("abc"_fu, result, _here);
    if (result == "abcababbcbc"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        nocopy struct Val { x: i32 };
        struct Out { v: Val };
        fn move_Val_into_Out(mut v: Val)    = Out(:v);
        fn main()                           = move_Val_into_Out(Val(0)).v.x;

-----
struct s_Val;
struct s_Out;

                                #ifndef DEF_s_Val
                                #define DEF_s_Val
struct s_Val
{
    int x;
    s_Val(const s_Val&) = delete;
    s_Val(s_Val&&) = default;
    s_Val& operator=(const s_Val&) = delete;
    s_Val& operator=(s_Val&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Out
                                #define DEF_s_Out
struct s_Out
{
    s_Val v;
    s_Out(const s_Out&) = delete;
    s_Out(s_Out&&) = default;
    s_Out& operator=(const s_Out&) = delete;
    s_Out& operator=(s_Out&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Out move_Val_into_Out_LazwcNSH(/*MOV*/ s_Val&& v)
{
    return s_Out { static_cast<s_Val&&>(v) };
}

int fu_MAIN()
{
    return move_Val_into_Out_LazwcNSH(s_Val { 0 }).v.x;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn must_not_move_mystr(n: i32) {
            mut mystr = "";
            for (mut i = 0; i < n; i++)
                mystr ~= "!";

            mut result: string[];
            for (mut i = 0; i < n; i++)
                result ~= mystr;

            return result.join();
        }

        fn main() = must_not_move_mystr(3).len - 9;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_join_6LmAXnK0Otg
                                #define DEF_join_6LmAXnK0Otg
inline fu::str join_6LmAXnK0(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str must_not_move_mystr_72skkfd5(const int n)
{
    fu::str mystr = ""_fu;
    for (int i = 0; i < n; i++)
        mystr += "!"_fu;

    fu::vec<fu::str> result {};
    for (int i_1 = 0; i_1 < n; i_1++)
        result += fu::str(mystr);

    return join_6LmAXnK0(result);
}

int fu_MAIN()
{
    return must_not_move_mystr_72skkfd5(3).size() - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_ref_and_val(ref r!: Type, mut v!: Type) {
            v.canon ~= r.canon;
            r.canon ~= v.canon;
            v.quals |= r.quals;
            return r;
        }

        fn main() {
            mut t = Type("abc", 123);
            return takes_ref_and_val(r: t, v: t).canon.len - 9;
        }

-----
#include <fu/str.h>
#include <fu/vec/concat.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type& takes_ref_and_val_6QrJeg7v(s_Type& r, s_Type&& v)
{
    v.canon += r.canon;
    r.canon += v.canon;
    v.quals |= r.quals;
    return r;
}

int fu_MAIN()
{
    s_Type t = s_Type { "abc"_fu, 123 };
    return takes_ref_and_val_6QrJeg7v(t, s_Type(t)).canon.size() - 9;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings(mut a: Type, mut b: Type) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            return a;
        }

        fn move_on_last_use_OOE(mut canon: string, quals: int) {
            canon ~= canon;
            return takes_two_strings(   // N_MoveMustSeq
                Type(:canon, :quals),
                Type(:canon, :quals));  // out of order move-into-struct will break this
        }

        fn main() {
            let res = move_on_last_use_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    1000);

            return res.canon.len + res.quals - 1192;
        }

-----
#include <fu/str.h>
#include <fu/vec/concat.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type takes_two_strings_2BgGRu0V(/*MOV*/ s_Type&& a, s_Type&& b)
{
    b.canon += a.canon;
    a.canon += b.canon;
    a.quals |= b.quals;
    return static_cast<s_Type&&>(a);
}

static s_Type move_on_last_use_OOE_OFbN7Pys(/*MOV*/ fu::str&& canon, const int quals)
{
    canon += fu::str(canon);
    s_Type _0 {};
    return (_0 = s_Type { fu::str(canon), quals }, takes_two_strings_2BgGRu0V(static_cast<s_Type&&>(_0), s_Type { static_cast<fu::str&&>(canon), quals }));
}

int fu_MAIN()
{
    s_Type res = move_on_last_use_OOE_OFbN7Pys("1234567890abcdef1234567890abcdef"_fu, 1000);
    return (res.canon.size() + res.quals) - 1192;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_MoveMustSeq

-----

        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings_and_an_int(mut a: Type, mut b: Type, c: int) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            a.quals += c;
            return a;
        }

        fn moves_reordered_by_bck_OOE(mut canon: string, mut quals: int) {
            canon ~= canon;
            return takes_two_strings_and_an_int(    // N_MoveMustSeq
                Type(:canon, 0),
                Type(:canon, quals++), // quals++ triggered bck MUSTSEQ
                             quals  ); //  which reordered arg b BEFORE arg a,
        }                              //   which broke move-on-last-use.

        fn main() {
            let res = moves_reordered_by_bck_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    0);

            return res.canon.len + res.quals - 193;
        }

-----
#include <fu/str.h>
#include <fu/vec/concat.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type takes_two_strings_and_an_int_Nftu409T(/*MOV*/ s_Type&& a, s_Type&& b, const int c)
{
    b.canon += a.canon;
    a.canon += b.canon;
    a.quals |= b.quals;
    a.quals += c;
    return static_cast<s_Type&&>(a);
}

static s_Type moves_reordered_by_bck_OOE_OFbN7Pys(/*MOV*/ fu::str&& canon, int quals)
{
    canon += fu::str(canon);
    s_Type _0 {};
    s_Type _1 {};
    return (_0 = s_Type { fu::str(canon), 0 }, _1 = s_Type { static_cast<fu::str&&>(canon), quals++ }, takes_two_strings_and_an_int_Nftu409T(static_cast<s_Type&&>(_0), static_cast<s_Type&&>(_1), quals));
}

int fu_MAIN()
{
    s_Type res = moves_reordered_by_bck_OOE_OFbN7Pys("1234567890abcdef1234567890abcdef"_fu, 0);
    return (res.canon.size() + res.quals) - 193;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_BckMustSeq, N_MoveMustSeq

-----

        nocopy struct NCItem { x: i32 };

        fn unshift_odds_push_evens(n: i32) {
            mut arr: NCItem[];
            for (mut i = 0; i < n; i++) {
                let item = NCItem(i);
                if (i & 1)  arr.unshift(item);                  // !*MustSeq
                else        arr.push(item);
            }
            return arr;
        }

        fn main() {
            let arr = unshift_odds_push_evens(3);
            return arr[0].x == 1
                && arr[1].x == 0
                && arr[2].x == 2 ? 0 : 1;
        }

-----
#include <fu/vec.h>

struct s_NCItem;

                                #ifndef DEF_s_NCItem
                                #define DEF_s_NCItem
struct s_NCItem
{
    int x;
    s_NCItem(const s_NCItem&) = delete;
    s_NCItem(s_NCItem&&) = default;
    s_NCItem& operator=(const s_NCItem&) = delete;
    s_NCItem& operator=(s_NCItem&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<s_NCItem> unshift_odds_push_evens_72skkfd5(const int n)
{
    /*MOV*/ fu::vec<s_NCItem> arr {};
    for (int i = 0; i < n; i++)
    {
        /*MOV*/ s_NCItem item = s_NCItem { i };
        if (i & 1)
        {
            arr.unshift(static_cast<s_NCItem&&>(item));
        }
        else
            arr.push(static_cast<s_NCItem&&>(item));

    };
    return /*NRVO*/ arr;
}

int fu_MAIN()
{
    fu::vec<s_NCItem> arr = unshift_odds_push_evens_72skkfd5(3);
    if ((arr[0].x == 1) && (arr[1].x == 0) && (arr[2].x == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NCThing { x: i32 };

        fn last_used_before_break(mut nc: NCThing, N: i32) {
            mut res: NCThing;
            for (mut i = 0; i < N; i++) {
                nc.x *= 2;
                if (nc.x > 10) {
                    if (nc.x > 20) return nc;
                    res = nc; // <- should move here ...
                    break;
                }
            }


            if (nc.x > 15) return nc; // <- ... unless used here.


            res.x *= 10;
            return res;
        }

        fn main() {
            let res = last_used_before_break(NCThing(3), 10);
            return res.x - 120;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:27+2[0m:

[2m      |                 if (nc.x > 10) {[0m
[2m      |                     if (nc.x > 20) return nc;[0m
[2m   10 | [0m                    res = [31;1mnc[0m; // <- should move here ...
[2m      |                     break;[0m
[2m      |                 }[0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1marg[0m [34;1mnc[0m) -> NCThing

RelaxCopyResize [35;1mfn[0m [34;1mlast_used_before_break[0m(NCThing, i32) at [2m4:12+22[0m

-----

        nocopy struct NCThing { x: i32 };

        fn last_used_before_break(mut nc: NCThing, N: i32) {
            mut res: NCThing;
            for (mut i = 0; i < N; i++) {
                nc.x *= 2;
                if (nc.x > 10) {
                    if (nc.x > 20) return nc;
                    res = nc; // <- should move here ...
                    break;
                }
            }



            res.x *= 10;
            return res;
        }

        fn main() {
            let res = last_used_before_break(NCThing(3), 10);
            return res.x - 120;
        }

-----
struct s_NCThing;

                                #ifndef DEF_s_NCThing
                                #define DEF_s_NCThing
struct s_NCThing
{
    int x;
    s_NCThing(const s_NCThing&) = delete;
    s_NCThing(s_NCThing&&) = default;
    s_NCThing& operator=(const s_NCThing&) = delete;
    s_NCThing& operator=(s_NCThing&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_NCThing last_used_before_break_9ckmOdaF(/*MOV*/ s_NCThing&& nc, const int N)
{
    /*MOV*/ s_NCThing res {};
    for (int i = 0; i < N; i++)
    {
        nc.x *= 2;
        if (nc.x > 10)
        {
            if (nc.x > 20)
                return static_cast<s_NCThing&&>(nc);
            else
            {
                res = static_cast<s_NCThing&&>(nc);
                break;
            };
        };
    };
    res.x *= 10;
    return /*NRVO*/ res;
}

int fu_MAIN()
{
    s_NCThing res = last_used_before_break_9ckmOdaF(s_NCThing { 3 }, 10);
    return res.x - 120;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NCThing { str: string };

        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {
            defer other = nc; // last use, move here!
            while (nc.str.len < 64)
                nc.str ~= nc.str;


            return nc;                     
        }

        fn main() {
            mut other: NCThing;
            last_used_in_defer(NCThing("Hello!"), other);
            return other.str.len - 96;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:20+2[0m:

[2m      | [0m
[2m      | [0m
[2m   10 | [0m            return [31;1mnc[0m;                     
[2m      |         }[0m
[2m      | [0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1marg[0m [34;1mnc[0m) -> NCThing

RelaxCopyResize [35;1mfn[0m [34;1mlast_used_in_defer[0m(NCThing, NCThing) at [2m4:12+18[0m

-----

        nocopy struct NCThing { str: string };

        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {
            defer other = nc; // last use, move here!
            while (nc.str.len < 64)
                nc.str ~= nc.str;


            return nc.str.len;             
        }

        fn main() {
            mut other: NCThing;
            last_used_in_defer(NCThing("Hello!"), other);
            return other.str.len - 96;
        }

-----
#include <fu/str.h>
#include <fu/defer.h>
#include <fu/vec/concat.h>

struct s_NCThing;

                                #ifndef DEF_s_NCThing
                                #define DEF_s_NCThing
struct s_NCThing
{
    fu::str str;
    s_NCThing(const s_NCThing&) = delete;
    s_NCThing(s_NCThing&&) = default;
    s_NCThing& operator=(const s_NCThing&) = delete;
    s_NCThing& operator=(s_NCThing&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int last_used_in_defer_er9CdlpT(/*MOV*/ s_NCThing&& nc, s_NCThing& other)
{
    fu_DEFER(other = static_cast<s_NCThing&&>(nc));
    while (nc.str.size() < 64)
        nc.str += fu::str(nc.str);

    return nc.str.size();
}

int fu_MAIN()
{
    s_NCThing other {};
    last_used_in_defer_er9CdlpT(s_NCThing { "Hello!"_fu }, other);
    return other.str.size() - 96;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        nocopy struct Node { nodes: Node[]; }

        noinline fn add(a: i32, b: i32) {
            return a + b;
        }

        fn main() {
            mut res = Node([ Node ]);
            mut cpy: Node;

            mut res_len = 0;
            mut cpy_len = 0;                                    // N_MoveMustSeq

            mut sum = add(res_len = res.nodes.len, cpy_len = (cpy = res).nodes.len); 

            return cpy.nodes.len == cpy_len
                && res_len == 1
                && cpy_len == 1
                && sum == 2             ? 0 : 1;
        }

-----
#include <fu/vec.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> nodes;
    s_Node(const s_Node&) = delete;
    s_Node(s_Node&&) = default;
    s_Node& operator=(const s_Node&) = delete;
    s_Node& operator=(s_Node&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int add_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    /*MOV*/ s_Node res = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } };
    s_Node cpy {};
    int res_len = 0;
    int cpy_len = 0;
    int _0 {};
    const int sum = (_0 = (res_len = res.nodes.size()), add_hwGp0ETu(_0, (cpy_len = (cpy = static_cast<s_Node&&>(res)).nodes.size())));
    if ((cpy.nodes.size() == cpy_len) && (res_len == 1) && (cpy_len == 1) && (sum == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_MoveMustSeq

-----

        nocopy struct Node { nodes: Node[]; }

        noinline fn add(a: i32, b: i32) {
            return a + b;
        }

        fn main() {
            mut res = Node([ Node ]);
            mut cpy: Node;

            mut res_len = 0;
            mut cpy_len = 0;                                    // N_MoveMustSeq

            mut sum = (res_len = res.nodes.len) + (cpy_len = (cpy = res).nodes.len); 

            return cpy.nodes.len == cpy_len
                && res_len == 1
                && cpy_len == 1
                && sum == 2             ? 0 : 1;
        }

-----
#include <fu/vec.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> nodes;
    s_Node(const s_Node&) = delete;
    s_Node(s_Node&&) = default;
    s_Node& operator=(const s_Node&) = delete;
    s_Node& operator=(s_Node&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    /*MOV*/ s_Node res = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } };
    s_Node cpy {};
    int res_len = 0;
    int cpy_len = 0;
    int _0 {};
    const int sum = (_0 = (res_len = res.nodes.size()), (_0 + (cpy_len = (cpy = static_cast<s_Node&&>(res)).nodes.size())));
    if ((cpy.nodes.size() == cpy_len) && (res_len == 1) && (cpy_len == 1) && (sum == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_MoveMustSeq

-----

        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);


        fn main() {
            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);
            let local = intoLocal(foreign);
            return local.name.ncs.len - 2;
        }

-----
#include <fu/vec.h>

struct s_Foreign;
struct s_NC;
struct s_Local;

                                #ifndef DEF_s_NC
                                #define DEF_s_NC
struct s_NC
{
    fu::vec<s_NC> ncs;
    s_NC(const s_NC&) = delete;
    s_NC(s_NC&&) = default;
    s_NC& operator=(const s_NC&) = delete;
    s_NC& operator=(s_NC&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Foreign
                                #define DEF_s_Foreign
struct s_Foreign
{
    s_NC name;
    int kind;
    int flags;
    s_Foreign(const s_Foreign&) = delete;
    s_Foreign(s_Foreign&&) = default;
    s_Foreign& operator=(const s_Foreign&) = delete;
    s_Foreign& operator=(s_Foreign&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Local
                                #define DEF_s_Local
struct s_Local
{
    int kind;
    int flags;
    s_NC name;
    s_Local(const s_Local&) = delete;
    s_Local(s_Local&&) = default;
    s_Local& operator=(const s_Local&) = delete;
    s_Local& operator=(s_Local&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Local intoLocal_iwZYLfIv(/*MOV*/ s_Foreign&& f)
{
    return s_Local { f.kind, f.flags, static_cast<s_NC&&>(f.name) };
}

int fu_MAIN()
{
    /*MOV*/ s_Foreign foreign = s_Foreign { s_NC { fu::vec<s_NC> { fu::slate<2, s_NC> { s_NC{}, s_NC{} } } }, 0, 0 };
    s_Local local = intoLocal_iwZYLfIv(static_cast<s_Foreign&&>(foreign));
    return local.name.ncs.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);


-----
#include <fu/vec.h>

struct s_Local;
struct s_NC;
struct s_Foreign;

                                #ifndef DEF_s_NC
                                #define DEF_s_NC
struct s_NC
{
    fu::vec<s_NC> ncs;
    s_NC(const s_NC&) = delete;
    s_NC(s_NC&&) = default;
    s_NC& operator=(const s_NC&) = delete;
    s_NC& operator=(s_NC&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Local
                                #define DEF_s_Local
struct s_Local
{
    int kind;
    int flags;
    s_NC name;
    s_Local(const s_Local&) = delete;
    s_Local(s_Local&&) = default;
    s_Local& operator=(const s_Local&) = delete;
    s_Local& operator=(s_Local&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Foreign
                                #define DEF_s_Foreign
struct s_Foreign
{
    s_NC name;
    int kind;
    int flags;
    s_Foreign(const s_Foreign&) = delete;
    s_Foreign(s_Foreign&&) = default;
    s_Foreign& operator=(const s_Foreign&) = delete;
    s_Foreign& operator=(s_Foreign&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Local intoLocal_iwZYLfIv(/*MOV*/ s_Foreign&& f)
{
    return s_Local { f.kind, f.flags, static_cast<s_NC&&>(f.name) };
}

#endif

// N_TypeRecursion, N_TypeResolve

-----

        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);

        pub import _0;
        fn main() {
            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);
            let local = intoLocal(foreign);
            return local.name.ncs.len - 2;
        }

-----
#include <fu/vec.h>

struct s_Foreign;
struct s_NC;
struct s_Local;
s_Local intoLocal_iwZYLfIv(s_Foreign&&);

                                #ifndef DEF_s_NC
                                #define DEF_s_NC
struct s_NC
{
    fu::vec<s_NC> ncs;
    s_NC(const s_NC&) = delete;
    s_NC(s_NC&&) = default;
    s_NC& operator=(const s_NC&) = delete;
    s_NC& operator=(s_NC&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || ncs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Foreign
                                #define DEF_s_Foreign
struct s_Foreign
{
    s_NC name;
    int kind;
    int flags;
    s_Foreign(const s_Foreign&) = delete;
    s_Foreign(s_Foreign&&) = default;
    s_Foreign& operator=(const s_Foreign&) = delete;
    s_Foreign& operator=(s_Foreign&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || kind
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Local
                                #define DEF_s_Local
struct s_Local
{
    int kind;
    int flags;
    s_NC name;
    s_Local(const s_Local&) = delete;
    s_Local(s_Local&&) = default;
    s_Local& operator=(const s_Local&) = delete;
    s_Local& operator=(s_Local&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    /*MOV*/ s_Foreign foreign = s_Foreign { s_NC { fu::vec<s_NC> { fu::slate<2, s_NC> { s_NC{}, s_NC{} } } }, 0, 0 };
    s_Local local = intoLocal_iwZYLfIv(static_cast<s_Foreign&&>(foreign));
    return local.name.ncs.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { items: i32[] };
        struct B { items: i32[] };


        fn takesRef_OOE(b: B, ref a: A) 
            a.items ~= b.items;

        struct C { items: i32[] };

        fn C2B(mut c: C) B(c.items);

        fn selectA(mut c: C, ref a0: A, ref a1: A) {
            ref a   = c.items.len & 1 ? a0 : a1;
            a.items = c.items;
            return a;
        }

        fn main() {
            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);
            mut a0: A;
            mut a1: A;

            takesRef_OOE(                                       // N_MoveMustSeq
                a: selectA(:c, :a0, :a1),
                b: C2B(:c));

            return a0.items.len - 14;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct s_C;
struct s_A;
struct s_B;

                                #ifndef DEF_s_C
                                #define DEF_s_C
struct s_C
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B C2B_AezJTCza(/*MOV*/ s_C&& c)
{
    return s_B { static_cast<fu::vec<int>&&>(c.items) };
}

static s_A& selectA_5ZDd4jTv(/*MOV*/ s_C&& c, s_A& a0, s_A& a1)
{
    s_A& /*a1|a0*/ a = ((c.items.size() & 1) ? a0 : a1);
    a.items = static_cast<fu::vec<int>&&>(c.items);
    return a;
}

static fu::vec<int>& takesRef_OOE_hGcammsu(const s_B& b, s_A& a)
{
    return (a.items += b.items);
}

int fu_MAIN()
{
    /*MOV*/ s_C c = s_C { fu::vec<int> { fu::slate<7, int> { 1, 2, 3, 4, 5, 6, 7 } } };
    s_A a0 {};
    s_A a1 {};
    s_B _0 {};
    (_0 = C2B_AezJTCza(s_C(c)), takesRef_OOE_hGcammsu(static_cast<s_B&&>(_0), selectA_5ZDd4jTv(static_cast<s_C&&>(c), a0, a1)));
    return a0.items.size() - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_MoveMustSeq

-----

        struct A { items: i32[] };
        struct B { items: i32[] };


        fn takesRef_OOE(ref a: A, b: B) 
            a.items ~= b.items;

        struct C { items: i32[] };

        fn C2B(mut c: C) B(c.items);

        fn selectA(mut c: C, ref a0: A, ref a1: A) {
            ref a   = c.items.len & 1 ? a0 : a1;
            a.items = c.items;
            return a;
        }

        fn main() {
            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);
            mut a0: A;
            mut a1: A;

            takesRef_OOE(                                       // N_MoveMustSeq
                a: selectA(:c, :a0, :a1),
                b: C2B(:c));

            return a0.items.len - 14;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct s_C;
struct s_A;
struct s_B;

                                #ifndef DEF_s_C
                                #define DEF_s_C
struct s_C
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    fu::vec<int> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B C2B_AezJTCza(/*MOV*/ s_C&& c)
{
    return s_B { static_cast<fu::vec<int>&&>(c.items) };
}

static s_A& selectA_5ZDd4jTv(/*MOV*/ s_C&& c, s_A& a0, s_A& a1)
{
    s_A& /*a1|a0*/ a = ((c.items.size() & 1) ? a0 : a1);
    a.items = static_cast<fu::vec<int>&&>(c.items);
    return a;
}

static fu::vec<int>& takesRef_OOE_rpk0U1Xa(s_A& a, const s_B& b)
{
    return (a.items += b.items);
}

int fu_MAIN()
{
    /*MOV*/ s_C c = s_C { fu::vec<int> { fu::slate<7, int> { 1, 2, 3, 4, 5, 6, 7 } } };
    s_A a0 {};
    s_A a1 {};
    s_B _0 {};
    (_0 = C2B_AezJTCza(s_C(c)), takesRef_OOE_rpk0U1Xa(selectA_5ZDd4jTv(static_cast<s_C&&>(c), a0, a1), static_cast<s_B&&>(_0)));
    return a0.items.size() - 14;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_MoveMustSeq

-----

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;

-----
#include <fu/str.h>
#include <fu/vec/cmp.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str trail = "x"_fu;
    if (!((trail >= "0"_fu) && (trail <= "9"_fu)) && !(((trail >= "a"_fu) && (trail <= "f"_fu)) || ((trail >= "A"_fu) && (trail <= "F"_fu))))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags?:     i32;
            value?:     string;
            items?:     SolvedNode[];
            token:      Token;

            type:       Type;
            target?:    ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: "definit",
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;

-----
#include <fu/str.h>
#include <fu/vec.h>

struct s_Token;
struct s_Type;
struct s_SolvedNode;
struct s_ScopeIdx;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeIdx
                                #define DEF_s_ScopeIdx
struct s_ScopeIdx
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str kind;
    int flags;
    fu::str value;
    fu::vec<s_SolvedNode> items;
    s_Token token;
    s_Type type;
    s_ScopeIdx target;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || flags
            || value
            || items
            || token
            || type
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode createDefaultInit_EPf80T4o(const s_Type& type, const s_Token& _here)
{
    return s_SolvedNode { "definit"_fu, 0, fu::str{}, fu::vec<s_SolvedNode>{}, s_Token(_here), s_Type(type), s_ScopeIdx{} };
}

int fu_MAIN()
{
    const s_Token _here {};
    return createDefaultInit_EPf80T4o(s_Type{}, _here).target.i;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_Scope;
struct s_Type;
struct s_Template;
struct s_SolvedNode;
struct s_Partial;

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Template
                                #define DEF_s_Template
struct s_Template
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Partial
                                #define DEF_s_Partial
struct s_Partial
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int Scope_add_n0Z1QIog(const s_Scope& scope, fu::view<char> kind, fu::view<char> id, const s_Type& type, const int min, const int max, fu::view<fu::str> arg_n, fu::view<s_Type> arg_t, fu::view<s_SolvedNode> arg_d, const s_Template& tEmplate, const s_Partial& partial)
{
    return (((((((((scope.i + kind.size()) + id.size()) + type.i) + min) + max) + arg_n.size()) + arg_t.size()) + arg_d.size()) + tEmplate.i) + partial.i;
}

int fu_MAIN()
{
    const s_Scope _scope {};
    fu::str id {};
    const s_Type t_template {};
    const int min {};
    const int max {};
    fu::vec<fu::str> arg_n {};
    const s_Template tEmplate {};
    return Scope_add_n0Z1QIog(_scope, ""_fu, id, t_template, min, max, arg_n, fu::view<s_Type>{}, fu::view<s_SolvedNode>{}, tEmplate, s_Partial{});
}

#endif

int main() { return fu_MAIN(); }

-----

        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int i = 0;
    fu::vec<fu::str> items = fu::vec<fu::str> { fu::slate<1, fu::str> { ""_fu } };
    if (i == (items.size() - 1))
        return i;
    else
        fu::fail("what?"_fu);

}

#endif

int main() { return fu_MAIN(); }

-----

        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(id: i32) id;
        return test(/*id*/0); // <- bad parse

-----

#ifndef fu_NO_fdefs

static int test_fjyGaRGP(const int id)
{
    return id;
}

int fu_MAIN()
{
    return test_fjyGaRGP(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part: &string = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            return path.join("/");
        }

        fn main() path_normalize("./hello///hey") == "hello/hey" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

inline static fu::vec<fu::str>& l_0_0_WNUkCqZ3(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_nFb7U3wbV7b
                                #define DEF_split_nFb7U3wbV7b
inline void split_nFb7U3wb(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_WNUkCqZ3(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_WNUkCqZ3(fu::slice(str, last), result);
    else
        l_0_0_WNUkCqZ3(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_nFb7U3wb(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str path_normalize_xfJXbOvX(const fu::str& p)
{
    fu::vec<fu::str> path = split_e8WhGmUq(p, "/"_fu);
    for (int i = path.size(); i-- > 0; )
    {
        fu::view<char> /*path|static*/ part = path[i];
        if ((part == "."_fu) || (!part && (i > 0) && (i < (path.size() - 1))))
            path.splice(i, 1);

    };
    return join_jCe9HYtv(path, "/"_fu);
}

int fu_MAIN()
{
    if (path_normalize_xfJXbOvX("./hello///hey"_fu) == "hello/hey"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == "..")
                    path.splice(--i, 2);
            }

            return path.join("/");
        }

        fn path_join(a: string, b: string)
            path_normalize(a ~ "/" ~ b);

        fn main()
            path_join("hello/hey", "./../you//") == "hello/you/"
                ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

inline static fu::vec<fu::str>& l_0_0_KgtOnqDg(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_c7hXhG5Pc50
                                #define DEF_split_c7hXhG5Pc50
inline void split_c7hXhG5P(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_KgtOnqDg(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_KgtOnqDg(fu::slice(str, last), result);
    else
        l_0_0_KgtOnqDg(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_c7hXhG5P(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str path_normalize_xfJXbOvX(const fu::str& p)
{
    fu::vec<fu::str> path = split_e8WhGmUq(p, "/"_fu);
    for (int i = path.size(); i-- > 0; )
    {
        fu::view<char> /*path|static*/ part = path[i];
        if ((part == "."_fu) || (!part && (i > 0) && (i < (path.size() - 1))))
            path.splice(i, 1);

    };
    for (int i_1 = 1; i_1 < path.size(); i_1++)
    {
        if (path[i_1] == ".."_fu)
            path.splice(--i_1, 2);

    };
    return join_jCe9HYtv(path, "/"_fu);
}

static fu::str path_join_xagds2ks(fu::view<char> a, fu::view<char> b)
{
    return path_normalize_xfJXbOvX(((a + "/"_fu) + b));
}

int fu_MAIN()
{
    if (path_join_xagds2ks("hello/hey"_fu, "./../you//"_fu) == "hello/you/"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial
        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done
        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done

        pub fn main() {
            let a = Template(ScopeMemo(+3));
            let b = Template(ScopeMemo(-3));
            return a.locals + b.locals; // <- fails to match.
        }

-----
struct s_ScopeMemo;
struct s_Template;

                                #ifndef DEF_s_ScopeMemo
                                #define DEF_s_ScopeMemo
struct s_ScopeMemo
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Template
                                #define DEF_s_Template
struct s_Template
{
    s_ScopeMemo locals;
    explicit operator bool() const noexcept
    {
        return false
            || locals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int operator+(const s_ScopeMemo& a, const s_ScopeMemo& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    const s_Template a = s_Template { s_ScopeMemo { +3 } };
    const s_Template b = s_Template { s_ScopeMemo { -3 } };
    return a.locals + b.locals;
}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn novec_each(a: $T[], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut a = [ 1 ];
            a.novec_each: |ref i| i *= 2;
            return a[0] - 2;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_4CSf9tOe(int& i)
{
    return (i *= 2);
}

inline static void novec_each_qAjNhGwE(fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_4CSf9tOe(a.mutref(i));

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    novec_each_qAjNhGwE(a);
    return a[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        novec fn Each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        struct Node { kind: string; items: Node[]; flags: i32; };

        let F_PREDICATE = 2;

        fn parse(tokens: byte[]): Node {
            mut _idx = 0;

            fn parseStructDecl(flags! = 0): Node {
                mut items = parseBlockLike('}');

                :F_PREDICATE {
                    items.Each: |item|
                        if (item.kind == "let")
                            if (item.flags & F_PREDICATE)
                                break :F_PREDICATE;             // Goto

                    items.Each: |ref item|
                        if (item.kind == "let")
                            item.flags |= F_PREDICATE;
                }

                return Node("struct", items, :flags);
            }

            fn parseBlockLike(endToken: byte): Node[] {
                mut items: Node[] = [];
                for (;;) {
                    let token = tokens[_idx++];                 // !N_BckMustSeq
                    if (token == endToken)                      // !N_MoveMustSeq
                        break;

                    items ~= Node("let", [], flags: token == '+' && F_PREDICATE);
                }

                return items;
            }

            return parseStructDecl();
        }

        fn main() {
            let tokens = "+-}";
            let p = parse(tokens).items;
            return p.len - p[0].flags
                         + p[1].flags * 17;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str kind;
    fu::vec<s_Node> items;
    int flags;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_F_PREDICATE
                                #define DEF_F_PREDICATE
inline constexpr int F_PREDICATE = 2;
                                #endif

static fu::vec<s_Node> parseBlockLike_j9Z9VBq3(const char endToken, fu::view<char> tokens, int& _idx)
{
    /*MOV*/ fu::vec<s_Node> items {};
    for (; ; )
    {
        fu::view<char> _0 {};
        const char /*tokens|static*/ token = (_0 = tokens, static_cast<fu::view<char>&&>(_0)[_idx++]);
        if (token == endToken)
            break;
        else
        {
            items += s_Node { "let"_fu, fu::vec<s_Node>{}, ((token == '+') ? F_PREDICATE : 0) };
        };
    };
    return /*NRVO*/ items;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

inline static void l_1_1_Fz2r1x7y(s_Node& item)
{
    if (item.kind == "let"_fu)
        item.flags |= F_PREDICATE;

}

inline static void Each_2uYDjByQ(fu::view_mut<s_Node> a)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_Fz2r1x7y(a.mutref(i));

}

static s_Node parseStructDecl_mvgfHCH7(const int flags, fu::view<char> tokens, int& _idx)
{
    /*MOV*/ fu::vec<s_Node> items = parseBlockLike_j9Z9VBq3('}', tokens, _idx);

    { {
        for (int i = 0; i < items.size(); i++)
        {
            const s_Node& /*items|static*/ item = items[i];
            if ((item.kind == "let"_fu) && (item.flags & F_PREDICATE))
                goto BL_1;

        };
        Each_2uYDjByQ(items);
      } BL_1:;
    };
    return s_Node { "struct"_fu, static_cast<fu::vec<s_Node>&&>(items), flags };
}

static s_Node parse_BWoQludi(fu::view<char> tokens)
{
    int _idx = 0;
    return parseStructDecl_mvgfHCH7(0, tokens, _idx);
}

int fu_MAIN()
{
    fu::str tokens = "+-}"_fu;
    fu::vec<s_Node> p = parse_BWoQludi(tokens).items;
    return (p.size() - p[0].flags) + (p[1].flags * 17);
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec, N_AARMustSeq, N_SD_HasStaticInit

-----

        pub struct MeshBuilder
        {
            verts?:     byte[];
            indices?:   byte[];
            vert_bytes: i32;
            num_verts?: i32;
        };

        pub fn alloc(
            using mb: &mut MeshBuilder,
            new_verts: i32,
            new_indices: i32)
        {
            verts.resize_junk((verts.len + new_verts) * vert_bytes);

            let index_bytes = 4;
            indices.resize_junk((indices.len + new_indices) * index_bytes);
        }

        pub fn setup_quads(
            using mb: &mut MeshBuilder, // <- the 'using' introduced more bindings,
            num_quads: i32)             // <-  advancing the target index number of this arg,
                : &mut [byte]           // <-   confusing the callsite lifetime of this view.
        {
            let b0 = verts.len;
            let v0 = num_verts;
            let i0 = indices.len;

            mut v1 = v0;

            alloc(num_quads * 4, num_quads * 6);

            let indices_i32: &mut [i32] =
                indices[i0 : indices.len]
                    .view(i32);

            for (mut i = 0; i < indices_i32.len; i += 6)
            {
                indices_i32[i    ] = v1;
                indices_i32[i + 1] = v1 + 1;
                indices_i32[i + 2] = v1 + 2;

                indices_i32[i + 3] = v1;
                indices_i32[i + 4] = v1 + 2;
                indices_i32[i + 5] = v1 + 3;

                v1 += 4;
            }

            num_verts = v1;

            return verts[b0 : verts.len];
        }

        let QUAD_VBO: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0,
            +1, +1, 0,      0, 0, 1,    1, 1,
            -1, +1, 0,      0, 0, 1,    0, 1,
        ];

        pub fn main()
        {
            mut mb = MeshBuilder(
                vert_bytes: 4 * (3+3+2));

            mb.setup_quads(1).view(f32) .= QUAD_VBO;

            return mb.num_verts - 4;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/view_assign.h>

struct s_MeshBuilder;

                                #ifndef DEF_s_MeshBuilder
                                #define DEF_s_MeshBuilder
struct s_MeshBuilder
{
    fu::str verts;
    fu::str indices;
    int vert_bytes;
    int num_verts;
    explicit operator bool() const noexcept
    {
        return false
            || verts
            || indices
            || vert_bytes
            || num_verts
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void alloc_WyVJI1Vf(s_MeshBuilder& mb, const int new_verts, const int new_indices)
{
    mb.verts.resize<false>(((mb.verts.size() + new_verts) * mb.vert_bytes));
    const int index_bytes = 4;
    mb.indices.resize<false>(((mb.indices.size() + new_indices) * index_bytes));
}

fu::view_mut<char> setup_quads_Ie0nmZSy(s_MeshBuilder& mb, const int num_quads)
{
    const int b0 = mb.verts.size();
    const int /*mb*/ v0 = mb.num_verts;
    const int i0 = mb.indices.size();
    int v1 = v0;
    alloc_WyVJI1Vf(mb, (num_quads * 4), (num_quads * 6));
    fu::view_mut<int> /*mb|static*/ indices_i32 = fu::view_of_mut<int>(fu::get_view_mut(mb.indices, i0, mb.indices.size()));
    for (int i = 0; i < indices_i32.size(); (i += 6))
    {
        indices_i32.mutref(i) = v1;
        indices_i32.mutref((i + 1)) = (v1 + 1);
        indices_i32.mutref((i + 2)) = (v1 + 2);
        indices_i32.mutref((i + 3)) = v1;
        indices_i32.mutref((i + 4)) = (v1 + 2);
        indices_i32.mutref((i + 5)) = (v1 + 3);
        v1 += 4;
    };
    mb.num_verts = v1;
    return fu::get_view_mut(mb.verts, b0, mb.verts.size());
}

static const fu::vec<float> QUAD_VBO fu_INIT_PRIORITY(1001) = fu::vec<float> { fu::slate<32, float> { -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, +1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f } };

int fu_MAIN()
{
    s_MeshBuilder mb = s_MeshBuilder { fu::str{}, fu::str{}, (4 * ((3 + 3) + 2)), 0 };
    fu::view_assign(fu::view_of_mut<float>(setup_quads_Ie0nmZSy(mb, 1)), QUAD_VBO);
    return mb.num_verts - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_SD_HasStaticInit

-----

        fn target(implicit ref _target: i32) _target;

        // this suddenly reported that it doesn't see __solveStruct
        fn GET_mut(ref x: i32) x || target;

        // while i was trying to reproduce an ambig "o" fail here
        fn __solveStruct(mut arg: i32): i32 {
            if (arg) {
                ref o = GET_mut(arg);
                o++;
                checkRecursions(o, o);
            }
            return arg;
        }

        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

        fn main() {
            implicit mut _target = 0;
            return __solveStruct(1) - 4;
        }

-----

#ifndef fu_NO_fdefs

static int& target_YT3Z4HVO(int& _target)
{
    return _target;
}

static int& GET_mut_TJJ0YIOU(int& x, int& _target)
{
    return x ? x : target_YT3Z4HVO(_target);
}

static void checkRecursions_Rl7rGctf(int& o, const int incr, int& _target)
{
    GET_mut_TJJ0YIOU(o, _target) += incr;
}

static int __solveStruct_XFYhfiRH(int arg, int& _target)
{
    if (arg)
    {
        int& /*_target|arg*/ o = GET_mut_TJJ0YIOU(arg, _target);
        o++;
        checkRecursions_Rl7rGctf(o, o, _target);
    };
    return arg;
}

int fu_MAIN()
{
    int _target = 0;
    return __solveStruct_XFYhfiRH(1, _target) - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   // PointlessMustSeq
            return GET_mut(target) - 1;
        }

-----
static int& GET_mut_Nuz2Imfv(int&, int&);

#ifndef fu_NO_fdefs

static int& GET_mut_Nuz2Imfv(int& x, int& target)
{
    return x ? x : GET_mut_Nuz2Imfv((target += 1), target);
}

int fu_MAIN()
{
    int target = 0;
    return GET_mut_Nuz2Imfv(target, target) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_BckMustSeq

-----

        fn target(implicit ref _itarg: i32) _itarg;

        fn main() {
            implicit mut _itarg = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   // PointlessMustSeq
            return GET_mut(target) - 1;
        }

-----
static int& GET_mut_TBpTD435(int&, int&);

#ifndef fu_NO_fdefs

static int& target_wTvY2cFt(int& _itarg)
{
    return _itarg;
}

static int& GET_mut_TBpTD435(int& x, int& _itarg)
{
    return x ? x : GET_mut_TBpTD435((target_wTvY2cFt(_itarg) += 1), _itarg);
}

int fu_MAIN()
{
    int _itarg = 0;
    return GET_mut_TBpTD435(target_wTvY2cFt(_itarg), _itarg) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_BckMustSeq

-----

        fn target(implicit ref _itarg: i32) _itarg;
        fn GET_mut(ref x: i32) x || GET_mut(target += 1);       // PointlessMustSeq

        fn main() {
            implicit mut _itarg = 0;
            return GET_mut(target) - 1;
        }

-----
static int& GET_mut_TJJ0YIOU(int&, int&);

#ifndef fu_NO_fdefs

static int& target_wTvY2cFt(int& _itarg)
{
    return _itarg;
}

static int& GET_mut_TJJ0YIOU(int& x, int& _itarg)
{
    return x ? x : GET_mut_TJJ0YIOU((target_wTvY2cFt(_itarg) += 1), _itarg);
}

int fu_MAIN()
{
    int _itarg = 0;
    return GET_mut_TJJ0YIOU(target_wTvY2cFt(_itarg), _itarg) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_BckMustSeq

-----

        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(++target);      // PointlessMustSeq
            return GET_mut(target) - 1;
        }

-----
static int& GET_mut_Nuz2Imfv(int&, int&);

#ifndef fu_NO_fdefs

static int& GET_mut_Nuz2Imfv(int& x, int& target)
{
    return x ? x : GET_mut_Nuz2Imfv(++target, target);
}

int fu_MAIN()
{
    int target = 0;
    return GET_mut_Nuz2Imfv(target, target) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_BckMustSeq

-----

        // TODO use something like pragma lax to opt-out of cc warnings.
        // Output looks fine & works on gcc/clang but gcc warns and breaks build.
        pragma emit(`#pragma GCC diagnostic ignored "-Wsequence-point"`);

        fn main() {
            mut target = 0;
            fn __solveStruct(mut arg: i32): i32 {
                ref o = GET_mut(arg); o += target;
                return target;
            }

            fn GET_mut(ref x: i32)
                x || (target = __solveStruct(target += 1));     // PointlessMustSeq

            return __solveStruct(0) - 2;
        }

-----
static int& __solveStruct_2fwL2UAv(int, int&);
#pragma GCC diagnostic ignored "-Wsequence-point"

#ifndef fu_NO_fdefs

static int& GET_mut_TBpTD435(int& x, int& target)
{
    return x ? x : (target = __solveStruct_2fwL2UAv((target += 1), target));
}

static int& __solveStruct_2fwL2UAv(int arg, int& target)
{
    int& /*target|arg*/ o = GET_mut_TBpTD435(arg, target);
    o += target;
    return target;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_2fwL2UAv(0, target) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_BckMustSeq

-----

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || (a = B(incr(a)));
        fn B(ref b: i32) b || (b = A(incr(b)));
        fn main() { mut v = 0; return A(v) - 1; }

-----
static int& A_wQ3JO5Ij(int&);

#ifndef fu_NO_fdefs

static int& incr_wQ3JO5Ij(int& a)
{
    return ++a;
}

static int& B_azdBgL8V(int& b)
{
    return b ? b : (b = A_wQ3JO5Ij(incr_wQ3JO5Ij(b)));
}

static int& A_wQ3JO5Ij(int& a)
{
    return a ? a : (a = B_azdBgL8V(incr_wQ3JO5Ij(a)));
}

int fu_MAIN()
{
    int v = 0;
    return A_wQ3JO5Ij(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }
        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }
        fn main() { mut v = 0; return A(v) - 1; }

-----
static int& A_wQ3JO5Ij(int&);

#ifndef fu_NO_fdefs

static int& incr_wQ3JO5Ij(int& a)
{
    return ++a;
}

static int& B_azdBgL8V(int& b)
{
    int& /*b*/ bb = (b ? b : (b = A_wQ3JO5Ij(incr_wQ3JO5Ij(b))));
    return bb;
}

static int& A_wQ3JO5Ij(int& a)
{
    int& /*a*/ aa = (a ? a : (a = B_azdBgL8V(incr_wQ3JO5Ij(a))));
    return aa;
}

int fu_MAIN()
{
    int v = 0;
    return A_wQ3JO5Ij(v) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        fn main()
        {
            fn Each(cond, cons) cond && cons();
            fn arg(implicit ref __arg: i32) __arg;
            fn __solveStruct(x = 3) Each(arg, || arg += x);
            implicit mut __arg = 1;
            return __solveStruct - 4;
        }

-----

#ifndef fu_NO_fdefs

static int& arg_H89wM6XP(int& __arg)
{
    return __arg;
}

static int& l_1_0_P6T2P5fq(const int x, int& __arg)
{
    return (arg_H89wM6XP(__arg) += x);
}

inline static int& Each_5yiz7oqb(int& cond, const int x, int& __arg)
{
    return !cond ? cond : l_1_0_P6T2P5fq(x, __arg);
}

static int& __solveStruct_p0Z3qeME(const int x, int& __arg)
{
    return Each_5yiz7oqb(arg_H89wM6XP(__arg), x, __arg);
}

int fu_MAIN()
{
    int __arg = 1;
    return __solveStruct_p0Z3qeME(3, __arg) - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32)             Each(arg, || arg);
            return arg_incr_x(+7) - 7;
        }

-----

#ifndef fu_NO_fdefs

static int& l_1_0_hpa9AihZ(int& arg)
{
    return arg;
}

inline static int Each_DlADBxzP(const int cond, int& arg)
{
    return !cond ? cond : l_1_0_hpa9AihZ(arg);
}

static int arg_incr_x_h0VRrRqD(int arg)
{
    return Each_DlADBxzP(arg, arg);
}

int fu_MAIN()
{
    return arg_incr_x_h0VRrRqD(+7) - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0)      Each(arg, || arg += x);
            return arg_incr_x(+7, -11) + 4;
        }

-----

#ifndef fu_NO_fdefs

static int& l_1_0_cBgsJZQs(int& arg, const int x)
{
    return (arg += x);
}

inline static int Each_FiQl67fq(const int cond, int& arg, const int x)
{
    return !cond ? cond : l_1_0_cBgsJZQs(arg, x);
}

static int arg_incr_x_km8YHr5c(int arg, const int x)
{
    return Each_FiQl67fq(arg, arg, x);
}

int fu_MAIN()
{
    return arg_incr_x_km8YHr5c(+7, -11) + 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                return arg;
            }
            return arg_incr_x(+7, -11) + 4;
        }

-----

#ifndef fu_NO_fdefs

static int& l_1_0_cBgsJZQs(int& arg, const int x)
{
    return (arg += x);
}

inline static int Each_FiQl67fq(const int cond, int& arg, const int x)
{
    return !cond ? cond : l_1_0_cBgsJZQs(arg, x);
}

static int arg_incr_x_km8YHr5c(int arg, const int x)
{
    Each_FiQl67fq(arg, arg, x);
    return arg;
}

int fu_MAIN()
{
    return arg_incr_x_km8YHr5c(+7, -11) + 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main()
        {
            mut target = 0;

            fn Each(cond, cons) cond && cons();

            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));

            fn __solveStruct(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }

-----
static int __solveStruct_wj7Z1KLn(int, int, int&);

#ifndef fu_NO_fdefs

static int& l_1_0_Q6WEMcJc(int& arg, const int x)
{
    return (arg += x);
}

inline static int Each_oZoaobJI(const int cond, int& arg, const int x)
{
    return !cond ? cond : l_1_0_Q6WEMcJc(arg, x);
}

static int& GET_mut_TBpTD435(int& x, int& target)
{
    return x ? x : (target = __solveStruct_wj7Z1KLn(target, 0, target));
}

static void checkRecursions_L79gikSs(int& o, const int incr, int& target)
{
    GET_mut_TBpTD435(o, target) += incr;
}

static int __solveStruct_wj7Z1KLn(int arg, const int x, int& target)
{
    Each_oZoaobJI(arg, arg, x);
    if (arg)
    {
        int& /*target|arg*/ o = GET_mut_TBpTD435(arg, target);
        o++;
        checkRecursions_L79gikSs(o, o, target);
    };
    return arg;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_wj7Z1KLn(1, 0, target) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode, N_DeadLet, N_RelaxRespec

-----

        fn main()
        {
            mut target = 0;

            // this suddenly reported that it doesn't see __solveStruct
            fn GET_mut(ref x) x || (target = __solveStruct(target));

            // while i was trying to reproduce an ambig "o" fail here
            fn __solveStruct(mut arg: i32): i32 {
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }

-----
static int __solveStruct_CB8JYUif(int, int&);

#ifndef fu_NO_fdefs

inline static int& GET_mut_eKOPSaav(int& x, int& target)
{
    return x ? x : (target = __solveStruct_CB8JYUif(target, target));
}

static void checkRecursions_wo5sBfW6(int& o, const int incr, int& target)
{
    GET_mut_eKOPSaav(o, target) += incr;
}

static int __solveStruct_CB8JYUif(int arg, int& target)
{
    if (arg)
    {
        int& /*target|arg*/ o = GET_mut_eKOPSaav(arg, target);
        o++;
        checkRecursions_wo5sBfW6(o, o, target);
    };
    return arg;
}

int fu_MAIN()
{
    int target = 0;
    return __solveStruct_CB8JYUif(1, target) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        pub struct ScopeSkip { start: i32; end: i32; };

        pub fn Each(items: [$T], scope_skip: ScopeSkip[], fn, start = 0) {
            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

            mut i0 = start;
            for (mut i = 0; i < scope_skip.len + 1; i++) {
                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
                if (ss.end <= i0)
                    continue;

                let i1 = ss.start;
                for (shadow mut i = i0; i < i1; i++)
                    fn(items[i]);

                i0 = ss.end;
            }
        }

        pub fn test(items?: i32[]) {
            mut sum = 0;
            let ss: ScopeSkip[];
            items.Each(ss, |item| sum += item, start: sum);
            return sum;
        }

        pub fn main() test();

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_ScopeSkip;

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_0_Ae3rC55M(const int item, int& sum)
{
    return (sum += item);
}

                                #ifndef DEF_Each_PaPfTi63Ype
                                #define DEF_Each_PaPfTi63Ype
inline void Each_PaPfTi63(fu::view<int> items, fu::view<s_ScopeSkip> scope_skip, const int start, int& sum)
{
    const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const s_ScopeSkip& /*END_DUMMY|scope_skip|static*/ ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int /*ss*/ i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                l_1_0_Ae3rC55M(items[i_1], sum);

            i0 = ss.end;
        };
    };
}
                                #endif

int test_Lodybvpk(fu::view<int> items)
{
    int sum = 0;
    fu::vec<s_ScopeSkip> ss {};
    Each_PaPfTi63(items, ss, sum, sum);
    return sum;
}

int fu_MAIN()
{
    return test_Lodybvpk(fu::view<int>{});
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Each(a: [$T], fn, start!?: i32)
            for (mut i = start; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut sum = 0;
            let a = [ 1, 2, 3 ];
            a.Each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit
            return sum - 6;                     //     perhaps we can use the optionality to infer constness
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_aT7gGMs3(const int i, int& sum)
{
    return (sum += i);
}

inline static void Each_NosVmkbe(fu::view<int> a, const int start, int& sum)
{
    for (int i = start; i < a.size(); i++)
        l_1_0_aT7gGMs3(a[i], sum);

}

int fu_MAIN()
{
    int sum = 0;
    fu::vec<int> a = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    Each_NosVmkbe(a, sum, sum);
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

-----


        novec // Abusing to test novec, unrelated to the test

        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:9+5[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        [31;1mnovec[0m // Abusing to test novec, unrelated to the test
[2m      | [0m
[2m      |         fn ScopeSkip_push(ref scope_skip: i32[]) {[0m

	[35;1mfn[0m [34;1mScopeSkip_push[0m is not novec, [35;1mref arg[0m [34;1mscope_skip[0m is i32[] mutref copy resize:

            via [35;1m__native[0m [34;1m
<fu/vec/concat_one.h>
+=[0m at [2m7:40+2[0m:

[2m      |         fn ScopeSkip_push(ref scope_skip: i32[]) {[0m
[2m      |             if (scope_skip) scope_skip[0]++;[0m
[2m    7 | [0m            else            scope_skip [31;1m~=[0m 1;
[2m      |         }[0m
[2m      | [0m


-----


        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static void ScopeSkip_push_u9WbtfFK(fu::vec<int>& scope_skip)
{
    if (scope_skip)
        scope_skip.mutref(0)++;
    else
        scope_skip += 1;

}

int fu_MAIN()
{
    fu::vec<int> scope_skip = fu::vec<int> { fu::slate<1, int> { 1 } };
    ScopeSkip_push_u9WbtfFK(scope_skip);
    return scope_skip[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Hello { v: i32[] };

        fn main() {
            let h = Hello();


            novec // qSTACK bug with args.len == 0 at call to Hello

            fn hello(woot?: i32)
                woot ? Hello() : h;

            return hello.v.len;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:13+5[0m:

[2m      | [0m
[2m      | [0m
[2m    8 | [0m            [31;1mnovec[0m // qSTACK bug with args.len == 0 at call to Hello
[2m      | [0m
[2m      |             fn hello(woot?: i32)[0m

	[35;1mfn[0m [34;1mhello[0m is not novec, [35;1minjected implicit arg[0m [34;1mmain:h[0m is Hello copy:


        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        struct Hello { v: i32[] };

        fn main() {
            let h = Hello();


            fn hello(woot?: i32)
                woot ? Hello() : h;

            return hello.v.len;
        }

-----
#include <fu/vec.h>

struct s_Hello;

                                #ifndef DEF_s_Hello
                                #define DEF_s_Hello
struct s_Hello
{
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Hello hello_wVRBbo9P(const int woot, const s_Hello& h)
{
    if (woot)
    {
        return s_Hello{};
    }
    else
        return s_Hello(h);

}

int fu_MAIN()
{
    s_Hello h = s_Hello{};
    return hello_wVRBbo9P(0, h).v.size();
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Module  { cpp:    string; };
        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here

        fn snippet2cpp(cpp: string): string {
            let ctx = Context( Module(cpp) );
            {
                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.
                if (module.cpp)
                    return module.cpp;          // EXPECT return static_cast<fu::str&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;

-----
#include <fu/str.h>

struct s_Context;
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    fu::str cpp;
    explicit operator bool() const noexcept
    {
        return false
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    s_Module module;
    explicit operator bool() const noexcept
    {
        return false
            || module
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str snippet2cpp_ppBHeEsh(const fu::str& cpp)
{
    /*MOV*/ s_Context ctx = s_Context { s_Module { fu::str(cpp) } };

    {
        /*MOV*/ s_Module& /*ctx*/ module = ctx.module;
        if (module.cpp)
            return static_cast<fu::str&&>(module.cpp);

    };
    return ""_fu;
}

int fu_MAIN()
{
    return snippet2cpp_ppBHeEsh("1"_fu).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Module  { cpp:     string;   };
        struct Context { modules: Module[]; };  // Module[] is COW-capable -
                                                //  - either prove there's no COW,
        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.
            let ctx = Context([ Module(cpp) ]);
            for (mut i = 0; i < ctx.modules.len; i++)
            {
                let module = ctx.modules[i];    // TODO .unique(i)
                if (module.cpp)
                    return module.cpp;          // TODO return static_cast<fu::str&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;

-----
;; TODO .unique(i)
;; TODO return static_cast<fu::str&&>

#include <fu/str.h>
#include <fu/vec.h>

struct s_Context;
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    fu::str cpp;
    explicit operator bool() const noexcept
    {
        return false
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::vec<s_Module> modules;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str snippet2cpp_ppBHeEsh(const fu::str& cpp)
{
    s_Context ctx = s_Context { fu::vec<s_Module> { fu::slate<1, s_Module> { s_Module { fu::str(cpp) } } } };
    for (int i = 0; i < ctx.modules.size(); i++)
    {
        const s_Module& /*ctx|static*/ module = ctx.modules[i];
        if (module.cpp)
            return fu::str(module.cpp);

    };
    return ""_fu;
}

int fu_MAIN()
{
    return snippet2cpp_ppBHeEsh("1"_fu).size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn test(x: string) {
            // cg fail: fwd annots of the two fns where unconsting hey to "enable move",
            //          basically the decision was made in the wrong scope.
            let hey = "hey";
            fn inner(you: string) you && hey ~ you || outer("what#1");
            fn outer(arg: string) inner(arg && " " ~ arg) || inner("what#2");
            return outer(x);
        }

        fn main() test("you").len - 7;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

static fu::str outer_XciSdY57(fu::view<char>, fu::view<char>);

#ifndef fu_NO_fdefs

static fu::str inner_H8scdtMt(fu::view<char> you, fu::view<char> hey)
{
    fu::str _0 {};
    return (_0 = (you ? (hey + you) : fu::str{})) ? static_cast<fu::str&&>(_0) : outer_XciSdY57("what#1"_fu, hey);
}

static fu::str outer_XciSdY57(fu::view<char> arg, fu::view<char> hey)
{
    fu::str _0 {};
    return (_0 = inner_H8scdtMt((arg ? (" "_fu + arg) : fu::str{}), hey)) ? static_cast<fu::str&&>(_0) : inner_H8scdtMt("what#2"_fu, hey);
}

static fu::str test_blSJ8lql(fu::view<char> x)
{
    fu::str hey = "hey"_fu;
    return outer_XciSdY57(x, hey);
}

int fu_MAIN()
{
    return test_blSJ8lql("you"_fu).size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;



        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;

-----
struct s_CurrentFn;
struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int modid;
    int packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_tUmGp6H5(const s_CurrentFn& c)
{
    const s_Target& /*c*/ a = c.target;
    return a.packed;
}

int fu_MAIN()
{
    return hello_tUmGp6H5(s_CurrentFn{});
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;


-----

-----

        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;

        pub import _0;

        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;

-----
struct s_CurrentFn;
struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int modid;
    int packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_KKlRyXCq(const s_CurrentFn& c)
{
    const s_Target& /*c*/ a = c.target;
    return a.packed;
}

int fu_MAIN()
{
    return hello_KKlRyXCq(s_CurrentFn{});
}

#endif

int main() { return fu_MAIN(); }

-----

        struct ID   { offset: i32;  };
        struct Data { items:  ID[]; };

        using fn Data(implicit all: Data[], nid: ID): Data {
            return all[nid.offset];
        }

        fn test(node: ID) {
            let init = node.items[0];
            return init.items.len;
        }

        fn main() {
            let implicit all =  [ Data([ ID(1)      ])
                                , Data([ ID, ID, ID ]) ];

            return 0.ID.test - 3;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Data;
struct s_ID;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
struct s_ID
{
    int offset;
    explicit operator bool() const noexcept
    {
        return false
            || offset
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Data
                                #define DEF_s_Data
struct s_Data
{
    fu::vec<s_ID> items;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Data& Data_jVOigWJQ(const s_ID& nid, fu::view<s_Data> all)
{
    return all[nid.offset];
}

static int test_qgBjSc6L(const s_ID& node, fu::view<s_Data> all)
{
    const s_ID& /*all|static*/ init = Data_jVOigWJQ(node, all).items[0];
    return Data_jVOigWJQ(init, all).items.size();
}

int fu_MAIN()
{
    fu::vec<s_Data> all = fu::vec<s_Data> { fu::slate<2, s_Data> { s_Data { fu::vec<s_ID> { fu::slate<1, s_ID> { s_ID { 1 } } } }, s_Data { fu::vec<s_ID> { fu::slate<3, s_ID> { s_ID{}, s_ID{}, s_ID{} } } } } };
    return test_qgBjSc6L(s_ID { 0 }, all) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:17+1[0m:

[2m      |         fn hello(ref s: S, w: i32) {[0m
[2m      |             infix fn |=(ref s: S, v: i32)[0m
[2m    6 | [0m                [31;1ms[0m.i |= v << w;
[2m      | [0m
[2m      |             s |= 2;[0m

	Ambiguous call to [31;1ms[0m, matches multiple items in scope:

	[35;1mref arg[0m [34;1ms[0m at [2m5:29+1[0m:
[2m    5 | [0m            infix fn |=(ref [31;1ms[0m: S, v: i32)

	[35;1mref arg[0m [34;1ms[0m at [2m4:22+1[0m:
[2m    4 | [0m        fn hello(ref [31;1ms[0m: S, w: i32) {


        Solving [35;1mfn[0m [34;1m|=[0m(S, i32) at [2m5:22+2[0m
                [35;1mfn[0m [34;1mhello[0m(S, i32) at [2m4:12+5[0m

-----

        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(shadow ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }

-----
struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& x7Cx3D_eKqOwJP9(s_S& s, const int v, const int w)
{
    return (s.i |= (v << w));
}

static void hello_5sUuQ00T(s_S& s, const int w)
{
    x7Cx3D_eKqOwJP9(s, 2, w);
}

int fu_MAIN()
{
    s_S s = s_S { 1 };
    hello_5sUuQ00T(s, 3);
    return s.i - 17;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn lex(src: string) {
            let end = src.len;
            mut idx = 0;

            fn err_str(idx1: i32) {
                while (idx < end && src[idx] == ' ') idx++;
                return src.slice(idx, idx1);
            }

            fn err(idx1_x2: i32) err_str(idx1_x2 /2);
            return err(end *2);
        }

        fn main() lex("    hello").len - 5;

-----
#include <fu/str.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

static fu::str err_str_VJDJtHVA(const int idx1, const fu::str& src, const int end, int& idx)
{
    while ((idx < end) && (src[idx] == ' '))
        idx++;

    return fu::slice(src, idx, idx1);
}

static fu::str err_QPlI3ZdR(const int idx1_x2, const fu::str& src, const int end, int& idx)
{
    return err_str_VJDJtHVA((idx1_x2 / 2), src, end, idx);
}

static fu::str lex_CeQuEEC1(const fu::str& src)
{
    const int end = src.size();
    int idx = 0;
    return err_QPlI3ZdR((end * 2), src, end, idx);
}

int fu_MAIN()
{
    return lex_CeQuEEC1("    hello"_fu).size() - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void
        {
            // Fuzzing module splits.
            for (mut i = 0; i < sources.len; i++)
            {
                for (;;)
                {
                    ref src     = sources[i];

                    mut start0  = src.find("[split/]");
                    if (start0 < 0)
                        break;

                    let start00 = start0;
                    let start1  = start0 + 8;
                    while (start0 && src[start0 - 1] == ' ') start0--;

                    let moduleA = src.slice(0, start0);
                    let moduleB = src[start0 : start00] ~ "import _" ~ i ~ ";" ~ src[start1 : src.len];
                    let without = src[0 : start0] ~ src[start1 : src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                }

                sum += sources[i].len;
            }
        }

        fn main() {
            implicit mut sum: i32;

            ZERO( "AAAA|BB[split/]CC".split("|") );
            let expect = 4+2+2 + 4+2+2 + 10; // 10 = "import _0;"

            return sum - expect;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

void ZERO_kAWeAycE(fu::vec<fu::str>&&, int&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

void ZERO_kAWeAycE(fu::vec<fu::str>&& sources, int& sum)
{
    for (int i = 0; i < sources.size(); i++)
    {
        for (; ; )
        {
            const fu::str& /*sources|static*/ src = sources[i];
            int start0 = fu::lfind(src, "[split/]"_fu);
            if (start0 < 0)
                break;
            else
            {
                const int /*start0*/ start00 = start0;
                const int start1 = (start0 + 8);
                while (start0 && (src[(start0 - 1)] == ' '))
                    start0--;

                /*MOV*/ fu::str moduleA = fu::slice(src, 0, start0);
                /*MOV*/ fu::str moduleB = ((x7E_gCeFmDFw((fu::get_view(src, start0, start00) + "import _"_fu), fu::i64dec(i)) + ";"_fu) + fu::get_view(src, start1, src.size()));
                /*MOV*/ fu::str without = (fu::get_view(src, 0, start0) + fu::get_view(src, start1, src.size()));
                sources.mutref(i) = static_cast<fu::str&&>(without);
                ZERO_kAWeAycE(fu::vec<fu::str>(sources), sum);
                sources.mutref(i) = static_cast<fu::str&&>(moduleA);
                sources.insert((i + 1), static_cast<fu::str&&>(moduleB));
            };
        };
        sum += sources[i].size();
    };
}

inline static fu::vec<fu::str>& l_0_0_WkDRtMDj(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_oSilf95p9Od
                                #define DEF_split_oSilf95p9Od
inline void split_oSilf95p(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_WkDRtMDj(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_WkDRtMDj(fu::slice(str, last), result);
    else
        l_0_0_WkDRtMDj(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_oSilf95p(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

int fu_MAIN()
{
    int sum {};
    ZERO_kAWeAycE(split_e8WhGmUq("AAAA|BB[split/]CC"_fu, "|"_fu), sum);
    const int expect = ((((((4 + 2) + 2) + 4) + 2) + 2) + 10);
    return sum - expect;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct SolvedNode {
            bli: i32;
        };

        // --> [2] ... triggered the solve of this fn, ...
        fn SolvedNode(blah: string) {
            return SolvedNode(blah.len.NOT_PREPPED_YET);
        }

        // [1] During prep, this type annotation ...
        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {
            return node.bli + 2;
        }

        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).
        fn NOT_PREPPED_YET(x: i32) {
            return x * 2;
        }

        fn main() {
            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode("hello")) - (2*5+2);
        }

-----
#include <fu/str.h>
#include <fu/view.h>

struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int bli;
    explicit operator bool() const noexcept
    {
        return false
            || bli
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int NOT_PREPPED_YET_1WsbUdat(const int x)
{
    return x * 2;
}

static s_SolvedNode SolvedNode_fnB9U19R(fu::view<char> blah)
{
    return s_SolvedNode { NOT_PREPPED_YET_1WsbUdat(blah.size()) };
}

static int ARG_ANNOT_TRIGGERS_SOLVE_7Wi0YdjQ(const s_SolvedNode& node)
{
    return node.bli + 2;
}

int fu_MAIN()
{
    return ARG_ANNOT_TRIGGERS_SOLVE_7Wi0YdjQ(SolvedNode_fnB9U19R("hello"_fu)) - ((2 * 5) + 2);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                let o = overloads[target.index];
                return o;
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                let nodes = overloads[nid.nodeidx].nodes;
                return nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct s_CurrentFn;
struct s_SolvedNode;
struct s_Overload;
struct s_SolvedNodeData;
struct s_Target;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int nodeidx;
    explicit operator bool() const noexcept
    {
        return false
            || nodeidx
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    s_SolvedNode out;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::vec<s_SolvedNodeData> nodes;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNodeData
                                #define DEF_s_SolvedNodeData
struct s_SolvedNodeData
{
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_SolvedNodeData& SolvedNodeData_rSwildui(const s_SolvedNode& nid, fu::view<s_Overload> overloads)
{
    fu::view<s_SolvedNodeData> /*overloads|static*/ nodes = overloads[nid.nodeidx].nodes;
    return nodes[nid.nodeidx];
}

static const s_Overload& GET_osV1oXPG(const s_Target& target, fu::view<s_Overload> overloads)
{
    const s_Overload& /*overloads|static*/ o = overloads[target.index];
    return o;
}

static int test_lwDj0oCD(fu::view<s_Overload> overloads, const s_CurrentFn& _current_fn)
{
    const s_Target& /*overloads|static*/ current_fn = SolvedNodeData_rSwildui(_current_fn.out, overloads).target;
    const s_Overload& /*overloads|static*/ debug_2 = (current_fn ? GET_osV1oXPG(current_fn, overloads) : (*(const s_Overload*)fu::NIL));
    if (debug_2)
        return current_fn.index;
    else
        return 0;

}

int fu_MAIN()
{
    const s_CurrentFn _current_fn = s_CurrentFn { s_SolvedNode { 0 } };
    fu::vec<s_Overload> overloads = fu::vec<s_Overload> { fu::slate<1, s_Overload> { s_Overload { fu::vec<s_SolvedNodeData> { fu::slate<1, s_SolvedNodeData> { s_SolvedNodeData { s_Target { 0 } } } } } } };
    return test_lwDj0oCD(overloads, _current_fn);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                if (target.index != 303) // Same as above, different setup.
                    return overloads[target.index];

                return []; // Also this fails to solve: cannot definit mutref
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                return nid.nodeidx != 303 // Same as above, rewording as a logical.
                    && overloads[nid.nodeidx].nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>

struct s_CurrentFn;
struct s_SolvedNode;
struct s_Overload;
struct s_SolvedNodeData;
struct s_Target;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int nodeidx;
    explicit operator bool() const noexcept
    {
        return false
            || nodeidx
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    s_SolvedNode out;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::vec<s_SolvedNodeData> nodes;
    explicit operator bool() const noexcept
    {
        return false
            || nodes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNodeData
                                #define DEF_s_SolvedNodeData
struct s_SolvedNodeData
{
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_SolvedNodeData& SolvedNodeData_rSwildui(const s_SolvedNode& nid, fu::view<s_Overload> overloads)
{
    if (nid.nodeidx != 303)
        return overloads[nid.nodeidx].nodes[nid.nodeidx];
    else
        return (*(const s_SolvedNodeData*)fu::NIL);

}

static const s_Overload& GET_osV1oXPG(const s_Target& target, fu::view<s_Overload> overloads)
{
    if (target.index != 303)
        return overloads[target.index];
    else
        return (*(const s_Overload*)fu::NIL);

}

static int test_lwDj0oCD(fu::view<s_Overload> overloads, const s_CurrentFn& _current_fn)
{
    const s_Target& /*overloads|static*/ current_fn = SolvedNodeData_rSwildui(_current_fn.out, overloads).target;
    const s_Overload& /*overloads|static*/ debug_2 = (current_fn ? GET_osV1oXPG(current_fn, overloads) : (*(const s_Overload*)fu::NIL));
    if (debug_2)
        return current_fn.index;
    else
        return 0;

}

int fu_MAIN()
{
    const s_CurrentFn _current_fn = s_CurrentFn { s_SolvedNode { 0 } };
    fu::vec<s_Overload> overloads = fu::vec<s_Overload> { fu::slate<1, s_Overload> { s_Overload { fu::vec<s_SolvedNodeData> { fu::slate<1, s_SolvedNodeData> { s_SolvedNodeData { s_Target { 0 } } } } } } };
    return test_lwDj0oCD(overloads, _current_fn);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Token {
            col: i32;
            line: i32;
            value: string;
        };

        fn parse(tokens: Token[]) {
            mut _idx = 0;
            mut _loc = 0;

            fn fail(mut reason = "") {
                let loc  = tokens[_loc];
                let here = tokens[_idx];
                if (!reason)
                    reason = "Unexpected '" ~ here.value ~ "'.";

                let l0 = loc.line;  let c0 = loc.col;
                let l1 = here.line; let c1 = here.col;

                let addr = l1 == l0
                    ? "@" ~ l1 ~ ":" ~ c1
                    : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

                return throw(addr ~ ":\n\t" ~ reason);
            }

            fn consume(value: [byte], err = "") {
                let token = tokens[_idx];
                if (token.value == value) {
                    _idx++;
                    return token;
                }

                return fail((err || "Expected") ~ " '" ~ value ~ "', got '" ~ token.value ~ "'.");
            }

            fn parseRoot() {
                let ret = consume("sof");
                _loc = _idx;
                return ret;
            }

            return parseRoot();
        }

        fn main() {
            return parse([ Token(1, 1, "sof") ]).value.len - 3;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct s_Token;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int col;
    int line;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || col
            || line
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_OsqoAcQP(fu::str&& reason, fu::view<s_Token> tokens, const int _idx, const int _loc)
{
    const s_Token& /*tokens|static*/ loc = tokens[_loc];
    const s_Token& /*tokens|static*/ here = tokens[_idx];
    if (!reason)
        reason = (("Unexpected '"_fu + here.value) + "'."_fu);

    const int /*loc*/ l0 = loc.line;
    const int /*loc*/ c0 = loc.col;
    const int /*here*/ l1 = here.line;
    const int /*here*/ c1 = here.col;
    fu::str addr = ((l1 == l0) ? x7E_gCeFmDFw((x7E_gCeFmDFw("@"_fu, fu::i64dec(l1)) + ":"_fu), fu::i64dec(c1)) : x7E_gCeFmDFw((x7E_gCeFmDFw((x7E_gCeFmDFw((x7E_gCeFmDFw("@"_fu, fu::i64dec(l0)) + ":"_fu), fu::i64dec(c0)) + ".."_fu), fu::i64dec(l1)) + ":"_fu), fu::i64dec(c1)));
    fu::fail(((addr + ":\n\t"_fu) + reason));
}

static const s_Token& consume_VRiGfvFd(fu::view<char> value, const fu::str& err, fu::view<s_Token> tokens, int& _idx, const int _loc)
{
    const s_Token& /*tokens|static*/ token = tokens[_idx];
    if (token.value == value)
    {
        _idx++;
        return token;
    }
    else
        fail_OsqoAcQP(((((((err ? fu::str(err) : "Expected"_fu) + " '"_fu) + value) + "', got '"_fu) + token.value) + "'."_fu), tokens, _idx, _loc);

}

static const s_Token& parseRoot_mmuUTiyK(fu::view<s_Token> tokens, int& _idx, int& _loc)
{
    const s_Token& /*tokens|static*/ ret = consume_VRiGfvFd("sof"_fu, ""_fu, tokens, _idx, _loc);
    _loc = _idx;
    return ret;
}

static const s_Token& parse_iKJYcClp(fu::view<s_Token> tokens)
{
    int _idx = 0;
    int _loc = 0;
    return parseRoot_mmuUTiyK(tokens, _idx, _loc);
}

int fu_MAIN()
{
    return parse_iKJYcClp((fu::slate<1, s_Token> { s_Token { 1, 1, "sof"_fu } })).value.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn CallerNode(mut t?: i32, arr?: i32[])
        {
            for (mut i = 0; i < arr.len; i++) {
                return CallerNode(arr[i]);
                //     ^^^^^^^^^^
                // fn CallerNode: Arg #1, arr not assignable to host_arg:
                //      expect: []+252i32: ref copy resize
                //      actual: []+252i32: ref
            }

            return t;
        }

        fn main() = CallerNode();

-----
#include <fu/view.h>

static int CallerNode_4w7OKhIG(int, fu::view<int>);

#ifndef fu_NO_fdefs

static int CallerNode_4w7OKhIG(const int t, fu::view<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        return CallerNode_4w7OKhIG(arr[i], fu::view<int>{});
    };
    return t;
}

int fu_MAIN()
{
    return CallerNode_4w7OKhIG(0, fu::view<int>{});
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        struct Target       { index: i32; };
        struct SolvedNode   { target: Target; args: SolvedNode[]; };

        fn CallerNode(
            mut target: Target,
            mut args: SolvedNode[] = [],
            reorder?: i32[],
            conversions?: Target[][]): SolvedNode
        {
            if (reorder) {
                mut args_out: SolvedNode[]; args_out.resize(reorder.len);
                for (mut i = 0; i < reorder.len; i++) {
                    let idx = reorder[i];
                    if (idx >= 0)
                        args_out[i] = args[idx];
                }

                args = args_out;
            }

            for (mut argIdx = 0; argIdx < conversions.len; argIdx++) {
                let conversion = conversions[argIdx];
                for (mut i = 0; i < conversion.len; i++) {
                    args[argIdx] = CallerNode(conversion[i]);
                    //             ^^^^^^^^^^
                    // fn CallerNode: Arg #2, reorder not assignable to host_arg:
                    //      expect: []+252i32: ref copy resize
                    //      actual: []+252i32: ref copy
                }
            }

            return SolvedNode(:target, :args);
        }

        fn main() {
            return CallerNode(Target(0)).target.index;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Target;
struct s_SolvedNode;
static s_SolvedNode CallerNode_zeY3Alvz(s_Target&&, fu::vec<s_SolvedNode>&&, fu::view<int>, fu::view<fu::vec<s_Target>>);

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    s_Target target;
    fu::vec<s_SolvedNode> args;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || target
            || args
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolvedNode CallerNode_zeY3Alvz(s_Target&& target, /*MOV*/ fu::vec<s_SolvedNode>&& args, fu::view<int> reorder, fu::view<fu::vec<s_Target>> conversions)
{
    if (reorder)
    {
        /*MOV*/ fu::vec<s_SolvedNode> args_out {};
        args_out.resize(reorder.size());
        for (int i = 0; i < reorder.size(); i++)
        {
            const int /*reorder|static*/ idx = reorder[i];
            if ((idx >= 0))
                args_out.mutref(i) = s_SolvedNode(args[idx]);

        };
        args = static_cast<fu::vec<s_SolvedNode>&&>(args_out);
    };
    for (int argIdx = 0; argIdx < conversions.size(); argIdx++)
    {
        fu::view<s_Target> /*conversions|static*/ conversion = conversions[argIdx];
        for (int i = 0; i < conversion.size(); i++)
        {
            args.mutref(argIdx) = CallerNode_zeY3Alvz(s_Target(conversion[i]), fu::vec<s_SolvedNode>{}, fu::view<int>{}, fu::view<fu::vec<s_Target>>{});
        };
    };
    return s_SolvedNode { s_Target(target), static_cast<fu::vec<s_SolvedNode>&&>(args) };
}

int fu_MAIN()
{
    return CallerNode_zeY3Alvz(s_Target { 0 }, fu::vec<s_SolvedNode>{}, fu::view<int>{}, fu::view<fu::vec<s_Target>>{}).target.index;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn qSTACK(x: i32) {
            let rec = x & 1 && "rec ";
            let via = !rec && qSTACK(x / 2);
            return "\n" ~ rec ~ "at #" ~ x ~ via;
        }

        fn main() qSTACK(2).len - 2 - 4 - 8 - 2;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

static fu::str qSTACK_1WsbUdat(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str qSTACK_1WsbUdat(const int x)
{
    fu::str rec = ((x & 1) ? "rec "_fu : fu::str{});
    fu::str via = (!rec ? qSTACK_1WsbUdat((x / 2)) : fu::str{});
    return x7E_gCeFmDFw((("\n"_fu + rec) + "at #"_fu), fu::i64dec(x)) + via;
}

int fu_MAIN()
{
    return (((qSTACK_1WsbUdat(2).size() - 2) - 4) - 8) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        struct SolvedNode { items: SolvedNode[] };

        fn solve(node: SolvedNode) {
            mut events = 0;

            fn propagateType(shadow node: SolvedNode) {
                fn tryTrackLastUse() !(node.items.len & 1);
                let canDiscard = node.items.len != 0;
                fn discardIntoBlock() tryTrackLastUse();

                if (canDiscard && discardIntoBlock)
                    propagateType(node.items[0]);

                events++;
            }

            propagateType(node);
            return events;
        }

        fn main() solve(SolvedNode([ SolvedNode(), SolvedNode() ])) == 2 ? 0 : 1;

-----
#include <fu/vec.h>

struct s_SolvedNode;
static void propagateType_0rtm2N3X(const s_SolvedNode&, int&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool tryTrackLastUse_fwJRfWgj(const s_SolvedNode& node)
{
    return !(node.items.size() & 1);
}

static bool discardIntoBlock_eIpiHrV4(const s_SolvedNode& node)
{
    return tryTrackLastUse_fwJRfWgj(node);
}

static void propagateType_0rtm2N3X(const s_SolvedNode& node, int& events)
{
    const bool canDiscard = (node.items.size() != 0);
    if (canDiscard && discardIntoBlock_eIpiHrV4(node))
        propagateType_0rtm2N3X(node.items[0], events);

    events++;
}

static int solve_MkqgH20q(const s_SolvedNode& node)
{
    int events = 0;
    propagateType_0rtm2N3X(node, events);
    return events;
}

int fu_MAIN()
{
    if (solve_MkqgH20q(s_SolvedNode { fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode{}, s_SolvedNode{} } } }) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        fn path_relative(from: string, to: string): string {
            let min = from.len < to.len ? from.len : to.len;

            mut same = 0;
            for (mut i = 0; i < min; i++) {
                let a = from[i];
                let b = to[i];

                if (b != a)
                    break;

                if (b == '/')
                    same = i + 1;
            }

            mut res: string;
            for (mut i = same; i < from.len; i++)
                if (from[i] == '/')
                    res ~= "../";

            res ~= to.slice(same);
            return res;
        }

        fn main() {
            let from    = "/a/b/c";
            let to      = "/a/e/f";
            let rel     = path_relative(:from, :to);

            return rel == "../e/f" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str path_relative_TGelh3Ij(fu::view<char> from, const fu::str& to)
{
    const int min = ((from.size() < to.size()) ? from.size() : to.size());
    int same = 0;
    for (int i = 0; i < min; i++)
    {
        const char /*from|static*/ a = from[i];
        const char /*to|static*/ b = to[i];
        if (b != a)
            break;
        else if (b == '/')
            same = (i + 1);

    };
    /*MOV*/ fu::str res {};
    for (int i_1 = same; i_1 < from.size(); i_1++)
    {
        if (from[i_1] == '/')
            res += "../"_fu;

    };
    res += fu::slice(to, same);
    return /*NRVO*/ res;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str from = "/a/b/c"_fu;
    fu::str to = "/a/e/f"_fu;
    fu::str rel = path_relative_TGelh3Ij(from, to);
    if (rel == "../e/f"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn test(ref a: i32[]) {
            if ((a[0] + a[2]) & 1) {
                shadow ref a = a[0 : 2];                        // GNUStmtExpr
                return a;
            }
            else {
                shadow ref a = a[2 : 4];                        // PointlessLocal
                return a;
            }
        }

        inline fn sum(ref a: [i32]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            for (mut i = 0; i < a.len; i++) a[i] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            return sum(test(a))[0] - 7;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
    fu::view<int> BL_1_v {};
    return (__extension__ (
    {
        fu::view_mut<int> BL_2_v {};
        fu::view_mut<int> BL_3_v {};
        fu::view_mut<int> /*a|a*/ a_1 = (((a[0] + a[2]) & 1) ? (__extension__ (
        {
            fu::view_mut<int> /*a*/ a_2 = fu::get_view_mut(a, 0, 2);
            BL_2_v = (a_2);
        (void)0;}), static_cast<fu::view_mut<int>&&>(BL_2_v)) : (__extension__ (
        {
            fu::view_mut<int> /*a*/ a_2 = fu::get_view_mut(a, 2, 4);
            BL_3_v = (a_2);
        (void)0;}), static_cast<fu::view_mut<int>&&>(BL_3_v)));
        int sum = 0;
        for (int i = 0; i < a_1.size(); i++)
            sum += a_1[i];

        for (int i_1 = 0; i_1 < a_1.size(); i_1++)
            a_1.mutref(i_1) = sum;

        BL_1_v = (a_1);
    (void)0;}), static_cast<fu::view<int>&&>(BL_1_v))[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_RelaxRespec

-----

        inline fn test(ref a: i32[], ref b: i32[]) {
            if ((a[0] + b[0]) & 1)
                return a;

            return b;
        }

        inline fn sum(ref a: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            a.shrink(1);
            a[0] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2 ];
            mut b = [ 3, 4 ];
            return sum(test(a, b))[0] - 7;                      // GNUStmtExpr
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<2, int> { 3, 4 } };
    fu::view<int> BL_1_v {};
    return (__extension__ (
    {
        fu::vec<int>& /*b|a*/ a_1 = (((a[0] + b[0]) & 1) ? a : b);
        int sum = 0;
        for (int i = 0; i < a_1.size(); i++)
            sum += a_1[i];

        a_1.shrink(1);
        a_1.mutref(0) = sum;
        BL_1_v = (a_1);
    (void)0;}), static_cast<fu::view<int>&&>(BL_1_v))[0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        inline fn hey(ref arr: i32[], a: i32) {
            if (a & 1) {
                arr.grow_if_oob(a)++;

            }

            return arr;
        }

        fn main() {
            mut a = [ 1 ];
            return a[0] - hey(a, 1)[1];                         // GNUStmtExpr
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int _0 {};
    fu::view<int> BL_1_v {};
    return (_0 = a[0], (_0 - (__extension__ (
    {
        const int a_1 = 1;
        if (a_1 & 1)
            (((a.size() <= a_1) && (a.grow((a_1 + 1)), 0)), a.mutref(a_1))++;

        BL_1_v = (a);
    (void)0;}), static_cast<fu::view<int>&&>(BL_1_v))[1]));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

-----

        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        inline fn hey(ref arr: i32[], a: i32) {
            if (a & 1) {
                arr.grow_if_oob(a)++;

                return arr[0 : a + 1];

            }

            return arr;
        }

        fn main() {
            mut a = [ 1 ];
            return a[0] - hey(a, 1)[1];                         // GNUStmtExpr
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int _0 {};
    fu::view<int> BL_1_v {};
    return (_0 = a[0], (_0 - (__extension__ (
    {
        const int a_1 = 1;
        BL_1_v = (((a_1 & 1) ? ((((a.size() <= a_1) && (a.grow((a_1 + 1)), 0)), a.mutref(a_1))++, fu::get_view(a, 0, (a_1 + 1))) : a));
    (void)0;}), static_cast<fu::view<int>&&>(BL_1_v))[1]));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_BckMustSeq

-----

        fn serializeType(type: string, debug: string)
            debug ~ ":" ~ type;

        fn mangleArguments(args: [$T]): string {
            mut mangle = "";
            for (mut i = 0; i < args.len; i++) {
                if (i) mangle ~= ",";
                mangle ~= serializeType(args[i], debug: "M");
            }
            return mangle;
        }

        fn trySpecialize(args: string[], ref args_mangled: string) {
            args_mangled ||= mangleArguments(args);
            return args_mangled.len;
        }

        fn main() {
            mut args_mangled: string;
            return trySpecialize([ "a", "b" ], args_mangled) - 7;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str serializeType_1HFAO8ji(fu::view<char> type, fu::view<char> debug)
{
    return (debug + ":"_fu) + type;
}

inline static fu::str mangleArguments_7xJ6vcOm(fu::view<fu::str> args)
{
    /*MOV*/ fu::str mangle = ""_fu;
    for (int i = 0; i < args.size(); i++)
    {
        if (i)
            mangle += ","_fu;

        mangle += serializeType_1HFAO8ji(args[i], "M"_fu);
    };
    return /*NRVO*/ mangle;
}

static int trySpecialize_zX0i0Zo9(fu::view<fu::str> args, fu::str& args_mangled)
{
    if (!(args_mangled))
        args_mangled = mangleArguments_7xJ6vcOm(args);

    return args_mangled.size();
}

int fu_MAIN()
{
    fu::str args_mangled {};
    return trySpecialize_zX0i0Zo9((fu::slate<2, fu::str> { "a"_fu, "b"_fu }), args_mangled) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        let EMIT_CPP = 1 << 0;
        let EMIT_OBJ = 1 << 1;
        let EMIT_BIN = 1 << 2;

        struct Cmd { self: string; options: i32 };

        inline fn unlessHasExt(str: string) {
            let idx = str.find('.');                            // GNUStmtExpr
            if (idx > 0)
                return [];

            return str;
        }

        fn parseOptions(argv: string[]) {
            mut idx = 0;
            fn next(): string {
                let i = idx++;
                if (i < argv.len) return argv[i];
                return "";
            }

            let self = next();
            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.
                return [];

            mut options: i32;
            mut val = next();
            while (val.len > 1 && val[0] == '-') {
                mut opt = val;
                if (opt[1] != '-') {
                    opt = [ opt[1] ];
                    val = '-' ~ val.slice(2);
                    if (val == "-")
                        val = next();
                }
                else
                    val = next();

                fn option(short: string, o: i32) {
                    if (opt == short) {
                        options |= o;
                        opt = "";
                    }
                }

                option("c", EMIT_CPP);
                option("o", EMIT_OBJ);
                option("b", EMIT_BIN);

                if (opt)
                    throw("Unknown option: '" ~ opt ~ "'.");
            }

            return Cmd(unlessHasExt(self), options);
        }

        fn main() = parseOptions([ "./hey", "-c", "-b" ]).options - (EMIT_CPP | EMIT_BIN);

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_Cmd;

                                #ifndef DEF_s_Cmd
                                #define DEF_s_Cmd
struct s_Cmd
{
    fu::str self;
    int options;
    explicit operator bool() const noexcept
    {
        return false
            || self
            || options
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str next_MWY2fGIW(fu::view<fu::str> argv, int& idx)
{
    const int i = idx++;
    if (i < argv.size())
        return fu::str(argv[i]);
    else
        return ""_fu;

}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_EMIT_CPP
                                #define DEF_EMIT_CPP
inline constexpr int EMIT_CPP = (1 << 0);
                                #endif

static void option_o87NlJ6h(fu::view<char> sHort, const int o, int& options, fu::str& opt)
{
    if (opt == sHort)
    {
        options |= o;
        opt = ""_fu;
    };
}

                                #ifndef DEF_EMIT_OBJ
                                #define DEF_EMIT_OBJ
inline constexpr int EMIT_OBJ = (1 << 1);
                                #endif

                                #ifndef DEF_EMIT_BIN
                                #define DEF_EMIT_BIN
inline constexpr int EMIT_BIN = (1 << 2);
                                #endif

                                #ifndef DEF_find_KonMQ4KBuu5
                                #define DEF_find_KonMQ4KBuu5
inline int find_KonMQ4KB(fu::view<char> a, const char b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

static s_Cmd parseOptions_JAqklO28(fu::view<fu::str> argv)
{
    int idx = 0;
    fu::str self = next_MWY2fGIW(argv, idx);
    if (argv.size() == 1)
    {
        return s_Cmd{};
    }
    else
    {
        int options {};
        fu::str val = next_MWY2fGIW(argv, idx);
        while ((val.size() > 1) && (val[0] == '-'))
        {
            fu::str opt { val };
            if (opt[1] != '-')
            {
                opt = fu::str { fu::slate<1, char> { opt[1] } };
                val = ('-' + fu::slice(val, 2));
                if (val == "-"_fu)
                    val = next_MWY2fGIW(argv, idx);

            }
            else
                val = next_MWY2fGIW(argv, idx);

            option_o87NlJ6h("c"_fu, EMIT_CPP, options, opt);
            option_o87NlJ6h("o"_fu, EMIT_OBJ, options, opt);
            option_o87NlJ6h("b"_fu, EMIT_BIN, options, opt);
            if (opt)
                fu::fail((("Unknown option: '"_fu + opt) + "'."_fu));

        };
        const fu::str* BL_9_v;
        return s_Cmd { fu::str((__extension__ (
        {
            const int idx_1 = find_KonMQ4KB(self, '.');
            BL_9_v = &(((idx_1 > 0) ? (*(const fu::str*)fu::NIL) : self));
        (void)0;}), *BL_9_v)), options };
    };
}

int fu_MAIN()
{
    return parseOptions_JAqklO28((fu::slate<3, fu::str> { "./hey"_fu, "-c"_fu, "-b"_fu })).options - (EMIT_CPP | EMIT_BIN);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_SD_HasStaticInit

-----

        fn withPrefixed(b: byte, view: [byte], fn) {
            mut tmp: string;
            return fn(view.len > 1 ? view : tmp = b ~ view);
        }

        fn main() withPrefixed('a', "b"): |ab| return ab.len - 2;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char b = 'a';
    fu::str view = "b"_fu;
    fu::str tmp {};
    fu::view<char> /*tmp|view*/ ab = ((view.size() > 1) ? view : (tmp = (b + view)));
    return ab.size() - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn tryIntersect(left: [byte], right: [byte], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;


            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : qq.byte ~ left[lq && 1 : left.len],

                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    {
        /*MOV*/ fu::str left = "7a012345678900123456789001234567890"_fu;
        /*MOV*/ fu::str right = "5a012345678900123456789001234567890"_fu;
        const char /*left|static*/ l = left[0];
        const char /*right|static*/ r = right[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (!(fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(right, (rq ? 1 : 0), right.size())))
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            fu::str m = ((qq == ll) ? static_cast<fu::str&&>(left) : ((qq == rr) ? static_cast<fu::str&&>(right) : (char(qq) + fu::get_view(left, (lq ? 1 : 0), left.size()))));
            const bool left_1 = (qq == ll);
            if ((m == "7a012345678900123456789001234567890"_fu) && left_1)
                return 0;
            else
                return 100;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn tryIntersect(left: [byte], right: [byte], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;


            mut tmp: string;
            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : tmp = (qq.byte ~ left[lq && 1 : left.len]),

                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    {
        fu::str left = "7a012345678900123456789001234567890"_fu;
        fu::str right = "5a012345678900123456789001234567890"_fu;
        const char /*left|static*/ l = left[0];
        const char /*right|static*/ r = right[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (!(fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(right, (rq ? 1 : 0), right.size())))
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            fu::str tmp {};
            fu::view<char> /*tmp|right|left*/ m = ((qq == ll) ? left : ((qq == rr) ? right : (tmp = (char(qq) + fu::get_view(left, (lq ? 1 : 0), left.size())))));
            const bool left_1 = (qq == ll);
            if ((m == "7a012345678900123456789001234567890"_fu) && left_1)
                return 0;
            else
                return 100;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

-----

        // Added this while replacing the inliner, used to compile with a [byte].

        type Right = byte[:]; 

        fn tryIntersect(left: [byte], right: Right, ifLeft, ifNotLeft) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;

            if (qq == ll)   ifLeft();
            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 : right.len]);

            return true;
        }

        fn TP_get(typeParams!: string, id!: string)
        {
            id || assert();

            mut start = 0;
            for (;;)
            {
                let idx = typeParams.find(id, :start);
                if (idx < 0)
                    return -1;

                start = id.len;
                if (typeParams[start] == ' ')
                    return start + 1;
            }
        }

        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {
            let start = TP_get(:typeParams, :id);
            if (start < 0) {
                typeParams ~= id;
                typeParams ~= canon;
                typeParams ~= '	';
                return true;
            }

            let end = typeParams.find('	', :start);
            return tryIntersect(typeParams[start : end], canon,
                ifLeft: || { /* egyptian */
                    return true;
                },                  // <- Lint complained about the nested curlies here ...
                ifNotLeft: |inter|
                { /* pedantic */
                    typeParams.splice(start, end - start, inter);
                    return true;
                });                 // <-  ... and here.

            return false;
        }

        fn main() {
            mut typeParams = "$T 3hey	";

            // I was fiddling with jumps, and broke return type reporting,
            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),
            //   adding this because the test didn't care.
            if (TP_upsert(:typeParams, id: "$T", "x4x"))
                return 202;

            return TP_upsert(:typeParams, id: "$T", "4hey")
                && typeParams == "$T 7hey	" ? 0 : 101;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 20:50+5[0m:

[2m      | [0m
[2m      |             if (qq == ll)   ifLeft();[0m
[2m   20 | [0m            else            ifNotLeft(qq == rr ? [31;1mright[0m : qq ~ right[rq && 1 : right.len]);
[2m      | [0m
[2m      |             return true;[0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1marg[0m [34;1mcanon[0m) -> string

RelaxCopyResize [35;1mfn[0m [34;1mTP_upsert[0m(string, string, string) at [2m42:12+9[0m

-----

        // Added this while replacing the inliner, used to compile with a [byte].

        type Right = byte []; 

        fn tryIntersect(left: [byte], right: Right, ifLeft, ifNotLeft) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;

            if (qq == ll)   ifLeft();
            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 : right.len]);

            return true;
        }

        fn TP_get(typeParams!: string, id!: string)
        {
            id || assert();

            mut start = 0;
            for (;;)
            {
                let idx = typeParams.find(id, :start);
                if (idx < 0)
                    return -1;

                start = id.len;
                if (typeParams[start] == ' ')
                    return start + 1;
            }
        }

        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {
            let start = TP_get(:typeParams, :id);
            if (start < 0) {
                typeParams ~= id;
                typeParams ~= canon;
                typeParams ~= '	';
                return true;
            }

            let end = typeParams.find('	', :start);
            return tryIntersect(typeParams[start : end], canon,
                ifLeft: || { /* egyptian */
                    return true;
                },                  // <- Lint complained about the nested curlies here ...
                ifNotLeft: |inter|
                { /* pedantic */
                    typeParams.splice(start, end - start, inter);
                    return true;
                });                 // <-  ... and here.

            return false;
        }

        fn main() {
            mut typeParams = "$T 3hey	";

            // I was fiddling with jumps, and broke return type reporting,
            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),
            //   adding this because the test didn't care.
            if (TP_upsert(:typeParams, id: "$T", "x4x"))
                return 202;

            return TP_upsert(:typeParams, id: "$T", "4hey")
                && typeParams == "$T 7hey	" ? 0 : 101;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/find.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int TP_get_CsG1JOrs(fu::view<char> typeParams, fu::view<char> id)
{
    if (id)
    {
        int start = 0;
        for (; ; )
        {
            const int idx = fu::lfind(typeParams, id, start);
            if (idx < 0)
                return -1;
            else
            {
                start = id.size();
                if (typeParams[start] == ' ')
                    return start + 1;

            };
        };
    }
    else
        fu_ASSERT();

}

                                #ifndef DEF_find_T9i966y9wQg
                                #define DEF_find_T9i966y9wQg
inline int find_T9i966y9(fu::view<char> a, const char b, int start)
{
    start = ((start > 0) ? start : 0);
    for (int i = start; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static bool TP_upsert_A4zUWsEJ(fu::str& typeParams, fu::view<char> id, const fu::str& canon)
{
    const int start = TP_get_CsG1JOrs(typeParams, id);
    if (start < 0)
    {
        typeParams += id;
        typeParams += canon;
        typeParams += '\t';
        return true;
    }
    else
    {
        const int end = find_T9i966y9(typeParams, '\t', start);
        fu::view<char> /*typeParams*/ left = fu::get_view(typeParams, start, end);
        const char /*left|static*/ l = left[0];
        const char /*canon|static*/ r = canon[0];
        const bool lq = ((l > '0') ? (l < '8') : false);
        const bool rq = ((r > '0') ? (r < '8') : false);
        if (fu::get_view(left, (lq ? 1 : 0), left.size()) != fu::get_view(canon, (rq ? 1 : 0), canon.size()))
            return false;
        else
        {
            const int ll = (lq ? (int(fu::u8(l)) - int(fu::u8('0'))) : 0);
            const int rr = (rq ? (int(fu::u8(r)) - int(fu::u8('0'))) : 0);
            const int qq = (ll | rr);
            if (qq == ll)
                return true;
            else
            {
                fu::str inter = ((qq == rr) ? fu::str(canon) : x7E_gCeFmDFw(fu::i64dec(qq), fu::get_view(canon, (rq ? 1 : 0), canon.size())));
                typeParams.splice(start, (end - start), inter);
                return true;
            };
        };
    };
}

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str typeParams = "$T 3hey\t"_fu;
    if (TP_upsert_A4zUWsEJ(typeParams, "$T"_fu, "x4x"_fu))
        return 202;
    else if (TP_upsert_A4zUWsEJ(typeParams, "$T"_fu, "4hey"_fu) && (typeParams == "$T 7hey\t"_fu))
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn fails_with_silly_error(ref set: i32[], i) {

            set  ||= i;  //  outputing a decent err msg
            return set;
        }

        fn main() {
            mut set = [ 0 ];
            fails_with_silly_error(set, 2);

            mut sum = 0;
            for (mut i = 0; i < set.len; i++) sum += set[i];
            return sum - 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:18+3[0m:

[2m      |         fn fails_with_silly_error(ref set: i32[], i) {[0m
[2m      | [0m
[2m    4 | [0m            set  [31;1m||=[0m i;  //  outputing a decent err msg
[2m      |             return set;[0m
[2m      |         }[0m

	Bad call to [34;1m||=[0m with args (i32[] mutref copy resize, i32 copy): 

	[35;1mtemplate[0m [34;1m||=[0m at [2m../../../../../[0mprelude[2m 166:10+3[0m:
[2m  166 | [0minfix fn [31;1m||=[0m !T(ref a: T, inline b: T): &mut T = a || (a = b);

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: i32[] copy resize Typename <-> i32 copy Typename

        Solving [35;1mfn[0m [34;1mfails_with_silly_error[0m(i32[:], i32) at [2m2:12+22[0m
                [35;1mfn[0m [34;1mmain[0m at [2m8:12+4[0m

-----

        fn fails_with_silly_error(ref set: i32[], i) {
 // this BUGged out instead of
            set   ~= i;  //  outputing a decent err msg
            return set;
        }

        fn main() {
            mut set = [ 0 ];
            fails_with_silly_error(set, 2);

            mut sum = 0;
            for (mut i = 0; i < set.len; i++) sum += set[i];
            return sum - 2;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

inline static fu::vec<int>& fails_with_silly_error_rp4azl6g(fu::vec<int>& set, const int i)
{
    set += i;
    return set;
}

int fu_MAIN()
{
    fu::vec<int> set = fu::vec<int> { fu::slate<1, int> { 0 } };
    fails_with_silly_error_rp4azl6g(set, 2);
    int sum = 0;
    for (int i = 0; i < set.size(); i++)
        sum += set[i];

    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn solve(ref output: i32[], input: i32[])
        {
            fn SLOW_traverse(visit)
                for (mut i = 0; i < input.len; i++)
                    visit(input[i]);

            fn qSTACK(id: i32, implicit _current_fnort: i32) {
                SLOW_traverse: |x|
                    if (id == x)
                        return id || _current_fnort;

                return 0;
            }

            fn doTrySpecialize(target: i32)
            {
                fn updateScope(result: i32)
                    output ~= result || qSTACK(result + 1);

                if (target & 1) {
                    updateScope(target); // 1 - 1
                    return;
                }

                let implicit _current_fnort = target;
                updateScope(target / 2); // 4 - 2, 2 - 1, 0 - 0
            }

            let implicit _current_fnort = 1;

            doTrySpecialize(1);
            for (mut i = 0; i < input.len; i++)
                doTrySpecialize(input[i]);
        }

        fn main() {
            mut output: i32[];
            solve(output, input: [ 0, 3 ]);

            return output[0] == 1
                && output[1] == 0
                && output[2] == 3 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int qSTACK_AdJ6AdAB(const int id, const int _current_fnort, fu::view<int> input)
{
    for (int i = 0; i < input.size(); i++)
    {
        const int /*input|static*/ x = input[i];
        if (id == x)
            return (id ? id : _current_fnort);

    };
    return 0;
}

static fu::vec<int>& updateScope_uKGiCPS4(const int result, fu::vec<int>& output, fu::view<int> input, const int _current_fnort)
{
    return (output += (result ? result : qSTACK_AdJ6AdAB((result + 1), _current_fnort, input)));
}

static void doTrySpecialize_14xRSfC2(const int target, fu::vec<int>& output, fu::view<int> input, const int _current_fnort)
{
    if (target & 1)
        updateScope_uKGiCPS4(target, output, input, _current_fnort);
    else
        updateScope_uKGiCPS4((target / 2), output, input, target);

}

static void solve_5q1Co7e6(fu::vec<int>& output, fu::view<int> input)
{
    const int _current_fnort = 1;
    doTrySpecialize_14xRSfC2(1, output, input, _current_fnort);
    for (int i = 0; i < input.size(); i++)
        doTrySpecialize_14xRSfC2(input[i], output, input, _current_fnort);

}

int fu_MAIN()
{
    fu::vec<int> output {};
    solve_5q1Co7e6(output, (fu::slate<2, int> { 0, 3 }));
    if ((output[0] == 1) && (output[1] == 0) && (output[2] == 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----


        fn noop_let_lax(lax ref x: i32) {
            let lax y = x;
        }

        fn main() {
            mut x = 0;
            noop_let_lax(x);
            return x;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:12+12[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        fn [31;1mnoop_let_lax[0m(lax ref x: i32) {
[2m      |             let lax y = x;[0m
[2m      |         }[0m

	[35;1mfn[0m [34;1mnoop_let_lax[0m does nothing: returns void and has no effects. Make it [35;1mlax[0m if this is intentional.

-----


        lax                
        fn noop_let_lax(lax ref x: i32) {
            let lax y = x;
        }

        fn main() {
            mut x = 0;
            noop_let_lax(x);
            return x;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    return x;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

-----

        fn compile_begin(mul: i32) {
            let id = mul * 10;
            let implicit options = getModule(:id);
            return compile(:id);
        }

        fn compile(implicit options: i32, id: i32) {
            return getModule(id) + options;
        }

        fn getModule(id: i32, implicit ctx: i32) {
            return ctx + id;
        }

-----

#ifndef fu_NO_fdefs

int getModule_8TYzUWn1(const int id, const int ctx)
{
    return ctx + id;
}

int compile_c8FXXkEJ(const int id, const int options, const int ctx)
{
    return getModule_8TYzUWn1(id, ctx) + options;
}

int compile_begin_Tbi9lG4a(const int mul, const int ctx)
{
    const int id = (mul * 10);
    const int options = getModule_8TYzUWn1(id, ctx);
    return compile_c8FXXkEJ(id, options, ctx);
}

#endif

-----

        fn compile_begin(mul: i32) {
            let id = mul * 10;
            let implicit options = getModule(:id);
            return compile(:id);
        }

        fn compile(implicit options: i32, id: i32) {
            return getModule(id) + options;
        }

        fn getModule(id: i32, implicit ctx: i32) {
            return ctx + id;
        }

        import _0;

        fn main() {
            let implicit ctx = 2;
            return compile_begin(3) - 64;
        }

-----
int compile_begin_Tbi9lG4a(int, int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ctx = 2;
    return compile_begin_Tbi9lG4a(3, ctx) - 64;
}

#endif

int main() { return fu_MAIN(); }

-----

        // An empty file.

-----

-----

        // An empty file.

        fn sqr(x: i32) x * x;

-----

#ifndef fu_NO_fdefs

int sqr_W0HwfDvt(const int x)
{
    return x * x;
}

#endif

-----

        // An empty file.

        fn sqr(x: i32) x * x;

        import _0;
        import _1;

        fn main() = 0.sqr;

-----
int sqr_W0HwfDvt(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return sqr_W0HwfDvt(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec2 {
            x?: f32;
            y?: f32;
        };

        inline fn *=(ref a: vec2, b: f32) {
            a.x *= b;
            a.y *= b;
            return a;
        }

        fn main() {
            mut v = vec2(1, 1);
            v *= 0.5; // BUG: Considering copy or move for incompatible types: vec2: copy <- f32: copy
            return v.x.i32;
        }

-----
struct s_vec2;

                                #ifndef DEF_s_vec2
                                #define DEF_s_vec2
struct s_vec2
{
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec2 v = s_vec2 { 1.0f, 1.0f };

    {
        const float b = 0.5f;
        v.x *= b;
        v.y *= b;
    };
    return int(v.x);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x: f32; y: f32; z: f32; };

        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);

        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

-----

-----

        struct vec3 { x: f32; y: f32; z: f32; };

        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);

        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        import _0;

        struct Atmosphere { pView: vec3; rPlanet: f32; };

        let rEarth: f32 = 1e3;

        fn Atmosphere(
            altitude: f32,
            rPlanet: f32 = rEarth,
            vUp = vec3(z: 1)) // <- this crashes
        {
            let pView = vUp * (rPlanet + altitude);
            return Atmosphere(:rPlanet, :pView);                // GNUStmtExpr
        }

-----
struct s_Atmosphere;
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Atmosphere
                                #define DEF_s_Atmosphere
struct s_Atmosphere
{
    s_vec3 pView;
    float rPlanet;
    explicit operator bool() const noexcept
    {
        return false
            || pView
            || rPlanet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_rEarth
                                #define DEF_rEarth
inline constexpr float rEarth = 1e3f;
                                #endif

s_Atmosphere Atmosphere_raJ7TDDI(const float altitude, const float rPlanet, const s_vec3& vUp)
{
    s_vec3 BL_1_v {};
    const s_vec3 pView = (__extension__ (
    {
        const float b = (rPlanet + altitude);
        BL_1_v = (s_vec3 { (vUp.x * b), (vUp.y * b), (vUp.z * b) });
    (void)0;}), static_cast<s_vec3&&>(BL_1_v));
    return s_Atmosphere { s_vec3(pView), rPlanet };
}

#endif

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };

        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);

        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        import _0;

        struct Atmosphere { pView: vec3; rPlanet: f32; };

        let rEarth: f32 = 1e3;

        fn Atmosphere(
            altitude: f32,
            rPlanet: f32 = rEarth,
            vUp = vec3(z: 1)) // <- this crashes
        {
            let pView = vUp * (rPlanet + altitude);
            return Atmosphere(:rPlanet, :pView);                // GNUStmtExpr
        }

        import _0;
        import _1;

        fn main() {
            let atmo = Atmosphere(altitude: 1e2);
            return atmo.pView.z == 11e2 ? 0 : 1;                // GNUStmtExpr
        }

-----
struct s_Atmosphere;
struct s_vec3;
s_Atmosphere Atmosphere_raJ7TDDI(float, float, const s_vec3&);

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Atmosphere
                                #define DEF_s_Atmosphere
struct s_Atmosphere
{
    s_vec3 pView;
    float rPlanet;
    explicit operator bool() const noexcept
    {
        return false
            || pView
            || rPlanet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_rEarth
                                #define DEF_rEarth
inline constexpr float rEarth = 1e3f;
                                #endif

int fu_MAIN()
{
    s_vec3 BL_1_v {};
    const s_Atmosphere atmo = Atmosphere_raJ7TDDI(1e2f, rEarth, (__extension__ (
    {
        const float z = 1.0f;
        const float x = 0.0f;
        const float y = 0.0f;
        BL_1_v = (s_vec3 { x, y, z });
    (void)0;}), static_cast<s_vec3&&>(BL_1_v)));
    if (atmo.pView.z == 11e2f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn vec3(fill!: f32) fill;

        let kMie_min: f32 = 3e-6;
        inline fn Atmo(kMie = vec3(fill: kMie_min)) = kMie;     // PointlessLocal

        fn main() Atmo == 3e-6 ? 0 : 1;                         // GNUStmtExpr

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

int fu_MAIN()
{
    float BL_1_v {};
    if ((__extension__ (
    {
        const float /*static*/ kMie = kMie_min;
        BL_1_v = (kMie);
    (void)0;}), BL_1_v) == 3e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


        fn main() Atmosphere == 6e-6 ? 0 : 1;                   // GNUStmtExpr

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

int fu_MAIN()
{
    float BL_1_v {};
    if ((__extension__ (
    {
        const s_vec3 kMie = s_vec3 { {}, kMie_min, {} };
        BL_1_v = ((kMie.y * 2.0f));
    (void)0;}), BL_1_v) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;

        pub import _0;
        fn main() Atmosphere == 6e-6 ? 0 : 1;                   // GNUStmtExpr

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

int fu_MAIN()
{
    float BL_1_v {};
    if ((__extension__ (
    {
        const s_vec3 kMie = s_vec3 { {}, kMie_min, {} };
        BL_1_v = ((kMie.y * 2.0f));
    (void)0;}), BL_1_v) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


-----

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        pub import _0;
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


        fn main() Atmosphere == 6e-6 ? 0 : 1;                   // GNUStmtExpr

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

int fu_MAIN()
{
    float BL_1_v {};
    if ((__extension__ (
    {
        const s_vec3 kMie = s_vec3 { {}, kMie_min, {} };
        BL_1_v = ((kMie.y * 2.0f));
    (void)0;}), BL_1_v) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);


-----

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        pub import _0;
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;


-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        pub import _0;
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;

        pub import _1;
        fn main() Atmosphere == 6e-6 ? 0 : 1;                   // GNUStmtExpr

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_kMie_min
                                #define DEF_kMie_min
inline constexpr float kMie_min = 3e-6f;
                                #endif

int fu_MAIN()
{
    float BL_1_v {};
    if ((__extension__ (
    {
        const s_vec3 kMie = s_vec3 { {}, kMie_min, {} };
        BL_1_v = ((kMie.y * 2.0f));
    (void)0;}), BL_1_v) == 6e-6f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Loop { l: i32 };
        struct Ring { r: i32 };
        struct Mesh { m: i32 };

        fn op(ref m: Mesh, x: i32, l: Loop) m.m += l.l + x;
        fn op(ref m: Mesh, r: Ring, x: i32) m.m *= r.r + x;
        fn op(using ref m: Mesh, l: Loop, r: Ring, x: i32) {
            l.op(:x);
            r.op(:x);
        }

        fn main() {
            mut m = Mesh(1);
            m.op(Loop(2), Ring(7), x: 1);
            return m.m == 32 ? 0 : 1;
        }

-----
struct s_Mesh;
struct s_Loop;
struct s_Ring;

                                #ifndef DEF_s_Mesh
                                #define DEF_s_Mesh
struct s_Mesh
{
    int m;
    explicit operator bool() const noexcept
    {
        return false
            || m
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Loop
                                #define DEF_s_Loop
struct s_Loop
{
    int l;
    explicit operator bool() const noexcept
    {
        return false
            || l
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Ring
                                #define DEF_s_Ring
struct s_Ring
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& op_njwpPTwv(s_Mesh& m, const int x, const s_Loop& l)
{
    return (m.m += (l.l + x));
}

static int& op_esvrL0Wj(s_Mesh& m, const s_Ring& r, const int x)
{
    return (m.m *= (r.r + x));
}

static void op_eHbkGBqE(s_Mesh& m, const s_Loop& l, const s_Ring& r, const int x)
{
    op_njwpPTwv(m, x, l);
    op_esvrL0Wj(m, r, x);
}

int fu_MAIN()
{
    s_Mesh m = s_Mesh { 1 };
    op_eHbkGBqE(m, s_Loop { 2 }, s_Ring { 7 }, 1);
    if (m.m == 32)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct MultiDraw { id: i32; }

-----

-----

        pub struct MultiDraw { id: i32; }

        import _0;
        type ViewQuads = MultiDraw;

        fn ViewQuads(id!: i32, populate!): ViewQuads {
            mut vq = ViewQuads(:id);
            populate(vq);
            return vq;
        }

-----

-----

        pub struct MultiDraw { id: i32; }

        import _0;
        type ViewQuads = MultiDraw;

        fn ViewQuads(id!: i32, populate!): ViewQuads {
            mut vq = ViewQuads(:id);
            populate(vq);
            return vq;
        }

        import _1;
        fn ViewQuads(id!: i32, camera!: i32): ViewQuads {
            return ViewQuads(:id, populate: |ref vq| vq.id += camera);
        }

        fn main() {
            return ViewQuads(id: 2, camera: 5).id - 7;
        }

-----
struct s_MultiDraw;

                                #ifndef DEF_s_MultiDraw
                                #define DEF_s_MultiDraw
struct s_MultiDraw
{
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_3_0_r94EMDvj(s_MultiDraw& vq, const int camera)
{
    return (vq.id += camera);
}

                                #ifndef DEF_ViewQuads_GNONCVxCuci
                                #define DEF_ViewQuads_GNONCVxCuci
inline s_MultiDraw ViewQuads_GNONCVxC(const int id, const int camera)
{
    s_MultiDraw vq = s_MultiDraw { id };
    l_3_0_r94EMDvj(vq, camera);
    return vq;
}
                                #endif

static s_MultiDraw ViewQuads_p5gbmjRh(const int id, const int camera)
{
    return ViewQuads_GNONCVxC(id, camera);
}

int fu_MAIN()
{
    return ViewQuads_p5gbmjRh(2, 5).id - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn setupOperators()
        {
            struct Maplike {
                keys: string[];
                vals: i32[];
            };

            fn set(ref m: Maplike, k: string, v: i32) {
                m.keys ~= k;
                m.vals ~= v;
            }

            struct BINOP {
                PRECEDENCE: Maplike;
                RIGHT_TO_LEFT: bool[];
            };

            mut out: BINOP;
            mut precedence: i32 = -1;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT ~= rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE.set(ops[i], precedence);
            }

            rightToLeft = false;
            binop([ "*", "/", "%" ]);

            rightToLeft = true;
            binop([ "*=", "/=", "%=" ]);

            return out;
        }

        let BINOP = setupOperators();
        fn main() BINOP.RIGHT_TO_LEFT[1] && BINOP.PRECEDENCE.vals[3] == 1 ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>
#include <fu/vec/concat_one.h>

struct s_BINOP;
struct s_Maplike;

                                #ifndef DEF_s_Maplike
                                #define DEF_s_Maplike
struct s_Maplike
{
    fu::vec<fu::str> keys;
    fu::vec<int> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BINOP
                                #define DEF_s_BINOP
struct s_BINOP
{
    s_Maplike PRECEDENCE;
    fu::vec<bool> RIGHT_TO_LEFT;
    explicit operator bool() const noexcept
    {
        return false
            || PRECEDENCE
            || RIGHT_TO_LEFT
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void set_OqdlIyFU(s_Maplike& m, const fu::str& k, const int v)
{
    m.keys += fu::str(k);
    m.vals += v;
}

static void binop_bi9tfQP2(fu::view<fu::str> ops, s_BINOP& out, int& precedence, const bool rightToLeft)
{
    precedence++;
    out.RIGHT_TO_LEFT += rightToLeft;
    for (int i = 0; i < ops.size(); i++)
        set_OqdlIyFU(out.PRECEDENCE, ops[i], precedence);

}

static s_BINOP setupOperators_H9fhQUVP()
{
    /*MOV*/ s_BINOP out {};
    int precedence = -1;
    bool rightToLeft = false;
    rightToLeft = false;
    binop_bi9tfQP2((fu::slate<3, fu::str> { "*"_fu, "/"_fu, "%"_fu }), out, precedence, rightToLeft);
    rightToLeft = true;
    binop_bi9tfQP2((fu::slate<3, fu::str> { "*="_fu, "/="_fu, "%="_fu }), out, precedence, rightToLeft);
    return /*NRVO*/ out;
}

static const s_BINOP BINOP fu_INIT_PRIORITY(1001) = setupOperators_H9fhQUVP();

int fu_MAIN()
{
    if (BINOP.RIGHT_TO_LEFT[1] && (BINOP.PRECEDENCE.vals[3] == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_SD_HasStaticInit

-----

        fn Split !T(str: T[], sep: T or T[:], each) {
            mut last_idx = 0;
            mut next_idx = 0;

            let N = typeof(sep) -> T[:] ? sep.len : 1;
            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {
                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);
                last_idx = next_idx + N;
            }

            if (last_idx)
                each(str.slice(last_idx), first?: false, last?: true);
            else
                each(str, first?: true, last?: true);
        }

        fn Replace !T(str: T[], all: T or T[:], with: T or T[:] or []) {
            mut result: T[];
            Split(str, sep: all, |substr, lax first, lax last| {
                if !(first) {
                    if !(typeof(with) -> [])
                        result ~= with;
                }
                else if (last) {
                    return str;
                }

                result ~= substr;
            });

            return result;
        }

        fn main() {
            let res = "hello".Replace(all: "ll", with: []);
            return res == "heo" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

inline static fu::str Replace_YtKVivLf(const fu::str& str, fu::view<char> all)
{
    /*MOV*/ fu::str result {};

    {
        int last_idx = 0;
        int next_idx = 0;
        const int N = all.size();
        if (N)
        {
            while (((next_idx = fu::lfind(str, all, last_idx)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last_idx, next_idx);
                    result += substr;
                };
                last_idx = (next_idx + N);
            };
        };
        if (last_idx)
        {
            fu::str substr = fu::slice(str, last_idx);
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Replace_YtKVivLf("hello"_fu, "ll"_fu);
    if (res == "heo"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedAndOr, N_UnusedLet

-----

        struct BitSet { _data: u8[] };

        fn add(using _: &mut BitSet, idx: int) {
            let no_neg = idx & int.MIN;
            let bucket = idx >> 3 | no_neg;
            let bit    = idx & 7;
            let mask   = 1 << bit.u8;

            if (_data.len <= bucket)
                _data.grow(bucket + 1);

            _data[bucket] |= mask;
        }

        fn each(using _: BitSet, visit) {
            for (mut i = 0; i < _data.len; i++) {
                let item = _data[i];
                if (item) for (mut b = 0; b < 8; b++) {
                    let mask = 1 << b.u8;
                    if (item & mask)
                        visit(i << 3 | b.int);
                }
            }
        }

        struct Node { items: Node[] }

        fn each(using n: Node, visit)
            for (mut i = 0; i < n.items.len; i++)
                visit(n.items[i]);

        fn traverse(ref node: Node, ref bitset: BitSet) {
            bitset.add(node.items.len);
            node.each(.traverse(:bitset));

            mut res = 0;
            bitset.each: |index|
                res += index;

            return res;
        }

        fn main() {
            mut bitset: BitSet;
            return traverse(Node([ Node([ Node, Node, Node ]), Node ]), :bitset) == 5 ? 0 : 1;
        }

-----
#include <fu/int.h>
#include <fu/vec.h>

struct s_BitSet;
struct s_Node;
static int traverse_9bz4X7X8(const s_Node&, s_BitSet&);

                                #ifndef DEF_s_BitSet
                                #define DEF_s_BitSet
struct s_BitSet
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_MIN_5Mxm22OPs0k
                                #define DEF_MIN_5Mxm22OPs0k
inline int MIN_5Mxm22OP()
{
    return -2147483648;
}
                                #endif

static void add_rNtuo3Go(s_BitSet& _, const int idx)
{
    const int no_neg = (idx & MIN_5Mxm22OP());
    const int bucket = ((idx >> 3) | no_neg);
    const int bit = (idx & 7);
    const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(bit))));
    if ((_._data.size() <= bucket))
        _._data.grow((bucket + 1));

    _._data.mutref(bucket) |= mask;
}

inline static int l_1_0_lHxhqBd0(const s_Node& l_1_0, s_BitSet& bitset)
{
    return traverse_9bz4X7X8(l_1_0, bitset);
}

inline static void each_i6nHRxlu(const s_Node& n, s_BitSet& bitset)
{
    for (int i = 0; i < n.items.size(); i++)
        l_1_0_lHxhqBd0(n.items[i], bitset);

}

inline static int& l_1_1_1Q4zB3Zp(const int index, int& res)
{
    return (res += index);
}

inline static void each_aNbtr7OC(const s_BitSet& _, int& res)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 /*_|static*/ item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    l_1_1_1Q4zB3Zp(((i << 3) | int(b)), res);

            };
        };
    };
}

static int traverse_9bz4X7X8(const s_Node& node, s_BitSet& bitset)
{
    add_rNtuo3Go(bitset, node.items.size());
    each_i6nHRxlu(node, bitset);
    int res = 0;
    each_aNbtr7OC(bitset, res);
    return res;
}

int fu_MAIN()
{
    s_BitSet bitset {};
    if (traverse_9bz4X7X8(s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { fu::vec<s_Node> { fu::slate<3, s_Node> { s_Node{}, s_Node{}, s_Node{} } } }, s_Node{} } } }, bitset) == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_UnusedCall

-----

        struct Type {
            quals: i32;
            canon: string;
        };

        fn is_never (t: Type) t.canon == "never";
        fn is_zeroes(t: Type) t.canon == "zeroes";

        let CANNOT_definit_mutrefs = true;

        fn clear_mutref(mut t: Type) {
            t.quals &= ~1;
            return t;
        }

        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {
            if (a.canon != b.canon)
                return a.is_never  ? b
                     : b.is_never  ? a
                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
                     : [];

            return Type(:a.canon, a.quals | b.quals);
        }

-----
#include <fu/str.h>
#include <fu/view.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

bool is_never_E7BVw6XF(const s_Type& t)
{
    return t.canon == "never"_fu;
}

bool is_zeroes_E7BVw6XF(const s_Type& t)
{
    return t.canon == "zeroes"_fu;
}

                                #ifndef DEF_CANNOT_definit_mutrefs
                                #define DEF_CANNOT_definit_mutrefs
inline constexpr bool CANNOT_definit_mutrefs = true;
                                #endif

s_Type clear_mutref_4vx5myXl(/*MOV*/ s_Type&& t)
{
    t.quals &= ~1;
    return static_cast<s_Type&&>(t);
}

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

s_Type uNion_z9kwiQWA(const s_Type& a, const s_Type& b, const bool DONT_match_zeroes)
{
    if (a.canon != b.canon)
    {
        if (is_never_E7BVw6XF(a))
            return s_Type(b);
        else if (is_never_E7BVw6XF(b))
            return s_Type(a);
        else if (is_zeroes_E7BVw6XF(a) && !DONT_match_zeroes)
            return clear_mutref_4vx5myXl(s_Type(b));
        else if (is_zeroes_E7BVw6XF(b) && !DONT_match_zeroes)
            return clear_mutref_4vx5myXl(s_Type(a));
        else
        {
            return s_Type{};
        };
    }
    else
    {
        return s_Type { (a.quals | b.quals), fu::str(a.canon) };
    };
}

#endif

// N_NonTrivAutoCopy, N_SD_HasStaticInit

-----

        struct Type {
            quals: i32;
            canon: string;
        };

        fn is_never (t: Type) t.canon == "never";
        fn is_zeroes(t: Type) t.canon == "zeroes";

        let CANNOT_definit_mutrefs = true;

        fn clear_mutref(mut t: Type) {
            t.quals &= ~1;
            return t;
        }

        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {
            if (a.canon != b.canon)
                return a.is_never  ? b
                     : b.is_never  ? a
                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
                     : [];

            return Type(:a.canon, a.quals | b.quals);
        }

        import _0;
        fn main() {
            let Hey1    = Type(1, "hey");
            let Zeroes  = Type(0, "zeroes");
            let res     = union(Hey1, Zeroes);
            return res.canon == "hey" && res.quals == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>

struct s_Type;
s_Type uNion_z9kwiQWA(const s_Type&, const s_Type&, bool);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int quals;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || canon
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Type Hey1 = s_Type { 1, "hey"_fu };
    s_Type Zeroes = s_Type { 0, "zeroes"_fu };
    s_Type res = uNion_z9kwiQWA(Hey1, Zeroes, false);
    if ((res.canon == "hey"_fu) && (res.quals == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        inline 
        fn inlineSelfRecursion(x: int)
            x > 10  ? inlineSelfRecursion(x / 2)
                    : x;

        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:38+1[0m:

[2m      |                     : x;[0m
[2m      | [0m
[2m    8 | [0m        fn main() inlineSelfRecursion[31;1m([0m15) == 7 ? 0 : 1;
[2m      | [0m

	Cannot inline self-recursive fns: [35;1minline[0m [34;1minlineSelfRecursion[0m

        Solving [35;1mfn[0m [34;1mmain[0m at [2m8:12+4[0m

-----


        fn inlineSelfRecursion(x: int)
            x > 10  ? inlineSelfRecursion(x / 2)
                    : x;

        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;

-----
static int inlineSelfRecursion_1WsbUdat(int);

#ifndef fu_NO_fdefs

static int inlineSelfRecursion_1WsbUdat(const int x)
{
    if (x > 10)
        return inlineSelfRecursion_1WsbUdat((x / 2));
    else
        return x;

}

int fu_MAIN()
{
    if (inlineSelfRecursion_1WsbUdat(15) == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----


        inline 
        fn inlineMutualRecursion_a(x: int)
            x > 10  ? inlineMutualRecursion_b(x / 2)
                    : x;

        inline fn inlineMutualRecursion_b(x: int)
            x > 5   ? inlineMutualRecursion_a(x / 2)
                    : x;

        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:46+1[0m:

[2m      | [0m
[2m      |         inline fn inlineMutualRecursion_b(x: int)[0m
[2m    9 | [0m            x > 5   ? inlineMutualRecursion_a[31;1m([0mx / 2)
[2m      |                     : x;[0m
[2m      | [0m

	Cannot inline self-recursive fns: [35;1minline[0m [34;1minlineMutualRecursion_a[0m

        Solving [35;1minline[0m [34;1minlineMutualRecursion_b[0m(i32) at [2m8:19+23[0m

-----


        fn inlineMutualRecursion_a(x: int)
            x > 10  ? inlineMutualRecursion_b(x / 2)
                    : x;

        inline fn inlineMutualRecursion_b(x: int)
            x > 5   ? inlineMutualRecursion_a(x / 2)
                    : x;

        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;

-----
static int inlineMutualRecursion_a_1WsbUdat(int);

#ifndef fu_NO_fdefs

static int inlineMutualRecursion_a_1WsbUdat(const int x)
{
    if (x > 10)
    {
        const int x_1 = (x / 2);
        if (x_1 > 5)
            return inlineMutualRecursion_a_1WsbUdat((x_1 / 2));
        else
            return x_1;

    }
    else
        return x;

}

int fu_MAIN()
{
    if (inlineMutualRecursion_a_1WsbUdat(15) == 3)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        nocopy struct SolverOutput {
            content?: SolverOutput[];
        };

        fn test(ref _helpers_data: i32[], mut content: SolverOutput[])
        {
            _helpers_data.len & 1 && _helpers_data.pop();
            {
                _helpers_data && throw("non-empty _helpers_data.");
                {
                    content.len & 1 && content.pop();
                    {
                        return SolverOutput(:content);
                    }
                }
            }
        }

        fn main() {
            mut _helpers_data: i32[];
            mut content: SolverOutput[];
            return test(_helpers_data, content).content.len;    // !*MustSeq
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>

struct s_SolverOutput;

                                #ifndef DEF_s_SolverOutput
                                #define DEF_s_SolverOutput
struct s_SolverOutput
{
    fu::vec<s_SolverOutput> content;
    s_SolverOutput(const s_SolverOutput&) = delete;
    s_SolverOutput(s_SolverOutput&&) = default;
    s_SolverOutput& operator=(const s_SolverOutput&) = delete;
    s_SolverOutput& operator=(s_SolverOutput&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || content
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_SolverOutput test_qbMB8y2K(fu::vec<int>& _helpers_data, /*MOV*/ fu::vec<s_SolverOutput>&& content)
{
    if (_helpers_data.size() & 1)
        _helpers_data.pop();

    if (_helpers_data)
        fu::fail("non-empty _helpers_data."_fu);
    else
    {
        if (content.size() & 1)
            content.pop();

        return s_SolverOutput { static_cast<fu::vec<s_SolverOutput>&&>(content) };
    };
}

int fu_MAIN()
{
    fu::vec<int> _helpers_data {};
    /*MOV*/ fu::vec<s_SolverOutput> content {};
    return test_qbMB8y2K(_helpers_data, static_cast<fu::vec<s_SolverOutput>&&>(content)).content.size();
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve

-----

        struct Type { quals: i32; };
        struct Node { type: Type; };

        fn unusedLetExprOrBlock(args_in: [Node], default: Node) {
            mut inType: Type;
            for (mut i = 0; i < args_in.len; i++) {
                // got this while auto-reducing smth else,
                //  nonsense but currently bugs mcom
                lax let inValue = args_in[i] || {
                    inType = default.type;  //      <- then, mcom tries to copy here
                    default                 // <- first this gets discarded
                };
            }

            return inType;
        }

        fn main() {
            return unusedLetExprOrBlock([ Node() ], Node(Type(1))).quals - 1;
        }

-----
#include <fu/view.h>

struct s_Node;
struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || quals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Type unusedLetExprOrBlock_OaLHECxW(fu::view<s_Node> args_in, const s_Node& dEfault)
{
    s_Type inType {};
    for (int i = 0; i < args_in.size(); i++)
    {
        if (!(args_in[i]))
            inType = dEfault.type;

    };
    return inType;
}

int fu_MAIN()
{
    return unusedLetExprOrBlock_OaLHECxW((fu::slate<1, s_Node> { s_Node{} }), s_Node { s_Type { 1 } }).quals - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        fn parse !T(v: [byte], lax as!: T) {
            mut result: T;

            if (T.is::bitfield) {
                for (mut i = 1; i < v.len; i++) {
                    if (v[i] == '|') {
                        return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);
                    }
                }
            }

            for (mut i = 0; i < v.len; i++) {
                if (v[i] == '*') {
                    let prefix = v[0 : i];
                    let suffix = v[i + 1 : v.len]

                    for (fieldname i: T) {
                        let opt = "i";
                        if (opt.starts(with: prefix) && opt.ends(with: suffix))
                            result |= T.i;
                    }

                    return result;
                }
                else if (i > 0 && v[i] == '|') {
                    return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);
                }
            }

            for (fieldname i: T)
                if (v == "i")
                    return T.i;

            return [];
        }

        flags UpperCase { Hello = 1; World = 2; Cruel = 4; CruelWorld = 8 };
        flags LowerCase { hello = 16; world = 32; cruel = 64; cruel_world = 128 };

        fn parseUpperOrLower(str: string) {
            if (let upper = parse(str, as: UpperCase))
                return upper.i32;
            else if (let lower = parse(str, as: LowerCase))
                return lower.i32;
            else
                return 0;
        }

        fn main() {
            if (parseUpperOrLower("World|Cruel*") != 2|4|8) return 1;
            if (parseUpperOrLower("*world|hello") != 16|32|128) return 2;
            return 0;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>

typedef fu::u8 s_UpperCase;
typedef fu::u8 s_LowerCase;
inline static s_UpperCase parse_K17aXsKI(fu::view<char>, s_UpperCase);
inline static s_LowerCase parse_bqFR2zVU(fu::view<char>, s_LowerCase);

                                #ifndef DEF_s_UpperCase
                                #define DEF_s_UpperCase
inline constexpr s_UpperCase s_UpperCase_Hello = s_UpperCase(1u);
inline constexpr s_UpperCase s_UpperCase_World = s_UpperCase(2u);
inline constexpr s_UpperCase s_UpperCase_Cruel = s_UpperCase(4u);
inline constexpr s_UpperCase s_UpperCase_CruelWorld = s_UpperCase(8u);

inline constexpr s_UpperCase MASK_s_UpperCase
    = s_UpperCase_Hello
    | s_UpperCase_World
    | s_UpperCase_Cruel
    | s_UpperCase_CruelWorld;
                                #endif

                                #ifndef DEF_s_LowerCase
                                #define DEF_s_LowerCase
inline constexpr s_LowerCase s_LowerCase_hello = s_LowerCase(16u);
inline constexpr s_LowerCase s_LowerCase_world = s_LowerCase(32u);
inline constexpr s_LowerCase s_LowerCase_cruel = s_LowerCase(64u);
inline constexpr s_LowerCase s_LowerCase_cruel_world = s_LowerCase(128u);

inline constexpr s_LowerCase MASK_s_LowerCase
    = s_LowerCase_hello
    | s_LowerCase_world
    | s_LowerCase_cruel
    | s_LowerCase_cruel_world;
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_starts_t2TApdnqRc8
                                #define DEF_starts_t2TApdnqRc8
inline bool starts_t2TApdnq(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF_ends_t2TApdnqRc8
                                #define DEF_ends_t2TApdnqRc8
inline bool ends_t2TApdnq(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

inline static s_UpperCase parse_K17aXsKI(fu::view<char> v, const s_UpperCase as)
{
    s_UpperCase result {};
    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] == '|')
            return parse_K17aXsKI(fu::get_view(v, 0, i), as) | parse_K17aXsKI(fu::get_view(v, (i + 1), v.size()), as);

    };
    for (int i_1 = 0; i_1 < v.size(); i_1++)
    {
        if (v[i_1] == '*')
        {
            fu::view<char> /*v*/ prefix = fu::get_view(v, 0, i_1);
            fu::view<char> /*v*/ suffix = fu::get_view(v, (i_1 + 1), v.size());

            {

                {
                    fu::str opt = "Hello"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_UpperCase_Hello;

                };

                {
                    fu::str opt = "World"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_UpperCase_World;

                };

                {
                    fu::str opt = "Cruel"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_UpperCase_Cruel;

                };
                fu::str opt = "CruelWorld"_fu;
                if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                    result |= s_UpperCase_CruelWorld;

            };
            return result;
        }
        else if ((i_1 > 0) && (v[i_1] == '|'))
            return parse_K17aXsKI(fu::get_view(v, 0, i_1), as) | parse_K17aXsKI(fu::get_view(v, (i_1 + 1), v.size()), as);

    };
    if (v == "Hello"_fu)
        return s_UpperCase_Hello;
    else if (v == "World"_fu)
        return s_UpperCase_World;
    else if (v == "Cruel"_fu)
        return s_UpperCase_Cruel;
    else if (v == "CruelWorld"_fu)
        return s_UpperCase_CruelWorld;

    return s_UpperCase{};
}

inline static s_LowerCase parse_bqFR2zVU(fu::view<char> v, const s_LowerCase as)
{
    s_LowerCase result {};
    for (int i = 1; i < v.size(); i++)
    {
        if (v[i] == '|')
            return parse_bqFR2zVU(fu::get_view(v, 0, i), as) | parse_bqFR2zVU(fu::get_view(v, (i + 1), v.size()), as);

    };
    for (int i_1 = 0; i_1 < v.size(); i_1++)
    {
        if (v[i_1] == '*')
        {
            fu::view<char> /*v*/ prefix = fu::get_view(v, 0, i_1);
            fu::view<char> /*v*/ suffix = fu::get_view(v, (i_1 + 1), v.size());

            {

                {
                    fu::str opt = "hello"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_LowerCase_hello;

                };

                {
                    fu::str opt = "world"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_LowerCase_world;

                };

                {
                    fu::str opt = "cruel"_fu;
                    if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                        result |= s_LowerCase_cruel;

                };
                fu::str opt = "cruel_world"_fu;
                if (starts_t2TApdnq(opt, prefix) && ends_t2TApdnq(opt, suffix))
                    result |= s_LowerCase_cruel_world;

            };
            return result;
        }
        else if ((i_1 > 0) && (v[i_1] == '|'))
            return parse_bqFR2zVU(fu::get_view(v, 0, i_1), as) | parse_bqFR2zVU(fu::get_view(v, (i_1 + 1), v.size()), as);

    };
    if (v == "hello"_fu)
        return s_LowerCase_hello;
    else if (v == "world"_fu)
        return s_LowerCase_world;
    else if (v == "cruel"_fu)
        return s_LowerCase_cruel;
    else if (v == "cruel_world"_fu)
        return s_LowerCase_cruel_world;

    return s_LowerCase{};
}

static int parseUpperOrLower_bih4ghNz(fu::view<char> str)
{
    if (const s_UpperCase upper = parse_K17aXsKI(str, s_UpperCase{}))
        return int(upper);
    else if (const s_LowerCase lower = parse_bqFR2zVU(str, s_LowerCase{}))
        return int(lower);
    else
        return 0;

}

int fu_MAIN()
{
    if (parseUpperOrLower_bih4ghNz("World|Cruel*"_fu) != ((2 | 4) | 8))
        return 1;
    else if (parseUpperOrLower_bih4ghNz("*world|hello"_fu) != ((16 | 32) | 128))
        return 2;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        struct Type { items: Type[]; }

        fn solve(root: Type) {
            mut out = 0;
            fn test_node(node: Type) {
                for (mut i = 0; i < node.items.len; i++)
                    test_node(node.items[i]);

                fn checkLt(actual: Type) {
                    out += node.items.len;
                    for (mut i = 0; i < actual.items.len; i++)
                        checkLt(actual.items[i]);
                }

                checkLt(node);
            }

            test_node(root);
            return out;
        }

        fn main() solve(Type([ Type([ Type, Type ]), Type([ Type, Type, Type ]) ])) == 34 ? 0 : 1;

-----
#include <fu/vec.h>

struct s_Type;
static void test_node_f6Jk3zrI(const s_Type&, int&);
static void checkLt_X3sjBzc5(const s_Type&, const s_Type&, int&);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<s_Type> items;
    s_Type(const s_Type&) = default;
    s_Type(s_Type&&) = default;
    s_Type& operator=(s_Type&&) = default;
    s_Type& operator=(const s_Type& selfrec) { return *this = s_Type(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void checkLt_X3sjBzc5(const s_Type& actual, const s_Type& node, int& out)
{
    out += node.items.size();
    for (int i = 0; i < actual.items.size(); i++)
        checkLt_X3sjBzc5(actual.items[i], node, out);

}

static void test_node_f6Jk3zrI(const s_Type& node, int& out)
{
    for (int i = 0; i < node.items.size(); i++)
        test_node_f6Jk3zrI(node.items[i], out);

    checkLt_X3sjBzc5(node, node, out);
}

static int solve_dMA093E9(const s_Type& root)
{
    int out = 0;
    test_node_f6Jk3zrI(root, out);
    return out;
}

int fu_MAIN()
{
    if (solve_dMA093E9(s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type { fu::vec<s_Type> { fu::slate<2, s_Type> { s_Type{}, s_Type{} } } }, s_Type { fu::vec<s_Type> { fu::slate<3, s_Type> { s_Type{}, s_Type{}, s_Type{} } } } } } }) == 34)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        fn runSolver(
            implicit ref notes: i32,
            break_notes: i32,
            implicit ref value: i32)
        {
            fn makeNote(note: i32, inline reason: string) {
                if (break_notes & note)
                    throw("#" ~ note ~ ": " ~ reason);

                notes |= note;
            }

            if (value > 0) {
                if (value++ & 1) return makeNote(1, "A: " ~ value);
                if (value++ & 2) return makeNote(2, "B: " ~ value);
            }
            else {
                if (value++ & 4) return makeNote(4, "C: " ~ value);
                if (value++ & 8) return makeNote(8, "D: " ~ value);
            }
        }

        fn main() {
            implicit mut notes: i32;

            implicit mut print: string; 
            implicit mut value = 0;

            runSolver(1|2);
            runSolver(4|8);
            return value == 4 && notes == 2 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 27:26+5[0m:

[2m      |             implicit mut notes: i32;[0m
[2m      | [0m
[2m   27 | [0m            implicit mut [31;1mprint[0m: string; 
[2m      |             implicit mut value = 0;[0m
[2m      | [0m

	Unused variable: [35;1mimplicit[0m [34;1mprint[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1mmain[0m at [2m24:12+4[0m

-----

        fn runSolver(
            implicit ref notes: i32,
            break_notes: i32,
            implicit ref value: i32)
        {
            fn makeNote(note: i32, inline reason: string) {
                if (break_notes & note)
                    throw("#" ~ note ~ ": " ~ reason);

                notes |= note;
            }

            if (value > 0) {
                if (value++ & 1) return makeNote(1, "A: " ~ value);
                if (value++ & 2) return makeNote(2, "B: " ~ value);
            }
            else {
                if (value++ & 4) return makeNote(4, "C: " ~ value);
                if (value++ & 8) return makeNote(8, "D: " ~ value);
            }
        }

        fn main() {
            implicit mut notes: i32;

            implicit mut value = 0;

            runSolver(1|2);
            runSolver(4|8);
            return value == 4 && notes == 2 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static void runSolver_ZmULMf1Y(const int break_notes, int& notes, int& value)
{
    if (value > 0)
    {
        if (value++ & 1)
        {
            const int note = 1;
            if (break_notes & note)
                fu::fail(((x7E_gCeFmDFw("#"_fu, fu::i64dec(note)) + ": "_fu) + x7E_gCeFmDFw("A: "_fu, fu::i64dec(value))));
            else
                notes |= note;

        }
        else if (value++ & 2)
        {
            const int note = 2;
            if (break_notes & note)
                fu::fail(((x7E_gCeFmDFw("#"_fu, fu::i64dec(note)) + ": "_fu) + x7E_gCeFmDFw("B: "_fu, fu::i64dec(value))));
            else
                notes |= note;

        };
    }
    else if (value++ & 4)
    {
        const int note = 4;
        if (break_notes & note)
            fu::fail(((x7E_gCeFmDFw("#"_fu, fu::i64dec(note)) + ": "_fu) + x7E_gCeFmDFw("C: "_fu, fu::i64dec(value))));
        else
            notes |= note;

    }
    else if (value++ & 8)
    {
        const int note = 8;
        if (break_notes & note)
            fu::fail(((x7E_gCeFmDFw("#"_fu, fu::i64dec(note)) + ": "_fu) + x7E_gCeFmDFw("D: "_fu, fu::i64dec(value))));
        else
            notes |= note;

    };
}

int fu_MAIN()
{
    int notes {};
    int value = 0;
    runSolver_ZmULMf1Y((1 | 2), notes, value);
    runSolver_ZmULMf1Y((4 | 8), notes, value);
    if ((value == 4) && (notes == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Target { x: i32; };

        fn ScopeSkip_push_bad_args(targets: Target[], ref sum: i32) {
            fn descend(acc?: bool) {
                fn foreach(t: Target) {
                    if (acc)    sum += t.x;
                    else        descend(true);
                }

                targets.each(|u| foreach(u));
            }

            descend();
        }

        fn main() {
            mut targets = [ Target(1), Target(2) ];
            mut sum = 0;
            ScopeSkip_push_bad_args(:targets, :sum);
            return sum == 6 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Target;
static void descend_fPgGysTm(bool, fu::view<s_Target>, int&);

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void foreach_rmNAppAm(const s_Target& t, const bool acc, fu::view<s_Target> targets, int& sum)
{
    if (acc)
        sum += t.x;
    else
        descend_fPgGysTm(true, targets, sum);

}

inline static void l_1_0_iWqmCLrc(const s_Target& u, const bool acc, fu::view<s_Target> targets, int& sum)
{
    foreach_rmNAppAm(u, acc, targets, sum);
}

                                #ifndef DEF_each_mdhxX2y9CQ5
                                #define DEF_each_mdhxX2y9CQ5
inline void each_mdhxX2y9(fu::view<s_Target> a, const bool acc, fu::view<s_Target> targets, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_iWqmCLrc(a[i], acc, targets, sum);

}
                                #endif

static void descend_fPgGysTm(const bool acc, fu::view<s_Target> targets, int& sum)
{
    each_mdhxX2y9(targets, acc, targets, sum);
}

static void ScopeSkip_push_bad_args_nGVGAlkL(fu::view<s_Target> targets, int& sum)
{
    descend_fPgGysTm(false, targets, sum);
}

int fu_MAIN()
{
    fu::vec<s_Target> targets = fu::vec<s_Target> { fu::slate<2, s_Target> { s_Target { 1 }, s_Target { 2 } } };
    int sum = 0;
    ScopeSkip_push_bad_args_nGVGAlkL(targets, sum);
    if (sum == 6)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_TjnCjfak(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    profile_TjnCjfak(2, module);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    profile_dhWSYT8z(3, module);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_TjnCjfak(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    profile_TjnCjfak(2, module);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    profile_dhWSYT8z(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_TjnCjfak(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    profile_TjnCjfak(2, module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    profile_dhWSYT8z(3, module);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        noinline 
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

inline static void profile_TjnCjfak(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

inline static void profile_dhWSYT8z(const int id, s_Module& module)
{
    const int /*module*/ events0 = module.events;
    profile_TjnCjfak(2, module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    profile_dhWSYT8z(3, module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    propagateType_23bnk5q3(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    l_1_0_GlILXiYX(module);
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        propagateType_23bnk5q3(module);
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        noinline 
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;

    {
        const int id_1 = 2;
        const int /*module*/ events0_1 = module.events;
        l_1_0_GlILXiYX(module);
        module.events += (events0_1 + id_1);
    };
    module.events += (events0 + id);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };


        inline   
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2, || module.events = 1);
        }


        inline   
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& l_1_0_GlILXiYX(s_Module& module)
{
    return (module.events = 1);
}

int fu_MAIN()
{
    s_Module module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;

        {
            const int id_1 = 2;
            const int /*module*/ events0_1 = module.events;
            l_1_0_GlILXiYX(module);
            module.events += (events0_1 + id_1);
        };
        module.events += (events0 + id);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        noinline 
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
#include <fu/defer.h>

struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    module.events = 1;
}

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    propagateType_23bnk5q3(module);
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        noinline 
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        inline   
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
#include <fu/defer.h>

struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void propagateType_23bnk5q3(s_Module& module)
{
    const int id = 2;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    module.events = 1;
}

int fu_MAIN()
{
    s_Module module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        fu_DEFER(module.events += (events0 + id));
        propagateType_23bnk5q3(module);
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        noinline 
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
#include <fu/defer.h>

struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void runAllPasses_H9fhQUVP(s_Module& module)
{
    const int id = 3;
    const int /*module*/ events0 = module.events;
    fu_DEFER(module.events += (events0 + id));
    const int id_1 = 2;
    const int /*module*/ events0_1 = module.events;
    fu_DEFER(module.events += (events0_1 + id_1));
    module.events = 1;
}

int fu_MAIN()
{
    s_Module module {};
    runAllPasses_H9fhQUVP(module);
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }


        inline   
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }


        inline   
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }

-----
#include <fu/defer.h>

struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int events;
    explicit operator bool() const noexcept
    {
        return false
            || events
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Module module {};

    {
        const int id = 3;
        const int /*module*/ events0 = module.events;
        fu_DEFER(module.events += (events0 + id));
        const int id_1 = 2;
        const int /*module*/ events0_1 = module.events;
        fu_DEFER(module.events += (events0_1 + id_1));
        module.events = 1;
    };
    if (module.events == ((1 + 2) + 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Target { template: string; };
        fn BUG(what?: string) throw(what || "Assertion failed.");

        fn assign_WOOT(ref into: Target) {
            mut name = "";
            mut what = "WOOT";
            name ||= what || BUG(); // arg inliner out of range local
            into.template = name;
        }

        fn main() {
            mut t = Target();
            assign_WOOT(into: t);
            return t.template == "WOOT" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>

struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    fu::str tEmplate;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

[[noreturn]] static fu::never BUG_nn4nr8lc(const fu::str& what)
{
    fu::fail((what ? fu::str(what) : "Assertion failed."_fu));
}

static void assign_WOOT_jVMVKWb3(s_Target& into)
{
    /*MOV*/ fu::str name = ""_fu;
    /*MOV*/ fu::str what = "WOOT"_fu;
    if (!(name))
        name = static_cast<fu::str&&>((what ? what : BUG_nn4nr8lc((*(const fu::str*)fu::NIL))));

    into.tEmplate = static_cast<fu::str&&>(name);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Target t = s_Target{};
    assign_WOOT_jVMVKWb3(t);
    if (t.tEmplate == "WOOT"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Overload { type: Type; }
        struct Type     { lifetime: i32[]; }

        fn BUG(implicit _here: i32, reason: string)
            throw(_here ~ ": " ~ reason);

        fn is_even(type: Type) {
            let a = !(type.lifetime.len & 1);
            let b =   type.lifetime.len < 4;
            a && !b && BUG("THROW-1");
            return a;
        }

        fn solve(check: Type) {
            let implicit mut _here: i32;

            using fn GET(implicit overloads: Overload[], target: i32)
                target < 0 || target >= overloads.len
                    ? BUG("THROW-2")
                    : overloads[target];

            fn Lifetime_each(type, visit)
                for (mut i = type.lifetime.len; i --> 0; )
                    visit(t: type.lifetime[i]);

            fn Lifetime_allEven(type: Type): bool {
                Lifetime_each(:type, visit: |t| {
                    if (!t.type.is_even)                return false;
                    if (!Lifetime_allEven(t.type))      return false;
                    _here = t;
                });

                return true;
            }

            return Lifetime_allEven(check);
        }

        fn main() {
            let implicit overloads = [
                Overload(),             // 0] even
                Overload(Type([0])),    // 1] odd
                Overload(Type([0, 0])), // 2] even
                Overload(Type([0, 2])), // 3] even
            ];

            if !(solve(Type()))         return 1;
            if  (solve(Type([ 1, 2 ]))) return 2;
            if !(solve(Type([ 2, 3 ]))) return 3;
            return 0;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct s_Overload;
struct s_Type;
static bool Lifetime_allEven_cd7BBPYf(const s_Type&, int&, fu::view<s_Overload>);

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    s_Type type;
    explicit operator bool() const noexcept
    {
        return false
            || type
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never BUG_8WAAo4DB(fu::view<char> reason, const int _here)
{
    fu::fail((x7E_gCeFmDFw(fu::i64dec(_here), ": "_fu) + reason));
}

static const s_Overload& GET_I3KpjoLM(const int target, fu::view<s_Overload> overloads, const int _here)
{
    if ((target < 0) || (target >= overloads.size()))
        BUG_8WAAo4DB("THROW-2"_fu, _here);
    else
        return overloads[target];

}

static bool is_even_4sJKd5mL(const s_Type& type, const int _here)
{
    const bool a = !(type.lifetime.size() & 1);
    const bool b = (type.lifetime.size() < 4);
    if (a && !b)
        BUG_8WAAo4DB("THROW-1"_fu, _here);
    else
        return a;

}

static bool Lifetime_allEven_cd7BBPYf(const s_Type& type, int& _here, fu::view<s_Overload> overloads)
{
    for (int i = type.lifetime.size(); i-- > 0; )
    {
        const int /*type|static*/ t = type.lifetime[i];
        if (!is_even_4sJKd5mL(GET_I3KpjoLM(t, overloads, _here).type, _here))
            return false;
        else if (!Lifetime_allEven_cd7BBPYf(GET_I3KpjoLM(t, overloads, _here).type, _here, overloads))
            return false;
        else
            _here = t;

    };
    return true;
}

static bool solve_t6WMLD6G(const s_Type& check, fu::view<s_Overload> overloads)
{
    int _here {};
    return Lifetime_allEven_cd7BBPYf(check, _here, overloads);
}

int fu_MAIN()
{
    fu::vec<s_Overload> overloads = fu::vec<s_Overload> { fu::slate<4, s_Overload> { s_Overload{}, s_Overload { s_Type { fu::vec<int> { fu::slate<1, int> { 0 } } } }, s_Overload { s_Type { fu::vec<int> { fu::slate<2, int> { 0, 0 } } } }, s_Overload { s_Type { fu::vec<int> { fu::slate<2, int> { 0, 2 } } } } } };
    if (!solve_t6WMLD6G(s_Type{}, overloads))
        return 1;
    else if (solve_t6WMLD6G(s_Type { fu::vec<int> { fu::slate<2, int> { 1, 2 } } }, overloads))
        return 2;
    else if (!solve_t6WMLD6G(s_Type { fu::vec<int> { fu::slate<2, int> { 2, 3 } } }, overloads))
        return 3;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        struct Overload { name: string; args?: Argument[]; }
        struct Argument { name: string; }
        struct Target   { index: i32; }

        fn solve(overloads: Overload[], check: Target, from?: Target)
        {
            fn fail(mut reason: string) {
                if (from)
                    reason ~= GET(from).qWHAT;

                return throw(reason);
            }

            fn qWHAT(o: Overload) o.name.human;
            fn qWHAT(a: Argument) a.name.human;

            fn tryParse(id: string)
                id.len == 1 && id[0] >= '0' && id[0] <= '9'
                    && Target(index: id[0].i32 - '0'.i32);

            fn human(id: string) {
                let t = tryParse(:id);
                return t ? GET(t).name : id;
            }

            fn parent(target: Target)
                target.index > 0
                    && Target(target.index - 1);

            using fn GET(target: Target) {
                if (overloads.len < target.index)
                    fail("Parent: " ~ (target.parent ? GET(target.parent).name : "-"));

                return overloads[target.index - 1];
            }

            return check.qWHAT;
        }

        fn main() {
            let overloads = [
                Overload("hello"),
                Overload("1"),
            ];

            return solve(overloads, check: Target(2)) == "hello" ? 0 : 1;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct s_Overload;
struct s_Argument;
struct s_Target;
static const s_Overload& GET_d248PqcY(const s_Target&, fu::view<s_Overload>, const s_Target&);

                                #ifndef DEF_s_Argument
                                #define DEF_s_Argument
struct s_Argument
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str name;
    fu::vec<s_Argument> args;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Target parent_G25zpGOK(const s_Target& target)
{
    if (target.index > 0)
    {
        return s_Target { (target.index - 1) };
    }
    else
    {
        return s_Target{};
    };
}

static s_Target tryParse_6rEvIORO(fu::view<char> id)
{
    if ((id.size() == 1) && (id[0] >= '0') && (id[0] <= '9'))
    {
        return s_Target { (int(fu::u8(id[0])) - int(fu::u8('0'))) };
    }
    else
    {
        return s_Target{};
    };
}

static const fu::str& human_9fZyCbXC(const fu::str& id, fu::view<s_Overload> overloads, const s_Target& from)
{
    const s_Target t = tryParse_6rEvIORO(id);
    if (t)
        return GET_d248PqcY(t, overloads, from).name;
    else
        return id;

}

static const fu::str& qWHAT_6AhscwR4(const s_Overload& o, fu::view<s_Overload> overloads, const s_Target& from)
{
    return human_9fZyCbXC(o.name, overloads, from);
}

[[noreturn]] static fu::never fail_d6RtpAVH(/*MOV*/ fu::str&& reason, fu::view<s_Overload> overloads, const s_Target& from)
{
    if (from)
        reason += qWHAT_6AhscwR4(GET_d248PqcY(from, overloads, from), overloads, from);

    fu::fail(static_cast<fu::str&&>(reason));
}

static const s_Overload& GET_d248PqcY(const s_Target& target, fu::view<s_Overload> overloads, const s_Target& from)
{
    if (overloads.size() < target.index)
        fail_d6RtpAVH(("Parent: "_fu + (parent_G25zpGOK(target) ? fu::str(GET_d248PqcY(parent_G25zpGOK(target), overloads, from).name) : "-"_fu)), overloads, from);
    else
        return overloads[(target.index - 1)];

}

static const fu::str& solve_oI82L6Pn(fu::view<s_Overload> overloads, const s_Target& check, const s_Target& from)
{
    return qWHAT_6AhscwR4(GET_d248PqcY(check, overloads, from), overloads, from);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Overload> overloads = fu::vec<s_Overload> { fu::slate<2, s_Overload> { s_Overload { "hello"_fu, fu::vec<s_Argument>{} }, s_Overload { "1"_fu, fu::vec<s_Argument>{} } } };
    if (solve_oI82L6Pn(overloads, s_Target { 2 }, s_Target{}) == "hello"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy

-----

        struct Type { quals: i32; lifet: i32 };

        fn tryInter(a: Type, b: Type) {
            let quals = a.quals & b.quals;
            let lifet = a.lifet & b.lifet;
            if (!lifet && (a.lifet || b.lifet))
                return [];

            return quals;
        }

        fn fail(reason: string) {
            return 101 + reason.len;
        }

        fn intersect(reason: string, a: Type, b: Type) {
            return tryInter(a, b) || fail(reason);
        }

        fn main() {
            let a = Type(quals: 1, lifet: 1);
            let b = Type(quals: 3, lifet: 3);
            return intersect("Hello!", a, b) == 1 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int quals;
    int lifet;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || lifet
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int tryInter_2BgGRu0V(const s_Type& a, const s_Type& b)
{
    const int quals = (a.quals & b.quals);
    const int lifet = (a.lifet & b.lifet);
    if (!lifet && (a.lifet || b.lifet))
    {
        return int{};
    }
    else
        return quals;

}

static int fail_KfhWIuH5(fu::view<char> reason)
{
    return 101 + reason.size();
}

static int intersect_GtLBvegz(fu::view<char> reason, const s_Type& a, const s_Type& b)
{
    int _0 {};
    return (_0 = tryInter_2BgGRu0V(a, b)) ? _0 : fail_KfhWIuH5(reason);
}

int fu_MAIN()
{
    const s_Type a = s_Type { 1, 1 };
    const s_Type b = s_Type { 3, 3 };
    if (intersect_GtLBvegz("Hello!"_fu, a, b) == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Item { val: i32 };

        fn Each !T(a: T[:], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i], i?: i);

        fn parseStructDecl(ref items: [Item], ref sum: i32) {
            if (items.len & 2)
                parseStructDecl(items[1 : items.len], sum);     // PointlessMustSeq

            :BLOCK {
                items.Each: |item|
                    if ((sum += item.val) & 2)
                        break :BLOCK;                           // Goto

                items.Each: |ref item|
                    item.val += sum;
            }

            items.Each: |ref item|
                item.val++;
        }

        fn main() {
            mut sum = 0;
            mut items = [ Item(0), Item(1) ];
            parseStructDecl(items, sum);
            return sum == 4
                && items[0].val == 5
                && items[1].val == 8 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Item;
static void parseStructDecl_ujVOMBuf(fu::view_mut<s_Item>, int&);

                                #ifndef DEF_s_Item
                                #define DEF_s_Item
struct s_Item
{
    int val;
    explicit operator bool() const noexcept
    {
        return false
            || val
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int& l_1_1_tue1bu41(s_Item& item, const int sum)
{
    return (item.val += sum);
}

inline static void Each_5Wj9NYkp(fu::view_mut<s_Item> a, const int sum)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_tue1bu41(a.mutref(i), sum);

}

inline static int l_1_2_8buCzj78(s_Item& item)
{
    return item.val++;
}

inline static void Each_B9mbZleY(fu::view_mut<s_Item> a)
{
    for (int i = 0; i < a.size(); i++)
        l_1_2_8buCzj78(a.mutref(i));

}

static void parseStructDecl_ujVOMBuf(fu::view_mut<s_Item> items, int& sum)
{
    if (items.size() & 2)
        parseStructDecl_ujVOMBuf(fu::get_view_mut(items, 1, items.size()), sum);


    { {
        for (int i = 0; i < items.size(); i++)
        {
            const s_Item& /*items|static*/ item = items[i];
            if ((sum += item.val) & 2)
                goto BL_2;

        };
        Each_5Wj9NYkp(items, sum);
      } BL_2:;
    };
    Each_B9mbZleY(items);
}

int fu_MAIN()
{
    int sum = 0;
    fu::vec<s_Item> items = fu::vec<s_Item> { fu::slate<2, s_Item> { s_Item { 0 }, s_Item { 1 } } };
    parseStructDecl_ujVOMBuf(items, sum);
    if ((sum == 4) && (items[0].val == 5) && (items[1].val == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_RelaxRespec, N_AARMustSeq

-----

        struct Node {
            value?: string;
            items?: Node[];
        };

        fn SLOW_traverse(node: Node, visit) {
            mut stack = [ node ];
            while (stack) {
                shadow mut node = stack[stack.len - 1];
                stack.pop();
                visit(node);
                for (mut i = node.items.len; i --> 0; )
                    stack ~= node.items[i];
            }
        }

        fn qSTACK(node: Node) {
            SLOW_traverse(node): |n| {
                if (n.value && n.items)
                    return n.value ~ ", " ~ qSTACK(n.items[0]);
            }

            return node.value ~ "!";
        }

        fn main() {
            let res = qSTACK(
                Node(items: [
                    Node("Ignore me"),
                    Node("Hello", [ Node("World") ]),
                ]));

            return res == "Hello, World!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_Node;
static fu::str qSTACK_jlJeov1J(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str value;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str qSTACK_jlJeov1J(const s_Node& node)
{

    {
        fu::vec<s_Node> stack = fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node(node) } };
        while (stack)
        {
            s_Node node_1 { stack[(stack.size() - 1)] };
            stack.pop();
            if (node_1.value && node_1.items)
                return (node_1.value + ", "_fu) + qSTACK_jlJeov1J(node_1.items[0]);
            else
                for (int i = node_1.items.size(); i-- > 0; )
                    stack += s_Node(node_1.items[i]);
;
        };
    };
    return node.value + "!"_fu;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = qSTACK_jlJeov1J(s_Node { fu::str{}, fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { "Ignore me"_fu, fu::vec<s_Node>{} }, s_Node { "Hello"_fu, fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { "World"_fu, fu::vec<s_Node>{} } } } } } } });
    if (res == "Hello, World!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>

struct s_Lifetime;
inline static fu::vec<int> inter_hCMVsxXD(const fu::vec<int>&, const fu::vec<int>&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

inline static void l_1_2_fapJL5Je(const int item, fu::vec<int>& result, const bool useResult)
{
    if (useResult)
        result += item;

}

inline static void l_1_0_PzswXvfY(const int left, const fu::vec<int>& l, fu::vec<int>& result, bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::slice(l, 0, left);
    };
}

inline static void merge_jyx61iT6(fu::view<int> l, fu::view<int> r, const fu::vec<int>& l_1, fu::vec<int>& result, bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        fu::never BL_3_v {};
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
        (void)0;}), static_cast<fu::never&&>(BL_3_v)) : +1) : (r_done ? -1 : x3Cx3E_mJGU9byO(l[li], r[ri])));
        if (cmp == 0)
        {
            l_1_2_fapJL5Je(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            l_1_0_PzswXvfY(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}

inline static fu::vec<int> inter_hCMVsxXD(const fu::vec<int>& l, const fu::vec<int>& r)
{
    if (r.size() < l.size())
        return inter_hCMVsxXD(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_jyx61iT6(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}

static s_Lifetime Lifetime_inter_2Ay3GNQA(const s_Lifetime& a, const s_Lifetime& b)
{
    return s_Lifetime { inter_hCMVsxXD(a.uni0n, b.uni0n) };
}

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Lifetime a = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } } };
    s_Lifetime b = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 2, 3, 4 } } };
    s_Lifetime c = Lifetime_inter_2Ay3GNQA(a, b);
    if (c.uni0n == (fu::slate<2, int> { 2, 3 }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>

struct s_Lifetime;
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>&, const fu::vec<int>&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

inline static void l_1_2_PugLxXqC(const int item, fu::vec<int>& result, const bool useResult)
{
    if (useResult)
        result += item;

}

inline static void l_1_0_y9WvHMQo(const int left, const fu::vec<int>& l, fu::vec<int>& result, bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::slice(l, 0, left);
    };
}

                                #ifndef DEF_merge_R2YB7wbMO3h
                                #define DEF_merge_R2YB7wbMO3h
inline void merge_R2YB7wbM(fu::view<int> l, fu::view<int> r, const fu::vec<int>& l_1, fu::vec<int>& result, bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        fu::never BL_3_v {};
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
        (void)0;}), static_cast<fu::never&&>(BL_3_v)) : +1) : (r_done ? -1 : x3Cx3E_mJGU9byO(l[li], r[ri])));
        if (cmp == 0)
        {
            l_1_2_PugLxXqC(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            l_1_0_y9WvHMQo(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_hCMVsxXDRBd
                                #define DEF_inter_hCMVsxXDRBd
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>& l, const fu::vec<int>& r)
{
    if (r.size() < l.size())
        return inter_hCMVsxXD(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_R2YB7wbM(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

s_Lifetime Lifetime_inter_2Ay3GNQA(const s_Lifetime& a, const s_Lifetime& b)
{
    return s_Lifetime { inter_hCMVsxXD(a.uni0n, b.uni0n) };
}

#endif

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_UnusedCall

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr

        pub import _0;
        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;
s_Lifetime Lifetime_inter_2Ay3GNQA(const s_Lifetime&, const s_Lifetime&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Lifetime a = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } } };
    s_Lifetime b = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 2, 3, 4 } } };
    s_Lifetime c = Lifetime_inter_2Ay3GNQA(a, b);
    if (c.uni0n == (fu::slate<2, int> { 2, 3 }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


-----

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        pub import _0;
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>

struct s_Lifetime;
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>&, const fu::vec<int>&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

inline static void l_1_2_79GUaorj(const int item, fu::vec<int>& result, const bool useResult)
{
    if (useResult)
        result += item;

}

inline static void l_1_0_AnzzQ8yW(const int left, const fu::vec<int>& l, fu::vec<int>& result, bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::slice(l, 0, left);
    };
}

                                #ifndef DEF_merge_cnbhJ87KP4b
                                #define DEF_merge_cnbhJ87KP4b
inline void merge_cnbhJ87K(fu::view<int> l, fu::view<int> r, const fu::vec<int>& l_1, fu::vec<int>& result, bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        fu::never BL_3_v {};
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
        (void)0;}), static_cast<fu::never&&>(BL_3_v)) : +1) : (r_done ? -1 : x3Cx3E_mJGU9byO(l[li], r[ri])));
        if (cmp == 0)
        {
            l_1_2_79GUaorj(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            l_1_0_AnzzQ8yW(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_hCMVsxXDRBd
                                #define DEF_inter_hCMVsxXDRBd
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>& l, const fu::vec<int>& r)
{
    if (r.size() < l.size())
        return inter_hCMVsxXD(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_cnbhJ87K(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

static s_Lifetime Lifetime_inter_pjaGNGMW(const s_Lifetime& a, const s_Lifetime& b)
{
    return s_Lifetime { inter_hCMVsxXD(a.uni0n, b.uni0n) };
}

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Lifetime a = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } } };
    s_Lifetime b = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 2, 3, 4 } } };
    s_Lifetime c = Lifetime_inter_pjaGNGMW(a, b);
    if (c.uni0n == (fu::slate<2, int> { 2, 3 }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_UnusedCall

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }


-----

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        pub import _0;
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr


-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat_one.h>

struct s_Lifetime;
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>&, const fu::vec<int>&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

inline static void l_1_2_naGascp4(const int item, fu::vec<int>& result, const bool useResult)
{
    if (useResult)
        result += item;

}

inline static void l_1_0_RJJGZCxT(const int left, const fu::vec<int>& l, fu::vec<int>& result, bool& useResult)
{
    if (!useResult)
    {
        useResult = true;
        result = fu::slice(l, 0, left);
    };
}

                                #ifndef DEF_merge_WRAZOLKlUW4
                                #define DEF_merge_WRAZOLKlUW4
inline void merge_WRAZOLKl(fu::view<int> l, fu::view<int> r, const fu::vec<int>& l_1, fu::vec<int>& result, bool& useResult)
{
    int li = 0;
    int ri = 0;
    for (; ; )
    {
        const bool l_done = (li == l.size());
        const bool r_done = (ri == r.size());
        fu::never BL_3_v {};
        const int cmp = (l_done ? (r_done ? (__extension__ (
        {
            return;
        (void)0;}), static_cast<fu::never&&>(BL_3_v)) : +1) : (r_done ? -1 : x3Cx3E_mJGU9byO(l[li], r[ri])));
        if (cmp == 0)
        {
            l_1_2_naGascp4(l[li], result, useResult);
            li++;
            ri++;
        }
        else if (cmp < 0)
        {
            l_1_0_RJJGZCxT(li, l_1, result, useResult);
            li++;
        }
        else
            ri++;

    };
}
                                #endif

                                #ifndef DEF_inter_hCMVsxXDRBd
                                #define DEF_inter_hCMVsxXDRBd
inline fu::vec<int> inter_hCMVsxXD(const fu::vec<int>& l, const fu::vec<int>& r)
{
    if (r.size() < l.size())
        return inter_hCMVsxXD(r, l);
    else
    {
        /*MOV*/ fu::vec<int> result {};
        bool useResult = false;
        merge_WRAZOLKl(l, r, l, result, useResult);
        if (useResult)
            return /*NRVO*/ result;
        else
            return fu::vec<int>(l);

    };
}
                                #endif

s_Lifetime Lifetime_inter_pjaGNGMW(const s_Lifetime& a, const s_Lifetime& b)
{
    return s_Lifetime { inter_hCMVsxXD(a.uni0n, b.uni0n) };
}

#endif

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy, N_UnusedCall

-----

        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        pub import _0;
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           // GNUStmtExpr

        pub import _1;
        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;
s_Lifetime Lifetime_inter_pjaGNGMW(const s_Lifetime&, const s_Lifetime&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Lifetime a = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } } };
    s_Lifetime b = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 2, 3, 4 } } };
    s_Lifetime c = Lifetime_inter_pjaGNGMW(a, b);
    if (c.uni0n == (fu::slate<2, int> { 2, 3 }))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Type { canon: string; quals: i32 };
        struct Node { type: Type; value: string };

        let t_f32 = Type("f32", 2);
        let t_f64 = Type("f32", 2);

        fn solveReal(lax v: string, type: Type): Type {
            if (type.canon == t_f32.canon) return t_f32;
            return t_f64;
        }

        fn tryRetype(node: Node, expect: Type): Type {
            return solveReal(node.value, expect);
        }

        fn main() {
            let a = Node(t_f64, "0.0");
            let b = tryRetype(a, t_f32);
            return b.canon == "f32" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>

struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    fu::str canon;
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || canon
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Type t_f32 fu_INIT_PRIORITY(1001) = s_Type { "f32"_fu, 2 };

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static const s_Type t_f64 fu_INIT_PRIORITY(1001) = s_Type { "f32"_fu, 2 };

static const s_Type& solveReal_5aYHX6Jc(const s_Type& type)
{
    if (type.canon == t_f32.canon)
        return t_f32;
    else
        return t_f64;

}

static const s_Type& tryRetype_2dvjneV9(const s_Type& expect)
{
    return solveReal_5aYHX6Jc(expect);
}

int fu_MAIN()
{
    const s_Type& /*static*/ b = tryRetype_2dvjneV9(t_f32);
    if (b.canon == "f32"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet, N_SD_HasStaticInit

-----

        fn main() {
            nocopy struct Nc { items: Nc[]; };

            fn rem_odd(ref items: Nc[])
                for (mut i = items.len; i --> 0; )
                    if (i & 1)
                        items.splice(i, 1);

            mut items: Nc[];
            for (mut i = 0; i < 11; i++)
                items ~= Nc(i & 1 ? [ Nc ] : [ Nc, Nc ]);

            rem_odd(items);

            mut sum = 0;
            fn visit(shadow items: [Nc])
            {
                fn visit(nc: Nc) {
                    sum++;
                    visit(nc.items);
                }

                for (mut i = 0; i < items.len; i++)
                    visit(items[i]);
            }

            visit(items);
            return sum == 18 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_Nc;
static void visit_Hj68SbZj(fu::view<s_Nc>, int&);

                                #ifndef DEF_s_Nc
                                #define DEF_s_Nc
struct s_Nc
{
    fu::vec<s_Nc> items;
    s_Nc(const s_Nc&) = delete;
    s_Nc(s_Nc&&) = default;
    s_Nc& operator=(const s_Nc&) = delete;
    s_Nc& operator=(s_Nc&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void rem_odd_JuRpfaJl(fu::vec<s_Nc>& items)
{
    for (int i = items.size(); i-- > 0; )
    {
        if (i & 1)
            items.splice(i, 1);

    };
}

static void visit_sGvl3jYe(const s_Nc& nc, int& sum)
{
    sum++;
    visit_Hj68SbZj(nc.items, sum);
}

static void visit_Hj68SbZj(fu::view<s_Nc> items, int& sum)
{
    for (int i = 0; i < items.size(); i++)
        visit_sGvl3jYe(items[i], sum);

}

int fu_MAIN()
{
    fu::vec<s_Nc> items {};
    for (int i = 0; i < 11; i++)
    {
        items += s_Nc { ((i & 1) ? fu::vec<s_Nc> { fu::slate<1, s_Nc> { s_Nc{} } } : fu::vec<s_Nc> { fu::slate<2, s_Nc> { s_Nc{}, s_Nc{} } }) };
    };
    rem_odd_JuRpfaJl(items);
    int sum = 0;
    visit_Hj68SbZj(items, sum);
    if (sum == 18)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_DeadCode

-----

        let SMTH = false;

        fn FAIL(reason: string, implicit ref log: string)
            log ~= reason ~ '\n';

        fn fail_appendStack(lax mut reason: string)
            SMTH ? reason : [];

        fn fail(mut reason: string)
            FAIL(reason.fail_appendStack());

        fn main() {
            implicit mut log = "";
            fail("Hello!");
            return log.len - 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str& FAIL_2UP4sHJA(fu::view<char> reason, fu::str& log)
{
    return (log += (reason + '\n'));
}

static fu::str& fail_jqAIYfyi(fu::str& log)
{
    return FAIL_2UP4sHJA(fu::str{}, log);
}

int fu_MAIN()
{
    fu::str log = ""_fu;
    fail_jqAIYfyi(log);
    return log.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_SD_HasStaticInit

-----

        struct Type { quals: i32 };
        pub fn tryLookupUserType(type: Type) = type;
        fn propagateType(type: Type) {
            let s = tryLookupUserType(type);
            if (s.quals != 13 || true) return 17;
            return 19;
        }

        fn main = 1.Type.propagateType - 17;

-----
struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int quals;
    explicit operator bool() const noexcept
    {
        return false
            || quals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

const s_Type& tryLookupUserType_IM5occtK(const s_Type& type)
{
    return type;
}

static int propagateType_8UcmmEq1()
{
    return 17;
}

int fu_MAIN()
{
    return propagateType_8UcmmEq1() - 17;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedAndOr, N_UnusedLet

-----


        noinline        
        fn voidfn(ref a: i32) { a += 100; }


        noinline        
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void voidfn_wQ3JO5Ij(int& a)
{
    a += 100;
}

static void returnVoidExpr_qg01zOoD(int& a, int& b)
{
    while (b-- > 0)
    {
        a++;
        if (a & 1)
        {
            voidfn_wQ3JO5Ij(a);
            return;
        };
    };
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;
    returnVoidExpr_qg01zOoD(a, b);
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        noinline        
        fn voidfn(ref a: i32) { a += 100; }


        inline   // Goto
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void voidfn_wQ3JO5Ij(int& a)
{
    a += 100;
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;

    { {
        while (b-- > 0)
        {
            a++;
            if (a & 1)
            {
                voidfn_wQ3JO5Ij(a);
                goto BL_1;
            };
        };
      } BL_1:;
    };
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        inline          
        fn voidfn(ref a: i32) { a += 100; }


        noinline        
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void returnVoidExpr_qg01zOoD(int& a, int& b)
{
    while (b-- > 0)
    {
        a++;
        if (a & 1)
        {
            a += 100;
            return;
        };
    };
}

int fu_MAIN()
{
    int a = 0;
    int b = 10;
    returnVoidExpr_qg01zOoD(a, b);
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        inline          
        fn voidfn(ref a: i32) { a += 100; }


        inline   // Goto
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    int b = 10;

    { {
        while (b-- > 0)
        {
            a++;
            if (a & 1)
            {
                a += 100;
                goto BL_1;
            };
        };
      } BL_1:;
    };
    if ((a == 101) && (b == 9))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(implicit) = implicit;
        fn main() = 0.hello;

-----

#ifndef fu_NO_fdefs

inline static int hello_AiMDl7mB(const int implicit)
{
    return implicit;
}

int fu_MAIN()
{
    return hello_AiMDl7mB(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(implicit: i32) = implicit;
        fn main() = 0.hello;

-----

#ifndef fu_NO_fdefs

static int hello_AiMDl7mB(const int implicit)
{
    return implicit;
}

int fu_MAIN()
{
    return hello_AiMDl7mB(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn voidIf(ref a: i32, ref b: u32)

            a   ? a++
                : b++;


        fn main() {
            mut a: i32;
            mut b: u32;
            voidIf(:a, :b);
            return !a && b ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:17+1[0m:

[2m      |         fn voidIf(ref a: i32, ref b: u32)[0m
[2m      | [0m
[2m    4 | [0m            a   [31;1m?[0m a++
[2m      |                 : b++;[0m
[2m      | [0m

	if/else: No common supertype: i32 copy <-> u32 copy

        Solving [35;1mfn[0m [34;1mvoidIf[0m(i32, u32) at [2m2:12+6[0m

-----

        fn voidIf(ref a: i32, ref b: u32)

            if (a)  a++;
            else    b++;


        fn main() {
            mut a: i32;
            mut b: u32;
            voidIf(:a, :b);
            return !a && b ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void voidIf_rVxOKa1B(int& a, unsigned& b)
{
    if (a)
        a++;
    else
        b++;

}

int fu_MAIN()
{
    int a {};
    unsigned b {};
    voidIf_rVxOKa1B(a, b);
    if (!a && b)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct ScopeItem { id: string; uval: u32 }

        fn search(ref items: [ScopeItem], id: string, ref scope_iterator: i32): u32
        {
            if (!scope_iterator)
                scope_iterator = items.len;

            defer if (scope_iterator == 0)
                scope_iterator = -1;

            while (scope_iterator --> 0) {
                let item = items[scope_iterator];
                if (item.id == id)
                    return item.uval;
            }

            return [];
        }

        fn main() {
            mut items = [ ScopeItem("a", 1), ScopeItem("a", 2), ScopeItem("a", 3) ];
            mut scope_iterator = 0;
            mut uval: u32;

            mut result: u32;
            while (uval = items.search("a", scope_iterator))
                result += uval;

            return (result - 6).signed;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>

struct s_ScopeItem;

                                #ifndef DEF_s_ScopeItem
                                #define DEF_s_ScopeItem
struct s_ScopeItem
{
    fu::str id;
    unsigned uval;
    explicit operator bool() const noexcept
    {
        return false
            || id
            || uval
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static unsigned search_8Eb2CtzJ(fu::view<s_ScopeItem> items, fu::view<char> id, int& scope_iterator)
{
    if (!scope_iterator)
        scope_iterator = items.size();

    fu_DEFER(if (scope_iterator == 0)
        scope_iterator = -1;);
    while (scope_iterator-- > 0)
    {
        const s_ScopeItem& /*items|static*/ item = items[scope_iterator];
        if (item.id == id)
            return item.uval;

    };
    return 0u;
}

                                #ifndef DEF_sIgned_dYXO8QTTIif
                                #define DEF_sIgned_dYXO8QTTIif
inline int sIgned_dYXO8QTT(const unsigned v)
{
    return int(v);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_ScopeItem> items = fu::vec<s_ScopeItem> { fu::slate<3, s_ScopeItem> { s_ScopeItem { "a"_fu, 1u }, s_ScopeItem { "a"_fu, 2u }, s_ScopeItem { "a"_fu, 3u } } };
    int scope_iterator = 0;
    unsigned uval {};
    unsigned result {};
    while ((uval = search_8Eb2CtzJ(items, "a"_fu, scope_iterator)))
        result += uval;

    return sIgned_dYXO8QTT((result - 6u));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn woot!E (e?: E) {
            if (E -> [])
                return 2;
            else
                return e(3);
        }

        fn main() woot * woot(|x| x * 5) - 30;

-----

#ifndef fu_NO_fdefs

inline static int woot_r496CKcn()
{
    return 2;
}

inline static int l_1_0_yM0yD4mH(const int x)
{
    return x * 5;
}

inline static int woot_PP8IZRHd()
{
    return l_1_0_yM0yD4mH(3);
}

int fu_MAIN()
{
    return (woot_r496CKcn() * woot_PP8IZRHd()) - 30;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn woot(myfn) myfn(1);

        fn main() {
            mut sum = 0;            // PARSE DRAMA
            woot: |one| sum += one; //  stmt lambda, followed by
            (sum += 1) += 1;        //   '(' which continued as-if-expr
            return sum -3;
        }

-----

#ifndef fu_NO_fdefs

inline static int& l_1_0_347rfI5l(const int one, int& sum)
{
    return (sum += one);
}

inline static int& woot_f3n1QTgn(int& sum)
{
    return l_1_0_347rfI5l(1, sum);
}

int fu_MAIN()
{
    int sum = 0;
    woot_f3n1QTgn(sum);
    (sum += 1) += 1;
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        let PROFILE = false;

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_PROFILE
                                #define DEF_PROFILE
inline constexpr bool PROFILE = false;
                                #endif

void x2Bx3D_YUlx94qn()
{
}

int get_dbImhJ93()
{
    return 0;
}

#endif

// N_SD_HasStaticInit

-----

        let PROFILE = false;

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

        import _0;
        fn main() {
            mut a: Item;
            a += Item();
            return a.get();
        }

-----
int get_dbImhJ93();

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return get_dbImhJ93();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

-----

        let PROFILE = true;

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

-----
struct s_NonEmpty;

                                #ifndef DEF_s_NonEmpty
                                #define DEF_s_NonEmpty
struct s_NonEmpty
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_PROFILE
                                #define DEF_PROFILE
inline constexpr bool PROFILE = true;
                                #endif

void operator+=(s_NonEmpty& a, const s_NonEmpty& b)
{
    a.v += b.v;
}

int get_29DKlTVh(const s_NonEmpty& a)
{
    return a.v;
}

#endif

// N_SD_HasStaticInit

-----

        let PROFILE = true;

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;

        import _0;
        fn main() {
            mut a: Item;
            a += Item();
            return a.get();
        }

-----
struct s_NonEmpty;
void operator+=(s_NonEmpty&, const s_NonEmpty&);
int get_29DKlTVh(const s_NonEmpty&);

                                #ifndef DEF_s_NonEmpty
                                #define DEF_s_NonEmpty
struct s_NonEmpty
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_NonEmpty a {};
    a += s_NonEmpty{};
    return get_29DKlTVh(a);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32): bool   
            let y = x > 10;     

        fn main() test(3).i32;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+1[0m:

[2m      | [0m
[2m      |         fn test(x: i32): bool   [0m
[2m    3 | [0m            let [31;1my[0m = x > 10;     
[2m      | [0m
[2m      |         fn main() test(3).i32;[0m

	Actual return type does not match annotation: bool copy <- void

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m2:12+4[0m

-----

        fn test(x: i32): bool   
                    x > 10;     

        fn main() test(3).i32;

-----

#ifndef fu_NO_fdefs

static bool test_1WsbUdat(const int x)
{
    return x > 10;
}

int fu_MAIN()
{
    return int(test_1WsbUdat(3));
}

#endif

int main() { return fu_MAIN(); }

-----

        let a = 7;
        let b = a && 3;
        return b - 3;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int b = 3;
    return b - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw("woot");

-----
#include <fu/str.h>
#include <fu/never.h>

struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_S a = s_S { 0 };
    const s_S b = s_S { 3 };
    return a.i ? a.i : ((((b ? s_S(b) : s_S { 4 }).i * 2) - (a ? s_S(a) : s_S { 6 }).i) ? fu::fail("woot"_fu) : 0);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct KindValue { kind: string; value: string; };

        mut spec = KindValue(kind: "fn", value: "val");
        spec.kind == "fn" && spec.value || throw("nope");
        ref v = spec.kind == "fn" ? spec.value : throw("nope");

        v ~= "ue";
        return spec.value == "value" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct s_KindValue;

                                #ifndef DEF_s_KindValue
                                #define DEF_s_KindValue
struct s_KindValue
{
    fu::str kind;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_KindValue spec = s_KindValue { "fn"_fu, "val"_fu };
    if ((spec.kind == "fn"_fu) && spec.value)
    {
        fu::str& /*spec*/ v = ((spec.kind == "fn"_fu) ? spec.value : fu::fail("nope"_fu));
        v += "ue"_fu;
        if (spec.value == "value"_fu)
            return 0;
        else
            return 1;

    }
    else
        fu::fail("nope"_fu);

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };

-----
#include <fu/str.h>

struct s_Token;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Token consume_H9fhQUVP()
{
    return s_Token { "hey"_fu };
}

int fu_MAIN()
{
    const int a = 3;
    fu::str v = consume_H9fhQUVP().value;
    return v.size() - a;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct ScopeIdx { raw: i32; };

        fn thing(x: i32) x;             
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:27+1[0m:

[2m      |         fn hey(x: i32) {[0m
[2m      |             let scope0 = thing(x);[0m
[2m   12 | [0m            _return_scope [31;1m=[0m scope0; //overload
[2m      |             return _return_scope.raw;[0m
[2m      |         }[0m

	Bad call to [34;1m=[0m with args (ScopeIdx mutref copy, i32 copy): 

	[35;1mtemplate[0m [34;1m=[0m at [2m../../../../../[0mprelude[2m 165:12+1[0m:
[2m  165 | [0minfix fn   [31;1m=[0m !T(ref a: T,    mut b: T): &mut T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: ScopeIdx Typename <-> i32 Typename

        Solving [35;1mfn[0m [34;1mhey[0m(i32) at [2m10:12+3[0m
                [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct ScopeIdx { raw: i32; };

        fn thing(x: i32) ScopeIdx(x);   
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);

-----
struct s_ScopeIdx;

                                #ifndef DEF_s_ScopeIdx
                                #define DEF_s_ScopeIdx
struct s_ScopeIdx
{
    int raw;
    explicit operator bool() const noexcept
    {
        return false
            || raw
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_ScopeIdx thing_2ix8ckGt(const int x)
{
    return s_ScopeIdx { x };
}

static int& hey_xqw9xMXF(const int x, s_ScopeIdx& _return_scope)
{
    const s_ScopeIdx scope0 = thing_2ix8ckGt(x);
    _return_scope = scope0;
    return _return_scope.raw;
}

int fu_MAIN()
{
    s_ScopeIdx _return_scope {};
    return hey_xqw9xMXF(0, _return_scope);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= [ "world!" ]; // same as below but wrapped
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::str> maybe_empty_PGQNT7AD(const int N)
{
    /*MOV*/ fu::vec<fu::str> res {};
    for (int i = 0; i < N; i++)
    {
        res += (fu::slate<1, fu::str> { "world!"_fu });
    };
    return /*NRVO*/ res;
}

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> arr = fu::vec<fu::str> { fu::slate<1, fu::str> { "Hello"_fu } };
    for (int i = 0; i < 2; i++)
        arr += maybe_empty_PGQNT7AD(i);

    if (join_jCe9HYtv(arr, " "_fu) == "Hello world!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= "world!"; // cpp template issue here
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::str> maybe_empty_PGQNT7AD(const int N)
{
    /*MOV*/ fu::vec<fu::str> res {};
    for (int i = 0; i < N; i++)
        res += "world!"_fu;

    return /*NRVO*/ res;
}

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<fu::str> arr = fu::vec<fu::str> { fu::slate<1, fu::str> { "Hello"_fu } };
    for (int i = 0; i < 2; i++)
        arr += maybe_empty_PGQNT7AD(i);

    if (join_jCe9HYtv(arr, " "_fu) == "Hello world!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut _info = "abc";

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && info.i32;
                return reason;
            }

            return fail.len - 2; // 'a' is 97, "97".len is 2.
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_vuSW0Q9ulEj
                                #define DEF_x7Ex3D_vuSW0Q9ulEj
inline fu::str& x7Ex3D_vuSW0Q9u(fu::str& a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

static fu::str fail_9snJx10P(/*MOV*/ fu::str&& reason, fu::view<char> _info)
{
    const char /*_info|static*/ info = _info[0];
    x7Ex3D_vuSW0Q9u(reason, fu::i64dec((info ? int(fu::u8(info)) : 0)));
    return static_cast<fu::str&&>(reason);
}

int fu_MAIN()
{
    fu::str _info = "abc"_fu;
    return fail_9snJx10P(""_fu, _info).size() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        let q_mutref = 1;
        pub let RELAX_mutref_only = q_mutref;
        pub fn what(relax_mask: i32) relax_mask -1;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_q_mutref
                                #define DEF_q_mutref
inline constexpr int q_mutref = 1;
                                #endif

                                #ifndef DEF_RELAX_mutref_only
                                #define DEF_RELAX_mutref_only
inline constexpr int /*static*/ RELAX_mutref_only = q_mutref;
                                #endif

int what_CZGpxp4U(const int relax_mask)
{
    return relax_mask - 1;
}

#endif

// N_SD_HasStaticInit

-----

        let q_mutref = 1;
        pub let RELAX_mutref_only = q_mutref;
        pub fn what(relax_mask: i32) relax_mask -1;

        import _0;
        fn main() what(RELAX_mutref_only);

-----
int what_CZGpxp4U(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_q_mutref
                                #define DEF_q_mutref
inline constexpr int q_mutref = 1;
                                #endif

                                #ifndef DEF_RELAX_mutref_only
                                #define DEF_RELAX_mutref_only
inline constexpr int /*static*/ RELAX_mutref_only = q_mutref;
                                #endif

int fu_MAIN()
{
    return what_CZGpxp4U(RELAX_mutref_only);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            try         { return 0; }
            catch (e)   { return e == "x=2: even!" ? 11 : 22; }
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedTry

-----

        fn fail(str: string)
            throw(str ~ "!");

        fn test(x: i32)
        {
            // We want to override fail but
            //  we want to call it within the override,
            //   so we can do this i guess?
            //
            shadow let fail = |mut str: string| {
                str = "x=" ~ x ~ ": " ~ str;
                fail(str);
            };

            return x & 1 || fail("even");
        }

        fn main() {
            try {
                return test(2);
            }
            catch (e) {

                shadow let e = "hello " ~ e;
                return e == "hello x=2: even!" ? 0 : 10;

            }
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_bih4ghNz(fu::view<char> str)
{
    fu::fail((str + "!"_fu));
}

[[noreturn]] static fu::never l_1_0_zjtMZ4iT(fu::str&& str, const int x)
{
    str = ((x7E_gCeFmDFw("x="_fu, fu::i64dec(x)) + ": "_fu) + str);
    fail_bih4ghNz(str);
}

static int test_1WsbUdat(const int x)
{
    int _0 {};
    return (_0 = (x & 1)) ? _0 : l_1_0_zjtMZ4iT("even"_fu, x);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        return test_1WsbUdat(2);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        fu::str e_1 = ("hello "_fu + e);
        if (e_1 == "hello x=2: even!"_fu)
            return 0;
        else
            return 10;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn fail(str: string)
            throw(str ~ "!");

        fn test(x: i32)
        {
            // We want to override fail but
            //  we want to call it within the override,
            //   so we can do this i guess?
            //
            shadow let fail = |mut str: string| {
                str = "x=" ~ x ~ ": " ~ str;
                fail(str);
            };

            return x & 1 || fail("even");
        }

        fn main() {
            try {
                return test(2);
            }
            catch (e) {

                return e == "x=2: even!" ? 0 : 10;

            }
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

[[noreturn]] static fu::never fail_bih4ghNz(fu::view<char> str)
{
    fu::fail((str + "!"_fu));
}

[[noreturn]] static fu::never l_1_0_zjtMZ4iT(fu::str&& str, const int x)
{
    str = ((x7E_gCeFmDFw("x="_fu, fu::i64dec(x)) + ": "_fu) + str);
    fail_bih4ghNz(str);
}

static int test_1WsbUdat(const int x)
{
    int _0 {};
    return (_0 = (x & 1)) ? _0 : l_1_0_zjtMZ4iT("even"_fu, x);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        return test_1WsbUdat(2);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "x=2: even!"_fu)
            return 0;
        else
            return 10;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        // The Cats&Dogs example from
        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch
        //   https://www.youtube.com/watch?v=kc9HwsxE1OY
        //
        fn encounter(a, b) {
            let verb = meets(a, b);
            return a.name ~ " meets " ~ b.name ~ " and " ~ verb ~ "\n";
        }

        struct Dog { name: string };
        struct Cat { name: string };

        fn meets(lax a: Dog, lax b: Dog) "sniffs";
        fn meets(lax a: Dog, lax b: Cat) "chases";
        fn meets(lax a: Cat, lax b: Dog) "hisses";
        fn meets(lax a: Cat, lax b: Cat) "slinks";

        fn main() {
            let fido        = Dog("Fido");
            let rex         = Dog("Rex");
            let whiskers    = Cat("Whiskers");
            let spots       = Cat("Spots");

            mut res = encounter(fido, rex)
                    ~ encounter(fido, whiskers)
                    ~ encounter(whiskers, rex)
                    ~ encounter(whiskers, spots);

            return res == "Fido meets Rex and sniffs\n"
                        ~ "Fido meets Whiskers and chases\n"
                        ~ "Whiskers meets Rex and hisses\n"
                        ~ "Whiskers meets Spots and slinks\n"
                            ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct s_Dog;
struct s_Cat;

                                #ifndef DEF_s_Dog
                                #define DEF_s_Dog
struct s_Dog
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Cat
                                #define DEF_s_Cat
struct s_Cat
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::str meets_TOJ7Ierf()
{
    return "sniffs"_fu;
}

inline static fu::str encounter_TOJ7Ierf(const s_Dog& a, const s_Dog& b)
{
    fu::str verb = meets_TOJ7Ierf();
    return ((((a.name + " meets "_fu) + b.name) + " and "_fu) + verb) + "\n"_fu;
}

static fu::str meets_uZbVy2ur()
{
    return "chases"_fu;
}

inline static fu::str encounter_uZbVy2ur(const s_Dog& a, const s_Cat& b)
{
    fu::str verb = meets_uZbVy2ur();
    return ((((a.name + " meets "_fu) + b.name) + " and "_fu) + verb) + "\n"_fu;
}

static fu::str meets_s6TvvWJH()
{
    return "hisses"_fu;
}

inline static fu::str encounter_s6TvvWJH(const s_Cat& a, const s_Dog& b)
{
    fu::str verb = meets_s6TvvWJH();
    return ((((a.name + " meets "_fu) + b.name) + " and "_fu) + verb) + "\n"_fu;
}

static fu::str meets_MgDgvsaZ()
{
    return "slinks"_fu;
}

inline static fu::str encounter_MgDgvsaZ(const s_Cat& a, const s_Cat& b)
{
    fu::str verb = meets_MgDgvsaZ();
    return ((((a.name + " meets "_fu) + b.name) + " and "_fu) + verb) + "\n"_fu;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_Dog fido = s_Dog { "Fido"_fu };
    s_Dog rex = s_Dog { "Rex"_fu };
    s_Cat whiskers = s_Cat { "Whiskers"_fu };
    s_Cat spots = s_Cat { "Spots"_fu };
    fu::str res = (((encounter_TOJ7Ierf(fido, rex) + encounter_uZbVy2ur(fido, whiskers)) + encounter_s6TvvWJH(whiskers, rex)) + encounter_MgDgvsaZ(whiskers, spots));
    if (res == ((("Fido meets Rex and sniffs\n"_fu + "Fido meets Whiskers and chases\n"_fu) + "Whiskers meets Rex and hisses\n"_fu) + "Whiskers meets Spots and slinks\n"_fu))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn args_in_cases(a, b)              
            case (a -> typeof(b))            = a + b;

        fn main() args_in_cases(+1, -1);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:19+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case ([31;1ma[0m -> typeof(b))            = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn args_in_cases(a, b)              
            case (typeof(a) -> b)            = a + b;

        fn main() args_in_cases(+1, -1);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:32+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case (typeof(a) -> [31;1mb[0m)            = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn args_in_cases(a, b)              
            case (a -> b)                    = a + b;

        fn main() args_in_cases(+1, -1);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:19+1[0m:

[2m      | [0m
[2m      |         fn args_in_cases(a, b)              [0m
[2m    3 | [0m            case ([31;1ma[0m -> b)                    = a + b;
[2m      | [0m
[2m      |         fn main() args_in_cases(+1, -1);[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn args_in_cases(a, b)              
            case (typeof(a) -> typeof(b))    = a + b;

        fn main() args_in_cases(+1, -1);

-----

#ifndef fu_NO_fdefs

inline static int args_in_cases_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return args_in_cases_hwGp0ETu(+1, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ARR_LAST(a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        fn main()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int ARR_LAST_zj1tLGtT(fu::view<int> a)
{
    return a[(a.size() - 1)];
}

inline static int& ARR_LAST_bJzechqP(fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 2 } };
    ARR_LAST_bJzechqP(b) += ARR_LAST_zj1tLGtT(a);
    return ARR_LAST_zj1tLGtT(b) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn ARR_LAST(a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int ARR_LAST_rdDCo7PP(fu::view<int> a)
{
    return a[(a.size() - 1)];
}

inline static int& ARR_LAST_qAYA9w8C(fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 2 } };
    ARR_LAST_qAYA9w8C(b) += ARR_LAST_rdDCo7PP(a);
    return ARR_LAST_rdDCo7PP(b) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;

-----
struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_g1XyuUhX(s_S&& x)
{
    return (x.i += 1);
}

int fu_MAIN()
{
    return test_g1XyuUhX(s_S { -1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int ARR_LAST_rdDCo7PP(fu::view<int> a)
{
    return a[(a.size() - 1)];
}

inline static int& ARR_LAST_qAYA9w8C(fu::view_mut<int> a)
{
    return a.mutref((a.size() - 1));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 2 } };
    ARR_LAST_qAYA9w8C(b) += ARR_LAST_rdDCo7PP(a);
    return ARR_LAST_rdDCo7PP(b) - ARR_LAST_rdDCo7PP((fu::slate<1, int> { 3 }));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct mat4 { i: i32; };
        struct RenderFrame { u_mat4_VP: mat4; };

        inline fn mat4_identity() mat4(1);

        fn test(output: &mut RenderFrame) {
            output.u_mat4_VP = mat4_identity;
        }

        fn main() {
            mut ret: RenderFrame;
            test(ret);
            return ret.u_mat4_VP.i - 1;
        }

-----
struct s_RenderFrame;
struct s_mat4;

                                #ifndef DEF_s_mat4
                                #define DEF_s_mat4
struct s_mat4
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_RenderFrame
                                #define DEF_s_RenderFrame
struct s_RenderFrame
{
    s_mat4 u_mat4_VP;
    explicit operator bool() const noexcept
    {
        return false
            || u_mat4_VP
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_DjvGR4Jn(s_RenderFrame& output)
{
    output.u_mat4_VP = s_mat4 { 1 };
}

int fu_MAIN()
{
    s_RenderFrame ret {};
    test_DjvGR4Jn(ret);
    return ret.u_mat4_VP.i - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()

            ScopeSkip(min: -1, max: +1)     
                .end - 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 12:22+1[0m:

[2m      |         pub fn main()[0m
[2m      | [0m
[2m   12 | [0m            ScopeSkip[31;1m([0mmin: -1, max: +1)     
[2m      |                 .end - 1;[0m
[2m      | [0m

	Bad call to [34;1mScopeSkip[0m with args (i32 copy AlwaysTrue, i32 copy AlwaysTrue): 

	[35;1mtype[0m [34;1mScopeSkip[0m at [2m2:13+6[0m:
[2m    2 | [0m        pub [31;1mstruct[0m ScopeSkip {

	    Explicit named argument mismatch: no arg [31;1mmin[0m.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m10:16+4[0m

-----

        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()

            ScopeSkip(start: -1, end: +1)   
                .end - 1;

-----
struct s_ScopeSkip;

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int search_cnZRTRF2(const s_ScopeSkip& skip)
{
    return skip.end - skip.start;
}

int fu_MAIN()
{
    return s_ScopeSkip { {}, +1 }.end - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };

        struct mat34 {
            mx: vec3; my: vec3; mz: vec3;
            mo: vec3;
        };

        inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        // What broke is this using reports a conflict,
        //  because 'determinant' got expanded within 'inverse',
        //   and there's another using mat34 there.
        //    Basically we totally don't want it to expand there.
        inline fn determinant(using _: mat34): f32
            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z
            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;

        fn inverse(using mat: mat34): mat34
        {
            let idet = 1 / mat.determinant;

            let i_mx = vec3(
                idet * (- mz.y * my.z + my.y * mz.z),
                idet * (+ mz.y * mx.z - mx.y * mz.z),
                idet * (- my.y * mx.z + mx.y * my.z));

            let i_my = vec3(
                idet * (+ mz.x * my.z - my.x * mz.z),
                idet * (- mz.x * mx.z + mx.x * mz.z),
                idet * (+ my.x * mx.z - mx.x * my.z));

            let i_mz = vec3(
                idet * (- mz.x * my.y + my.x * mz.y),
                idet * (+ mz.x * mx.y - mx.x * mz.y),
                idet * (- my.x * mx.y + mx.x * my.y));

            return mat34(
                i_mx, i_my, i_mz,

                vec3( // point3
                      mo.x * -i_mx.x +
                      mo.y * -i_my.x +
                      mo.z * -i_mz.x,

                      mo.x * -i_mx.y +
                      mo.y * -i_my.y +
                      mo.z * -i_mz.y,

                      mo.x * -i_mx.z +
                      mo.y * -i_my.z +
                      mo.z * -i_mz.z));
        }

        fn main() i32 <|
            mat34_identity.inverse.determinant - 1;             // GNUStmtExpr

-----
struct s_mat34;
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_s_mat34
                                #define DEF_s_mat34
struct s_mat34
{
    s_vec3 mx;
    s_vec3 my;
    s_vec3 mz;
    s_vec3 mo;
    explicit operator bool() const noexcept
    {
        return false
            || mx
            || my
            || mz
            || mo
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_mat34 inverse_5Y56wRHq(const s_mat34& mat)
{
    const float idet = (1.0f / (((((((-mat.mz.x * mat.my.y) * mat.mx.z) + ((mat.my.x * mat.mz.y) * mat.mx.z)) + ((mat.mz.x * mat.mx.y) * mat.my.z)) - ((mat.mx.x * mat.mz.y) * mat.my.z)) - ((mat.my.x * mat.mx.y) * mat.mz.z)) + ((mat.mx.x * mat.my.y) * mat.mz.z)));
    const s_vec3 i_mx = s_vec3 { (idet * ((-mat.mz.y * mat.my.z) + (mat.my.y * mat.mz.z))), (idet * ((+mat.mz.y * mat.mx.z) - (mat.mx.y * mat.mz.z))), (idet * ((-mat.my.y * mat.mx.z) + (mat.mx.y * mat.my.z))) };
    const s_vec3 i_my = s_vec3 { (idet * ((+mat.mz.x * mat.my.z) - (mat.my.x * mat.mz.z))), (idet * ((-mat.mz.x * mat.mx.z) + (mat.mx.x * mat.mz.z))), (idet * ((+mat.my.x * mat.mx.z) - (mat.mx.x * mat.my.z))) };
    const s_vec3 i_mz = s_vec3 { (idet * ((-mat.mz.x * mat.my.y) + (mat.my.x * mat.mz.y))), (idet * ((+mat.mz.x * mat.mx.y) - (mat.mx.x * mat.mz.y))), (idet * ((-mat.my.x * mat.mx.y) + (mat.mx.x * mat.my.y))) };
    return s_mat34 { s_vec3(i_mx), s_vec3(i_my), s_vec3(i_mz), s_vec3 { (((mat.mo.x * -i_mx.x) + (mat.mo.y * -i_my.x)) + (mat.mo.z * -i_mz.x)), (((mat.mo.x * -i_mx.y) + (mat.mo.y * -i_my.y)) + (mat.mo.z * -i_mz.y)), (((mat.mo.x * -i_mx.z) + (mat.mo.y * -i_my.z)) + (mat.mo.z * -i_mz.z)) } };
}

int fu_MAIN()
{
    float BL_1_v {};
    return int(((__extension__ (
    {
        const s_mat34 _ = inverse_5Y56wRHq(s_mat34 { s_vec3 { 1.0f, 0.0f, 0.0f }, s_vec3 { 0.0f, 1.0f, 0.0f }, s_vec3 { 0.0f, 0.0f, 1.0f }, s_vec3{} });
        BL_1_v = ((((((((-_.mz.x * _.my.y) * _.mx.z) + ((_.my.x * _.mz.y) * _.mx.z)) + ((_.mz.x * _.mx.y) * _.my.z)) - ((_.mx.x * _.mz.y) * _.my.z)) - ((_.my.x * _.mx.y) * _.mz.z)) + ((_.mx.x * _.my.y) * _.mz.z)));
    (void)0;}), BL_1_v) - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct TEA
        {
            v0: u32;
            v1: u32;
        }

        inline fn r4(using _: &mut TEA, sum: &mut u32)
        {
            mut delta: u32 = 0x9e3779b9;

            for (mut i = 0; i < 4; i++) {
                sum += delta;

                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        // Stack overflow solving this,
        //  argmax is +inf, and it just
        //   re-enters and re-enters.
        inline fn r4(tea: &mut TEA) {
            mut sum: u32; tea.r4(sum);
        }

        fn main() {
            mut tea: TEA;
            tea.r4();
            return (tea.v0 ^ tea.v0).i32;
        }

-----
struct s_TEA;

                                #ifndef DEF_s_TEA
                                #define DEF_s_TEA
struct s_TEA
{
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_TEA tea {};

    {
        unsigned sum {};
        const unsigned delta = 0x9e3779b9u;
        for (int i = 0; i < 4; i++)
        {
            sum += delta;
            tea.v0 += ((((tea.v1 << 4u) + 0xa341316cu) ^ (tea.v1 + sum)) ^ ((tea.v1 >> 5u) + 0xc8013ea4u));
            tea.v1 += ((((tea.v0 << 4u) + 0xad90777du) ^ (tea.v0 + sum)) ^ ((tea.v0 >> 5u) + 0x7e95761eu));
        };
    };
    return int((tea.v0 ^ tea.v0));
}

#endif

int main() { return fu_MAIN(); }

-----

        // Same as below, but avoids the $T call, which is also broken somehow.
        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -
        //   we emit useless overloads for mutrefs when its clearly useless.

        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i) {
                shadow mut a = a;
                a.i /= 2;
                return rec_cases(a);
            }
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;

-----
struct s_X;
inline static int rec_cases_LFTHD3Vu(const s_X&);
inline static int rec_cases_rgx2eiBu(int);

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int rec_cases_rgx2eiBu(const int a)
{
    if (a)
        return rec_cases_rgx2eiBu((a / 2));
    else
        return a;

}

inline static int rec_cases_LFTHD3Vu(const s_X& a)
{
    if (a.i)
    {
        s_X a_1 { a };
        a_1.i /= 2;
        return rec_cases_LFTHD3Vu(a_1);
    }
    else
        return rec_cases_rgx2eiBu(a.i);

}

int fu_MAIN()
{
    return rec_cases_LFTHD3Vu(s_X { 1 });
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i)    return rec_cases($T(i: a.i / 2));
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;

-----
struct s_X;
inline static int rec_cases_LFTHD3Vu(const s_X&);
inline static int rec_cases_rgx2eiBu(int);

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int rec_cases_rgx2eiBu(const int a)
{
    if (a)
        return rec_cases_rgx2eiBu((a / 2));
    else
        return a;

}

inline static int rec_cases_LFTHD3Vu(const s_X& a)
{
    if (a.i)
    {
        return rec_cases_LFTHD3Vu(s_X { (a.i / 2) });
    }
    else
        return rec_cases_rgx2eiBu(a.i);

}

int fu_MAIN()
{
    return rec_cases_LFTHD3Vu(s_X { 1 });
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        struct X { i: i32; };
        type Y = X;
        fn main() Y(1).i / 2;

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_X { 1 }.i / 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node {
            kind  ?: string;
            items ?: Node[];
            value ?: string;
        };

        fn astReplace(node: Node, mutate): Node {
            fn walk(shadow ref node: Node) {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        fn test(n: Node, a: string, b: string) {
            return astReplace(n, |ref item: Node| {
                if (item.value == a) {
                    if (item.items.len == 1 && item.kind == "call")
                        item.value = b;
                    else if (item.kind == "str")
                        item.value = b;
                }
            });
        }

        fn main() {
            let v0 = Node(kind: "str", value: "woot");
            let v1 = v0.test("woot", "who");
            return v1.value.len - 3;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_Node;
static void walk_AbVucrcx(s_Node&, fu::view<char>, const fu::str&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str kind;
    fu::vec<s_Node> items;
    fu::str value;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static void l_1_0_hplu2tPu(s_Node& item, fu::view<char> a, const fu::str& b)
{
    if (item.value == a)
    {
        if ((item.items.size() == 1) && (item.kind == "call"_fu))
            item.value = b;
        else if (item.kind == "str"_fu)
            item.value = b;

    };
}

static void walk_AbVucrcx(s_Node& node, fu::view<char> a, const fu::str& b)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        s_Node* _0;
        (_0 = &(node.items.mutref(i)), walk_AbVucrcx(*_0, a, b));
    };
    l_1_0_hplu2tPu(node, a, b);
}

inline static s_Node astReplace_VVHrRqWq(const s_Node& node, fu::view<char> a, const fu::str& b)
{
    /*MOV*/ s_Node node_1 { node };
    walk_AbVucrcx(node_1, a, b);
    return /*NRVO*/ node_1;
}

static s_Node test_MjbPTrEm(const s_Node& n, fu::view<char> a, const fu::str& b)
{
    return astReplace_VVHrRqWq(n, a, b);
}

int fu_MAIN()
{
    s_Node v0 = s_Node { "str"_fu, fu::vec<s_Node>{}, "woot"_fu };
    s_Node v1 = test_MjbPTrEm(v0, "woot"_fu, "who"_fu);
    return v1.value.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec, N_AARMustSeq

-----

        fn main() {
            mut x:  
                    typeof(i32)      = 0;
            return x;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:28+3[0m:

[2m      |         fn main() {[0m
[2m      |             mut x:  [0m
[2m    4 | [0m                    typeof([31;1mi32[0m)      = 0;
[2m      |             return x;[0m
[2m      |         }[0m

	Redundant [31;1mtypeof[0m, this is a type, not a value: i32 copy Typename

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut x:  
                    i32              = 0;
            return x;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    return x;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);



            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

-----
#include <fu/vec.h>

struct s_SolvedNode;
struct s_Visitor;
static void traverse_M9uHliTm(s_Visitor&, const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int value;
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Visitor
                                #define DEF_s_Visitor
struct s_Visitor
{
    int sum;
    explicit operator bool() const noexcept
    {
        return false
            || sum
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void visit_nIE6QEMB(s_Visitor& v, const s_SolvedNode& node)
{
    v.sum += node.value;
}

static void traverse_M9uHliTm(s_Visitor& v, const s_SolvedNode& n)
{
    visit_nIE6QEMB(v, n);
    for (int i = 0; i < n.items.size(); i++)
        traverse_M9uHliTm(v, n.items[i]);

}

inline static void visitNodes_uqNWjqxX(s_Visitor& _v, const s_SolvedNode& _n)
{
    traverse_M9uHliTm(_v, _n);
}

int fu_MAIN()
{
    s_SolvedNode tree = s_SolvedNode { 3, fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode { 5, fu::vec<s_SolvedNode>{} }, s_SolvedNode { 7, fu::vec<s_SolvedNode>{} } } } };
    s_Visitor myVisitor {};
    visitNodes_uqNWjqxX(myVisitor, tree);
    return myVisitor.sum - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);


            // This is an aside, managed to lose the copy qual when working structs
            //  Initially noticed it because visitNodes tried to change its sighash
            mut cpy = tree; cpy = tree; // <- but this fails cleanly when tree is nocopy


            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

-----
#include <fu/vec.h>

struct s_SolvedNode;
struct s_Visitor;
static void traverse_ZpXBUH71(s_Visitor&, const s_SolvedNode&);

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int value;
    fu::vec<s_SolvedNode> items;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || value
            || items
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Visitor
                                #define DEF_s_Visitor
struct s_Visitor
{
    int sum;
    explicit operator bool() const noexcept
    {
        return false
            || sum
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void visit_nIE6QEMB(s_Visitor& v, const s_SolvedNode& node)
{
    v.sum += node.value;
}

static void traverse_ZpXBUH71(s_Visitor& v, const s_SolvedNode& n)
{
    visit_nIE6QEMB(v, n);
    for (int i = 0; i < n.items.size(); i++)
        traverse_ZpXBUH71(v, n.items[i]);

}

inline static void visitNodes_uqNWjqxX(s_Visitor& _v, const s_SolvedNode& _n)
{
    traverse_ZpXBUH71(_v, _n);
}

int fu_MAIN()
{
    s_SolvedNode tree = s_SolvedNode { 3, fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode { 5, fu::vec<s_SolvedNode>{} }, s_SolvedNode { 7, fu::vec<s_SolvedNode>{} } } } };
    s_SolvedNode cpy { tree };
    cpy = tree;
    s_Visitor myVisitor {};
    visitNodes_uqNWjqxX(myVisitor, tree);
    return myVisitor.sum - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy

-----

        return 0 > 1 ? throw("should type check") : 0;

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0 > 1)
        fu::fail("should type check"_fu);
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_H9fhQUVP()
{
    fu::fail("hey"_fu);
}

int fu_MAIN()
{

    try
    {
        throw_hey_H9fhQUVP();
    }
    catch (const std::exception& o_0)
    {
        fu::str err = fu::to_str(o_0.what());

        return err.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

-----

        fn throw_hey() {
            throw("hey");
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_H9fhQUVP()
{
    fu::fail("hey"_fu);
}

int fu_MAIN()
{

    try
    {
        throw_hey_H9fhQUVP();
    }
    catch (const std::exception& o_0)
    {
        fu::str err = fu::to_str(o_0.what());

        return err.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

-----

        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                return throw_hey();
            }
            catch (e) {
                return e.len - 3;
            }

            return 11;
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throw_hey_H9fhQUVP()
{
    fu::fail("hey"_fu);
}

int fu_MAIN()
{

    try
    {
        throw_hey_H9fhQUVP();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e.size() - 3;
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static fu::str next_ijszdsuy(fu::view<fu::str> args, int& idx)
{
    const int i = idx++;
    if (i < args.size())
        return fu::str(args[i]);
    else
        return ""_fu;

}

static int cli_handle_7xJ6vcOm(fu::view<fu::str> args)
{
    int idx = 0;
    return next_ijszdsuy(args, idx).size() - 5;
}

int fu_MAIN()
{
    return cli_handle_7xJ6vcOm((fu::slate<2, fu::str> { "hello"_fu, "you"_fu }));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn test() {
            mut x = 5;
            return x;
        }

        fn main()
            test() - 5;

-----

#ifndef fu_NO_fdefs

static int test_H9fhQUVP()
{
    const int x = 5;
    return x;
}

int fu_MAIN()
{
    return test_H9fhQUVP() - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { i: i32; };

        fn test() {
            mut x = Test(5);
            return x;
        }

        fn main()
            test().i - 5;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test test_H9fhQUVP()
{
    const s_Test x = s_Test { 5 };
    return x;
}

int fu_MAIN()
{
    return test_H9fhQUVP().i - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a: i32; b: i32; };

        fn test() {
            mut x = Test(5, -5);
            return x;
        }

        fn main()
            test().a + test().b;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test test_H9fhQUVP()
{
    const s_Test x = s_Test { 5, -5 };
    return x;
}

int fu_MAIN()
{
    return test_H9fhQUVP().a + test_H9fhQUVP().b;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X { x: i32; };
        fn ref2arg(x: X) = x;

        fn main() {
            let NOTREF = ref2arg(X(101));
            return NOTREF.x - 101;
        }

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_X& ref2arg_YneUA981(const s_X& x)
{
    return x;
}

int fu_MAIN()
{
    const s_X NOTREF { ref2arg_YneUA981(s_X { 101 }) };
    return NOTREF.x - 101;
}

#endif

int main() { return fu_MAIN(); }

-----


        nocopy 
        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:21+1[0m:

[2m      |         fn main() {[0m
[2m      |             let a = Copied(1);[0m
[2m    8 | [0m            mut b = [31;1ma[0m;
[2m      |             b.x++;[0m
[2m      |             return b.x - a.x * 2;[0m

	A value is needed, but can neither copy nor move from: [35;1mcall[0m([35;1mvar[0m [34;1ma[0m) -> Copied

RelaxCopyResize [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----


        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }

-----
struct s_Copied;

                                #ifndef DEF_s_Copied
                                #define DEF_s_Copied
struct s_Copied
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Copied a = s_Copied { 1 };
    s_Copied b { a };
    b.x++;
    return b.x - (a.x * 2);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct XY { x: i32; y: i32; };
        fn ref2arg(v: XY) = v;

        fn main() {
            let a = XY(99, 2);
            let ref2a = ref2arg(a);
            return mem::ptr_eq(a, ref2a) ? 0 : 1;
        }

-----

-----

        nocopy struct NoCopy { i: i32; };
        fn retmutref(ref nc: NoCopy) nc;

        fn main() {
            mut nc: NoCopy;
            nc.retmutref.retmutref.i++;
            return nc.i - 1;
        }

-----
struct s_NoCopy;

                                #ifndef DEF_s_NoCopy
                                #define DEF_s_NoCopy
struct s_NoCopy
{
    int i;
    s_NoCopy(const s_NoCopy&) = delete;
    s_NoCopy(s_NoCopy&&) = default;
    s_NoCopy& operator=(const s_NoCopy&) = delete;
    s_NoCopy& operator=(s_NoCopy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_NoCopy& retmutref_Rgy4SZeR(s_NoCopy& nc)
{
    return nc;
}

int fu_MAIN()
{
    s_NoCopy nc {};
    retmutref_Rgy4SZeR(retmutref_Rgy4SZeR(nc)).i++;
    return nc.i - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NoCopy { i: i32; };
        fn mutrefself(ref nc: NoCopy) {
            nc.i++;
            return nc;
        }

        fn main() {
            mut nc: NoCopy;
            nc.mutrefself().mutrefself();
            return nc.i - 2;
        }

-----
struct s_NoCopy;

                                #ifndef DEF_s_NoCopy
                                #define DEF_s_NoCopy
struct s_NoCopy
{
    int i;
    s_NoCopy(const s_NoCopy&) = delete;
    s_NoCopy(s_NoCopy&&) = default;
    s_NoCopy& operator=(const s_NoCopy&) = delete;
    s_NoCopy& operator=(s_NoCopy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_NoCopy& mutrefself_Rgy4SZeR(s_NoCopy& nc)
{
    nc.i++;
    return nc;
}

int fu_MAIN()
{
    s_NoCopy nc {};
    mutrefself_Rgy4SZeR(mutrefself_Rgy4SZeR(nc));
    return nc.i - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;
            let b: NoCopy;
            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;
        }

-----
struct s_NoCopy;

                                #ifndef DEF_s_NoCopy
                                #define DEF_s_NoCopy
struct s_NoCopy
{
    int i;
    s_NoCopy(const s_NoCopy&) = delete;
    s_NoCopy(s_NoCopy&&) = default;
    s_NoCopy& operator=(const s_NoCopy&) = delete;
    s_NoCopy& operator=(s_NoCopy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_NoCopy& retargs_or_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    return a ? a : b;
}

static const s_NoCopy& retargs_and_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    return !a ? a : b;
}

static const s_NoCopy& retargs_if_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    if (a.i)
        return b;
    else
        return a;

}

static const s_NoCopy& retarg_qcIgV1Nu(const s_NoCopy& a)
{
    return a;
}

int fu_MAIN()
{
    s_NoCopy a {};
    s_NoCopy b {};
    return retarg_qcIgV1Nu(retargs_if_WwvEw7pS(a, retargs_and_WwvEw7pS(a, retargs_or_WwvEw7pS(a, b)))).i;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;                      // <- b now temp

            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;
        }

-----
struct s_NoCopy;

                                #ifndef DEF_s_NoCopy
                                #define DEF_s_NoCopy
struct s_NoCopy
{
    int i;
    s_NoCopy(const s_NoCopy&) = delete;
    s_NoCopy(s_NoCopy&&) = default;
    s_NoCopy& operator=(const s_NoCopy&) = delete;
    s_NoCopy& operator=(s_NoCopy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_NoCopy& retargs_or_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    return a ? a : b;
}

static const s_NoCopy& retargs_and_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    return !a ? a : b;
}

static const s_NoCopy& retargs_if_WwvEw7pS(const s_NoCopy& a, const s_NoCopy& b)
{
    if (a.i)
        return b;
    else
        return a;

}

static const s_NoCopy& retarg_qcIgV1Nu(const s_NoCopy& a)
{
    return a;
}

int fu_MAIN()
{
    s_NoCopy a {};
    return retarg_qcIgV1Nu(retargs_if_WwvEw7pS(a, retargs_and_WwvEw7pS(a, retargs_or_WwvEw7pS(a, s_NoCopy{})))).i;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct NoCopy { i: i32; };

        fn      retarg(a) a;                    // <- now templates
        fn  retargs_if(a, b) a.i ? b : a;
        fn  retargs_or(a, b) a || b;
        fn retargs_and(a, b) a && b;

        fn main() {
            mut a: NoCopy;                      // <- now muts
            mut b: NoCopy;
            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;
            return a.i + b.i - 1;
        }

-----
struct s_NoCopy;

                                #ifndef DEF_s_NoCopy
                                #define DEF_s_NoCopy
struct s_NoCopy
{
    int i;
    s_NoCopy(const s_NoCopy&) = delete;
    s_NoCopy(s_NoCopy&&) = default;
    s_NoCopy& operator=(const s_NoCopy&) = delete;
    s_NoCopy& operator=(s_NoCopy&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_NoCopy& retargs_or_YXHyp6lj(s_NoCopy& a, s_NoCopy& b)
{
    return a ? a : b;
}

inline static s_NoCopy& retargs_and_YXHyp6lj(s_NoCopy& a, s_NoCopy& b)
{
    return !a ? a : b;
}

inline static s_NoCopy& retargs_if_YXHyp6lj(s_NoCopy& a, s_NoCopy& b)
{
    if (a.i)
        return b;
    else
        return a;

}

inline static s_NoCopy& retarg_YorEcrLB(s_NoCopy& a)
{
    return a;
}

int fu_MAIN()
{
    s_NoCopy a {};
    s_NoCopy b {};
    retarg_YorEcrLB(retargs_if_YXHyp6lj(a, retargs_and_YXHyp6lj(a, retargs_or_YXHyp6lj(a, b)))).i++;
    return (a.i + b.i) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn as_blocks_after(x: i32) {
            mut zero = 0;
            if (x > 2) // a broken stmt emit lifted the loop out of the conditional
                for (mut i = 0; i < x; i++)
                    zero = i + i*zero;

            return zero;
        }

        fn main() 2.as_blocks_after;

-----

#ifndef fu_NO_fdefs

static int as_blocks_after_1WsbUdat(const int x)
{
    int zero = 0;
    if (x > 2)
        for (int i = 0; i < x; i++)
            zero = (i + (i * zero));
;
    return zero;
}

int fu_MAIN()
{
    return as_blocks_after_1WsbUdat(2);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Lifetime { woot: Lifetime[]; };

        fn Lifetime_test(x: Lifetime) {
            x.woot.len & 1 && throw("This is very important.");
            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);
            return x;
        }

        fn Lifetime_fromBinding(x: i32) {
            mut woot: Lifetime[];
            for (mut i = 0; i < x; i++)
                woot[i] = Lifetime();

            // !N_NonTrivAutoCopy
            //
            //  1. Move 'woot' into Lifetime
            //      instead of naively copying it.
            //                             ....
            return Lifetime_test(Lifetime(:woot));              // ConstCast
            //     ....
            //  2. Move the result out even though
            //      Lifetime_test takes and returns refs.
        }

        fn main() 0.Lifetime_fromBinding.woot.len;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>

struct s_Lifetime;
static const s_Lifetime& Lifetime_test_2OpeMETq(const s_Lifetime&);

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<s_Lifetime> woot;
    s_Lifetime(const s_Lifetime&) = default;
    s_Lifetime(s_Lifetime&&) = default;
    s_Lifetime& operator=(s_Lifetime&&) = default;
    s_Lifetime& operator=(const s_Lifetime& selfrec) { return *this = s_Lifetime(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || woot
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Lifetime& Lifetime_test_2OpeMETq(const s_Lifetime& x)
{
    if (x.woot.size() & 1)
        fu::fail("This is very important."_fu);
    else
    {
        for (int i = 0; i < x.woot.size(); i++)
        {
            Lifetime_test_2OpeMETq(x.woot[i]);
        };
        return x;
    };
}

static s_Lifetime Lifetime_fromBinding_1WsbUdat(const int x)
{
    /*MOV*/ fu::vec<s_Lifetime> woot {};
    for (int i = 0; i < x; i++)
    {
        woot.mutref(i) = s_Lifetime{};
    };
    return static_cast<s_Lifetime&&>(const_cast<s_Lifetime&>(Lifetime_test_2OpeMETq(s_Lifetime { static_cast<fu::vec<s_Lifetime>&&>(woot) })));
}

int fu_MAIN()
{
    return Lifetime_fromBinding_1WsbUdat(0).woot.size();
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        fn test(x: i32) {                       // none of these need vecs
            let c = [10007];                    // TODO fu::slate<1, int> c
            let a = [7, 11, 9, 21, x, x, x, x]; // TODO fu::slate<2, int> a
            let b = {                           // TODO fu::slate<1, int> b
                :BRK {                          // !N_NonTrivAutoCopy
                    if (x & 2) break :BRK c;
                    if (x & 1) break :BRK [ x ]; // a val
                    a // a ref
                }
            };
            return a[0] - b[0] * a[1];
        }

        fn main() 1.test + 4.test + 74;

-----
;; TODO fu::slate<1, int> c
;; TODO fu::slate<2, int> a
;; TODO fu::slate<1, int> b

#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    /*MOV*/ fu::vec<int> c = fu::vec<int> { fu::slate<1, int> { 10007 } };
    fu::vec<int> a = fu::vec<int> { fu::slate<8, int> { 7, 11, 9, 21, x, x, x, x } };
    fu::vec<int> b = ((x & 2) ? static_cast<fu::vec<int>&&>(c) : ((x & 1) ? fu::vec<int> { fu::slate<1, int> { x } } : fu::vec<int>(a)));
    return a[0] - (b[0] * a[1]);
}

int fu_MAIN()
{
    return (test_1WsbUdat(1) + test_1WsbUdat(4)) + 74;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Test { i: i32[]; };

        fn test(mut x: Test) {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }

-----
#include <fu/vec.h>

struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test test_SG3u5QDV(/*MOV*/ s_Test&& x)
{
    x.i.mutref(0) += x.i[1];
    return static_cast<s_Test&&>(x);
}

int fu_MAIN()
{
    s_Test s = s_Test { fu::vec<int> { fu::slate<2, int> { 1, 2 } } };
    return test_SG3u5QDV(s_Test(s)).i[0] - (s.i[0] * 3);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Test { i: i32[]; };

        fn test(mut x: Test): Test {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }

-----
#include <fu/vec.h>

struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    fu::vec<int> i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test test_SG3u5QDV(/*MOV*/ s_Test&& x)
{
    x.i.mutref(0) += x.i[1];
    return static_cast<s_Test&&>(x);
}

int fu_MAIN()
{
    s_Test s = s_Test { fu::vec<int> { fu::slate<2, int> { 1, 2 } } };
    return test_SG3u5QDV(s_Test(s)).i[0] - (s.i[0] * 3);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn compile_snippets(x0: string) x0.find('a') && throw("throw#1");
        fn ZERO(x1: string) x1.find('b') && throw("throw#2");

        fn FAIL(x2: string): string {                   // EXPECT fu::view<char> x2
            try {
                let ctx = compile_snippets(x2) && "hey";
                return ctx;
            }
            catch (e) {
                return ZERO(x2) && e;
            }
        }

        fn main() FAIL("a").len;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_find_KonMQ4KBuu5
                                #define DEF_find_KonMQ4KBuu5
inline int find_KonMQ4KB(fu::view<char> a, const char b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

static int compile_snippets_URoAvQ5D(fu::view<char> x0)
{
    if (find_KonMQ4KB(x0, 'a'))
        fu::fail("throw#1"_fu);
    else
        return 0;

}

static int ZERO_no1OFgBl(fu::view<char> x1)
{
    if (find_KonMQ4KB(x1, 'b'))
        fu::fail("throw#2"_fu);
    else
        return 0;

}

static fu::str FAIL_Cl70xXVM(fu::view<char> x2)
{

    try
    {
    {
        /*MOV*/ fu::str ctx = (compile_snippets_URoAvQ5D(x2), fu::str{});
        return /*NRVO*/ ctx;
    }
    }
    catch (const std::exception& o_0)
    {
    {
        ZERO_no1OFgBl(x2);
        return fu::str{};
    }
    }
;
}

int fu_MAIN()
{
    return FAIL_Cl70xXVM("a"_fu).size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        // The thing below but shorter:
        //  the '|| throw' introduces a bullshit lambda during codegen,
        //   which misreturns a dangling reference to its own frame.
        fn test(x: string) [x][0] || throw("nope!");
        fn main() "what".test.len - 4;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static fu::str test_Z6ISOjUJ(const fu::str& x)
{
    const fu::str* _0;
    return fu::str((*(_0 = &((fu::slate<1, fu::str> { fu::str(x) })[0])) ? *_0 : fu::fail("nope!"_fu)));
}

int fu_MAIN()
{
    return test_Z6ISOjUJ("what"_fu).size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn only(s: $T[]) s.len == 1 ? s[0] : throw ("len != 1: " ~ s.len);

        struct Node       { kind: string; };
        struct SolvedNode { kind: string; };

        fn solveNodes(n: Node[]) {
            mut r: SolvedNode[];
            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);
            return r;
        }

        // the '|| throw' introduces a bullshit lambda during codegen,
        //  which misreturns a dangling reference to its own frame.
        fn solveDeclExpr(n: Node) solveNodes([ n ]).only || throw ("!only");

        fn main() solveDeclExpr(Node("a")).kind.len - 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_Node;
struct s_SolvedNode;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str kind;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str kind;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<s_SolvedNode> solveNodes_MZ5eMiuF(fu::view<s_Node> n)
{
    /*MOV*/ fu::vec<s_SolvedNode> r {};
    for (int i = 0; i < n.size(); i++)
    {
        r += s_SolvedNode { fu::str(n[i].kind) };
    };
    return /*NRVO*/ r;
}

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

inline static const s_SolvedNode& only_Q4jDR6az(fu::view<s_SolvedNode> s)
{
    if (s.size() == 1)
        return s[0];
    else
        fu::fail(x7E_gCeFmDFw("len != 1: "_fu, fu::i64dec(s.size())));

}

static s_SolvedNode solveDeclExpr_UOKmiuTs(const s_Node& n)
{
    const s_SolvedNode* _0;
    return s_SolvedNode((*(_0 = &(only_Q4jDR6az(solveNodes_MZ5eMiuF((fu::slate<1, s_Node> { s_Node(n) }))))) ? *_0 : fu::fail("!only"_fu)));
}

int fu_MAIN()
{
    return solveDeclExpr_UOKmiuTs(s_Node { "a"_fu }).kind.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        pub fn test(x: i32): i32[] { // !N_NonTrivAutoCopy
            mut a = [ 4 ];
            mut b = [ 5 ];
            mut c = [ 6 ];

            for (mut i = 0; i < x; i++) {
                a.unshift(x);
                b.unshift(x);
                c.unshift(x);
            }

            inline fn which() {
                return :test x & 1 ? a : b;
            }

            if !(x & 2)
                return which();

            return c;
        }

        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

fu::vec<int> test_1WsbUdat(const int x)
{
    /*MOV*/ fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 4 } };
    /*MOV*/ fu::vec<int> b = fu::vec<int> { fu::slate<1, int> { 5 } };
    /*MOV*/ fu::vec<int> c = fu::vec<int> { fu::slate<1, int> { 6 } };
    for (int i = 0; i < x; i++)
    {
        a.unshift(x);
        b.unshift(x);
        c.unshift(x);
    };
    if (!(x & 2))
    {
        if (x & 1)
            return /*NRVO*/ a;
        else
            return /*NRVO*/ b;

    }
    else
        return /*NRVO*/ c;

}

int fu_MAIN()
{
    return (test_1WsbUdat(2)[2] + test_1WsbUdat(1)[1]) - (2 * test_1WsbUdat(0)[0]);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn incr_x_to_1(ref x: i32) {
            x && throw("this reports return t_never");
            fn incr_x() { return x++; }
            incr_x();
        }
        fn main() {
            mut x = 0;
            incr_x_to_1(x);
            return x - 1;
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int incr_x_y1jV3SX3(int& x)
{
    return x++;
}

static void incr_x_to_1_3JeKX2Qj(int& x)
{
    if (x)
        fu::fail("this reports return t_never"_fu);
    else
        incr_x_y1jV3SX3(x);

}

int fu_MAIN()
{
    int x = 0;
    incr_x_to_1_3JeKX2Qj(x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut x = 0;
            fn incr_x_to_1() {
                x && throw("this reports return t_never");
                fn incr_x() { return x++; }
                incr_x();
            }
            incr_x_to_1();
            return x - 1;
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int incr_x_y1jV3SX3(int& x)
{
    return x++;
}

static void incr_x_to_1_EJhRWC6k(int& x)
{
    if (x)
        fu::fail("this reports return t_never"_fu);
    else
        incr_x_y1jV3SX3(x);

}

int fu_MAIN()
{
    int x = 0;
    incr_x_to_1_EJhRWC6k(x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn apply(fn, v) fn(v);
        fn main() {
            mut x = 0;
            fn scope_using(via: i32) {
                x && throw("this reports return t_never");
                // which messed up retcount for scope_using
                fn visit(item: i32) {
                    if (item) return item;
                    return x++;
                }
                apply(fn visit, via);
            }

            scope_using(x);
            return x - 1;
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int visit_AbClDjXn(const int item, int& x)
{
    if (item)
        return item;
    else
        return x++;

}

inline static int apply_5SmlbYU3(const int v, int& x)
{
    return visit_AbClDjXn(v, x);
}

static void scope_using_MTGRgajD(const int via, int& x)
{
    if (x)
        fu::fail("this reports return t_never"_fu);
    else
        apply_5SmlbYU3(via, x);

}

int fu_MAIN()
{
    int x = 0;
    scope_using_MTGRgajD(x, x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()   
            010     
                == 8 ? 0 : 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:13+1[0m:

[2m      | [0m
[2m      |         fn main()   [0m
[2m    3 | [0m            [31;1m0[0m10     
[2m      |                 == 8 ? 0 : 1;[0m
[2m      | [0m

	Leading zero in numeric literal, perhaps you meant 0x, 0b or 0o.

-----

        fn main()   
            0o10    
                == 8 ? 0 : 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (010u == 8u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        fn main() 0x101 == 257 ? 0 : 1; 

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0x101u == 257u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        fn main() 0o101 ==  65 ? 0 : 1; 

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0101u == 65u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        fn main() 0b101 ==   5 ? 0 : 1; 

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (0b101u == 5u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()
            i32(f64.PI * 2.0) - 6;

-----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((static_cast<double>(M_PI) * 2.0)) - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn main()
            i32(f64.PI * 2 - 6);

-----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn main()
            f64.PI * 2 - 6 |> i32;

-----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn main()
            i32 <| f64.PI * 2 - 6;

-----
#include <math.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(((static_cast<double>(M_PI) * 2.0) - 6.0));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        let x: f32 = 1; fn main() 1 - x.i32;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr float x = 1.0f;
                                #endif

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let x: f32 = 1.0; fn main() 1 - x.i32;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr float x = 1.0f;
                                #endif

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let x: u8 = 1; fn main() 1 - x.i32;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr fu::u8 x = fu::u8(1u);
                                #endif

int fu_MAIN()
{
    return 1 - int(unsigned(x));
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let x = 1.f32; fn main() 1 - x.i32;

-----

#ifndef fu_NO_fdefs

static const float x = float(1);

int fu_MAIN()
{
    return 1 - int(x);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn gt0(x: f32) x > 0;
        fn main() gt0(1.f32) ? 0 : 1;

-----

#ifndef fu_NO_fdefs

static bool gt0_1fnyaPLZ(const float x)
{
    return x > 0.0f;
}

int fu_MAIN()
{
    if (gt0_1fnyaPLZ(float(1)))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hey { x: f32; };
        fn hey() Hey(1);
        fn main() hey.x.i32 - 1;

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    float x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Hey hey_H9fhQUVP()
{
    return s_Hey { 1.0f };
}

int fu_MAIN()
{
    return int(hey_H9fhQUVP().x) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);
        fn main() {
            let v = test(1);
            return (v.x + v.z).i32;
        }

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_vec3 test_nD58vCLu(const int i)
{
    return s_vec3 { float((i - 2)), 0.0f, 1.0f };
}

int fu_MAIN()
{
    const s_vec3 v = test_nD58vCLu(1);
    return int((v.x + v.z));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(f: f32) vec3(x: f, z: -1);
        fn main() {
            let v = test(-1);
            return (v.x - v.z).i32;
        }

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_vec3 test_ykW4bBCj(const float f)
{
    return s_vec3 { f, 0.0f, -1.0f };
}

int fu_MAIN()
{
    const s_vec3 v = test_ykW4bBCj(-1.0f);
    return int((v.x - v.z));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hey(i: f32) i.f32 + 0.5;
        fn main() hey(1).i32 - 1;

-----

#ifndef fu_NO_fdefs

static float hey_A6hvC3sT(const float i)
{
    return float(i) + 0.5f;
}

int fu_MAIN()
{
    return int(hey_A6hvC3sT(1.0f)) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn lin2srgb(l: f32): f32
            l <= 0.0031308
                ? l * 12.92
                : 1.055 * pow(l, 1/2.4.f32) - 0.055;

        fn lin255(v: f32) u32 <|
            v.lin2srgb.max(0).min(1) * 255.99;

        fn main() i32 <|
            lin255(1) - 255;

-----
#include <cmath>


#ifndef fu_NO_fdefs

static float lin2srgb_uoT1VD7R(const float l)
{
    if ((l <= 0.0031308f))
        return l * 12.92f;
    else
        return (1.055f * std::pow(l, (1.0f / float(2.4)))) - 0.055f;

}

static unsigned lin255_4VAT4DJ8(const float v)
{
    return unsigned((std::fmax(std::fmin(lin2srgb_uoT1VD7R(v), 0.0f), 1.0f) * 255.99f));
}

int fu_MAIN()
{
    return int((lin255_4VAT4DJ8(1.0f) - 255u));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };

        inline fn /(a: f32, b: vec3)                            // GNUStmtExpr
            vec3(a / b.x, a / b.y, a / b.z);

        fn main() i32 <|
            (1/vec3(x: 1)).x - 1;

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec3 BL_1_v {};
    return int(((__extension__ (
    {
        const float a = 1.0f;
        const s_vec3 b = s_vec3 { 1.0f, {}, {} };
        BL_1_v = (s_vec3 { (a / b.x), {}, {} });
    (void)0;}), static_cast<s_vec3&&>(BL_1_v)).x - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        let QUAD_DATA: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
            -1, +1, 0,      0, 0, 1,    0, 1, 0,

            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
        ];

        fn main() QUAD_DATA.len - 6 * 9;

-----
#include <fu/vec.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<float> QUAD_DATA fu_INIT_PRIORITY(1001) = fu::vec<float> { fu::slate<54, float> { -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, -1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, +1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, +1.0f, +1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f } };

int fu_MAIN()
{
    return QUAD_DATA.size() - (6 * 9);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn test(a: bool): u8 = a ? 1 : 0;

        fn main() test(false).i32;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

static fu::u8 test_vp6KWXBC(const bool a)
{
    if (a)
        return fu::u8(1u);
    else
        return fu::u8(0u);

}

int fu_MAIN()
{
    return int(unsigned(test_vp6KWXBC(false)));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a: bool): u8 = a && 1;

        fn main() test(false).i32;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

static fu::u8 test_vp6KWXBC(const bool a)
{
    if (a)
        return fu::u8(1u);
    else
        return fu::u8(0u);

}

int fu_MAIN()
{
    return int(unsigned(test_vp6KWXBC(false)));
}

#endif

int main() { return fu_MAIN(); }

-----

        pub let A_u8: u8 = 0x0;

        fn ATTRIB(type: u8, count: i32, srgb = false): u8
            = type & 0x3 | count.u8 << 2

            // TODO can't deep-retype the last cast unfortunately:
            //  we need another hint to drive typing here,
            //   perhaps monogenous signatures, or else.
            | (srgb && 0x80.u8);

        fn main() ATTRIB(A_u8, 4).i32 - 16;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_A_u8
                                #define DEF_A_u8
inline constexpr fu::u8 A_u8 = fu::u8(0x0u);
                                #endif

static fu::u8 ATTRIB_Ug78t7b3(const fu::u8 type, const int count, const bool srgb)
{
    return fu::u8((fu::u8((type & fu::u8(0x3u))) | fu::u8((fu::u8(unsigned(count)) << fu::u8(2u))))) | (srgb ? fu::u8(0x80u) : fu::u8(0u));
}

int fu_MAIN()
{
    return int(unsigned(ATTRIB_Ug78t7b3(A_u8, 4, false))) - 16;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        pub struct Geometry    { g: i32; };
        pub struct Texture     { t: i32; };
        pub struct RenderFrame { r: i32; };

        pub struct LogicFrame_in
        {
            lastLogic:  LogicFrame;
        };

        pub struct LogicFrame
        {
            DATA_fbx:   Geometry;
            TEX_A:      Texture;
            TEX_AO:     Texture;
            TEX_M:      Texture;
            TEX_N:      Texture;
            TEX_R:      Texture;
            HDR:        Texture;
        };

        pub struct RenderFrame_in
        {
            w:          i16;
            h:          i16;
            frame:      i32;

            mouseX:     f32;
            mouseY:     f32;
            mouseBtns:  i32;

            using logic:    LogicFrame;
            lastRender:     RenderFrame;
        };

        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame
        {
            return RenderFrame(args.HDR.t);
        }

        fn main() 0;

-----
struct s_RenderFrame;
struct s_RenderFrame_in;
struct s_LogicFrame;
struct s_Geometry;
struct s_Texture;

                                #ifndef DEF_s_RenderFrame
                                #define DEF_s_RenderFrame
struct s_RenderFrame
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Texture
                                #define DEF_s_Texture
struct s_Texture
{
    int t;
    explicit operator bool() const noexcept
    {
        return false
            || t
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Geometry
                                #define DEF_s_Geometry
struct s_Geometry
{
    int g;
    explicit operator bool() const noexcept
    {
        return false
            || g
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LogicFrame
                                #define DEF_s_LogicFrame
struct s_LogicFrame
{
    s_Geometry DATA_fbx;
    s_Texture TEX_A;
    s_Texture TEX_AO;
    s_Texture TEX_M;
    s_Texture TEX_N;
    s_Texture TEX_R;
    s_Texture HDR;
    explicit operator bool() const noexcept
    {
        return false
            || DATA_fbx
            || TEX_A
            || TEX_AO
            || TEX_M
            || TEX_N
            || TEX_R
            || HDR
        ;
    }
};
                                #endif

                                #ifndef DEF_s_RenderFrame_in
                                #define DEF_s_RenderFrame_in
struct s_RenderFrame_in
{
    short w;
    short h;
    int frame;
    float mouseX;
    float mouseY;
    int mouseBtns;
    s_LogicFrame logic;
    s_RenderFrame lastRender;
    explicit operator bool() const noexcept
    {
        return false
            || w
            || h
            || frame
            || mouseX
            || mouseY
            || mouseBtns
            || logic
            || lastRender
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_RenderFrame APP_renderFrame_7QtSvwQx(const s_RenderFrame_in& args)
{
    return s_RenderFrame { args.logic.HDR.t };
}

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;
        fn main() "hello".leadingDigit.i32;

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static bool leadingDigit_xEpVqWPh(fu::view<char> name)
{
    return fu::u8((fu::u8(fu::u8(name[0])) - fu::u8(fu::u8('0')))) < fu::u8(10u);
}

int fu_MAIN()
{
    return int(leadingDigit_xEpVqWPh("hello"_fu));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() 1_000_000 - 1000000
               || 0xffff_ffff.i32 - 0xffffffff.i32
               || 123_456.789.i32 - 123456.789.i32;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int _0 {};
    return (_0 = (1000000 - 1000000)) ? _0 : (_0 = (int(0xffffffffu) - int(0xffffffffu))) ? _0 : (int(123456.789) - int(123456.789));
}

#endif

int main() { return fu_MAIN(); }

-----
                                  // litfix through && /////
        fn test(a: u32, shadows: bool)      (a << 1) | (shadows && 1);
        fn main()                           test(1, true).i32 - 3;

-----

#ifndef fu_NO_fdefs

static unsigned test_aS41lIFO(const unsigned a, const bool shadows)
{
    return (a << 1u) | (shadows ? 1u : 0u);
}

int fu_MAIN()
{
    return int(test_aS41lIFO(1u, true)) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;
        inline fn len(a: vec3) a.lensq.sqrt;

        inline fn norm(a: vec3) {
            mut n = 1 / a.len;
            n = n.finite ? n : 0;
            return a * n;
        }

-----

-----

        struct vec3 { x?: f32; y?: f32; z?: f32; };
        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;
        inline fn len(a: vec3) a.lensq.sqrt;

        inline fn norm(a: vec3) {
            mut n = 1 / a.len;
            n = n.finite ? n : 0;
            return a * n;
        }

        inline fn test(ref v) {
            v = v.norm();                                       // GNUStmtExpr
            return v.len;
        }

        fn main() {
            mut v = _0::vec3(2, 0, 0);
            return v.test() == 1 ? 0 : 1;
        }

-----
#include <cmath>

struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec3 v = s_vec3 { 2.0f, 0.0f, 0.0f };
    float BL_1_v {};
    if ((__extension__ (
    {
        s_vec3 BL_2_v {};
        v = (__extension__ (
        {
            const s_vec3& /*v*/ a = v;
            float n = (1.0f / std::sqrt((((a.x * a.x) + (a.y * a.y)) + (a.z * a.z))));
            n = (std::isfinite(n) ? n : 0.0f);
            const float /*n*/ b = n;
            BL_2_v = (s_vec3 { (a.x * b), (a.y * b), (a.z * b) });
        (void)0;}), static_cast<s_vec3&&>(BL_2_v));
        const s_vec3& /*v*/ a = v;
        BL_1_v = (std::sqrt((((a.x * a.x) + (a.y * a.y)) + (a.z * a.z))));
    (void)0;}), BL_1_v) == 1.0f)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn sub15(x: i32) x - 15;
        fn main() 0xf.sub15;

-----

#ifndef fu_NO_fdefs

static int sub15_1WsbUdat(const int x)
{
    return x - 15;
}

int fu_MAIN()
{
    return sub15_1WsbUdat(0xf);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn pick(albedo: i32 = 0x12345678, shift = 16)
            albedo >> shift & 0xf;
        fn main()
            pick() == 4 ? 0 : 1;

-----

#ifndef fu_NO_fdefs

static int pick_UtzfR6Dn(const int albedo, const int shift)
{
    return (albedo >> shift) & 0xf;
}

int fu_MAIN()
{
    if (pick_UtzfR6Dn(0x12345678, 16) == 4)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() abs(-19191) - 19191
                + abs(+72713) - 72713;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_abs_D7vDA3guA8l
                                #define DEF_abs_D7vDA3guA8l
inline int abs_D7vDA3gu(const int v)
{
    if (v < 0)
        return -v;
    else
        return v;

}
                                #endif

int fu_MAIN()
{
    return ((abs_D7vDA3gu(-19191) - 19191) + abs_D7vDA3gu(+72713)) - 72713;
}

#endif

int main() { return fu_MAIN(); }

-----

        type Test = i32[];
        fn yo(t: Test) t[0] + t[1];
        fn main() yo([-1, +1]);

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int yo_x171rEY7(fu::view<int> t)
{
    return t[0] + t[1];
}

int fu_MAIN()
{
    return yo_x171rEY7((fu::slate<2, int> { -1, +1 }));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn if_first(a: $T[]) a && a[0];
        fn hello(a: i32[]) a.if_first;
        fn main() hello([ 3 ]) - 3;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int if_first_zj1tLGtT(fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}

static int hello_zj1tLGtT(fu::view<int> a)
{
    return if_first_zj1tLGtT(a);
}

int fu_MAIN()
{
    return hello_zj1tLGtT((fu::slate<1, int> { 3 })) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn if_first(a: $T[]) a && a[0];
        type X = i32[];
        fn hello(a: X) a.if_first;
        fn main() hello([ 3 ]) - 3;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int if_first_zj1tLGtT(fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}

static int hello_zj1tLGtT(fu::view<int> a)
{
    return if_first_zj1tLGtT(a);
}

int fu_MAIN()
{
    return hello_zj1tLGtT((fu::slate<1, int> { 3 })) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn if_first(a: $T[]) a && a[0];

        fn list(): i32[][] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> list_H9fhQUVP()
{
    return fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<1, int> { 3 } } } };
}

inline static const fu::vec<int>& if_first_HyFbNXAV(fu::view<fu::vec<int>> a)
{
    if (a)
        return a[0];
    else
        return (*(const fu::vec<int>*)fu::NIL);

}

inline static int if_first_zj1tLGtT(fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}

static int hello_H9fhQUVP()
{
    return if_first_zj1tLGtT(if_first_HyFbNXAV(list_H9fhQUVP()));
}

int fu_MAIN()
{
    return hello_H9fhQUVP() - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn if_first(a: $T[]) a && a[0];
        type X = i32[];

        fn list(): X[] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static fu::vec<fu::vec<int>> list_H9fhQUVP()
{
    return fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<1, int> { 3 } } } };
}

inline static const fu::vec<int>& if_first_HyFbNXAV(fu::view<fu::vec<int>> a)
{
    if (a)
        return a[0];
    else
        return (*(const fu::vec<int>*)fu::NIL);

}

inline static int if_first_zj1tLGtT(fu::view<int> a)
{
    if (a)
        return a[0];
    else
        return 0;

}

static int hello_H9fhQUVP()
{
    return if_first_zj1tLGtT(if_first_HyFbNXAV(list_H9fhQUVP()));
}

int fu_MAIN()
{
    return hello_H9fhQUVP() - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        let arr = [1, 2];
        fn eq(a: i32[], b: i32[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<int> arr fu_INIT_PRIORITY(1001) = fu::vec<int> { fu::slate<2, int> { 1, 2 } };

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

static bool eq_VaCdQhcs(fu::view<int> a, fu::view<int> b)
{
    return a == b;
}

int fu_MAIN()
{
    if (eq_VaCdQhcs(arr, arr))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let arr = [1, 2];
        fn eq(a: $T[], b: $T[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<int> arr fu_INIT_PRIORITY(1001) = fu::vec<int> { fu::slate<2, int> { 1, 2 } };

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_fMp33mLs54j
                                #define DEF_x3Dx3D_fMp33mLs54j
inline bool operator==(fu::view<int> a, fu::view<int> b)
{
    return !x3Cx3E_fMp33mLs(a, b);
}
                                #endif

inline static bool eq_VaCdQhcs(fu::view<int> a, fu::view<int> b)
{
    return a == b;
}

int fu_MAIN()
{
    if (eq_VaCdQhcs(arr, arr))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            mut b = a[1: ];
            mut c = a[ :3];
            mut d = a[1:3];

            mut res = b ~ c ~ d;
            return res <> [ 2, 3, 4,  1, 2, 3,  2, 3 ];
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
    fu::view<int> /*a*/ b = fu::get_view(a, 1);
    fu::view<int> /*a*/ c = fu::get_view_start0(a, 3);
    fu::view<int> /*a*/ d = fu::get_view(a, 1, 3);
    fu::vec<int> res = ((b + c) + d);
    return x3Cx3E_fMp33mLs(res, (fu::slate<8, int> { 2, 3, 4, 1, 2, 3, 2, 3 }));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            let str = "hello world";
            let s10 = str[:5] ~ str[6:];
            return s10.len - 10;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::str str = "hello world"_fu;
    fu::str s10 = (fu::get_view_start0(str, 5) + fu::get_view(str, 6));
    return s10.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut strs = [ "hello", "world" ];
            let hello = strs[0];
            strs.insert(1,

                hello[0:5] /* should work too, but currently expected to mismatch */ 
            );
            return strs.len - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:24+1[0m:

[2m      |             mut strs = [ "hello", "world" ];[0m
[2m      |             let hello = strs[0];[0m
[2m    5 | [0m            strs.insert[31;1m([0m1,
[2m      | [0m
[2m      |                 hello[0:5] /* should work too, but currently expected to mismatch */ [0m

	Bad call to [34;1minsert[0m with args (string[] mutref copy resize, i32 copy AlwaysTrue, string): 

	[35;1mtemplate[0m [34;1m
.insert[0m at [2m../../../../../[0mprelude[2m 205:5+6[0m:
[2m  205 | [0mfn  [31;1minsert[0m !T(ref a: T[], i: int, mut b: T): void __native(".insert");

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: string copy resize Typename <- string Typename

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            mut strs = [ "hello", "world" ];
            let hello = strs[0];
            strs.insert(1,

                hello.slice(0, 5)
            );
            return strs.len - 3;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/vec/slice.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::str> strs = fu::vec<fu::str> { fu::slate<2, fu::str> { "hello"_fu, "world"_fu } };
    const fu::str& /*strs|static*/ hello = strs[0];
    strs.insert(1, fu::slice(hello, 0, 5));
    return strs.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main()
            test([-1, +1]);

        // EXPECT fu::slate<2, int> { -1, +1 }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_ZJhI7Zq9(fu::view<int> hey)
{
    return hey[0] + hey[1];
}

int fu_MAIN()
{
    return test_ZJhI7Zq9((fu::slate<2, int> { -1, +1 }));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [-1, +1];
            return hey.test();
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& test_T6WmdOSf(fu::view_mut<int> hey)
{
    return (hey.mutref(0) += hey[1]);
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> { fu::slate<2, int> { -1, +1 } };
    return test_T6WmdOSf(hey);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(i: i32) [ i, i + 1 ];
        fn main() test(0)[1] - 1;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static fu::vec<int> test_nD58vCLu(const int i)
{
    return fu::vec<int> { fu::slate<2, int> { i, (i + 1) } };
}

int fu_MAIN()
{
    return test_nD58vCLu(0)[1] - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(hey: byte[])
            hey.view(u32)[0];

        fn main() {
            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];
            return (hey.test - 0x1010101).i32;
        }

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static unsigned test_FIPMWF6p(fu::view<char> hey)
{
    return fu::view_of<unsigned>(hey)[0];
}

int fu_MAIN()
{
    fu::str hey = fu::str { fu::slate<4, char> { char(1), char(1), char(1), char(1) } };
    return int((test_FIPMWF6p(hey) - 0x1010101u));
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main() {
            let hey = [7, -1, +1];
            return test(hey[1 : 3]);
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int test_ZJhI7Zq9(fu::view<int> hey)
{
    return hey[0] + hey[1];
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> { fu::slate<3, int> { 7, -1, +1 } };
    return test_ZJhI7Zq9(fu::get_view(hey, 1, 3));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [7, -1, +1];
            return hey[1 : 3].test();
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& test_T6WmdOSf(fu::view_mut<int> hey)
{
    return (hey.mutref(0) += hey[1]);
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> { fu::slate<3, int> { 7, -1, +1 } };
    return test_T6WmdOSf(fu::get_view_mut(hey, 1, 3));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(hey: &mut [i32])
            hey.= [2, -3];

        fn main() {
            mut hey = [1, 0, 0];
            test(hey[1 : 3]);
            return hey[0] + hey[1] + hey[2];
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static void test_T6WmdOSf(fu::view_mut<int> hey)
{
    fu::view_assign(hey, (fu::slate<2, int> { 2, -3 }));
}

int fu_MAIN()
{
    fu::vec<int> hey = fu::vec<int> { fu::slate<3, int> { 1, 0, 0 } };
    test_T6WmdOSf(fu::get_view_mut(hey, 1, 3));
    return (hey[0] + hey[1]) + hey[2];
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Hey {
            i: i32;
        };

        fn test(out: &mut [Hey]) {
            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];
        }

        fn main() {
            mut a = [ Hey ];
            a.test();
            return a[0].i - 16843009;
        }

-----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>

struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_xvYzk6UG(fu::view_mut<s_Hey> out)
{
    fu::view_assign(fu::view_of_mut<fu::u8>(out), (fu::slate<4, fu::u8> { fu::u8(unsigned(1)), fu::u8(unsigned(1)), fu::u8(unsigned(1)), fu::u8(unsigned(1)) }));
}

int fu_MAIN()
{
    fu::vec<s_Hey> a = fu::vec<s_Hey> { fu::slate<1, s_Hey> { s_Hey{} } };
    test_xvYzk6UG(a);
    return a[0].i - 16843009;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

-----

        struct Hey {
            i: i32;
        };

        fn test(x: &mut [i32], y: [ Hey ])
            x .= y.view(i32);

        fn main() {
            mut a = [ 0 ];
            test(a, [ Hey(13) ]);
            return a[0] - 13;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>

struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void test_HFTA8cIW(fu::view_mut<int> x, fu::view<s_Hey> y)
{
    fu::view_assign(x, fu::view_of<int>(y));
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    test_HFTA8cIW(a, (fu::slate<1, s_Hey> { s_Hey { 13 } }));
    return a[0] - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

-----

        struct Hey {
            i: i32;
        };

        fn main() {
            mut a = [ 0 ];
            a .= [ Hey(13) ].view(i32);
            return a[0] - 13;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>

struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 0 } };
    fu::view_assign(a, fu::view_of<int>((fu::slate<1, s_Hey> { s_Hey { 13 } })));
    return a[0] - 13;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedCall

-----

        fn test(a: [byte], b?: [byte]) a == b;
        fn main() test("") ? 0 : 1;

        // EXPECT (""_fu, fu::view<char>{})

        // This is what we had before, it's better.
        // TODO (fu::view<char>{}, fu::view<char>{})

-----
;; TODO (fu::view<char>{}, fu::view<char>{})

#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool test_xagds2ks(fu::view<char> a, fu::view<char> b)
{
    return a == b;
}

int fu_MAIN()
{
    if (test_xagds2ks(""_fu, fu::view<char>{}))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        let NOTES = [ "AAA", "BBB", "CCC" ];
        fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
        fn main() what("!BBB") - 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::vec<fu::str> NOTES fu_INIT_PRIORITY(1001) = fu::vec<fu::str> { fu::slate<3, fu::str> { "AAA"_fu, "BBB"_fu, "CCC"_fu } };

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_find_g5ZsWtbdNfi
                                #define DEF_find_g5ZsWtbdNfi
inline int find_g5ZsWtbd(fu::view<fu::str> a, fu::view<char> b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

static int what_ENCuXRCz(const fu::str& annot)
{
    return find_g5ZsWtbd(NOTES, fu::slice(annot, 1, annot.size()));
}

int fu_MAIN()
{
    return what_ENCuXRCz("!BBB"_fu) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn Join(a: $T[][], lax sep = [])            // The sep is of type any-init.
        {                                           //
            if (a.len < 2)                          //
                return a.len && a[0];               // NOT SURE WHAT'S 100% IDEAL, BUT:
                                                    //
            let N = typeof(sep) -> [$T;] ? sep.len  // should either match here,
                  : typeof(sep) ->  $T   ? 1        //                                    but currently matches here, which is just wrong.
                                 : 0;               //                           or here,

            mut size = a[0].len;
            for (mut i = 1; i < a.len; i++)
                size += N + a[i].len;

            mut res: $T[];
            res.grow_junk(size);

            let head = a[0];
            size = head.len;
            res[0 : head.len] .= head;
            for (mut i = 1; i < a.len; i++)
            {
                let range = a[i];
                if (typeof(sep) -> [$T;])
                    res[size : size + N] .= sep;
                else if (typeof(sep) -> $T)
                    res[size] = sep;

                size += N;
                res[size : size + range.len] .= range;
                size += range.len;
            }

            return res;
        }

        fn main() {
            let res = Join([ "hello", "world" ], []); // the [] fails the case above
            return res == "helloworld" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

inline static fu::str Join_0QDcIfZm(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_mut(res, 0, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_0QDcIfZm((fu::slate<2, fu::str> { "hello"_fu, "world"_fu }));
    if (res == "helloworld"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        // one of these things reported there's no $S in scope.
        fn Join(a: $T, b: $T, lax sep: $S = [])
            case ($S -> $T || $S -> [$T;] || $S -> [])
        {
            return typeof(sep) -> $T || typeof(sep) -> [$T;]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

inline static fu::str Join_oHYRe7dd(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_oHYRe7dd("hello"_fu, "world"_fu);
    if (res == "helloworld"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        // This is the initial type union concept
        fn Join(a: $T, b: $T, lax sep?: $T or [$T;] or [])
        {
            return typeof(sep) -> $T || typeof(sep) -> [$T;]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

inline static fu::str Join_oHYRe7dd(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = Join_oHYRe7dd("hello"_fu, "world"_fu);
    if (res == "helloworld"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn Replace(str: $T[], all: $T or [$T;], with: $T or [$T;] or [])
            str.len + (typeof(all)  -> $T ? 1 : all.len)
                    + (typeof(with) -> [] ? 0 : typeof(with) -> $T ? 1 : with.len);

        fn main()
            "Hello".Replace(all: "ll", with: []) == 7 ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int Replace_sEpwuSMx(fu::view<char> str, fu::view<char> all)
{
    return (str.size() + all.size()) + 0;
}

int fu_MAIN()
{
    if (Replace_sEpwuSMx("Hello"_fu, "ll"_fu) == 7)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const s_Hey r = s_Hey { a };
    return r.i - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hey { i: i32; }

        fn main() {
            let a: Hey[] = [ [ -1 ], [ +1 ] ];
            return a[0].i + a[1].i;
        }

-----
#include <fu/vec.h>

struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<s_Hey> a = fu::vec<s_Hey> { fu::slate<2, s_Hey> { s_Hey { -1 }, s_Hey { +1 } } };
    return a[0].i + a[1].i;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hey { i: i32; }

        fn test(): Hey {
            return [ 0 ];
        }

        fn main() test.i;

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Hey test_H9fhQUVP()
{
    return s_Hey { 0 };
}

int fu_MAIN()
{
    return test_H9fhQUVP().i;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test {

            a: i32;  
            b: i32;
        };

        return Test(b: 1).a;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:20+1[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return Test[31;1m([0mb: 1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [34;1mTest[0m with args (i32 copy AlwaysTrue): 

	[35;1mtype[0m [34;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct Test {

            a?: i32; 
            b: i32;
        };

        return Test(b: 1).a;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_Test { 0, {} }.a;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test {
            b: i32;

            a: i32;  
        };

        return Test(1).a;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 11:20+1[0m:

[2m      |         };[0m
[2m      | [0m
[2m   11 | [0m        return Test[31;1m([0m1).a;
[2m      | [0m
[2m      | }[0m

	Bad call to [34;1mTest[0m with args (i32 copy AlwaysTrue): 

	[35;1mtype[0m [34;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test {

	    Wrong number of arguments: expects 2, got 1.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct Test {
            b: i32;

            a?: i32; 
        };

        return Test(1).a;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int b;
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || b
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_Test { {}, 0 }.a;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node {
            items?: Node[];
            stuff?: Node[];
        };

        fn rec_copy(ref a: Node) {
            // If implemented naively,
            //  by the time you copy stuff it's no longer there.
            a = a.items[0];
        }

        fn main() {
            mut a = Node(items: [ Node(stuff: [ Node ]) ]);
            rec_copy(a);
            return a.stuff.len - 1;
        }

-----
#include <fu/vec.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    fu::vec<s_Node> stuff;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
            || stuff
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static void rec_copy_zLvPlqS0(s_Node& a)
{
    a = a.items[0];
}

int fu_MAIN()
{
    s_Node a = s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node { fu::vec<s_Node>{}, fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } } } }, fu::vec<s_Node>{} };
    rec_copy_zLvPlqS0(a);
    return a.stuff.size() - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(a: i32, b!: i32 = 1) a + b;
        return test(-1);

-----

#ifndef fu_NO_fdefs

static int test_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_qoaTQFTa(-1, 1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(hey!: i32) hey * 2;

        fn main() = (0).test;       

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:25+4[0m:

[2m      |         fn test(hey!: i32) hey * 2;[0m
[2m      | [0m
[2m    4 | [0m        fn main() = (0).[31;1mtest[0m;       
[2m      | [0m

	Bad call to [34;1mtest[0m with args (i32 copy AlwaysFalse): 

	[35;1mfn[0m [34;1mtest[0m at [2m2:12+4[0m:
[2m    2 | [0m        fn [31;1mtest[0m(hey!: i32) hey * 2;

	    [35;1marg[0m [34;1mtest[0m:[34;1mhey[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        fn test(hey!: i32) hey * 2;

        fn main() = test(hey: 0);   

-----

#ifndef fu_NO_fdefs

static int test_UvoBgY4t(const int hey)
{
    return hey * 2;
}

int fu_MAIN()
{
    return test_UvoBgY4t(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a: i32, b!: i32 = 1) a + b;

        return test(-2, +2);    

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:20+1[0m:

[2m      |         fn test(a: i32, b!: i32 = 1) a + b;[0m
[2m      | [0m
[2m    7 | [0m        return test[31;1m([0m-2, +2);    
[2m      | [0m
[2m      | }[0m

	Bad call to [34;1mtest[0m with args (i32 copy AlwaysTrue, i32 copy AlwaysTrue): 

	[35;1mfn[0m [34;1mtest[0m at [2m5:12+4[0m:
[2m    5 | [0m        fn [31;1mtest[0m(a: i32, b!: i32 = 1) a + b;

	    [35;1marg[0m [34;1mtest[0m:[34;1mb[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        fn test(a: i32, b!: i32 = 1) a + b;

        return test(-2, b: +2); 

-----

#ifndef fu_NO_fdefs

static int test_qoaTQFTa(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return test_qoaTQFTa(-2, +2);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:20+1[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return Test[31;1m([0m-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [34;1mTest[0m with args (i32 copy AlwaysTrue, i32 copy AlwaysTrue): 

	[35;1mtype[0m [34;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a: i32; b!: i32; };

	    [35;1marg[0m [34;1mb[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, b: +2).test; 

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_rhrdPfxs(const s_Test& t)
{
    return t.a + t.b;
}

int fu_MAIN()
{
    return test_rhrdPfxs(s_Test { -2, +2 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(-2, +2).test;    

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:20+1[0m:

[2m      |         fn test(t: Test) t.a + t.b;[0m
[2m      | [0m
[2m    8 | [0m        return Test[31;1m([0m-2, +2).test;    
[2m      | [0m
[2m      | }[0m

	Bad call to [34;1mTest[0m with args (i32 copy AlwaysTrue, i32 copy AlwaysTrue): 

	[35;1mtype[0m [34;1mTest[0m at [2m5:9+6[0m:
[2m    5 | [0m        [31;1mstruct[0m Test { a?: i32; b!?: i32; };

	    [35;1marg[0m [34;1mb[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:4+4[0m

-----

        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;

        return Test(b: +2).test - 2; 

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_rhrdPfxs(const s_Test& t)
{
    return t.a + t.b;
}

int fu_MAIN()
{
    return test_rhrdPfxs(s_Test { 0, +2 }) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        let _precedence = 0;
        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;
        fn main() parseExpression();

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF__precedence
                                #define DEF__precedence
inline constexpr int _precedence = 0;
                                #endif

static int parseExpression_P4YzOdsG(const int p1, const int mode)
{
    return p1 + mode;
}

int fu_MAIN()
{
    return parseExpression_P4YzOdsG(_precedence, 0);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn what(a = -1, b!: i32) a + b; // Trailing explicit args.
        fn main() what(b: +1);

-----

#ifndef fu_NO_fdefs

static int what_ah7Sm1pL(const int b, const int a)
{
    return a + b;
}

int fu_MAIN()
{
    return what_ah7Sm1pL(+1, -1);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn greet(with!greeting: string)     greeting.len;
        fn main()                           greet(with: "Hello!") - 6;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int greet_lfox3jLo(fu::view<char> greeting)
{
    return greeting.size();
}

int fu_MAIN()
{
    return greet_lfox3jLo("Hello!"_fu) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Each(arr: $T[], visit)
            for (mut i = 0; i < arr.len; i++)
                visit(arr[i], i?: i);

        fn main() {
            mut muls = 0;
            mut arr = [ 1, 2, 3 ];

            arr.Each: |v, i!index|
                muls += v * index; // complained no index in scope

            return muls - 8;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_2ZAHJjHN(const int v, const int index, int& muls)
{
    return (muls += (v * index));
}

inline static void Each_vKBkIETC(fu::view<int> arr, int& muls)
{
    for (int i = 0; i < arr.size(); i++)
        l_1_0_2ZAHJjHN(arr[i], i, muls);

}

int fu_MAIN()
{
    int muls = 0;
    fu::vec<int> arr = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    Each_vKBkIETC(arr, muls);
    return muls - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        struct Lifetime { using regions: i32[] };
        fn isInvalidatedBy(write: i32[]) write.len * write[0];

        // This blew up with a TODO: bck_node(non-empty argid).
        fn main() isInvalidatedBy(write: Lifetime([ 3, 5 ])) - 6;

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int isInvalidatedBy_CQ3tPzg5(fu::view<int> write)
{
    return write.size() * write[0];
}

int fu_MAIN()
{
    return isInvalidatedBy_CQ3tPzg5(s_Lifetime { fu::vec<int> { fu::slate<2, int> { 3, 5 } } }.regions) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Node { a: i32; b: i32; c: i32; d: i32 };

        fn make(a: i32, b?: i32, c?: i32)
            Node(a, :b, :c, d: 10);

        fn make(a: i32, b?: i32, c?: i32, d!: i32)
            Node(a, :b, :c, :d);

        fn res(using n: Node)
            return a + 10 * b + 100 * c + 1000 * d;

        fn main()
            make(4, 5).res      == 10054 &&
            make(3, b: 4).res   == 10043 &&
            make(2, c: 3).res   == 10302 &&
            make(1, d: 2).res   == 2001 ? 0 : 1;

-----
struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    int a;
    int b;
    int c;
    int d;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
            || d
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Node make_S3uH54Qk(const int a, const int b, const int c)
{
    return s_Node { a, b, c, 10 };
}

static int res_UOKmiuTs(const s_Node& n)
{
    return ((n.a + (10 * n.b)) + (100 * n.c)) + (1000 * n.d);
}

static s_Node make_OLFelY6d(const int a, const int d, const int b, const int c)
{
    return s_Node { a, b, c, d };
}

int fu_MAIN()
{
    if ((res_UOKmiuTs(make_S3uH54Qk(4, 5, 0)) == 10054) && (res_UOKmiuTs(make_S3uH54Qk(3, 4, 0)) == 10043) && (res_UOKmiuTs(make_S3uH54Qk(2, 0, 3)) == 10302) && (res_UOKmiuTs(make_OLFelY6d(1, 2, 0, 0)) == 2001))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, 
                              c       
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 10:23+1[0m:

[2m      |                 + a2o1(a?: 1, b?: 2) *    100   //    300[0m
[2m      |                 + a2o2(a?: 1, b?: 2) *   1000   //   3000[0m
[2m   10 | [0m                + a2o1[31;1m([0ma : 1, 
[2m      |                               c       [0m
[2m      |                                ?: 2) *  10000   //  30000[0m

	Bad call to [34;1ma2o1[0m with args (i32 copy AlwaysTrue, i32 copy AlwaysTrue): 

	[35;1mfn[0m [34;1ma2o1[0m at [2m4:12+4[0m:
[2m    4 | [0m        fn [31;1ma2o1[0m(a : i32, b?: i32) a + b;

	    Optional argument ambiguity, not all optional arguments provided, and not all callsite arguments used. Cannot distinguish from a typo. [TODO LIST MISSING ARGS]

        Solving [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, 
                              b       
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;

-----

#ifndef fu_NO_fdefs

static int a0o0_H9fhQUVP()
{
    return 0;
}

static int a1o0_rgx2eiBu(const int a)
{
    return a;
}

static int a2o1_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

static int a2o2_hwGp0ETu(const int a, const int b)
{
    return a + b;
}

int fu_MAIN()
{
    return ((((((a0o0_H9fhQUVP() * 1) + (a1o0_rgx2eiBu(1) * 10)) + (a2o1_hwGp0ETu(1, 2) * 100)) + (a2o2_hwGp0ETu(1, 2) * 1000)) + (a2o1_hwGp0ETu(1, 2) * 10000)) + (a2o1_hwGp0ETu(1, 0) * 100000)) - 133310;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn reveach(items: [$T], fn)
            for (mut i = items.len; i --> 0; )
                fn(items[i], i?: i);

        pub fn main() {
            mut sum = 0;
            [1, 2, 3].reveach(|x   | sum += x          );
            [1, 2, 3].reveach(|x, i| sum += x * i * 100);
            return sum - 806;
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_sRfGrrW8(const int x, int& sum)
{
    return (sum += x);
}

                                #ifndef DEF_reveach_13QH1MgCvC4
                                #define DEF_reveach_13QH1MgCvC4
inline void reveach_13QH1MgC(fu::view<int> items, int& sum)
{
    for (int i = items.size(); i-- > 0; )
        l_1_0_sRfGrrW8(items[i], sum);

}
                                #endif

inline static int& l_1_1_D5AuCEaP(const int x, const int i, int& sum)
{
    return (sum += ((x * i) * 100));
}

                                #ifndef DEF_reveach_PGSnSWjTlN8
                                #define DEF_reveach_PGSnSWjTlN8
inline void reveach_PGSnSWjT(fu::view<int> items, int& sum)
{
    for (int i = items.size(); i-- > 0; )
        l_1_1_D5AuCEaP(items[i], i, sum);

}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    reveach_13QH1MgC((fu::slate<3, int> { 1, 2, 3 }), sum);
    reveach_PGSnSWjT((fu::slate<3, int> { 1, 2, 3 }), sum);
    return sum - 806;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub lax fn noop() 0;
        pub fn woot(ref i: i32, fn) i += fn(i?: i += 1); // Will not add 1.

        fn main() {
            mut sum = 0;
            woot(sum, fn noop);
            return sum;
        }

-----

#ifndef fu_NO_fdefs

int noop_H9fhQUVP()
{
    return 0;
}

                                #ifndef DEF_woot_v3xFj1GoNM6
                                #define DEF_woot_v3xFj1GoNM6
inline int& woot_v3xFj1Go(int& i)
{
    return (i += noop_H9fhQUVP());
}
                                #endif

int fu_MAIN()
{
    int sum = 0;
    woot_v3xFj1Go(sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn takesFns(x, f)
            f(x * 2, optAndUnused?: x * 3);

        fn hasUnusedOptArg(x: int, alt = 7, lax optAndUnused?: int)
            x + alt;

        fn main()
            takesFns(2, fn hasUnusedOptArg) - 11;

-----

#ifndef fu_NO_fdefs

static int hasUnusedOptArg_egSUp0wC(const int x, const int alt)
{
    return x + alt;
}

inline static int takesFns_l8p22zED(const int x)
{
    return hasUnusedOptArg_egSUp0wC((x * 2), 7);
}

int fu_MAIN()
{
    return takesFns_l8p22zED(2) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn main() {
            let ret: i8 = 
                128 ;

            return (ret - 100).i32 - 27;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i8 = 
[2m      |                 128 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i8 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i8 = 
                127 ;

            return (ret - 100).i32 - 27;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 ret = fu::i8(127);
    return int(fu::i8((ret - fu::i8(100)))) - 27;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: i16 = 
                32768 ;

            return (ret - 32700).i32 - 67;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i16 = 
[2m      |                 32768 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i16 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i16 = 
                32767 ;

            return (ret - 32700).i32 - 67;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const short ret = short(32767);
    return int(short((ret - short(32700)))) - 67;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: i32 = 
                2147483648 ;

            return (ret - 2147483600).i32 - 47;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i32 = 
[2m      |                 2147483648 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i32 copy <- i64 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i32 = 
                2147483647 ;

            return (ret - 2147483600).i32 - 47;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ret = 2147483647;
    return int((ret - 2147483600)) - 47;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() { // weird error, see the other two below
            let ret: i64 = 
                9223372036854775808 ;

            return (ret - 9223372036854775800).i32 - 7;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:17+19[0m:

[2m      |         fn main() { // weird error, see the other two below[0m
[2m      |             let ret: i64 = [0m
[2m    4 | [0m                [31;1m9223372036854775808[0m ;
[2m      | [0m
[2m      |             return (ret - 9223372036854775800).i32 - 7;[0m

	Bad int literal.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() { // weird error, see the other two below
            let ret: i64 = 
                9223372036854775807 ;

            return (ret - 9223372036854775800).i32 - 7;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int64_t ret = 9223372036854775807ll;
    return int((ret - 9223372036854775800ll)) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: i8 = 
                -129 ;

            return (ret + 100).i32 + 28;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i8 = 
[2m      |                 -129 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i8 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i8 = 
                -128 ;

            return (ret + 100).i32 + 28;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 ret = fu::i8(-128);
    return int(fu::i8((ret + fu::i8(100)))) + 28;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: i16 = 
                -32769 ;

            return (ret + 32700).i32 + 68;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i16 = 
[2m      |                 -32769 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i16 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i16 = 
                -32768 ;

            return (ret + 32700).i32 + 68;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const short ret = short(-32768);
    return int(short((ret + short(32700)))) + 68;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: i32 = 
                -2147483649 ;

            return (ret + 2147483600).i32 + 48;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: i32 = 
[2m      |                 -2147483649 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: i32 copy <- i64 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: i32 = 
                -2147483648 ;

            return (ret + 2147483600).i32 + 48;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int ret = -2147483648;
    return int((ret + 2147483600)) + 48;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() { // wording different from the ones above and below
            let ret: i64 = 
                -9223372036854775809 ;

            return (ret + 9223372036854775800).i32 + 8;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:18+19[0m:

[2m      |         fn main() { // wording different from the ones above and below[0m
[2m      |             let ret: i64 = [0m
[2m    4 | [0m                -[31;1m9223372036854775809[0m ;
[2m      | [0m
[2m      |             return (ret + 9223372036854775800).i32 + 8;[0m

	Oversized signed int literal.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() { // wording different from the ones above and below
            let ret: i64 = 
                -9223372036854775808 ;

            return (ret + 9223372036854775800).i32 + 8;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int64_t ret = (-9223372036854775807-1);
    return int((ret + 9223372036854775800ll)) + 8;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: u8 = 
                256 ;

            return (ret - 0xff).i32;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u8 = 
[2m      |                 256 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: u8 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: u8 = 
                255 ;

            return (ret - 0xff).i32;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::u8 ret = fu::u8(255u);
    return int(unsigned(fu::u8((ret - fu::u8(0xffu)))));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: u16 = 
                65536 ;

            return (ret - 0xffff).i32;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u16 = 
[2m      |                 65536 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: u16 copy <- i32 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: u16 = 
                65535 ;

            return (ret - 0xffff).i32;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint16_t ret = uint16_t(65535u);
    return int(unsigned(uint16_t((ret - uint16_t(0xffffu)))));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let ret: u32 = 
                4294967296 ;

            return (ret - 0xffffffff).i32;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 3:17+3[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    3 | [0m            let [31;1mret[0m: u32 = 
[2m      |                 4294967296 ;[0m
[2m      | [0m

	Type annotation does not match init expression [34;1mret[0m: u32 copy <- i64 copy AlwaysTrue

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let ret: u32 = 
                4294967295 ;

            return (ret - 0xffffffff).i32;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned ret = 4294967295u;
    return int((ret - 0xffffffffu));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() { // this is the best of the weird ones
            let ret: u64 = 
                18446744073709551616 ;

            return (ret - 0xffffffffffffffff).i32;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:17+20[0m:

[2m      |         fn main() { // this is the best of the weird ones[0m
[2m      |             let ret: u64 = [0m
[2m    4 | [0m                [31;1m18446744073709551616[0m ;
[2m      | [0m
[2m      |             return (ret - 0xffffffffffffffff).i32;[0m

	Integer literal overflows a u64.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() { // this is the best of the weird ones
            let ret: u64 = 
                18446744073709551615 ;

            return (ret - 0xffffffffffffffff).i32;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint64_t ret = 18446744073709551615ull;
    return int(unsigned((ret - 0xffffffffffffffffull)));
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn set_once(ref entry, bit: i32): bool
        {
            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'
            if (entry & mask)           //  which doesnt work for some reason
                return false;

            entry |= mask;
            return true;
        }

        fn main() {
            mut entry: u64;
            let a = set_once(entry, 32);
            let b = set_once(entry, 32);
            return a && !b ? 0 : 101;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

                                #ifndef DEF_set_once_AdC5nJPoof2
                                #define DEF_set_once_AdC5nJPoof2
inline bool set_once_AdC5nJPo(uint64_t& entry, const int bit)
{
    const uint64_t mask = (1ull << uint64_t(unsigned(bit)));
    if (entry & mask)
        return false;
    else
    {
        entry |= mask;
        return true;
    };
}
                                #endif

int fu_MAIN()
{
    uint64_t entry {};
    const bool a = set_once_AdC5nJPo(entry, 32);
    const bool b = set_once_AdC5nJPo(entry, 32);
    if (a && !b)
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let hey: u128 = 0x8000000000000000.u128;
            let res = hey + hey;
            return res > hey ? 0 : 1;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const __uint128_t hey = __uint128_t(0x8000000000000000ull);
    const __uint128_t res = (hey + hey);
    if (res > hey)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = byte(128);
            return v.i32 == 128 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const char v = char(128);
    if (int(fu::u8(v)) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = u8(128);
            return v.i32 == 128 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::u8 v = fu::u8(unsigned(128));
    if (int(unsigned(v)) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = u32(128);
            return byte(v) == byte(128) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(128);
    if (char(v) == char(128))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = i32(128);
            return byte(v) == byte(128) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(128);
    if (char(v) == char(128))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = u32(2147483648);
            return byte(v) == byte(0) ? 0 : 1;
        }

-----
#include <cstdint>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(uint64_t(2147483648ll));
    if (char(v) == char(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = i32(2147483648);
            return byte(v) == byte(0) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(2147483648ll);
    if (char(v) == char(0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = u32(-1);
            return byte(v) == byte(255) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const unsigned v = unsigned(-1);
    if (char(v) == char(255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let v = i32(-1);
            return byte(v) == byte(255) ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int v = int(-1);
    if (char(v) == char(255))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            return i32(byte(i32(128))) == 128 ? 0 : 1;
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (int(fu::u8(char(int(128)))) == 128)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;


        fn test(f) {
            let a = 1; // none of these should need 'lax',
            let b = 2; //  they're all SS_MATCHED below,
            let c = 3; //   and their use is explicitly discard-ok.
            return f(?:a, ?:b, ?:c);
        }

        fn main() test(fn hello) - 210;

-----

#ifndef fu_NO_fdefs

static int hello_hwGp0ETu(const int a, const int b)
{
    return (10 * a) + (100 * b);
}

inline static int test_mUh65Nrp()
{
    const int a = 1;
    const int b = 2;
    return hello_hwGp0ETu(a, b);
}

int fu_MAIN()
{
    return test_mUh65Nrp() - 210;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;


        inline                                                  // GNUStmtExpr

        fn test(f) {
            let a = 1; // none of these should need 'lax',
            let b = 2; //  they're all SS_MATCHED below,
            let c = 3; //   and their use is explicitly discard-ok.
            return f(?:a, ?:b, ?:c);
        }

        fn main() test(fn hello) - 210;

-----

#ifndef fu_NO_fdefs

static int hello_hwGp0ETu(const int a, const int b)
{
    return (10 * a) + (100 * b);
}

int fu_MAIN()
{
    int BL_1_v {};
    return (__extension__ (
    {
        const int a = 1;
        const int b = 2;
        BL_1_v = (hello_hwGp0ETu(a, b));
    (void)0;}), BL_1_v) - 210;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        pub lax fn noop() {} // AUTOPUB

        fn hello() 3;

        import _0;
        fn main() 6 - hello * 2;

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 3:23+5[0m:

[2m      | [0m
[2m      |         import _0;[0m
[2m    3 | [0m        fn main() 6 - [31;1mhello[0m * 2;
[2m      | [0m

	Bad call to [34;1mhello[0m: [34;1mhello[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        pub lax fn noop() {} // AUTOPUB

        pub

        fn hello() 3;

-----

#ifndef fu_NO_fdefs

void noop_H9fhQUVP()
{
}

int hello_H9fhQUVP()
{
    return 3;
}

#endif

-----

        pub lax fn noop() {} // AUTOPUB

        pub

        fn hello() 3;

        import _0;
        fn main() 6 - hello * 2;

-----
int hello_H9fhQUVP();

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 6 - (hello_H9fhQUVP() * 2);
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Hey { i: i32; };

-----

-----

        pub struct Hey { i: i32; };

        fn main() 1._0::Hey.i - 1;

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return s_Hey { 1 }.i - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Hey { i: i32; };

-----

-----

        pub struct Hey { i: i32; };

        import _0;
        pub inline fn test(h: Hey) h.i + 2;

-----

-----

        pub struct Hey { i: i32; };

        import _0;
        pub inline fn test(h: Hey) h.i + 2;

        import _1;
        fn main() 1._0::Hey.test - 3;                           // GNUStmtExpr

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    return (__extension__ (
    {
        const s_Hey h = s_Hey { 1 };
        BL_1_v = ((h.i + 2));
    (void)0;}), BL_1_v) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Hey { i: i32; };

-----

-----

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

-----

-----

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

        import _1;
        fn main() 1._0::Hey.test - 3;                           // GNUStmtExpr

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    return (__extension__ (
    {
        const s_Hey h = s_Hey { 1 };
        BL_1_v = ((h.i + 2));
    (void)0;}), BL_1_v) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Hey { i: i32; };

-----

-----

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

-----

-----

        pub struct Hey { i: i32; };

        pub inline fn test(h: _0::Hey) h.i + 2;

        fn main() 1._0::Hey._1::test - 3;                       // GNUStmtExpr

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    return (__extension__ (
    {
        const s_Hey h = s_Hey { 1 };
        BL_1_v = ((h.i + 2));
    (void)0;}), BL_1_v) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct You { i: i32; };

-----

-----

        pub struct You { i: i32; };

        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];

-----
struct s_Hey;
struct s_You;

                                #ifndef DEF_s_You
                                #define DEF_s_You
struct s_You
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    s_You you;
    explicit operator bool() const noexcept
    {
        return false
            || you
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Hey init3_t0IXs7Dh()
{
    return s_Hey { s_You { 3 } };
}

#endif

-----

        pub struct You { i: i32; };

        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];

        pub inline fn test(using h = _1::init3) i + 7;

-----

-----

        pub struct You { i: i32; };

        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];

        pub inline fn test(using h = _1::init3) i + 7;

        fn main() _2::test - 10;                                // GNUStmtExpr

-----
struct s_Hey;
struct s_You;
s_Hey init3_t0IXs7Dh();

                                #ifndef DEF_s_You
                                #define DEF_s_You
struct s_You
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    s_You you;
    explicit operator bool() const noexcept
    {
        return false
            || you
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    return (__extension__ (
    {
        const s_Hey h = init3_t0IXs7Dh();
        BL_1_v = ((h.you.i + 7));
    (void)0;}), BL_1_v) - 10;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };

-----

-----

        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };

        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

-----

-----

        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };

        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;

-----
struct s_mat4;

                                #ifndef DEF_s_mat4
                                #define DEF_s_mat4
struct s_mat4
{
    float m0;
    float m1;
    float m2;
    float m3;
    float m4;
    float m5;
    float m6;
    float m7;
    float m8;
    float m9;
    float mA;
    float mB;
    float mC;
    float mD;
    float mE;
    float mF;
    explicit operator bool() const noexcept
    {
        return false
            || m0
            || m1
            || m2
            || m3
            || m4
            || m5
            || m6
            || m7
            || m8
            || m9
            || mA
            || mB
            || mC
            || mD
            || mE
            || mF
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float determinant_BFcPOysL(const s_mat4& _)
{
    return (((((((((((((((((((((((((+_.mC * _.m9) * _.m6) * _.m3) - (((_.m8 * _.mD) * _.m6) * _.m3)) - (((_.mC * _.m5) * _.mA) * _.m3)) + (((_.m4 * _.mD) * _.mA) * _.m3)) + (((_.m8 * _.m5) * _.mE) * _.m3)) - (((_.m4 * _.m9) * _.mE) * _.m3)) - (((_.mC * _.m9) * _.m2) * _.m7)) + (((_.m8 * _.mD) * _.m2) * _.m7)) + (((_.mC * _.m1) * _.mA) * _.m7)) - (((_.m0 * _.mD) * _.mA) * _.m7)) - (((_.m8 * _.m1) * _.mE) * _.m7)) + (((_.m0 * _.m9) * _.mE) * _.m7)) + (((_.mC * _.m5) * _.m2) * _.mB)) - (((_.m4 * _.mD) * _.m2) * _.mB)) - (((_.mC * _.m1) * _.m6) * _.mB)) + (((_.m0 * _.mD) * _.m6) * _.mB)) + (((_.m4 * _.m1) * _.mE) * _.mB)) - (((_.m0 * _.m5) * _.mE) * _.mB)) - (((_.m8 * _.m5) * _.m2) * _.mF)) + (((_.m4 * _.m9) * _.m2) * _.mF)) + (((_.m8 * _.m1) * _.m6) * _.mF)) - (((_.m0 * _.m9) * _.m6) * _.mF)) - (((_.m4 * _.m1) * _.mA) * _.mF)) + (((_.m0 * _.m5) * _.mA) * _.mF);
}

#endif

-----

        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };

        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;

        pub fn main()
        {
            let m34 = _1::mat34_identity;
            let m44 = _2::mat4(m34);

            return m44.determinant.i32 - 1;
        }

-----
struct s_mat34;
struct s_vec3;
struct s_mat4;
float determinant_BFcPOysL(const s_mat4&);

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    float x;
    float y;
    float z;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
            || z
        ;
    }
};
                                #endif

                                #ifndef DEF_s_mat34
                                #define DEF_s_mat34
struct s_mat34
{
    s_vec3 mx;
    s_vec3 my;
    s_vec3 mz;
    s_vec3 mo;
    explicit operator bool() const noexcept
    {
        return false
            || mx
            || my
            || mz
            || mo
        ;
    }
};
                                #endif

                                #ifndef DEF_s_mat4
                                #define DEF_s_mat4
struct s_mat4
{
    float m0;
    float m1;
    float m2;
    float m3;
    float m4;
    float m5;
    float m6;
    float m7;
    float m8;
    float m9;
    float mA;
    float mB;
    float mC;
    float mD;
    float mE;
    float mF;
    explicit operator bool() const noexcept
    {
        return false
            || m0
            || m1
            || m2
            || m3
            || m4
            || m5
            || m6
            || m7
            || m8
            || m9
            || mA
            || mB
            || mC
            || mD
            || mE
            || mF
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_mat34 m34 = s_mat34 { s_vec3 { 1.0f, 0.0f, 0.0f }, s_vec3 { 0.0f, 1.0f, 0.0f }, s_vec3 { 0.0f, 0.0f, 1.0f }, s_vec3{} };
    const s_mat4 m44 = s_mat4 { m34.mx.x, m34.mx.y, m34.mx.z, 0.0f, m34.my.x, m34.my.y, m34.my.z, 0.0f, m34.mz.x, m34.mz.y, m34.mz.z, 0.0f, m34.mo.x, m34.mo.y, m34.mo.z, 1.0f };
    return int(determinant_BFcPOysL(m44)) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;

-----
struct s__0;

                                #ifndef DEF_s__0
                                #define DEF_s__0
struct s__0
{
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float maxc_JZnAmTRW(const s__0& vec)
{
    if (vec.x > vec.y)
        return vec.x;
    else
        return vec.y;

}

#endif

-----

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;


        fn main() ::_0.maxc.i32;


-----
struct s__0;
float maxc_JZnAmTRW(const s__0&);

                                #ifndef DEF_s__0
                                #define DEF_s__0
struct s__0
{
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(maxc_JZnAmTRW(s__0{}));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;

-----
struct s__0;

                                #ifndef DEF_s__0
                                #define DEF_s__0
struct s__0
{
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

float maxc_JZnAmTRW(const s__0& vec)
{
    if (vec.x > vec.y)
        return vec.x;
    else
        return vec.y;

}

#endif

-----

        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;


        import _0;
        fn main() _0.maxc.i32;


-----
struct s__0;
float maxc_JZnAmTRW(const s__0&);

                                #ifndef DEF_s__0
                                #define DEF_s__0
struct s__0
{
    float x;
    float y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(maxc_JZnAmTRW(s__0{}));
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn _0(i: i32) i + 1;

-----

#ifndef fu_NO_fdefs

int _0_nD58vCLu(const int i)
{
    return i + 1;
}

#endif

-----

        pub fn _0(i: i32) i + 1;

        fn main() (-1).::_0;

-----
int _0_nD58vCLu(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return _0_nD58vCLu(-1);
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn add(ref to: $T[], item: $T) {
            for (mut i = 0; i < to.len; i++) {
                if (to[i] >= item) {
                    if (to[i] != item)
                        to.insert(i, item);

                    return;
                }
            }

            to.push(item);
        }

-----

-----

        pub fn add(ref to: $T[], item: $T) {
            for (mut i = 0; i < to.len; i++) {
                if (to[i] >= item) {
                    if (to[i] != item)
                        to.insert(i, item);

                    return;
                }
            }

            to.push(item);
        }

        fn main() {
            mut x = [1, 2, 3];
            x._0::add(3); if (x.len != 3) return 33;
            x._0::add(4); return x.len - x[3];
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_add_GaSmDVGKc8d
                                #define DEF_add_GaSmDVGKc8d
inline void add_GaSmDVGK(fu::vec<int>& to, const int item)
{
    for (int i = 0; i < to.size(); i++)
    {
        if ((to[i] >= item))
        {
            if (to[i] != item)
                to.insert(i, item);

            return;
        };
    };
    to.push(item);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> x = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    add_GaSmDVGK(x, 3);
    if (x.size() != 3)
        return 33;
    else
    {
        add_GaSmDVGK(x, 4);
        return x.size() - x[3];
    };
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_pad0
                                #define DEF_pad0
inline constexpr int pad0 = 0;
                                #endif

                                #ifndef DEF_pad1
                                #define DEF_pad1
inline constexpr int pad1 = 1;
                                #endif

                                #ifndef DEF_pad2
                                #define DEF_pad2
inline constexpr int pad2 = 2;
                                #endif

                                #ifndef DEF_pad3
                                #define DEF_pad3
inline constexpr int pad3 = 3;
                                #endif

                                #ifndef DEF_pad4
                                #define DEF_pad4
inline constexpr int pad4 = 4;
                                #endif

                                #ifndef DEF_pad5
                                #define DEF_pad5
inline constexpr int pad5 = 5;
                                #endif

                                #ifndef DEF_pad6
                                #define DEF_pad6
inline constexpr int pad6 = 6;
                                #endif

                                #ifndef DEF_pad7
                                #define DEF_pad7
inline constexpr int pad7 = 7;
                                #endif

                                #ifndef DEF_pad8
                                #define DEF_pad8
inline constexpr int pad8 = 8;
                                #endif

                                #ifndef DEF_pad9
                                #define DEF_pad9
inline constexpr int pad9 = 9;
                                #endif

                                #ifndef DEF_PAD0
                                #define DEF_PAD0
inline constexpr int PAD0 = 0;
                                #endif

                                #ifndef DEF_PAD1
                                #define DEF_PAD1
inline constexpr int PAD1 = 1;
                                #endif

                                #ifndef DEF_PAD2
                                #define DEF_PAD2
inline constexpr int PAD2 = 2;
                                #endif

                                #ifndef DEF_PAD3
                                #define DEF_PAD3
inline constexpr int PAD3 = 3;
                                #endif

                                #ifndef DEF_PAD4
                                #define DEF_PAD4
inline constexpr int PAD4 = 4;
                                #endif

                                #ifndef DEF_PAD5
                                #define DEF_PAD5
inline constexpr int PAD5 = 5;
                                #endif

                                #ifndef DEF_PAD6
                                #define DEF_PAD6
inline constexpr int PAD6 = 6;
                                #endif

                                #ifndef DEF_PAD7
                                #define DEF_PAD7
inline constexpr int PAD7 = 7;
                                #endif

                                #ifndef DEF_PAD8
                                #define DEF_PAD8
inline constexpr int PAD8 = 8;
                                #endif

                                #ifndef DEF_PAD9
                                #define DEF_PAD9
inline constexpr int PAD9 = 9;
                                #endif

                                #ifndef DEF_A
                                #define DEF_A
extern const fu::str A fu_INIT_PRIORITY(1001) = "hello"_fu;
                                #endif

                                #ifndef DEF_B
                                #define DEF_B
extern const fu::str B fu_INIT_PRIORITY(1001) = "world"_fu;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";

        import _0;
        fn test(i: i32) {
            let v = i & 1 ? A : B;
            return v.len;
        }

        fn main() 0.test - 1.test;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_A
                                #define DEF_A
extern const fu::str A;
                                #endif

                                #ifndef DEF_B
                                #define DEF_B
extern const fu::str B;
                                #endif

static int test_vqTO4Yz9(const int i)
{
    fu::view<char> /*static*/ v = ((i & 1) ? A : B);
    return v.size();
}

int fu_MAIN()
{
    return test_vqTO4Yz9(0) - test_vqTO4Yz9(1);
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> $T) {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

-----

-----

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> $T) {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };

        pub struct ModuleOutputs {
            deps: i32[];
            scope: Scope;
        };

        pub fn test(a: ModuleOutputs) {
            let b = a._0::clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);

-----
#include <fu/vec.h>

struct s_ModuleOutputs;
struct s_Scope;

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    int x;
    s_Scope(const s_Scope&) = delete;
    s_Scope(s_Scope&&) = default;
    s_Scope& operator=(const s_Scope&) = delete;
    s_Scope& operator=(s_Scope&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOutputs
                                #define DEF_s_ModuleOutputs
struct s_ModuleOutputs
{
    fu::vec<int> deps;
    s_Scope scope;
    s_ModuleOutputs(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs(s_ModuleOutputs&&) = default;
    s_ModuleOutputs& operator=(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs& operator=(s_ModuleOutputs&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || deps
            || scope
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_clone_hhyuasJYzG4
                                #define DEF_clone_hhyuasJYzG4
inline const fu::vec<int>& clone_hhyuasJY(const fu::vec<int>& a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_rgx2eiBuuy6
                                #define DEF_clone_rgx2eiBuuy6
inline int clone_rgx2eiBu(const int a)
{
    return a;
}
                                #endif

                                #ifndef DEF_clone_VZYffNibLX7
                                #define DEF_clone_VZYffNibLX7
inline s_Scope clone_VZYffNib(const s_Scope& a)
{
    /*MOV*/ s_Scope res {};
    res.x = clone_rgx2eiBu(a.x);
    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_clone_NFhH0TJoYDb
                                #define DEF_clone_NFhH0TJoYDb
inline s_ModuleOutputs clone_NFhH0TJo(const s_ModuleOutputs& a)
{
    /*MOV*/ s_ModuleOutputs res {};

    {
        res.deps = clone_hhyuasJY(a.deps);
        res.scope = clone_VZYffNib(a.scope);
    };
    return /*NRVO*/ res;
}
                                #endif

int test_ckg5CXi3(const s_ModuleOutputs& a)
{
    s_ModuleOutputs b = clone_NFhH0TJo(a);
    return a.deps.size() - b.deps.size();
}

int fu_MAIN()
{
    return test_ckg5CXi3(s_ModuleOutputs{});
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        // a private fn
        fn createShader(src: string) = src;

        // inits a public let
        pub let GEOMETRY_PASS_TEST = createShader("src");       // ConstCast

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

static const fu::str& createShader_CeQuEEC1(const fu::str& src)
{
    return src;
}

                                #ifndef DEF_GEOMETRY_PASS_TEST
                                #define DEF_GEOMETRY_PASS_TEST
extern const fu::str GEOMETRY_PASS_TEST fu_INIT_PRIORITY(1001) = static_cast<fu::str&&>(const_cast<fu::str&>(createShader_CeQuEEC1("src"_fu)));
                                #endif

#endif

// N_SD_HasStaticInit

-----

        // a private fn
        fn createShader(src: string) = src;

        // inits a public let
        pub let GEOMETRY_PASS_TEST = createShader("src");       // ConstCast

        pub fn main() _0::GEOMETRY_PASS_TEST.len - 3;

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_GEOMETRY_PASS_TEST
                                #define DEF_GEOMETRY_PASS_TEST
extern const fu::str GEOMETRY_PASS_TEST;
                                #endif

int fu_MAIN()
{
    return GEOMETRY_PASS_TEST.size() - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct List {
            vals: string[];
        };

        fn add(using ref _: List, val: string)
            vals ~= val;

        fn [](using _: List, val: string) {
            mut count = 0;
            for (mut i = 0; i < vals.len; i++)
                if (vals[i] == val)
                    count++;

            return count;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_List;

                                #ifndef DEF_s_List
                                #define DEF_s_List
struct s_List
{
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

fu::vec<fu::str>& add_LBujZ5J9(s_List& _, const fu::str& val)
{
    return (_.vals += fu::str(val));
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int x5Bx5D_3qVEVc50(const s_List& _, fu::view<char> val)
{
    int count = 0;
    for (int i = 0; i < _.vals.size(); i++)
    {
        if (_.vals[i] == val)
            count++;

    };
    return count;
}

#endif

// N_NonTrivAutoCopy

-----

        struct List {
            vals: string[];
        };

        fn add(using ref _: List, val: string)
            vals ~= val;

        fn [](using _: List, val: string) {
            mut count = 0;
            for (mut i = 0; i < vals.len; i++)
                if (vals[i] == val)
                    count++;

            return count;
        }

        fn main() {
            mut list: _0::List;
            for (mut i = 0; i < 3; i++)
                list.add(i & 1 ? "a" : "b");

            return list["b"] - 2;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_List;
fu::vec<fu::str>& add_LBujZ5J9(s_List&, const fu::str&);
int x5Bx5D_3qVEVc50(const s_List&, fu::view<char>);

                                #ifndef DEF_s_List
                                #define DEF_s_List
struct s_List
{
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_List list {};
    for (int i = 0; i < 3; i++)
        add_LBujZ5J9(list, ((i & 1) ? "a"_fu : "b"_fu));

    return x5Bx5D_3qVEVc50(list, "b"_fu) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Int { i: i32; };
        fn -(a: Int) Int(-a.i);
        fn +(a: Int, b: Int) Int(a.i + b.i);
        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };
        postfix fn ++(ref a: Int) { a.i++; };

-----
struct s_Int;

                                #ifndef DEF_s_Int
                                #define DEF_s_Int
struct s_Int
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Int operator-(const s_Int& a)
{
    return s_Int { -a.i };
}

s_Int operator+(const s_Int& a, const s_Int& b)
{
    return s_Int { (a.i + b.i) };
}

s_Int& operator+=(s_Int& a, const s_Int& b)
{
    a.i += b.i;
    return a;
}

void operator++(s_Int& a, /*postfix*/int)
{
    a.i++;
}

#endif

-----

        struct Int { i: i32; };
        fn -(a: Int) Int(-a.i);
        fn +(a: Int, b: Int) Int(a.i + b.i);
        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };
        postfix fn ++(ref a: Int) { a.i++; };

        fn main() {
            mut x: _0::Int = [ 1 ];
            x += -(x + x);
            x++;
            return x.i;
        }

-----
struct s_Int;
s_Int operator+(const s_Int&, const s_Int&);
s_Int operator-(const s_Int&);
s_Int& operator+=(s_Int&, const s_Int&);
void operator++(s_Int&, /*postfix*/int);

                                #ifndef DEF_s_Int
                                #define DEF_s_Int
struct s_Int
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Int x = s_Int { 1 };
    x += -(x + x);
    x++;
    return x.i;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.

        fn main()               1.public - 6;

-----

#ifndef fu_NO_fdefs

inline static int pRivate_1WsbUdat(const int x)
{
    return x * 3;
}

                                #ifndef DEF_pUblic_rQBG6KTthAa
                                #define DEF_pUblic_rQBG6KTthAa
inline int pUblic_rQBG6KTt(const int y)
{
    return pRivate_1WsbUdat(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_rQBG6KTt(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.

-----

-----

        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.
        pub import _0;
        fn main()               1.public - 6;

-----

#ifndef fu_NO_fdefs

inline static int pRivate_1WsbUdat(const int x)
{
    return x * 3;
}

                                #ifndef DEF_pUblic_rQBG6KTthAa
                                #define DEF_pUblic_rQBG6KTthAa
inline int pUblic_rQBG6KTt(const int y)
{
    return pRivate_1WsbUdat(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_rQBG6KTt(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn private(x: i32)      x * 3;              // cg fail:
        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.

-----

#ifndef fu_NO_fdefs

int pRivate(const int x)
{
    return x * 3;
}

#endif

// N_SD_ExternPrivates

-----

        fn private(x: i32)      x * 3;              // cg fail:
        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.

        fn main()               1._0::public - 6;

-----
int pRivate(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_pUblic_rQBG6KTthAa
                                #define DEF_pUblic_rQBG6KTthAa
inline int pUblic_rQBG6KTt(const int y)
{
    return pRivate(y) * 2;
}
                                #endif

int fu_MAIN()
{
    return pUblic_rQBG6KTt(1) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";   // nowadays problem is OPTOKENS cgs to static in first translation unit

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...
                    return idx - 1;
            }

            return src.len;
        }

-----
#include <fu/str.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_OPTOKENS
                                #define DEF_OPTOKENS
extern const fu::str OPTOKENS fu_INIT_PRIORITY(1001) = "{}[]()!?~@#$%^&*/-+<=>,.;:|"_fu;
                                #endif

#endif

// N_SD_HasStaticInit, N_SD_ExternPrivates

-----

        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";   // nowadays problem is OPTOKENS cgs to static in first translation unit

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...
                    return idx - 1;
            }

            return src.len;
        }

        fn main() _0::lex("3 - 3") - 2; // <- from here

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/init_priority.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_OPTOKENS
                                #define DEF_OPTOKENS
extern const fu::str OPTOKENS;
                                #endif

                                #ifndef DEF_has_KonMQ4KBuu5
                                #define DEF_has_KonMQ4KBuu5
inline bool has_KonMQ4KB(fu::view<char> a, const char b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return true;

    };
    return false;
}
                                #endif

                                #ifndef DEF_lex_IbHLL4cS2G8
                                #define DEF_lex_IbHLL4cS2G8
inline int lex_IbHLL4cS(fu::view<char> src)
{
    const int end = src.size();
    int idx = 0;
    while (idx < end)
    {
        const char /*src|static*/ c = src[idx++];
        if (has_KonMQ4KB(OPTOKENS, c))
            return idx - 1;

    };
    return src.size();
}
                                #endif

int fu_MAIN()
{
    return lex_IbHLL4cS("3 - 3"_fu) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn pubbed(a: i32) a * 2;

        fn not_pubbed(b: i32) b * 3;

        fn main() 1._0::pubbed._0::not_pubbed - 6;

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 2:32+2[0m:

[2m      | [0m
[2m    2 | [0m        fn main() 1._0::pubbed.[31;1m_0[0m::not_pubbed - 6;
[2m      | [0m

	Bad call to [34;1mnot_pubbed[0m with args (i32 copy): [34;1mnot_pubbed[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        pub fn pubbed(a: i32) a * 2;

        pub                          
        fn not_pubbed(b: i32) b * 3;

-----

#ifndef fu_NO_fdefs

int pubbed_rgx2eiBu(const int a)
{
    return a * 2;
}

int not_pubbed_urWHdJ0x(const int b)
{
    return b * 3;
}

#endif

-----

        pub fn pubbed(a: i32) a * 2;

        pub                          
        fn not_pubbed(b: i32) b * 3;

        fn main() 1._0::pubbed._0::not_pubbed - 6;

-----
int pubbed_rgx2eiBu(int);
int not_pubbed_urWHdJ0x(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return not_pubbed_urWHdJ0x(pubbed_rgx2eiBu(1)) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        let SELF_TEST           = true;
        let NODEIDX_signbits    = SELF_TEST && 4;
        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_SELF_TEST
                                #define DEF_SELF_TEST
inline constexpr bool SELF_TEST = true;
                                #endif

                                #ifndef DEF_NODEIDX_signbits
                                #define DEF_NODEIDX_signbits
inline constexpr int NODEIDX_signbits = 4;
                                #endif

                                #ifndef DEF_NODEIDX_signmask
                                #define DEF_NODEIDX_signmask
extern const int NODEIDX_signmask = ((1 << NODEIDX_signbits) - 1);
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let SELF_TEST           = true;
        let NODEIDX_signbits    = SELF_TEST && 4;
        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;

        fn main() _0::NODEIDX_signmask - 15;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_NODEIDX_signmask
                                #define DEF_NODEIDX_signmask
extern const int NODEIDX_signmask;
                                #endif

int fu_MAIN()
{
    return NODEIDX_signmask - 15;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;

        import _0;
        fn main() {
 //  feels like this override should be explicit
            infix fn +(a: Helpers, b: Helpers) a.index + b.index;
            return Helpers(+1) + Helpers(-1);
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 6:32+1[0m:

[2m      |  //  feels like this override should be explicit[0m
[2m      |             infix fn +(a: Helpers, b: Helpers) a.index + b.index;[0m
[2m    6 | [0m            return Helpers(+1) [31;1m+[0m Helpers(-1);
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [31;1m+[0m, matches multiple items in scope:

	[35;1mfn[0m [34;1m+[0m at [2m5:22+1[0m:
[2m    5 | [0m            infix fn [31;1m+[0m(a: Helpers, b: Helpers) a.index + b.index;

	[35;1mfn[0m [34;1m+[0m at [2m[0m_0[2m.fu 3:12+1[0m:
[2m    3 | [0m        fn [31;1m+[0m(a: Helpers, b: Helpers) a.index - b.index;


        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;

-----
struct s_Helpers;

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int operator+(const s_Helpers& a, const s_Helpers& b)
{
    return a.index - b.index;
}

#endif

-----

        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;

        import _0;
        fn main() {
 // autoshadowing surprised me here
            shadow       //  feels like this override should be explicit
            infix fn +(a: Helpers, b: Helpers) a.index + b.index;
            return Helpers(+1) + Helpers(-1);
        }

-----
struct s_Helpers;

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int operator+(const s_Helpers& a, const s_Helpers& b)
{
    return a.index + b.index;
}

int fu_MAIN()
{
    return s_Helpers { +1 } + s_Helpers { -1 };
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Options { v: i32; };

-----

-----

        struct Options { v: i32; };

        fn compile(o: _0::Options) = o.v;

-----
struct s_Options;

                                #ifndef DEF_s_Options
                                #define DEF_s_Options
struct s_Options
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int compile_SaT06GAC(const s_Options& o)
{
    return o.v;
}

#endif

-----

        struct Options { v: i32; };

        fn compile(o: _0::Options) = o.v;

        // Won't find Options if solving in reverse modid order.
        fn compile_snippets(o: _0::Options) = o.v;

-----
struct s_Options;

                                #ifndef DEF_s_Options
                                #define DEF_s_Options
struct s_Options
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int compile_snippets_INsPKGYB(const s_Options& o)
{
    return o.v;
}

#endif

-----

        struct Options { v: i32; };

        fn compile(o: _0::Options) = o.v;

        // Won't find Options if solving in reverse modid order.
        fn compile_snippets(o: _0::Options) = o.v;

        import _1;
        import _2;

        fn main() {
            let o = _0::Options(0);
            return compile(o) + compile_snippets(o);
        }

-----
struct s_Options;
int compile_SaT06GAC(const s_Options&);
int compile_snippets_INsPKGYB(const s_Options&);

                                #ifndef DEF_s_Options
                                #define DEF_s_Options
struct s_Options
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Options o = s_Options { 0 };
    return compile_SaT06GAC(o) + compile_snippets_INsPKGYB(o);
}

#endif

int main() { return fu_MAIN(); }

-----

        let x: i32 = 2;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr int x = 2;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let x: i32 = 2;

        pub import _0;
        let y: i32 = 3;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_y
                                #define DEF_y
inline constexpr int y = 3;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let x: i32 = 2;

        pub import _0;
        let y: i32 = 3;

        import _1;
        fn main() x + y - 5;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x
                                #define DEF_x
inline constexpr int x = 2;
                                #endif

                                #ifndef DEF_y
                                #define DEF_y
inline constexpr int y = 3;
                                #endif

int fu_MAIN()
{
    return (x + y) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Profile {
            a: i32;
            b: i32;
            c: i32;
        };

        fn incr(implicit ref p: Profile, which) {
            p.which++;
        }

-----

-----

        struct Profile {
            a: i32;
            b: i32;
            c: i32;
        };

        fn incr(implicit ref p: Profile, which) {
            p.which++;
        }

        fn main() {
            implicit mut p: _0::Profile;

            _0::incr(fn _0::a);
            _0::incr(|i| i._0::b);
            _0::incr(|i| i.b);
            _0::incr(._0::c);
            _0::incr(.c);

            return p._0::a + p.b * 10 + p.c * 100 == 221 ? 0 : 1;
        }

-----
struct s_Profile;

                                #ifndef DEF_s_Profile
                                #define DEF_s_Profile
struct s_Profile
{
    int a;
    int b;
    int c;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_incr_1A92PWH5TU8
                                #define DEF_incr_1A92PWH5TU8
inline void incr_1A92PWH5(s_Profile& p)
{
    p.a++;
}
                                #endif

inline static int& l_2_0_yRsq3T7g(s_Profile& i)
{
    return i.b;
}

                                #ifndef DEF_incr_fWjZ2mewm4g
                                #define DEF_incr_fWjZ2mewm4g
inline void incr_fWjZ2mew(s_Profile& p)
{
    l_2_0_yRsq3T7g(p)++;
}
                                #endif

inline static int& l_2_1_0iMQT1rv(s_Profile& i)
{
    return i.b;
}

                                #ifndef DEF_incr_GO0dDJ2tBda
                                #define DEF_incr_GO0dDJ2tBda
inline void incr_GO0dDJ2t(s_Profile& p)
{
    l_2_1_0iMQT1rv(p)++;
}
                                #endif

inline static int& l_2_2_fOaQyAYn(s_Profile& l_2_2)
{
    return l_2_2.c;
}

                                #ifndef DEF_incr_OWA2KEeFOQ8
                                #define DEF_incr_OWA2KEeFOQ8
inline void incr_OWA2KEeF(s_Profile& p)
{
    l_2_2_fOaQyAYn(p)++;
}
                                #endif

inline static int& l_2_3_GVzYJrT5(s_Profile& l_2_3)
{
    return l_2_3.c;
}

                                #ifndef DEF_incr_V3oXY5ICeE1
                                #define DEF_incr_V3oXY5ICeE1
inline void incr_V3oXY5IC(s_Profile& p)
{
    l_2_3_GVzYJrT5(p)++;
}
                                #endif

int fu_MAIN()
{
    s_Profile p {};
    incr_1A92PWH5(p);
    incr_fWjZ2mew(p);
    incr_GO0dDJ2t(p);
    incr_OWA2KEeF(p);
    incr_V3oXY5IC(p);
    if (((p.a + (p.b * 10)) + (p.c * 100)) == 221)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;

-----

-----

        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;

        fn lookupUserType(type: string) =
            "<" ~ type.len ~ ">";

        fn tryLookupUserType(type: string) =
            type._0::isStruct && lookupUserType(type);

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

fu::str lookupUserType_qAgrDsAQ(fu::view<char> type)
{
    return x7E_gCeFmDFw("<"_fu, fu::i64dec(type.size())) + ">"_fu;
}

                                #ifndef DEF_starts_Db9eGFmCKDj
                                #define DEF_starts_Db9eGFmCKDj
inline bool starts_Db9eGFmC(fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

fu::str tryLookupUserType_qAgrDsAQ(fu::view<char> type)
{
    if (starts_Db9eGFmC(type, '/'))
        return lookupUserType_qAgrDsAQ(type);
    else
    {
        return fu::str{};
    };
}

#endif

-----

        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;

        fn lookupUserType(type: string) =
            "<" ~ type.len ~ ">";

        fn tryLookupUserType(type: string) =
            type._0::isStruct && lookupUserType(type);

        fn getFlatCount(type: string) =
            type._0::isStructOrUnion
                ? _1::tryLookupUserType(type).len
                : 1;

-----
#include <fu/str.h>
#include <fu/view.h>

fu::str tryLookupUserType_qAgrDsAQ(fu::view<char>);

#ifndef fu_NO_fdefs

                                #ifndef DEF_starts_Db9eGFmCKDj
                                #define DEF_starts_Db9eGFmCKDj
inline bool starts_Db9eGFmC(fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

int getFlatCount_LN33G3Z2(fu::view<char> type)
{
    if (starts_Db9eGFmC(type, '/'))
        return tryLookupUserType_qAgrDsAQ(type).size();
    else
        return 1;

}

#endif

-----

        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;

        fn lookupUserType(type: string) =
            "<" ~ type.len ~ ">";

        fn tryLookupUserType(type: string) =
            type._0::isStruct && lookupUserType(type);

        fn getFlatCount(type: string) =
            type._0::isStructOrUnion
                ? _1::tryLookupUserType(type).len
                : 1;

        fn main() = "/a"._2::getFlatCount() == 3 ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>

int getFlatCount_LN33G3Z2(fu::view<char>);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (getFlatCount_LN33G3Z2("/a"_fu) == 3)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        noinline fn recA(x) x & 1 ? recB(x) : x;
        noinline fn recB(x) recA(x + 1);

        pub inline fn fun(x: i32) recB(x);

-----

// N_FnRecursion, N_FnReopen

-----

        noinline fn recA(x) x & 1 ? recB(x) : x;
        noinline fn recB(x) recA(x + 1);

        pub inline fn fun(x: i32) recB(x);

        fn main() _0::fun(0) == 2 ? 0 : 1;                      // GNUStmtExpr

-----
inline static int recB_1WsbUdat(int);

#ifndef fu_NO_fdefs

inline static int recA_1WsbUdat(const int x)
{
    if (x & 1)
        return recB_1WsbUdat(x);
    else
        return x;

}

inline static int recB_1WsbUdat(const int x)
{
    return recA_1WsbUdat((x + 1));
}

int fu_MAIN()
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const int x = 0;
        BL_1_v = (recB_1WsbUdat(x));
    (void)0;}), BL_1_v) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * _1::add5(5)     ;

        import _0;
        fn add5(x: i32) add2(x) + 3;

        fn main() _0::times10(_1::add5(8)) - 130;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:23+2[0m:

[2m      |         fn times10(x: i32)[0m
[2m      | [0m
[2m    5 | [0m                x * _1[31;1m::[0madd5(5)     ;
[2m      | [0m

	Imports:

[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 2:9+6[0m:

[2m      | [0m
[2m    2 | [0m        [31;1mimport[0m _0;
[2m      |         fn add5(x: i32) add2(x) + 3;[0m
[2m      | [0m

	Resulting in an import circle, not currently supported.

-----

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * 10              ;

-----

#ifndef fu_NO_fdefs

int add2_1WsbUdat(const int x)
{
    return x + 2;
}

int times10_1WsbUdat(const int x)
{
    return x * 10;
}

#endif

-----

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * 10              ;

        import _0;
        fn add5(x: i32) add2(x) + 3;

-----
int add2_1WsbUdat(int);

#ifndef fu_NO_fdefs

int add5_W0HwfDvt(const int x)
{
    return add2_1WsbUdat(x) + 3;
}

#endif

-----

        fn add2(x: i32) x + 2;
        fn times10(x: i32)

                x * 10              ;

        import _0;
        fn add5(x: i32) add2(x) + 3;

        fn main() _0::times10(_1::add5(8)) - 130;

-----
int add5_W0HwfDvt(int);
int times10_1WsbUdat(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return times10_1WsbUdat(add5_W0HwfDvt(8)) - 130;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(x: i32) x * 3;


        import _2;                       
        fn main() hello(4) - 12;

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 3:9+6[0m:

[2m      | [0m
[2m      | [0m
[2m    3 | [0m        [31;1mimport[0m _2;                       
[2m      |         fn main() hello(4) - 12;[0m
[2m      | [0m

	Could not resolve this import.

	Searched relative to:    	[31;1m/Users/hdachev/fu/__tests__/[0m
	Looking for a file named:	[31;1m_2.fu[0m

-----

        fn hello(x: i32) x * 3;

-----

#ifndef fu_NO_fdefs

int hello_1WsbUdat(const int x)
{
    return x * 3;
}

#endif

-----

        fn hello(x: i32) x * 3;


        import _0;                       
        fn main() hello(4) - 12;

-----
int hello_1WsbUdat(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return hello_1WsbUdat(4) - 12;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct What { thing: i32 };


        fn must_be_public(x: What) = x.thing * 11;

        fn main() = _0::What(3).must_be_public - 33;

-----
[2m/Users/hdachev/fu/__tests__/[0m_1[2m.fu 2:33+14[0m:

[2m      | [0m
[2m    2 | [0m        fn main() = _0::What(3).[31;1mmust_be_public[0m - 33;
[2m      | [0m

	Bad call to [34;1mmust_be_public[0m with args (What copy): [34;1mmust_be_public[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        pub struct What { thing: i32 };


        pub 
        fn must_be_public(x: What) = x.thing * 11;

-----
struct s_What;

                                #ifndef DEF_s_What
                                #define DEF_s_What
struct s_What
{
    int thing;
    explicit operator bool() const noexcept
    {
        return false
            || thing
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int must_be_public_GR6BKBJx(const s_What& x)
{
    return x.thing * 11;
}

#endif

-----

        pub struct What { thing: i32 };


        pub 
        fn must_be_public(x: What) = x.thing * 11;

        fn main() = _0::What(3).must_be_public - 33;

-----
struct s_What;
int must_be_public_GR6BKBJx(const s_What&);

                                #ifndef DEF_s_What
                                #define DEF_s_What
struct s_What
{
    int thing;
    explicit operator bool() const noexcept
    {
        return false
            || thing
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return must_be_public_GR6BKBJx(s_What { 3 }) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { modid: i32; target: Target }
        struct Target { _packed: u64 }

        let modid = 2;
        inline fn modid(t: Target) i32(t._packed);
        inline fn index(t: Target) i32(t._packed >> 32);

        fn Target(shadow modid: i32, index: i32) {
            return Target(modid.u64 | index.u64 << 32);
        }

-----
#include <cstdint>

struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_modid
                                #define DEF_modid
inline constexpr int modid = 2;
                                #endif

s_Target Target_zZ1ZU0sW(const int modid, const int index)
{
    return s_Target { (uint64_t(unsigned(modid)) | (uint64_t(unsigned(index)) << 32ull)) };
}

#endif

// N_SD_HasStaticInit

-----

        struct Module { modid: i32; target: Target }
        struct Target { _packed: u64 }

        let modid = 2;
        inline fn modid(t: Target) i32(t._packed);
        inline fn index(t: Target) i32(t._packed >> 32);

        fn Target(shadow modid: i32, index: i32) {
            return Target(modid.u64 | index.u64 << 32);
        }

        import _0;
        fn inspect(m: Module) {
            return modid + m.modid + m.target.modid;            // GNUStmtExpr
        }

-----
#include <cstdint>

struct s_Module;
struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_modid
                                #define DEF_modid
inline constexpr int modid = 2;
                                #endif

int inspect_Ba2zAmxx(const s_Module& m)
{
    int BL_1_v {};
    return (modid + m.modid) + (__extension__ (
    {
        const s_Target& /*m*/ t = m.target;
        BL_1_v = (int(unsigned(t._packed)));
    (void)0;}), BL_1_v);
}

#endif

-----

        struct Module { modid: i32; target: Target }
        struct Target { _packed: u64 }

        let modid = 2;
        inline fn modid(t: Target) i32(t._packed);
        inline fn index(t: Target) i32(t._packed >> 32);

        fn Target(shadow modid: i32, index: i32) {
            return Target(modid.u64 | index.u64 << 32);
        }

        import _0;
        fn inspect(m: Module) {
            return modid + m.modid + m.target.modid;            // GNUStmtExpr
        }

        import _0;
        fn main() {
            let m = Module(3, Target(5, 7));
            return m._1::inspect() - 10;
        }

-----
#include <cstdint>

struct s_Module;
struct s_Target;
s_Target Target_zZ1ZU0sW(int, int);
int inspect_Ba2zAmxx(const s_Module&);

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || target
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Module m = s_Module { 3, Target_zZ1ZU0sW(5, 7) };
    return inspect_Ba2zAmxx(m) - 10;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Module { modid: i32; };
        struct Target { _packed: u64; };

        fn modid(t: Target) i32(t._packed & 0xffffff);

        fn Target(modid: i32, index: i32, local: i32) {
            return Target(modid.u64
                        | index.u64 << 24
                        | local.u64 << 44);
        }

-----
#include <cstdint>

struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int modid_tIv2fK7v(const s_Target& t)
{
    return int(unsigned((t._packed & 0xffffffull)));
}

s_Target Target_sJNTwOQP(const int modid, const int index, const int local)
{
    return s_Target { ((uint64_t(unsigned(modid)) | (uint64_t(unsigned(index)) << 24ull)) | (uint64_t(unsigned(local)) << 44ull)) };
}

#endif

-----

        struct Module { modid: i32; };
        struct Target { _packed: u64; };

        fn modid(t: Target) i32(t._packed & 0xffffff);

        fn Target(modid: i32, index: i32, local: i32) {
            return Target(modid.u64
                        | index.u64 << 24
                        | local.u64 << 44);
        }

        import _0;
        fn inspect(module: Module) = module.modid;

-----
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int inspect_fap6eisX(const s_Module& module)
{
    return module.modid;
}

#endif

-----

        struct Module { modid: i32; };
        struct Target { _packed: u64; };

        fn modid(t: Target) i32(t._packed & 0xffffff);

        fn Target(modid: i32, index: i32, local: i32) {
            return Target(modid.u64
                        | index.u64 << 24
                        | local.u64 << 44);
        }

        import _0;
        fn inspect(module: Module) = module.modid;

        fn main() _1::inspect([]);

-----
struct s_Module;
int inspect_fap6eisX(const s_Module&);

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return inspect_fap6eisX(s_Module{});
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Opts { b: i32 };

-----

-----

        struct Opts { b: i32 };

        fn main() {
            fn muteRest(a, opts?: _0::Opts) a + opts.b;
            return 0.muteRest;
        }

-----
struct s_Opts;

                                #ifndef DEF_s_Opts
                                #define DEF_s_Opts
struct s_Opts
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int muteRest_iWOZFUGw(const int a, const s_Opts& opts)
{
    return a + opts.b;
}

int fu_MAIN()
{
    return muteRest_iWOZFUGw(0, s_Opts{});
}

#endif

int main() { return fu_MAIN(); }

-----

        let a = 1;
        shadow let a = a + 1;
        return a - 2;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = 1;
    const int a_1 = (a + 1);
    return a_1 - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn outer() inner(); // <- this reset root-scope
        inline fn inner() {
            // <- so main::i was visible here
            for (mut i = 0; i < 10; i++) return i;
            return 1;
        }
        fn main() {
            for (mut i = 0; i < 10; i++) return outer();
            return 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    for (int i = 0; i < 10; i++)
    {
        for (int i_1 = 0; i_1 < 10; i_1++)
            return i_1;

        return 1;
    };
    return 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Target { modid: i32; packed: u32; };

        pub fn index(t: Target) i32(t.packed & 0x7fffffff);

        pub fn local_eq(t: Target, index: i32, implicit modid: i32)
            modid - t.modid || index - t.index;

        fn main() {
            let implicit modid = 1;
            return local_eq(Target(1, 0x80000002), 7) - 5;
        }

-----
struct s_Target;

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int modid;
    unsigned packed;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || packed
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int index_tIv2fK7v(const s_Target& t)
{
    return int((t.packed & 0x7fffffffu));
}

int local_eq_YUE5K6GH(const s_Target& t, const int index, const int modid)
{
    int _0 {};
    return (_0 = (modid - t.modid)) ? _0 : (index - index_tIv2fK7v(t));
}

int fu_MAIN()
{
    const int modid = 1;
    return local_eq_YUE5K6GH(s_Target { 1, 0x80000002u }, 7, modid) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        nocopy struct P { secs: P[] };

        fn matchImplicitArgByName_closuresAndShadowing(prims: P[]) {
            struct Helper { idx: i32; };

            using fn GET(using _: Helper) prims[idx];

            shadow mut prims = {
                mut res: Helper[];
                for (mut i = 0; i < prims.len; i++)
                    res ~= Helper(i);
                res                                             // GNUStmtExpr
            };

            prims.sort(|a, b| a.secs.len < b.secs.len);

            mut res = 101;
            for (mut i = 0; i < prims.len; i++) {
                let m = prims[i];
                res += m.secs.len;
                res *= m.secs.len;
            }

            return res;
        }

        fn main() {
            let prims = [ P([ P, P, P ]), P, P([ P ]), P([ P, P ]) ];
            let res = matchImplicitArgByName_closuresAndShadowing(prims);
            return res == 27 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_P;
struct s_Helper;

                                #ifndef DEF_s_P
                                #define DEF_s_P
struct s_P
{
    fu::vec<s_P> secs;
    s_P(const s_P&) = delete;
    s_P(s_P&&) = default;
    s_P& operator=(const s_P&) = delete;
    s_P& operator=(s_P&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || secs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Helper
                                #define DEF_s_Helper
struct s_Helper
{
    int idx;
    explicit operator bool() const noexcept
    {
        return false
            || idx
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_P& GET_3YrLCzit(const s_Helper& _, fu::view<s_P> prims)
{
    return prims[_.idx];
}

inline static bool l_1_0_MU6JZ3QR(const s_Helper& a, const s_Helper& b, fu::view<s_P> prims)
{
    return GET_3YrLCzit(a, prims).secs.size() < GET_3YrLCzit(b, prims).secs.size();
}

static void sort_tGAOQHOU(fu::vec<s_Helper>& a, fu::view<s_P> prims)
{
    s_Helper l {};
    s_Helper r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = l_1_0_MU6JZ3QR(l, r, prims);
    return lt;
            });

}

                                #ifndef DEF_sort_tATFRjKyR7h
                                #define DEF_sort_tATFRjKyR7h
inline void sort_tATFRjKy(fu::vec<s_Helper>& a, fu::view<s_P> prims)
{
    sort_tGAOQHOU(a, prims);
}
                                #endif

static int matchImplicitArgByName_closuresAndShadowing_ZItF4XI6(fu::view<s_P> prims)
{
    // Hoisted:
    fu::vec<s_Helper> res {};

    fu::vec<s_Helper>* BL_1_v;
    fu::vec<s_Helper> prims_1 = static_cast<fu::vec<s_Helper>&&>((__extension__ (
    {
        res =  {};
        for (int i = 0; i < prims.size(); i++)
        {
            res += s_Helper { i };
        };
        BL_1_v = &(res);
    (void)0;}), *BL_1_v));
    sort_tATFRjKy(prims_1, prims);
    int res_1 = 101;
    for (int i_1 = 0; i_1 < prims_1.size(); i_1++)
    {
        const s_Helper& /*prims_1|static*/ m = prims_1[i_1];
        res_1 += GET_3YrLCzit(m, prims).secs.size();
        res_1 *= GET_3YrLCzit(m, prims).secs.size();
    };
    return res_1;
}

int fu_MAIN()
{
    fu::vec<s_P> prims = fu::vec<s_P> { fu::slate<4, s_P> { s_P { fu::vec<s_P> { fu::slate<3, s_P> { s_P{}, s_P{}, s_P{} } } }, s_P{}, s_P { fu::vec<s_P> { fu::slate<1, s_P> { s_P{} } } }, s_P { fu::vec<s_P> { fu::slate<2, s_P> { s_P{}, s_P{} } } } } };
    const int res = matchImplicitArgByName_closuresAndShadowing_ZItF4XI6(prims);
    if (res == 27)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

-----

        struct HasInt { i: i32; };

        fn test(s: HasInt): &i32 {
            let i = s.i;
            return i;
        }

        fn main() HasInt(-1).test + 1;

-----
struct s_HasInt;

                                #ifndef DEF_s_HasInt
                                #define DEF_s_HasInt
struct s_HasInt
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_jzSE8ssT(const s_HasInt& s)
{
    const int /*s*/ i = s.i;
    return i;
}

int fu_MAIN()
{
    return test_jzSE8ssT(s_HasInt { -1 }) + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32): &i32 = x;
        fn main() test(3) - 3;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    return x;
}

int fu_MAIN()
{
    return test_1WsbUdat(3) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32): &i32 {
            fn inner() x;
            return inner;
        }

        fn main() test(3) - 3;

-----

#ifndef fu_NO_fdefs

static int inner_y1jV3SX3(const int x)
{
    return x;
}

static int test_1WsbUdat(const int x)
{
    return inner_y1jV3SX3(x);
}

int fu_MAIN()
{
    return test_1WsbUdat(3) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct I { v: i32; };

        fn test(x: I): &i32 {
            fn inner() x.v;
            return inner;
        }

        fn main() test(I(3)) - 3;

-----
struct s_I;

                                #ifndef DEF_s_I
                                #define DEF_s_I
struct s_I
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_V6uTIUa3(const s_I& x)
{
    return x.v;
}

static int test_oIXhHJLm(const s_I& x)
{
    return inner_V6uTIUa3(x);
}

int fu_MAIN()
{
    return test_oIXhHJLm(s_I { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() x.v[0];
            return inner;
        }

        fn main() test(I([3])) - 3;

-----
#include <fu/vec.h>

struct s_I;

                                #ifndef DEF_s_I
                                #define DEF_s_I
struct s_I
{
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_V6uTIUa3(const s_I& x)
{
    return x.v[0];
}

static int test_vU2uEvkV(const s_I& x)
{
    return inner_V6uTIUa3(x);
}

int fu_MAIN()
{
    return test_vU2uEvkV(s_I { fu::vec<int> { fu::slate<1, int> { 3 } } }) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() {
                let v = x.v;
                return v[0];
            }

            return inner;
        }

        fn main() test(I([3])) - 3;

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_I;

                                #ifndef DEF_s_I
                                #define DEF_s_I
struct s_I
{
    fu::vec<int> v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_V6uTIUa3(const s_I& x)
{
    fu::view<int> /*x*/ v = x.v;
    return v[0];
}

static int test_vU2uEvkV(const s_I& x)
{
    return inner_V6uTIUa3(x);
}

int fu_MAIN()
{
    return test_vU2uEvkV(s_I { fu::vec<int> { fu::slate<1, int> { 3 } } }) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn noReturn() throw ("ex");

        fn doesReturn(a: i32) {
            if (a > 0) return noReturn();
            return a;
        }

        fn main() doesReturn(-3) + 3;

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never noReturn_H9fhQUVP()
{
    fu::fail("ex"_fu);
}

static int doesReturn_rgx2eiBu(const int a)
{
    if (a > 0)
        noReturn_H9fhQUVP();
    else
        return a;

}

int fu_MAIN()
{
    return doesReturn_rgx2eiBu(-3) + 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Context { modules: Module[]; };
        struct Module  { fname: i32; };

        fn test(implicit ctx: Context) {
            fn findModule(fname: i32): &Module {
                let modules = ctx.modules;
                for (mut i = 0; i < modules.len; i++) {
                    let module = modules[i];
                    if (module.fname == fname)
                        return module;
                }

                throw("Cannot locate: " ~ fname);
            }

            return findModule(0);
        }

        fn main() {
            let implicit ctx = Context([ Module ]);
            return test.fname;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct s_Context;
struct s_Module;

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int fname;
    explicit operator bool() const noexcept
    {
        return false
            || fname
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::vec<s_Module> modules;
    explicit operator bool() const noexcept
    {
        return false
            || modules
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static const s_Module& findModule_9mrGZUzx(const int fname, const s_Context& ctx)
{
    fu::view<s_Module> /*ctx*/ modules = ctx.modules;
    for (int i = 0; i < modules.size(); i++)
    {
        const s_Module& /*modules|static*/ module = modules[i];
        if (module.fname == fname)
            return module;

    };
    fu::fail(x7E_gCeFmDFw("Cannot locate: "_fu, fu::i64dec(fname)));
}

static const s_Module& test_d61OS8du(const s_Context& ctx)
{
    return findModule_9mrGZUzx(0, ctx);
}

int fu_MAIN()
{
    s_Context ctx = s_Context { fu::vec<s_Module> { fu::slate<1, s_Module> { s_Module{} } } };
    return test_d61OS8du(ctx).fname;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn noReturn() throw ("ex");

        fn returnVoid(a: i32): void {
            if (a > 0) return noReturn();
        }

        fn main() {
            returnVoid(0);
            return 0;
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never noReturn_H9fhQUVP()
{
    fu::fail("ex"_fu);
}

static void returnVoid_rgx2eiBu(const int a)
{
    if (a > 0)
        noReturn_H9fhQUVP();

}

int fu_MAIN()
{
    returnVoid_rgx2eiBu(0);
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn parseQualifierChain(mut i: i32): i32 {
            for (;;) {
                if !(i & 15) return i;
                i--;
            }
        }

        fn main() parseQualifierChain(15);

-----

#ifndef fu_NO_fdefs

static int parseQualifierChain_nD58vCLu(int i)
{
    for (; ; )
    {
        if (!(i & 15))
            return i;
        else
            i--;

    };
}

int fu_MAIN()
{
    return parseQualifierChain_nD58vCLu(15);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main()
        {
            mut sum = 0;
            fn compile(x: i32)
            {
                // 1. this throw contributed a 'never' ret_count.
                x || throw ("x=0");
                if (x & 1) compile(x + 1); // 2. then this recursion did something.
                sum += x; // <- also this must be a closure.
                // 3. finally no ret_actual but non-zero ret_count.
            }

            compile(2);
            return sum - 2;
        }

-----
#include <fu/str.h>
#include <fu/never.h>

static void compile_rRHSWec8(int, int&);

#ifndef fu_NO_fdefs

static void compile_rRHSWec8(const int x, int& sum)
{
    if (x)
    {
        if (x & 1)
            compile_rRHSWec8((x + 1), sum);

        sum += x;
    }
    else
        fu::fail("x=0"_fu);

}

int fu_MAIN()
{
    int sum = 0;
    compile_rRHSWec8(2, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn main()
        {
            mut sum = 0;
            fn getModule(fname: string) fname.len;
            fn compile(fname: string, via: string = "")
            {
                let module = getModule(fname) || throw ("import circle: '" ~ via ~ fname ~ "'.");
                if (module & 1) {
                    let fuzimports = fname.split("a");
                    for (mut i = 0; i < fuzimports.len; i++)
                        compile(
                            fname: fuzimports[i],
                              via: fname ~ " <- " ~ via);
                }

                sum += module;
            }

            compile("ab");
            return sum - 2;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

static void compile_gc8eTRNH(const fu::str&, fu::view<char>, int&);

#ifndef fu_NO_fdefs

static int getModule_gI4Ohfkr(fu::view<char> fname)
{
    return fname.size();
}

inline static fu::vec<fu::str>& l_0_0_zIJJ0oqP(const fu::str& substr, fu::vec<fu::str>& result)
{
    return (result += fu::str(substr));
}

                                #ifndef DEF_split_GMzs1whClJf
                                #define DEF_split_GMzs1whClJf
inline void split_GMzs1whC(const fu::str& str, fu::view<char> sep, fu::vec<fu::str>& result)
{
    int last = 0;
    int next = 0;
    const int N = sep.size();
    if (N)
    {
        while (((next = fu::lfind(str, sep, last)) >= 0))
        {
            l_0_0_zIJJ0oqP(fu::slice(str, last, next), result);
            last = (next + N);
        };
    };
    if (last)
        l_0_0_zIJJ0oqP(fu::slice(str, last), result);
    else
        l_0_0_zIJJ0oqP(str, result);

}
                                #endif

                                #ifndef DEF_split_e8WhGmUqohg
                                #define DEF_split_e8WhGmUqohg
inline fu::vec<fu::str> split_e8WhGmUq(const fu::str& str, fu::view<char> sep)
{
    /*MOV*/ fu::vec<fu::str> result {};
    split_GMzs1whC(str, sep, result);
    return /*NRVO*/ result;
}
                                #endif

static void compile_gc8eTRNH(const fu::str& fname, fu::view<char> via, int& sum)
{
    int _0 {};
    const int module = ((_0 = getModule_gI4Ohfkr(fname)) ? _0 : fu::fail(((("import circle: '"_fu + via) + fname) + "'."_fu)));
    if (module & 1)
    {
        fu::vec<fu::str> fuzimports = split_e8WhGmUq(fname, "a"_fu);
        for (int i = 0; i < fuzimports.size(); i++)
            compile_gc8eTRNH(fuzimports[i], ((fname + " <- "_fu) + via), sum);

    };
    sum += module;
}

int fu_MAIN()
{
    int sum = 0;
    compile_gc8eTRNH("ab"_fu, ""_fu, sum);
    return sum - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_NonTrivAutoCopy

-----

        fn A(implicit _A: i32[]) _A;
        fn B(implicit _B:  u8[]) _B;

        fn AB(x: i32) A[x] - B[x].i32;
        fn BA(x: i32) B[x].i32 - A[x];

        fn cycleA_inner(x: i32)
            x & 1   ? either(x + 1) + AB(x)
                    : BA(x);

        fn cycleA_outer(x: i32)
            x & 1   ? cycleA_inner(x + 1) + AB(x)
                    : BA(x);

        fn cycleB_inner(x: i32)
            x & 2   ? either(x + 1) + BA(x)
                    : AB(x);

        fn cycleB_outer(x: i32)
            x & 2   ? cycleB_inner(x + 1) + BA(x)
                    : AB(x);

        fn either(x: i32)
            x & 4   ? cycleA_outer(x)
                    : cycleB_outer(x);

        fn main() {
            let implicit _A = [ 0,    1,    2    ];
            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];

            return either(0);
        }

-----
#include <fu/int.h>
#include <fu/vec.h>

static int either_WUl6zTdW(int, const fu::vec<int>&, const fu::vec<fu::u8>&);

#ifndef fu_NO_fdefs

static const fu::vec<int>& A_B8ygcZ3J(const fu::vec<int>& _A)
{
    return _A;
}

static const fu::vec<fu::u8>& B_7ouyYAMN(const fu::vec<fu::u8>& _B)
{
    return _B;
}

static int AB_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    return A_B8ygcZ3J(_A)[x] - int(unsigned(B_7ouyYAMN(_B)[x]));
}

static int BA_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    return int(unsigned(B_7ouyYAMN(_B)[x])) - A_B8ygcZ3J(_A)[x];
}

static int cycleA_inner_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    if (x & 1)
        return either_WUl6zTdW((x + 1), _A, _B) + AB_WUl6zTdW(x, _A, _B);
    else
        return BA_WUl6zTdW(x, _A, _B);

}

static int cycleA_outer_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    if (x & 1)
        return cycleA_inner_WUl6zTdW((x + 1), _A, _B) + AB_WUl6zTdW(x, _A, _B);
    else
        return BA_WUl6zTdW(x, _A, _B);

}

static int cycleB_inner_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    if (x & 2)
        return either_WUl6zTdW((x + 1), _A, _B) + BA_WUl6zTdW(x, _A, _B);
    else
        return AB_WUl6zTdW(x, _A, _B);

}

static int cycleB_outer_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    if (x & 2)
        return cycleB_inner_WUl6zTdW((x + 1), _A, _B) + BA_WUl6zTdW(x, _A, _B);
    else
        return AB_WUl6zTdW(x, _A, _B);

}

static int either_WUl6zTdW(const int x, const fu::vec<int>& _A, const fu::vec<fu::u8>& _B)
{
    if (x & 4)
        return cycleA_outer_WUl6zTdW(x, _A, _B);
    else
        return cycleB_outer_WUl6zTdW(x, _A, _B);

}

int fu_MAIN()
{
    fu::vec<int> _A = fu::vec<int> { fu::slate<3, int> { 0, 1, 2 } };
    fu::vec<fu::u8> _B = fu::vec<fu::u8> { fu::slate<3, fu::u8> { fu::u8(unsigned(0)), fu::u8(unsigned(1)), fu::u8(unsigned(2)) } };
    return either_WUl6zTdW(0, _A, _B);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn if0_ret101(x: i32) {
            if      (x > 2) return x * 2;
            else if (x > 1) return x + 1; // <- left branch seeded right with never
            return x + 101;
        }

        fn main() 0.if0_ret101 - 101;

-----

#ifndef fu_NO_fdefs

static int if0_ret101_1WsbUdat(const int x)
{
    if (x > 2)
        return x * 2;
    else if (x > 1)
        return x + 1;

    return x + 101;
}

int fu_MAIN()
{
    return if0_ret101_1WsbUdat(0) - 101;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn hello(x: i32) {
            if (x & 1)
                return x * 2;


            x;            
        }

        fn main() 0.hello;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:13+1[0m:

[2m      | [0m
[2m      | [0m
[2m    7 | [0m            [31;1mx[0m;            
[2m      |         }[0m
[2m      | [0m

	Missing final return: No common supertype: i32 copy | void

        Solving [35;1mfn[0m [34;1mhello[0m(i32) at [2m2:12+5[0m

-----

        fn hello(x: i32) {
            if (x & 1)
                return x * 2;


            return x;     
        }

        fn main() 0.hello;

-----

#ifndef fu_NO_fdefs

static int hello_1WsbUdat(const int x)
{
    if (x & 1)
        return x * 2;
    else
        return x;

}

int fu_MAIN()
{
    return hello_1WsbUdat(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn throws()         { throw("WHAT!");   }
        fn myfn(a = throws) { return a;         } // never in default argument position!
        fn main() {
            try             { return myfn();                }
            catch (e)       { return e == "WHAT!" ? 0 : 1;  }
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never throws_H9fhQUVP()
{
    fu::fail("WHAT!"_fu);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{

    try
    {
        throws_H9fhQUVP();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

    {
        if (e == "WHAT!"_fu)
            return 0;
        else
            return 1;

    }
    }
;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

-----

        fn printus(parts: string[], implicit ref out: i32)
            parts.each(|part| part.each(|c| out += c.i32 ));


        lax     
        fn silent(lax parts) {}

        fn main() {
            implicit mut out: i32;

            printus([ "Hel","lo" ]);
            if (out != 500)
                return 1;

            // Tries to test dead array literals.
            shadow let printus = fn silent;

            printus([ "Hel","lo" ]);
            return out == 500 ? 0 : 1;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_1_cY7pBKBe(const char c, int& out)
{
    return (out += int(fu::u8(c)));
}

                                #ifndef DEF_each_233QRH34N1c
                                #define DEF_each_233QRH34N1c
inline void each_233QRH34(fu::view<char> a, int& out)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_cY7pBKBe(a[i], out);

}
                                #endif

inline static void l_1_0_AkLzOyeg(fu::view<char> part, int& out)
{
    each_233QRH34(part, out);
}

                                #ifndef DEF_each_EG2tGyD69Qb
                                #define DEF_each_EG2tGyD69Qb
inline void each_EG2tGyD6(fu::view<fu::str> a, int& out)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_AkLzOyeg(a[i], out);

}
                                #endif

static void printus_YTP4acFR(fu::view<fu::str> parts, int& out)
{
    each_EG2tGyD6(parts, out);
}

int fu_MAIN()
{
    int out {};
    printus_YTP4acFR((fu::slate<2, fu::str> { "Hel"_fu, "lo"_fu }), out);
    if (out != 500)
        return 1;
    else if (out == 500)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedArrlit

-----

        fn printus(parts: string[], implicit ref out: i32)
            parts.each(|part| part.each(|c| out += c.i32 ));


        inline  
        fn silent(lax parts) {}

        fn main() {
            implicit mut out: i32;

            printus([ "Hel","lo" ]);
            if (out != 500)
                return 1;

            // Tries to test dead array literals.
            shadow let printus = fn silent;

            printus([ "Hel","lo" ]);
            return out == 500 ? 0 : 1;
        }

-----
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_1_cY7pBKBe(const char c, int& out)
{
    return (out += int(fu::u8(c)));
}

                                #ifndef DEF_each_233QRH34N1c
                                #define DEF_each_233QRH34N1c
inline void each_233QRH34(fu::view<char> a, int& out)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_cY7pBKBe(a[i], out);

}
                                #endif

inline static void l_1_0_AkLzOyeg(fu::view<char> part, int& out)
{
    each_233QRH34(part, out);
}

                                #ifndef DEF_each_EG2tGyD69Qb
                                #define DEF_each_EG2tGyD69Qb
inline void each_EG2tGyD6(fu::view<fu::str> a, int& out)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_AkLzOyeg(a[i], out);

}
                                #endif

static void printus_YTP4acFR(fu::view<fu::str> parts, int& out)
{
    each_EG2tGyD6(parts, out);
}

int fu_MAIN()
{
    int out {};
    printus_YTP4acFR((fu::slate<2, fu::str> { "Hel"_fu, "lo"_fu }), out);
    if (out != 500)
        return 1;
    else if (out == 500)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedArrlit, N_UnusedLet

-----

        struct X { i: i32; };

        fn         ++(using x: &mut X) ++i;
        postfix fn ++(using x: &mut X) i++;

        fn main() {
            mut x: X;
            let a = x++;
            let b = ++x;
            return a || b - 2;
        }

-----
struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int operator++(s_X& x, /*postfix*/int)
{
    return x.i++;
}

static int& operator++(s_X& x)
{
    return ++x.i;
}

int fu_MAIN()
{
    s_X x {};
    const int a = x++;
    const int /*x*/ b = ++x;
    return a ? a : (b - 2);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(s: $T) {
            mut sum = 0;
            for (fieldname i: $T) sum += s.i;
            return sum;
        }

        struct XY { x: i32; y: i32; };

        fn main() {
            let thing = XY(1, 2);
            let sum = test(thing);
            return sum - 3;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int test_7aw2rGek(const s_XY& s)
{
    int sum = 0;

    {
        sum += s.x;
        sum += s.y;
    };
    return sum;
}

int fu_MAIN()
{
    const s_XY thing = s_XY { 1, 2 };
    const int sum = test_7aw2rGek(thing);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct ScopeSkip     { imports:     i32[]; implicits:     i32[]; }
        struct ScopeSkipMemo { imports_len: i32;   implicits_len: i32;   }

        fn snap(ss: ScopeSkip) {
            mut r: ScopeSkipMemo;
            for (fieldname i: typeof(ss))
                r.i_len = ss.i.len;

            return r;
        }

        fn check(v) {
            mut sum = 0; mut mul = 1;
            for (fieldname i: typeof(v)) {
                sum += v.i * mul; mul *= 10;
            }

            return sum;
        }

        fn main() check(snap(ScopeSkip([ 1 ], [ 2, 2 ]))) - 21;

-----
#include <fu/vec.h>

struct s_ScopeSkip;
struct s_ScopeSkipMemo;

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    fu::vec<int> imports;
    fu::vec<int> implicits;
    explicit operator bool() const noexcept
    {
        return false
            || imports
            || implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeSkipMemo
                                #define DEF_s_ScopeSkipMemo
struct s_ScopeSkipMemo
{
    int imports_len;
    int implicits_len;
    explicit operator bool() const noexcept
    {
        return false
            || imports_len
            || implicits_len
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_ScopeSkipMemo snap_x1EqsjZ8(const s_ScopeSkip& ss)
{
    s_ScopeSkipMemo r {};

    {
        r.imports_len = ss.imports.size();
        r.implicits_len = ss.implicits.size();
    };
    return r;
}

inline static int check_x5aPGH3y(const s_ScopeSkipMemo& v)
{
    int sum = 0;
    int mul = 1;

    {

        {
            sum += (v.imports_len * mul);
            mul *= 10;
        };
        sum += (v.implicits_len * mul);
        mul *= 10;
    };
    return sum;
}

int fu_MAIN()
{
    return check_x5aPGH3y(snap_x1EqsjZ8(s_ScopeSkip { fu::vec<int> { fu::slate<1, int> { 1 } }, fu::vec<int> { fu::slate<2, int> { 2, 2 } } })) - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Lazy(getValue) {
            struct Lazy {
                evaluated?: bool;
                value?:     typeof(getValue());
                getValue?:  typeof(fn getValue);
            };

            return Lazy();
        }

        fn get(ref lazy) {
            if (!lazy.evaluated) {
                lazy.evaluated  = true;

                // This is just exploratory stuff,
                //  don't feel obliged to keep this working.
                let getValue    = lazy.getValue;
                lazy.value      = getValue();
            }

            return lazy.value;
        }

        fn main() {
            mut calls   = 0;
            mut lazy    = Lazy(|| calls++);
            mut res     = lazy.get() + lazy.get();

            return res == 0 && calls == 1 ? 0 : 1;
        }

-----
struct s_Lazy_QJ4e6yjq8qk;

                                #ifndef DEF_s_Lazy_QJ4e6yjq8qk
                                #define DEF_s_Lazy_QJ4e6yjq8qk
struct s_Lazy_QJ4e6yjq8qk
{
    bool evaluated;
    int value;
    s_Lazy_QJ4e6yjq8qk(const s_Lazy_QJ4e6yjq8qk&) = delete;
    s_Lazy_QJ4e6yjq8qk(s_Lazy_QJ4e6yjq8qk&&) = default;
    s_Lazy_QJ4e6yjq8qk& operator=(const s_Lazy_QJ4e6yjq8qk&) = delete;
    s_Lazy_QJ4e6yjq8qk& operator=(s_Lazy_QJ4e6yjq8qk&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || evaluated
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Lazy_QJ4e6yjq8qk Lazy_MhOAVMs2()
{
    return s_Lazy_QJ4e6yjq8qk{};
}

static int l_1_0_hpa9AihZ(int& calls)
{
    return calls++;
}

inline static int& get_XaAUR7GE(s_Lazy_QJ4e6yjq8qk& lazy, int& calls)
{
    if (!lazy.evaluated)
    {
        lazy.evaluated = true;
        lazy.value = l_1_0_hpa9AihZ(calls);
    };
    return lazy.value;
}

int fu_MAIN()
{
    int calls = 0;
    s_Lazy_QJ4e6yjq8qk lazy = Lazy_MhOAVMs2();
    int _0 {};
    const int res = (_0 = get_XaAUR7GE(lazy, calls), (_0 + get_XaAUR7GE(lazy, calls)));
    if ((res == 0) && (calls == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_BckMustSeq

-----

        fn test() [] => i32;
        fn main() test;

-----

#ifndef fu_NO_fdefs

static int test_H9fhQUVP()
{
    return 0;
}

int fu_MAIN()
{
    return test_H9fhQUVP();
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {

            if !(false) return 0;   
            DOESNT_EXIST();
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn main() {

            if (!false) return 0;   
            DOESNT_EXIST();
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn main() {

            if (true) return 0;     
            DOESNT_EXIST();
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn test(a) {
            if (typeof(a) -> _[:])
                return a.len;

            return a * 10;
        }

        fn main() {
            let A = [ 0, 1 ].test;
            let B = 4.test;
            return A + B == 42 ? 0 : 1;
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int test_zj1tLGtT(fu::view<int> a)
{
    return a.size();
}

inline static int test_rgx2eiBu(const int a)
{
    return a * 10;
}

int fu_MAIN()
{
    const int A = test_zj1tLGtT((fu::slate<2, int> { 0, 1 }));
    const int B = test_rgx2eiBu(4);
    if ((A + B) == 42)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn staticIfSymmetry(

            ref a: $U[], b)  
        {
            let N = typeof(b) ->  $T   ? 1 : 2;
            let M = typeof(b) -> [$T;] ? 2 : 1;
            a ~= b;
            return N == M ? 0 : 1;
        }

        fn main() {
            mut arr = [ 0 ];
            return staticIfSymmetry(arr, 0)
                 + staticIfSymmetry(arr, [ 0, 0 ])
                 + arr.len * 10 - 40;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:35+1[0m:

[2m      |             ref a: $U[], b)  [0m
[2m      |         {[0m
[2m    6 | [0m            let N = typeof(b) ->  [31;1m$[0mT   ? 1 : 2;
[2m      |             let M = typeof(b) -> [$T;] ? 2 : 1;[0m
[2m      |             a ~= b;[0m

	Bad call to [34;1m$T[0m: [34;1m$T[0m is not defined here.

        Solving [35;1mfn[0m [34;1mstaticIfSymmetry[0m(i32[:], i32) at [2m2:12+16[0m
                [35;1mfn[0m [34;1mmain[0m at [2m12:12+4[0m

-----

        fn staticIfSymmetry(

            ref a: $T[], b)  
        {
            let N = typeof(b) ->  $T   ? 1 : 2;
            let M = typeof(b) -> [$T;] ? 2 : 1;
            a ~= b;
            return N == M ? 0 : 1;
        }

        fn main() {
            mut arr = [ 0 ];
            return staticIfSymmetry(arr, 0)
                 + staticIfSymmetry(arr, [ 0, 0 ])
                 + arr.len * 10 - 40;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

inline static int staticIfSymmetry_uFmG0Ccf(fu::vec<int>& a, const int b)
{
    const int N = 1;
    const int M = 1;
    a += b;
    if (N == M)
        return 0;
    else
        return 1;

}

inline static int staticIfSymmetry_tPQwHJmw(fu::vec<int>& a, fu::view<int> b)
{
    const int N = 2;
    const int M = 2;
    a += b;
    if (N == M)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<1, int> { 0 } };
    int _0 {};
    int _1 {};
    return (_1 = (_0 = staticIfSymmetry_uFmG0Ccf(arr, 0), (_0 + staticIfSymmetry_tPQwHJmw(arr, (fu::slate<2, int> { 0, 0 })))), (_1 + (arr.size() * 10))) - 40;
}

#endif

int main() { return fu_MAIN(); }

// N_BckMustSeq

-----

        fn main() {
            let a: f32 = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+8[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f32 = 1;[0m
[2m    4 | [0m            let b = a.[31;1munsigned[0m;
[2m      |             let c = a.signed;[0m
[2m      |             if (typeof(a) -> u32) return 1;[0m

	Bad call to [34;1munsigned[0m with args (f32 copy AlwaysTrue): 

	[35;1mtemplate[0m [34;1munsigned[0m at [2m../../../../../[0mprelude[2m 79:4+8[0m:
[2m   79 | [0mfn [31;1munsigned[0m !T(v: T)

	    No body pattern matched.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let a: i32 = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedLet

-----

        fn main() {
            let a: f64 = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+6[0m:

[2m      |         fn main() {[0m
[2m      |             let a: f64 = 1;[0m
[2m    4 | [0m            let b = a.[31;1msigned[0m;
[2m      |             let c = a.unsigned;[0m
[2m      |             if (typeof(a) -> i64) return 1;[0m

	Bad call to [34;1msigned[0m with args (f64 copy AlwaysTrue): 

	[35;1mtemplate[0m [34;1msigned[0m at [2m../../../../../[0mprelude[2m 87:4+6[0m:
[2m   87 | [0mfn [31;1msigned[0m !T(v: T)

	    No body pattern matched.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let a: u64 = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedCall, N_UnusedLet

-----

        fn main() {
            mut a = 1;
            mut b = 0;
            {
                defer a++;
                b = a;
            }
            return (b+1) - a;
        }

-----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;

    {
        fu_DEFER(a++);
        b = a;
    };
    return (b + 1) - a;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut a = 1;
            mut b = 0;
            mut c = 0;
            {
                defer a++;
                defer c = a;
                b = a;
            }
            return (b*27) - (a*11 + c*5);
        }

-----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 1;
    int b = 0;
    int c = 0;

    {
        fu_DEFER(a++);
        fu_DEFER(c = a);
        b = a;
    };
    return (b * 27) - ((a * 11) + (c * 5));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test_defer_if_errok(throw_err: bool) {
            mut x      = 1;
            mut if_err = 0;
            mut if_ok  = 0;
            try {
                defer x++;
                defer:err if_err += x;
                defer:ok  if_ok  += x;

                if (throw_err)
                    throw("len=5");

                x += 8; // 9 defer++ = 10
            }
            catch (e) {
                x += e.len; // 6 defer++ = 7
            }

            return x * 3 + if_err * 5 + if_ok * 7;
        }

        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)
            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);

-----
#include <fu/str.h>
#include <fu/defer.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_defer_if_errok_MG5H1voF(const bool throw_err)
{
    int x = 1;
    int if_err = 0;
    int if_ok = 0;

    try
    {
    {
        fu_DEFER(x++);
        fu_DEFER_IF_ERR(if_err += x);
        fu_DEFER_IF_OK(if_ok += x);
        if (throw_err)
            fu::fail("len=5"_fu);
        else
            x += 8;

    }
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        x += e.size();
    }
;
    return ((x * 3) + (if_err * 5)) + (if_ok * 7);
}

int fu_MAIN()
{
    return (((test_defer_if_errok_MG5H1voF(true) - (7 * 3)) - (1 * 5)) - (0 * 7)) + (100 * (((test_defer_if_errok_MG5H1voF(false) - (10 * 3)) - (0 * 5)) - (9 * 7)));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(ref x: i32) {
            x++;

            defer:ok x++;   
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 2 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void test_3JeKX2Qj(int& x)
{
    x++;
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_3JeKX2Qj(x);
    if (x == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(ref x: i32) {
            x++;

            defer x++;      
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 2 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void test_3JeKX2Qj(int& x)
{
    x++;
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_3JeKX2Qj(x);
    if (x == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(ref x: i32) {

            if (x & 1)              // ------ currently highlights the defer
                return x;           //         probably should highlight the semicollon

            x++;
            defer:err x++;
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 1 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:13+5[0m:

[2m      | [0m
[2m      |             x++;[0m
[2m    8 | [0m            [31;1mdefer[0m:err x++;
[2m      |         }[0m
[2m      | [0m

	Missing final return: No common supertype: i32 mutref copy`[35;1mref arg[0m [34;1mx[0m | void

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m2:12+4[0m

-----

        fn test(ref x: i32) {

            x++;
            defer:err x++;
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 1 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static void test_3JeKX2Qj(int& x)
{
    x++;
}

int fu_MAIN()
{
    int x = 0;
    test_3JeKX2Qj(x);
    if (x == 1)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            defer incrarr_by1(:a);
            return a[0] - 1;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>


#ifndef fu_NO_fdefs

static void sum_amulb_ul3bDPWA(fu::view<int> a, fu::view<int> b, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static void incrarr_by1_bJzechqP(fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

}

static int test_GielRYVW(fu::vec<int>& a, int& sum)
{
    fu::vec<int> b { a };
    fu_DEFER(sum_amulb_ul3bDPWA(a, b, sum));
    fu_DEFER(incrarr_by1_bJzechqP(a));
    return a[0] - 1;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int sum = 0;
    const int ret = (100 * test_GielRYVW(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            incrarr_by1(:a);
            return a[0] - 2;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>


#ifndef fu_NO_fdefs

static void sum_amulb_ul3bDPWA(fu::view<int> a, fu::view<int> b, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static void incrarr_by1_bJzechqP(fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

}

static int test_GielRYVW(fu::vec<int>& a, int& sum)
{
    fu::vec<int> b { a };
    fu_DEFER(sum_amulb_ul3bDPWA(a, b, sum));
    incrarr_by1_bJzechqP(a);
    return a[0] - 2;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int sum = 0;
    const int ret = (100 * test_GielRYVW(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            defer for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 1;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>


#ifndef fu_NO_fdefs

static void sum_amulb_ul3bDPWA(fu::view<int> a, fu::view<int> b, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static int test_GielRYVW(fu::vec<int>& a, int& sum)
{
    fu::vec<int> b { a };
    fu_DEFER(sum_amulb_ul3bDPWA(a, b, sum));
    fu_DEFER(for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;);
    return a[0] - 1;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int sum = 0;
    const int ret = (100 * test_GielRYVW(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);


            for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 2;

        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/defer.h>


#ifndef fu_NO_fdefs

static void sum_amulb_ul3bDPWA(fu::view<int> a, fu::view<int> b, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        sum += (a[i] * b[i]);

}

static int test_GielRYVW(fu::vec<int>& a, int& sum)
{
    fu::vec<int> b { a };
    fu_DEFER(sum_amulb_ul3bDPWA(a, b, sum));
    for (int i = 0; i < a.size(); i++)
        a.mutref(i) += 1;

    return a[0] - 2;
}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<1, int> { 1 } };
    int sum = 0;
    const int ret = (100 * test_GielRYVW(a, sum));
    return (sum - 2) + ret;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn main() {
            mut res = 1;            // single statement blocks unwrap
            { defer res--; }        //  fix by unwraping tailing defers
            return res;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int res = 1;
    res--;
    return res;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn unwraps_defer(ref x: i32) unwrap {
            defer x++;
        }

        fn main() {
            mut y = 0;
            { unwraps_defer(y); }
            mut x = 0;
            unwraps_defer(x);
            return y == 1 && x == 0 ? 0 : 1;
        }

-----
#include <fu/defer.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int y = 0;
    y++;
    int x = 0;
    fu_DEFER(x++);
    if ((y == 1) && (x == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        type Test = i8;
        fn main() 256.Test.i32;

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::i8(256));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a: $A, b: $B) b +   
            a;                      

        fn main() i8(-1).test(+1);

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:33+1[0m:

[2m      | [0m
[2m    2 | [0m        fn test(a: $A, b: $B) b [31;1m+[0m   
[2m      |             a;                      [0m
[2m      | [0m

	Bad call to [34;1m+[0m with args (i32 copy, i8 copy): 

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: i32 Typename <-> i8 Typename

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mtest[0m(i8, i32) at [2m2:12+4[0m
                [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn test(a: $A, b: $B) b +   
            $B(a);                  

        fn main() i8(-1).test(+1);

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

inline static int test_hUay6shI(const fu::i8 a, const int b)
{
    return b + int(a);
}

int fu_MAIN()
{
    return test_hUay6shI(fu::i8(-1), +1);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Test { v: u32 };
        fn test(v   

            ): Test = [ v ];

        fn main() test(2).v == 2 ? 0 : 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:23+1[0m:

[2m      |         fn test(v   [0m
[2m      | [0m
[2m    5 | [0m            ): Test = [31;1m[[0m v ];
[2m      | [0m
[2m      |         fn main() test(2).v == 2 ? 0 : 1;[0m

	Bad call to [35;1mtype[0m [34;1mTest[0m with args (i32 copy): 

	[35;1mtype[0m [34;1mTest[0m at [2m2:9+6[0m:
[2m    2 | [0m        [31;1mstruct[0m Test { v: u32 };

	    [35;1marg[0m [34;1mv[0m expects u32 copy, got i32 copy

        Solving [35;1mfn[0m [34;1mtest[0m(i32) at [2m3:12+4[0m
                [35;1mfn[0m [34;1mmain[0m at [2m7:12+4[0m

-----

        struct Test { v: u32 };
        fn test(v   
                 : u32  
            ): Test = [ v ];

        fn main() test(2).v == 2 ? 0 : 1;

-----
struct s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
struct s_Test
{
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Test test_0sygvzDN(const unsigned v)
{
    return s_Test { v };
}

int fu_MAIN()
{
    if (test_0sygvzDN(2u).v == 2u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        let x = { mut z = 0; z++; z };
        return x - 1;

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    // Hoisted:
    int z;

    const int /*z*/ x = (z = 0, z++, z);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn mul2(a) a*2;
        fn test(b, fn) fn(1 + fn(b));
        fn main() 14 - test(3, fn mul2);

-----

#ifndef fu_NO_fdefs

inline static int mul2_rgx2eiBu(const int a)
{
    return a * 2;
}

inline static int test_fcV3GGI7(const int b)
{
    return mul2_rgx2eiBu((1 + mul2_rgx2eiBu(b)));
}

int fu_MAIN()
{
    return 14 - test_fcV3GGI7(3);
}

#endif

int main() { return fu_MAIN(); }

-----

        let overloaded = 1;
        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() 14 - test(3, fn overloaded);

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_overloaded
                                #define DEF_overloaded
inline constexpr int overloaded = 1;
                                #endif

inline static int overloaded_rgx2eiBu(const int a)
{
    return a * 2;
}

inline static int test_D12MWnF5(const int b)
{
    return overloaded_rgx2eiBu((overloaded + overloaded_rgx2eiBu(b)));
}

int fu_MAIN()
{
    return 14 - test_D12MWnF5(3);
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() {
            let overloaded = 1;
            return 14 - test(3, fn overloaded);
        }

-----

#ifndef fu_NO_fdefs

inline static int overloaded_rgx2eiBu(const int a)
{
    return a * 2;
}

inline static int test_uv8ClR3t(const int b, const int overloaded)
{
    return overloaded_rgx2eiBu((overloaded + overloaded_rgx2eiBu(b)));
}

int fu_MAIN()
{
    const int overloaded = 1;
    return 14 - test_uv8ClR3t(3, overloaded);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn MAP(items: $T[], fn) {
            mut result: typeof( fn(items[0]) )[];
            for (mut i = 0; i < items.len; i++)
                result.push(fn(items[i]));

            return result;
        }

        fn sqr(x) x*x;

        fn main() [2].MAP(fn sqr)[0] - 4;

        // EXPECT (fu::slate<1, int> { 2 })
        //  During the propagateType rework
        //   the 'mut result: fn(items[0])[]' type annot
        //    was found listed as a callsite for items,
        //     but wasn't reachable for relax.

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int sqr_1WsbUdat(const int x)
{
    return x * x;
}

inline static fu::vec<int> MAP_cKV9nErz(fu::view<int> items)
{
    /*MOV*/ fu::vec<int> result {};
    for (int i = 0; i < items.size(); i++)
        result.push(sqr_1WsbUdat(items[i]));

    return /*NRVO*/ result;
}

int fu_MAIN()
{
    return MAP_cKV9nErz((fu::slate<1, int> { 2 }))[0] - 4;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn reduce(items: $T[], fn, init?: $T) {
            mut result = init;
            for (mut i = 0; i < items.len; i++)
                result = fn(result, items[i]);

            return result;
        }

        fn main() [1, 2].reduce(|a, b| a + b) - 3;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int l_1_0_pgT46eOk(const int a, const int b)
{
    return a + b;
}

inline static int reduce_3njwwYkd(fu::view<int> items, const int init)
{
    int result = init;
    for (int i = 0; i < items.size(); i++)
        result = l_1_0_pgT46eOk(result, items[i]);

    return result;
}

int fu_MAIN()
{
    return reduce_3njwwYkd((fu::slate<2, int> { 1, 2 }), 0) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Each(items: $T[], fn) {
            for (mut i = 0; i < items.len; i++) // <- one i
                fn(items[i]);
        }

        fn main() {
            mut i = 0;                  // <- another i, i got them to shadow each other
            [1, 2].Each: |x| i += x;    //      in the everything-a-free-function
            return i - 3;               //      impl of closures
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_5VriesX5(const int x, int& i)
{
    return (i += x);
}

inline static void Each_13QH1MgC(fu::view<int> items, int& i)
{
    for (int i_1 = 0; i_1 < items.size(); i_1++)
        l_1_0_5VriesX5(items[i_1], i);

}

int fu_MAIN()
{
    int i = 0;
    Each_13QH1MgC((fu::slate<2, int> { 1, 2 }), i);
    return i - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        mut sum = 2;

        fn FnDecl_update(parent_idx: i32) {
            fn Each(fn) fn();
            Each(|| makeDirty(:parent_idx));
        }

        fn makeDirty(parent_idx: i32): void {
            sum += parent_idx;
        }

        FnDecl_update(1);

        return sum - 3;

-----

#ifndef fu_NO_fdefs

static void makeDirty_G9VzvwAh(const int parent_idx, int& sum)
{
    sum += parent_idx;
}

static void l_1_0_P6T2P5fq(const int parent_idx, int& sum)
{
    makeDirty_G9VzvwAh(parent_idx, sum);
}

inline static void Each_iwmc7uxJ(const int parent_idx, int& sum)
{
    l_1_0_P6T2P5fq(parent_idx, sum);
}

static void FnDecl_update_FyEDPfs0(const int parent_idx, int& sum)
{
    Each_iwmc7uxJ(parent_idx, sum);
}

int fu_MAIN()
{
    int sum = 2;
    FnDecl_update_FyEDPfs0(1, sum);
    return sum - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation
                // TODO should work without the continue

                "".len.addret(x)

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

-----
#include <fu/str.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x = 0;
    if (!(x & 1))
        return x;
    else
    {
        const int a = ""_fu.size();
        return a + x;
    };
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCall

-----

        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation
                // TODO should work without the continue

                continue "".len                                 // GNUStmtExpr

            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        // !*MustSeq

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    int BL_3_v {};
    return (__extension__ (
    {
        const int x = 0;
        fu::never BL_2_v {};
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
        (void)0;}), static_cast<fu::never&&>(BL_2_v)) : ""_fu.size()));
    (void)0;}), BL_1_v) * (__extension__ (
    {
        const int x = 1;
        fu::never BL_4_v {};
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
        (void)0;}), static_cast<fu::never&&>(BL_4_v)) : ""_fu.size()));
    (void)0;}), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

-----

        // something complains about no final return
        fn main() {
            let hey = |x: i32| {
                if !(x & 1)
                    return x;                                   // GNUStmtExpr

                "".len + x
            };

            // and this complains about no match for *(void, void)
            return hey(1) * hey(0);
        }

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    int BL_3_v {};
    return (__extension__ (
    {
        const int x = 1;
        fu::never BL_2_v {};
        BL_1_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
        (void)0;}), static_cast<fu::never&&>(BL_2_v)) : (""_fu.size() + x)));
    (void)0;}), BL_1_v) * (__extension__ (
    {
        const int x = 0;
        fu::never BL_4_v {};
        BL_3_v = ((!(x & 1) ? (__extension__ (
        {
            return x;
        (void)0;}), static_cast<fu::never&&>(BL_4_v)) : (""_fu.size() + x)));
    (void)0;}), BL_3_v);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn check(a, b, compare! = infix fn <>)
            compare(a, b);

        fn main() check(0, 0);

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

inline static int check_CHWkHY4a(const int a, const int b)
{
    return x3Cx3E_mJGU9byO(a, b);
}

int fu_MAIN()
{
    return check_CHWkHY4a(0, 0);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a.a)   B(  a * 2); 


        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_B bananas_rgx2eiBu(const int a)
{
    return s_B { (a * 2) };
}

int fu_MAIN()
{
    return bananas_rgx2eiBu(s_A { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a.a)   B(  a * 2); 


-----

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a.a)   B(  a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_rgx2eiBuuy6
                                #define DEF_bananas_rgx2eiBuuy6
inline s_B bananas_rgx2eiBu(const int a)
{
    return s_B { (a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_rgx2eiBu(s_A { 1 }.a).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a)     B(a.a * 2); 


        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_B bananas_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a * 2) };
}

int fu_MAIN()
{
    return bananas_7Nh2jNsJ(s_A { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a)     B(a.a * 2); 


-----

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a)     B(a.a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_bananas_7Nh2jNsJbTc
                                #define DEF_bananas_7Nh2jNsJbTc
inline s_B bananas_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a * 2) };
}
                                #endif

int fu_MAIN()
{
    return bananas_7Nh2jNsJ(s_A { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: A)  B(a.a * 2); 


        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B bananas_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a * 2) };
}

int fu_MAIN()
{
    return bananas_7Nh2jNsJ(s_A { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: A)  B(a.a * 2); 


-----
struct s_B;
struct s_A;

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_B bananas_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a * 2) };
}

#endif

-----

        struct A { a: i32; };
        struct B { b: i32; };


        using fn bananas(a: A)  B(a.a * 2); 

        pub import _0;
        fn main() 1.A.b - 2;

-----
struct s_A;
struct s_B;
s_B bananas_7Nh2jNsJ(const s_A&);

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return bananas_7Nh2jNsJ(s_A { 1 }).b - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sqr(a: i32) a * a;
        fn woot(a.sqr) a + 1;
        fn main() 2.woot - 5;

-----

#ifndef fu_NO_fdefs

static int sqr_rgx2eiBu(const int a)
{
    return a * a;
}

inline static int woot_rgx2eiBu(const int a)
{
    return a + 1;
}

int fu_MAIN()
{
    return woot_rgx2eiBu(sqr_rgx2eiBu(2)) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B  { b:  i32; };

        fn a0(a1: A1) a1.a1 * 100;
        fn bananas(a) B(a.a0 * 2); // <- template
        fn woot(a.bananas: B) a.b; // <- check

        fn main() 1.A0.woot + 1.A1.woot - 202;

-----
struct s_A0;
struct s_B;
struct s_A1;

                                #ifndef DEF_s_A0
                                #define DEF_s_A0
struct s_A0
{
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A1
                                #define DEF_s_A1
struct s_A1
{
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_B bananas_lpHs6oC2(const s_A0& a)
{
    return s_B { (a.a0 * 2) };
}

static int woot_dZN72K8p(const s_B& a)
{
    return a.b;
}

static int a0_vel6scVK(const s_A1& a1)
{
    return a1.a1 * 100;
}

inline static s_B bananas_HXU5Ti5l(const s_A1& a)
{
    return s_B { (a0_vel6scVK(a) * 2) };
}

int fu_MAIN()
{
    return (woot_dZN72K8p(bananas_lpHs6oC2(s_A0 { 1 })) + woot_dZN72K8p(bananas_HXU5Ti5l(s_A1 { 1 }))) - 202;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b0: i32; };
        struct B1 { b1: i32; };
        struct C  { c:  i32; };

        fn bananas(using _: A0) B0(a0 * 2);
        fn bananas(using _: A1) B1(a1 * 3);
        using fn c0(using _: B0) C(c: b0 * 5);
        using fn c1(using _: B1) C(c: b1 * 7);
        fn woot(using a.bananas: C) c; // extra conversion

        fn main() 1.A0.woot + 1.A1.woot - 31;

-----
struct s_A0;
struct s_B0;
struct s_C;
struct s_A1;
struct s_B1;

                                #ifndef DEF_s_A0
                                #define DEF_s_A0
struct s_A0
{
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B0
                                #define DEF_s_B0
struct s_B0
{
    int b0;
    explicit operator bool() const noexcept
    {
        return false
            || b0
        ;
    }
};
                                #endif

                                #ifndef DEF_s_C
                                #define DEF_s_C
struct s_C
{
    int c;
    explicit operator bool() const noexcept
    {
        return false
            || c
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A1
                                #define DEF_s_A1
struct s_A1
{
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B1
                                #define DEF_s_B1
struct s_B1
{
    int b1;
    explicit operator bool() const noexcept
    {
        return false
            || b1
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B0 bananas_LWOzuCnP(const s_A0& _)
{
    return s_B0 { (_.a0 * 2) };
}

static s_C c0_NEUTO2pg(const s_B0& _)
{
    return s_C { (_.b0 * 5) };
}

static int woot_r3oEPEOd(const s_C& a)
{
    return a.c;
}

static s_B1 bananas_IoRNnW8M(const s_A1& _)
{
    return s_B1 { (_.a1 * 3) };
}

static s_C c1_BB1RVGVl(const s_B1& _)
{
    return s_C { (_.b1 * 7) };
}

int fu_MAIN()
{
    return (woot_r3oEPEOd(c0_NEUTO2pg(bananas_LWOzuCnP(s_A0 { 1 }))) + woot_r3oEPEOd(c1_BB1RVGVl(bananas_IoRNnW8M(s_A1 { 1 })))) - 31;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b:  i32; };
        struct B1 { b:  i32; };

        fn bananas(a0: A0) B0(a0.a0 * 2);
        fn bananas(a1: A1) B1(a1.a1 * 3);
        fn woot(a.bananas) a.b; // <- template

        fn main() 1.A0.woot + 1.A1.woot - 5;

-----
struct s_A0;
struct s_B0;
struct s_A1;
struct s_B1;

                                #ifndef DEF_s_A0
                                #define DEF_s_A0
struct s_A0
{
    int a0;
    explicit operator bool() const noexcept
    {
        return false
            || a0
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B0
                                #define DEF_s_B0
struct s_B0
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A1
                                #define DEF_s_A1
struct s_A1
{
    int a1;
    explicit operator bool() const noexcept
    {
        return false
            || a1
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B1
                                #define DEF_s_B1
struct s_B1
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B0 bananas_hak8W46s(const s_A0& a0)
{
    return s_B0 { (a0.a0 * 2) };
}

inline static int woot_69YHlOiT(const s_B0& a)
{
    return a.b;
}

static s_B1 bananas_vel6scVK(const s_A1& a1)
{
    return s_B1 { (a1.a1 * 3) };
}

inline static int woot_QZIauXZR(const s_B1& a)
{
    return a.b;
}

int fu_MAIN()
{
    return (woot_69YHlOiT(bananas_hak8W46s(s_A0 { 1 })) + woot_QZIauXZR(bananas_vel6scVK(s_A1 { 1 }))) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn times_implicit(x: i32, implicit y: i32) x * y;
        fn times7(x: i32) x * 7;

        fn woot(a.times_implicit, b: u32) a * b.i32;
        fn woot(a: i32, b.times7: i32) a * b;

        fn test0() 3.woot(2.i32);

        fn test1() {
            let implicit y = 7;
            return 3.woot(2.u32);
        }

        fn main() test0 + test1 * 1000 - 42042;

-----

#ifndef fu_NO_fdefs

static int times7_1WsbUdat(const int x)
{
    return x * 7;
}

static int woot_hwGp0ETu(const int a, const int b)
{
    return a * b;
}

static int test0_H9fhQUVP()
{
    return woot_hwGp0ETu(3, times7_1WsbUdat(int(2)));
}

static int times_implicit_UXsyOHvH(const int x, const int y)
{
    return x * y;
}

inline static int woot_UYpdw4aN(const int a, const unsigned b)
{
    return a * int(b);
}

static int test1_H9fhQUVP()
{
    const int y = 7;
    return woot_UYpdw4aN(times_implicit_UXsyOHvH(3, y), unsigned(2));
}

int fu_MAIN()
{
    return (test0_H9fhQUVP() + (test1_H9fhQUVP() * 1000)) - 42042;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct X { str: string; };
        fn ~(a: X, b: X) X(a.str ~ b.str);          // currently: invalid operator~ cg
        inline fn ~(a: X, b.to_debug_str) a ~ b;    // currently: pointless blocks

        fn to_debug_str(a: i32) X("i" ~ a);

        fn main() {
            let hey = X("Hey! ") ~ 5;                           // GNUStmtExpr
            return hey.str == "Hey! i5" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    fu::str str;
    explicit operator bool() const noexcept
    {
        return false
            || str
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static s_X to_debug_str_rgx2eiBu(const int a)
{
    return s_X { x7E_gCeFmDFw("i"_fu, fu::i64dec(a)) };
}

static s_X x7E_RTGZzglO(const s_X& a, const s_X& b)
{
    return s_X { (a.str + b.str) };
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    s_X BL_1_v {};
    s_X hey = (__extension__ (
    {
        s_X a = s_X { "Hey! "_fu };
        s_X b = to_debug_str_rgx2eiBu(5);
        BL_1_v = (x7E_RTGZzglO(a, b));
    (void)0;}), static_cast<s_X&&>(BL_1_v));
    if (hey.str == "Hey! i5"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec32  { x: f32; };
        struct conv32 { v: f32; };


        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32


        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        fn main() i32 <| (1/vec32(1)).x - 1;                    // GNUStmtExpr

-----
struct s_vec32;
struct s_conv32;

                                #ifndef DEF_s_vec32
                                #define DEF_s_vec32
struct s_vec32
{
    float x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_conv32
                                #define DEF_s_conv32
struct s_conv32
{
    float v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec32 BL_1_v {};
    return int(((__extension__ (
    {
        s_conv32 BL_2_v {};
        const s_conv32 a = (__extension__ (
        {
            const float v = 1.0f;
            BL_2_v = (s_conv32 { v });
        (void)0;}), static_cast<s_conv32&&>(BL_2_v));
        const s_vec32 b = s_vec32 { 1.0f };
        BL_1_v = (s_vec32 { (a.v / b.x) });
    (void)0;}), static_cast<s_vec32&&>(BL_1_v)).x - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec32  { x: f32; };
        struct conv32 { v: f32; };


        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix


        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        fn main() i32 <| (1/vec32(1)).x - 1;                    // GNUStmtExpr

-----
struct s_vec32;
struct s_conv32;

                                #ifndef DEF_s_vec32
                                #define DEF_s_vec32
struct s_vec32
{
    float x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_conv32
                                #define DEF_s_conv32
struct s_conv32
{
    float v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec32 BL_1_v {};
    return int(((__extension__ (
    {
        s_conv32 BL_2_v {};
        const s_conv32 a = (__extension__ (
        {
            const int v = 1;
            BL_2_v = (s_conv32 { float(v) });
        (void)0;}), static_cast<s_conv32&&>(BL_2_v));
        const s_vec32 b = s_vec32 { 1.0f };
        BL_1_v = (s_vec32 { (a.v / b.x) });
    (void)0;}), static_cast<s_vec32&&>(BL_1_v)).x - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec_u  { x: u32; };
        struct vec32  { x: f32; };
        struct vec64  { x: f64; };

        struct conv_u { v: u32; };
        struct conv32 { v: f32; };
        struct conv64 { v: f64; };

        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before
        using inline fn convert(v: f32): conv32 = [ v ];
        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after

        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);

        fn main() i32 <| (1/vec32(1)).x - 1;                    // GNUStmtExpr

-----
struct s_vec32;
struct s_conv32;

                                #ifndef DEF_s_vec32
                                #define DEF_s_vec32
struct s_vec32
{
    float x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_conv32
                                #define DEF_s_conv32
struct s_conv32
{
    float v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_vec32 BL_1_v {};
    return int(((__extension__ (
    {
        s_conv32 BL_2_v {};
        const s_conv32 a = (__extension__ (
        {
            const float v = 1.0f;
            BL_2_v = (s_conv32 { v });
        (void)0;}), static_cast<s_conv32&&>(BL_2_v));
        const s_vec32 b = s_vec32 { 1.0f };
        BL_1_v = (s_vec32 { (a.v / b.x) });
    (void)0;}), static_cast<s_vec32&&>(BL_1_v)).x - 1.0f));
}

#endif

int main() { return fu_MAIN(); }

-----

        pub struct Module       { modid: i32; };
        pub struct Target       { modid: i32; index: i32; };
        pub struct Type         { using vtype: ValueType; };
        pub struct ValueType    { modid: i32; canon: string; };
        pub struct Overload     { kind: string; locals?: Overload[]; };

        fn main() {
            using fn GET(target: Target, implicit overloads: Overload[]) {
                target.index > 0 || assert();
                if (target.modid < 0)
                    return overloads[-target.modid - 1].locals[target.index - 1];
                else
                    return overloads[target.index - 1];
            }

            fn try_GET(target: Target)
                target && GET(target);

            implicit mut overloads: Overload[];
            overloads ~= Overload("What");
            return try_GET(Target(0, 1)).kind.len - 4;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/default.h>
#include <fu/vec/concat_one.h>

struct s_Overload;
struct s_Target;

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str kind;
    fu::vec<s_Overload> locals;
    s_Overload(const s_Overload&) = default;
    s_Overload(s_Overload&&) = default;
    s_Overload& operator=(s_Overload&&) = default;
    s_Overload& operator=(const s_Overload& selfrec) { return *this = s_Overload(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Overload& GET_aEsc81jq(const s_Target& target, fu::view<s_Overload> overloads)
{
    if (target.index > 0)
    {
        if (target.modid < 0)
            return overloads[(-target.modid - 1)].locals[(target.index - 1)];
        else
            return overloads[(target.index - 1)];

    }
    else
        fu_ASSERT();

}

static const s_Overload& try_GET_vGDcyRxu(const s_Target& target, fu::view<s_Overload> overloads)
{
    if (target)
        return GET_aEsc81jq(target, overloads);
    else
        return (*(const s_Overload*)fu::NIL);

}

int fu_MAIN()
{
    fu::vec<s_Overload> overloads {};
    overloads += s_Overload { "What"_fu, fu::vec<s_Overload>{} };
    return try_GET_vGDcyRxu(s_Target { 0, 1 }, overloads).kind.size() - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_DeadCode

-----

        struct RWEvent { rw_target!: i32 };
        struct ReadID  { id: i32 };

        fn main()
        {

            using   
            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);

            fn rw_target(read: ReadID)  read.id;

            return ReadID(0).rw_target;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 13:30+9[0m:

[2m      |             fn rw_target(read: ReadID)  read.id;[0m
[2m      | [0m
[2m   13 | [0m            return ReadID(0).[31;1mrw_target[0m;
[2m      |         }[0m
[2m      | [0m

	Ambiguous call to [31;1mrw_target[0m, matches multiple items in scope:

	[35;1mfn[0m [34;1mrw_target[0m at [2m11:16+9[0m:
[2m   11 | [0m            fn [31;1mrw_target[0m(read: ReadID)  read.id;

	[35;1mfield[0m [34;1mrw_target[0m at [2m2:26+9[0m:
[2m    2 | [0m        struct RWEvent { [31;1mrw_target[0m!: i32 };

	    [35;1musing[0m [35;1mfn[0m [34;1mRWEvent[0m at [2m8:13+5[0m:
[2m    8 | [0m            [31;1musing[0m   
[2m    9 | [0m            fn [31;1mRWEvent[0m(read: ReadID)    RWEvent(rw_target: read.id);


        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        struct RWEvent { rw_target!: i32 };
        struct ReadID  { id: i32 };

        fn main()
        {

            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);

            fn rw_target(read: ReadID)  read.id;

            return ReadID(0).rw_target;
        }

-----
struct s_ReadID;

                                #ifndef DEF_s_ReadID
                                #define DEF_s_ReadID
struct s_ReadID
{
    int id;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rw_target_wLpypMqE(const s_ReadID& read)
{
    return read.id;
}

int fu_MAIN()
{
    return rw_target_wLpypMqE(s_ReadID { 0 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        using    
        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];

        using
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];

        fn RGB(linear: bool, r: i32) {
            return linear
                 ? linearRGB(r)
                 :      sRGB(r);
        }

        fn main() {
            mut c = RGB(linear: false, 7);
            return c.r - 21;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 14:18+1[0m:

[2m      |         fn RGB(linear: bool, r: i32) {[0m
[2m      |             return linear[0m
[2m   14 | [0m                 [31;1m?[0m linearRGB(r)
[2m      |                  :      sRGB(r);[0m
[2m      |         }[0m

	if/else: Type ambiguity, conversions exist both ways:

	linearRGB -> sRGB:
	    [35;1musing[0m [35;1mfn[0m [34;1mlin2srgb[0m at [2m6:9+5[0m:
[2m    6 | [0m        [31;1musing[0m    
[2m    7 | [0m        fn [31;1mlin2srgb[0m(c: linearRGB): sRGB = [ c.r / 3 ];

	sRGB -> linearRGB:
	    [35;1musing[0m [35;1mfn[0m [34;1msrgb2lin[0m at [2m9:9+5[0m:
[2m    9 | [0m        [31;1musing[0m
[2m   10 | [0m        fn [31;1msrgb2lin[0m(c: sRGB): linearRGB = [ c.r * 3 ];


        Solving [35;1mfn[0m [34;1mRGB[0m(bool, i32) at [2m12:12+3[0m

-----

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];

        using
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];

        fn RGB(linear: bool, r: i32) {
            return linear
                 ? linearRGB(r)
                 :      sRGB(r);
        }

        fn main() {
            mut c = RGB(linear: false, 7);
            return c.r - 21;
        }

-----
struct s_linearRGB;
struct s_sRGB;

                                #ifndef DEF_s_linearRGB
                                #define DEF_s_linearRGB
struct s_linearRGB
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_s_sRGB
                                #define DEF_s_sRGB
struct s_sRGB
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_linearRGB srgb2lin_Y7H2JVrI(const s_sRGB& c)
{
    return s_linearRGB { (c.r * 3) };
}

static s_linearRGB RGB_UlXzYVu2(const bool linear, const int r)
{
    if (linear)
    {
        return s_linearRGB { r };
    }
    else
    {
        return srgb2lin_Y7H2JVrI(s_sRGB { r });
    };
}

int fu_MAIN()
{
    const s_linearRGB c = RGB_UlXzYVu2(false, 7);
    return c.r - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];

        fn main() = (sRGB(r: 3) => linearRGB).r - 21;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 8:26+1[0m:

[2m      |         fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];[0m
[2m      | [0m
[2m    8 | [0m        fn main() = (sRGB[31;1m([0mr: 3) => linearRGB).r - 21;
[2m      | [0m

	Cannot convert: : linearRGB copy <- sRGB copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m8:12+4[0m

-----

        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };


        using                
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];

        fn main() = (sRGB(r: 3) => linearRGB).r - 21;

-----
struct s_sRGB;
struct s_linearRGB;

                                #ifndef DEF_s_sRGB
                                #define DEF_s_sRGB
struct s_sRGB
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

                                #ifndef DEF_s_linearRGB
                                #define DEF_s_linearRGB
struct s_linearRGB
{
    int r;
    explicit operator bool() const noexcept
    {
        return false
            || r
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_linearRGB srgb2lin_Y7H2JVrI(const s_sRGB& c)
{
    return s_linearRGB { (c.r * 7) };
}

int fu_MAIN()
{
    return srgb2lin_Y7H2JVrI(s_sRGB { 3 }).r - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Overload     { name: string; };
        struct Target       { o_index: i32; };

        struct Helpers      { hd_index: i32; };
        struct HelpersData  { target: Target; };

        fn solve(ref overloads: Overload[], ref helpers: HelpersData[])
        {
            using fn GET(h: Helpers)
                helpers[h.hd_index];

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(t: Target) {
                ref o = overloads[t.o_index];

                // The qWHAT here tried to (pointlessly) solve qWHAT below,
                //  but GET hadn't solved yet so it wasn't available.
                return o.qWHAT ? o : GET(Target(t.o_index + 1));
            }

            fn qWHAT(hd: HelpersData)
                hd.target.qWHAT;

            return Helpers(0).qWHAT;
        }

        fn main() {
            mut overloads: Overload[];
            mut helpers: HelpersData[];

            for (mut i = 0; i < 2; i++) {
                overloads ~= Overload(i && "o=" ~ i);
                helpers ~= HelpersData(Target(i));
            }

            return solve(overloads, helpers) == "o=1" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>

struct s_Overload;
struct s_HelpersData;
struct s_Target;
struct s_Helpers;
static s_Overload& GET_ZXr9M5fH(const s_Target&, fu::view_mut<s_Overload>);

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int o_index;
    explicit operator bool() const noexcept
    {
        return false
            || o_index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_HelpersData
                                #define DEF_s_HelpersData
struct s_HelpersData
{
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int hd_index;
    explicit operator bool() const noexcept
    {
        return false
            || hd_index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static s_HelpersData& GET_3xN2XVzZ(const s_Helpers& h, fu::view_mut<s_HelpersData> helpers)
{
    return helpers.mutref(h.hd_index);
}

static const fu::str& qWHAT_8qpkNrJ7(const s_Overload& o)
{
    return o.name;
}

static s_Overload& GET_ZXr9M5fH(const s_Target& t, fu::view_mut<s_Overload> overloads)
{
    s_Overload& /*overloads|static*/ o = overloads.mutref(t.o_index);
    if (qWHAT_8qpkNrJ7(o))
        return o;
    else
    {
        return GET_ZXr9M5fH(s_Target { (t.o_index + 1) }, overloads);
    };
}

static const fu::str& qWHAT_IfAGNmka(const s_HelpersData& hd, fu::view_mut<s_Overload> overloads)
{
    return qWHAT_8qpkNrJ7(GET_ZXr9M5fH(hd.target, overloads));
}

static const fu::str& solve_QE72T6IE(fu::view_mut<s_Overload> overloads, fu::view_mut<s_HelpersData> helpers)
{
    const s_HelpersData* _0;
    return (_0 = &(GET_3xN2XVzZ(s_Helpers { 0 }, helpers)), qWHAT_IfAGNmka(*_0, overloads));
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::vec<s_Overload> overloads {};
    fu::vec<s_HelpersData> helpers {};
    for (int i = 0; i < 2; i++)
    {
        overloads += s_Overload { (i ? x7E_gCeFmDFw("o="_fu, fu::i64dec(i)) : fu::str{}) };
        helpers += s_HelpersData { s_Target { i } };
    };
    if (solve_QE72T6IE(overloads, helpers) == "o=1"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_AARMustSeq

-----

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {

                return n.map(|t| t.qWHAT).join();

            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

struct s_Overload;
struct s_Target;
static const s_Overload& GET_XGBVJTLP(const s_Target&, fu::view<s_Overload>, fu::view<s_Target>);

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& qWHAT_n4Bi0qtE(const s_Overload& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_JYnom89o(/*MOV*/ fu::str&& reason, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    for (int i = _targets.size(); i-- > 0; )
    {
        const s_Target& /*_targets|static*/ t = _targets[i];
        if (t)
            reason += qWHAT_n4Bi0qtE(GET_XGBVJTLP(t, _overloads, _targets));

    };
    fu::fail(static_cast<fu::str&&>(reason));
}

static const s_Overload& GET_XGBVJTLP(const s_Target& target, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    if ((_overloads.size() >= target.index))
        return _overloads[target.index];
    else
    {
        fail_JYnom89o(fu::str(qWHAT_n4Bi0qtE(GET_XGBVJTLP(s_Target { (_overloads.size() - 1) }, _overloads, _targets))), _overloads, _targets);
    };
}

inline static const fu::str& l_1_0_x2Ngl3K6(const s_Target& t, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    return qWHAT_n4Bi0qtE(GET_XGBVJTLP(t, _overloads, _targets));
}

                                #ifndef DEF_map_ZPeHR11S12k
                                #define DEF_map_ZPeHR11S12k
inline fu::vec<fu::str> map_ZPeHR11S(fu::view<s_Target> a, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = fu::str(l_1_0_x2Ngl3K6(a[i], _overloads, _targets));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_6LmAXnK0Otg
                                #define DEF_join_6LmAXnK0Otg
inline fu::str join_6LmAXnK0(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::str qWHAT_yvI3n0tb(fu::view<s_Target> n, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    return join_6LmAXnK0(map_ZPeHR11S(n, _overloads, _targets));
}

static fu::str solve_SzIiQc1N(fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    return qWHAT_yvI3n0tb(_targets, _overloads, _targets);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_SzIiQc1N((fu::slate<4, s_Overload> { s_Overload { "Hello"_fu }, s_Overload { ", "_fu }, s_Overload { "! "_fu }, s_Overload { "World!"_fu } }), (fu::slate<3, s_Target> { s_Target { 0 }, s_Target { 1 }, s_Target { 3 } }));
    if (res == "Hello, World!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {

                mut res = "";
                for (mut i = 0; i < n.len; i++)
                    res ~= n[i].qWHAT;

                return res;

            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/concat.h>

struct s_Overload;
struct s_Target;
static const s_Overload& GET_XGBVJTLP(const s_Target&, fu::view<s_Overload>, fu::view<s_Target>);

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::str name;
    explicit operator bool() const noexcept
    {
        return false
            || name
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::str& qWHAT_n4Bi0qtE(const s_Overload& o)
{
    return o.name;
}

[[noreturn]] static fu::never fail_JYnom89o(/*MOV*/ fu::str&& reason, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    for (int i = _targets.size(); i-- > 0; )
    {
        const s_Target& /*_targets|static*/ t = _targets[i];
        if (t)
            reason += qWHAT_n4Bi0qtE(GET_XGBVJTLP(t, _overloads, _targets));

    };
    fu::fail(static_cast<fu::str&&>(reason));
}

static const s_Overload& GET_XGBVJTLP(const s_Target& target, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    if ((_overloads.size() >= target.index))
        return _overloads[target.index];
    else
    {
        fail_JYnom89o(fu::str(qWHAT_n4Bi0qtE(GET_XGBVJTLP(s_Target { (_overloads.size() - 1) }, _overloads, _targets))), _overloads, _targets);
    };
}

static fu::str qWHAT_yvI3n0tb(fu::view<s_Target> n, fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    /*MOV*/ fu::str res = ""_fu;
    for (int i = 0; i < n.size(); i++)
        res += qWHAT_n4Bi0qtE(GET_XGBVJTLP(n[i], _overloads, _targets));

    return /*NRVO*/ res;
}

static fu::str solve_SzIiQc1N(fu::view<s_Overload> _overloads, fu::view<s_Target> _targets)
{
    return qWHAT_yvI3n0tb(_targets, _overloads, _targets);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str res = solve_SzIiQc1N((fu::slate<4, s_Overload> { s_Overload { "Hello"_fu }, s_Overload { ", "_fu }, s_Overload { "! "_fu }, s_Overload { "World!"_fu } }), (fu::slate<3, s_Target> { s_Target { 0 }, s_Target { 1 }, s_Target { 3 } }));
    if (res == "Hello, World!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn a_slash_b(a: f32, b: f32) {
            return a ~ "/" ~ b;
        }

        fn main() {
            return a_slash_b(1, 2) == "1.000000/2.000000" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str a_slash_b_tuHuzKaE(const float a, const float b)
{
    return x7E_gCeFmDFw(x7E_gCeFmDFw(fu::f32dec(a), "/"_fu), fu::f32dec(b));
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if (a_slash_b_tuHuzKaE(1.0f, 2.0f) == "1.000000/2.000000"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;

            return s + u;             
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:22+1[0m:

[2m      |             let u: u32 =  3;[0m
[2m      | [0m
[2m    6 | [0m            return s [31;1m+[0m u;             
[2m      |         }[0m
[2m      | [0m

	Bad call to [34;1m+[0m with args (i32 copy AlwaysTrue, u32 copy AlwaysTrue): 

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 9:10+1[0m:
[2m    9 | [0minfix fn [31;1m+[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: i32 Typename <-> u32 Typename

	[35;1mtemplate[0m [34;1m+[0m at [2m../../../../../[0mprelude[2m 6:11+1[0m:
[2m    6 | [0mprefix fn [31;1m+[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;

            return s + u.i32;         
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int s = -3;
    const unsigned u = 3u;
    return s + int(u);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        using 
        fn toEnd(midb: MidB) End(midb.b * 7);
        <split/>

        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 18:26+1[0m:

[2m      |         fn main() {[0m
[2m      |             let start = Start(1);[0m
[2m   18 | [0m            return start.[31;1me[0m - 2*5;
[2m      |         }[0m
[2m      | [0m

	Conversion ambiguity, multiple ways to convert Start copy into End:

	    [35;1musing[0m [35;1mfn[0m [34;1mtoMidA[0m at [2m7:9+5[0m:
[2m    7 | [0m        [31;1musing[0m fn [31;1mtoMidA[0m(start: Start) MidA(start.s * 2);
	    [35;1musing[0m [35;1mfn[0m [34;1mtoEnd[0m at [2m9:9+5[0m:
[2m    9 | [0m        [31;1musing[0m fn [31;1mtoEnd[0m(mida: MidA) End(mida.a * 5);

	and:

	    [35;1musing[0m [35;1mfn[0m [34;1mtoMidB[0m at [2m8:9+5[0m:
[2m    8 | [0m        [31;1musing[0m fn [31;1mtoMidB[0m(start: Start) MidB(start.s * 3);
	    [35;1musing[0m [35;1mfn[0m [34;1mtoEnd[0m at [2m12:9+5[0m:
[2m   12 | [0m        [31;1musing[0m 
[2m   13 | [0m        fn [31;1mtoEnd[0m(midb: MidB) End(midb.b * 7);


        Solving [35;1mfn[0m [34;1mmain[0m at [2m16:12+4[0m

-----

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        fn toEnd(midb: MidB) End(midb.b * 7);


        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

-----
struct s_Start;
struct s_MidA;
struct s_End;

                                #ifndef DEF_s_Start
                                #define DEF_s_Start
struct s_Start
{
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_s_MidA
                                #define DEF_s_MidA
struct s_MidA
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_End
                                #define DEF_s_End
struct s_End
{
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_MidA toMidA_5UiHrChf(const s_Start& start)
{
    return s_MidA { (start.s * 2) };
}

static s_End toEnd_PPftlZPC(const s_MidA& mida)
{
    return s_End { (mida.a * 5) };
}

int fu_MAIN()
{
    const s_Start start = s_Start { 1 };
    return toEnd_PPftlZPC(toMidA_5UiHrChf(start)).e - (2 * 5);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        fn toEnd(midb: MidB) End(midb.b * 7);

-----
struct s_MidA;
struct s_Start;
struct s_MidB;
struct s_End;

                                #ifndef DEF_s_MidA
                                #define DEF_s_MidA
struct s_MidA
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Start
                                #define DEF_s_Start
struct s_Start
{
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_s_MidB
                                #define DEF_s_MidB
struct s_MidB
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_End
                                #define DEF_s_End
struct s_End
{
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_MidA toMidA_5UiHrChf(const s_Start& start)
{
    return s_MidA { (start.s * 2) };
}

s_MidB toMidB_5UiHrChf(const s_Start& start)
{
    return s_MidB { (start.s * 3) };
}

s_End toEnd_PPftlZPC(const s_MidA& mida)
{
    return s_End { (mida.a * 5) };
}

s_End toEnd_4Z1fNQ0v(const s_MidB& midb)
{
    return s_End { (midb.b * 7) };
}

#endif

-----

        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);


        fn toEnd(midb: MidB) End(midb.b * 7);
        pub import _0;

        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }

-----
struct s_Start;
struct s_MidA;
struct s_End;
s_MidA toMidA_5UiHrChf(const s_Start&);
s_End toEnd_PPftlZPC(const s_MidA&);

                                #ifndef DEF_s_Start
                                #define DEF_s_Start
struct s_Start
{
    int s;
    explicit operator bool() const noexcept
    {
        return false
            || s
        ;
    }
};
                                #endif

                                #ifndef DEF_s_MidA
                                #define DEF_s_MidA
struct s_MidA
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_End
                                #define DEF_s_End
struct s_End
{
    int e;
    explicit operator bool() const noexcept
    {
        return false
            || e
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Start start = s_Start { 1 };
    return toEnd_PPftlZPC(toMidA_5UiHrChf(start)).e - (2 * 5);
}

#endif

int main() { return fu_MAIN(); }

-----

        struct vec3 { x: i32 };
        fn woot(
            using a: vec3,

            using 
            b: vec3)
        {
            return x + b.x;
        }

        fn main() vec3(1).woot(vec3(-1));

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:20+1[0m:

[2m      |             b: vec3)[0m
[2m      |         {[0m
[2m    9 | [0m            return [31;1mx[0m + b.x;
[2m      |         }[0m
[2m      | [0m

	[31;1musing[0m ambiguity, multiple ways to obtain a vec3 in this scope:

	    [35;1musing[0m [35;1marg[0m [34;1ma[0m at [2m4:13+5[0m:
[2m    4 | [0m            [31;1musing[0m [31;1ma[0m: vec3,

	and:

	    [35;1musing[0m [35;1marg[0m [34;1mb[0m at [2m6:13+5[0m:
[2m    6 | [0m            [31;1musing[0m 
[2m    7 | [0m            [31;1mb[0m: vec3)


        Solving [35;1mfn[0m [34;1mwoot[0m(vec3, vec3) at [2m3:12+4[0m

-----

        struct vec3 { x: i32 };
        fn woot(
            using a: vec3,

            b: vec3)
        {
            return x + b.x;
        }

        fn main() vec3(1).woot(vec3(-1));

-----
struct s_vec3;

                                #ifndef DEF_s_vec3
                                #define DEF_s_vec3
struct s_vec3
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int woot_74IzQc29(const s_vec3& a, const s_vec3& b)
{
    return a.x + b.x;
}

int fu_MAIN()
{
    return woot_74IzQc29(s_vec3 { 1 }, s_vec3 { -1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        struct B { v: i32 };
        struct C { v: i32 };


        struct A { v: i32 };
        using fn AB(a: A) B(a.v * 2);
        using fn AC(a: A) C(a.v * 3);


        fn main() {
            let a = A(1);
            let b: B = a;
            let c: C = a;
            return b.v * c.v - 6;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:31+1[0m:

[2m      | [0m
[2m      |         struct A { v: i32 };[0m
[2m    7 | [0m        using fn AB(a: A) B(a.[31;1mv[0m * 2);
[2m      |         using fn AC(a: A) C(a.v * 3);[0m
[2m      | [0m

	Ambiguous call to [31;1mv[0m, matches multiple items in scope:

	[35;1mfield[0m [34;1mv[0m at [2m6:20+1[0m:
[2m    6 | [0m        struct A { [31;1mv[0m: i32 };

	[35;1mfield[0m [34;1mv[0m at [2m3:20+1[0m:
[2m    3 | [0m        struct C { [31;1mv[0m: i32 };

	    [35;1musing[0m [35;1mfn[0m [34;1mAC[0m at [2m8:9+5[0m:
[2m    8 | [0m        [31;1musing[0m fn [31;1mAC[0m(a: A) C(a.v * 3);


        Solving [35;1mfn[0m [34;1mAB[0m(A) at [2m7:18+2[0m

-----

        struct B { v: i32 };
        struct C { v: i32 };


        struct A { a: i32 };
        using fn AB(a: A) B(a.a * 2);
        using fn AC(a: A) C(a.a * 3);


        fn main() {
            let a = A(1);
            let b: B = a;
            let c: C = a;
            return b.v * c.v - 6;
        }

-----
struct s_A;
struct s_B;
struct s_C;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_C
                                #define DEF_s_C
struct s_C
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B AB_7Nh2jNsJ(const s_A& a)
{
    return s_B { (a.a * 2) };
}

static s_C AC_7Nh2jNsJ(const s_A& a)
{
    return s_C { (a.a * 3) };
}

int fu_MAIN()
{
    const s_A a = s_A { 1 };
    const s_B b = AB_7Nh2jNsJ(a);
    const s_C c = AC_7Nh2jNsJ(a);
    return (b.v * c.v) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct A1 { v: i32 };
        struct A2 { v: i32 };
        struct B { v: i32 };

        using fn A1B(a: A1) B(a.v * 2);
        using fn A2B(a: A2) B(a.v * 3);

        fn test(a): B = a;

        fn main() A1(1).test.v * A2(1).test.v - 6;

-----
struct s_A1;
struct s_B;
struct s_A2;

                                #ifndef DEF_s_A1
                                #define DEF_s_A1
struct s_A1
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_A2
                                #define DEF_s_A2
struct s_A2
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_B A1B_HXU5Ti5l(const s_A1& a)
{
    return s_B { (a.v * 2) };
}

inline static s_B test_HXU5Ti5l(const s_A1& a)
{
    return A1B_HXU5Ti5l(a);
}

static s_B A2B_IU9MIvWg(const s_A2& a)
{
    return s_B { (a.v * 3) };
}

inline static s_B test_IU9MIvWg(const s_A2& a)
{
    return A2B_IU9MIvWg(a);
}

int fu_MAIN()
{
    return (test_HXU5Ti5l(s_A1 { 1 }).v * test_IU9MIvWg(s_A2 { 1 }).v) - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn varargs(a[]) a[0] + a[1];
        fn main() varargs(1, 2) - 3;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int varargs_zj1tLGtT(fu::view<int> a)
{
    return a[0] + a[1];
}

int fu_MAIN()
{
    return varargs_zj1tLGtT((fu::slate<2, int> { 1, 2 })) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;


        fn inspect(items.to_debug_str[]) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int to_debug_str_rgx2eiBu(const int a)
{
    return a * 2;
}

static int to_debug_str_4QVUjHxA(const unsigned b)
{
    return int(b) * 3;
}

inline static int inspect_Lodybvpk(fu::view<int> items)
{
    int a = 0;
    for (int i = 0; i < items.size(); i++)
        a += items[i];

    return a;
}

int fu_MAIN()
{
    return inspect_Lodybvpk((fu::slate<2, int> { to_debug_str_rgx2eiBu(int(5)), to_debug_str_4QVUjHxA(unsigned(7)) })) - 31;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;


        inline                                                  // GNUStmtExpr

        fn inspect(items.to_debug_str[]) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int to_debug_str_rgx2eiBu(const int a)
{
    return a * 2;
}

static int to_debug_str_4QVUjHxA(const unsigned b)
{
    return int(b) * 3;
}

int fu_MAIN()
{
    // Hoisted:
    int a;

    int BL_1_v {};
    return (__extension__ (
    {
        fu::vec<int> items = fu::vec<int> { fu::slate<2, int> { to_debug_str_rgx2eiBu(int(5)), to_debug_str_4QVUjHxA(unsigned(7)) } };
        a = 0;
        for (int i = 0; i < items.size(); i++)
            a += items[i];

        BL_1_v = (a);
    (void)0;}), BL_1_v) - 31;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn va(args[]: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < args.len; i++) sum += args[i];
            return sum;
        }

        fn main() va(1, 2) - 3;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int va_rPJTR1MJ(fu::view<int> args)
{
    int sum = 0;
    for (int i = 0; i < args.size(); i++)
        sum += args[i];

    return sum;
}

int fu_MAIN()
{
    return va_rPJTR1MJ((fu::slate<2, int> { 1, 2 })) - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // PointlessLocal
        inline fn Printy(x.Stringy): string = x;

        fn Println(parts.Printy[]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_nD58vCLu(const int i)
{
    return x7E_gCeFmDFw("i:"_fu, fu::i64dec(i));
}

inline static int Println_DhBMCYh2(fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}

int fu_MAIN()
{
    // Hoisted:
    fu::str x {};
    fu::str x_1 {};

    return Println_DhBMCYh2((fu::slate<2, fu::str> { static_cast<fu::str&&>((x = "str"_fu, x)), static_cast<fu::str&&>((x_1 = Stringy_nD58vCLu(10), x_1)) })) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                // PointlessLocal
        inline fn Printy(x.Stringy): string = x;

        fn Println(parts.Printy[]: [string]) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

static fu::str Stringy_nD58vCLu(const int i)
{
    return x7E_gCeFmDFw("i:"_fu, fu::i64dec(i));
}

static int Println_DhBMCYh2(fu::view<fu::str> parts)
{
    int total = 0;
    for (int i = 0; i < parts.size(); i++)
        total += parts[i].size();

    return total;
}

int fu_MAIN()
{
    // Hoisted:
    fu::str x {};
    fu::str x_1 {};

    return Println_DhBMCYh2((fu::slate<2, fu::str> { static_cast<fu::str&&>((x = "str"_fu, x)), static_cast<fu::str&&>((x_1 = Stringy_nD58vCLu(10), x_1)) })) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----
 // inline fn empty retval on autocall                // GNUStmtExpr
        inline fn concatable(a: bool)               a ? "yes" : "no";
        inline fn concat(a.concatable, b: string)   a ~ b;
        fn main()                                   concat(true, "!") == "yes!" ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str BL_1_v {};
    if ((__extension__ (
    {
        fu::str a = "yes"_fu;
        fu::str b = "!"_fu;
        BL_1_v = ((a + b));
    (void)0;}), static_cast<fu::str&&>(BL_1_v)) == "yes!"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----
 // inline fn empty retval on autocall
        inline fn inl_print(a: byte)                a;          // PointlessLocal
        fn inl_println(a.inl_print[]: string)       a.len;
        fn main()                                   inl_println('a', 'b') == 2 ? 0 : 1;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int inl_println_INJ0JhEX(fu::view<char> a)
{
    return a.size();
}

int fu_MAIN()
{
    // Hoisted:
    char a;
    char a_1;

    if (inl_println_INJ0JhEX((fu::slate<2, char> { (a = 'a', a), (a_1 = 'b', a_1) })) == 2)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        struct My { i: i32 };

        fn test(oh: My)
        {
            // autocall(): never
            let str = |my: My|: never {             // N_DeadConv
                return my.i; // exits test() here
            };

 // both mess up, this one emits a pointless overload,
            let hello = oh ~ "!";            //  this one messes up earlier in the solver

            return hello.len;
        }

        fn main() {
            return test(My(3)) - 3;
        }

-----
struct s_My;

                                #ifndef DEF_s_My
                                #define DEF_s_My
struct s_My
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_wVcswA7m(const s_My& oh)
{
    return oh.i;
}

int fu_MAIN()
{
    return test_wVcswA7m(s_My { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet, N_DeadConv

-----

        struct My { i: i32 };

        fn test(oh: My)
        {
            // autocall(): never
            let str = |my: My|: never {             // N_DeadConv
                return my.i; // exits test() here
            };


            let hello = "Hello, " ~ oh;      //  this one messes up earlier in the solver

            return hello.len;
        }

        fn main() {
            return test(My(3)) - 3;
        }

-----
struct s_My;

                                #ifndef DEF_s_My
                                #define DEF_s_My
struct s_My
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int test_wVcswA7m(const s_My& oh)
{
    return oh.i;
}

int fu_MAIN()
{
    return test_wVcswA7m(s_My { 3 }) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet, N_DeadConv

-----

        fn printlike(topic: string, stuff.print[]: [string], implicit ref out: string) {
            out ~= topic ~ ": " ~ stuff.join() ~ '\n';
        }

        fn main() {
            let topic = "A";
            implicit mut out: string;
            printlike(:topic, "Hello, ", "World", "!");         // PointlessLocal
            return out == "A: Hello, World!\n" ? 0 : 1
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_join_6LmAXnK0Otg
                                #define DEF_join_6LmAXnK0Otg
inline fu::str join_6LmAXnK0(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void printlike_K8vxGBl6(fu::view<char> topic, fu::view<fu::str> stuff, fu::str& out)
{
    out += (((topic + ": "_fu) + join_6LmAXnK0(stuff)) + '\n');
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    // Hoisted:
    fu::str x {};
    fu::str x_1 {};
    fu::str x_2 {};

    fu::str topic = "A"_fu;
    fu::str out {};
    printlike_K8vxGBl6(topic, (fu::slate<3, fu::str> { static_cast<fu::str&&>((x = "Hello, "_fu, x)), static_cast<fu::str&&>((x_1 = "World"_fu, x_1)), static_cast<fu::str&&>((x_2 = "!"_fu, x_2)) }), out);
    if (out == "A: Hello, World!\n"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        fn main() {
            mut out: string;                                    // PointlessLocal
            fn lazywarn(prefix: string, inline stuff.print[]: [string]) {
                out ||= prefix ~ stuff.join();
            }

            mut once = 0;
            fn once(str: string) {
                once++;
                return str;                                     // ConstCast
            }

            lazywarn(once("Hello"), ", ", "World", "!", prefix: "X: ");
            lazywarn(prefix: "Y: ", once("Hello"), "!");

            return out == "X: Hello, World!" && once == 1 ? 0 : 1
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>


#ifndef fu_NO_fdefs

static const fu::str& once_GlK04lyD(const fu::str& str, int& once)
{
    once++;
    return str;
}

                                #ifndef DEF_join_6LmAXnK0Otg
                                #define DEF_join_6LmAXnK0Otg
inline fu::str join_6LmAXnK0(fu::view<fu::str> a)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 0;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    // Hoisted:
    fu::str x {};
    fu::str x_1 {};
    fu::str x_2 {};
    fu::str x_3 {};
    fu::str x_4 {};
    fu::str x_5 {};

    fu::str out {};
    int once = 0;

    {
        fu::str prefix = "X: "_fu;
        if (!(out))
        {
            out = (prefix + join_6LmAXnK0((fu::slate<4, fu::str> { static_cast<fu::str&&>((x = static_cast<fu::str&&>(const_cast<fu::str&>(once_GlK04lyD("Hello"_fu, once))), x)), static_cast<fu::str&&>((x_1 = ", "_fu, x_1)), static_cast<fu::str&&>((x_2 = "World"_fu, x_2)), static_cast<fu::str&&>((x_3 = "!"_fu, x_3)) })));
        };
    };

    {
        fu::str prefix_1 = "Y: "_fu;
        if (!(out))
        {
            out = (prefix_1 + join_6LmAXnK0((fu::slate<2, fu::str> { static_cast<fu::str&&>((x_4 = static_cast<fu::str&&>(const_cast<fu::str&>(once_GlK04lyD("Hello"_fu, once))), x_4)), static_cast<fu::str&&>((x_5 = "!"_fu, x_5)) })));
        };
    };
    if ((out == "X: Hello, World!"_fu) && (once == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn ifThenElse(inline cond, inline cons, inline alt)
            cond ? cons : alt;

        fn main() {
            mut cond = 0;
            ifThenElse(cond++,
                { return 10; },
                { return cond == 1 ? 0 : 100; });
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int cond = 0;
    if (cond++)
        return 10;
    else if (cond == 1)
        return 0;
    else
        return 100;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn not_ambig !T(ref sum!: i32,
            <alt>
            inline                                              ;; GNUStmtExpr
            </alt>
            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     'g'); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 23:30+1[0m:

[2m      |             let c = not_ambig(:sum, "abc", "de");[0m
[2m      |             let d = not_ambig(:sum, 3, 3);[0m
[2m   23 | [0m            let e = not_ambig[31;1m([0m:sum, "abcdef",
[2m      | [0m
[2m      |                                      'g'); [0m

	Bad call to [34;1mnot_ambig[0m with args (i32 mutref copy, string copy resize AlwaysTrue, byte copy): 

	[35;1mfn[0m [34;1mnot_ambig[0m at [2m14:12+9[0m:
[2m   14 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

	    [35;1marg[0m [34;1mnot_ambig[0m:[34;1mb[0m expects i32 copy, got byte copy

	[35;1mfn[0m [34;1mnot_ambig[0m at [2m13:12+9[0m:
[2m   13 | [0m        fn [31;1mnot_ambig[0m !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);

	    [35;1marg[0m [34;1mnot_ambig[0m:[34;1ma[0m expects i32 copy, got string copy resize AlwaysTrue

	[35;1mtemplate[0m [34;1mnot_ambig[0m at [2m2:12+9[0m:
[2m    2 | [0m        fn [31;1mnot_ambig[0m !T(ref sum!: i32,

	    Rest arguments have no common supertype: string copy resize AlwaysTrue <- byte copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m16:12+4[0m

-----

        fn not_ambig !T(ref sum!: i32,

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     "g"); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& not_ambig_h83UZvH7(int& sum, const int a, fu::view<char> b)
{
    return (sum += (a + b.size()));
}

static int& not_ambig_PP1ObRTl(int& sum, fu::view<char> a, const int b)
{
    return (sum += (a.size() + b));
}

inline static int& not_ambig_gdce1bAf(int& sum, fu::view<fu::str> v)
{
    for (int i = 0; i < v.size(); i++)
        sum += v[i].size();

    return sum;
}

inline static int& not_ambig_zPUBpYyX(int& sum, fu::view<int> v)
{
    for (int i = 0; i < v.size(); i++)
        sum += v[i];

    return sum;
}

int fu_MAIN()
{
    int sum = 0;
    const int /*sum*/ a = not_ambig_h83UZvH7(sum, 1, "ab"_fu);
    const int /*sum*/ b = not_ambig_PP1ObRTl(sum, "bc"_fu, 2);
    const int /*sum*/ c = not_ambig_gdce1bAf(sum, (fu::slate<2, fu::str> { "abc"_fu, "de"_fu }));
    const int /*sum*/ d = not_ambig_zPUBpYyX(sum, (fu::slate<2, int> { 3, 3 }));
    const int /*sum*/ e = not_ambig_gdce1bAf(sum, (fu::slate<2, fu::str> { "abcdef"_fu, "g"_fu }));
    if ((a == 3) && (b == 7) && (c == 12) && (d == 18) && (e == 25))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn not_ambig !T(ref sum!: i32,

            inline                                              // GNUStmtExpr

            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",

                                     "g"); 

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& not_ambig_h83UZvH7(int& sum, const int a, fu::view<char> b)
{
    return (sum += (a + b.size()));
}

static int& not_ambig_PP1ObRTl(int& sum, fu::view<char> a, const int b)
{
    return (sum += (a.size() + b));
}

int fu_MAIN()
{
    int sum = 0;
    const int /*sum*/ a = not_ambig_h83UZvH7(sum, 1, "ab"_fu);
    const int /*sum*/ b = not_ambig_PP1ObRTl(sum, "bc"_fu, 2);
    int BL_1_v {};
    const int /*sum*/ c = (__extension__ (
    {
        for (int i = 0; i < (fu::slate<2, fu::str> { "abc"_fu, "de"_fu }).size(); i++)
        {
            sum += (fu::slate<2, fu::str> { "abc"_fu, "de"_fu })[i].size();
        };
        BL_1_v = (sum);
    (void)0;}), BL_1_v);
    int BL_4_v {};
    const int /*sum*/ d = (__extension__ (
    {
        for (int i = 0; i < (fu::slate<2, int> { 3, 3 }).size(); i++)
        {
            sum += (fu::slate<2, int> { 3, 3 })[i];
        };
        BL_4_v = (sum);
    (void)0;}), BL_4_v);
    int BL_7_v {};
    const int /*sum*/ e = (__extension__ (
    {
        for (int i = 0; i < (fu::slate<2, fu::str> { "abcdef"_fu, "g"_fu }).size(); i++)
        {
            sum += (fu::slate<2, fu::str> { "abcdef"_fu, "g"_fu })[i].size();
        };
        BL_7_v = (sum);
    (void)0;}), BL_7_v);
    if ((a == 3) && (b == 7) && (c == 12) && (d == 18) && (e == 25))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);                       // GNUStmtExpr
            return res == 10000 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

static int will_relax_args_b_Sq5feUey(fu::view<int>, int, int, int, int, int);
static int will_relax_args_a_6IrEyZ5f(fu::view<int>, int, int, int, int, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_6IrEyZ5f(fu::view<int> data, const int offset, const int THREE, const int FIVE, const int FOUR, const int TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*THREE*/ THREE_1 = THREE;
            return FIVE * will_relax_args_b_Sq5feUey(data, (offset + 1), FOUR, FIVE, THREE_1, TWO);
        }
        else
        {
            const int /*FIVE*/ FIVE_1 = FIVE;
            const int /*THREE*/ THREE_1 = THREE;
            return TWO * will_relax_args_a_6IrEyZ5f(data, (offset + 1), THREE_1, FIVE_1, FOUR, TWO);
        };
    }
    else
        return THREE * offset;

}

static int will_relax_args_b_Sq5feUey(fu::view<int> data, const int offset, const int FOUR, const int FIVE, const int THREE, const int TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return TWO * will_relax_args_a_6IrEyZ5f(data, (offset + 1), THREE, FIVE, FOUR_1, TWO);
        }
        else
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            const int /*TWO*/ TWO_1 = TWO;
            return FIVE * will_relax_args_b_Sq5feUey(data, (offset + 1), FOUR_1, FIVE, THREE, TWO_1);
        };
    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    const int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    const int FIVE = 5;
    fu::vec<int> data = fu::vec<int> { fu::slate<5, int> { 0, 0, 0, 0, 0 } };
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int offset = 0;
        const int /*FOUR*/ FOUR_1 = FOUR;
        const int /*THREE*/ THREE_1 = THREE;
        const int /*TWO*/ TWO_1 = TWO;
        BL_1_v = ((FIVE * will_relax_args_b_Sq5feUey(data, (offset + 1), FOUR_1, FIVE, THREE_1, TWO_1)));
    (void)0;}), BL_1_v);
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                if (offset & 2)
                    return 5 * will_relax_args_b(data, offset + 1);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);                       // GNUStmtExpr
            return res == 10000 ? 0 : 1;
        }

-----
#include <fu/vec.h>

static int will_relax_args_b_mf3EPVYP(fu::vec<int>&, int, int, int&, int, int);
static int will_relax_args_a_OAxvEuNx(fu::vec<int>&, int, int, int&, int, int);

#ifndef fu_NO_fdefs

static int will_relax_args_a_OAxvEuNx(fu::vec<int>& data, const int offset, const int THREE, int& FIVE, const int FOUR, const int TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*THREE*/ THREE_1 = THREE;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR, FIVE, THREE_1, TWO);
        }
        else
        {
            const int /*THREE*/ THREE_1 = THREE;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE_1, FIVE, FOUR, TWO);
        };
    }
    else
        return THREE * offset;

}

static int will_relax_args_b_mf3EPVYP(fu::vec<int>& data, const int offset, const int FOUR, int& FIVE, const int THREE, const int TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE, FIVE, FOUR_1, TWO);
        }
        else if (offset & 2)
            return 5 * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR, FIVE, THREE, TWO);
        else
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            const int /*TWO*/ TWO_1 = TWO;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE, TWO_1);
        };
    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    const int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    int FIVE = 5;
    fu::vec<int> data = fu::vec<int> { fu::slate<5, int> { 0, 0, 0, 0, 0 } };
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int offset = 0;
        const int /*FOUR*/ FOUR_1 = FOUR;
        const int /*THREE*/ THREE_1 = THREE;
        const int /*TWO*/ TWO_1 = TWO;
        BL_1_v = ((FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE_1, TWO_1)));
    (void)0;}), BL_1_v);
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

-----

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                if (offset & 2)
                    return 2 * will_relax_args_a(data, offset + 1);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);                       // GNUStmtExpr
            return res == 10000 ? 0 : 1;
        }

-----
#include <fu/vec.h>

static int will_relax_args_b_mf3EPVYP(fu::vec<int>&, int, int, int, int, int&);
static int will_relax_args_a_OAxvEuNx(fu::vec<int>&, int, int, int, int, int&);

#ifndef fu_NO_fdefs

static int will_relax_args_a_OAxvEuNx(fu::vec<int>& data, const int offset, const int THREE, const int FIVE, const int FOUR, int& TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*THREE*/ THREE_1 = THREE;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR, FIVE, THREE_1, TWO);
        }
        else if (offset & 2)
            return 2 * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE, FIVE, FOUR, TWO);
        else
        {
            const int /*FIVE*/ FIVE_1 = FIVE;
            const int /*THREE*/ THREE_1 = THREE;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE_1, FIVE_1, FOUR, TWO);
        };
    }
    else
        return THREE * offset;

}

static int will_relax_args_b_mf3EPVYP(fu::vec<int>& data, const int offset, const int FOUR, const int FIVE, const int THREE, int& TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE, FIVE, FOUR_1, TWO);
        }
        else
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE, TWO);
        };
    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    const int FIVE = 5;
    fu::vec<int> data = fu::vec<int> { fu::slate<5, int> { 0, 0, 0, 0, 0 } };
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int offset = 0;
        const int /*FOUR*/ FOUR_1 = FOUR;
        const int /*THREE*/ THREE_1 = THREE;
        BL_1_v = ((FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE_1, TWO)));
    (void)0;}), BL_1_v);
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

-----

        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);

                if (offset & 2)
                    return 2 * will_relax_args_a(data, offset + 1);

                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);

                if (offset & 2)
                    return 5 * will_relax_args_b(data, offset + 1);

                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);                       // GNUStmtExpr
            return res == 10000 ? 0 : 1;
        }

-----
#include <fu/vec.h>

static int will_relax_args_b_mf3EPVYP(fu::vec<int>&, int, int, int&, int, int&);
static int will_relax_args_a_OAxvEuNx(fu::vec<int>&, int, int, int&, int, int&);

#ifndef fu_NO_fdefs

static int will_relax_args_a_OAxvEuNx(fu::vec<int>& data, const int offset, const int THREE, int& FIVE, const int FOUR, int& TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*THREE*/ THREE_1 = THREE;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR, FIVE, THREE_1, TWO);
        }
        else if (offset & 2)
            return 2 * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE, FIVE, FOUR, TWO);
        else
        {
            const int /*THREE*/ THREE_1 = THREE;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE_1, FIVE, FOUR, TWO);
        };
    }
    else
        return THREE * offset;

}

static int will_relax_args_b_mf3EPVYP(fu::vec<int>& data, const int offset, const int FOUR, int& FIVE, const int THREE, int& TWO)
{
    if (offset < data.size())
    {
        if (offset & 1)
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return TWO * will_relax_args_a_OAxvEuNx(data, (offset + 1), THREE, FIVE, FOUR_1, TWO);
        }
        else if (offset & 2)
            return 5 * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR, FIVE, THREE, TWO);
        else
        {
            const int /*FOUR*/ FOUR_1 = FOUR;
            return FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE, TWO);
        };
    }
    else
        return FOUR * offset;

}

int fu_MAIN()
{
    int TWO = 2;
    const int THREE = 3;
    const int FOUR = 4;
    int FIVE = 5;
    fu::vec<int> data = fu::vec<int> { fu::slate<5, int> { 0, 0, 0, 0, 0 } };
    int BL_1_v {};
    const int res = (__extension__ (
    {
        const int offset = 0;
        const int /*FOUR*/ FOUR_1 = FOUR;
        const int /*THREE*/ THREE_1 = THREE;
        BL_1_v = ((FIVE * will_relax_args_b_mf3EPVYP(data, (offset + 1), FOUR_1, FIVE, THREE_1, TWO)));
    (void)0;}), BL_1_v);
    if (res == 10000)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int HERE_VEGJom6t(const s_Token& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_VEGJom6t(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;
        pub import _0;
        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_VEGJom6t6o6
                                #define DEF_HERE_VEGJom6t6o6
inline int HERE_VEGJom6t(const s_Token& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_VEGJom6t(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token) t.index * 11;

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token) t.index * 11;
        pub import _1;
        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_ftFz4sal7p0
                                #define DEF_HERE_ftFz4sal7p0
inline int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: Token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int HERE_VEGJom6t(const s_Token& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_VEGJom6t(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: Token) t.index * 11;

-----
struct s_Token;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_VEGJom6t(const s_Token& t)
{
    return t.index * 11;
}

#endif

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: Token) t.index * 11;
        pub import _0;
        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;
int HERE_VEGJom6t(const s_Token&);

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_VEGJom6t(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token: Token) t.index * 11;

        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token: Token) t.index * 11;

-----
struct s_Token;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}

#endif

-----

        struct Token { index: i32 };
        struct Node  { token: Token };
        pub import _0;
        fn HERE(t.token: Token) t.index * 11;
        pub import _1;
        fn main = HERE(Node(Token(3))) - 33;

-----
struct s_Token;
struct s_Node;
int HERE_ftFz4sal(const s_Token&);

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token) t.index * 11;

        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;

-----
struct s_Token;
struct s_Node;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_HERE_ftFz4sal7p0
                                #define DEF_HERE_ftFz4sal7p0
inline int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}
                                #endif

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

-----

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: _0::Token) t.index * 11;

-----
struct s_Token;

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int HERE_ftFz4sal(const s_Token& t)
{
    return t.index * 11;
}

#endif

-----

        struct Token { index: i32 };
        struct Node  { token: Token };

        fn HERE(t.token: _0::Token) t.index * 11;

        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;

-----
struct s_Token;
struct s_Node;
int HERE_ftFz4sal(const s_Token&);

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Token token;
    explicit operator bool() const noexcept
    {
        return false
            || token
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return HERE_ftFz4sal(s_Node { s_Token { 3 } }.token) - 33;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn fn_v(fn, v) fn(v);
        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int l_1_0_tfAsCCEq(const s_XY& l_1_0)
{
    return l_1_0.x;
}

inline static int fn_v_Za9yYiB5(const s_XY& v)
{
    return l_1_0_tfAsCCEq(v);
}

inline static int l_1_1_L3Xtvwxs(const s_XY& l_1_1)
{
    return l_1_1.y;
}

inline static int fn_v_80191DIc(const s_XY& v)
{
    return l_1_1_L3Xtvwxs(v);
}

int fu_MAIN()
{
    const s_XY v = s_XY { 11, 13 };
    return (fn_v_Za9yYiB5(v) + fn_v_80191DIc(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int l_1_0_tfAsCCEq(const s_XY& l_1_0)
{
    return l_1_0.x;
}

inline static int fn_v_ZYxn8jFA(const s_XY& v)
{
    return l_1_0_tfAsCCEq(v);
}

inline static int l_1_1_L3Xtvwxs(const s_XY& l_1_1)
{
    return l_1_1.y;
}

inline static int fn_v_AohblPq6(const s_XY& v)
{
    return l_1_1_L3Xtvwxs(v);
}

int fu_MAIN()
{
    const s_XY v = s_XY { 11, 13 };
    return (fn_v_ZYxn8jFA(v) + fn_v_AohblPq6(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn fn_w(x, y) x(y);             // same thing but
        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }

-----
struct s_XY;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int l_1_0_TYJ1a9Y9(const s_XY& l_1_0)
{
    return l_1_0.x;
}

inline static int fn_w_fQSfHj52(const s_XY& y)
{
    return l_1_0_TYJ1a9Y9(y);
}

inline static int fn_v_2nPRWk9y(const s_XY& x)
{
    return fn_w_fQSfHj52(x);
}

inline static int l_1_1_ZkQJrmi2(const s_XY& l_1_1)
{
    return l_1_1.y;
}

inline static int fn_w_5cHo4AW0(const s_XY& y)
{
    return l_1_1_ZkQJrmi2(y);
}

inline static int fn_v_WUivI5Sp(const s_XY& x)
{
    return fn_w_5cHo4AW0(x);
}

int fu_MAIN()
{
    const s_XY v = s_XY { 11, 13 };
    return (fn_v_2nPRWk9y(v) + fn_v_WUivI5Sp(v)) - 24;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn identity(x) x;
        fn main() {
            fn outer(depth1) {
                let sum = depth1; return identity(|| sum);
            }
            let sum = 0; return outer(sum);
        }

-----

#ifndef fu_NO_fdefs

static int l_1_0_V6uTIUa3(const int depth1)
{
    return depth1;
}

inline static int identity_tXkPTF1p(const int depth1)
{
    return l_1_0_V6uTIUa3(depth1);
}

inline static int outer_ZOYcGAvD(const int depth1)
{
    return identity_tXkPTF1p(depth1);
}

int fu_MAIN()
{
    const int sum = 0;
    return outer_ZOYcGAvD(sum);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn identity(x) x;
        fn test(depth0) {
            fn outer(depth1) {
                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);

-----

#ifndef fu_NO_fdefs

inline static int identity_8W49klIm(const int sum)
{
    return sum;
}

inline static int outer_9DfIfwrI(const int depth0)
{
    const int /*depth0*/ sum = depth0;
    return identity_8W49klIm(sum);
}

inline static int test_AN7n5y6F(const int depth0)
{
    return outer_9DfIfwrI(depth0);
}

int fu_MAIN()
{
    return test_AN7n5y6F(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(depth0) {
            fn identity(x) x;
            fn outer(depth1) {
                fn inner(depth2) {
                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);
                }
                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);

-----

#ifndef fu_NO_fdefs

inline static int identity_cocobEsp(const int sum)
{
    return sum;
}

inline static int inner_y07TqQWx(const int sum)
{
    const int /*sum*/ sum_1 = sum;
    return identity_cocobEsp(sum_1);
}

inline static int outer_9DfIfwrI(const int depth0)
{
    const int /*depth0*/ sum = depth0;
    return inner_y07TqQWx(sum);
}

inline static int test_AN7n5y6F(const int depth0)
{
    return outer_9DfIfwrI(depth0);
}

int fu_MAIN()
{
    return test_AN7n5y6F(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(depth0)
        {
            fn first(depth1) {
                fn first_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum;
                }

                let sum = depth0 + depth1;
                return first_inner(|| sum);
            }

            fn second(depth1) {
                fn second_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum + first(|| sum);
                }

                let sum = depth0 + depth1;
                return second_inner(|| sum);
            }

            let sum = depth0 + depth0;
            return second(|| sum);
        }

        fn main() test(0);

-----

#ifndef fu_NO_fdefs

static int l_1_3_wE2gFZNe(const int sum)
{
    return sum;
}

static int l_1_2_BMgtH4ep(const int sum)
{
    return sum;
}

static int l_1_1_bxx8eI2b(const int sum)
{
    return sum;
}

static int l_1_0_Jk6XWwnT(const int sum)
{
    return sum;
}

inline static int first_inner_ZTF4A1ik(const int sum, const int sum_1, const int depth0)
{
    const int sum_2 = ((depth0 + l_1_1_bxx8eI2b(sum_1)) + l_1_0_Jk6XWwnT(sum));
    return sum_2;
}

inline static int first_CA1ap31m(const int sum, const int depth0)
{
    const int sum_1 = (depth0 + l_1_1_bxx8eI2b(sum));
    return first_inner_ZTF4A1ik(sum_1, sum, depth0);
}

inline static int second_inner_VBw6EJJH(const int sum, const int depth0, const int sum_1)
{
    const int sum_2 = ((depth0 + l_1_3_wE2gFZNe(sum_1)) + l_1_2_BMgtH4ep(sum));
    return sum_2 + first_CA1ap31m(sum_2, depth0);
}

inline static int second_IPKg0GoX(const int depth0, const int sum)
{
    const int sum_1 = (depth0 + l_1_3_wE2gFZNe(sum));
    return second_inner_VBw6EJJH(sum_1, depth0, sum);
}

inline static int test_AN7n5y6F(const int depth0)
{
    const int sum = (depth0 + depth0);
    return second_IPKg0GoX(depth0, sum);
}

int fu_MAIN()
{
    return test_AN7n5y6F(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
    {
        int BL_3_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_3_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_3_v) * use_c_AnSmg6nY(c);
    };
}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
    {
        int BL_3_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_3_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_3_v) * use_c_AnSmg6nY(c);
    };
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
    {
        int BL_3_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_3_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_3_v) * use_c_AnSmg6nY(c);
    };
}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int parseStuff_9EOY0KdX(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
        return parseStuff_9EOY0KdX((y / 2), a, b, c) * parseStuff_9EOY0KdX(x, a, b, c);
    else
    {
        int BL_3_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_3_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_3_v) * use_c_AnSmg6nY(c);
    };
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int parseStuff_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    return parseStuff_9EOY0KdX(0, a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
    {
        int BL_4_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_4_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_4_v) * use_c_AnSmg6nY(c);
    };
}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
    {
        int BL_4_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_4_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_4_v) * use_c_AnSmg6nY(c);
    };
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doSomething_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    return doSomething_9EOY0KdX((y * y), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
    {
        int BL_4_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_4_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_4_v) * use_c_AnSmg6nY(c);
    };
}

static int descend_9EOY0KdX(const int x, const int a, const int b, const int c)
{
    return descend_inner_SP2wqm0N((x * x), x, a, b, c);
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    return (y * use_a_rgx2eiBu(a)) * descend_9EOY0KdX((y * y), a, b, c);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int doSomethingElse_BG4BMnQN(const int x, const int b)
{
    return doSomethingElse_inner_eTc16mhC((x * x), b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
        return doSomethingElse_BG4BMnQN((y * y), b) * use_c_AnSmg6nY(c);

}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;


        inline                                                  // GNUStmtExpr

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }


        inline 
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }


        inline                                                  // GNUStmtExpr

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }

-----
static int doStuff_JhWp7RUI(int, int, int, int);

#ifndef fu_NO_fdefs

static int use_a_rgx2eiBu(const int a)
{
    return a * a;
}

static int use_b_urWHdJ0x(const int b)
{
    return b * b;
}

static int doSomethingElse_inner_eTc16mhC(const int y, const int b)
{
    return y * use_b_urWHdJ0x(b);
}

static int use_c_AnSmg6nY(const int c)
{
    return c * c;
}

static int descend_inner_SP2wqm0N(const int y, const int x, const int a, const int b, const int c)
{
    if (y & 1)
    {
        int BL_2_v {};
        return (__extension__ (
        {
            const int x_1 = (y / 2);
            BL_2_v = (doStuff_JhWp7RUI((x_1 * x_1), a, b, c));
        (void)0;}), BL_2_v) * doStuff_JhWp7RUI((x * x), a, b, c);
    }
    else
    {
        int BL_4_v {};
        return (__extension__ (
        {
            const int x_1 = (y * y);
            BL_4_v = (doSomethingElse_inner_eTc16mhC((x_1 * x_1), b));
        (void)0;}), BL_4_v) * use_c_AnSmg6nY(c);
    };
}

static int doSomething_inner_CJkCYOxX(const int y, const int a, const int b, const int c)
{
    int BL_1_v {};
    return (y * use_a_rgx2eiBu(a)) * (__extension__ (
    {
        const int x = (y * y);
        BL_1_v = (descend_inner_SP2wqm0N((x * x), x, a, b, c));
    (void)0;}), BL_1_v);
}

static int doStuff_JhWp7RUI(const int y, const int a, const int b, const int c)
{
    const int x = (y * y);
    return doSomething_inner_CJkCYOxX((x * x), a, b, c);
}

int fu_MAIN()
{
    const int a = 0;
    const int b = 0;
    const int c = 0;
    const int x = 0;
    return doStuff_JhWp7RUI((x * x), a, b, c);
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing("Reason");
            };
            return stuff.len - 15; // "continue Reason"

        }

-----
#include <fu/str.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

static fu::str l_1_0_y1jV3SX3()
{
    return "Reason"_fu;
}

inline static void doThing_gPm6u8J5(fu::str& stuff)
{
    stuff = ("continue "_fu + l_1_0_y1jV3SX3());
}

int fu_MAIN()
{
    fu::str stuff = ""_fu;
    doThing_gPm6u8J5(stuff);
    return stuff.size() - 15;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_UnusedTry

-----

        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;

                cannotDoThing(throw("Reason"));
            };
            return stuff.len - 12; // "throw Reason"

        }

-----
#include <fu/str.h>
#include <fu/never.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

[[noreturn]] static fu::never l_1_0_y1jV3SX3()
{
    fu::fail("Reason"_fu);
}

inline static void doThing_gPm6u8J5(fu::str& stuff)
{

    try
    {
        l_1_0_y1jV3SX3();
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        stuff = ("throw "_fu + e);
    }
;
}

int fu_MAIN()
{
    fu::str stuff = ""_fu;
    doThing_gPm6u8J5(stuff);
    return stuff.size() - 12;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

-----

        fn nested(ref index: i32)
            return index++ && [];

        fn Lifetime_each(ref lifetime: i32[], visit)
            for (mut i = lifetime.len; i --> 0; )
                visit(nested(lifetime[i]));

        fn Lifetime_allowsMutrefReturn(ref lifetime: i32[])
            Lifetime_each(:lifetime): |t|
                return t;

        fn main() {
            mut arr: i32[] = [ 5, -2 ];
            Lifetime_allowsMutrefReturn(arr);

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 4;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void nested_JqMQw4jm(int& index)
{
    index++;
    return;
}

static void Lifetime_allowsMutrefReturn_AXdzeKxY(fu::view_mut<int> lifetime)
{
    for (int i = lifetime.size(); i-- > 0; )
    {
        nested_JqMQw4jm(lifetime.mutref(i));
        return;
    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<2, int> { 5, -2 } };
    Lifetime_allowsMutrefReturn_AXdzeKxY(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_UnusedIfElse, N_UnusedLet

-----

        fn Incr(ref x: i32) ++x;

        struct N { v: i32 };


        fn +=(ref a: N, b: i32) {
            a.v = a.v * 10 + b;
            return a;
        }

        fn main() {
            mut c: i32;
            mut a: N;
            (a = N(c.Incr)) += c.Incr;
            return a.v - 21;
        }

-----
struct s_N;

                                #ifndef DEF_s_N
                                #define DEF_s_N
struct s_N
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& Incr_3JeKX2Qj(int& x)
{
    return ++x;
}

static s_N& operator+=(s_N& a, const int b)
{
    a.v = ((a.v * 10) + b);
    return a;
}

int fu_MAIN()
{
    int c {};
    s_N a {};
    (a = s_N { Incr_3JeKX2Qj(c) }) += Incr_3JeKX2Qj(c);
    return a.v - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Incr(ref x: i32) ++x;

        struct N { v: i32 };


        inline

        fn +=(ref a: N, b: i32) {
            a.v = a.v * 10 + b;
            return a;
        }

        fn main() {
            mut c: i32;
            mut a: N;
            (a = N(c.Incr)) += c.Incr;
            return a.v - 21;
        }

-----
struct s_N;

                                #ifndef DEF_s_N
                                #define DEF_s_N
struct s_N
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int& Incr_3JeKX2Qj(int& x)
{
    return ++x;
}

int fu_MAIN()
{
    int c {};
    s_N a {};

    {
        const int /*c*/ b = Incr_3JeKX2Qj(c);
        s_N& /*a*/ a_1 = (a = s_N { Incr_3JeKX2Qj(c) });
        a_1.v = ((a_1.v * 10) + b);
    };
    return a.v - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() = test();
        fn test() {

            mut lt = Lifetime([ 1001, 1, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

static int Region_asLocal_cDppOF4Z(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_zFgHs9Pq(const int locid)
{
    return locid & 1;
}

inline static void Lifetime_each_cMVYWl2j(fu::view<int> lt, int& locids, bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            if (r == Region_STATIC)
                goto BL_3;
            else if (const int locid = Region_asLocal_cDppOF4Z(r))
            {
                if (!isMovedFrom_zFgHs9Pq(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}

static int test_H9fhQUVP()
{
    s_Lifetime lt = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1001, 1, 1003 } } };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_cMVYWl2j(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_H9fhQUVP();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

-----

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() = test();
        fn test() {

            mut lt = Lifetime([ 1001, 1002, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

static int Region_asLocal_cDppOF4Z(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_zFgHs9Pq(const int locid)
{
    return locid & 1;
}

inline static void Lifetime_each_cMVYWl2j(fu::view<int> lt, int& locids, bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            if (r == Region_STATIC)
                goto BL_3;
            else if (const int locid = Region_asLocal_cDppOF4Z(r))
            {
                if (!isMovedFrom_zFgHs9Pq(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}

static int test_H9fhQUVP()
{
    s_Lifetime lt = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1001, 1002, 1003 } } };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_cMVYWl2j(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_H9fhQUVP();
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

-----

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() {

            mut lt = Lifetime([ 1001, 1, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

static int Region_asLocal_cDppOF4Z(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_zFgHs9Pq(const int locid)
{
    return locid & 1;
}

inline static void Lifetime_each_pQ4FytCU(fu::view<int> lt, int& locids, bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            if (r == Region_STATIC)
                goto BL_3;
            else if (const int locid = Region_asLocal_cDppOF4Z(r))
            {
                if (!isMovedFrom_zFgHs9Pq(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}

int fu_MAIN()
{
    s_Lifetime lt = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1001, 1, 1003 } } };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_pQ4FytCU(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

-----

        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         // Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;


        fn main() {

            mut lt = Lifetime([ 1001, 1002, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Lifetime;

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::vec<int> regions;
    explicit operator bool() const noexcept
    {
        return false
            || regions
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_Region_STATIC
                                #define DEF_Region_STATIC
inline constexpr int Region_STATIC = 0;
                                #endif

static int Region_asLocal_cDppOF4Z(const int r)
{
    if (r > 1000)
        return r - 1000;
    else
        return 0;

}

static int isMovedFrom_zFgHs9Pq(const int locid)
{
    return locid & 1;
}

inline static void Lifetime_each_pQ4FytCU(fu::view<int> lt, int& locids, bool& force_mut)
{
    for (int i = 0; i < lt.size(); i++)
    {
        const int /*lt|static*/ r = lt[i];

        { {
            if (r == Region_STATIC)
                goto BL_3;
            else if (const int locid = Region_asLocal_cDppOF4Z(r))
            {
                if (!isMovedFrom_zFgHs9Pq(locid))
                {
                    force_mut = false;
                    return;
                }
                else
                    locids += locid;

            }
            else
                goto BL_3;

            continue;
          } BL_3:;
        };
        force_mut = false;
        return;
    };
}

int fu_MAIN()
{
    s_Lifetime lt = s_Lifetime { fu::vec<int> { fu::slate<3, int> { 1001, 1002, 1003 } } };
    int locids = 0;
    bool force_mut = true;
    Lifetime_each_pQ4FytCU(lt.regions, locids, force_mut);
    if ((force_mut == false) && (locids == 1))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_SD_HasStaticInit

-----

        fn sA(_: $T) struct { hey: $T; };

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;

-----
struct s_sA_R1UhomuA6F6;

                                #ifndef DEF_s_sA_R1UhomuA6F6
                                #define DEF_s_sA_R1UhomuA6F6
struct s_sA_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_sA_R1UhomuA6F6 fA_rgx2eiBu(const int a)
{
    return s_sA_R1UhomuA6F6 { (a + 2) };
}

int fu_MAIN()
{
    return fA_rgx2eiBu(1).hey - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey  ;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:28+1[0m:

[2m      | [0m
[2m      |         fn fB(a: $T): sB($T) = [ a + 2 ];[0m
[2m    5 | [0m        fn main() 1.fB.hey [31;1m-[0m 1.u32.fB.hey  ;
[2m      | [0m

	Bad call to [34;1m-[0m with args (i32 copy, u32 copy): 

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: i32 Typename <-> u32 Typename

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey  .i32  ;

-----
struct s_sB_R1UhomuA6F6;
struct s_sB_o9tQpOIntAa;

                                #ifndef DEF_s_sB_R1UhomuA6F6
                                #define DEF_s_sB_R1UhomuA6F6
struct s_sB_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_s_sB_o9tQpOIntAa
                                #define DEF_s_sB_o9tQpOIntAa
struct s_sB_o9tQpOIntAa
{
    unsigned hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_sB_R1UhomuA6F6 fB_rgx2eiBu(const int a)
{
    return s_sB_R1UhomuA6F6 { (a + 2) };
}

inline static s_sB_o9tQpOIntAa fB_IpqlK8nd(const unsigned a)
{
    return s_sB_o9tQpOIntAa { (a + 2u) };
}

int fu_MAIN()
{
    return fB_rgx2eiBu(1).hey - int(fB_IpqlK8nd(unsigned(1)).hey);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sB(_: $T) struct { hey: $T; };

        // Prep for the thing below.
        fn test(x) x.hey - 1;

        // 'a' must be callable.
        type a = sB(i32);
        fn main() a(1).test;

-----
struct s_sB_R1UhomuA6F6;

                                #ifndef DEF_s_sB_R1UhomuA6F6
                                #define DEF_s_sB_R1UhomuA6F6
struct s_sB_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int test_5VBX1wjT(const s_sB_R1UhomuA6F6& x)
{
    return x.hey - 1;
}

int fu_MAIN()
{
    return test_5VBX1wjT(s_sB_R1UhomuA6F6 { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        fn setupOperators(i: i32) {
            struct BINOP { i: i32; };
            return BINOP(:i);
        }

        fn main() setupOperators(0).i;

-----
struct s_BINOP;

                                #ifndef DEF_s_BINOP
                                #define DEF_s_BINOP
struct s_BINOP
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_BINOP setupOperators_nD58vCLu(const int i)
{
    return s_BINOP { i };
}

int fu_MAIN()
{
    return setupOperators_nD58vCLu(0).i;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sB(_: $T) struct { hey: $T; };

        fn setupOperators(i: i32) {
            struct BINOP { i: sB(i32); };
            mut s: sB(i32) = [ i ];
            return BINOP(s);
        }

        fn main() setupOperators(0).i.hey;

-----
struct s_BINOP;
struct s_sB_R1UhomuA6F6;

                                #ifndef DEF_s_sB_R1UhomuA6F6
                                #define DEF_s_sB_R1UhomuA6F6
struct s_sB_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BINOP
                                #define DEF_s_BINOP
struct s_BINOP
{
    s_sB_R1UhomuA6F6 i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_BINOP setupOperators_nD58vCLu(const int i)
{
    const s_sB_R1UhomuA6F6 s = s_sB_R1UhomuA6F6 { i };
    return s_BINOP { s_sB_R1UhomuA6F6(s) };
}

int fu_MAIN()
{
    return setupOperators_nD58vCLu(0).i.hey;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code
        fn get(s: Hey) s.i;

-----
struct s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Hey Hey_H9fhQUVP()
{
    return s_Hey{};
}

int get_e9PoxZOr(const s_Hey& s)
{
    return s.i;
}

#endif

-----

        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code
        fn get(s: Hey) s.i;

        fn main() {
            mut s: _0::Hey;
            return s.get();
        }

-----
struct s_Hey;
int get_e9PoxZOr(const s_Hey&);

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
struct s_Hey
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Hey s {};
    return get_e9PoxZOr(s);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Hey(_: $T) = struct { i: $T };
        fn get(s) s.i;

-----

-----

        fn Hey(_: $T) = struct { i: $T };
        fn get(s) s.i;

        fn main() {
            mut s: _0::Hey(i32);
            return s.get(); // get(): wasn't visible, the struct didnt remember its template origin module.
        }

-----
struct s_Hey_R1UhomuA6F6;

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int i;
    explicit operator bool() const noexcept
    {
        return false
            || i
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_get_BsnweOO71ph
                                #define DEF_get_BsnweOO71ph
inline int get_BsnweOO7(const s_Hey_R1UhomuA6F6& s)
{
    return s.i;
}
                                #endif

int fu_MAIN()
{
    const s_Hey_R1UhomuA6F6 s {};
    return get_BsnweOO7(s);
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn Hey(_: $T) = struct { v: $T };

-----

-----

        fn Hey(_: $T) = struct { v: $T };

        fn unwrap(h: _0::Hey(i32)) = h.v * 10;

-----
struct s_Hey_R1UhomuA6F6;

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int unwrap_MMVwwE3m(const s_Hey_R1UhomuA6F6& h)
{
    return h.v * 10;
}

#endif

-----

        fn Hey(_: $T) = struct { v: $T };

        fn unwrap(h: _0::Hey(i32)) = h.v * 10;

        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];

-----
struct s_Hey_R1UhomuA6F6;

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Hey_R1UhomuA6F6 wrap_6tjNUbai(const int v)
{
    return s_Hey_R1UhomuA6F6 { (v + 3) };
}

#endif

-----

        fn Hey(_: $T) = struct { v: $T };

        fn unwrap(h: _0::Hey(i32)) = h.v * 10;

        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];

        fn main() = _1::unwrap(_2::wrap(4)) - 70;

-----
struct s_Hey_R1UhomuA6F6;
struct s_Hey_R1UhomuA6F6;
s_Hey_R1UhomuA6F6 wrap_6tjNUbai(int);
int unwrap_MMVwwE3m(const s_Hey_R1UhomuA6F6&);

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return unwrap_MMVwwE3m(wrap_6tjNUbai(4)) - 70;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Hello(_: $T) struct { world: $T };

-----

-----

        fn Hello(_: $T) struct { world: $T };

        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];

-----
struct s_Hello_R1UhomuA6F6;

                                #ifndef DEF_s_Hello_R1UhomuA6F6
                                #define DEF_s_Hello_R1UhomuA6F6
struct s_Hello_R1UhomuA6F6
{
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Hello_R1UhomuA6F6 getHello_W0HwfDvt(const int x)
{
    return s_Hello_R1UhomuA6F6 { (x * x) };
}

#endif

-----

        fn Hello(_: $T) struct { world: $T };

        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];

        fn hello(x: i32) _1::getHello(x + 3);

-----
struct s_Hello_R1UhomuA6F6;
s_Hello_R1UhomuA6F6 getHello_W0HwfDvt(int);

                                #ifndef DEF_s_Hello_R1UhomuA6F6
                                #define DEF_s_Hello_R1UhomuA6F6
struct s_Hello_R1UhomuA6F6
{
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Hello_R1UhomuA6F6 hello_owZRYvo1(const int x)
{
    return getHello_W0HwfDvt((x + 3));
}

#endif

-----

        fn Hello(_: $T) struct { world: $T };

        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];

        fn hello(x: i32) _1::getHello(x + 3);

        fn main() _2::hello(2).world - 25;

-----
struct s_Hello_R1UhomuA6F6;
s_Hello_R1UhomuA6F6 hello_owZRYvo1(int);

                                #ifndef DEF_s_Hello_R1UhomuA6F6
                                #define DEF_s_Hello_R1UhomuA6F6
struct s_Hello_R1UhomuA6F6
{
    int world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return hello_owZRYvo1(2).world - 25;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sB(_: $T) struct { hey: $T; };

        // Pattern & partial spec, how?
        fn test(x: sB($T)): $T = x.hey - 1;

        type a = sB(i32);
        fn main() a(1).test;

-----
struct s_sB_R1UhomuA6F6;

                                #ifndef DEF_s_sB_R1UhomuA6F6
                                #define DEF_s_sB_R1UhomuA6F6
struct s_sB_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static int test_5VBX1wjT(const s_sB_R1UhomuA6F6& x)
{
    return x.hey - 1;
}

int fu_MAIN()
{
    return test_5VBX1wjT(s_sB_R1UhomuA6F6 { 1 });
}

#endif

int main() { return fu_MAIN(); }

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 VV_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

static s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

inline static s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_7jNlLvKM(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _0;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_7jNlLvKMs8g
                                #define DEF_VV_7jNlLvKMs8g
inline s_M_M5UPdNePry3 VV_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_7jNlLvKM(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

inline static s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_I85gcPM9O7g
                                #define DEF_VV_I85gcPM9O7g
inline s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

static s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

inline static s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_I85gcPM9O7g
                                #define DEF_VV_I85gcPM9O7g
inline s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

inline static s_M_M5UPdNePry3 VV_N5csxUSG(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_N5csxUSG(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

#endif

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _2;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;
struct s_M_M5UPdNePry3;
s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3&, const s_M_M5UPdNePry3&);

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_N5csxUSGrCb
                                #define DEF_VV_N5csxUSGrCb
inline s_M_M5UPdNePry3 VV_N5csxUSG(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_N5csxUSG(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 VV_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

inline static s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_7jNlLvKM(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _0;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_7jNlLvKMs8g
                                #define DEF_VV_7jNlLvKMs8g
inline s_M_M5UPdNePry3 VV_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_add_7ZOQfEsTMt6
                                #define DEF_add_7ZOQfEsTMt6
inline s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_7jNlLvKM(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

inline static s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

                                #ifndef DEF_add_7ZOQfEsTMt6
                                #define DEF_add_7ZOQfEsTMt6
inline s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };



        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _0;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_7jNlLvKMs8g
                                #define DEF_KK_7jNlLvKMs8g
inline s_M_M5UPdNePry3 KK_7jNlLvKM(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_I85gcPM9O7g
                                #define DEF_VV_I85gcPM9O7g
inline s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_add_7ZOQfEsTMt6
                                #define DEF_add_7ZOQfEsTMt6
inline s_M_M5UPdNePry3 add_7ZOQfEsT(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_1rsTusojDmb
                                #define DEF_incr_by_1rsTusojDmb
inline s_M_M5UPdNePry3& incr_by_1rsTusoj(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_7ZOQfEsT(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_7jNlLvKM(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_1rsTusoj(a, b);
    incr_by_1rsTusoj(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

inline static s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}

inline static s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _1;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_I85gcPM9O7g
                                #define DEF_VV_I85gcPM9O7g
inline s_M_M5UPdNePry3 VV_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_add_CmEDfZQQk95
                                #define DEF_add_CmEDfZQQk95
inline s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_I85gcPM9(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];


        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

inline static s_M_M5UPdNePry3 VV_N5csxUSG(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}

                                #ifndef DEF_add_CmEDfZQQk95
                                #define DEF_add_CmEDfZQQk95
inline s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_N5csxUSG(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];

-----

-----

        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        pub import _0;


        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = 
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        pub import _1;
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        pub import _2;

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }

-----
struct s_M_M5UPdNePry3;

                                #ifndef DEF_s_M_M5UPdNePry3
                                #define DEF_s_M_M5UPdNePry3
struct s_M_M5UPdNePry3
{
    unsigned k;
    unsigned v;
    explicit operator bool() const noexcept
    {
        return false
            || k
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_KK_I85gcPM9O7g
                                #define DEF_KK_I85gcPM9O7g
inline s_M_M5UPdNePry3 KK_I85gcPM9(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_VV_N5csxUSGrCb
                                #define DEF_VV_N5csxUSGrCb
inline s_M_M5UPdNePry3 VV_N5csxUSG(const unsigned k, const unsigned v)
{
    return s_M_M5UPdNePry3 { k, v };
}
                                #endif

                                #ifndef DEF_add_CmEDfZQQk95
                                #define DEF_add_CmEDfZQQk95
inline s_M_M5UPdNePry3 add_CmEDfZQQ(const s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return s_M_M5UPdNePry3 { (a.k + b.k), (a.v + b.v) };
}
                                #endif

                                #ifndef DEF_incr_by_fMqKyeGCgXc
                                #define DEF_incr_by_fMqKyeGCgXc
inline s_M_M5UPdNePry3& incr_by_fMqKyeGC(s_M_M5UPdNePry3& a, const s_M_M5UPdNePry3& b)
{
    return (a = add_CmEDfZQQ(a, b));
}
                                #endif

int fu_MAIN()
{
    s_M_M5UPdNePry3 a = KK_I85gcPM9(0x1u, 2u);
    s_M_M5UPdNePry3 b = VV_N5csxUSG(3u, 0x4u);
    incr_by_fMqKyeGC(a, b);
    incr_by_fMqKyeGC(b, a);
    if (((b.k * 100u) + b.v) == 710u)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(_: $T) struct { hey: $T; };

        fn hello(x: i32) x * 10;
        fn hello(x: Hey(i32)) x.hey * 100;
        fn hello(x: Hey($T)) case ($T.is::unsigned) x.hey * 1000;

        fn main() hello(1)
                + hello([ 1 ]   => Hey(i32))
                + hello([ 0x1 ] => Hey(u32)).i32
                    - 1110;

-----
struct s_Hey_R1UhomuA6F6;
struct s_Hey_o9tQpOIntAa;

                                #ifndef DEF_s_Hey_R1UhomuA6F6
                                #define DEF_s_Hey_R1UhomuA6F6
struct s_Hey_R1UhomuA6F6
{
    int hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_o9tQpOIntAa
                                #define DEF_s_Hey_o9tQpOIntAa
struct s_Hey_o9tQpOIntAa
{
    unsigned hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int hello_1WsbUdat(const int x)
{
    return x * 10;
}

static int hello_hAp0nGcl(const s_Hey_R1UhomuA6F6& x)
{
    return x.hey * 100;
}

inline static unsigned hello_bWIcrLoD(const s_Hey_o9tQpOIntAa& x)
{
    return x.hey * 1000u;
}

int fu_MAIN()
{
    return ((hello_1WsbUdat(1) + hello_hAp0nGcl(s_Hey_R1UhomuA6F6 { 1 })) + int(hello_bWIcrLoD(s_Hey_o9tQpOIntAa { 0x1u }))) - 1110;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Hey(_: $T) struct { hey: $T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }

-----
#include <fu/vec.h>

struct s_Hey_GqGTyOs1Zw3;

                                #ifndef DEF_s_Hey_GqGTyOs1Zw3
                                #define DEF_s_Hey_GqGTyOs1Zw3
struct s_Hey_GqGTyOs1Zw3
{
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_GqGTyOs1Zw3 Hey_W2vcbQqi()
{
    return s_Hey_GqGTyOs1Zw3{};
}

int fu_MAIN()
{
    s_Hey_GqGTyOs1Zw3 _ = Hey_W2vcbQqi();
    return _.hey.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) struct { hey: T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }

-----
#include <fu/vec.h>

struct s_Hey_m6xMRhUdV69;

                                #ifndef DEF_s_Hey_m6xMRhUdV69
                                #define DEF_s_Hey_m6xMRhUdV69
struct s_Hey_m6xMRhUdV69
{
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_m6xMRhUdV69 Hey_kro13RP9()
{
    return s_Hey_m6xMRhUdV69{};
}

int fu_MAIN()
{
    s_Hey_m6xMRhUdV69 _ = Hey_kro13RP9();
    return _.hey.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey !T(type T)
            case (T.is::arithmetic) = struct { hello: T };
            default                 = struct { world: T };

        fn main() {
            using let _a = Hey(i32);
            using let _b = Hey(i32[]);
            return hello + world.len;
        }

-----
#include <fu/vec.h>

struct s_Hey_95BJOojOc45;
struct s_Hey_m6xMRhUdV69;

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    int hello;
    explicit operator bool() const noexcept
    {
        return false
            || hello
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_m6xMRhUdV69
                                #define DEF_s_Hey_m6xMRhUdV69
struct s_Hey_m6xMRhUdV69
{
    fu::vec<int> world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_95BJOojOc45{};
}

inline static s_Hey_m6xMRhUdV69 Hey_kro13RP9()
{
    return s_Hey_m6xMRhUdV69{};
}

int fu_MAIN()
{
    const s_Hey_95BJOojOc45 _a = Hey_gJwHMvO5();
    s_Hey_m6xMRhUdV69 _b = Hey_kro13RP9();
    return _a.hello + _b.world.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey !T(lax _: T)
            case (T.is::arithmetic) = struct { hello: T };
            default                 = struct { world: T };

        fn main() {
            using let _a = Hey(i32);
            using let _b = Hey(i32[]);
            return hello + world.len;
        }

-----
#include <fu/vec.h>

struct s_Hey_nJ4BPGz6xhg;
struct s_Hey_qO8NzPctMi1;

                                #ifndef DEF_s_Hey_nJ4BPGz6xhg
                                #define DEF_s_Hey_nJ4BPGz6xhg
struct s_Hey_nJ4BPGz6xhg
{
    int hello;
    explicit operator bool() const noexcept
    {
        return false
            || hello
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_qO8NzPctMi1
                                #define DEF_s_Hey_qO8NzPctMi1
struct s_Hey_qO8NzPctMi1
{
    fu::vec<int> world;
    explicit operator bool() const noexcept
    {
        return false
            || world
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_nJ4BPGz6xhg Hey_KC2LCWQ6()
{
    return s_Hey_nJ4BPGz6xhg{};
}

inline static s_Hey_qO8NzPctMi1 Hey_W2vcbQqi()
{
    return s_Hey_qO8NzPctMi1{};
}

int fu_MAIN()
{
    const s_Hey_nJ4BPGz6xhg _a = Hey_KC2LCWQ6();
    s_Hey_qO8NzPctMi1 _b = Hey_W2vcbQqi();
    return _a.hello + _b.world.size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn new(type T): T = [];
        fn main() =

            new(0)   ;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:16+1[0m:

[2m      |         fn main() =[0m
[2m      | [0m
[2m    5 | [0m            new[31;1m([0m0)   ;
[2m      | [0m

	Bad call to [34;1mnew[0m with args (i32 copy AlwaysFalse): 

	[35;1mtemplate[0m [34;1mnew[0m at [2m2:12+3[0m:
[2m    2 | [0m        fn [31;1mnew[0m(type T): T = [];

	    [35;1marg[0m [34;1mT[0m expects a type, got a value: i32 copy AlwaysFalse

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        fn new(type T): T = [];
        fn main() =

            new(i32) ;

-----

#ifndef fu_NO_fdefs

inline static int nEw_gJwHMvO5()
{
    return 0;
}

int fu_MAIN()
{
    return nEw_gJwHMvO5();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        type A = struct { x: i32 };
        type B = struct { y: i32 };
        fn main() {
            mut a: A;
            mut b: B;
            return a.x + b.y;
        }

-----
struct s_Anon;
struct s_Anon_4;

                                #ifndef DEF_s_Anon
                                #define DEF_s_Anon
struct s_Anon
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Anon_4
                                #define DEF_s_Anon_4
struct s_Anon_4
{
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Anon a {};
    const s_Anon_4 b {};
    return a.x + b.y;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
        case (typeof(s) -> Hey(_)) {
            fill(s.a, v);
            fill(s.b, v);
        }
        default {
            for (fieldname i: typeof(s))
                s.i = v++;
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_8_95BJOojOc45;
struct s_Hey_95BJOojOc45;
struct s_Hey_4_95BJOojOc45;

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_4_95BJOojOc45
                                #define DEF_s_Hey_4_95BJOojOc45
struct s_Hey_4_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_8_95BJOojOc45
                                #define DEF_s_Hey_8_95BJOojOc45
struct s_Hey_8_95BJOojOc45
{
    s_Hey_95BJOojOc45 a;
    s_Hey_4_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_8_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_8_95BJOojOc45{};
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_MrViMcaK(s_Hey_4_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_m6XRF8CS(s_Hey_8_95BJOojOc45& s, int& v)
{
    fill_R9OQ48KR(s.a, v);
    fill_MrViMcaK(s.b, v);
}

int fu_MAIN()
{
    s_Hey_8_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_m6XRF8CS(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32) {
            if (typeof(s) -> Hey(_)) {
                fill(s.a, v);
                fill(s.b, v);
            }
            else for (fieldname i: typeof(s)) {
                s.i = v++;
            }
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_8_95BJOojOc45;
struct s_Hey_95BJOojOc45;
struct s_Hey_4_95BJOojOc45;

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_4_95BJOojOc45
                                #define DEF_s_Hey_4_95BJOojOc45
struct s_Hey_4_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_8_95BJOojOc45
                                #define DEF_s_Hey_8_95BJOojOc45
struct s_Hey_8_95BJOojOc45
{
    s_Hey_95BJOojOc45 a;
    s_Hey_4_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_8_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_8_95BJOojOc45{};
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_MrViMcaK(s_Hey_4_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_m6XRF8CS(s_Hey_8_95BJOojOc45& s, int& v)
{
    fill_R9OQ48KR(s.a, v);
    fill_MrViMcaK(s.b, v);
}

int fu_MAIN()
{
    s_Hey_8_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_m6XRF8CS(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) {

            type A = struct { a: T };
            type B = struct { b: T };

            return struct { a: A; b: B };
        }


        fn fill(s, ref v: i32)
            for (fieldname i: typeof(s))
                if (typeof(s.i) -> i32)     s.i = v++;
                else                        fill(s.i, v);


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_8_95BJOojOc45;
struct s_Hey_95BJOojOc45;
struct s_Hey_4_95BJOojOc45;

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_4_95BJOojOc45
                                #define DEF_s_Hey_4_95BJOojOc45
struct s_Hey_4_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_8_95BJOojOc45
                                #define DEF_s_Hey_8_95BJOojOc45
struct s_Hey_8_95BJOojOc45
{
    s_Hey_95BJOojOc45 a;
    s_Hey_4_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_8_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_8_95BJOojOc45{};
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_MrViMcaK(s_Hey_4_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_m6XRF8CS(s_Hey_8_95BJOojOc45& s, int& v)
{
    fill_R9OQ48KR(s.a, v);
    fill_MrViMcaK(s.b, v);
}

int fu_MAIN()
{
    s_Hey_8_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_m6XRF8CS(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32)
        case (typeof(s) -> Hey(_)) {
            fill(s.a, v);
            fill(s.b, v);
        }
        default {
            for (fieldname i: typeof(s))
                s.i = v++;
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_95BJOojOc45;
struct s_A_95BJOojOc45;
struct s_B_95BJOojOc45;

                                #ifndef DEF_s_A_95BJOojOc45
                                #define DEF_s_A_95BJOojOc45
struct s_A_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B_95BJOojOc45
                                #define DEF_s_B_95BJOojOc45
struct s_B_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    s_A_95BJOojOc45 a;
    s_B_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_95BJOojOc45{};
}

inline static void fill_tjc4tVHd(s_A_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_4XGFySgh(s_B_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    fill_tjc4tVHd(s.a, v);
    fill_4XGFySgh(s.b, v);
}

int fu_MAIN()
{
    s_Hey_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_R9OQ48KR(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(ref s, ref v: i32) {
            if (typeof(s) -> Hey(_)) {
                fill(s.a, v);
                fill(s.b, v);
            }
            else for (fieldname i: typeof(s)) {
                s.i = v++;
            }
        }


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_95BJOojOc45;
struct s_A_95BJOojOc45;
struct s_B_95BJOojOc45;

                                #ifndef DEF_s_A_95BJOojOc45
                                #define DEF_s_A_95BJOojOc45
struct s_A_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B_95BJOojOc45
                                #define DEF_s_B_95BJOojOc45
struct s_B_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    s_A_95BJOojOc45 a;
    s_B_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_95BJOojOc45{};
}

inline static void fill_tjc4tVHd(s_A_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_4XGFySgh(s_B_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    fill_tjc4tVHd(s.a, v);
    fill_4XGFySgh(s.b, v);
}

int fu_MAIN()
{
    s_Hey_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_R9OQ48KR(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn Hey(type T) {

            struct A { a: T };
            struct B { b: T };

            return struct { a: A; b: B };
        }


        fn fill(s, ref v: i32)
            for (fieldname i: typeof(s))
                if (typeof(s.i) -> i32)     s.i = v++;
                else                        fill(s.i, v);


        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }

-----
struct s_Hey_95BJOojOc45;
struct s_A_95BJOojOc45;
struct s_B_95BJOojOc45;

                                #ifndef DEF_s_A_95BJOojOc45
                                #define DEF_s_A_95BJOojOc45
struct s_A_95BJOojOc45
{
    int a;
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B_95BJOojOc45
                                #define DEF_s_B_95BJOojOc45
struct s_B_95BJOojOc45
{
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Hey_95BJOojOc45
                                #define DEF_s_Hey_95BJOojOc45
struct s_Hey_95BJOojOc45
{
    s_A_95BJOojOc45 a;
    s_B_95BJOojOc45 b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hey_95BJOojOc45 Hey_gJwHMvO5()
{
    return s_Hey_95BJOojOc45{};
}

inline static void fill_tjc4tVHd(s_A_95BJOojOc45& s, int& v)
{
    s.a = v++;
}

inline static void fill_4XGFySgh(s_B_95BJOojOc45& s, int& v)
{
    s.b = v++;
}

inline static void fill_R9OQ48KR(s_Hey_95BJOojOc45& s, int& v)
{
    fill_tjc4tVHd(s.a, v);
    fill_4XGFySgh(s.b, v);
}

int fu_MAIN()
{
    s_Hey_95BJOojOc45 ab = Hey_gJwHMvO5();
    int v = 11;
    fill_R9OQ48KR(ab, v);
    return (ab.a.a + ab.b.b) - 23;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----


        let  X = i32; 
        struct Y { x: X };

        fn main() {
            mut y = Y(1 + 2);
            return y.x - 3;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+1[0m:

[2m      | [0m
[2m      |         let  X = i32; [0m
[2m    4 | [0m        struct Y { x: [31;1mX[0m };
[2m      | [0m
[2m      |         fn main() {[0m

	Invalid type annotation: evaluates to a value, not a type. Consider wrapping it in typeof().

        Solving [35;1mtype[0m [34;1mY[0m

-----


        type X = i32; 
        struct Y { x: X };

        fn main() {
            mut y = Y(1 + 2);
            return y.x - 3;
        }

-----
struct s_Y;

                                #ifndef DEF_s_Y
                                #define DEF_s_Y
struct s_Y
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Y y = s_Y { (1 + 2) };
    return y.x - 3;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Hello { a: i32; b: i32 };

        fn Wrap(type T) = struct { using v: T };
        fn incr_a1_b2 !T(using w: Wrap(T)) =
            T(:a + 1, :b + 2);

        fn main() {
            mut zeroes: Wrap(Hello);
            let ones = incr_a1_b2(zeroes);
            return ones.a * 10 + ones.b * 100 - 210;
        }

-----
struct s_Wrap_itEC32jBzO9;
struct s_Hello;

                                #ifndef DEF_s_Hello
                                #define DEF_s_Hello
struct s_Hello
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Wrap_itEC32jBzO9
                                #define DEF_s_Wrap_itEC32jBzO9
struct s_Wrap_itEC32jBzO9
{
    s_Hello v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Hello incr_a1_b2_Q6DsQ4qH(const s_Wrap_itEC32jBzO9& w)
{
    return s_Hello { (w.v.a + 1), (w.v.b + 2) };
}

int fu_MAIN()
{
    const s_Wrap_itEC32jBzO9 zeroes {};
    const s_Hello ones = incr_a1_b2_Q6DsQ4qH(zeroes);
    return ((ones.a * 10) + (ones.b * 100)) - 210;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn typeArgRename(type Outer!Inner)
            case (Inner.is::primitive)
                = Inner;

        fn main() {
            mut x: typeArgRename(

                    i32);

            return x;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:33+1[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m    7 | [0m            mut x: typeArgRename[31;1m([0m
[2m      | [0m
[2m      |                     i32);[0m

	Bad call to [34;1mtypeArgRename[0m with args (i32 copy Typename): 

	[35;1mtemplate[0m [34;1mtypeArgRename[0m at [2m2:12+13[0m:
[2m    2 | [0m        fn [31;1mtypeArgRename[0m(type Outer!Inner)

	    [35;1marg[0m [34;1mOuter[0m must be :explicitly named.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        fn typeArgRename(type Outer!Inner)
            case (Inner.is::primitive)
                = Inner;

        fn main() {
            mut x: typeArgRename(
Outer: 
                    i32);

            return x;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int x {};
    return x;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {
            :OUTER {
                :INNER {
                    if (x > 1) break :OUTER;                    // Goto
                    if (x > 0) break :INNER;
                    return 2;
                }
                return 1;
            }
            return 0;
        }

        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{

    { {
        if (x > 1)
            goto BL_1;
        else
        {
            if (!(x > 0))
                return 2;

        };
        return 1;
      } BL_1:;
    };
    return 0;
}

int fu_MAIN()
{
    return ((test_1WsbUdat(2) * 11) + ((test_1WsbUdat(1) - 1) * 13)) + ((test_1WsbUdat(0) - 2) * 17);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {
            return {
                :BLOCK {
                    if (x & 1) break :BLOCK 1;
                    if (x & 2) return 2;
                    3
                }
            };
        }

        fn main() 4.test - 5.test - 6.test; // 3-1-2

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 1)
        return 1;
    else if (x & 2)
        return 2;
    else
        return 3;

}

int fu_MAIN()
{
    return (test_1WsbUdat(4) - test_1WsbUdat(5)) - test_1WsbUdat(6);
}

#endif

int main() { return fu_MAIN(); }

-----

        fn brkif(mut x: i32)
        {
            :WOOT
            if (x & 1) {
                if (x & 2) x++;
                if (x & 4) break :WOOT;                         // Goto
                x *= x;
            }

            return x;
        }

        fn main()
            brkif(1) + brkif(3) * 10 + brkif(5) * 100 + brkif(9) * 1000
                == 81541 ? 0 : 1;

-----

#ifndef fu_NO_fdefs

static int brkif_1WsbUdat(int x)
{

    { {
        if (x & 1)
        {
            if (x & 2)
                x++;

            if (x & 4)
                goto BL_1;
            else
                x *= x;

        };
      } BL_1:;
    };
    return x;
}

int fu_MAIN()
{
    if ((((brkif_1WsbUdat(1) + (brkif_1WsbUdat(3) * 10)) + (brkif_1WsbUdat(5) * 100)) + (brkif_1WsbUdat(9) * 1000)) == 81541)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(a: i32) {
            mut w = 3;
            :OUTER w += {                                       // GNUStmtExpr
                :INNER {
                    if (a & 1)  break :INNER;
                    else        break :OUTER;                   // Goto
                };
                5
            };
            return w;
        }
        fn main() 0.test + 1.test - 11;

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_rgx2eiBu(const int a)
{
    int w = 3;

    { {
        fu::never BL_2_v {};
        w += ((a & 1) ? 5 : (__extension__ (
        {
            goto BL_1;
        (void)0;}), static_cast<fu::never&&>(BL_2_v)));
      } BL_1:;
    };
    return w;
}

int fu_MAIN()
{
    return (test_rgx2eiBu(0) + test_rgx2eiBu(1)) - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn ifbrk(a: i32) {
            mut x = 0;
            if (a & 3) {
                x += a;

                :IF_LABEL
                if (a & 1) {
                    mut incr    = a & 4 ? a * 2
                                : a & 2 ? { break :IF_LABEL; }  // Goto
                                        : a;                    // GNUStmtExpr
                    x += incr;
                }
            }

            return x;
        }

        fn main() 1.ifbrk + 3.ifbrk * 10 + 5.ifbrk * 100 - 1532;

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int ifbrk_rgx2eiBu(const int a)
{
    int x = 0;
    if (a & 3)
    { {
        x += a;
        if (a & 1)
        {
            fu::never BL_3_v {};
            const int incr = ((a & 4) ? (a * 2) : ((a & 2) ? (__extension__ (
            {
                goto BL_1;
            (void)0;}), static_cast<fu::never&&>(BL_3_v)) : a));
            x += incr;
        };
      } BL_1:;
    };
    return x;
}

int fu_MAIN()
{
    return ((ifbrk_rgx2eiBu(1) + (ifbrk_rgx2eiBu(3) * 10)) + (ifbrk_rgx2eiBu(5) * 100)) - 1532;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(x: i32) {
            return {
                :BLOCK 2 * {
                    if (x) break :BLOCK 3;                      // GNUStmtExpr
                    1
                }
            };
        }

        fn main() = test(0) == 2 && test(1) == 3 ? 0 : 1;

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int test_XzHONHMl(const int x)
{
    fu::never BL_1_v {};
    return 2 * (x ? (__extension__ (
    {
        return 3;
    (void)0;}), static_cast<fu::never&&>(BL_1_v)) : 1);
}

int fu_MAIN()
{
    if ((test_XzHONHMl(0) == 2) && (test_XzHONHMl(1) == 3))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn v(x: i32) {                                          // GNUStmtExpr
            return {
                :BLOCK                          5000 + { // *2:
                    if (x == 9) continue :BLOCK 2000;    //   - here
                    if (x == 8) return           300;
                    if (x == 7) break :BLOCK      40;

                    5                                    //   - and here!
                }
            }  // -----------------------------------
        }
        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;

-----
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int v_1WsbUdat(const int x)
{
    fu::never BL_1_v {};
    fu::never BL_2_v {};
    return 5000 + ((x == 9) ? 2000 : ((x == 8) ? (__extension__ (
    {
        return 300;
    (void)0;}), static_cast<fu::never&&>(BL_1_v)) : ((x == 7) ? (__extension__ (
    {
        return 40;
    (void)0;}), static_cast<fu::never&&>(BL_2_v)) : 5)));
}

int fu_MAIN()
{
    return (((v_1WsbUdat(9) + v_1WsbUdat(8)) + v_1WsbUdat(7)) + v_1WsbUdat(6)) - 12345;
}

#endif

int main() { return fu_MAIN(); }

-----

        pub fn test(x: i32[], y: i32[]) {
            let z = {
                :BLOCK {
                    mut w: i32[] = x;
                    if (y[0]) w ~= y;
                    if (w[0] != 17)
                        break :BLOCK w;
                    x
                }
            };

            return z[0] + z[z.len - 1];
        }

        fn main() test([ 1 ], [ 2 ]) - 3;

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

int test_FgkWYvPs(const fu::vec<int>& x, fu::view<int> y)
{
    // Hoisted:
    fu::vec<int> w {};

    fu::view<int> /*w|x*/ z = (w =  { x }, (y[0] && ((w += y), 0)), ((w[0] != 17) ? w : x));
    return z[0] + z[(z.size() - 1)];
}

int fu_MAIN()
{
    return test_FgkWYvPs(fu::vec<int> { fu::slate<1, int> { 1 } }, (fu::slate<1, int> { 2 })) - 3;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(mut x: i32) {
            {
                x++;
                :CANT_FLATTEN { // naive block flattening
                                //  can damage this label
                    if (x & 1) break :CANT_FLATTEN;
                    return x;
                }
            }
            return x * 2;
        }

        fn main() test(1) + test(2) - 8;

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(int x)
{

    {
        x++;
        if (!(x & 1))
            return x;

    };
    return x * 2;
}

int fu_MAIN()
{
    return (test_1WsbUdat(1) + test_1WsbUdat(2)) - 8;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn Some(arr, fn) {
            arr.Each: |x| if (fn(x)) return x;
            return 0;
        }

        fn main() [ 1, 2, 3 ].Some(|v| v & 1 == 0) - 2;

        // EXPECT (fu::slate<3, int> { 1, 2, 3 })

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static bool l_1_1_V02KGPsP(const int v)
{
    return (v & 1) == 0;
}

inline static int Some_x5iEXXFD(fu::view<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        const int /*arr|static*/ x = arr[i];
        if (l_1_1_V02KGPsP(x))
            return x;

    };
    return 0;
}

int fu_MAIN()
{
    return Some_x5iEXXFD((fu::slate<3, int> { 1, 2, 3 })) - 2;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn outer() {
            mut sum = 0;

            inline fn inner(v: i32) {                           // GNUStmtExpr
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return :outer sum;
                }

                return v * 2;
            }

            mut x = 1;
            for (;;) x = inner(x);
        }

        fn main() outer - 42; // extra points for style

-----

#ifndef fu_NO_fdefs

static int outer_H9fhQUVP()
{
    int sum = 0;
    int x = 1;
    for (; ; )
    {
        int BL_3_v {};
        x = (__extension__ (
        {
            const int /*x*/ v = x;
            for (int i = 0; i < 10; i++)
            {
                sum += v;
                if (sum > 40)
                    return sum;

            };
            BL_3_v = ((v * 2));
        (void)0;}), BL_3_v);
    };
}

int fu_MAIN()
{
    return outer_H9fhQUVP() - 42;
}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn main() {
            mut sum = 0;
            :OUTER [1, 2, 3, 4].Each(|x| {
                sum += x;
                for (mut i = 1; i--; ) // once
                    if (sum == 6) break :OUTER;                 // Goto
            });
            return sum - 6;
        }

        // !N_NonTrivAutoCopy

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int sum = 0;

    { {
        fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
        for (int i = 0; i < arr.size(); i++)
        {
            const int /*arr|static*/ x = arr[i];
            sum += x;
            for (int i_1 = 1; i_1--; )
            {
                if (sum == 6)
                    goto BL_1;

            };
        };
      } BL_1:;
    };
    return sum - 6;
}

#endif

int main() { return fu_MAIN(); }

-----

        inline fn hello(ref sum) {  //     when inlined into woot
            if (sum > 2) return;    //      the hello block now looks like an expr
            sum += 2;               // <-    with a diverging tail return here
        }

        fn woot(ref sum) hello(sum);

        fn main() {
            mut sum = -2;
            sum.woot();
            return sum;
        }

-----

#ifndef fu_NO_fdefs

inline static void woot_6gX0LZBm(int& sum)
{
    if (!(sum > 2))
        sum += 2;

}

int fu_MAIN()
{
    int sum = -2;
    woot_6gX0LZBm(sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) break; });
            return x - 1;
        }

-----

#ifndef fu_NO_fdefs

inline static void loop1d_X7Jdi3UZ(const int i0, const int i1, int& x)
{
    for (int i = i0; i < i1; i++)
    {
        if ((x += i))
            return;

    };
}

int fu_MAIN()
{
    int x = 0;
    loop1d_X7Jdi3UZ(0, 10, x);
    return x - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) return x - 1; });
            return 101;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int x = 0;

    {
        const int i0 = 0;
        const int i1 = 10;
        for (int i = i0; i < i1; i++)
        {
            if ((x += i))
                return x - 1;

        };
    };
    return 101;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop2d(x0, x1, y0, y1, fn) {
            for (mut y = y0; y < y1; y++)
            for (mut x = x0; x < x1; x++) fn(x, y);
        }

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }

-----

#ifndef fu_NO_fdefs

inline static void loop2d_WPm3SLbd(const int x0, const int x1, const int y0, const int y1, int& sum)
{
    for (int y = y0; y < y1; y++)
    {
        for (int x = x0; x < x1; x++)
        {
            if (y < 11)
                sum++;
            else if (x == 1)
                return;
            else
                sum += ((x + 1) * y);

        };
    };
}

int fu_MAIN()
{
    int sum = 0;
    loop2d_WPm3SLbd(0, 10, 10, 12, sum);
    return sum - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn loop2d(x0, x1, y0, y1, fn)
            loop1d(y0, y1, |y|
                loop1d(x0, x1, |x|
                    fn (x, y)));

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }

-----

#ifndef fu_NO_fdefs

inline static void loop2d_QOHXLmOO(const int x0, const int x1, const int y0, const int y1, int& sum)
{
    for (int i = y0; i < y1; i++)
    {
        for (int i_1 = x0; i_1 < x1; i_1++)
        {
            if (i < 11)
                sum++;
            else if (i_1 == 1)
                return;
            else
                sum += ((i_1 + 1) * i);

        };
    };
}

int fu_MAIN()
{
    int sum = 0;
    loop2d_QOHXLmOO(0, 10, 10, 12, sum);
    return sum - 21;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn next(implicit ref sum: i32, lifetime: [i32], locals_start: i32) {
            sum += lifetime.len;
            return lifetime[locals_start : lifetime.len];
        }

        fn Lifetime_each(lifetime: [i32], visit) {
            for (mut i = 0; i < lifetime.len; i++)
                visit(lifetime[i : lifetime.len]);
        }

        fn Lifetime_F_TODO_FIX_RRET(lifetime: [i32], locals_start: i32) {
            Lifetime_each(:lifetime, visit: |l| {
                if (l)
                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);
            });
        }

        fn main() {
            let lifetime = [ 1, 2 ];
            implicit mut sum = 0;
            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);
            return sum - 4;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

static void Lifetime_F_TODO_FIX_RRET_D0hWdWZM(fu::view<int>, int, int&);

#ifndef fu_NO_fdefs

static fu::view<int> next_G9wskTVX(fu::view<int> lifetime, const int locals_start, int& sum)
{
    sum += lifetime.size();
    return fu::get_view(lifetime, locals_start, lifetime.size());
}

inline static void l_1_0_xP2tc74J(fu::view<int> l, const int locals_start, int& sum)
{
    if (l)
    {
        fu::view<int> _0 {};
        (_0 = next_G9wskTVX(l, locals_start, sum), Lifetime_F_TODO_FIX_RRET_D0hWdWZM(static_cast<fu::view<int>&&>(_0), locals_start, sum));
    };
}

inline static void Lifetime_each_MH2Kdo6j(fu::view<int> lifetime, const int locals_start, int& sum)
{
    for (int i = 0; i < lifetime.size(); i++)
    {
        l_1_0_xP2tc74J(fu::get_view(lifetime, i, lifetime.size()), locals_start, sum);
    };
}

static void Lifetime_F_TODO_FIX_RRET_D0hWdWZM(fu::view<int> lifetime, const int locals_start, int& sum)
{
    Lifetime_each_MH2Kdo6j(lifetime, locals_start, sum);
}

int fu_MAIN()
{
    fu::vec<int> lifetime = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    int sum = 0;
    Lifetime_F_TODO_FIX_RRET_D0hWdWZM(lifetime, 1, sum);
    return sum - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_BckMustSeq

-----

        fn test(x: i32, ref odds: i32) {
            return x & 1 ? { odds++; x } : x + 1;
        }

        fn main() {
            let nums = [ 1, 2, 3 ];
            mut odds = 0;
            mut sum  = 0;
            for (mut i = 0; i < nums.len; i++)
                sum += test(nums[i], :odds);

            return odds != 2 ? 100
                 : sum  != 7 ? 200
                 : 0;
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

static int test_NembzFLx(const int x, int& odds)
{
    if (x & 1)
    {
        odds++;
        return x;
    }
    else
        return x + 1;

}

int fu_MAIN()
{
    fu::vec<int> nums = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    int odds = 0;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++)
        sum += test_NembzFLx(nums[i], odds);

    if (odds != 2)
        return 100;
    else if (sum != 7)
        return 200;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn test(ref x: i32) {
            return {
                :BLOCK {
                    if (x & 1)  break :BLOCK x++;
                    else        break :BLOCK x * 2;
                }
            };
        }

        fn main() {
            mut x = 1;
            return test(x) == 1 && test(x) == 4 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_3JeKX2Qj(int& x)
{
    if (x & 1)
        return x++;
    else
        return x * 2;

}

int fu_MAIN()
{
    int x = 1;
    if ((test_3JeKX2Qj(x) == 1) && (test_3JeKX2Qj(x) == 4))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn PASS_borrowCheck(ref x: i32[]) {
            fn bck_node(add: i32) {
                for (mut i = 0; i < x.len; i++) {
                    x[i] *= x[i];
                    x[i] += add;
                }
            }

            bck_node(1);

            :SOLVE_AAR {
                if (x.len & 2)
                    bck_node(2);

                if (x.len & 1)
                    break :SOLVE_AAR;

                bck_node(3);
            }
        }

        fn main() {
            mut a = [ 1, 2, 3 ];
            mut b = [ 1, 2 ];
            PASS_borrowCheck(a);
            PASS_borrowCheck(b);
            return a[2] == 102 && b[1] == 732 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static void bck_node_1ALUPMI9(const int add, fu::view_mut<int> x)
{
    for (int i = 0; i < x.size(); i++)
    {
        x.mutref(i) *= x[i];
        x.mutref(i) += add;
    };
}

static void PASS_borrowCheck_jdiq9sLU(fu::view_mut<int> x)
{
    bck_node_1ALUPMI9(1, x);
    if (x.size() & 2)
        bck_node_1ALUPMI9(2, x);

    if (!(x.size() & 1))
        bck_node_1ALUPMI9(3, x);

}

int fu_MAIN()
{
    fu::vec<int> a = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    fu::vec<int> b = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    PASS_borrowCheck_jdiq9sLU(a);
    PASS_borrowCheck_jdiq9sLU(b);
    if ((a[2] == 102) && (b[1] == 732))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn rev(arr, fn) {
            for (mut i = arr.len; i --> 0; ) {
                if (!arr[i])
                    break;

                fn(arr[i], i?: i);

            }
        }

        fn test(arr) {
            mut sum = 0;
            arr.rev: |x| {
                if (x & 1) continue;
                sum += x;
            }
            return sum;
        }

        fn main() {
            return test([2, 4, 6, 8]) == 20
                && test([2, 4, 7, 8]) == 14
                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static void l_1_0_eTvuXzOS(const int x, int& sum)
{
    if (!(x & 1))
        sum += x;

}

inline static void rev_7ydSwTiU(fu::view<int> arr, int& sum)
{
    for (int i = arr.size(); i-- > 0; )
    {
        if (!arr[i])
            break;
        else
            l_1_0_eTvuXzOS(arr[i], sum);

    };
}

inline static int test_VgLKCq8Z(fu::view<int> arr)
{
    int sum = 0;
    rev_7ydSwTiU(arr, sum);
    return sum;
}

int fu_MAIN()
{
    if ((test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 6, 8 })) == 20) && (test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 7, 8 })) == 14) && (test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 0, 8 })) == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn rev(arr, fn) {
            for (mut i = arr.len; i --> 0; ) {
                if (!arr[i])
                    break;

                else
                    fn(arr[i], i?: i);

            }
        }

        fn test(arr) {
            mut sum = 0;
            arr.rev: |x| {
                if (x & 1) continue;
                sum += x;
            }
            return sum;
        }

        fn main() {
            return test([2, 4, 6, 8]) == 20
                && test([2, 4, 7, 8]) == 14
                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;
        }

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static void l_1_0_eTvuXzOS(const int x, int& sum)
{
    if (!(x & 1))
        sum += x;

}

inline static void rev_7ydSwTiU(fu::view<int> arr, int& sum)
{
    for (int i = arr.size(); i-- > 0; )
    {
        if (!arr[i])
            break;
        else
            l_1_0_eTvuXzOS(arr[i], sum);

    };
}

inline static int test_VgLKCq8Z(fu::view<int> arr)
{
    int sum = 0;
    rev_7ydSwTiU(arr, sum);
    return sum;
}

int fu_MAIN()
{
    if ((test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 6, 8 })) == 20) && (test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 7, 8 })) == 14) && (test_VgLKCq8Z((fu::slate<4, int> { 2, 4, 0, 8 })) == 8))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            fn exit(code: i32) { return :main code; }

            fn exitViaArgdef(what: i32 = exit(0)) = what;

            exitViaArgdef();
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int code = 0;
    return code;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadCall

-----


        fn test(mut x: i32) {
            fn loopInsideInlineArg(inline theLoop = {
                while (x) {
                    if (x & 1)  return x;
                    if (x & 2)  break;
                    if (x & 8)  return :test x * 100;
                    x /= 2;
                }
            }) {
                theLoop();
                return x * 10;
            }

            return loopInsideInlineArg() * 3;                   // GNUStmtExpr
        }

        fn main() {
            let a = test(5);
            let b = test(4);
            let c = test(16);
            return a == 5 && b == 60 && c == 800 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(int x)
{
    int BL_1_v {};
    return (__extension__ (
    {
        while (x)
        {
            if (x & 1)
                return x;
            else if (x & 2)
                break;
            else if (x & 8)
                return x * 100;
            else
                x /= 2;

        };
        BL_1_v = ((x * 10));
    (void)0;}), BL_1_v) * 3;
}

int fu_MAIN()
{
    const int a = test_1WsbUdat(5);
    const int b = test_1WsbUdat(4);
    const int c = test_1WsbUdat(16);
    if ((a == 5) && (b == 60) && (c == 800))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----


        inline                                                  // Goto

        fn test(mut x: i32) {
            fn loopInsideInlineArg(inline theLoop = {
                while (x) {
                    if (x & 1)  return x;
                    if (x & 2)  break;
                    if (x & 8)  return :test x * 100;
                    x /= 2;
                }
            }) {
                theLoop();
                return x * 10;
            }

            return loopInsideInlineArg() * 3;                   // GNUStmtExpr
        }

        fn main() {
            let a = test(5);
            let b = test(4);
            let c = test(16);
            return a == 5 && b == 60 && c == 800 ? 0 : 1;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int BL_1_v {};
    const int a = (__extension__ (
    { {
        int x = 5;
        int BL_2_v {};
        BL_1_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_1_v = x; goto BL_1; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_1_v = (x * 100); goto BL_1; };
                }
                else
                    x /= 2;

            };
            BL_2_v = ((x * 10));
        (void)0;}), BL_2_v) * 3));
      } BL_1:;
    (void)0;}), BL_1_v);
    int BL_9_v {};
    const int b = (__extension__ (
    { {
        int x = 4;
        int BL_10_v {};
        BL_9_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_9_v = x; goto BL_9; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_9_v = (x * 100); goto BL_9; };
                }
                else
                    x /= 2;

            };
            BL_10_v = ((x * 10));
        (void)0;}), BL_10_v) * 3));
      } BL_9:;
    (void)0;}), BL_9_v);
    int BL_17_v {};
    const int c = (__extension__ (
    { {
        int x = 16;
        int BL_18_v {};
        BL_17_v = (((__extension__ (
        {
            while (x)
            {
                if (x & 1)
                {
                    { BL_17_v = x; goto BL_17; };
                }
                else if (x & 2)
                    break;
                else if (x & 8)
                {
                    { BL_17_v = (x * 100); goto BL_17; };
                }
                else
                    x /= 2;

            };
            BL_18_v = ((x * 10));
        (void)0;}), BL_18_v) * 3));
      } BL_17:;
    (void)0;}), BL_17_v);
    if ((a == 5) && (b == 60) && (c == 800))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn UnusedArgError(arr: i32[], fn)
            for (mut i = 0; i < arr.len; i++)
                fn(hello: arr[i], i?: i);

        fn main() {
            mut sum = 0;
            let arr = [ 1, 2, -3 ];
            arr.UnusedArgError: |lax i, hello|

                sum += arr[i];         

            return sum;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 9:41+5[0m:

[2m      |             mut sum = 0;[0m
[2m      |             let arr = [ 1, 2, -3 ];[0m
[2m    9 | [0m            arr.UnusedArgError: |lax i, [31;1mhello[0m|
[2m      | [0m
[2m      |                 sum += arr[i];         [0m

	Unused variable: [35;1marg[0m [34;1mhello[0m: make it [35;1mlax[0m if this is intentional.

       RelaxMut [35;1mfn[0m [34;1ml_1_0[0m(i32, i32) at [2m9:33+1[0m
        Solving [35;1mfn[0m [34;1mUnusedArgError[0m(i32[:], @130) at [2m2:12+14[0m
                [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        fn UnusedArgError(arr: i32[], fn)
            for (mut i = 0; i < arr.len; i++)
                fn(hello: arr[i], i?: i);

        fn main() {
            mut sum = 0;
            let arr = [ 1, 2, -3 ];
            arr.UnusedArgError: |lax i, hello|

                sum += hello;          

            return sum;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_6kaQOREx(const int hello, int& sum)
{
    return (sum += hello);
}

inline static void UnusedArgError_CDiwdppH(fu::view<int> arr, int& sum)
{
    for (int i = 0; i < arr.size(); i++)
        l_1_0_6kaQOREx(arr[i], sum);

}

int fu_MAIN()
{
    int sum = 0;
    fu::vec<int> arr = fu::vec<int> { fu::slate<3, int> { 1, 2, -3 } };
    UnusedArgError_CDiwdppH(arr, sum);
    return sum;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn each(ref arr: i32[], even, odd)
            for (mut i = 0; i < arr.len; i++)
                if (!i) odd(i?: i, it?: arr[i]);
                else   even(i?: i, it?: arr[i]);

        fn main() {
            mut arr = [ 1, 2, 3 ];
            arr.each(odd: |it| it++, even: || { break; });

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 7;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int l_1_0_IKw7N6or(int& it)
{
    return it++;
}

inline static void each_limouq9j(fu::view_mut<int> arr)
{
    for (int i = 0; i < arr.size(); i++)
    {
        if (!i)
            l_1_0_IKw7N6or(arr.mutref(i));
        else
            return;

    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } };
    each_limouq9j(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return sum - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn hello(a) a * a;          // EXPECT (const int a)
        fn main() {
            mut a = 3;
            let b = hello(a);
            return b - 9;
        }

-----

#ifndef fu_NO_fdefs

inline static int hello_rgx2eiBu(const int a)
{
    return a * a;
}

int fu_MAIN()
{
    const int a = 3;
    const int b = hello_rgx2eiBu(a);
    return b - 9;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct AB { a: i32; b: i32; };
        fn sqr   (ref x: i32) x * x;
        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        // EXPECT const s_AB&
        fn main() {
            mut ab = AB(3, 5);
            return ab.outer - 34;
        }

-----
struct s_AB;

                                #ifndef DEF_s_AB
                                #define DEF_s_AB
struct s_AB
{
    int a;
    int b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int sqr_1WsbUdat(const int x)
{
    return x * x;
}

static int outer_2g4Rzed4(const s_AB& ab)
{
    return sqr_1WsbUdat(ab.a) + sqr_1WsbUdat(ab.b);
}

int fu_MAIN()
{
    const s_AB ab = s_AB { 3, 5 };
    return outer_2g4Rzed4(ab) - 34;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }



        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;

-----
#include <fu/int.h>
#include <fu/str.h>


#ifndef fu_NO_fdefs

static fu::str ascii_lower_eY1c7dF3(const fu::str& a)
{
    const int offset = (int(fu::u8('a')) - int(fu::u8('A')));
    /*MOV*/ fu::str res { a };
    for (int i = 0; i < res.size(); i++)
    {
        const char /*res|static*/ c = res[i];
        if ((c >= 'A') && (c <= 'Z'))
            res.mutref(i) = char((int(fu::u8(c)) + offset));

    };
    return /*NRVO*/ res;
}

int fu_MAIN()
{
    return int(fu::u8(ascii_lower_eY1c7dF3("WORLD!"_fu)[2])) - int(fu::u8('r'));
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }


-----
#include <fu/int.h>
#include <fu/str.h>


#ifndef fu_NO_fdefs

fu::str ascii_lower_eY1c7dF3(const fu::str& a)
{
    const int offset = (int(fu::u8('a')) - int(fu::u8('A')));
    /*MOV*/ fu::str res { a };
    for (int i = 0; i < res.size(); i++)
    {
        const char /*res|static*/ c = res[i];
        if ((c >= 'A') && (c <= 'Z'))
            res.mutref(i) = char((int(fu::u8(c)) + offset));

    };
    return /*NRVO*/ res;
}

#endif

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }

        pub import _0;

        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;

-----
#include <fu/int.h>
#include <fu/str.h>

fu::str ascii_lower_eY1c7dF3(const fu::str&);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(fu::u8(ascii_lower_eY1c7dF3("WORLD!"_fu)[2])) - int(fu::u8('r'));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {
            mut a = [[ 7 ]];
            return a[0][0] - 7;        // EXPECT a[0][0]
        }

-----
#include <fu/vec.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    fu::vec<fu::vec<int>> a = fu::vec<fu::vec<int>> { fu::slate<1, fu::vec<int>> { fu::vec<int> { fu::slate<1, int> { 7 } } } };
    return a[0][0] - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        lax fn doNothing(pointlessArg: i32) {
            if (pointlessArg == 1)
                return;
        }

        fn main() {
            doNothing(1);
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedIfElse

-----

        struct Target   { index: i32 };
        struct Overload { uni0n: i32[] };

        fn solve(all: Overload[], check: Target) {
            fn GET(t: Target) {
                if (t.index < 1 || t.index > all.len) throw("nope");
                return all[t.index - 1];
            }

            fn propagateType(t: Target) {
                if (t.GET.uni0n.has(t.index)) {}
                return t.index;
            }

            return propagateType(check);
        }

        fn main() solve([ Overload([ 1, 2, 3 ])], Target(1)) - 1;

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Overload;
struct s_Target;

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::vec<int> uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Overload& GET_sPKQP6RR(const s_Target& t, fu::view<s_Overload> all)
{
    if ((t.index < 1) || (t.index > all.size()))
        fu::fail("nope"_fu);
    else
        return all[(t.index - 1)];

}

static int propagateType_4jlr2fM3(const s_Target& t, fu::view<s_Overload> all)
{
    GET_sPKQP6RR(t, all);
    return t.index;
}

static int solve_WQbe957p(fu::view<s_Overload> all, const s_Target& check)
{
    return propagateType_4jlr2fM3(check, all);
}

int fu_MAIN()
{
    return solve_WQbe957p((fu::slate<1, s_Overload> { s_Overload { fu::vec<int> { fu::slate<3, int> { 1, 2, 3 } } } }), s_Target { 1 }) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedAndOr

-----

        struct Overload     { args: Argument[]; };
        struct SolvedNode   { x: i32; };
        struct Argument     { default: SolvedNode; };

        pub fn test(overload: Overload, ref args: SolvedNode[])
        {
            let host_args = overload.args;          // EXPECT fu::view<s_Argument> /*overload*/ host_args

            args.resize(host_args.len);             // .len didnt relax its arg
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default;
                }
            }
        }

        fn main() {
            mut o: Overload;
            for (mut i = 0; i < 3; i++)
                o.args ~= Argument(default: SolvedNode(x: i));

            mut args: SolvedNode[];
            test(o, args);
            return args.len - args[args.len - 1].x - 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>

struct s_Overload;
struct s_Argument;
struct s_SolvedNode;

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    int x;
    explicit operator bool() const noexcept
    {
        return false
            || x
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    fu::vec<s_Argument> args;
    explicit operator bool() const noexcept
    {
        return false
            || args
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Argument
                                #define DEF_s_Argument
struct s_Argument
{
    s_SolvedNode dEfault;
    explicit operator bool() const noexcept
    {
        return false
            || dEfault
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

void test_XcQ0JGEY(const s_Overload& overload, fu::vec<s_SolvedNode>& args)
{
    fu::view<s_Argument> /*overload*/ host_args = overload.args;
    args.resize(host_args.size());
    for (int i = 0; i < args.size(); i++)
    {
        if (!args[i])
        {
            const s_Argument& /*host_args|static*/ host_arg = host_args[i];
            args.mutref(i) = s_SolvedNode(host_arg.dEfault);
        };
    };
}

int fu_MAIN()
{
    s_Overload o {};
    for (int i = 0; i < 3; i++)
    {
        o.args += s_Argument { s_SolvedNode { i } };
    };
    fu::vec<s_SolvedNode> args {};
    test_XcQ0JGEY(o, args);
    return (args.size() - args[(args.size() - 1)].x) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        // !!!! The m_and_c_cant_alias_001 test obsoletes this,
        // !!!!  this is just detects what we definitely don't want to see -
        // !!!!   returning a reference into a temporary copy.
        //
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_002(ref m: S, c: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);

            let hey = m_and_c_cant_alias_002(mc, mc);

            return hey.len - 10;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:50+2[0m:

[2m      |             mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);[0m
[2m      | [0m
[2m   16 | [0m            let hey = m_and_c_cant_alias_002(mc, [31;1mmc[0m);
[2m      | [0m
[2m      |             return hey.len - 10;[0m

	At call to [35;1mfn[0m [34;1mm_and_c_cant_alias_002[0m, arguments:

	    2:	[35;1marg[0m [34;1mm_and_c_cant_alias_002[0m:[34;1mc[0m and
	    1:	[35;1mref arg[0m [34;1mm_and_c_cant_alias_002[0m:[34;1mm[0m

	    both alias:

	    [35;1mvar[0m [34;1mmc[0m at [2m14:17+2[0m:

[2m      | [0m
[2m      |         fn main() {[0m
[2m   14 | [0m            mut [31;1mmc[0m  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
[2m      | [0m
[2m      |             let hey = m_and_c_cant_alias_002(mc, mc);[0m

	Can't resolve aliasing by a temporary copy:

	    [35;1marg[0m [34;1mm_and_c_cant_alias_002[0m:[34;1mc[0m is ref-returned from [35;1mfn[0m [34;1mm_and_c_cant_alias_002[0m

	    [35;1mref arg[0m [34;1mm_and_c_cant_alias_002[0m:[34;1mm[0m is [31;1mref[0m

    BorrowCheck [35;1mfn[0m [34;1mmain[0m at [2m13:12+4[0m

-----

        // !!!! The m_and_c_cant_alias_001 test obsoletes this,
        // !!!!  this is just detects what we definitely don't want to see -
        // !!!!   returning a reference into a temporary copy.
        //
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_002(ref m: S, c: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);

            mut bc  = mc;
            let hey = m_and_c_cant_alias_002(mc, bc);

            return hey.len - 10;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_S;

                                #ifndef DEF_s_S
                                #define DEF_s_S
struct s_S
{
    fu::vec<int> hey;
    explicit operator bool() const noexcept
    {
        return false
            || hey
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const fu::vec<int>& m_and_c_cant_alias_002_MURZA2QC(s_S& m, const s_S& c)
{
    m.hey.clear();
    return c.hey;
}

int fu_MAIN()
{
    s_S mc = s_S { fu::vec<int> { fu::slate<10, int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } } };
    s_S bc { mc };
    fu::view<int> /*bc*/ hey = m_and_c_cant_alias_002_MURZA2QC(mc, bc);
    return hey.size() - 10;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn grow_if_oob(a: &mut $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        struct BitSet { _data: u8[]; }

        fn add_once(using _: &mut BitSet, idx: i32): bool {
            let no_neg = idx < 0 ? -1 : 0;
            let bucket = idx / 8 | no_neg;
            let bit    = idx % 8;
            let mask   = 1 << bit.u8;

            ref entry = _data.grow_if_oob(bucket);
            if !(entry & mask) {
                entry |= mask;
                return true;
            }

            // Already there.
            return false;
        }

        type BitSet2D = BitSet[];

        fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool {
            return bs
                .grow_if_oob(i)
                .add_once(j);                                   // !*MustSeq
        }

        fn main() {
            mut bs: BitSet2D;
            bs.add_once(9, 9);
            return bs.len + 1000 * bs[9]._data.len - 2010;
        }

-----
#include <fu/int.h>
#include <fu/vec.h>

struct s_BitSet;

                                #ifndef DEF_s_BitSet
                                #define DEF_s_BitSet
struct s_BitSet
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_BitSet& grow_if_oob_6dRgWI60(fu::vec<s_BitSet>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

inline static fu::u8& grow_if_oob_9Q2AdejQ(fu::vec<fu::u8>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static bool add_once_rNtuo3Go(s_BitSet& _, const int idx)
{
    const int no_neg = ((idx < 0) ? -1 : 0);
    const int bucket = ((idx / 8) | no_neg);
    const int bit = (idx % 8);
    const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(bit))));
    fu::u8& /*_|static*/ entry = grow_if_oob_9Q2AdejQ(_._data, bucket);
    if (!fu::u8((entry & mask)))
    {
        entry |= mask;
        return true;
    }
    else
        return false;

}

static bool add_once_zsP3XJCF(fu::vec<s_BitSet>& bs, const int i, const int j)
{
    return add_once_rNtuo3Go(grow_if_oob_6dRgWI60(bs, i), j);
}

int fu_MAIN()
{
    fu::vec<s_BitSet> bs {};
    add_once_zsP3XJCF(bs, 9, 9);
    return (bs.size() + (1000 * bs[9]._data.size())) - 2010;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(mut _precedence = 0)
        {
            fn parseExpression(p1?: i32): i32 {
                if !(_precedence = p1)
                    return parseExpressionHead();

                return _precedence;
            }

            fn parseExpressionHead()
                parseExpression(_precedence * 101 + 1);

            return parseExpression();
        }

        fn main() = test() - 1;

-----
static int parseExpression_sP8kS6Nv(int, int&);

#ifndef fu_NO_fdefs

static int parseExpressionHead_hpa9AihZ(int& _precedence)
{
    return parseExpression_sP8kS6Nv(((_precedence * 101) + 1), _precedence);
}

static int parseExpression_sP8kS6Nv(const int p1, int& _precedence)
{
    if (!(_precedence = p1))
        return parseExpressionHead_hpa9AihZ(_precedence);
    else
        return _precedence;

}

static int test_O4LAFtz0(int _precedence)
{
    return parseExpression_sP8kS6Nv(0, _precedence);
}

int fu_MAIN()
{
    return test_O4LAFtz0(0) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen

-----

        struct Overload {
            is_var?: bool;
            lifetime?: i32[];
        }

        fn GET(implicit overloads: Overload[], idx: i32) {
            return overloads[idx];
        }

        // Uncommenting the inline passes this,
        //  this is shit, we can't leave this like this.
        //
        // inline
        fn Lifetime_each(mut lifetime: i32[], visit) {
            for (mut i = 0; i < lifetime.len; i++) {
                let r = lifetime[i];
                let o = GET(r);
                visit(:o, i?: i, lifetime?: lifetime);
            }
        }

        fn Lifetime_ascend(mut lifetime: i32[], visit) {
            Lifetime_each(:lifetime, visit: |o, shadow lifetime| {
                visit(o);
                lifetime ~= o.lifetime; // set::add
            });
        }

        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {
            Lifetime_ascend(:lifetime, visit: |o| {
                if (o.is_var)
                    return false; // ERR: propagateType(jump): h.ret_actual not available.
            });

            return true;
        }

        fn main() {
            let implicit overloads = [
                Overload,
                Overload(lifetime: [ 0 ]),
                Overload(lifetime: [ 1 ], is_var: true),
                Overload(lifetime: [ 1 ]),
                Overload(lifetime: [ 2 ]), /* the isvar */
                Overload(lifetime: [ 3 ]), /* the non-isvar */
            ];

            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);
            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);

            if (expect_false) return 20;
            if (!expect_true) return 10;
            return 0;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat.h>

struct s_Overload;

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    bool is_var;
    fu::vec<int> lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || is_var
            || lifetime
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const s_Overload& GET_bIqbGnuG(const int idx, fu::view<s_Overload> overloads)
{
    return overloads[idx];
}

static bool Lifetime_allowsMutrefReturn_9h7KZVOf(const fu::vec<int>& lifetime, fu::view<s_Overload> overloads)
{

    {
        const fu::vec<int>& /*lifetime*/ lifetime_1 = lifetime;
        fu::vec<int> lifetime_2 { lifetime_1 };
        for (int i = 0; i < lifetime_2.size(); i++)
        {
            const int /*lifetime_2|static*/ r = lifetime_2[i];
            const s_Overload& /*overloads|static*/ o = GET_bIqbGnuG(r, overloads);
            if (o.is_var)
                return false;
            else
            {
                lifetime_2 += o.lifetime;
            };
        };
    };
    return true;
}

int fu_MAIN()
{
    fu::vec<s_Overload> overloads = fu::vec<s_Overload> { fu::slate<6, s_Overload> { s_Overload{}, s_Overload { false, fu::vec<int> { fu::slate<1, int> { 0 } } }, s_Overload { true, fu::vec<int> { fu::slate<1, int> { 1 } } }, s_Overload { false, fu::vec<int> { fu::slate<1, int> { 1 } } }, s_Overload { false, fu::vec<int> { fu::slate<1, int> { 2 } } }, s_Overload { false, fu::vec<int> { fu::slate<1, int> { 3 } } } } };
    const bool expect_false = Lifetime_allowsMutrefReturn_9h7KZVOf(fu::vec<int> { fu::slate<1, int> { 4 } }, overloads);
    const bool expect_true = Lifetime_allowsMutrefReturn_9h7KZVOf(fu::vec<int> { fu::slate<1, int> { 5 } }, overloads);
    if (expect_false)
        return 20;
    else if (!expect_true)
        return 10;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        using inline fn GET(h: Helpers, implicit ref _helpers_data: HelpersData[]): HelpersData
            _helpers_data[h.index];
                                                            //////////////////
        fn isFnOrType(h: Helpers): bool                     // EXPECT fu::view
            !!(h.mask & (HM_Function | HM_Struct));         //////////////////

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];
            return Helpers(0).isFnOrType.i32;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_HelpersData;
struct s_Helpers;

                                #ifndef DEF_s_HelpersData
                                #define DEF_s_HelpersData
struct s_HelpersData
{
    short mask;
    explicit operator bool() const noexcept
    {
        return false
            || mask
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const short HM_Function = short((short(1) << short(3)));

static const short HM_Struct = short((short(1) << short(5)));

static bool isFnOrType_wwXMrfYX(const s_Helpers& h, fu::view<s_HelpersData> _helpers_data)
{
    return !!short((_helpers_data[h.index].mask & short((HM_Function | HM_Struct))));
}

int fu_MAIN()
{
    fu::vec<s_HelpersData> _helpers_data = fu::vec<s_HelpersData> { fu::slate<1, s_HelpersData> { s_HelpersData { short(0) } } };
    return int(isFnOrType_wwXMrfYX(s_Helpers { 0 }, _helpers_data));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

-----

        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];

            using inline fn GET(h: Helpers): HelpersData
                _helpers_data[h.index];
                                                            //////////////////
            fn isFnOrType(h: Helpers): bool                 // EXPECT fu::view
                !!(h.mask & (HM_Function | HM_Struct));     //////////////////

            return Helpers(0).isFnOrType.i32;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_HelpersData;
struct s_Helpers;

                                #ifndef DEF_s_HelpersData
                                #define DEF_s_HelpersData
struct s_HelpersData
{
    short mask;
    explicit operator bool() const noexcept
    {
        return false
            || mask
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static const short HM_Function = short((short(1) << short(3)));

static const short HM_Struct = short((short(1) << short(5)));

static bool isFnOrType_wiskVfmn(const s_Helpers& h, fu::view<s_HelpersData> _helpers_data)
{
    return !!short((_helpers_data[h.index].mask & short((HM_Function | HM_Struct))));
}

int fu_MAIN()
{
    fu::vec<s_HelpersData> _helpers_data = fu::vec<s_HelpersData> { fu::slate<1, s_HelpersData> { s_HelpersData { short(0) } } };
    return int(isFnOrType_wiskVfmn(s_Helpers { 0 }, _helpers_data));
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec, N_SD_HasStaticInit

-----

        pub fn ref(dest, item: $T, extras) {
            for (mut i = 0; i < dest.len; i++) {
                if (dest[i] >= item) {
                    if (dest[i] != item) {
                        dest.insert(i, item);
                        extras.insert(i, []);
                    }
                    return extras[i];
                }
            }

            dest.push(item);
            extras.push([]);
            return extras[extras.len - 1];
        }

-----

-----

        pub fn ref(dest, item: $T, extras) {
            for (mut i = 0; i < dest.len; i++) {
                if (dest[i] >= item) {
                    if (dest[i] != item) {
                        dest.insert(i, item);
                        extras.insert(i, []);
                    }
                    return extras[i];
                }
            }

            dest.push(item);
            extras.push([]);
            return extras[extras.len - 1];
        }

        fn Map(lax k: $K, lax v: $V) struct {
            keys: $K[];
            vals: $V[];
        };

        fn ref(using ref _, key)
            _0::ref(
                || keys, key,
                || vals);

-----

-----

        pub fn ref(dest, item: $T, extras) {
            for (mut i = 0; i < dest.len; i++) {
                if (dest[i] >= item) {
                    if (dest[i] != item) {
                        dest.insert(i, item);
                        extras.insert(i, []);
                    }
                    return extras[i];
                }
            }

            dest.push(item);
            extras.push([]);
            return extras[extras.len - 1];
        }

        fn Map(lax k: $K, lax v: $V) struct {
            keys: $K[];
            vals: $V[];
        };

        fn ref(using ref _, key)
            _0::ref(
                || keys, key,
                || vals);

        fn main() {
            mut _map: _1::Map(string, string);

            fn upsert(k: string, v: string) _map._1::ref(k) = v;
            upsert("hello", "world");

            // Relaxer failed here while I was trying to get rid of F_REFs from specTypes.
            fn check(k: string) _map._1::ref(k) == "world" ? 0 : 1;
            return check("hello");
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/cmp.h>

struct s_Map_iIYL7rECCBg;

                                #ifndef DEF_s_Map_iIYL7rECCBg
                                #define DEF_s_Map_iIYL7rECCBg
struct s_Map_iIYL7rECCBg
{
    fu::vec<fu::str> keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static fu::vec<fu::str>& l_2_0_akq5FHyc(s_Map_iIYL7rECCBg& _)
{
    return _.keys;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static fu::vec<fu::str>& l_2_1_7RTE6CyC(s_Map_iIYL7rECCBg& _)
{
    return _.vals;
}

                                #ifndef DEF_ref_lvzWj4bMRfa
                                #define DEF_ref_lvzWj4bMRfa
inline fu::str& ref_lvzWj4bM(const fu::str& item, s_Map_iIYL7rECCBg& _)
{
    for (int i = 0; i < l_2_0_akq5FHyc(_).size(); i++)
    {
        if ((l_2_0_akq5FHyc(_)[i] >= item))
        {
            if (l_2_0_akq5FHyc(_)[i] != item)
            {
                l_2_0_akq5FHyc(_).insert(i, fu::str(item));
                l_2_1_7RTE6CyC(_).insert(i, fu::str{});
            };
            return l_2_1_7RTE6CyC(_).mutref(i);
        };
    };
    l_2_0_akq5FHyc(_).push(fu::str(item));
    l_2_1_7RTE6CyC(_).push(fu::str{});
    return l_2_1_7RTE6CyC(_).mutref((l_2_1_7RTE6CyC(_).size() - 1));
}
                                #endif

                                #ifndef DEF_ref_dmH7GomQ6xk
                                #define DEF_ref_dmH7GomQ6xk
inline fu::str& ref_dmH7GomQ(s_Map_iIYL7rECCBg& _, const fu::str& key)
{
    return ref_lvzWj4bM(key, _);
}
                                #endif

static fu::str& upsert_bTm9xmat(const fu::str& k, const fu::str& v, s_Map_iIYL7rECCBg& _map)
{
    return (ref_dmH7GomQ(_map, k) = fu::str(v));
}

static fu::vec<fu::str>& l_2_0_Xk1MkK9h(s_Map_iIYL7rECCBg& _)
{
    return _.keys;
}

static fu::vec<fu::str>& l_2_1_nfDWI1oi(s_Map_iIYL7rECCBg& _)
{
    return _.vals;
}

                                #ifndef DEF_ref_hvsHuPC7qVi
                                #define DEF_ref_hvsHuPC7qVi
inline fu::str& ref_hvsHuPC7(const fu::str& item, s_Map_iIYL7rECCBg& _)
{
    for (int i = 0; i < l_2_0_Xk1MkK9h(_).size(); i++)
    {
        if ((l_2_0_Xk1MkK9h(_)[i] >= item))
        {
            if (l_2_0_Xk1MkK9h(_)[i] != item)
            {
                l_2_0_Xk1MkK9h(_).insert(i, fu::str(item));
                l_2_1_nfDWI1oi(_).insert(i, fu::str{});
            };
            return l_2_1_nfDWI1oi(_).mutref(i);
        };
    };
    l_2_0_Xk1MkK9h(_).push(fu::str(item));
    l_2_1_nfDWI1oi(_).push(fu::str{});
    return l_2_1_nfDWI1oi(_).mutref((l_2_1_nfDWI1oi(_).size() - 1));
}
                                #endif

                                #ifndef DEF_ref_HR5l1Eezgfl
                                #define DEF_ref_HR5l1Eezgfl
inline fu::str& ref_HR5l1Eez(s_Map_iIYL7rECCBg& _, const fu::str& key)
{
    return ref_hvsHuPC7(key, _);
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static int check_x0IPLltv(const fu::str& k, s_Map_iIYL7rECCBg& _map)
{
    if (ref_HR5l1Eez(_map, k) == "world"_fu)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    s_Map_iIYL7rECCBg _map {};
    upsert_bTm9xmat("hello"_fu, "world"_fu, _map);
    return check_x0IPLltv("hello"_fu, _map);
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        struct Node { items: Node[] };

        pure fn rec_useless_ref_simple(ref n: Node, offset: i32)
            offset < n.items.len
                ? rec_useless_ref_simple(:n, offset + 1)
                : offset;

        fn main() {
            mut n = Node([ Node(), Node() ]);
            return rec_useless_ref_simple(:n, 0) - 2;
        }

-----
#include <fu/vec.h>

struct s_Node;
static int rec_useless_ref_simple_QJ3vDA6j(const s_Node&, int);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rec_useless_ref_simple_QJ3vDA6j(const s_Node& n, const int offset)
{
    if (offset < n.items.size())
        return rec_useless_ref_simple_QJ3vDA6j(n, (offset + 1));
    else
        return offset;

}

int fu_MAIN()
{
    s_Node n = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } };
    return rec_useless_ref_simple_QJ3vDA6j(n, 0) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve

-----

        struct Node { items: Node[]; };

        pure fn rec_useless_ref(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += rec_useless_ref(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node(), Node() ]);
            return rec_useless_ref(tree) - 2;
        }

-----
#include <fu/vec.h>

struct s_Node;
static int rec_useless_ref_fxrKgvsN(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int rec_useless_ref_fxrKgvsN(const s_Node& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += rec_useless_ref_fxrKgvsN(n.items[i]);

    return ret;
}

int fu_MAIN()
{
    s_Node tree = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } };
    return rec_useless_ref_fxrKgvsN(tree) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_TypeRecursion, N_TypeResolve, N_RelaxRespec

-----

        struct Node { items: Node[]; };

        fn mrec_useless_ref_A(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ?      mrec_useless_ref_A(n.items[i])
                    : 50 * mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        pure fn mrec_useless_ref_B(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ? 10 * mrec_useless_ref_A(n.items[i])
                    :      mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node([ Node, Node ]), Node([ Node ]) ]);
            return mrec_useless_ref_A(tree) - 103;
        }

-----
#include <fu/vec.h>

struct s_Node;
static int mrec_useless_ref_A_fxrKgvsN(const s_Node&);
static int mrec_useless_ref_B_fxrKgvsN(const s_Node&);

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int mrec_useless_ref_B_fxrKgvsN(const s_Node& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += ((i & 1) ? (10 * mrec_useless_ref_A_fxrKgvsN(n.items[i])) : mrec_useless_ref_B_fxrKgvsN(n.items[i]));

    return ret;
}

static int mrec_useless_ref_A_fxrKgvsN(const s_Node& n)
{
    int ret = n.items.size();
    for (int i = 0; i < n.items.size(); i++)
        ret += ((i & 1) ? mrec_useless_ref_A_fxrKgvsN(n.items[i]) : (50 * mrec_useless_ref_B_fxrKgvsN(n.items[i])));

    return ret;
}

int fu_MAIN()
{
    s_Node tree = s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node { fu::vec<s_Node> { fu::slate<2, s_Node> { s_Node{}, s_Node{} } } }, s_Node { fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node{} } } } } } };
    return mrec_useless_ref_A_fxrKgvsN(tree) - 103;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_TypeRecursion, N_TypeResolve, N_DeadCall, N_RelaxRespec

-----

        fn last(s: $T[])
            s.len ? s[s.len - 1] : throw("len == 0");

        struct Node { kind: string; items: Node[] }

        pure fn check(ref node: Node)
            node.kind != "block" ||
            node.items.last.kind == "return";

        fn main() {
            mut node: Node;
            return node.check ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Node;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str kind;
    fu::vec<s_Node> items;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
            || items
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

inline static const s_Node& last_A7JODjo3(fu::view<s_Node> s)
{
    if (s.size())
        return s[(s.size() - 1)];
    else
        fu::fail("len == 0"_fu);

}

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool check_WsizypDj(const s_Node& node)
{
    return (node.kind != "block"_fu) || (last_A7JODjo3(node.items).kind == "return"_fu);
}

int fu_MAIN()
{
    s_Node node {};
    if (check_WsizypDj(node))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeResolve, N_RelaxRespec

-----

        type Context = string[];

        fn compile_snippets(sources: string[], fnames?: string[]): Context {
            return sources ~ fnames;
        }

        fn ZERO(implicit ref output: string, mut sources: string[]): Context {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                let idx = src.find('X');
                if (idx >= 0) {
                    let moduleA = src.slice(0, idx);
                    let moduleB = src[idx : idx] ~ src[idx + 1 : src.len];
                    let without = src[0 : idx] ~ src[idx + 1 : src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                    i--;
                }
            }

            let ctx = compile_snippets(:sources);
            output ~= sources.join(',') ~ ";";
            return ctx;
        }

        fn ZERO(src: string) ZERO(sources: [ src ]);

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "abc;ab,c;a,bc;a,b,c;" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/view_assign.h>

static fu::vec<fu::str> ZERO_ixjBfNFN(fu::vec<fu::str>&&, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_find_KonMQ4KBuu5
                                #define DEF_find_KonMQ4KBuu5
inline int find_KonMQ4KB(fu::view<char> a, const char b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

static fu::vec<fu::str> compile_snippets_NFNgGMyK(fu::view<fu::str> sources, fu::view<fu::str> fnames)
{
    return sources + fnames;
}

                                #ifndef DEF_join_zqpLPm5h6cf
                                #define DEF_join_zqpLPm5h6cf
inline fu::str join_zqpLPm5h(fu::view<fu::str> a, const char sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = 1;
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            res.mutref(size) = sep;
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static fu::vec<fu::str> ZERO_ixjBfNFN(fu::vec<fu::str>&& sources, fu::str& output)
{
    for (int i = 0; i < sources.size(); i++)
    {
        const fu::str& /*sources|static*/ src = sources[i];
        const int idx = find_KonMQ4KB(src, 'X');
        if ((idx >= 0))
        {
            /*MOV*/ fu::str moduleA = fu::slice(src, 0, idx);
            /*MOV*/ fu::str moduleB = (fu::get_view(src, idx, idx) + fu::get_view(src, (idx + 1), src.size()));
            /*MOV*/ fu::str without = (fu::get_view(src, 0, idx) + fu::get_view(src, (idx + 1), src.size()));
            sources.mutref(i) = static_cast<fu::str&&>(without);
            ZERO_ixjBfNFN(fu::vec<fu::str>(sources), output);
            sources.mutref(i) = static_cast<fu::str&&>(moduleA);
            sources.insert((i + 1), static_cast<fu::str&&>(moduleB));
            i--;
        };
    };
    /*MOV*/ fu::vec<fu::str> ctx = compile_snippets_NFNgGMyK(sources, fu::view<fu::str>{});
    output += (join_zqpLPm5h(sources, ',') + ";"_fu);
    return /*NRVO*/ ctx;
}

static fu::vec<fu::str> ZERO_rDjUc3pO(const fu::str& src, fu::str& output)
{
    return ZERO_ixjBfNFN(fu::vec<fu::str> { fu::slate<1, fu::str> { fu::str(src) } }, output);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str output {};
    ZERO_rDjUc3pO("aXbXc"_fu, output);
    if (output == "abc;ab,c;a,bc;a,b,c;"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        fn ZERO(mut sources: string[], implicit ref output: string) {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                mut idx = 0;
                while ((idx = src.find("X")) > 0) {
                    let sources1 = sources[0 : i]
                        ~ src.slice(0, idx)
                        ~ src.slice(idx + 1, src.len)
                        ~ sources[i + 1 : sources.len];

                    ZERO(sources1);
                    src = src[0 : idx] ~ src[idx + 1 : src.len];
                }
            }

            output ~= sources.join(",") ~ ";";
        }

        fn ZERO(src: string) {
            return ZERO([ src ]);
        }

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "a,b,c;a,bc;ab,c;abc;" ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/find.h>
#include <fu/vec/slice.h>
#include <fu/vec/concat.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>

static void ZERO_SK7J0FiT(fu::vec<fu::str>&&, fu::str&);

#ifndef fu_NO_fdefs

                                #ifndef DEF_join_jCe9HYtvP9c
                                #define DEF_join_jCe9HYtvP9c
inline fu::str join_jCe9HYtv(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> /*a|static*/ head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> /*a|static*/ range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void ZERO_SK7J0FiT(fu::vec<fu::str>&& sources, fu::str& output)
{
    for (int i = 0; i < sources.size(); i++)
    {
        fu::str& /*sources|static*/ src = sources.mutref(i);
        int idx = 0;
        while ((idx = fu::lfind(src, "X"_fu)) > 0)
        {
            /*MOV*/ fu::vec<fu::str> sources1 = (((fu::get_view(sources, 0, i) + fu::slice(src, 0, idx)) + fu::slice(src, (idx + 1), src.size())) + fu::get_view(sources, (i + 1), sources.size()));
            ZERO_SK7J0FiT(static_cast<fu::vec<fu::str>&&>(sources1), output);
            src = (fu::get_view(src, 0, idx) + fu::get_view(src, (idx + 1), src.size()));
        };
    };
    output += (join_jCe9HYtv(sources, ","_fu) + ";"_fu);
}

static void ZERO_rDjUc3pO(const fu::str& src, fu::str& output)
{
    ZERO_SK7J0FiT(fu::vec<fu::str> { fu::slate<1, fu::str> { fu::str(src) } }, output);
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    fu::str output {};
    ZERO_rDjUc3pO("aXbXc"_fu, output);
    if (output == "a,b,c;a,bc;ab,c;abc;"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_FnReopen, N_DeadCode, N_NonTrivAutoCopy, N_RelaxRespec, N_COWRestrict

-----

        fn test(str: [byte]) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }

-----

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg    ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
        return ""_fu;

}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            !!arg   && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (!!arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len  ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
        return ""_fu;

}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg.len && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (arg.size())
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg      ? arg ~ suffix : "";                   

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
        return ""_fu;

}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        novec fn doesnt_copy_arg(arg: string, suffix: byte) 
            arg     && arg ~ suffix;                        

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static fu::str doesnt_copy_arg_uARgOrVH(fu::view<char> arg, const char suffix)
{
    if (arg)
        return arg + suffix;
    else
    {
        return fu::str{};
    };
}

int fu_MAIN()
{
    fu::str share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH"_fu;
    fu::str a = doesnt_copy_arg_uARgOrVH(share, '!');
    fu::str b = doesnt_copy_arg_uARgOrVH(share, '?');
    fu::str c = doesnt_copy_arg_uARgOrVH(""_fu, '.');
    if ((a.size() == b.size()) && (a.size() == 49) && (c.size() == 0))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop(cond, body)         
            do body();
            while (cond);           

        novec fn doesnt_copy_arg(ref nums: i32[]) {
            loop(nums): || {
                mut sum = 0;
                for (mut i = 0; i < nums.len; i++)
                    sum += nums[i]++;
                if (sum >= 10)
                    return sum;
            }
            return 0;
        }

        fn main() {
            mut nums: i32[];
            mut a = doesnt_copy_arg(nums);
            nums ~= 1;
            mut b = doesnt_copy_arg(nums);
            nums ~= 2;
            mut c = doesnt_copy_arg(nums);
            return a == 0 && b == 10 && c == 13 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int doesnt_copy_arg_XMaJvCmc(fu::view_mut<int> nums)
{
    do
    {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums.mutref(i)++;

        if ((sum >= 10))
            return sum;

    }
    while (nums);
    return 0;
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    const int a = doesnt_copy_arg_XMaJvCmc(nums);
    nums += 1;
    const int b = doesnt_copy_arg_XMaJvCmc(nums);
    nums += 2;
    const int c = doesnt_copy_arg_XMaJvCmc(nums);
    if ((a == 0) && (b == 10) && (c == 13))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn loop(cond, body)         
            while (cond) body();    

        novec fn doesnt_copy_arg(ref nums: i32[]) {
            loop(nums): || {
                mut sum = 0;
                for (mut i = 0; i < nums.len; i++)
                    sum += nums[i]++;
                if (sum >= 10)
                    return sum;
            }
            return 0;
        }

        fn main() {
            mut nums: i32[];
            mut a = doesnt_copy_arg(nums);
            nums ~= 1;
            mut b = doesnt_copy_arg(nums);
            nums ~= 2;
            mut c = doesnt_copy_arg(nums);
            return a == 0 && b == 10 && c == 13 ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/concat_one.h>


#ifndef fu_NO_fdefs

static int doesnt_copy_arg_XMaJvCmc(fu::view_mut<int> nums)
{
    while (nums)
    {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++)
            sum += nums.mutref(i)++;

        if ((sum >= 10))
            return sum;

    };
    return 0;
}

int fu_MAIN()
{
    fu::vec<int> nums {};
    const int a = doesnt_copy_arg_XMaJvCmc(nums);
    nums += 1;
    const int b = doesnt_copy_arg_XMaJvCmc(nums);
    nums += 2;
    const int c = doesnt_copy_arg_XMaJvCmc(nums);
    if ((a == 0) && (b == 10) && (c == 13))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn grow_if_oob !T(ref a: T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Target { modid: i32; index: i32 }
        struct Scope { overloads: Overload[]; extended: Extended[] };
        struct Overload { modid: i32 };
        struct Extended { min: i32; locals: Overload[] };

        fn create(ref scope: Scope, modid: i32): Target {
            ref overloads = modid
                ? scope.extended.grow_if_oob(modid).locals
                : scope.overloads;

            let target = Target(:modid, index: overloads.len + 1);
            overloads.push(Overload(:modid));
            return target;
        }

        fn main() {
            mut scope: Scope;
            scope.create(0);
            scope.create(1);
            return scope.overloads.len == 1
                && scope.extended .len == 2 ? 0 : 1;
        }

-----
#include <fu/vec.h>

struct s_Scope;
struct s_Overload;
struct s_Extended;
struct s_Target;

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Extended
                                #define DEF_s_Extended
struct s_Extended
{
    int min;
    fu::vec<s_Overload> locals;
    explicit operator bool() const noexcept
    {
        return false
            || min
            || locals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    fu::vec<s_Overload> overloads;
    fu::vec<s_Extended> extended;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Extended& grow_if_oob_JxRwNw9N(fu::vec<s_Extended>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}

static s_Target create_8WhGrpco(s_Scope& scope, const int modid)
{
    fu::vec<s_Overload>& /*scope|static*/ overloads = (modid ? grow_if_oob_JxRwNw9N(scope.extended, modid).locals : scope.overloads);
    const s_Target target = s_Target { modid, (overloads.size() + 1) };
    overloads.push(s_Overload { modid });
    return target;
}

int fu_MAIN()
{
    s_Scope scope {};
    create_8WhGrpco(scope, 0);
    create_8WhGrpco(scope, 1);
    if ((scope.overloads.size() == 1) && (scope.extended.size() == 2))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };

        struct TP { flags: TPFlags };

        fn doTrySpec(ref typeParams: TP[]) {
            fn useConsumedType(tp)
                tp.flags & (ArgSpec | Typename) == ArgSpec;

            typeParams.each: |ref tp|
                if (tp.useConsumedType)
                    tp.flags |= NeedsConsumed;
        }

        fn main() {
            mut typeParams: TP[] = [
                [ ArgSpec ],
                [ ArgSpec | Typename ],
                [ Typename ],
            ];

            doTrySpec(typeParams);

            mut count = 0;
            typeParams.each: |tp|
                if (tp.flags & NeedsConsumed)
                    count++;

            return count - 1;
        }

-----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_TP;
typedef fu::u8 s_TPFlags;

                                #ifndef DEF_s_TPFlags
                                #define DEF_s_TPFlags
inline constexpr s_TPFlags s_TPFlags_ArgSpec = s_TPFlags(1u);
inline constexpr s_TPFlags s_TPFlags_Typename = s_TPFlags(2u);
inline constexpr s_TPFlags s_TPFlags_NeedsConsumed = s_TPFlags(4u);

inline constexpr s_TPFlags MASK_s_TPFlags
    = s_TPFlags_ArgSpec
    | s_TPFlags_Typename
    | s_TPFlags_NeedsConsumed;
                                #endif

                                #ifndef DEF_s_TP
                                #define DEF_s_TP
struct s_TP
{
    s_TPFlags flags;
    explicit operator bool() const noexcept
    {
        return false
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static bool useConsumedType_yzfNng9m(const s_TP& tp)
{
    return s_TPFlags((tp.flags & s_TPFlags((s_TPFlags_ArgSpec | s_TPFlags_Typename)))) == s_TPFlags_ArgSpec;
}

inline static void l_1_0_fBbFyQOx(s_TP& tp)
{
    if (useConsumedType_yzfNng9m(tp))
        tp.flags |= s_TPFlags_NeedsConsumed;

}

                                #ifndef DEF_each_HBI31MnyGsb
                                #define DEF_each_HBI31MnyGsb
inline void each_HBI31Mny(fu::view_mut<s_TP> a)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_fBbFyQOx(a.mutref(i));

}
                                #endif

static void doTrySpec_51U48go7(fu::view_mut<s_TP> typeParams)
{
    each_HBI31Mny(typeParams);
}

inline static void l_1_1_LIuPBXqH(const s_TP& tp, int& count)
{
    if (tp.flags & s_TPFlags_NeedsConsumed)
        count++;

}

                                #ifndef DEF_each_dHUu4WVWnHf
                                #define DEF_each_dHUu4WVWnHf
inline void each_dHUu4WVW(fu::view<s_TP> a, int& count)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_LIuPBXqH(a[i], count);

}
                                #endif

int fu_MAIN()
{
    fu::vec<s_TP> typeParams = fu::vec<s_TP> { fu::slate<3, s_TP> { s_TP { s_TPFlags_ArgSpec }, s_TP { s_TPFlags((s_TPFlags_ArgSpec | s_TPFlags_Typename)) }, s_TP { s_TPFlags_Typename } } };
    doTrySpec_51U48go7(typeParams);
    int count = 0;
    each_dHUu4WVW(typeParams, count);
    return count - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };

        struct TP { flags: TPFlags };

        fn doTrySpec(ref typeParams: TP[]) {
            fn useConsumedType(tp: TP)
                tp.flags & (ArgSpec | Typename) == ArgSpec;

            typeParams.each: |ref tp|
                if (tp.useConsumedType)
                    tp.flags |= NeedsConsumed;
        }

        fn main() {
            mut typeParams: TP[] = [
                [ ArgSpec ],
                [ ArgSpec | Typename ],
                [ Typename ],
            ];

            doTrySpec(typeParams);

            mut count = 0;
            typeParams.each: |tp|
                if (tp.flags & NeedsConsumed)
                    count++;

            return count - 1;
        }

-----
#include <fu/int.h>
#include <fu/vec.h>
#include <fu/view.h>

struct s_TP;
typedef fu::u8 s_TPFlags;

                                #ifndef DEF_s_TPFlags
                                #define DEF_s_TPFlags
inline constexpr s_TPFlags s_TPFlags_ArgSpec = s_TPFlags(1u);
inline constexpr s_TPFlags s_TPFlags_Typename = s_TPFlags(2u);
inline constexpr s_TPFlags s_TPFlags_NeedsConsumed = s_TPFlags(4u);

inline constexpr s_TPFlags MASK_s_TPFlags
    = s_TPFlags_ArgSpec
    | s_TPFlags_Typename
    | s_TPFlags_NeedsConsumed;
                                #endif

                                #ifndef DEF_s_TP
                                #define DEF_s_TP
struct s_TP
{
    s_TPFlags flags;
    explicit operator bool() const noexcept
    {
        return false
            || flags
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static bool useConsumedType_dBebkRNQ(const s_TP& tp)
{
    return s_TPFlags((tp.flags & s_TPFlags((s_TPFlags_ArgSpec | s_TPFlags_Typename)))) == s_TPFlags_ArgSpec;
}

inline static void l_1_0_TfytOweh(s_TP& tp)
{
    if (useConsumedType_dBebkRNQ(tp))
        tp.flags |= s_TPFlags_NeedsConsumed;

}

                                #ifndef DEF_each_qLsaV4siTrd
                                #define DEF_each_qLsaV4siTrd
inline void each_qLsaV4si(fu::view_mut<s_TP> a)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_TfytOweh(a.mutref(i));

}
                                #endif

static void doTrySpec_51U48go7(fu::view_mut<s_TP> typeParams)
{
    each_qLsaV4si(typeParams);
}

inline static void l_1_1_kL3XDAV3(const s_TP& tp, int& count)
{
    if (tp.flags & s_TPFlags_NeedsConsumed)
        count++;

}

                                #ifndef DEF_each_tteDvCwxW4h
                                #define DEF_each_tteDvCwxW4h
inline void each_tteDvCwx(fu::view<s_TP> a, int& count)
{
    for (int i = 0; i < a.size(); i++)
        l_1_1_kL3XDAV3(a[i], count);

}
                                #endif

int fu_MAIN()
{
    fu::vec<s_TP> typeParams = fu::vec<s_TP> { fu::slate<3, s_TP> { s_TP { s_TPFlags_ArgSpec }, s_TP { s_TPFlags((s_TPFlags_ArgSpec | s_TPFlags_Typename)) }, s_TP { s_TPFlags_Typename } } };
    doTrySpec_51U48go7(typeParams);
    int count = 0;
    each_tteDvCwx(typeParams, count);
    return count - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn Map(type K, type V) struct {
            keys: K[];
            vals: V[];
        };

        fn ref !<K, V>(using ref _: Map(K, V), key: K) {
            for (mut i = 0; i < keys.len; i++)
                if (keys[i] == key)
                    return vals[i];

            keys.push(key);
            vals.push([]);
            return vals[vals.len - 1];
        }

        struct Type { using vtype: i32 };

        fn find_if_odd(ref map: Map(i32, Type), key: i32)
            key & 1
                ? map.ref(key)
                : key & 2 && throw("never");

        fn main() {
            mut map: Map(i32, Type);
            map.keys ~= 1;
            map.vals ~= Type(2);
            return find_if_odd(map, 1) - 2;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/never.h>
#include <fu/vec/concat_one.h>

struct s_Map_2VxdoRBZzyb;
struct s_Type;

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    int vtype;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_2VxdoRBZzyb
                                #define DEF_s_Map_2VxdoRBZzyb
struct s_Map_2VxdoRBZzyb
{
    fu::vec<int> keys;
    fu::vec<s_Type> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

inline static s_Type& ref_TLxNPCJi(s_Map_2VxdoRBZzyb& _, const int key)
{
    for (int i = 0; i < _.keys.size(); i++)
    {
        if (_.keys[i] == key)
            return _.vals.mutref(i);

    };
    _.keys.push(key);
    _.vals.push(s_Type{});
    return _.vals.mutref((_.vals.size() - 1));
}

static int find_if_odd_irSze8tP(s_Map_2VxdoRBZzyb& map, const int key)
{
    if (key & 1)
        return ref_TLxNPCJi(map, key).vtype;
    else if (key & 2)
        fu::fail("never"_fu);
    else
        return 0;

}

int fu_MAIN()
{
    s_Map_2VxdoRBZzyb map {};
    map.keys += 1;
    map.vals += s_Type { 2 };
    return find_if_odd_irSze8tP(map, 1) - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        lax fn longer(l: string, r: string, pick!) {
            let longer = {                                      // GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      // Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",             // ConstCast
                pick: |longer| { break longer; });

            return longer.len - 7;
        }

-----
#include <fu/str.h>


#ifndef fu_NO_fdefs

inline static const fu::str& longer_QgHB6pIZ(const fu::str& l, const fu::str& r)
{
    const fu::str* BL_1_v;
    const fu::str& /*r|l*/ longer = (__extension__ (
    { {
        for (; ; )
        {
            if (l.size() > r.size())
            {
                { BL_1_v = &(l); goto BL_1; };
            }
            else
            {
                { BL_1_v = &(r); goto BL_1; };
            };
        };
      } BL_1:;
    (void)0;}), *BL_1_v);
    return longer;
}

int fu_MAIN()
{
    fu::str longer = static_cast<fu::str&&>(const_cast<fu::str&>(longer_QgHB6pIZ("Hello"_fu, " World!"_fu)));
    return longer.size() - 7;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

-----

        fn no_fx() {
            mut res = 0;
            pragma clock(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        struct X { a: i32[]; b: i32[] };
        fn test(x: X, ref y: i32[])
            y ~= x.a;

        fn main() {
            mut x = X(
                [ no_fx(), 2, 3, 4, 5, 6, 7, 8 ],
                [ no_fx(), 3, 4, 5, 6, 7, 8, 9 ]);

            test(x, x.a);
            return x.a.len + no_fx * 1000 - 1016;
        }

-----
#include <fu/vec.h>
#include <fu/vec/concat.h>

struct s_X;

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    fu::vec<int> a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static int no_fx_H9fhQUVP()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static fu::vec<int>& test_VfbK3BrO(const s_X& x, fu::vec<int>& y)
{
    return (y += x.a);
}

int fu_MAIN()
{
    s_X x = s_X { fu::vec<int> { fu::slate<8, int> { no_fx_H9fhQUVP(), 2, 3, 4, 5, 6, 7, 8 } }, {} };
    test_VfbK3BrO(s_X { fu::vec<int>(x.a), {} }, x.a);
    return (x.a.size() + (no_fx_H9fhQUVP() * 1000)) - 1016;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_UnusedCall, N_UnusedArrlit

-----

        struct A { a: X[] };
        struct B { b: X[] };
        struct C { c: X[] };
        struct X { a: A[]; b: B[]; c?: C[]; };

        fn GET(implicit ref x: X[], idx: int) {
            return x[idx];
        }

        fn DUPE(implicit ref x: X[], idx: int) {
            let src = GET(idx);                                 // GNUStmtExpr
            let idx1 = x.len;

            x.grow(idx1 + 1)
            ref dest = x[idx1];
            dest.a = src.a;
            dest.b = src.b;
        }

        fn main() {
            implicit mut x = [ X([ A(), A() ], [ B(), B(), B() ], [ C(), C(), C(), C(), C() ]) ];
            DUPE(0);
            mut sum = 0;
            for (mut i = 0; i < x.len; i++) {
                shadow let x = x[i];
                sum *= x.a.len || 1; sum += x.a.len;
                sum *= x.b.len || 1; sum += x.b.len;
                sum *= x.c.len || 1; sum += x.c.len;
            }
            return sum - 309;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_X;
struct s_A;
struct s_B;
struct s_C;

                                #ifndef DEF_s_A
                                #define DEF_s_A
struct s_A
{
    fu::vec<s_X> a;
    s_A(const s_A&) = default;
    s_A(s_A&&) = default;
    s_A& operator=(s_A&&) = default;
    s_A& operator=(const s_A& selfrec) { return *this = s_A(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
        ;
    }
};
                                #endif

                                #ifndef DEF_s_B
                                #define DEF_s_B
struct s_B
{
    fu::vec<s_X> b;
    s_B(const s_B&) = default;
    s_B(s_B&&) = default;
    s_B& operator=(s_B&&) = default;
    s_B& operator=(const s_B& selfrec) { return *this = s_B(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || b
        ;
    }
};
                                #endif

                                #ifndef DEF_s_C
                                #define DEF_s_C
struct s_C
{
    fu::vec<s_X> c;
    s_C(const s_C&) = default;
    s_C(s_C&&) = default;
    s_C& operator=(s_C&&) = default;
    s_C& operator=(const s_C& selfrec) { return *this = s_C(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || c
        ;
    }
};
                                #endif

                                #ifndef DEF_s_X
                                #define DEF_s_X
struct s_X
{
    fu::vec<s_A> a;
    fu::vec<s_B> b;
    fu::vec<s_C> c;
    s_X(const s_X&) = default;
    s_X(s_X&&) = default;
    s_X& operator=(s_X&&) = default;
    s_X& operator=(const s_X& selfrec) { return *this = s_X(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
            || c
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_X& GET_6aSKPv4N(const int idx, fu::view_mut<s_X> x)
{
    return x.mutref(idx);
}

static void DUPE_s4GMeut5(const int idx, fu::vec<s_X>& x)
{
    s_X BL_1_v {};
    /*MOV*/ s_X src = (__extension__ (
    {
        const s_X& /*x|static*/ __partcopy_ref = GET_6aSKPv4N(idx, x);
        BL_1_v = (s_X { fu::vec<s_A>(__partcopy_ref.a), fu::vec<s_B>(__partcopy_ref.b), {} });
    (void)0;}), static_cast<s_X&&>(BL_1_v));
    const int idx1 = x.size();
    x.grow((idx1 + 1));
    s_X& /*x|static*/ dest = x.mutref(idx1);
    dest.a = src.a;
    dest.b = static_cast<fu::vec<s_B>&&>(src.b);
}

int fu_MAIN()
{
    fu::vec<s_X> x = fu::vec<s_X> { fu::slate<1, s_X> { s_X { fu::vec<s_A> { fu::slate<2, s_A> { s_A{}, s_A{} } }, fu::vec<s_B> { fu::slate<3, s_B> { s_B{}, s_B{}, s_B{} } }, fu::vec<s_C> { fu::slate<5, s_C> { s_C{}, s_C{}, s_C{}, s_C{}, s_C{} } } } } };
    DUPE_s4GMeut5(0, x);
    int sum = 0;
    for (int i = 0; i < x.size(); i++)
    {
        const s_X& /*x|static*/ x_1 = x[i];
        int _0 {};
        sum *= ((_0 = x_1.a.size()) ? _0 : 1);
        sum += x_1.a.size();
        int _1 {};
        sum *= ((_1 = x_1.b.size()) ? _1 : 1);
        sum += x_1.b.size();
        int _2 {};
        sum *= ((_2 = x_1.c.size()) ? _2 : 1);
        sum += x_1.c.size();
    };
    return sum - 309;
}

#endif

int main() { return fu_MAIN(); }

// N_TypeRecursion, N_TypeReopen, N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

-----

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

-----

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

-----
inline int Each_rQBG6KTt(int);
inline int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_rQBG6KTthAa
                                #define DEF_Each_rQBG6KTthAa
inline int Each_rQBG6KTt(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_rQBG6KTt((y / 2));

}
                                #endif

                                #ifndef DEF_Each_KIoFi8dUuVa
                                #define DEF_Each_KIoFi8dUuVa
inline int Each_KIoFi8dU(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_KIoFi8dU((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_rQBG6KTt(100);
    const int b = Each_KIoFi8dU(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

-----

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

-----
int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

int Each_KIoFi8dU(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_KIoFi8dU((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

-----

        fn Each(y)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

-----
inline int Each_rQBG6KTt(int);
int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_rQBG6KTthAa
                                #define DEF_Each_rQBG6KTthAa
inline int Each_rQBG6KTt(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_rQBG6KTt((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_rQBG6KTt(100);
    const int b = Each_KIoFi8dU(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

-----
int Each_rQBG6KTt(int);

#ifndef fu_NO_fdefs

int Each_rQBG6KTt(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_rQBG6KTt((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

-----

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

-----
int Each_rQBG6KTt(int);
inline int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

                                #ifndef DEF_Each_KIoFi8dUuVa
                                #define DEF_Each_KIoFi8dUuVa
inline int Each_KIoFi8dU(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_KIoFi8dU((y / 2));

}
                                #endif

int fu_MAIN()
{
    const int a = Each_rQBG6KTt(100);
    const int b = Each_KIoFi8dU(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

-----
int Each_rQBG6KTt(int);

#ifndef fu_NO_fdefs

int Each_rQBG6KTt(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_rQBG6KTt((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

-----
int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

int Each_KIoFi8dU(const int y)
{
    if (y & 1)
        return y / 2;
    else
        return (y / 2) + Each_KIoFi8dU((y / 2));

}

#endif

// N_FnRecursion, N_FnResolve

-----

        fn Each(y: i32)
            y & 1   ? y
                    : y / 2 + Each(y / 2);

        fn Each(y: i32)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);

        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }

-----
int Each_rQBG6KTt(int);
int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int a = Each_rQBG6KTt(100);
    const int b = Each_KIoFi8dU(8);
    return (a + b) - 107;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn find(keys: $T[], item: $T) {
            for (mut i = 0; i < keys.len; i++) {
                if (keys[i] >= item) {
                    if (keys[i] != item)
                        return -1;

                    return i;
                }
            }

            return -1;
        }

-----

-----

        fn find(keys: $T[], item: $T) {
            for (mut i = 0; i < keys.len; i++) {
                if (keys[i] >= item) {
                    if (keys[i] != item)
                        return -1;

                    return i;
                }
            }

            return -1;
        }

        fn Set(_: $K) struct { keys: $K[]; };

        fn has(using _, key)
            _0::find(keys, key) >= 0;

-----

-----

        fn find(keys: $T[], item: $T) {
            for (mut i = 0; i < keys.len; i++) {
                if (keys[i] >= item) {
                    if (keys[i] != item)
                        return -1;

                    return i;
                }
            }

            return -1;
        }

        fn Set(_: $K) struct { keys: $K[]; };

        fn has(using _, key)
            _0::find(keys, key) >= 0;

        fn use_Set(a: string) {
            mut set: _1::Set(string);
            set.keys ~= a;
            return set._1::has(a);
        }

        fn dont_use_Set(a: string, b: string) {
            mut keys: string[];
            keys ~= b;
            keys ~= a;
            return keys.find(a);
        }

        fn main() {
            if (!use_Set("a"))
                return -1;

            return dont_use_Set("a", "b") - 1;
        }

-----
#include <fu/str.h>
#include <fu/vec.h>
#include <fu/view.h>
#include <fu/vec/cmp.h>
#include <fu/vec/concat_one.h>

struct s_Set_tq1lp3FQkJ3;

                                #ifndef DEF_s_Set_tq1lp3FQkJ3
                                #define DEF_s_Set_tq1lp3FQkJ3
struct s_Set_tq1lp3FQkJ3
{
    fu::vec<fu::str> keys;
    explicit operator bool() const noexcept
    {
        return false
            || keys
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x21x3D_gCeFmDFw0L8
                                #define DEF_x21x3D_gCeFmDFw0L8
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_find_sciNYFBNeva
                                #define DEF_find_sciNYFBNeva
inline int find_sciNYFBN(fu::view<fu::str> keys, const fu::str& item)
{
    for (int i = 0; i < keys.size(); i++)
    {
        if ((keys[i] >= item))
        {
            if (keys[i] != item)
                return -1;
            else
                return i;

        };
    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_Dc0fjV7j389
                                #define DEF_has_Dc0fjV7j389
inline bool has_Dc0fjV7j(const s_Set_tq1lp3FQkJ3& _, const fu::str& key)
{
    return (find_sciNYFBN(_.keys, key) >= 0);
}
                                #endif

static bool use_Set_J4UHuUKa(const fu::str& a)
{
    s_Set_tq1lp3FQkJ3 set {};
    set.keys += fu::str(a);
    return has_Dc0fjV7j(set, a);
}

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

                                #ifndef DEF_find_g5ZsWtbdNfi
                                #define DEF_find_g5ZsWtbdNfi
inline int find_g5ZsWtbd(fu::view<fu::str> a, fu::view<char> b)
{
    for (int i = 0; i < a.size(); i++)
    {
        if (a[i] == b)
            return i;

    };
    return -1;
}
                                #endif

static int dont_use_Set_dnG7xUve(const fu::str& a, const fu::str& b)
{
    fu::vec<fu::str> keys {};
    keys += fu::str(b);
    keys += fu::str(a);
    return find_g5ZsWtbd(keys, a);
}

int fu_MAIN()
{
    if (!use_Set_J4UHuUKa("a"_fu))
        return -1;
    else
        return dont_use_Set_dnG7xUve("a"_fu, "b"_fu) - 1;

}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy, N_RelaxRespec

-----

        fn test(tokens: i32[]) {
            mut lidx = 0;
            mut sum  = 0;

            fn token(idx: i32, col!: i32)       = sum += idx * col;
            fn token(idx: i32)                  = token(:idx, col: lidx - idx);

            for (mut i = 0; i < tokens.len; i++)
                token(tokens[i]);

            return sum;
        }

        fn main() [ 1 ].test + 1;

-----
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int& token_zNcerWJu(const int idx, const int col, int& sum)
{
    return (sum += (idx * col));
}

static int& token_83AqmgOU(const int idx, const int lidx, int& sum)
{
    return token_zNcerWJu(idx, (lidx - idx), sum);
}

static int test_ylhW3gZg(fu::view<int> tokens)
{
    const int lidx = 0;
    int sum = 0;
    for (int i = 0; i < tokens.size(); i++)
        token_83AqmgOU(tokens[i], lidx, sum);

    return sum;
}

int fu_MAIN()
{
    return test_ylhW3gZg((fu::slate<1, int> { 1 })) + 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn sum_each(a, b, Each)     a.Each + b.Each;

        fn hello(x) {
            if (x & 1) {
                fn Each(y) y    ? y * Each(y - 1)
                                : 100;

                return sum_each(x, x, fn Each);
            }
            else {
                fn Each(y) y    ? y * Each(y - 1)
                                : 10000;

                return sum_each(x, x, fn Each);
            }
        }

-----

-----

        fn sum_each(a, b, Each)     a.Each + b.Each;

        fn hello(x) {
            if (x & 1) {
                fn Each(y) y    ? y * Each(y - 1)
                                : 100;

                return sum_each(x, x, fn Each);
            }
            else {
                fn Each(y) y    ? y * Each(y - 1)
                                : 10000;

                return sum_each(x, x, fn Each);
            }
        }

        fn Each(y) y & 1    ? y
                            : y / 2 + Each(y / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);

-----
inline static int Each_vQxzjS1T(int);
inline static int Each_GxvWNYoY(int);
inline static int Each_KIoFi8dU(int);

#ifndef fu_NO_fdefs

inline static int Each_vQxzjS1T(const int y)
{
    if (y)
        return y * Each_vQxzjS1T((y - 1));
    else
        return 100;

}

                                #ifndef DEF_sum_each_B0bLVHD6Xu6
                                #define DEF_sum_each_B0bLVHD6Xu6
inline int sum_each_B0bLVHD6(const int a, const int b)
{
    return Each_vQxzjS1T(a) + Each_vQxzjS1T(b);
}
                                #endif

inline static int Each_GxvWNYoY(const int y)
{
    if (y)
        return y * Each_GxvWNYoY((y - 1));
    else
        return 10000;

}

                                #ifndef DEF_sum_each_pTlDNPY3fbg
                                #define DEF_sum_each_pTlDNPY3fbg
inline int sum_each_pTlDNPY3(const int a, const int b)
{
    return Each_GxvWNYoY(a) + Each_GxvWNYoY(b);
}
                                #endif

                                #ifndef DEF_hello_1WsbUdatf7c
                                #define DEF_hello_1WsbUdatf7c
inline int hello_1WsbUdat(const int x)
{
    if (x & 1)
        return sum_each_B0bLVHD6(x, x);
    else
        return sum_each_pTlDNPY3(x, x);

}
                                #endif

inline static int Each_KIoFi8dU(const int y)
{
    if (y & 1)
        return y;
    else
        return (y / 2) + Each_KIoFi8dU((y / 2));

}

int fu_MAIN()
{
    return ((hello_1WsbUdat(1) - (2 * Each_KIoFi8dU(100))) + hello_1WsbUdat(2)) - (2 * Each_KIoFi8dU(20000));
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnResolve, N_DeadCode

-----

        fn a        = "aaa";
        fn shorter  = "bb";
        fn greater  = "aac";

        return a <> shorter == +1
            && a <> greater == -1 ? 0 : 101;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static fu::str a_EJhRWC6k()
{
    return "aaa"_fu;
}

static fu::str shorter_y1jV3SX3()
{
    return "bb"_fu;
}

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

static fu::str greater_hpa9AihZ()
{
    return "aac"_fu;
}

int fu_MAIN()
{
    if ((x3Cx3E_gCeFmDFw(a_EJhRWC6k(), shorter_y1jV3SX3()) == +1) && (x3Cx3E_gCeFmDFw(a_EJhRWC6k(), greater_hpa9AihZ()) == -1))
        return 0;
    else
        return 101;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn &(a, b) {
            mut res = a;
            for (fieldname i: typeof(a)) res.i &= b.i;
            return res;
        }

        struct XY  { x: i32; y: i32 };
        struct UVW { u: i32; v: i32; w: i32 };

-----

-----

        fn &(a, b) {
            mut res = a;
            for (fieldname i: typeof(a)) res.i &= b.i;
            return res;
        }

        struct XY  { x: i32; y: i32 };
        struct UVW { u: i32; v: i32; w: i32 };

        import _0;

        fn main() {
            mut xy  =  XY(1, 2)    &  XY(2, 3);
            mut uvw = UVW(1, 2, 3) & UVW(2, 3, 4);
            return xy.y - uvw.v;
        }

-----
struct s_XY;
struct s_UVW;

                                #ifndef DEF_s_XY
                                #define DEF_s_XY
struct s_XY
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

                                #ifndef DEF_s_UVW
                                #define DEF_s_UVW
struct s_UVW
{
    int u;
    int v;
    int w;
    explicit operator bool() const noexcept
    {
        return false
            || u
            || v
            || w
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x26_Im268WiBGz8
                                #define DEF_x26_Im268WiBGz8
inline s_XY operator&(const s_XY& a, const s_XY& b)
{
    s_XY res { a };

    {
        res.x &= b.x;
        res.y &= b.y;
    };
    return res;
}
                                #endif

                                #ifndef DEF_x26_hvvSofCDFp8
                                #define DEF_x26_hvvSofCDFp8
inline s_UVW operator&(const s_UVW& a, const s_UVW& b)
{
    s_UVW res { a };

    {
        res.u &= b.u;
        res.v &= b.v;
        res.w &= b.w;
    };
    return res;
}
                                #endif

int fu_MAIN()
{
    const s_XY xy = (s_XY { 1, 2 } & s_XY { 2, 3 });
    const s_UVW uvw = (s_UVW { 1, 2, 3 } & s_UVW { 2, 3, 4 });
    return xy.y - uvw.v;
}

#endif

int main() { return fu_MAIN(); }

-----

        struct Projection { x: i32; y: i32 };
        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);
        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);

-----
struct s_Projection;

                                #ifndef DEF_s_Projection
                                #define DEF_s_Projection
struct s_Projection
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

s_Projection Projection_hwGp0ETu(const int a, const int b)
{
    return s_Projection { (a * a), (b * b) };
}

s_Projection Projection_ggha33WP(const int c, const int d)
{
    return s_Projection { (c + c), (d + d) };
}

#endif

-----

        struct Projection { x: i32; y: i32 };
        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);
        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);

        import _0;

        fn main() {
            let p0 = Projection(a: 3,  4);
            let p1 = Projection(c: 20, 30);
            return p0.x + p1.x - 49;
        }

-----
struct s_Projection;
s_Projection Projection_hwGp0ETu(int, int);
s_Projection Projection_ggha33WP(int, int);

                                #ifndef DEF_s_Projection
                                #define DEF_s_Projection
struct s_Projection
{
    int x;
    int y;
    explicit operator bool() const noexcept
    {
        return false
            || x
            || y
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Projection p0 = Projection_hwGp0ETu(3, 4);
    const s_Projection p1 = Projection_ggha33WP(20, 30);
    return (p0.x + p1.x) - 49;
}

#endif

int main() { return fu_MAIN(); }

-----

        pragma emit(`
            void ccIncrX2(int& a, int b) {
                a += b * 2;
            }
        `);

        fn main() {
            mut a = 0;
            pragma emit("ccIncrX2(", a, ", 5);");
            return a - 10;
        }

-----
void ccIncrX2(int& a, int b) {
    a += b * 2;
}

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    int a = 0;
    ccIncrX2(a, 5);

    return a - 10;
}

#endif

int main() { return fu_MAIN(); }

-----

        pragma emit("// needs newline");
        pragma emit(`
            namespace {
            }
        `);
        fn main() 0;

-----
// needs newline
namespace {
}

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        fn desc(a: i32, b: i32) b < a;

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(fn desc);
            return vals[0] - 2;
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

static bool desc_hwGp0ETu(const int a, const int b)
{
    return b < a;
}

static void sort_vboY3Pmp(fu::vec<int>& a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = desc_hwGp0ETu(l, r);
    return lt;
            });

}

                                #ifndef DEF_sort_urq5NFj0okj
                                #define DEF_sort_urq5NFj0okj
inline void sort_urq5NFj0(fu::vec<int>& a)
{
    sort_vboY3Pmp(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    sort_urq5NFj0(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a: i32, b: i32| b < a);
            return vals[0] - 2;
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

static bool l_1_0_qoaTQFTa(const int a, const int b)
{
    return b < a;
}

static void sort_vboY3Pmp(fu::vec<int>& a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = l_1_0_qoaTQFTa(l, r);
    return lt;
            });

}

                                #ifndef DEF_sort_IaPFwlDqx2c
                                #define DEF_sort_IaPFwlDqx2c
inline void sort_IaPFwlDq(fu::vec<int>& a)
{
    sort_vboY3Pmp(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    sort_IaPFwlDq(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a, b| b < a);
            return vals[0] - 2;
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

inline static bool l_1_0_Er2zHL3S(const int a, const int b)
{
    return b < a;
}

static void sort_h2RRl8wS(fu::vec<int>& a)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = l_1_0_Er2zHL3S(l, r);
    return lt;
            });

}

                                #ifndef DEF_sort_aTtcayEql5a
                                #define DEF_sort_aTtcayEql5a
inline void sort_aTtcayEq(fu::vec<int>& a)
{
    sort_h2RRl8wS(a);
}
                                #endif

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    sort_aTtcayEq(vals);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(ref vals: i32[], xor: i32)
            vals.sort(
                |a: i32, b: i32|
                    a^xor < b^xor);

        fn main() {
            mut vals = [ 1, 2 ];
            vals.test(xor: 3); // xor:3 descs 1 and 2.
            return vals[0] - 2;
        }

-----
#include <fu/vec.h>
#include <algorithm>


#ifndef fu_NO_fdefs

static bool l_1_0_PFhG6zLk(const int a, const int b, const int xOr)
{
    return (a ^ xOr) < (b ^ xOr);
}

static void sort_ynS5Lt2u(fu::vec<int>& a, const int xOr)
{
    int l {};
    int r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = l_1_0_PFhG6zLk(l, r, xOr);
    return lt;
            });

}

                                #ifndef DEF_sort_RZDo9YcCc68
                                #define DEF_sort_RZDo9YcCc68
inline void sort_RZDo9YcC(fu::vec<int>& a, const int xOr)
{
    sort_ynS5Lt2u(a, xOr);
}
                                #endif

static void test_wFAfjTjW(fu::vec<int>& vals, const int xOr)
{
    sort_RZDo9YcC(vals, xOr);
}

int fu_MAIN()
{
    fu::vec<int> vals = fu::vec<int> { fu::slate<2, int> { 1, 2 } };
    test_wFAfjTjW(vals, 3);
    return vals[0] - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];

            arr.par::each: |it| it *= 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 8;
        }

-----

-----

        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];
            mut sum = 0;


            arr.par::each: |it| 
                sum += it *= 2;                                 ;; PointlessMustSeq

            return sum - 2 - 4 - 6 - 8;
        }

-----
[2m/Users/hdachev/fu/lib/[0mpar[2m.fu 2:5+7[0m:

[2m      | [0m
[2m    2 | [0mpub [31;1mpurectx[0m fn each(arr: [$T], visit, min!?: int)
[2m      |     parallel_for(:min, end: arr.len): |i|[0m
[2m      |         visit(arr[i], i?: i);[0m

	[35;1mfn[0m [34;1meach[0m is not purectx, writes to [35;1minjected implicit ref arg[0m [34;1mmain:sum[0m:

            via [35;1mfn[0m [34;1mparallel_for[0m at [2m../lib/[0mpar[2m.fu 3:17+1[0m:

[2m      | [0m
[2m      | pub purectx fn each(arr: [$T], visit, min!?: int)[0m
[2m    3 | [0m    parallel_for[31;1m([0m:min, end: arr.len): |i|
[2m      |         visit(arr[i], i?: i);[0m
[2m      | [0m

            via [35;1mfn[0m [34;1ml_2_0[0m at [2m../lib/[0mpar[2m.fu 49:14+1[0m:

[2m      |         // And this magically still looks like a loop -[0m
[2m      |         //  no linear / affine nonsense etc.[0m
[2m   49 | [0m        visit[31;1m([0mi);
[2m      |     }[0m
[2m      | [0m

            via [35;1mfn[0m [34;1ml_1_0[0m at [2m../lib/[0mpar[2m.fu 4:14+1[0m:

[2m      | pub purectx fn each(arr: [$T], visit, min!?: int)[0m
[2m      |     parallel_for(:min, end: arr.len): |i|[0m
[2m    4 | [0m        visit[31;1m([0marr[i], i?: i);
[2m      | [0m
[2m      | pub purectx fn zip(arr: [$T], barr: [$U], visit, min!?: int)[0m

            via [35;1m__native[0m [34;1m+=[0m at [2m12:21+2[0m:

[2m      | [0m
[2m      |             arr.par::each: |it| [0m
[2m   12 | [0m                sum [31;1m+=[0m it *= 2;                                 // PointlessMustSeq
[2m      | [0m
[2m      |             return sum - 2 - 4 - 6 - 8;[0m


        Solving [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];
            mut sum = 0;


            arr.seq__each: |it| 
                sum += it *= 2;                                 // PointlessMustSeq

            return sum - 2 - 4 - 6 - 8;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static int& l_1_0_YVWubm5W(int& it, int& sum)
{
    return (sum += (it *= 2));
}

inline static void seq__each_c2tv83DT(fu::view_mut<int> a, int& sum)
{
    for (int i = 0; i < a.size(); i++)
        l_1_0_YVWubm5W(a.mutref(i), sum);

}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
    int sum = 0;
    seq__each_c2tv83DT(arr, sum);
    return (((sum - 2) - 4) - 6) - 8;
}

#endif

int main() { return fu_MAIN(); }

// N_AARMustSeq

-----

        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];


            arr.par::each: |it| 
                if ((it *= 2) > 4)
                    break;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;
        }

-----
[2m/Users/hdachev/fu/lib/[0mpar[2m.fu 26:25+12[0m:

[2m      | //   without function types with noflow & purectx assertions.[0m
[2m      | [0m
[2m   26 | [0mnovec noflow nothrow fn [31;1mparallel_for[0m(min!, mut end!, visit)
[2m      | {[0m
[2m      |     mut start = end & 0;[0m

	[35;1mfn[0m [34;1mparallel_for[0m is not noflow: contains non-local control flow, jumping out to [35;1mfn[0m [34;1meach[0m.

        Solving [35;1mfn[0m [34;1meach[0m(i32[:], @130, i32) at [2m../lib/[0mpar[2m.fu 2:16+4[0m
                [35;1mfn[0m [34;1mmain[0m at [2m6:12+4[0m

-----

        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];


            arr.seq__each: |it| 
                if ((it *= 2) > 4)
                    break;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

inline static void seq__each_qAjNhGwE(fu::view_mut<int> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        int& /*a|static*/ it = a.mutref(i);
        if ((it *= 2) > 4)
            return;

    };
}

int fu_MAIN()
{
    fu::vec<int> arr = fu::vec<int> { fu::slate<4, int> { 1, 2, 3, 4 } };
    seq__each_qAjNhGwE(arr);
    int sum = 0;
    for (int i = 0; i < arr.size(); i++)
        sum += arr[i];

    return (((sum - 2) - 4) - 6) - 4;
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        fn test(ref arr: i32[])
            arr.par::each: |v, i| v += i;

        fn main() {
            let N = 1087 * 1091;

            mut orig: i32[];
            orig.resize(N);

            mut arr = orig;
            arr.test();

            if (arr.len != N || arr.len != orig.len)
                return 1;

            for (mut i = 0; i < N; i++)
                if (orig[i] != 0)
                    return 2;

            for (mut i = 0; i < N; i++)
                if (arr[i] != i)
                    return 3;

            return 0;
        }

-----

-----

        fn main() {
            let i: i8 = 0;

            return i;        
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:20+1[0m:

[2m      |             let i: i8 = 0;[0m
[2m      | [0m
[2m    5 | [0m            return [31;1mi[0m;        
[2m      |         }[0m
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- i8 copy AlwaysFalse

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {
            let i: i8 = 0;

            return i.i32;    
        }

-----
#include <fu/int.h>


#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const fu::i8 i = fu::i8(0);
    return int(i);
}

#endif

int main() { return fu_MAIN(); }

-----

        primitive s32: i32;

        fn main() {
            let i: s32 = 0;

            return i;        
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:20+1[0m:

[2m      |             let i: s32 = 0;[0m
[2m      | [0m
[2m    7 | [0m            return [31;1mi[0m;        
[2m      |         }[0m
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- i32/11 copy AlwaysFalse

        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        primitive s32: i32;

        fn main() {
            let i: s32 = 0;

            return i.i32;    
        }

-----
typedef int s_s32;

                                #ifndef DEF_s_s32
                                #define DEF_s_s32
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_s32 i = 0;
    return int(i);
}

#endif

int main() { return fu_MAIN(); }

-----

        enum Enum { None = 0 };

        fn main() {
            let e = Enum.None;

            return e;        
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 7:20+1[0m:

[2m      |             let e = Enum.None;[0m
[2m      | [0m
[2m    7 | [0m            return [31;1me[0m;        
[2m      |         }[0m
[2m      | [0m

	Actual return type does not match annotation: i32 copy <- e8/11 copy

        Solving [35;1mfn[0m [34;1mmain[0m at [2m4:12+4[0m

-----

        enum Enum { None = 0 };

        fn main() {
            let e = Enum.None;

            return e.i32;    
        }

-----
#include <fu/int.h>

enum s_Enum: fu::u8;

                                #ifndef DEF_s_Enum
                                #define DEF_s_Enum
enum s_Enum: fu::u8
{
    s_Enum_None = 0u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Enum e = s_Enum_None;
    return int(e);
}

#endif

int main() { return fu_MAIN(); }

-----

        using enum Test { A = 5; B; C };
        fn main()

            C - 7;      

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:15+1[0m:

[2m      |         fn main()[0m
[2m      | [0m
[2m    5 | [0m            C [31;1m-[0m 7;      
[2m      | [0m

	Bad call to [34;1m-[0m with args (e8/11 copy, i32 copy AlwaysTrue): 

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: e8/11 Typename <-> i32 Typename

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m3:12+4[0m

-----

        using enum Test { A = 5; B; C };
        fn main()

            C.i32 - 7;  

-----
#include <fu/int.h>

enum s_Test: fu::u8;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
enum s_Test: fu::u8
{
    s_Test_A = 5u,
    s_Test_B = 6u,
    s_Test_C = 7u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(s_Test_C) - 7;
}

#endif

int main() { return fu_MAIN(); }

-----

        using

        enum       Test: i32 { A1; A2; M5 = 5; A6 };

        fn main()
            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000
                == 6521 ? 0 : 1;

-----
enum s_Test: int;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
enum s_Test: int
{
    s_Test_A1 = 1,
    s_Test_A2 = 2,
    s_Test_M5 = 5,
    s_Test_A6 = 6,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if ((((int(s_Test_A1) + (int(s_Test_A2) * 10)) + (int(s_Test_M5) * 100)) + (int(s_Test_A6) * 1000)) == 6521)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using

        primitive  Test: i32 { A1; A2; M5 = 5; A6 };

        fn main()
            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000
                == 6521 ? 0 : 1;

-----
typedef int s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
inline constexpr s_Test s_Test_A1 = 1;
inline constexpr s_Test s_Test_A2 = 2;
inline constexpr s_Test s_Test_M5 = 5;
inline constexpr s_Test s_Test_A6 = 6;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if ((((int(s_Test_A1) + (int(s_Test_A2) * 10)) + (int(s_Test_M5) * 100)) + (int(s_Test_A6) * 1000)) == 6521)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using

        enum          Test: i32 { A; B };
        fn main() (B - A).i32 - 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:22+1[0m:

[2m      | [0m
[2m      |         enum          Test: i32 { A; B };[0m
[2m    5 | [0m        fn main() (B [31;1m-[0m A).i32 - 1;
[2m      | [0m

	Bad call to [34;1m-[0m with args (e32/11 copy, e32/11 copy): 

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 10:10+1[0m:
[2m   10 | [0minfix fn [31;1m-[0m !T(a: T, b: T) case (T.is::arithmetic): T __native;

	    No body pattern matched.

	[35;1mtemplate[0m [34;1m-[0m at [2m../../../../../[0mprelude[2m 7:11+1[0m:
[2m    7 | [0mprefix fn [31;1m-[0m !T(a: T) case (T.is::arithmetic): T __native;

	    Wrong number of arguments: expects 1, got 2.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m5:12+4[0m

-----

        using

        primitive     Test: i32 { A; B };
        fn main() (B - A).i32 - 1;

-----
typedef int s_Test;

                                #ifndef DEF_s_Test
                                #define DEF_s_Test
inline constexpr s_Test s_Test_A = 1;
inline constexpr s_Test s_Test_B = 2;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((s_Test_B - s_Test_A)) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        enum EnumA: i32;
        enum EnumB: EnumA { Zero = 0 };
        fn main() EnumB.Zero.i32;

-----
enum s_EnumB: int;

                                #ifndef DEF_s_EnumB
                                #define DEF_s_EnumB
enum s_EnumB: int
{
    s_EnumB_Zero = 0,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int(s_EnumB_Zero);
}

#endif

int main() { return fu_MAIN(); }

-----

        primitive PrimA: i32;
        using primitive PrimB: PrimA { Zero = 0; One };
        fn main() (One - 1).i32;

-----
typedef int s_PrimB;

                                #ifndef DEF_s_PrimB
                                #define DEF_s_PrimB
inline constexpr s_PrimB s_PrimB_Zero = 0;
inline constexpr s_PrimB s_PrimB_One = 1;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return int((s_PrimB_One - 1));
}

#endif

int main() { return fu_MAIN(); }

-----

        primitive PrimA: i32;
        primitive PrimB: PrimA { Zero = 0; One };


        fn and_decr(ref prim: PrimB)
        {
            mut res = prim - 1;
            prim &&= res;
            return prim;
        }


        fn main() {
            mut r = PrimB.One;
            return r.and_decr.i32;
        }

-----
typedef int s_PrimB;

                                #ifndef DEF_s_PrimB
                                #define DEF_s_PrimB
inline constexpr s_PrimB s_PrimB_Zero = 0;
inline constexpr s_PrimB s_PrimB_One = 1;
                                #endif

#ifndef fu_NO_fdefs

static s_PrimB& and_decr_QJ81RzZw(s_PrimB& prim)
{
    const s_PrimB res = (prim - 1);
    if (prim)
        prim = res;

    return prim;
}

int fu_MAIN()
{
    s_PrimB r = s_PrimB_One;
    return int(and_decr_QJ81RzZw(r));
}

#endif

int main() { return fu_MAIN(); }

-----

        primitive PrimA: i32;
        primitive PrimB: PrimA { Zero = 0; One };


        fn and_decr(ref prim: PrimB)
            prim &&= prim - 1;


        fn main() {
            mut r = PrimB.One;
            return r.and_decr.i32;
        }

-----
typedef int s_PrimB;

                                #ifndef DEF_s_PrimB
                                #define DEF_s_PrimB
inline constexpr s_PrimB s_PrimB_Zero = 0;
inline constexpr s_PrimB s_PrimB_One = 1;
                                #endif

#ifndef fu_NO_fdefs

static s_PrimB& and_decr_QJ81RzZw(s_PrimB& prim)
{
    return !prim ? prim : (prim = (prim - 1));
}

int fu_MAIN()
{
    s_PrimB r = s_PrimB_One;
    return int(and_decr_QJ81RzZw(r));
}

#endif

int main() { return fu_MAIN(); }

-----

        enum Hey { foo; };
        fn test(hey: Hey) hey.i32;
        fn main() test("foo") - 1;

-----
#include <fu/int.h>

enum s_Hey: fu::u8;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
enum s_Hey: fu::u8
{
    s_Hey_foo = 1u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_S57s7bW4(const s_Hey hey)
{
    return int(hey);
}

int fu_MAIN()
{
    return test_S57s7bW4(s_Hey_foo) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        using enum Greet { hello; world };
        fn main()
            hello ~ " " ~ world == "hello world"
                ? 0 : 1;

-----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

enum s_Greet: fu::u8;

                                #ifndef DEF_s_Greet
                                #define DEF_s_Greet
enum s_Greet: fu::u8
{
    s_Greet_hello = 1u,
    s_Greet_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_str_qz0AO8LT3ki
                                #define DEF_str_qz0AO8LT3ki
inline fu::str str_qz0AO8LT(const s_Greet n)
{
    if (n == s_Greet_hello)
        return "hello"_fu;
    else if (n == s_Greet_world)
        return "world"_fu;

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if (x7E_gCeFmDFw(x7E_gCeFmDFw(str_qz0AO8LT(s_Greet_hello), " "_fu), str_qz0AO8LT(s_Greet_world)) == "hello world"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        enum Greet { hello; world };
        fn woot(hi: Greet) hi == "hello";
        fn main() Greet.hello.woot ? 0 : 1;

-----
#include <fu/int.h>

enum s_Greet: fu::u8;

                                #ifndef DEF_s_Greet
                                #define DEF_s_Greet
enum s_Greet: fu::u8
{
    s_Greet_hello = 1u,
    s_Greet_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool woot_htmFOpLJ(const s_Greet hi)
{
    return hi == s_Greet_hello;
}

int fu_MAIN()
{
    if (woot_htmFOpLJ(s_Greet_hello))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using enum Greet { hello; world };
        fn h() Greet.hello;
        fn w() Greet.world;

-----
#include <fu/int.h>

enum s_Greet: fu::u8;

                                #ifndef DEF_s_Greet
                                #define DEF_s_Greet
enum s_Greet: fu::u8
{
    s_Greet_hello = 1u,
    s_Greet_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

s_Greet h_H9fhQUVP()
{
    return s_Greet_hello;
}

s_Greet w_H9fhQUVP()
{
    return s_Greet_world;
}

#endif

-----

        using enum Greet { hello; world };
        fn h() Greet.hello;
        fn w() Greet.world;

        fn main()
            _0::h() ~ " " ~ _0::w() == "hello world"
                ? 0 : 1;

-----
#include <cstdint>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/view.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>

enum s_Greet: fu::u8;
s_Greet h_H9fhQUVP();
s_Greet w_H9fhQUVP();

                                #ifndef DEF_s_Greet
                                #define DEF_s_Greet
enum s_Greet: fu::u8
{
    s_Greet_hello = 1u,
    s_Greet_world = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_str_qz0AO8LT3ki
                                #define DEF_str_qz0AO8LT3ki
inline fu::str str_qz0AO8LT(const s_Greet n)
{
    if (n == s_Greet_hello)
        return "hello"_fu;
    else if (n == s_Greet_world)
        return "world"_fu;

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x7E_gCeFmDFw0L8
                                #define DEF_x7E_gCeFmDFw0L8
inline fu::str x7E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

int fu_MAIN()
{
    if (x7E_gCeFmDFw(x7E_gCeFmDFw(str_qz0AO8LT(h_H9fhQUVP()), " "_fu), str_qz0AO8LT(w_H9fhQUVP())) == "hello world"_fu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using enum _0 { A; B };

-----

-----

        using enum _0 { A; B };

        fn test(::_0) _0.i32;
        fn main() "A".test - _0::A.i32;

-----
#include <fu/int.h>

enum s__0: fu::u8;

                                #ifndef DEF_s__0
                                #define DEF_s__0
enum s__0: fu::u8
{
    s__0_A = 1u,
    s__0_B = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_6deM7hub(const s__0 _0)
{
    return int(_0);
}

int fu_MAIN()
{
    return test_6deM7hub(s__0_A) - int(s__0_A);
}

#endif

int main() { return fu_MAIN(); }

-----

        enum _0 { A; B };

-----

-----

        enum _0 { A; B };

        fn test(x: ::_0 = "B") x.i32;
        fn main() test - ::_0.B.i32;

-----
#include <fu/int.h>

enum s__0: fu::u8;

                                #ifndef DEF_s__0
                                #define DEF_s__0
enum s__0: fu::u8
{
    s__0_A = 1u,
    s__0_B = 2u,
};
                                #endif

#ifndef fu_NO_fdefs

static int test_04SuPsWE(const s__0 x)
{
    return int(x);
}

int fu_MAIN()
{
    return test_04SuPsWE(s__0_B) - int(s__0_B);
}

#endif

int main() { return fu_MAIN(); }

-----

        enum Enum { A = 0; B };
        fn inner(x: Enum) x.i32;
        fn outer(x: i32) inner(x & 1 ? "B" : "A");
        fn main() outer(0);

-----
#include <fu/int.h>

enum s_Enum: fu::u8;

                                #ifndef DEF_s_Enum
                                #define DEF_s_Enum
enum s_Enum: fu::u8
{
    s_Enum_A = 0u,
    s_Enum_B = 1u,
};
                                #endif

#ifndef fu_NO_fdefs

static int inner_ju68XN2S(const s_Enum x)
{
    return int(x);
}

static int outer_1WsbUdat(const int x)
{
    return inner_ju68XN2S(((x & 1) ? s_Enum_B : s_Enum_A));
}

int fu_MAIN()
{
    return outer_1WsbUdat(0);
}

#endif

int main() { return fu_MAIN(); }

-----

        using flags Flags { A; B; C; D };

        fn main() {
            mut flags = A | C;
            return flags.i32 == 5 ? 0 : 1;
        }

-----
#include <fu/int.h>

typedef fu::u8 s_Flags;

                                #ifndef DEF_s_Flags
                                #define DEF_s_Flags
inline constexpr s_Flags s_Flags_A = s_Flags(1u);
inline constexpr s_Flags s_Flags_B = s_Flags(2u);
inline constexpr s_Flags s_Flags_C = s_Flags(4u);
inline constexpr s_Flags s_Flags_D = s_Flags(8u);

inline constexpr s_Flags MASK_s_Flags
    = s_Flags_A
    | s_Flags_B
    | s_Flags_C
    | s_Flags_D;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Flags flags = s_Flags((s_Flags_A | s_Flags_C));
    if (int(flags) == 5)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        flags Flags: i32 { A; B };

        fn main() {
            mut hello = 5;
            mut world = hello.Flags;
            return world.i32 - 1;
        }

-----
typedef int s_Flags;

                                #ifndef DEF_s_Flags
                                #define DEF_s_Flags
inline constexpr s_Flags s_Flags_A = 1;
inline constexpr s_Flags s_Flags_B = 2;

inline constexpr s_Flags MASK_s_Flags
    = s_Flags_A
    | s_Flags_B;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const int hello = 5;
    const s_Flags world = s_Flags((hello) & MASK_s_Flags);
    return int(world) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        using flags Hey: u8 { A; B };
        fn main() {
            mut flags = A | B;
            flags &= ~B;
            return flags.i32 - 1;
        }

-----
#include <fu/int.h>

typedef fu::u8 s_Hey;

                                #ifndef DEF_s_Hey
                                #define DEF_s_Hey
inline constexpr s_Hey s_Hey_A = s_Hey(1u);
inline constexpr s_Hey s_Hey_B = s_Hey(2u);

inline constexpr s_Hey MASK_s_Hey
    = s_Hey_A
    | s_Hey_B;
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    s_Hey flags = s_Hey((s_Hey_A | s_Hey_B));
    flags &= s_Hey(~s_Hey_B);
    return int(flags) - 1;
}

#endif

int main() { return fu_MAIN(); }

-----

        enum thing { i32; int; bool }

        // So the problem is the retval annotation for fn ==(template): bool
        //  fails to resolve as it conflicts with enumv from thing here.
        //
        // I'm not terribly sure what we want to do about it,
        //  it's the ambiguity thing again - template sees the enum on expansion,
        //   so it does kinda make sense for thing not to compile,
        //    otherwise imagine the original bool goes away,
        //     it'd fallback to the enumv here, which is exactly not what we want.
        //
        // Perhaps the scoping rules for templates don't make so much sense,
        //  if we didn't make everything from local scope visible
        //   they'll also compile faster.
        //
        fn isInt (k: thing) k == "i32" || k == "int";
        fn isBool(k: thing) k == "bool";
        fn main() isInt("i32") && isBool("bool") ? 0 : 1;

-----
#include <fu/int.h>

enum s_thing: fu::u8;

                                #ifndef DEF_s_thing
                                #define DEF_s_thing
enum s_thing: fu::u8
{
    s_thing_i32 = 1u,
    s_thing_int = 2u,
    s_thing_bool = 3u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool isInt_kEmt8Y6Z(const s_thing k)
{
    return (k == s_thing_i32) || (k == s_thing_int);
}

static bool isBool_kEmt8Y6Z(const s_thing k)
{
    return k == s_thing_bool;
}

int fu_MAIN()
{
    if (isInt_kEmt8Y6Z(s_thing_i32) && isBool_kEmt8Y6Z(s_thing_bool))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        enum ID: u64 {
            // clang warned with -Wimplicitly-unsigned-literal
            CustomIDs = 0x8000_0000_0000_0000;
            BitmapFontAtlas;
        };

        fn main() {
            mut id: u64 = ID.BitmapFontAtlas.u64;
            // meawhile this outputted the underscores
            return id == 0x8000_0000_0000_0001 ? 0 : 1;
        }

-----
#include <cstdint>

enum s_ID: uint64_t;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: uint64_t
{
    s_ID_CustomIDs = 0x8000000000000000ull,
    s_ID_BitmapFontAtlas = 9223372036854775809ull,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const uint64_t id = uint64_t(s_ID_BitmapFontAtlas);
    if (id == 0x8000000000000001ull)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        using enum ID: u32 {
            SecondLast = 0xffff_fffe;
            Last;

            NoRoom; 
        };

        fn main() {
            return Last.u32 == 0xffff_ffff ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:15+4[0m:

[2m      | [0m
[2m    2 | [0m        using [31;1menum[0m ID: u32 {
[2m      |             SecondLast = 0xffff_fffe;[0m
[2m      |             Last;[0m

	Primitive range exhausted: requires 64 bits, got 32.

        Solving [35;1mtype[0m [34;1mID[0m

-----

        using enum ID: u32 {
            SecondLast = 0xffff_fffe;
            Last;

        };

        fn main() {
            return Last.u32 == 0xffff_ffff ? 0 : 1;
        }

-----
enum s_ID: unsigned;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: unsigned
{
    s_ID_SecondLast = 0xfffffffeu,
    s_ID_Last = 4294967295u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (unsigned(s_ID_Last) == 0xffffffffu)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        enum ID: u64 {
            SecondLast = 0xffff_ffff_ffff_fffe;
            Last;

            NoRoom; 
        };

        fn main() {
            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 2:9+4[0m:

[2m      | [0m
[2m    2 | [0m        [31;1menum[0m ID: u64 {
[2m      |             SecondLast = 0xffff_ffff_ffff_fffe;[0m
[2m      |             Last;[0m

	Failed to auto-increment, range exhausted.

        Solving [35;1mtype[0m [34;1mID[0m

-----

        enum ID: u64 {
            SecondLast = 0xffff_ffff_ffff_fffe;
            Last;

        };

        fn main() {
            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;
        }

-----
#include <cstdint>

enum s_ID: uint64_t;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: uint64_t
{
    s_ID_SecondLast = 0xfffffffffffffffeull,
    s_ID_Last = 18446744073709551615ull,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (uint64_t(s_ID_Last) == 0xffffffffffffffffull)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

-----
#include <fu/int.h>

enum s_ID: fu::u8;
enum s_IDOffset: fu::u8;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: fu::u8
{
    s_ID_A = 1u,
};
                                #endif

                                #ifndef DEF_s_IDOffset
                                #define DEF_s_IDOffset
enum s_IDOffset: fu::u8
{
    s_IDOffset_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int offset_DDWWiiLd(const s_ID a, const s_IDOffset b)
{
    return int(a) + int(b);
}

#endif

-----

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

        fn main() = _0::ID.A.offset(
            _0::IDOffset.B) - 11;

-----
#include <fu/int.h>

enum s_ID: fu::u8;
enum s_IDOffset: fu::u8;
int offset_DDWWiiLd(s_ID, s_IDOffset);

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: fu::u8
{
    s_ID_A = 1u,
};
                                #endif

                                #ifndef DEF_s_IDOffset
                                #define DEF_s_IDOffset
enum s_IDOffset: fu::u8
{
    s_IDOffset_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return offset_DDWWiiLd(s_ID_A, s_IDOffset_B) - 11;
}

#endif

int main() { return fu_MAIN(); }

-----

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

-----
#include <fu/int.h>

enum s_ID: fu::u8;
enum s_IDOffset: fu::u8;

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: fu::u8
{
    s_ID_A = 1u,
};
                                #endif

                                #ifndef DEF_s_IDOffset
                                #define DEF_s_IDOffset
enum s_IDOffset: fu::u8
{
    s_IDOffset_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int offset_DDWWiiLd(const s_ID a, const s_IDOffset b)
{
    return int(a) + int(b);
}

#endif

-----

        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;

        fn main() = _0::ID.A.offset(
            _0::B) - 11;

-----
#include <fu/int.h>

enum s_ID: fu::u8;
enum s_IDOffset: fu::u8;
int offset_DDWWiiLd(s_ID, s_IDOffset);

                                #ifndef DEF_s_ID
                                #define DEF_s_ID
enum s_ID: fu::u8
{
    s_ID_A = 1u,
};
                                #endif

                                #ifndef DEF_s_IDOffset
                                #define DEF_s_IDOffset
enum s_IDOffset: fu::u8
{
    s_IDOffset_B = 10u,
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return offset_DDWWiiLd(s_ID_A, s_IDOffset_B) - 11;
}

#endif

int main() { return fu_MAIN(); }

-----

        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     
            x == "b";       

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:15+2[0m:

[2m      |         fn isAorB(x: ABC)[0m
[2m      |             x == "A" ||     [0m
[2m    6 | [0m            x [31;1m==[0m "b";       
[2m      | [0m
[2m      |         fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;[0m

	Bad call to [34;1m==[0m with args (e8/11 copy, string copy resize AlwaysTrue): 

	[35;1mtemplate[0m [34;1m==[0m at [2m../../../../../[0mprelude[2m 540:10+2[0m:
[2m  540 | [0minfix fn [31;1m==[0m !T(a: T, b: T)

	    [35;1marg[0m [34;1mb[0m:
	    Incompatible types for [31;1mT[0m: e8/11 copy Typename <-> string copy resize Typename

        Solving [35;1mfn[0m [34;1misAorB[0m(e8/11) at [2m4:12+6[0m

-----

        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     
            x == "B";       

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;

-----
#include <fu/int.h>

enum s_ABC: fu::u8;

                                #ifndef DEF_s_ABC
                                #define DEF_s_ABC
enum s_ABC: fu::u8
{
    s_ABC_A = 1u,
    s_ABC_B = 2u,
    s_ABC_C = 3u,
};
                                #endif

#ifndef fu_NO_fdefs

static bool isAorB_ju68XN2S(const s_ABC x)
{
    return (x == s_ABC_A) || (x == s_ABC_B);
}

int fu_MAIN()
{
    if (isAorB_ju68XN2S(s_ABC_A) && isAorB_ju68XN2S(s_ABC_B) && !isAorB_ju68XN2S(s_ABC_C))
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        union union_ui {
            i: i32;
            u: u32;
        }

        fn main() {
            mut ui = union_ui(i: -1);
            return (ui.u - 0xffffffff).i32;
        }

-----
union s_union_ui;

                                #ifndef DEF_s_union_ui
                                #define DEF_s_union_ui
union s_union_ui
{
    int i;
    unsigned u;
    explicit operator bool() const noexcept
    {
        return false
            || i
            || u
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_union_ui ui = s_union_ui { -1 };
    return int((ui.u - 0xffffffffu));
}

#endif

int main() { return fu_MAIN(); }

-----

        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }


        nothrow 
        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 16:12+12[0m:

[2m      | [0m
[2m      |         nothrow [0m
[2m   16 | [0m        fn [31;1mdoesnt_catch[0m(mut z: i32) {
[2m      |             if (z & 2)          return does_throw(z);[0m
[2m      |             else                return does_catch(z);[0m

	[35;1mfn[0m [34;1mdoesnt_catch[0m is not nothrow, throws here:

            via [35;1mfn[0m [34;1mdoes_throw[0m at [2m17:50+1[0m:

[2m      |         nothrow [0m
[2m      |         fn doesnt_catch(mut z: i32) {[0m
[2m   17 | [0m            if (z & 2)          return does_throw[31;1m([0mz);
[2m      |             else                return does_catch(z);[0m
[2m      |         }[0m

            via [35;1m__native[0m [34;1m
<fu/never.h>
fu::fail[0m at [2m6:18+1[0m:

[2m      |             mut str = "";[0m
[2m      |             while (x--)         str ~= x;[0m
[2m    6 | [0m            throw[31;1m([0mstr);
[2m      |         }[0m
[2m      | [0m


-----

        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }


        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/decstr.h>
#include <fu/vec/concat.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_x7Ex3D_vuSW0Q9ulEj
                                #define DEF_x7Ex3D_vuSW0Q9ulEj
inline fu::str& x7Ex3D_vuSW0Q9u(fu::str& a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

static int does_throw_1WsbUdat(int x)
{
    if (x & 1)
        return x;
    else
    {
        /*MOV*/ fu::str str = ""_fu;
        while (x--)
            x7Ex3D_vuSW0Q9u(str, fu::i64dec(x));

        fu::fail(static_cast<fu::str&&>(str));
    };
}

static int does_catch_rQBG6KTt(const int y)
{

    try
    {
        return does_throw_1WsbUdat(y);
    }
    catch (const std::exception& o_0)
    {
        fu::str e = fu::to_str(o_0.what());

        return e.size();
    }
;
}

static int doesnt_catch_6vx4UGAT(const int z)
{
    if (z & 2)
        return does_throw_1WsbUdat(z);
    else
        return does_catch_rQBG6KTt(z);

}

int fu_MAIN()
{
    return doesnt_catch_6vx4UGAT(1) - 1;
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn has_fx() {
            mut res = 0;
            pragma output(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn not_dead_mutually_rec_a(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_b(x - 1);
                has_fx();
            }
        }

        fn not_dead_mutually_rec_b(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_a(x - 1);
                has_fx();
            }
        }

        fn main() {

            not_dead_mutually_rec_b(2); 
            return has_fx() - 2;
        }

-----
static void not_dead_mutually_rec_b_1WsbUdat(int);

#ifndef fu_NO_fdefs

static int has_fx_H9fhQUVP()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static void not_dead_mutually_rec_a_1WsbUdat(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_b_1WsbUdat((x - 1));
        has_fx_H9fhQUVP();
    };
}

static void not_dead_mutually_rec_b_1WsbUdat(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_a_1WsbUdat((x - 1));
        has_fx_H9fhQUVP();
    };
}

int fu_MAIN()
{
    not_dead_mutually_rec_b_1WsbUdat(2);
    return has_fx_H9fhQUVP() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn has_fx() {
            mut res = 0;
            pragma output(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn not_dead_mutually_rec_a(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_b(x - 1);
                has_fx();
            }
        }

        fn not_dead_mutually_rec_b(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_a(x - 1);
                has_fx();
            }
        }

        fn main() {

            not_dead_mutually_rec_a(2); 
            return has_fx() - 2;
        }

-----
static void not_dead_mutually_rec_a_1WsbUdat(int);

#ifndef fu_NO_fdefs

static int has_fx_H9fhQUVP()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static void not_dead_mutually_rec_b_1WsbUdat(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_a_1WsbUdat((x - 1));
        has_fx_H9fhQUVP();
    };
}

static void not_dead_mutually_rec_a_1WsbUdat(const int x)
{
    if (x > 0)
    {
        not_dead_mutually_rec_b_1WsbUdat((x - 1));
        has_fx_H9fhQUVP();
    };
}

int fu_MAIN()
{
    not_dead_mutually_rec_a_1WsbUdat(2);
    return has_fx_H9fhQUVP() - 2;
}

#endif

int main() { return fu_MAIN(); }

// N_FnRecursion, N_FnReopen, N_DeadCode

-----

        fn no_fx() {
            mut res = 0;
            pragma clock(`
                static int counter;
                `res`  = counter++;
            `);
            return res;
        }

        fn test(lax x: i32) {
            x & 1 && no_fx();
            x & 2 || no_fx();
            if (!no_fx) no_fx(); else no_fx();
            for (mut i = 1; i--> 0; no_fx()) no_fx();

            // the idea is that everything above should go,
            //  and just this one call to no_fx will remain.
            return no_fx();
        }

        fn main() = test(1);

-----

#ifndef fu_NO_fdefs

static int no_fx_H9fhQUVP()
{
    int res = 0;
    static int counter;
    res  = counter++;

    return res;
}

static int test_XzHONHMl()
{
    for (int i = 1; i-- > 0; );
    return no_fx_H9fhQUVP();
}

int fu_MAIN()
{
    return test_XzHONHMl();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedAndOr, N_UnusedIfElse

-----

        fn lex(src: string) {
            mut idx = 0;
            let end = src.len;
            while (idx < end) {
                let c = src[idx++]; // bug in discard(if) unused this var
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9') {
                    //
                }
                else {
                    idx--;
                    break;
                }
            }
            return idx;
        }

        fn main() = "hello!".lex - 5;

-----
#include <fu/str.h>
#include <fu/view.h>


#ifndef fu_NO_fdefs

static int lex_IbHLL4cS(fu::view<char> src)
{
    int idx = 0;
    const int end = src.size();
    while (idx < end)
    {
        const char /*src|static*/ c = src[idx++];
        if (!(((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')) || (c == '_') || ((c >= '0') && (c <= '9'))))
        {
            idx--;
            break;
        };
    };
    return idx;
}

int fu_MAIN()
{
    return lex_IbHLL4cS("hello!"_fu) - 5;
}

#endif

int main() { return fu_MAIN(); }

-----

        let se_global_false = false;

        fn main() {
            if (se_global_false) return THIS_DOESNT_EXIST();
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let se_global_false = false;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_se_global_false
                                #define DEF_se_global_false
inline constexpr bool se_global_false = false;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let se_global_false = false;
        pub import _0;
        fn main() {
            if (se_global_false) return THIS_DOESNT_EXIST();
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        let se_global_true = true;

        fn main() {
            if (!se_global_true) return THIS_DOESNT_EXIST();
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let se_global_true = true;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_se_global_true
                                #define DEF_se_global_true
inline constexpr bool se_global_true = true;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let se_global_true = true;
        pub import _0;
        fn main() {
            if (!se_global_true) return THIS_DOESNT_EXIST();
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

-----

        let se_global_let_from_closure = false;

        fn main() {
            fn test() {
                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

-----

#ifndef fu_NO_fdefs

static int test_y1jV3SX3()
{
    return 0;
}

int fu_MAIN()
{
    return test_y1jV3SX3();
}

#endif

int main() { return fu_MAIN(); }

// N_SD_HasStaticInit

-----

        let se_global_let_from_closure = false;

-----

#ifndef fu_NO_fdefs

                                #ifndef DEF_se_global_let_from_closure
                                #define DEF_se_global_let_from_closure
inline constexpr bool se_global_let_from_closure = false;
                                #endif

#endif

// N_SD_HasStaticInit

-----

        let se_global_let_from_closure = false;
        pub import _0;
        fn main() {
            fn test() {
                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

-----

#ifndef fu_NO_fdefs

static int test_077CGISJ()
{
    return 0;
}

int fu_MAIN()
{
    return test_077CGISJ();
}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {

            mut  se_local_let = false;
            if (se_local_let) return THIS_DOESNT_EXIST();
            return 0;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 5:55+1[0m:

[2m      | [0m
[2m      |             mut  se_local_let = false;[0m
[2m    5 | [0m            if (se_local_let) return THIS_DOESNT_EXIST[31;1m([0m);
[2m      |             return 0;[0m
[2m      |         }[0m

	Bad call to [34;1mTHIS_DOESNT_EXIST[0m: [34;1mTHIS_DOESNT_EXIST[0m is not defined here.

        Solving [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {

            let  se_local_let = false;
            if (se_local_let) return THIS_DOESNT_EXIST();
            return 0;
        }

-----

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    return 0;
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }
        fn main() = Hello(true).v ? 0 : 1;

-----
struct s_Hello;

                                #ifndef DEF_s_Hello
                                #define DEF_s_Hello
struct s_Hello
{
    bool v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    if (s_Hello { true }.v)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----

        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }

        fn main() {
            let yes = Hello(true);
            let no  = Hello(false);

            let expect_true = yes.v;
            let expect_false = no.v;

            if (!expect_true) return 20;
            if (expect_false) return 10;
            return 0;
        }

-----
struct s_Hello;

                                #ifndef DEF_s_Hello
                                #define DEF_s_Hello
struct s_Hello
{
    bool v;
    explicit operator bool() const noexcept
    {
        return false
            || v
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

int fu_MAIN()
{
    const s_Hello yes = s_Hello { true };
    const s_Hello no = s_Hello { false };
    const bool /*yes*/ expect_true = yes.v;
    const bool /*no*/ expect_false = no.v;
    if (!expect_true)
        return 20;
    else if (expect_false)
        return 10;
    else
        return 0;

}

#endif

int main() { return fu_MAIN(); }

-----

        fn main() {

            mut  se_closure_let = false;
            fn test() {
                if (se_closure_let) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 6:61+1[0m:

[2m      |             mut  se_closure_let = false;[0m
[2m      |             fn test() {[0m
[2m    6 | [0m                if (se_closure_let) return THIS_DOESNT_EXIST[31;1m([0m);
[2m      |                 return 0;[0m
[2m      |             }[0m

	Bad call to [34;1mTHIS_DOESNT_EXIST[0m: [34;1mTHIS_DOESNT_EXIST[0m is not defined here.

        Solving [35;1mfn[0m [34;1mtest[0m at [2m5:16+4[0m
                [35;1mfn[0m [34;1mmain[0m at [2m2:12+4[0m

-----

        fn main() {

            let  se_closure_let = false;
            fn test() {
                if (se_closure_let) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }

-----

#ifndef fu_NO_fdefs

static int test_EJhRWC6k()
{
    return 0;
}

int fu_MAIN()
{
    return test_EJhRWC6k();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedImplicit, N_UnusedLet

-----

        fn test(x: i32) {
            let val =                                       
                (x & 1 || { return 1 }) && { return 0 };    

            return UNREACHABLE(val);
        }

        fn main() test(1);

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

-----

        fn test(x: i32) {
            let val =                                       
                x & 1 && { return 0 } || { return 1 };      

            return UNREACHABLE(val);
        }

        fn main() test(1);

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

-----

        fn test(x: i32) {
            let val =                                       
                x & 1 ? { return 0 } : { return 1 };        

            return UNREACHABLE(val);
        }

        fn main() test(1);

-----

#ifndef fu_NO_fdefs

static int test_1WsbUdat(const int x)
{
    if (x & 1)
        return 0;
    else
        return 1;

}

int fu_MAIN()
{
    return test_1WsbUdat(1);
}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode, N_DeadLet

-----

        noinline fn alwaysFalse() false;
        fn main() alwaysFalse.i32;

-----

#ifndef fu_NO_fdefs

static bool alwaysFalse_H9fhQUVP()
{
    return false;
}

int fu_MAIN()
{
    return int(alwaysFalse_H9fhQUVP());
}

#endif

int main() { return fu_MAIN(); }

-----

        fn typeParamsMusntPickUpVFacts(x: i32) {
            let y = x || throw("x == 0"); // Now y is always true.
            if (y & 1) // & 1 is not always true though.
                return y * 10;
            else
                return y * 100;
        }

        fn main() typeParamsMusntPickUpVFacts(3)
                + typeParamsMusntPickUpVFacts(2) == 230 ? 0 : 1;

-----
#include <fu/str.h>
#include <fu/never.h>


#ifndef fu_NO_fdefs

static int typeParamsMusntPickUpVFacts_1WsbUdat(const int x)
{
    const int /*x*/ y = (x ? x : fu::fail("x == 0"_fu));
    if (y & 1)
        return y * 10;
    else
        return y * 100;

}

int fu_MAIN()
{
    if ((typeParamsMusntPickUpVFacts_1WsbUdat(3) + typeParamsMusntPickUpVFacts_1WsbUdat(2)) == 230)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_DeadCode

-----

        fn test() 
                : never 
                    = [];

        fn main() {
            mut x: i32 = test();
            return x;
        }

-----
[2m/Users/hdachev/fu/__tests__/[0m_0[2m.fu 4:23+2[0m:

[2m      |         fn test() [0m
[2m      |                 : never [0m
[2m    4 | [0m                    = [31;1m[][0m;
[2m      | [0m
[2m      |         fn main() {[0m

	Actual return type does not match annotation: never <- zeroes AlwaysFalse

        Solving [35;1mfn[0m [34;1mtest[0m at [2m2:12+4[0m

-----

        fn test() 
                    = [];

        fn main() {
            mut x: i32 = test();
            return x;
        }

-----

#ifndef fu_NO_fdefs

void fu_MAIN()
{
    return;
}

#endif

int main() { return fu_MAIN(), 0; }

// N_UnusedCall, N_UnusedLet

-----

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            return checkPalindrome(value, rev)
                && rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/view_swap.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_5Wk4dJRAXFe
                                #define DEF_reverse_5Wk4dJRAXFe
inline void reverse_5Wk4dJRA(fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool checkPalindrome_BqucEQkD(fu::view<char> host, fu::view<char> guest)
{
    return (host == guest) || fu::fail(":("_fu);
}

static fu::str palindrome_mfCqxBiW(const fu::str& value)
{
    /*MOV*/ fu::str rev { value };
    reverse_5Wk4dJRA(rev);
    checkPalindrome_BqucEQkD(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    fu::str n = "opera-arepo"_fu;
    return palindrome_mfCqxBiW(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();

            checkPalindrome(value, rev);
            return rev;

        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>
#include <fu/vec/view_swap.h>


#ifndef fu_NO_fdefs

                                #ifndef DEF_reverse_5Wk4dJRAXFe
                                #define DEF_reverse_5Wk4dJRAXFe
inline void reverse_5Wk4dJRA(fu::view_mut<char> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool checkPalindrome_BqucEQkD(fu::view<char> host, fu::view<char> guest)
{
    return (host == guest) || fu::fail(":("_fu);
}

static fu::str palindrome_mfCqxBiW(const fu::str& value)
{
    /*MOV*/ fu::str rev { value };
    reverse_5Wk4dJRA(rev);
    checkPalindrome_BqucEQkD(value, rev);
    return /*NRVO*/ rev;
}

int fu_MAIN()
{
    fu::str n = "opera-arepo"_fu;
    return palindrome_mfCqxBiW(n).size() - 11;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Node         { value: string };
        struct Target       { index: i32    };
        struct SolvedNode   { value: string };

        fn solve(n_root: Node)
        {
            fn solveNode(node: Node)
                return CallerNode(node.value);

            fn checkAssignable(host: string, guest: string)
                return host == guest || throw(":(");

            fn CallerNode(value: string) {

                return checkAssignable(value, n_root.value)
                    && SolvedNode(:value);

            }

            return solveNode(n_root);
        }

        fn main() {
            mut n = Node("hello!");
            return n.solve.value.len - 6;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Node;
struct s_SolvedNode;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool checkAssignable_xH9ywgbd(fu::view<char> host, fu::view<char> guest)
{
    return (host == guest) || fu::fail(":("_fu);
}

static s_SolvedNode CallerNode_AwT9aYLf(const fu::str& value, const s_Node& n_root)
{
    checkAssignable_xH9ywgbd(value, n_root.value);
    return s_SolvedNode { fu::str(value) };
}

static s_SolvedNode solveNode_1Z113oTh(const s_Node& node, const s_Node& n_root)
{
    return CallerNode_AwT9aYLf(node.value, n_root);
}

static s_SolvedNode solve_8vrkvUM5(const s_Node& n_root)
{
    return solveNode_1Z113oTh(n_root, n_root);
}

int fu_MAIN()
{
    s_Node n = s_Node { "hello!"_fu };
    return solve_8vrkvUM5(n).value.size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Node         { value: string };
        struct Target       { index: i32    };
        struct SolvedNode   { value: string };

        fn solve(n_root: Node)
        {
            fn solveNode(node: Node)
                return CallerNode(node.value);

            fn checkAssignable(host: string, guest: string)
                return host == guest || throw(":(");

            fn CallerNode(value: string) {

                checkAssignable(value, n_root.value);
                return SolvedNode(:value);

            }

            return solveNode(n_root);
        }

        fn main() {
            mut n = Node("hello!");
            return n.solve.value.len - 6;
        }

-----
#include <fu/str.h>
#include <fu/view.h>
#include <fu/never.h>

struct s_Node;
struct s_SolvedNode;

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || value
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_sOVQcK2JOH3
                                #define DEF_x3Cx3E_sOVQcK2JOH3
inline int x3Cx3E_sOVQcK2J(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_gCeFmDFw0L8
                                #define DEF_x3Cx3E_gCeFmDFw0L8
inline int x3Cx3E_gCeFmDFw(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_sOVQcK2J(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Dx3D_gCeFmDFw0L8
                                #define DEF_x3Dx3D_gCeFmDFw0L8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_gCeFmDFw(a, b);
}
                                #endif

static bool checkAssignable_xH9ywgbd(fu::view<char> host, fu::view<char> guest)
{
    return (host == guest) || fu::fail(":("_fu);
}

static s_SolvedNode CallerNode_AwT9aYLf(const fu::str& value, const s_Node& n_root)
{
    checkAssignable_xH9ywgbd(value, n_root.value);
    return s_SolvedNode { fu::str(value) };
}

static s_SolvedNode solveNode_1Z113oTh(const s_Node& node, const s_Node& n_root)
{
    return CallerNode_AwT9aYLf(node.value, n_root);
}

static s_SolvedNode solve_8vrkvUM5(const s_Node& n_root)
{
    return solveNode_1Z113oTh(n_root, n_root);
}

int fu_MAIN()
{
    s_Node n = s_Node { "hello!"_fu };
    return solve_8vrkvUM5(n).value.size() - 6;
}

#endif

int main() { return fu_MAIN(); }

// N_NonTrivAutoCopy

-----

        struct Postdom { a: i32; b?: i32[] };

        fn clear(ref p: Postdom)
            for (fieldname i: Postdom)
                if (typeof(p.i) -> i32[])
                    p.i.clear();

        fn main() {
            mut a = Postdom(a: 3);
            mut b = Postdom(a: 3, b: [ 1 ]);
            if (a == b) return 1;
            b.clear();
            return a == b ? 0 : 1;
        }

-----
#include <fu/vec.h>
#include <fu/view.h>

struct s_Postdom;

                                #ifndef DEF_s_Postdom
                                #define DEF_s_Postdom
struct s_Postdom
{
    int a;
    fu::vec<int> b;
    explicit operator bool() const noexcept
    {
        return false
            || a
            || b
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

                                #ifndef DEF_x3Cx3E_mJGU9byOmI4
                                #define DEF_x3Cx3E_mJGU9byOmI4
inline int x3Cx3E_mJGU9byO(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_fMp33mLs54j
                                #define DEF_x3Cx3E_fMp33mLs54j
inline int x3Cx3E_fMp33mLs(fu::view<int> a, fu::view<int> b)
{
    int cmp = x3Cx3E_mJGU9byO(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_mJGU9byO(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_YftrFGvzmNb
                                #define DEF_x3Cx3E_YftrFGvzmNb
inline int x3Cx3E_YftrFGvz(const s_Postdom& a, const s_Postdom& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_mJGU9byO(a.a, b.a)))
        return cmp;
    else if ((cmp = x3Cx3E_fMp33mLs(a.b, b.b)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_YftrFGvzmNb
                                #define DEF_x3Dx3D_YftrFGvzmNb
inline bool operator==(const s_Postdom& a, const s_Postdom& b)
{
    return !x3Cx3E_YftrFGvz(a, b);
}
                                #endif

static void clear_HzBpLyPu(s_Postdom& p)
{
    p.b.clear();
}

int fu_MAIN()
{
    s_Postdom a = s_Postdom { 3, fu::vec<int>{} };
    s_Postdom b = s_Postdom { 3, fu::vec<int> { fu::slate<1, int> { 1 } } };
    if (a == b)
        return 1;
    else
    {
        clear_HzBpLyPu(b);
        if (a == b)
            return 0;
        else
            return 1;

    };
}

#endif

int main() { return fu_MAIN(); }

// N_RelaxRespec

-----

        novec fn build(ref a: string, b: string) {
            let cmake       = false;

            let OPAQUE      = a.len + b.len;
            let CMakeLists  = cmake && OPAQUE && (a ~= b);

            if (CMakeLists) DOESNT_EXIST();
            return CMakeLists;
        }

        fn main() {
            mut a = "hello, ";
            let b = "world!";
            return build(a, b).len;
        }

-----
#include <fu/str.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static const fu::str& build_xagds2ks()
{
    const fu::str& /*static*/ CMakeLists = (*(const fu::str*)fu::NIL);
    return CMakeLists;
}

int fu_MAIN()
{
    return build_xagds2ks().size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall, N_UnusedLet

-----

        novec fn build(ref a: string, b: string) {
            let cmake       = false;

            let CMakeLists  = cmake && (a ~= b);

            if (CMakeLists) DOESNT_EXIST();
            return CMakeLists;
        }

        fn main() {
            mut a = "hello, ";
            let b = "world!";
            return build(a, b).len;
        }

-----
#include <fu/str.h>
#include <fu/default.h>


#ifndef fu_NO_fdefs

static const fu::str& build_xagds2ks()
{
    const fu::str& /*static*/ CMakeLists = (*(const fu::str*)fu::NIL);
    return CMakeLists;
}

int fu_MAIN()
{
    return build_xagds2ks().size();
}

#endif

int main() { return fu_MAIN(); }

// N_UnusedLet

-----

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn validate_looks_pure() {
            pretend_pure(1);
            return pretend_pure(2);
        }

        fn main() validate_looks_pure() == 102 ? 0 : 1;

-----

#ifndef fu_NO_fdefs

static int pretend_pure_U8dxWspX(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int validate_looks_pure_H9fhQUVP()
{
    return pretend_pure_U8dxWspX(2);
}

int fu_MAIN()
{
    if (validate_looks_pure_H9fhQUVP() == 102)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

// N_UnusedCall

-----

        fn pretend_pure(mut res = 0) {
            pragma emit(`
                static int counter = 100;
                `res` += counter++;
            `);
            return res;
        }

        fn licm_loop_preheader(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++)
            on enter {
                let must_hoist = pretend_pure(n);
            }
            then {
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_loop_preheader(2) == 204 ? 0 : 1;

-----

#ifndef fu_NO_fdefs

static int pretend_pure_U8dxWspX(int res)
{
    static int counter = 100;
    res += counter++;

    return res;
}

static int licm_loop_preheader_72skkfd5(const int n)
{
    int res = 0;

    {
        int i = 0;
        if (i < n)
        {
            const int must_hoist = pretend_pure_U8dxWspX(n);
            do
                res += must_hoist;
            while (i++, (i < n));
        };
    };
    return res;
}

int fu_MAIN()
{
    if (licm_loop_preheader_72skkfd5(2) == 204)
        return 0;
    else
        return 1;

}

#endif

int main() { return fu_MAIN(); }

-----
