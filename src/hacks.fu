import module;

struct ClosureID {
    target: Target;
    revision: i32;
};

fn serialize(using _: ClosureID)
    target.modid < 0
        ? "`" ~ target.index ~ "-" ~ -target.modid ~ "-" ~ revision
        : throw("Not a local.");

fn tryParseClosureID(id!: string): ClosureID
{
    if (id.len > 5 /* "`0-0-0".len == 6 */ && id[0] == '`')
    {
        mut   offset = 1;
        defer offset == id.len || throw("Bad ClosureID: trailing stuff.");
        let index = helpers::parse10u32(offset, id).i32;

        id[offset++] == '-' || throw("Bad ClosureID: no modid-dash.");
        let modid = -helpers::parse10u32(offset, id).i32;

        id[offset++] == '-' || throw("Bad ClosureID: no rev-dash.");
        let revision = helpers::parse10u32(offset, id).i32;

        return ClosureID(Target(:modid, :index), :revision);
    }

    return [];
}


//

struct NativeOpts
{
    name_start_idx:     i32;

    // Opts.
    no_AAR:             bool;
};

fn NativeOpts(name: string)
{
    if (name.starts(with: "\nno_AAR"))
    {
        return NativeOpts(
            name_start_idx: 7,
            no_AAR: true);
    }

    return [];
}
