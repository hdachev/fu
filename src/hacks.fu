import fail;
import module;
import helpers;

struct ClosureID
{
    target: Target;
    revision: u32;
};

fn serialize(using _: ClosureID)
{
    mut result = "`";

    let globid = target.globid;
    let locid = target.locid;
    if (globid <= 0 || locid <= 0)
        BUG("ClosureID: bad globid/locid");

    result.append09AV(locid.u32);
    result.append_ap(revision);
    result.append09AV(globid.u32);

    return result;
}

fn tryParseClosureID(id!: string): ClosureID
{
    if (id.len > 3 /* "`0a0".len == 6 */ && id[0] == '`')
    {
        mut   offset = 1;
        defer offset == id.len || BUG(
            "Bad ClosureID: trailing stuff.");

        let locid    = parse09AV(offset, id).i32;
        let revision =  parse_ap(offset, id);
        let globid   = parse09AV(offset, id).i32;

        return ClosureID(Target(modid: 0, :globid, :locid), :revision);
    }

    return [];
}


//

struct NativeHacks
{
    name_start_idx:     i32;

    // Opts.
    soft_risk:          bool;
};

fn NativeHacks(name: string)
{
    if (name.starts(with: "\nhacks/soft_risk"))
    {
        return NativeHacks(
            name_start_idx:     16,
            soft_risk:          true);
    }

    return [];
}
