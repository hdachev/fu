import helpers;
import types;

pub let EK_Read         = 1; // `read(a)`                       -> Read `a`.
pub let EK_ReadWrite    = 2; // `a0 = woot`                     ->
pub let EK_Invalidate   = 3; // `a0; a1 = a0.smth; a0 = woot    -> ReadWrite `a0`, Invalidate `a1`.

pub let EK_Def          = 4; // `a1 = a0.smth`                  -> Read `a0`, Ref `a1, a0`. Do we need the use?
pub let EK_LoopStart    = 5; // We're in a loop! Removed on loop exit.
pub let EK_LoopEnd      = 6;

pub let EK_JumpStart    = 7; // A block that returns never, when advancing from the back will be skipped over.
pub let EK_JumpEnd      = 8; //

pub let EK_Noop         = 9; // e.g. Skip over this entry.

pub struct Effect
{
    kind:       i32;        // what
    target:     i32;        // who

    ////////////////////////////////////
    // TODO ERRORINFO //////////////////
    ////////////////////////////////////
};

pub fn EK_isUse(effect: Effect)
    effect.kind == EK_Read ||
    effect.kind == EK_ReadWrite;

pub struct Flow
{
    usage:          Effect[];
    invalidates:    i32[][];
};

/*

pub fn try_ReadWrite(using ref flow: Flow, block!: i32, target!: i32, mut write!?: bool)
{
    mut loop_ignore = 0;
    mut last_loop_start = usage.len;

    // A write invalidates reads that follow, so:
    //
    //  1. For every read or write, scan back for an invalidate entry.
    //  2. For every invalidate IN A LOOP, scan forward for any uses that follow.
    //
    for (mut i0 = usage.len; i0 --> 0; )
    {
        let u = usage[i0];

        ////////////////////////////////

        if (u.kind == EK_JumpEnd && u.target < block) // Notice here we only ignore if we jump to a higher place.
        {
            // We've reached the "closing bracket" of a noreturn block,
            //  we want to skip over everything it has to say here.
            //
            mut depth = 0;

            for (mut i1 = i0; i1 --> 0; )
            {
                shadow let u = usage[i1];

                if (u.kind == EK_JumpEnd)
                {
                    depth++;
                }
                else if (u.kind == EK_JumpStart)
                {
                    depth--;
                    if (!depth)
                    {
                        i0 = i1;
                        break;
                    }
                }
            }
        }

        ////////////////////////////////

        else if (u.kind == EK_LoopEnd)
        {
            loop_ignore++;
        }
        else if (u.kind == EK_LoopStart)
        {
            if (loop_ignore)
            {
                loop_ignore--;
            }
            else if (write)
            {
                // Scan back ... forward towards the last known cursor,
                //  we cannot allow any reads that'd be invalidated by this.
                //
                for (mut i1 = i0; i1 < last_loop_start; i1++)
                {
                    shadow let u = usage[i1];

                    if (u.EK_isUse && invalidated.has(u.target))
                        fail("Write to " ~ target ~ " might invalidate preceding reads of "
                                         ~ u.target ~ " on next loop iteration.");
                }

                last_loop_start = i0;
            }
        }

        ////////////////////////////////

        else if (u.kind == EK_Def)
        {
            // We're done when we reach the definition -
            //  this cancels looping and such, if we're defined within the loop we don't care.
            if (u.target == target)
                break;
        }

        ////////////////////////////////

        else if (u.kind == EK_Invalidate)
        {
            if (u.target == target)
                fail("Cannot use " ~ target ~ " already invalidated here " ~ u.nodeidx);
        }
    }
}

*/

pub fn Reference_track(ref flow: Flow, left: i32, right: Lifetime)
{
    flow.invalidates.len <= left || assert();

    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if !(right)
            continue;

        // For each lifetime on the right of the assignment,
        //  the invals are the stuff it kills on write.
        mut invals = flow.invalidates.unless_oob(right);

        // LEFT can show up in the inval lists
        //  after we process the first lifetime.
        !invals.set::rem(left) || i > 0 || assert();

        // So, if:
        //  LEFT = &RIGHT;
        if (invals)
        {
            // Grand parents and siblings:
            //  LEFT invalidates everything RIGHT invalidates.
            flow.invalidates.grow_if_oob(left) = invals;

            // Same thing backward:
            //  Everything that RIGHT invalidates potentially invalidates LEFT.
            for (shadow mut i = 0; i < invals.len; i++)
                flow.invalidates[invals[i]].set::add(left);
        }

        // Parent rule, one-sided:
        //  Finally, RIGHT invalidates LEFT.
        flow.invalidates.grow_if_oob(right).set::add(left);
    }
}

pub fn Reference_untrack(ref flow: Flow, left: i32, right: Lifetime)
{
    // Unlist parents.
    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if (!right)
            continue;

        flow.invalidates[right].set::rem(left) || assert();
    }

    let invals = flow.invalidates.unless_oob(left);

    // Unlist any surviving backrefs.
    for (mut i = 0; i < invals.len; i++)
    {
        let idx = flow.invalidates.unless_oob(invals[i]).find(left);
        if (idx >= 0)
            flow.invalidates[invals[i]].splice(idx, 1);
    }

    // And this should be all.
    if (invals)
        flow.invalidates[left] = [];
}
