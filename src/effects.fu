import helpers;
import types;

pub let EK_Read         = 1;
pub let EK_ReadWrite    = 2;

pub let EK_Def          = 3;
pub let EK_LoopStart    = 4;
pub let EK_LoopEnd      = 5;

pub let EK_JumpStart    = 6;
pub let EK_JumpEnd      = 7;

pub struct Effect
{
    kind:       i32;                // what
    target:     i32;                // who
    token:      parser::TokenIdx;   // where
};

pub fn EK_isUse(effect: Effect)
    effect.kind == EK_Read ||
    effect.kind == EK_ReadWrite;

pub struct Flow
{
    usage:          Effect[];
    invalidates:    i32[][];
};

pub fn Reference_track(ref flow: Flow, left: i32, right: Lifetime)
{
    flow.invalidates.len <= left || assert();

    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if !(right)
            continue;

        // For each lifetime on the right of the assignment,
        //  the invals are the stuff it kills on write.
        mut invals = flow.invalidates.unless_oob(right);

        // LEFT can show up in the inval lists
        //  after we process the first lifetime.
        !invals.set::rem(left) || i > 0 || assert();

        // So, if:
        //  LEFT = &RIGHT;
        if (invals)
        {
            // Grand parents and siblings:
            //  LEFT invalidates everything RIGHT invalidates.
            flow.invalidates.grow_if_oob(left) = invals;

            // Same thing backward:
            //  Everything that RIGHT invalidates potentially invalidates LEFT.
            for (shadow mut i = 0; i < invals.len; i++)
                flow.invalidates[invals[i]].set::add(left);
        }

        // Parent rule, one-sided:
        //  Finally, RIGHT invalidates LEFT.
        flow.invalidates.grow_if_oob(right).set::add(left);
    }
}

pub fn Reference_untrack(ref flow: Flow, left: i32, right: Lifetime)
{
    // Unlist parents.
    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if (!right)
            continue;

        flow.invalidates[right].set::rem(left) || assert();
    }

    let invals = flow.invalidates.unless_oob(left);

    // Unlist any surviving backrefs.
    for (mut i = 0; i < invals.len; i++)
    {
        let idx = flow.invalidates.unless_oob(invals[i]).find(left);
        if (idx >= 0)
            flow.invalidates[invals[i]].splice(idx, 1);
    }

    // And this should be all.
    if (invals)
        flow.invalidates[left] = [];
}
