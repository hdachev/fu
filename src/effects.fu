import helpers;
import module;
import types;

pub struct Flow
{
    invalidates:    i32[][];

    // Arguments at risk analysis.
    is_arg:         bitset::BitSet; // acceleration structure.
    arg_targets:    i32[];          // argument targets at each position.
    arg_positions:  i32[];          // arguments (position + 1) at each target.

    arg_aliases:    i32[][];        // is_arg targets each target refers to.
    args_at_risk:   i32[][];        // ARG USES at risk from previous ARG WRITES.
};

pub fn Reference_trackArgument(ref flow: Flow, target: i32, position: i32)
{
    // Argument position -> target,
    //  this is only needed for collecting the outcomes at the end.
    flow.arg_targets.len <= position || assert();
    flow.arg_targets.grow(position + 1);
    flow.arg_targets[position] = target;

    flow.arg_positions.len <= target || assert();
    flow.arg_positions.grow(target + 1);
    flow.arg_positions[target] = position + 1;

    // Speed up memberships checks.
    flow.is_arg.add(target);
}

pub fn Reference_trackLocalRef(ref flow: Flow, left: i32, right: Lifetime)
{
    flow.invalidates.len <= left || assert();

    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if !(right)
            continue;

        // For each lifetime on the right of the assignment,
        //  the invals are the stuff it kills on write.
        mut invals = flow.invalidates.unless_oob(right);

        // LEFT can show up in the inval lists
        //  after we process the first lifetime.
        !invals.set::rem(left) || i > 0 || assert();

        // So, if:
        //  LEFT = &RIGHT;
        if (invals)
        {
            // Grand parents and siblings:
            //  LEFT invalidates everything RIGHT invalidates.
            flow.invalidates.grow_if_oob(left) = invals;

            // Same thing backward:
            //  Everything that RIGHT invalidates potentially invalidates LEFT.
            for (shadow mut i = 0; i < invals.len; i++)
                flow.invalidates[invals[i]].set::add(left);
        }

        // Parent rule, one-sided:
        //  Finally, RIGHT invalidates LEFT.
        flow.invalidates.grow_if_oob(right).set::add(left);

        // Propagate alised arguments.
        if (flow.is_arg.has(right))
        {
            flow.is_arg.add(left);
            flow.arg_aliases.grow_if_oob(left).set::add(right);
        }
    }
}

pub fn Reference_untrackLocalRef(ref flow: Flow, left: i32, right: Lifetime)
{
    // Unlist parents.
    for (mut i = 0; i < right.uni0n.len; i++)
    {
        shadow let right = Region_asIndex(right.uni0n[i]);
        if (!right)
            continue;

        flow.invalidates[right].set::rem(left) || assert();
    }

    let invals = flow.invalidates.try_steal(left);

    // Unlist any surviving backrefs.
    for (mut i = 0; i < invals.len; i++)
    {
        let idx = flow.invalidates.unless_oob(invals[i]).find(left);
        if (idx >= 0)
            flow.invalidates[invals[i]].splice(idx, 1);
    }
}


//

pub fn ArgsAtRisk_shake(ref flow: Flow)
{
    // For each ARG USE AT RISK from a previous ARG WRITE ...
    for (mut i = 0; i < flow.args_at_risk.len; i++)
    {
        let use             = i;
        fn at_risk_from()   = flow.args_at_risk[use];

        for (shadow mut i = at_risk_from.len; i --> 0; )
        {
            mut write = at_risk_from[i]; /*bck fix*/

            // DEDUPE BELOW /////////////
            at_risk_from.splice(i, 1); //
            /////////////////////////////

            ArgsAtRisk_shake(:flow, use, write);
        }
    }
}

fn ArgsAtRisk_shake(ref flow: Flow, mut high: i32, mut low: i32)
{
    for (;;)
    {
        // Write to AB does not invalidate a read from AB.
        if (high == low)
            return;

        // Normalize the ascent.
        //  We want to climb greater-first,
        //   so that if we have read(ABC = AB || C) after write(AB),
        //    C becomes at risk with A and B,
        //     but A & B are fine together.
        //
        if (high < low)
            SWAP(high, low);

        // One edge - prefer storing index of lower in higher bitmask -
        //  extra mileage for small bitmask optimizatons.

        // DEDUPE ////////////////////////////////////////////////
        // TODO this will be way faster as a bitmask. ////////////
        flow.args_at_risk.grow_if_oob(high).set::add(low); //
        { ////////////////////////////////////////////////////////
            {
                mut highs = flow.arg_aliases.unless_oob(high); /*bck fix*/
                if (highs)
                {
                    let last = highs.len - 1;
                    for (mut i = 0; i < last; i++)
                        ArgsAtRisk_shake(:flow, high: highs[i], :low);

                    // Repeat here.
                    high = highs[last];
                    continue;
                }
            }

            {
                mut lows = flow.arg_aliases.unless_oob(low); /*bck fix*/
                if (lows)
                {
                    let last = lows.len - 1;
                    for (mut i = 0; i < last; i++)
                        ArgsAtRisk_shake(:flow, :high, low: lows[i]);

                    // Repeat here.
                    low = lows[last];
                    continue;
                }
            }
        }

        break;
    }
}

pub fn ArgsAtRisk_listRiskFree(flow: Flow, position: i32)
{
    mut risk_free: bitset::BitSet;

    if (position)
    {
        // Each bitset as small as possible -
        //  lesser args listed in greater args bitsets -
        //   so even if we have 200 args, most of the bitsets will be smallvecs.
        risk_free.add_range(0, position);

        let target          = flow.arg_targets.unless_oob(position);
        let at_risk_from    = flow.args_at_risk.unless_oob(target);

        for (mut i = 0; i < at_risk_from.len; i++)
        {
            let other           = at_risk_from[i];
            if (other > target)
                break;

            let other_position  = flow.arg_positions.unless_oob(other) - 1;
            if (other_position >= 0)
                risk_free.rem(other_position);
        }
    }

    return risk_free;
}


//

pub fn ArgsWritten_shake(flow: Flow, ref args: [$T])
{
    for (mut i = min(args.len, flow.arg_aliases.len); i --> 0; )
    {
        let x = args[i];
        if (x)
        {
            let aliases = flow.arg_aliases[i];
            for (shadow mut i = 0; i < aliases.len; i++)
            {
                ref y = args[aliases[i]];
                if (!y)
                    y = x;
            }
        }
    }
}
