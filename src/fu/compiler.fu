// expect_lambda



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Lexer.

let OPTOKENS = '{}[]()!?~@#$%^&*/-+<=>,.;:|';

let OPERATORS =
[
    '+', '++', '-', '--',
    '*', '**', '/', '%',
    '<', '<<', '<<<', '>', '>>', '>>>',
    '===', '==', '!=', '!==', '<=', '>=', '=>', '->', '<=>',
    '!', '!!', '?', '??',
    '.', '..', '...', ':', '::', ',', ';',
    '&', '&&', '|', '||', '^', '~',
    '{', '}', '[', ']', '(', ')', '[]',
    '=',
    '+=', '-=', '*=', '**=', '/=', '%=',
    '&=', '|=', '^=',
    '&&=', '||=',
    '@', '#', '$'
];

struct Token
{
    kind:   string;
    value:  string;
    fname:  string;

    idx0:   i32;
    idx1:   i32;
    line:   i32;
    col:    i32;
};

struct LexErr
{
    reason: string;
    kind:   string;
    value:  string;
    fname:  string;

    idx0:   i32;
    idx1:   i32;
    line:   i32;
    col:    i32;
};

struct LexResult
{
    fname:  string;
    errors: LexErr[];
    tokens: Token[];
};

fn lex(src: &string, fname: &string): LexResult
{
    let end     = src.len;
    mut line    = 1;
    mut lidx    = -1;
    mut idx     = 0;

    mut errors: LexErr[];
    mut tokens: Token[];

    fn token(kind: &string, value: &string, idx0: i32, idx1: i32)
    {
        let col = idx0 - lidx;

        tokens.push(
            Token(  :kind, :value, :idx0, :idx1,
                    :fname, :line, :col ));
    }

    fn err_str(kind: &string, idx0: i32, reason: &string)
    {
        // exit to nearest whitespace
        while (idx < end && src[idx] > ' ')
            idx++;

        let col = idx0 - lidx;
        let value = src.slice(idx0, idx);

        errors.push(
            LexErr( :reason, :kind, :value, :idx0, idx,
                    :fname, :line, :col ));
    }

    fn err(kind: &string, idx0: i32, reason: i32)
    {
        err_str(kind, idx0, src[reason]);
    }

    fn checkNum(kind: &string, src: string): string
    {
        ////////////
        //  TODO  //
        ////////////

        if (src) {} // unused

        return kind;
    }

    fn unescapeStr(src: &string, idx0: i32, idx1: i32): string
    {
        mut out = '';

        mut n = idx1 - 1;
        for (mut i = idx0 + 1; i < n; i++)
        {
            let c = src[i];
            if (c == '\\')
            {
                let c1 = src[++i];

                if      (c1 == 'n') out += '\n';
                else if (c1 == 'r') out += '\r';
                else if (c1 == 't') out += '\t';
                else if (c1 == 'v') out += '\v';
                else                out += c1;
            }
            else
            {
                out += c;
            }
        }

        return out;
    }

    while (idx < end)
    {
        let idx0 = idx;
        let c = src[idx++];

        // whitespace
        if (c <= ' ')
        {
            if (c == '\n')
            {
                line++;
                lidx = idx - 1;
            }
        }

        // identifiers & keywords
        else if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_')
        {
            while (idx < end)
            {
                let c = src[idx++];
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9')
                {
                    //
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let idx1 = idx;

            token(
                'id', src.slice(idx0, idx1),
                idx0, idx1);
        }

        // numeric literals
        else if (c >= '0' && c <= '9')
        {
            mut hex = false;
            mut dot = false;
            mut exp = false;

            if (c == '0' && idx < end && src[idx] == 'x')
            {
                hex = true;
                idx++;
            }

            while (idx < end)
            {
                let c = src[idx++];

                if (c >= '0' && c <= '9')
                {
                    //
                }
                else if (c == '.')
                {
                    if (hex || dot || exp)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }

                    dot = true;
                }
                else if ((c == 'e' || c == 'E') && !hex)
                {
                    if (hex || exp)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }

                    if (idx < end && (src[idx] == '-' || src[idx] == '+'))
                        idx++;

                    exp = true;
                }
                else if (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F')
                {
                    if (!hex)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let trail = src[idx - 1];
            if (trail < '0' || trail > '9')
            {
                err('num', idx0, idx - 1);
            }
            else
            {
                let idx1 = idx;
                let str = src.slice(idx0, idx1);

                token(
                    checkNum(dot || exp ? 'num' : 'int', str), str,
                    idx0, idx1);
            }
        }

        // string literals
        else if (c == '\'' || c == '"' || c == '`')
        {
            mut esc = false;
            mut ok  = false;

            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == c)
                {
                    ok = true;
                    break;
                }
                else if (c1 == '\\')
                {
                    esc = true;
                    idx++;
                }
                else if (c == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
            }

            if (!ok)
            {
                err_str('str', idx0, 'Unterminated string literal.');
            }
            else
            {
                let idx1 = idx;
                let str  = esc  ? unescapeStr(src, idx0, idx1)
                                : src.slice(idx0 + 1, idx1 - 1);

                token(
                    'str', str,
                    idx0, idx1);
            }
        }

        // comments
        else if (c == '/' && idx < end && src[idx] == '/')
        {
            idx++;
            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == '\n')
                {
                    line++;
                    lidx = idx - 1;
                    break;
                }
            }
        }

        // multiline comments
        else if (c == '/' && idx < end && src[idx] == '*')
        {
            idx++;
            while (idx < end)
            {
                let c = src[idx++];
                if (c == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
                else if (c == '*' && idx < end && src[idx] == '/')
                {
                    idx++;
                    break;
                }
            }
        }

        // operators
        else if (OPTOKENS.has(c))
        {
            while (idx < end)
            {
                let c = src[idx++];
                if (!OPTOKENS.has(c))
                {
                    idx--;
                    break;
                }
            }

            // split off adjacent operators
            {
                mut begin   = idx0;
                mut end     = idx;
                while (begin < end)
                {
                    let candidate = src.slice(begin, end);
                    let ok = OPERATORS.has(candidate);
                    if (end > begin + 1 && !ok)
                    {
                        end--;
                        continue;
                    }

                    if (!ok)
                    {
                        err('op', begin, end);
                    }
                    else
                    {
                        token(
                            'op', candidate,
                            begin, end);
                    }

                    begin = end;
                    end = idx;
                }
            }
        }

        // dunno
        else
        {
            err('?', idx0, idx0);
        }
    }

    // end of file token
    line++;
    lidx = idx + 0;

    token(
        'eof', 'eof',
        idx, idx);

    // err, data
    return LexResult( :fname, :errors, :tokens );
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Parser.

pub struct Node
{
    kind:       string;
    flags:      i32;
    value:      string;
    items:      Node[];
    token:      Token;
};


// Calltypes, probably an enum is better for the 4 kinds,
//  can't be mixed and matched.

pub let F_METHOD       = 1 << 0;
pub let F_INFIX        = 1 << 1;
pub let F_PREFIX       = 1 << 2;
pub let F_POSTFIX      = 1 << 3;
pub let F_ACCESS       = 1 << 4;
pub let F_ID           = 1 << 5;
pub let F_INDEX        = 1 << 6;

pub let F_LOCAL        = 1 << 8;
pub let F_ARG          = 1 << 9;
pub let F_FIELD        = 1 << 10;

pub let F_MUT          = 1 << 16;
pub let F_IMPLICIT     = 1 << 17;
pub let F_USING        = 1 << 18;

pub let F_UNTYPED_ARGS = 1 << 23;
pub let F_NAMED_ARGS   = 1 << 24;
pub let F_FULLY_TYPED  = 1 << 25;
pub let F_CLOSURE      = 1 << 26;
pub let F_HAS_CLOSURE  = 1 << 27;
pub let F_PATTERN      = 1 << 28;
pub let F_TEMPLATE     = 1 << 29;
pub let F_DESTRUCTOR   = 1 << 30;
pub let F_ELISION      = 1 << 31;


// Operator precedence table.

let P_RESET           = 1000;
let P_PREFIX_UNARY    = 3   ;

let PREFIX:  string[] = [ '++', '+', '--', '-', '!', '!!', '~', '?', '*', '&', '&mut' ];
let POSTFIX: string[] = [ '++', '--', '[]' ];

struct BINOP {
    PRECEDENCE:     Map(string, i32);
    RIGHT_TO_LEFT:  Map(i32,   bool);
};

fn setupOperators()
{
    mut out: BINOP;

    mut precedence  = P_PREFIX_UNARY;
    mut rightToLeft = false;

    fn binop(ops: string[])
    {
        precedence++;
        out.RIGHT_TO_LEFT[precedence] = rightToLeft;

        for (mut i = 0; i < ops.len; i++)
            out.PRECEDENCE[ops[i]] = precedence;
    }

    binop([ 'as', 'is' ]);

    rightToLeft = true;
    binop([ '**' ]);

    rightToLeft = false;
    binop([ '*', '/', '%' ]);
    binop([ '+', '-' ]);
    binop([ '<<', '>>' ]);
    binop([ '&' ]); // Notice this is not js/c precedence, it's just never usefu]l.
    binop([ '^' ]); // We're doing the rust thing her]e.
    binop([ '|' ]);
    binop([ '<', '<=', '>', '>=' ]);
    binop([ '==', '!=', '<=>' ]);
    binop([ '->' ]);
    binop([ '&&' ]);
    binop([ '||' ]);

    rightToLeft = true;
    binop([ '?' ]);
    binop([ '=', '+=', '-=', '**=', '*=', '/=', '%=', '<<=', '>>=', '&=', '^=', '|=', '||=', '&&=' ]);

    rightToLeft = false;
    binop([ ',' ]);

    //
    return out;
}

let BINOP     = setupOperators();
let P_COMMA   = BINOP.PRECEDENCE[','] || assert();


// Commons.

pub let LET_TYPE       = 0;
pub let LET_INIT       = 1;

pub let FN_RET_BACK    = -2;
pub let FN_BODY_BACK   = -1;
pub let FN_ARGS_BACK   = FN_RET_BACK;

pub let LOOP_INIT      = 0;
pub let LOOP_COND      = 1;
pub let LOOP_POST      = 2;
pub let LOOP_BODY      = 3;
pub let LOOP_POST_COND = 4;


//

pub fn parse(_fname: string, _tokens: Token[])
{
    mut _idx        = 0;
    mut _loc: Token = _tokens[0];
    mut _col0       = 0;
    mut _precedence = P_RESET;
    mut _fnDepth    = 0;
    mut _numDollars = 0;
    mut _numReturns = 0;
    mut _implicits  = 0;
    mut _structName = '';


    //

    fn fail(mut reason: string = '')
    {
        let here = _tokens[_idx];

        if (!reason)
            reason = 'Unexpected `' + here.value + '`.';

        let l0 = _loc.line;
        let c0 = _loc.col;

        let l1 = here.line;
        let c1 = here.col;

        let addr = l1 == l0
            ? '@' + l1 + ':' + c1
            : '@' + l0 + ':' + c0 + '..' + l1 + ':' + c1;

        return throw(_fname + ' ' + addr + ':\n\t' + reason);
    }

    fn fail_Lint(reason: string)
    {
        // TODO allow opt out
        return fail('Lint: ' + reason);
    }

    fn make(
        kind:  string,
        items: Node[] = [],
        flags: i32    =  0,
        value: string = '')
    {
        return Node(
            :kind, :flags, :value, :items,
                token: _loc || throw('no loc'));
    };

    fn miss() Node();


    //

    fn consume(kind: string, value: string = ''): Token
    {
        let token = _tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return fail('Expected `' + (value || kind) + '`, got `' + token.value + '`.');
    }

    fn tryConsume(kind: string, value: string = ''): Token
    {
        let token = _tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return Token();
    }


    //

    fn parseRoot(): Node
    {
        _loc = _tokens[_idx];

        // Imports only ok on top of files.
        // for (;;) {
        //     if (!peek('id', 'import'))
        //         break;

        //     loc = ctx.idx
        //     consume()
        //     items += parseImport()
        // }

        mut out = make('root',
            parseBlockLike('eof', 'eof'));

        if (_implicits)
            out.flags |= F_IMPLICIT;

        return out;
    }


    //

    fn parseBlock(): Node
    {
        return createBlock(
            parseBlockLike('op', '}'));
    }

    fn createBlock(items: &Node[]): Node
    {
        return make('block', items);
    }


    //

    fn parseStructDecl(): Node
    {
        let name = tryConsume('id');
        let id = name && name.value || fail('Anon structs.');

        ////////////////////////////////
        let structName0 = _structName;
        _structName = id;

        consume('op', '{');
        let items = parseBlockLike(
            'op', '}', 'struct');

        _structName = structName0;
        //////////////////////////

        return make(
            'struct', items, 0,
                name ? name.value : '');
    }

    fn parseStructItem(): Node
    {
        //////////////////////////////
        let token = _tokens[_idx++];

        if (token.kind == 'op' || token.kind == 'id')
            if (token.value == 'fn')
                return parseStructMethod();

        _idx--;
        //////////////////////////////

        mut member = parseLet();
        member.flags |= F_FIELD;

        consume('op', ';');
        return member;
    }

    fn parseStructMethod(): Node
    {
        mut fnNode = parseFnDecl();

        // `this` arg annotation -
        //  -----------------------------------
        //  Now what the fuck is happening here -
        //      how do we deal with const/mut here?
        //  --------------------------------------------------------
        //  We dont want cpp-style double definitions for everything,
        //      so how do we go about this?

        let typeAnnot =
            createPrefix('&',
                createRead(_structName || fail()));

        fnNode.items.unshift(
            createLet('this', F_USING, typeAnnot, miss));

        fnNode.flags |= F_METHOD;
        return fnNode;
    }


    //

    fn parseBlockLike(
        endKind: string, endVal: string,
        mode: string = ''): Node[]
    {
        mut line0 = _tokens[_idx].line;
        mut col00 = _col0;

        mut items: Node[] = [];
        while (true)
        {
            let token = _tokens[_idx];
            if (token.kind == endKind && token.value == endVal)
            {
                // Done.
                _col0 = col00;
                _idx++;

                // Style-check, makes for more helpful errors.
                let line1 = token.line;
                let col1  = token.col;

                line1 == line0 || col1 == _col0 || fail_Lint(
                    'Bad closing `' + token.value + '` indent, expecting ' + (_col0 - 1)
                        + ', got ' + (col1 - 1)
                        + '. Block starts on line ' + line0 + '.');

                break;
            }

            _col0 = token.col;

            _col0 > col00 || fail_Lint(
                'Bad indent, expecting more than ' + col00
                    + '. Block starts on line ' + line0 + '.');

            mut expr = mode /*== 'struct'*/
                ? parseStructItem()
                : parseStatement();

            expr.kind != 'call'
                || ((expr.flags & (F_ID | F_ACCESS)) == 0)
                || expr.items.len > 1
                || fail_Lint('Orphan pure-looking expression.');

            let exprIdx = items.len;

            // Filter out excess semicolons.
            if (expr.kind != 'empty')
                items.push(expr);

            // Unpacking & ungrouping node types.
            if (expr.kind == 'struct')
                unwrapStructMethods(items, exprIdx);
        }

        return items;
    }

    fn unwrapStructMethods(
        out: &mut Node[], structNodeIdx: i32): void
    {
        mut structNode = out[structNodeIdx];

        let members: &mut Node[] = structNode.items;
        for (mut i = 0; i < members.len; i++)
        {
            let item: &mut Node = members[i];
            if (item.kind == 'fn')
            {
                if (item.value == 'free')
                {
                    structNode.flags |= F_DESTRUCTOR;
                    item.flags |= F_DESTRUCTOR;
                }

                item.items.len >= 2 || fail();
                out.push(item);

                members.splice(i--, 1);
            }
        }

        out[structNodeIdx] = structNode;
    }


    //

    fn parseStatement(): Node
    {
        ///////////////////////////////////////////////
        let loc0  = _loc;
        let token = _loc = _tokens[_idx++] || fail();
        ///////////////////////////////////////////////

        if (token.kind == 'op' || token.kind == 'id')
        {
            let v = token.value;

            if (v == '{')           return parseBlock();
            if (v == 'let')         return parseLetStmt();
            if (v == 'mut')         return (_idx--, parseLetStmt());

            if (v == 'if')          return parseIf();
            if (v == 'return')      return parseReturn();

            if (v == 'for')         return parseFor();
            if (v == 'while')       return parseWhile();
            if (v == 'do')          return parseDoWhile();
            if (v == 'break')       return parseJump('break');
            if (v == 'continue')    return parseJump('continue');

            if (v == ';')           return parseEmpty();
            if (v == 'fn')          return parseFnDecl();
            if (v == 'struct')      return parseStructDecl();

            if (v == ':')           return parseLabelledStatement();

            // Ignore pubs for now.
            if (v == 'pub')         return parseStatement();
        }

        ////////////
        _idx--;
        _loc = loc0;
        ////////////

        // Expression statement, followed by a semi.
        return parseExpressionStatement();
    }

    fn parseLabelledStatement(): Node
    {
        let label = consume('id');
        mut stmt  = parseStatement();

        if (stmt.kind == 'loop')
        {
            stmt.value && fail();
            stmt.value = label.value || fail();
            return stmt;
        }

        return fail();
    }

    fn parseEmpty(): Node
    {
        return make('empty');
    }

    fn parseExpressionStatement(): Node
    {
        let expr = parseExpression(P_RESET);
        consume('op', ';');
        return expr;
    }

    fn parseFnDecl(): Node
    {
        ////////////////////////////////
        let numDollars0 = _numDollars;
        let numReturns0 = _numReturns;
        ////////////////////////////////

        // fn hello(), fn +()
        mut name = tryConsume('id');
        name ||= tryConsume('op');

        // Opening parens.
        consume('op', '(');

        mut items: Node[] = [];
        mut flags = parseArgsDecl(items, 'op', ')');

        ////////////////////////////////
        _fnDepth++;
        ////////////////////////////////

        // Return type annot.
        mut type = tryPopTypeAnnot();
        let retIdx = items.len;
        items.push(type);

        // Body or pattern (case/case).
        flags |= parseFnBodyOrPattern(items);

        // Inject `: void` annot here, easy,
        //  one less thing to deal with later.
        if (!type && _numReturns == numReturns0)
            items[retIdx] = type = createRead('void');

        if (type)
            flags |= F_FULLY_TYPED;

        ////////////////////////////////
        {
            _fnDepth--;
            _numReturns = numReturns0;

            let numDollars1 = _numDollars;
            _numDollars = numDollars0;
            if (numDollars1 != numDollars0)
                flags |= F_TEMPLATE;
        }
        ////////////////////////////////

        return make('fn', items, flags, name.value);
    }

    fn parseFnBodyOrPattern(
        out_push_body: &mut Node[]): i32
    {
        mut flags = 0;
        mut body: Node;
        //

        if (tryConsume('id', 'case'))
        {
            mut branches: Node[] = [];

            flags |= F_PATTERN;

            do
            {
                let cond = parseUnaryExpression();
                let type = tryPopTypeAnnot();
                let body = parseFnBodyBranch();

                branches.push(
                    make('fnbranch', [ cond, type, body ]));
            }
            while (tryConsume('id', 'case'));

            body = make('pattern', branches);
        }
        else
        {
            body = parseFnBodyBranch();
        }

        //
        out_push_body.push(body);
        return flags;
    }

    fn parseFnBodyBranch(): Node
    {
        let body = parseStatement();

        return body.kind == 'block' || body.kind == 'return'
             ? body
             : (_numReturns++, createReturn(body));
    }

    fn tryPopTypeAnnot(): Node
    {
        return tryConsume('op', ':')
             ? parseTypeAnnot()
             : miss;
    }

    fn parseTypeAnnot(): Node
    {
        return parseUnaryExpression();
    }

    fn parseArgsDecl(
        outArgs: &mut Node[],
        endk: string, endv: string): i32
    {
        mut first = true;
        mut outFlags = 0;

        mut implicit: Node[];
        mut defaults = false;

        while (true)
        {
            if (tryConsume(endk, endv))
                break;

            if (!first)
                consume('op', ',');

            first = false;

            mut arg = parseLet();

            if (!arg.items[LET_TYPE])
                outFlags |= F_UNTYPED_ARGS;

            if (arg.items[LET_INIT])
            {
                if (arg.flags & F_IMPLICIT)
                    fail('TODO default implicit arguments');

                defaults = true;
            }
            else if (defaults)
            {
                fail('TODO non-trailing default arguments');
            }

            arg.flags &= ~F_LOCAL;
            arg.flags |= F_ARG;

            if (arg.flags & F_IMPLICIT)
                implicit.push(arg);
            else
                outArgs.push(arg);
        }

        // Ensures implicit arguments always come last.
        if (implicit)
            for (mut i = 0; i < implicit.len; i++)
                outArgs.push(implicit[i]);

        return outFlags;
    }

    fn parseLetStmt(): Node
    {
        let ret = parseLet();
        consume('op', ';');
        return ret;
    }

    fn parseLet(): Node
    {
        mut flags = F_LOCAL;

        let numDollars0 = _numDollars;

        if (tryConsume('id', 'using'   )) flags |= F_USING;
        if (tryConsume('id', 'implicit')) flags |= F_IMPLICIT;
        if (tryConsume('id', 'mut'     )) flags |= F_MUT;

        let id      = consume('id').value;
        let type    = tryPopTypeAnnot();
        let init    = tryConsume('op', '=')
                    ? parseExpression(P_COMMA)
                    : Node();

        if (numDollars0 != _numDollars)
            flags |= F_TEMPLATE;

        if (flags & F_IMPLICIT)
            _implicits++;

        return createLet(id, flags, type, init);
    }

    fn createLet(
        id: string, flags: i32,
        type: Node, init: Node): Node
    {
        return make('let', [ type, init ], flags, id);
    }

    fn parseExpression(p1 = _precedence): Node
    {
        let p0      = _precedence;
        let loc0    = _loc;

        //////////////////////////////
        _precedence = p1;
        _loc        = _tokens[_idx] || fail();
        //////////////////////////////

        mut head    = parseExpressionHead();
        {
            mut out: Node;
            while (out  = tryParseExpressionTail(head))
            {
                _loc    = _tokens[_idx] || fail();
                head    = out;
            };
        }

        //////////////////////////////
        _precedence = p0;
        _loc        = loc0;
        //////////////////////////////

        return head;
    }

    fn tryParseBinary(left: Node, op: string, p1: i32): Node
    {
        if (p1 > _precedence || p1 == _precedence && !BINOP.RIGHT_TO_LEFT[p1])
            return miss;

        // consume
        _idx++;

        mut mid: Node;
        if (op == '?')
        {
            mid = parseExpression();
            consume('op', ':');
        }

        mut right = parseExpression(p1);
        if (mid)
            return createIf(left, mid, right);

        mut flags = F_INFIX;

        // We'll treat these two differently,
        //  no operator overloading for those guys.
        if (op == '||') return createOr (left, right);
        if (op == '&&') return createAnd(left, right);

        //
        return createCall(
            op, flags, [ left, right ]);
    }

    fn tryParseExpressionTail(head: &Node): Node
    {
        // Consume.
        let token = _tokens[_idx++];
        if (token.kind == 'op')
        {
            let v = token.value;

            if (v == ';') return (_idx--, miss);
            if (v == '.') return parseAccessExpression(head);
            if (v == '(') return parseCallExpression(head);
            if (v == '[') return parseIndexExpression(head);

            let p1 = BINOP.PRECEDENCE[v];
            if (p1)
                return (_idx--, tryParseBinary(head, v, p1));

            if (POSTFIX.has(v))
                return createCall(v, F_POSTFIX, [ head ]);
        }

        // Backtrack.
        return (_idx--, miss);
    }

    fn parseExpressionHead(): Node
    {
        //////////////////////////////
        let token = _tokens[_idx++];
        //////////////////////////////

        {
            let k = token.kind;

            // Literals.
            if (k == 'int' || k == 'num' || k == 'str')
                return createLeaf(
                    token.kind, token.value);

            // Identifier expression.
            if (k == 'id')
                return createRead(token.value);

            // Operators.
            if (k == 'op')
            {
                let v = token.value;

                if (v ==  '(') return parseParens();
                if (v ==  '[') return parseArrayLiteral();
                if (v ==  '$') return parseTypeParam();
                if (v ==  '@') return parseTypeTag();
                if (v == '[]') return make('definit');

                return parsePrefix(token.value);
            }
        }

        ///////
        _idx--;
        ///////

        return fail();
    }

    fn parseParens(): Node
    {
        mut items: Node[] = [];

        do
        {
            items.push(parseExpression(P_COMMA));
        }
        while (tryConsume('op', ','));

        consume('op', ')');

        return items.len > 1
             ? createComma(items)
             : items[0];
    }

    fn createComma(nodes: &Node[]): Node
    {
        return make('comma', nodes);
    }

    fn parseTypeParam(): Node
    {
        _numDollars++;
        return createTypeParam(consume('id').value);
    }

    fn createTypeParam(value: string): Node
    {
        return make('typeparam', :value);
    }

    fn parseTypeTag(): Node
    {
        return createTypeTag(consume('id').value);
    }

    fn createTypeTag(value: string): Node
    {
        return make('typetag', :value);
    }

    fn parsePrefix(mut op: string): Node
    {
        PREFIX.has(op) || (_idx--, fail());

        if (op == '&' && tryConsume('id', 'mut'))
            op = '&mut';

        return createPrefix(
            op, parseUnaryExpression());
    }

    fn parseUnaryExpression(): Node
    {
        return parseExpression(P_PREFIX_UNARY);
    }

    fn createPrefix(op: string, expr: &Node): Node
    {
        return createCall(op, F_PREFIX, [ expr ]);
    }

    fn parseAccessExpression(expr: &Node): Node
    {
        return createCall(
            consume('id').value,
            F_ACCESS, [ expr ]);
    }


    //

    fn parseCallArgs(endop: string, out_args: &mut Node[]): i32
    {
        mut flags = 0;

        mut first = true;
        while (true)
        {
            if (tryConsume('op', endop))
                break;

            // Comma juggle.
            if (!first)
                consume('op', ',');

            first = false;

            // Named arguments.
            mut name = '';
            mut autoName = false;

            if (_tokens[_idx    ] .kind == 'id' &&
                _tokens[_idx + 1] .kind == 'op' &&
                _tokens[_idx + 1].value == ':')
            {
                name = _tokens[_idx].value;
                _idx += 2;

                flags |= F_NAMED_ARGS;
            }
            else if (_tokens[_idx].kind == 'op'
                  && _tokens[_idx].value == ':')
            {
                autoName = true;
                _idx++;

                flags |= F_NAMED_ARGS;
            }

            let expr = parseExpression(P_COMMA);
            if (autoName)
            {
                expr.kind == 'call' && (expr.flags & F_ID)
                    || fail('Can\'t :auto_name this expression.');

                name = expr.value;
            }

            out_args.push(
                name    ? createLabel(name, expr)
                        : expr);
        }

        return flags;
    }

    fn createLabel(id: string, value: &Node): Node
    {
        return make('label', [ value ], 0, id);
    }

    fn parseCallExpression(expr: &Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(')', args);

        // Uniform call syntax.
        if (expr.kind == 'call' && (expr.flags & F_ACCESS))
        {
            let head = expr.items
                    && expr.items.len == 1
                    && expr.items[0] || fail();

            args.unshift(head);

            return createCall(
                expr.value || fail(), F_METHOD | argFlags,
                args);
        }

        if (expr.kind == 'call' && (expr.flags & F_ID))
            return createCall(
                expr.value || fail(), argFlags, args);

        return fail('TODO dynamic call');
    }

    fn parseArrayLiteral(): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(']', args);

        return createArrayLiteral(argFlags, args);
    }

    fn createArrayLiteral(argFlags: i32, items: Node[]): Node
    {
        return make('arrlit', items, argFlags);
    }

    fn parseIndexExpression(expr: Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(']', args);

        args.unshift(expr);

        return createCall('[]',
            F_INDEX & argFlags, args);
    }

    fn createLeaf(kind: string, value: string): Node
    {
        return make(kind, :value);
    }

    fn createCall(id: string, flags: i32, args: Node[] = []): Node
    {
        return make('call', args, flags, id);
    }

    fn createRead(id: string): Node
    {
        return createCall(id || fail(), F_ID);
    }


    //

    fn parseReturn(): Node
    {
        _fnDepth > 0 || (_idx--, fail());
        _numReturns++;

        if (tryConsume('op', ';'))
            return createReturn();

        return createReturn(
            parseExpressionStatement());
    }

    fn createReturn(node: Node = Node()): Node
    {
        if (!node)
            return make('return');

        return make('return', [ node ]);
    }

    fn parseJump(kind: string /*'break'|'continue'*/): Node
    {
        mut label = '';

        mut jump = tryConsume('op', ':')
            ? createJump(kind, consume('id').value)
            : createJump(kind, label);

        consume('op', ';');
        return jump;
    }

    fn createJump(kind: string/*'break'|'continue'*/, label: string): Node
    {
        return make(kind, value: label);
    }


    //

    fn parseIf(): Node
    {
        consume('op', '(');
        let cond = parseExpression();
        consume('op', ')');

        let cons: Node = parseStatement();

        let alt: Node = tryConsume('id', 'else')
            ? parseStatement()
            : miss;

        return createIf(cond, cons, alt);
    }


    //

    fn createIf(cond: Node, cons: Node, alt: Node): Node
    {
        return make('if', [ cond, cons, alt ]);
    }

    fn createOr(left: Node, right: Node): Node
    {
        return flattenIfSame('or', left, right);
    }

    fn createAnd(left: Node, right: Node): Node
    {
        return flattenIfSame('and', left, right);
    }

    fn flattenIfSame(kind: string, left: Node, right: Node): Node
    {
        let k_left  =  left.kind;
        let k_right = right.kind;

        let items =
            k_left == kind && k_right == kind
                ? left.items.concat(right.items)
                : k_left == kind
                    ? left.items.concat([ right ])
                    : k_right == kind
                        ? [ left ].concat(right.items)
                        : [ left, right ];

        return make(kind, items);
    }


    //

    fn parseFor(): Node
    {
        consume('op', '(');

        tryConsume('id', 'let');
        let init = parseLetStmt();
        let cond = parseExpressionStatement();

        let token = _tokens[_idx];
        let post = token.kind == 'op' && token.value == ')'
            ? parseEmpty()
            : parseExpression();

        consume('op', ')');
        let body = parseStatement();

        return createLoop(init, cond, post, body, miss);
    }

    fn parseWhile(): Node
    {
        consume('op', '(');
        let cond = parseExpression();
        consume('op', ')');
        let body = parseStatement();

        return createLoop(miss, cond, miss, body, miss);
    }

    fn parseDoWhile(): Node
    {
        let body = parseStatement();
        consume('id', 'while');
        consume('op', '(');
        let cond = parseExpression();
        consume('op', ')');
        consume('op', ';');

        return createLoop(miss, miss, miss, body, cond);
    }

    fn createLoop(init: Node, cond: Node, post: Node, body: Node, postcond: Node): Node
    {
        return make('loop', [ init, cond, post, body, postcond ]);
    }

    // -------------------------------
    // Good to go.

    // Check EOF.
    _tokens[_tokens.len - 1].kind == 'eof' || fail(
        'Missing `eof` token.');

    //
    return parseRoot();
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Types.

// pub struct Primitive
//     'i8'  | 'u8'  |
//     'i16' | 'u16' |
//     'i32' | 'u32' |
//     'i64' | 'u64' | 'bool' | 'void' | 'never'
//                   | 'template'
//                   | 'string';

pub let q_mutref       = 1 << 0;
pub let q_ref          = 1 << 1;
pub let q_prvalue      = 1 << 2;
pub let q_copy         = 1 << 3;
pub let q_move         = 1 << 4;

pub let q_trivial      = 1 << 5;
pub let q_primitive    = 1 << 6;
pub let q_arithmetic   = 1 << 7;
pub let q_integral     = 1 << 8;
pub let q_signed       = 1 << 9;

let TAGS =
[
    'mutref',
    'ref',
    'prvalue',
    'copy',
    'move',

    'trivial',
    'primitive',
    'arithmetic',
    'integral',
    'signed'
];

pub struct Type
{
    canon: string;
    quals: i32;
};

fn ==(a: &Type, b: &Type)
    a.canon == b.canon &&
    a.quals == b.quals;


//

pub let Trivial        = q_copy | q_trivial;
pub let Primitive      = Trivial | q_primitive;
pub let Arithmetic     = Primitive | q_arithmetic;
pub let Integral       = Arithmetic | q_integral;
pub let SignedInt      = Integral | q_signed;

pub let t_i32          = Type('i32', SignedInt);
pub let t_void         = Type('void', 0);
pub let t_bool         = Type('bool', Primitive);
pub let t_never        = Type('never', 0);
pub let t_template     = Type('template', 0);
pub let t_string       = Type('string', q_copy);


// https://doc.rust-lang.org/nomicon/subtyping.html:

// Re: covariance of `T` in `Box<T>`:
//
// As it turns out, the argument for why it's ok for Box
//  (and Vec, Hashmap, etc.) to be covariant is pretty similar
//   to the argument for why it's ok for lifetimes to be covariant:
//    as soon as you try to stuff them in something like a mutable
//     reference, they inherit invariance and you're prevented
//      from doing anything bad.

pub fn isAssignable(host: Type, guest: Type)
{
    return host.canon == guest.canon
            && (host.quals == guest.quals ||
                  !(host.quals & q_mutref) // mut invariance
                    && (host.quals & guest.quals) == host.quals)
        || guest == t_never
            && guest.quals == 0;
}


//

pub fn qadd(type: Type, q: i32)
{
    return Type(type.canon, type.canon ? type.quals | q : 0);
}

pub fn qsub(type: Type, q: i32)
{
    return Type(type.canon, type.quals &~ q);
}

pub fn qhas(type: Type, q: i32)
{
    return type.quals & q == q;
}

fn tryClear(type: Type, q: i32): Type
{
    if (!type || !qhas(type, q))
        return Type();

    return qsub(type, q);
}


//

pub fn add_ref(type: Type)
{
    return qadd(type, q_ref);
}

pub fn add_mutref(type: Type)
{
    return qadd(type, q_ref | q_mutref);
}

pub fn add_prvalue_ref(type: Type)
{
    return qadd(type, q_ref | q_prvalue);
}


//

pub fn tryClear_mutref(type: Type)
{
    return tryClear(type, q_ref | q_mutref);
}

pub fn tryClear_ref(type: Type)
{
    let t = tryClear(type, q_ref);

    return t
         ? qsub(t, q_mutref)
         : t;
}

pub fn clear_refs(type: Type)
{
    return qsub(type, q_ref | q_mutref | q_prvalue);
}

pub fn add_refs_from(src: Type, dest: Type)
{
    return qadd(dest, src.quals & (q_ref | q_mutref));
}


//

pub fn serializeType(type: Type)
{
    if (type.quals)
        return '(' + type.canon + '{' + type.quals + '})';

    return '(' + type.canon + ')';
}

pub fn type_has(type: Type, tag: string)
{
    let idx = TAGS.find(tag);
    idx >= 0 || throw('Unknown type tag: `' + tag + '`.');
    let mask = 1 << idx;
    return (type.quals & mask) == mask;
}


//

pub fn type_tryInter(a: Type, b: Type)
{
    if (a.canon != b.canon)
        return Type();

    return Type(
        a.canon,
        a.quals & b.quals);
}


//

pub struct Struct
{
    kind:   string; // 'struct'|'array'|'map';
    id:     string;
    fields: StructField[];
    flags:  i32;
};

pub struct StructField
{
    id:     string;
    type:   Type;
};


// The temp context -
//  TBD what this will look like in the end -
//   we'll likely need a typespace per module,
//    so everyone can read from immut shared concurrently,
//     and write into their own without having to sync.

pub struct TEMP_Context
{
    types:  Map(string, Struct);
};

pub fn registerType(
    implicit ctx: &mut TEMP_Context,
    canon: string, def: Struct): void
{
    ctx.types[canon] = def;
}

pub fn lookupType(
    implicit ctx: &TEMP_Context,
    canon: string): &Struct
{
    return ctx.types[canon] || assert();
}

pub fn lookupType_mut(
    implicit ctx: &mut TEMP_Context,
    canon: string): &mut Struct
{
    return ctx.types[canon] || assert();
}


//

pub fn initStruct(id: string, flags: i32)
{
    // TODO struct data goes on compile context.
    // TODO use module id.

    let canon = 's_' + id;
    let def = Struct(
        kind:   'struct',
        id:     id      || throw('TODO anonymous structs?'),
        flags:  flags|0
    );

    registerType(canon, def);

    // TODO copyOrMove
    return Type(canon, q_copy);
}

pub fn finalizeStruct(id: string, fields: StructField[])
{
    // TODO struct data goes on compile context.
    // TODO use module id.

    let canon = 's_' + id;
    let def: &mut Struct = lookupType_mut(canon);

    def.fields = fields || throw('TODO empty structs?');
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[],
    tryTrivial: bool = false): i32
{
    if ((flags & F_DESTRUCTOR) || someFieldNonCopy(fields))
        return q_move;

    if (tryTrivial && !someFieldNotTrivial(fields))
        return Trivial;

    return q_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if (!(fields[i].type.quals & q_copy))
            return true;

    return false;
}

fn someFieldNotTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if (!(fields[i].type.quals & q_trivial))
            return true;

    return false;
}


//

pub fn createArray(item: Type): Type
{
    let flags = 0;
    let fields: StructField[] =
    [
        StructField(
            id:  'Item',
            type: item)
    ];

    let canon = 'Array(' + serializeType(item) + ')';

    registerType(canon, Struct(
        kind:   'array',
        id:     canon,
        :fields,
        :flags));

    return Type(canon,
        copyOrMove(flags, fields));
}

pub fn type_isString(type: Type): bool
{
    return type.canon == 'string';
}

pub fn type_isArray(type: Type): bool
{
    return type.canon.starts(with: 'Array(');
}

pub fn tryClear_array(type: Type): Type
{
    if (!type_isArray(type))
        return Type();

    let def = lookupType(type.canon);

    return def.kind == 'array'
        && def.fields[0].type
        || assert();
}


//

pub fn type_isMap(type: Type): bool
{
    return type.canon.starts(with: 'Map(');
}

pub fn createMap(key: Type, value: Type): Type
{
    let flags  = 0;
    let fields =
    [
        StructField(id:  'Key',   type: key  ),
        StructField(id:  'Value', type: value)
    ];

    let canon = 'Map(' + serializeType(key) + ',' + serializeType(value) + ')';

    registerType(canon, Struct(
        kind:   'map',
        id:     canon,
        :fields,
        :flags
    ));

    return Type(canon,
        copyOrMove(flags, fields));
}

pub struct MapFields
{
    key:   Type;
    value: Type;
}

pub fn tryClear_map(type: Type): MapFields
{
    if (!type_isMap(type))
        return MapFields();

    let def = lookupType(type.canon);
    def.kind == 'map' || assert();

    return MapFields(
        key:   def.fields[0].type || assert(),
        value: def.fields[1].type || assert());
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

struct ScopeIdx { raw: i32; };

struct SolvedNode
{
    kind:       string;
    flags:      i32;
    value:      string;
    items:      SolvedNode[];
    token:      Token;

    type:       Type;
    target:     ScopeIdx;
};

struct Template
{
    node: Node;
    specializations: Map(string, SolvedNode); // mangle -> spec
};

struct Partial
{
    via: ScopeIdx;
    target: ScopeIdx;
};

struct Overload
{
    kind: string;
    name: string;
    type: Type;

    // Arity.
    min: i32;
    max: i32;
    args: Type[];
    names: string[];
    defaults: SolvedNode[];

    // Amazing stuff.
    partial: Partial;
    template: Template;
};

struct ScopeItem
{
    id:         string;
    index:      ScopeIdx;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
};

pub fn Scope_lookup(scope: &Scope, id: string): ScopeIdx[]
{
    mut results: ScopeIdx[] = [];

    let items = scope.items;
    for (mut i = items.len; i --> 0; )
    {
        let item = items[i];
        if (item.id == id)
            results.push(item.index);
    }

    return results;
}

pub fn Scope_keys(scope: &Scope): string[]
{
    mut keys: string[] = [];

    let items = scope.items;
    for (mut i = items.len; i --> 0; )
    {
        let id = items[i].id;
        if (!keys.has(id))
            keys.push(id);
    }

    return keys;
}


////////////////////////////////

pub fn Scope_push(scope: &mut Scope): i32
{
    return scope.items.len;
}

pub fn Scope_pop(scope: &mut Scope, memo: i32): void
{
    scope.items.shrink(memo);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,

    min: i32 = 0,
    max: i32 = 0,
    arg_n: string[]     = [],
    arg_t: Type[]       = [],
    arg_d: SolvedNode[] = [],
    template: Template  = [],
    partial: Partial    = []): ScopeIdx
{
    let index = ScopeIdx(scope.overloads.len + 1);

    let item = Overload(
        :kind,
        name: id, :type,
        :min, :max, args: arg_t,
        names: arg_n, defaults: arg_d,
        :partial, :template);

    scope.items.push(ScopeItem( :id, :index ));
    scope.overloads.push(item);

    return index;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub struct SolveResult
{
    root:       SolvedNode;
    scope:      Scope;
};

fn Scope_Typedef(scope: &mut Scope, id: string, type: Type)
{
    return Scope_add(scope, 'type', id, type);
}


//

fn runSolver(implicit ctx: &mut TEMP_Context, parse: &Node, globals: &Scope): SolveResult
{
    mut _scope:         Scope       = globals;

    mut _here:          Token;
    mut _current_fn:    SolvedNode;
    mut _current_strt:  Type;
    mut _typeParams:    Map(string, Type);

    mut TEST_expectImplicits: bool = false;


    //

    fn GET(idx: ScopeIdx): &mut Overload
    {
        idx.raw > 0 || assert();
        return _scope.overloads[idx.raw - 1];
    }


    //

    fn fail(mut reason: string = ''): never
    {
        if (!reason)
            reason = 'Unexpected `' + _here.value + '`.';

        let fname = _here.fname;
        let l0    = _here.line;
        let c0    = _here.col;

        let addr = '@' + l0 + ':' + c0;

        return throw(fname + ' ' + addr + ':\n\t' + reason);
    }


    //

    fn Binding(id: string, type: Type)
    {
        return Scope_add(_scope, 'var', id, type);
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope,
            'field', id, fieldType,
            1, 1, [ 'this' ], [ structType ]);
    }

    fn TemplateDecl(node: Node)
    {
        let id = node.value;

        node.kind == 'fn' || fail('TODO');
        let min = node.items.len + FN_ARGS_BACK;

        let max = node.kind == 'fn'
            ? 0xffffff // implicit args etc, dunno whats happening, allow it all
            : min;

        let template = Template(node);

        mut arg_n: string[];
        if (node.kind == 'fn')
        {
            let items = node.items;
            let numArgs = items.len + FN_ARGS_BACK;
            for (mut i = 0; i < numArgs; i++)
            {
                let arg = items[i] || fail();
                arg.kind == 'let' || fail();
                let name = arg.value || fail();
                arg_n.push(name);
            }
        }

        return Scope_add(
            _scope,
            'template', id, t_template,
            min, max, arg_n, :template);
    }

    fn FnDecl(id: string, node: &mut SolvedNode): ScopeIdx
    {
        let items = node.items;
        let rnode = items[items.len + FN_RET_BACK];
        let ret   = rnode && rnode.type || fail();

        let max   = items.len + FN_RET_BACK;
        let args  = items.slice(0, max);

        mut arg_t: Type[]       = [];
        mut arg_n: string[]     = [];
        mut arg_d: SolvedNode[] = [];

        mut min = 0;
        for (mut i = 0; i < max; i++)
        {
            let arg = args[i]    || fail();
            arg.kind == 'let'    || fail();
            arg_t.push(arg.type  || fail());
            arg_n.push(arg.value || fail());

            //
            let isImplicit = !!(arg.flags & F_IMPLICIT);

            // Non-implicit, non-defaulted argument?
            if (!isImplicit)
            {
                arg_d.len >= i || fail();

                let def = arg.items[LET_INIT];
                arg_d.push(def);
                if (!def)
                    min++;
            }
        }

        let overload = Scope_add(
            _scope,
            'fn', id, ret,
            min, max, arg_n, arg_t, arg_d);

        node.target = overload;

        return overload;
    }

    fn DefaultCtor(id: string, type: Type, members: SolvedNode[])
    {
        mut arg_t:   Type[] = [];
        mut arg_n: string[] = [];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            arg_t.push(member.type  || fail());
            arg_n.push(member.value || fail());
        }

        //
        let max   = members.len;
        mut min   = 0;
        mut arg_d: SolvedNode[];

        {
            for (mut i = 0; i < members.len; i++)
            {
                let member = members[i];

                mut init = member.items[LET_INIT];
                init ||= tryDefaultInit(member.type);

                // Disable defaulting if any member is non-defaulted.
                if (!init)
                {
                    min = max;
                    arg_d.clear();
                    break;
                }

                arg_d.push(init);
            }
        }

        return Scope_add(
            _scope,
            'defctor', id, type,
            min, max, arg_n, arg_t, arg_d);
    }

    fn tryDefaultInit(type: Type): SolvedNode
    {
        // Reference? No init, else default.
        if (type.quals & q_ref)
            return SolvedNode();

        return createDefaultInit(type);
    }

    fn createDefaultInit(type: Type): SolvedNode
    {
        return SolvedNode(
            kind: 'definit',
            token: _here || fail(),
            :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                'Cannot solve definit, no inferred type.');

        let init = tryDefaultInit(type);
        init || fail('Cannot definit: ' + serializeType(type));
        return init;
    }


    //

    fn Partial(id: string, viaIdx: ScopeIdx, overloadIdx: ScopeIdx)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = 'p-unshift';
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut arg_t = overload.args     ? overload.args    .slice(1) : overload.args;
        mut arg_n = overload.names    ? overload.names   .slice(1) : overload.names;
        mut arg_d = overload.defaults ? overload.defaults.slice(1) : overload.defaults;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != 'var')
        {
            kind = 'p-wrap';
            min++;
            max++;

            let via_t = via.args && via.args[0] || fail();

            //
            arg_t.unshift(via_t);
            if (arg_n)
                arg_n.unshift('using');
            if (arg_d)
                arg_d.unshift(SolvedNode());
        }

        return Scope_add(
            _scope,
            kind, id, overload.type,
            min, max, arg_n, arg_t, arg_d,
            partial: Partial(viaIdx, overloadIdx));
    }


    //

    fn hasIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z')
            {
                return true;
            }
        }

        return false;
    }

    fn scope_using(viaIdx: ScopeIdx)
    {
        let via = GET(viaIdx);
        let actual = via.type || fail();

        let keys = Scope_keys(_scope);
        for (mut i = 0; i < keys.len; i++)
        {
            let id = keys[i];

            // Skip over operators.
            if (!hasIdentifierChars(id))
                continue;

            let overloads = Scope_lookup(_scope, id);
            if (!overloads)
                continue;

            mut arity0 = false;
            let MUT_n0 = overloads.len;
            for (mut i = 0; i < MUT_n0; i++)
            {
                let overloadIdx = overloads[i];
                let overload = GET(overloadIdx);

                if (overload.min < 1)
                {
                    arity0 = true;
                    continue;
                }

                // TODO using + templates, the fuck do we do?
                if (overload.template)
                    continue;

                let expect = (overload.args || fail())[0] || fail();
                if (!isAssignable(expect, actual))
                    continue;

                if (overload.min < 2 && arity0)
                    fail('`using` arity-0 conflict: `' + id + '`.');

                // MUT DURING ITER!
                Partial(id, viaIdx, overloadIdx);
            }
        }
    }


    //

    fn getNamedArgReorder(
        callsite:    &string[],
        declaration: &string[]): i32[]
    {
        mut result: i32[] = [];

        mut offset = 0;
        for (mut i = 0; i < declaration.len; i++)
        {
            mut idx = callsite.find(declaration[i]);
            if (idx < 0)
            {
                for (mut i = offset; i < callsite.len; i++)
                {
                    offset++;
                    if (!callsite[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }

            result.push(idx);
        }

        return result;
    }

    fn scope_tryMatch__mutargs(
        id: string, args: &mut SolvedNode[],
        flags: i32 = 0, retType: Type = []): ScopeIdx
    {
        mut matchIdx: ScopeIdx;

        //
        let overloads = Scope_lookup(_scope, id);
        if (!overloads)
            return matchIdx;

        // Arity 0 - blind head match.
        // Allows simple shadowing of variables and such, latest wins.
        if (!args.len)
        {
            let headIdx = overloads[0];
            if (GET(headIdx).min == 0)
                matchIdx = headIdx;
        }

        if (!matchIdx)
        {
            let arity = args.len;

            // Prep labelled args for remap.
            mut names: string[];
            if (flags & F_NAMED_ARGS)
            {
                mut some = false;

                for (mut i = 0; i < arity; i++)
                {
                    let arg = args[i];
                    names.push(arg.kind == 'label'
                        ? (some = true, arg.value) || fail()
                        : '');
                }

                some || fail();
            }

            mut reorder: i32[];

            //
            :NEXT
            for (mut i = 0; i < overloads.len; i++)
            {
                mut overloadIdx = overloads[i];
                mut overload = GET(overloadIdx);

                :TEST_AGAIN
                while (true)
                {
                    if (overload.min > arity || overload.max < arity)
                        continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    //
                    if (names && overload.names)
                    {
                        reorder = getNamedArgReorder(
                            names, overload.names);
                    }
                    else
                    {
                        reorder.clear();
                    }

                    // Specialize.
                    if (overload.template)
                    {
                        if (reorder)
                            fail('TODO handle argument reorder in template specialization.');

                        let specIdx = trySpecialize(
                            overload.template, args);

                        if (!specIdx)
                            continue :NEXT;

                        overloadIdx = specIdx;
                        overload = GET(specIdx);

                        // Repeat arity checks and such.
                        continue :TEST_AGAIN;
                    }

                    // Done here.
                    break :TEST_AGAIN;
                }

                // Type check args.
                let arg_t = overload.args || fail();
                let arg_d = overload.defaults;

                let N = reorder ? reorder.len
                                : args.len;

                for (mut i = 0; i < N; i++)
                {
                    let callsiteIndex = reorder ? reorder[i]
                                                : i;
                    if (callsiteIndex < 0)
                    {
                        // Argument may not be defaulted -
                        //  we might be supplying defaults via names
                        //   before we've actually exhausted
                        //    all the non-defaulted stuff.
                        if (!(arg_d && arg_d[i]))
                            continue :NEXT;

                        continue;
                    }

                    if (!isAssignable(arg_t[i], (args[callsiteIndex] || fail()).type))
                        continue :NEXT;
                }

                // Forbid ambiguity.
                if (matchIdx)
                    fail('Ambiguous callsite, matches multiple functions in scope: `' + id + '`.');

                // Done!
                matchIdx = overloadIdx;

                // Do reorder.
                if (reorder)
                {
                    // TODO:
                    // I shouldn't need this pass, just swaps must do.
                    mut new_args: SolvedNode[];
                    new_args.resize(reorder.len);

                    for (mut i = 0; i < reorder.len; i++)
                    {
                        let idx = reorder[i];
                        if (idx >= 0)
                            new_args[i] = args[idx];
                    }

                    for (mut i = 0; i < new_args.len; i++)
                        args[i] = new_args[i];
                }
            }
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let arg_d = matched.defaults;
            if (arg_d)
                for (mut i = 0; i < arg_d.len; i++)
                    args[i] = args[i] || arg_d && arg_d[i] || fail();

            // Implicit argument injection.
            let arg_t = matched.args;

            if (arg_t && args.len < arg_t.len)
            {
                let arg_n = matched.names || fail();
                for (mut i = args.len; i < arg_t.len; i++)
                {
                    let id   = arg_n[i];
                    let type = arg_t[i];

                    // Propagate implicit.
                    bindImplicitArg(args, i, id, type);
                }
            }
        }

        return matchIdx;
    }


    //

    fn scope_match__mutargs(id: string, args: &mut SolvedNode[], flags: i32): ScopeIdx
    {
        let ret = scope_tryMatch__mutargs(:id, :args, :flags);
        if (ret)
            return ret;

        return Scope_lookup(_scope, id)
             ? fail('No overload of `' + id + '` matches call signature.')
             : fail('`' + id + '` is not defined.');
    }

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == 'root')       return solveRoot(node);
        if (k == 'block')      return solveBlock(node);
        if (k == 'label')      return solveComma(node);
        if (k == 'comma')      return solveComma(node);

        if (k == 'let')        return solveLet(node);
        if (k == 'call')       return solveCall(node);
        if (k == 'arrlit')     return solveArrayLiteral(node, type);
        if (k == 'if')         return solveIf(node);
        if (k == 'or')         return solveOr(node);
        if (k == 'and')        return solveAnd(node);
        if (k == 'loop')       return solveBlock(node);

        if (k == 'return')     return solveReturn(node);
        if (k == 'break')      return solveJump(node);
        if (k == 'continue')   return solveJump(node);

        if (k == 'int')        return solveInt(node);
        if (k == 'str')        return solveStr(node);
        if (k == 'empty')      return solveEmpty(node);

        if (k == 'definit')    return solveDefinit(type);

        return fail('TODO: ' + k);
    }

    fn isUnordered(kind: string)
    {
        return kind == 'fn'
            || kind == 'struct';
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == 'fn')         return uPrepFn(node);
        if (k == 'struct')     return uPrepStruct(node);

        return fail('TODO: ' + k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == 'fn')         return uSolveFn(node, prep);
        if (k == 'struct')     return uSolveStruct(node, prep);

        return fail('TODO: ' + k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        TEST_expectImplicits = !!(node.flags & F_IMPLICIT);

        return solved(node, t_void, solveNodes(node.items));
    }

    fn solveBlock(node: Node): SolvedNode
    {
        let scope0 = Scope_push(_scope);
        let out = solved(node, t_void, solveNodes(node.items));
        Scope_pop(_scope, scope0);
        return out;
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(node: Node): SolvedNode
    {
        return solved(node, t_i32);
    }

    fn solveStr(node: Node): SolvedNode
    {
        return solved(node, t_string);
    }

    fn solveEmpty(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(false, false, node, SolvedNode, -1);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(true, false, node, prep, -1);
    }

    fn __solveFn(solve: bool, spec: bool, n_fn: Node, prep: SolvedNode, caseIdx: i32): SolvedNode
    {
        let id = n_fn.value || fail('TODO anonymous fns');

        // Template early exit.
        if (spec)
        {
            solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl   = TemplateDecl(n_fn);
            mut out     = solved(n_fn, t_void);
            out.target  = tDecl;
            return out;
        }

        // Prep reject.
        if (!solve && !(n_fn.flags & F_FULLY_TYPED))
            return SolvedNode();

        let inItems = n_fn.items;
        inItems.len >= FN_RET_BACK || fail();

        mut out = prep;
        out ||= solved(n_fn, t_void);

        out.items.resize(inItems.len);

        //
        if (_current_fn && id != 'free')
        {
            _current_fn.flags |= F_HAS_CLOSURE;
            out.flags |= F_CLOSURE;
        }

        //////////////////////////
        {
            let current_fn0     = _current_fn;
            let scope0          = Scope_push(_scope);

            _current_fn = out;
            let outItems: &mut SolvedNode[] = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == 'let' || fail();
                outItems[i] = solveLet(n_arg);
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
            mut n_body  = inItems[inItems.len + FN_BODY_BACK] || fail();

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == 'pattern' || fail();
                let branch = n_body.items[caseIdx] || fail();
                let items = branch.items;

                n_ret   = items[items.len + FN_RET_BACK]  || n_ret;
                n_body  = items[items.len + FN_BODY_BACK];
            }

            // Return type annot.
            {
                let s_ret = n_ret
                    ? evalTypeAnnot(n_ret)
                    : SolvedNode();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_RET_BACK] = s_ret;
            }

            // Only if actually solving the fn, the fn body.
            if (solve)
            {
                let s_body = solveNode(n_body);
                s_body || fail();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body;
            }

            //
            /////////////////////////////////////////////////////

            out                 = _current_fn;
            _current_fn         = current_fn0;
            Scope_pop(_scope, scope0);
        }
        //////////////////////////

        if (!prep)
            FnDecl(id, out);

        !solve || out.items[out.items.len + FN_BODY_BACK] || fail();

        return out;
    }


    //

    fn TODO_memoize_mangler(args: SolvedNode[]): string
    {
        mut mangle = '';
        for (mut i = 0; i < args.len; i++)
            mangle += '\v' + serializeType((args[i] || fail()).type);

        return mangle;
    }


    //

    fn trySpecialize(
        template: &mut Template, args: SolvedNode[])
            : ScopeIdx
    {
        let mangle = TODO_memoize_mangler(args);

        //
        let spec =
            (template.specializations[mangle] ||=
                doTrySpecialize(template, args));

        return spec.target;
    }

    fn doTrySpecialize(
        template: &mut Template, args: SolvedNode[])
            : SolvedNode
    {
        let node = template.node;

        node.kind == 'fn' || fail('TODO');
        mut result = trySpecializeFn(node, args);
        if (!result)
            result.kind = 'spec-fail';

        return result;
    }


    //

    fn trySpecializeFn(
        node: Node, args: SolvedNode[])
            : SolvedNode
    {
        let items = node.items;
        mut typeParams: Map(string, Type);

        // First off, solve type params.
        let numArgs = items.len + FN_ARGS_BACK;
        for (mut i = 0; i < numArgs; i++)
        {
            let argNode = items[i] || fail();
            argNode.kind == 'let'  || fail();

            let inType = args.len > i ? args[i].type : Type();
            if (inType)
            {
                let argName = argNode.value || fail();
                typeParams[argName] ||= inType;
            }

            if (argNode.flags & F_TEMPLATE)
            {
                let annot = argNode.items[LET_TYPE];
                if (annot)
                {
                    let ok = inType && trySolveTypeParams(
                        annot, inType, typeParams);

                    if (!ok)
                        return SolvedNode();
                }
            }
        }

        // Match pattern arm here.
        mut caseIdx = -1;

        let pattern = items[items.len + FN_BODY_BACK] || fail();
        if (pattern.kind == 'pattern')
        {
            let branches = pattern.items;
            for (mut i = 0; i < branches.len; i++)
            {
                let branch = branches[i];
                let items = (branch || fail()).items;
                let cond = items[0] || fail();

                if (evalTypePattern(cond, typeParams))
                {
                    caseIdx = i;
                    break;
                }
            }

            // All branches mismatch?
            if (caseIdx < 0)
                return SolvedNode();
        }

        ////////////////////////////////
        _typeParams = typeParams;
        let typeParams0 = _typeParams;
        let scope0 = Scope_push(_scope);
        ////////////////////////////////

        let specialized = __solveFn(true, true, node, SolvedNode(), caseIdx);
        specialized || fail();

        ////////////////////////////////
        _typeParams = typeParams0;
        Scope_pop(_scope, scope0);
        ////////////////////////////////

        return specialized;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(false, node, SolvedNode());
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(true, node, prep);
    }

    fn __solveStruct(solve: bool, node: Node, prep: SolvedNode): SolvedNode
    {
        mut out     = prep;
        out ||= solved(node, t_void);

        let id      = node.value || fail('TODO anonymous structs');
        let type    = initStruct(id, node.flags);

        // Add the arity-0 type entry.
        if (!prep)
            out.target = Scope_Typedef(_scope, id, type);

        if (!solve)
            return out;

        //////////////////////////
        {
            let current_strt0   = _current_strt;
            _current_strt       = type;

            out.items.resize(node.items.len);
            solveNodes(node.items, out.items);

            _current_strt       = current_strt0;
        }
        //////////////////////////

        // Add a default constructor.
        {
            mut members: SolvedNode[];
            let items = out.items;

            mut fields: StructField[];

            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == 'let' && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value || fail(),
                            type: item.type  || fail()));
                }
            }

            finalizeStruct(id, fields);

            DefaultCtor(id, type, members);
        }

        return out;
    }


    //

    fn solveReturn(node: Node): SolvedNode
    {
        let out = solved(node, t_void, solveNodes(node.items));

        // Either use the return expression,
        //  or the void-returning return statement itself,
        //   so we always have a node to rely on.

        let nextExpr  = out.items[0] || out;
        let nextType  = nextExpr.type || fail();

        let retIdx    = _current_fn.items.len + FN_RET_BACK;
        let prevExpr  = _current_fn.items[retIdx];

        mut prevType: Type;
        if (prevExpr)
            prevType = prevExpr.type || fail();

        if (prevType)
        {
            isAssignable(prevType, nextType)
                || fail('Non-assignable return types: ' + serializeType(prevType) + ' <- ' + serializeType(nextType));
        }
        else
        {
            _current_fn.items[retIdx] = nextExpr || fail();
        }

        return out;
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveLet(node: Node): SolvedNode
    {
        let annot     = node.items[LET_TYPE];
        let init      = node.items[LET_INIT];

        let s_annot   = annot ? evalTypeAnnot(annot) : SolvedNode;
        let t_annot   = s_annot ? s_annot.type : Type;

        mut s_init    = init ? solveNode(init, t_annot) : SolvedNode;
        let t_init    = s_init ? s_init.type : Type;

        let t_let     = t_annot ? t_annot : clear_refs(t_init || fail(
            'Variable declarations without explicit type annotations must be initialized.'));

        if (t_annot && t_init)
            isAssignable(t_annot, t_init) || fail(
                'Type annotation does not match init expression.');

        if (s_init)
            s_init = maybeCopyOrMove(
                maybePRValue(s_init), t_let);

        //
        let out       = solved(node, t_let, [s_annot || s_init, s_init]);
        let id        = node.value || fail();

        if (node.flags & F_MUT)
            _current_fn || fail(
                'Mutable statics are not currently allowed.');

        //
        let overload  = out.flags & F_FIELD
            ? Field  (id, _current_strt || fail(), t_let)
            : Binding(id, node.flags & F_MUT
                ? add_mutref(t_let)
                : add_ref(t_let));

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        if (node.kind == 'call')
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t = evalTypeAnnot(items[0]).type;
                    t || fail();

                    if (node.value == '&')
                        return solved(node, add_ref(t));

                    if (node.value == '&mut')
                        return solved(node, add_mutref(t));

                    if (node.value == '[]')
                        return solved(node, createArray(t));
                }
                else if (items.len == 2)
                {
                    let a = evalTypeAnnot(items[0]).type;
                    let b = evalTypeAnnot(items[1]).type;
                    a && b || fail();

                    if (node.value == 'Map')
                        return solved(node, createMap(a, b));
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == 'type')
                            return solved(node, maybe.type || fail());
                    }
                }

                fail('No type `' + id + '` in scope.');
            }
        }
        else if (node.kind == 'typeparam')
        {
            let id = node.value || fail();
            _typeParams || fail(
                'Unexpected type param: `$' + id + '`.');

            let type = _typeParams && _typeParams[id] || fail(
                'No type param `$' + id + '` in scope.');

            return solved(node, type);
        }

        return fail('TODO');
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, typeParams: &mut Map(string, Type)): bool
    {
        if (node.kind == 'call')
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t   = node.value == '&'    ? tryClear_ref(type)
                            : node.value == '&mut' ? tryClear_mutref(type)
                            : node.value == '[]'   ? tryClear_array(type)
                            : (fail('TODO'), Type);

                    if (!t)
                        return false;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == 'Map')
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == 'type')
                            return isAssignable(maybe.type || fail(), type);
                    }
                }

                fail('No type `' + id + '` in scope.');
            }
        }
        else if (node.kind == 'typeparam')
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            let _param: &mut Type =
                (typeParams[id] ||= Type);

            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }

        return fail('TODO');
    }

    fn evalTypePattern(node: Node, typeParams: Map(string, Type)): bool
    {
        let items = node.items;
        if (node.kind == 'call' && items.len == 2)
        {
            let left  = items[0] || fail();
            let right = items[1] || fail();

            if (node.value == '->')
            {
                if (left.kind  == 'typeparam' &&
                    right.kind == 'typetag')
                {
                    let tag   = right.value || fail();
                    let type  = left.value && typeParams[left.value] || fail(
                        'No type param `$' + left.value + '` in scope.');

                    return type_has(type, tag);
                }
                else
                {
                    ////////////////////////////////
                    let typeParams0 = _typeParams;
                    _typeParams       = typeParams;
                    ////////////////////////////////

                    //               is                //
                    // (actual) left -> right (expect) //
                    let expect = evalTypeAnnot(right).type;
                    let actual = evalTypeAnnot(left ).type;

                    ////////////////////////////////
                    _typeParams = typeParams0;
                    ////////////////////////////////

                    return isAssignable(expect, actual);
                }
            }
            else if (node.value == '&&')
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
            else if (node.value == '||')
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
        }

        return fail('TODO');
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   'call',
            flags:  F_ID,
            value:  id,
            token:  (_here || fail()));
    }

    fn solveCall(node: Node): SolvedNode
    {
        let id          = node.value; id || fail();
        mut args        = solveNodes(node.items);

        // Implicit temporaries, all args are referable.
        for (mut i = 0; i < args.len; i++)
            args[i] = maybePRValue(args[i] || fail());

        //
        mut callTargIdx = scope_match__mutargs(id, args, node.flags);
        mut callTarg    = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == 'p-unshift';

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead('__partial'),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
            {
                args.unshift(argNode);
            }
            else
            {
                args[0] = argNode;
            }
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }

    fn maybePRValue(mut node: SolvedNode): SolvedNode
    {
        if (!(node.type.quals & q_ref))
            node.type = add_prvalue_ref(node.type);

        return node;
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        let items = solveNodes(node.items);

        mut itemType = type
            ? tryClear_array(type)
            : Type;

        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail('Cannot infer empty arraylit.');

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                '[array literal] No common supertype.');
        }

        return solved(node, createArray(itemType), items);
    }


    // This is a weird one,
    //  in case this is the current fn we're solving,
    //   we wont have overload yet, but we do have the node,
    //    otherwise we have the overload and get the node from there.

    fn createLet(id: string, type: Type, flags: i32 = 0): SolvedNode
    {
        return SolvedNode(
            kind:   'let',
            flags:  flags,
            value:  id,
            token:  _here || fail(), :type);
    }

    fn injectImplicitArg__mutfn(
        fnNode: &mut SolvedNode,
        id: string, type: Type): ScopeIdx
    {
        let newArgIdx = fnNode.items.len + FN_RET_BACK;

        // The new argnode.
        let newArgNode = createLet(id, type, F_IMPLICIT);
        fnNode.items.insert(newArgIdx, newArgNode);

        // If we dont have the overload yet,
        //  there's nothing else to do here.

        // TODO argname check should come first -
        //  the one below is too late,
        //   wont catch an argname dupe here.
        if (fnNode.target)
        {
            let o: &mut Overload = GET(fnNode.target);

            // We'll be mutating the overload.
            o.kind == 'fn' || fail();

            o.names.len == o.args.len || fail();
            o.names.find(id) < 0 || fail(
                'Implicit argument name collision.');

            o.args .push(type);
            o.names.push(id);
        }

        // TODO put in the original scope!
        let scope0   =    Scope_push(_scope);
        let overload =    Binding(id, type);
                            Scope_pop(_scope, scope0);
        return overload;
    }

    fn bindImplicitArg(
        mut args: SolvedNode[],
        argIdx: i32, id: string, type: Type)
    {
        TEST_expectImplicits || fail(
            'Attempting to propagate implicit arguments.');

        args.len >= argIdx || fail();

        args[argIdx] = CallerNode(
            createRead(id), :type,
            target: getImplicit(id, type));
    }

    fn getImplicit(id: string, type: Type): ScopeIdx
    {
        mut args: SolvedNode[];
        mut matched = scope_tryMatch__mutargs(
            :id, :args, retType: type);

        if (!matched)
        {
            if (!_current_fn)
                return fail('No implicit `' + id + '` in scope.');

            matched = injectImplicitArg__mutfn(
                _current_fn, id, type);

            matched || fail();
        }

        return matched;
    }


    //

    fn solveIf(node: Node): SolvedNode
    {
        let items   = solveNodes(node.items);
        let cond    = items[0];
        let cons    = items[1];
        let alt     = items[2];

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt ? alt : cons;

        let priType = priExpr.type;
        let secType = secExpr ? secExpr.type : Type;

        let outType: Type = !secType
            ? priType
            : type_tryInter(priType, secType);

        outType || fail('No common supertype.');

        return solved(node, outType || fail(), items);
    }

    fn sumType_logic(items: SolvedNode[]): Type
    {
        // All args refs?
        if (items.len)
        {
            mut sumType: Type = (items[0] || fail()).type;
            for (mut i = 1; i < items.len; i++)
            {
                let type = (items[i] || fail()).type;
                if (type == t_never)
                {
                    i == items.len - 1 || fail(
                        'Dead code following never [A].');

                    continue;
                }

                sumType = type_tryInter(sumType, type);
                if (!sumType)
                    break;
            }

            sumType == t_never && fail(
                'Dead code following never [B].');

            if (sumType && (sumType.quals & q_ref))
                return sumType;
        }

        return t_bool;
    }

    fn solveAnd(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);

        return solved(node, sumType_logic(items), items);
    }

    fn solveOr(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);

        mut t_or = sumType_logic(items);
        if (t_or == t_bool)
        {
            mut change = false;

            // Look for the `(a && b) || c` pattern -
            //  With correct codegen, only `b` and `c` need to intersect,
            //   `a` is simply another condition for using `b`.
            mut alts = items;
            for (mut i = 0; i < alts.len - 1; i++)
            {
                let alt = alts[i] || fail();
                if (alt.kind == 'and')
                {
                    alts[i] = alt.items[alt.items.len - 1];
                    change = true;
                }
            }

            if (change)
                t_or = sumType_logic(alts);
        }

        return solved(node, t_or, items);
    }


    //

    fn solved(
        node: &Node, type: Type, items: SolvedNode[] = [])
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type);
    }

    fn wrap(kind: string, node: SolvedNode, flags: i32): SolvedNode
    {
        return SolvedNode(
            :kind,
            :flags,

            items:  [ node ],
            token:  node.token,
            type:   node.type);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: ScopeIdx, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        // TBD how we make this stuff work in real life.
        if (overload.kind == 'field')
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs_from(headType, type);
        }

        // Tag copies and moves.
        else if (args.len)
        {
            let arg_t = overload.args || fail();
            for (mut i = 0; i < args.len; i++)
                args[i] = maybeCopyOrMove(
                    args[i] || fail(), arg_t[i]);
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(
        node: SolvedNode, slot: Type): SolvedNode
    {
        let q = slot.quals;
        if (q & q_ref)
            return node;

        mut op = 'copy';

        if (!(q & q_copy))
        {
            if (!(q & q_move))
                fail('Non-copy/non-move?');

            op = 'move';
        }

        return wrap(op, node,
            node.type.quals & q_prvalue
                ? F_ELISION
                : 0);
    }


    //

    fn solveNodes(nodes: Node[]): SolvedNode[]
    {
        mut result: SolvedNode[];
        solveNodes(nodes, result);
        return result;
    }

    fn solveNodes(nodes: Node[], result: &mut SolvedNode[]): void
    {
        let here0 = _here;

        mut offset = 0;

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            if (!isUnordered(node.kind))
            {
                _here       = node.token || _here;
                result[i]   = solveNode(node);
                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (mut i = i0; i < nodes.len; i++)
            {
                let node = nodes[i];
                if (!node)
                    continue;

                if (!isUnordered(node.kind))
                {
                    i1 = i;
                    break;
                }

                _here       = node.token || _here;
                result[i]   = unorderedPrep(node);
            }

            // Second pass, do the remaining work.
            for (mut i = i0; i < i1; i++)
            {
                let node = nodes[i];
                if (node)
                {
                    _here       = node.token || _here;
                    result[i]   = unorderedSolve(node, result[i]);
                }
            }

            // Continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++
        }

        offset == 0 || fail();
        result.len == nodes.len + offset || fail();

        _here = here0;
    }


    // So lets go.

    return SolveResult(
        root: solveNode(parse),
        scope: _scope);
}


// Solve & cache the prelude.

fn listGlobals(): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope, 'i32',    t_i32   );
    Scope_Typedef(scope, 'bool',   t_bool  );
    Scope_Typedef(scope, 'void',   t_void  );
    Scope_Typedef(scope, 'string', t_string);
    Scope_Typedef(scope, 'never',  t_never );

    return scope;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Prelude.

let prelude_src = `


// Some lolcode.

fn __native_pure(): never never;


// Arithmetics.

fn +(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn +(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;

fn -(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn -(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;
fn *(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;
fn /(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native_pure;
    // case ($T -> @integral && $b -> @non_zero):          $T __native_pure;
    case ($T -> @integral):          $T __native_pure;

fn ++(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn --(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn +=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;
fn -=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;

fn ==(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn !=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn > (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn < (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn >=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn <=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;


// Bitwise.

fn ~(a: $T)                 case ($T -> @integral):     $T __native_pure;
fn &(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn |(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn ^(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn <<(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;
fn >>(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;

fn &=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn |=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn ^=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;


// Logic.

fn true (): bool __native_pure;
fn false(): bool __native_pure;

fn  !(a: &$T): bool __native_pure;
fn !!(a: &$T): bool __native_pure;


// Assignment.

fn   =(a: &mut $T, b: $T): &mut $T __native_pure;
fn ||=(a: &mut $T, b: $T): &mut $T __native_pure;


// Arrays.

fn len (a: &$T[]):         i32  __native_pure;
fn find(a: &$T[], b: &$T): i32  __native_pure;
fn has (a: &$T[], b: &$T): bool __native_pure;

fn [](a: &$T[], i: i32)
    case ($a -> &mut $T[]): &mut $T __native_pure;
    case ($a -> &    $T[]): &    $T __native_pure;

fn push   (a: &mut $T[], b: $T):              void __native_pure;
fn unshift(a: &mut $T[], b: $T):              void __native_pure;
fn insert (a: &mut $T[], i: i32, b: $T):      void __native_pure;

fn concat (a: &$T[], b: &$T[]):               $T[] __native_pure;
fn slice  (a: &$T[], i0: i32, i1: i32):       $T[] __native_pure;
fn slice  (a: &$T[], i0: i32):                $T[] __native_pure;

fn splice (a: &mut $T[], i: i32, count: i32): void __native_pure;
fn pop    (a: &mut $T[]):                     void __native_pure;

fn clear  (a: &mut $T[]):                     void __native_pure;
fn resize (a: &mut $T[], len: i32):           void __native_pure;
fn shrink (a: &mut $T[], len: i32):           void __native_pure;

fn move   (a: &mut $T[], from: i32, to: i32): void __native_pure;
fn sort   (a: &mut $T[]):                     void __native_pure;


// Strings.

fn len(a: &string):                 i32         __native_pure;
fn [](a: &string, i: i32):          string      __native_pure;
fn +=(a: &mut string, b: &string):  &mut string __native_pure;
fn + (a: &string, b: &string):      string      __native_pure;

fn ==(a: &string, b: &string):      bool        __native_pure;
fn !=(a: &string, b: &string):      bool        __native_pure;
fn  >(a: &string, b: &string):      bool        __native_pure;
fn  <(a: &string, b: &string):      bool        __native_pure;
fn >=(a: &string, b: &string):      bool        __native_pure;
fn <=(a: &string, b: &string):      bool        __native_pure;

fn find(a: &string, b: &string):    i32         __native_pure;
fn has(a: &string, b: &string):     bool        __native_pure;
fn starts(a: &string, with: &string): bool      __native_pure;

fn slice (a: &string, i0: i32, i1: i32): string __native_pure;
fn substr(a: &string, i0: i32, i1: i32): string __native_pure;
fn char  (a: &string, i0: i32): i32 __native_pure;


// Maps.

fn [](a: &Map($K, $V), b: &$K)
    case ($a -> &mut Map($K, $V)): &mut $V __native_pure;
    case ($a -> &    Map($K, $V)): &    $V __native_pure;


// Assertions, bugs & fails.

fn throw(reason: string): never __native_pure;
fn assert()             : never __native_pure;


// Butt plugs.

// TODO we should go for an any $B -> call stringify(b) macro.
fn + (a: &string, b: i32): &string __native_pure;

`;

fn solvePrelude(): Scope
{
    let lexed = lex(prelude_src, '__prelude');
    lexed.errors || !lexed.tokens && throw(
        'Failure to lex prelude.');

    let root = parse(
        '__prelude', lexed.tokens);

    let implicit mut ctx: TEMP_Context;
    let scope = listGlobals();
    let solved = runSolver(root, scope);

    return solved.scope;
}

let PRELUDE: Scope = solvePrelude();

pub fn solve(parse: Node)
{
    return runSolver(parse, PRELUDE);
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Codegen.

let M_STMT            = 1 << 0;
let M_RETBOOL         = 1 << 1;
let M_CONST           = 1 << 2;
let M_RETVAL          = 1 << 3;


//

pub fn cpp_codegen(
    implicit ctx: &TEMP_Context,
    root: &SolvedNode, scope: &Scope): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);
    mut _ffwd: Map(string, string);
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string     = '\n';
    mut _fnN:   i32;
    mut _clsrN: i32;
    mut _faasN: i32;

    fn GET(idx: ScopeIdx): &Overload
    {
        idx.raw > 0 || assert();
        return scope.overloads[idx.raw - 1];
    }

    fn fail(reason = '') throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = '#include ' + lib + '\n';
    }


    //

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        let fwd = typeAnnotBase(type);

        if ((mode & M_RETVAL) && type.canon == 'never')
            return '[[noreturn]] ' + fwd;

        if (!(type.quals & q_prvalue))
        {
            if (type.quals & q_mutref)
                return fwd + '&';
            if (type.quals & q_ref)
                return 'const ' + fwd + '&';
        }

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return 'const ' + fwd;

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (c == 'i32')    return 'int';
        if (c == 'bool')   return 'bool';
        if (c == 'void')   return 'void';
        if (c == 'string') return annotateString();
        if (c == 'never')  return annotateNever();

        let tdef = lookupType(type.canon) || fail('TODO: ' + type.canon);
        let k = tdef.kind;

        if (k == 'struct')
        {
            fn emitStructDecls()
            {
                let def = declareStruct(type, tdef);
                _tdef += def;

                return '\nstruct ' + type.canon + ';';
            }

            _tfwd[type.canon] ||= emitStructDecls();

            return type.canon;
        }

        if (k == 'array')
        {
            let item = typeAnnot(tdef.fields[0].type);

            include('<vector>');
            return 'std::vector<' + item + '>';
        }

        if (k == 'map')
        {
            let k = typeAnnot(tdef.fields[0].type);
            let v = typeAnnot(tdef.fields[1].type);

            include('<unordered_map>');
            return 'std::unordered_map<' + k + ', ' + v + '>';
        }

        return fail('TODO: ' + tdef.kind);
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        mut def = '\nstruct ' + t.canon + '\n{';
        mut indent = '\n    ';

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    struct Data\n    {';
            indent += '    ';
        }

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def += indent + typeAnnot(field.type) + ' ' + ID(field.id) + ';';
        }

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    };';
            def += '\n';
            def += '\n    Data data;';
            def += '\n    bool dtor = false;';
            def += '\n';
            def += '\n    ~' + t.canon + '() noexcept;';
            def += '\n    inline ' + t.canon + '(Data data) noexcept : data(data) {};';
            def += '\n    ' + t.canon + '(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '& operator=(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '(' + t.canon + '&&) noexcept;';
            def += '\n    ' + t.canon + '& operator=(' + t.canon + '&&) noexcept;';
        }

        def += '\n    explicit operator bool() noexcept';
        def += '\n    {';
        def += '\n        return false';

        for (mut i = 0; i < fields.len; i++)
            def += '\n            || '
                + boolWrap(fields[i].type,
                    (s.flags & F_DESTRUCTOR ? 'data.' : '')
                        + ID(fields[i].id));

        def += '\n        ;';
        def += '\n    }';

        return def + '\n};\n';
    }


    //

    fn collectDedupes(
        dedupes: &Map(string, string)): string
    {
        mut out = '';

        mut keys = dedupes.keys();
        keys.sort();

        for (mut i = 0; i < keys.len; i++)
            out += dedupes[keys[i]];

        return out;
    }

    fn cgRoot(root: SolvedNode): string
    {
        let src = cgStatements(root.items);

        mut header = collectDedupes(_libs)
                   + collectDedupes(_tfwd)
                   + collectDedupes(_ffwd)
                   +               (_tdef)
                   +               (_fdef)
                   ;

        return header + src;
    }


    //

    fn ID(id: string): string
    {
        if (id == 'this')     return '_';
        if (id == 'template') return 'tempalt';

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = '';

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src += _indent + line + ';';
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[]): string
    {
        let indent0 = _indent;
        _indent += '    ';

        let src = indent0 + '{' + cgStatements(nodes) + indent0 + '}';

        _indent = indent0;
        return src;
    }

    fn blockWrapOne(node: SolvedNode): string
    {
        return node.kind == 'block'
            ? cgBlock(node)
            : blockWrap([ node ]);
    }

    fn blockWrapOne_unlessSilly(node: SolvedNode): string
    {
        if (node.kind == 'if')
            return cgNode(node, M_STMT);

        return blockWrapOne(node);
    }

    fn cgBlock(block: SolvedNode): string
    {
        return blockWrap(block.items);
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return '(false /*empty parens*/)';

        if (items.len == 1)
            return items[0];

        mut src = '(';
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src += ', ';
            if (i < items.len - 1)
                src += '(void)';

            src += items[i];
        }

        return src + ')';
    }


    // This is kinda weird - it's an auto-refactor:
    //  it converts a fn that contains closures
    //   into a struct, with its args and leading "lets"
    //    converted into fields, and then leading closures
    //     converted into struct members.

    // The tail of the fn remains in an "EVAL" function,
    //  and currently to limit the damage we emit a macro
    //   that remaps the invocation.

    // TODO this can do more -
    //  we could collect most of the top-level stuff on the struct.

    fn try_cgFnAsStruct(fn: SolvedNode): string
    {
        let body = fn.items[fn.items.len + FN_BODY_BACK];
        if (!body || body.kind != 'block')
            return '';

        let items = body.items;

        // We need at least one closure
        //  in the function "header"
        //   for all of this to make sense.
        mut hasClosuresInHeader = false;
        mut end = 0;
        for (mut i = 0; i < items.len; i++)
        {
            end = i;

            let item = items[i];
            if (item.kind == 'fn')
            {
                if (item.flags & F_CLOSURE)
                    hasClosuresInHeader = true;
            }
            else if (item.kind != 'let' && item.kind != 'struct')
            {
                break;
            }
        }

        if (!hasClosuresInHeader)
            return '';

        // Ok - refactor time.
        let evalName = fn.value + '_EVAL';

        let restFn = SolvedNode(

            kind: 'fn', type: t_void,
            flags: fn.flags | F_CLOSURE,
            token: fn.token,
            value: evalName,

            items:
            [
                fn.items[fn.items.len - 2], // retval
                SolvedNode(
                    kind: 'block', type: t_void,
                    token: fn.token,
                    items: items.slice(
                        end, items.len))
            ]);

        let head: SolvedNode[] =
            (fn.items.slice(0, fn.items.len + FN_ARGS_BACK))
                .concat(items.slice(0, end))
                .concat([ restFn ]);

        //////////////////////
        _clsrN == 0 || fail();
        _clsrN--; // -1, so root closures come up at 0.
        //////////////////////

        let structName = 'sf_' + fn.value;
        mut src = '\nstruct ' + structName
                + blockWrap(head) + ';'
                + '\n\n#define ' + fn.value + '(...) ((' + structName + ' { __VA_ARGS__ }).' + evalName + '())\n';

        //////////////////////
        _clsrN++;
        //////////////////////

        return src;
    }


    //

    fn cgFn(fn: SolvedNode): string
    {
        // Template emit.
        if (!fn.items.len)
        {
            mut src = '';

            let template = GET(fn.target).template || fail();
            let specs = template.specializations;

            mut keys = specs.keys();
            keys.sort();

            for (mut i = 0; i < keys.len; i++)
            {
                let key = keys[i];
                let s = specs[key];
                if (s.target)
                    src += cgNode(s);
            }

            return src;
        }

        // Use like-struct output for top-level functions with closures -
        //  We'll try to "close over" a root-level struct.
        if (_faasN == 0 && (fn.flags & F_HAS_CLOSURE))
        {
            /////////
            _faasN++;
            /////////

            let src = try_cgFnAsStruct(fn);

            /////////
            _faasN--;
            /////////

            if (src)
            {
                _fdef += src;
                return '';
            }
        }

        ///////////////////////////
        let f0    = _fnN;
        let c0    = _clsrN;
        let indent0 = _indent;

        _fnN++;
        if (fn.flags & F_CLOSURE) _clsrN++;
        ///////////////////////////

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK] || fail();
        let ret   = items[items.len + FN_RET_BACK ] || fail();
        let annot = typeAnnot(ret.type || fail(), M_RETVAL);

        //
        let closure = !!_clsrN
            && (fn.flags & F_CLOSURE)
            && fn.value != '==';

        // Both closures and try_cgFnAsStruct
        if (!(fn.flags & F_CLOSURE))
            _indent = '\n';

        mut src = closure
                ? 'let auto& ' + fn.value + ' = [&]('
                : annot + ' ' + fn.value + '(';

        if (fn.value == '==')
            src = annot + ' operator' + fn.value + '(';

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src += ', ';

            src += binding(items[i] || fail(), false);
        }

        src += closure
             ? ') -> ' + annot
             : ') noexcept';

        if (!closure && src != 'int main()' && !(fn.flags & F_CLOSURE) && _fdef.has(fn.value || fail()))
            _ffwd[src] = '\n' + src + ';';

        if (body.kind == 'block')
            src += cgBlock(body);
        else
            src += blockWrap([ body ]);

        //////////////
        _fnN    = f0;
        _clsrN  = c0;
        _indent = indent0;
        //////////////

        if (fn.flags & F_DESTRUCTOR)
        {
            let head = items[0] || fail();
            let name = head.type.canon;

            src += '\n\n' + name + '::~' + name + '() noexcept';
            src += '\n{';
            src += '\n    if (!dtor)';
            src += '\n    {';
            src += '\n        dtor = true;';
            src += '\n        free(*this);';
            src += '\n    }';
            src += '\n}';

            include('<cassert>');
            include('<utility>');

            src += '\n\n' + name + '::' + name + '(' + name + '&& src) noexcept';
            src += '\n    : data(std::move(src.data))';
            src += '\n{';
            src += '\n    assert(!src.dtor);';
            src += '\n    dtor = src.dtor;';
            src += '\n    src.dtor = true;';
            src += '\n}';

            include('<cstring>');

            src += '\n\n' + name + '& ' + name + '::operator=(' + name + '&& src) noexcept';
            src += '\n{';
            src += '\n    if (&src != this)';
            src += '\n    {';
            src += '\n        char temp[sizeof(' + name + ')];';
            src += '\n        std::memcpy(temp, this, sizeof(' + name + '));';
            src += '\n        std::memcpy(this, &src, sizeof(' + name + '));';
            src += '\n        std::memcpy(&src, temp, sizeof(' + name + '));';
            src += '\n    }';
            src += '\n';
            src += '\n    return *this;';
            src += '\n}';
        }

        // This covers both closures & try_cgTryFnAsStruct:
        if (fn.flags & F_CLOSURE)
            return src;

        _fdef += '\n' + src + '\n';
        return '';
    }

    fn binding(node: SolvedNode, doInit: bool): string
    {
        let id    = node.value || fail();
        let annot = typeAnnot(node.type, (node.flags & F_MUT) == 0 ? M_CONST : 0);
        let head  = (annot || fail()) + ' ' + ID(id);
        let init  = node.items[LET_INIT];

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
            return head + ' = ' + cgNode(init);

        return head + ' {}';
    }

    fn cgLet(node: SolvedNode): string
    {
        mut src = binding(node, true);
        if (_fnN || _faasN)
            return src;

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.split('([&](').join('([](');

        // cpp17 inline const syntax sugars.
        if (src.starts(with: 'const '))
            src = src.slice(6);

        src = 'inline const ' + src;

        //
        return '';
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type == t_never)
                return src;

            return 'return ' + src;
        }

        return 'return';
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return 'goto L_' + node.value + '_' + node.kind[0];

        return node.kind;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        include('<string>');

        // TODO!
        // return 'std::string(' + JSON.stringify(node.value) + ')';
        return 'std::string("' + node.value + '")';
    }

    fn cgArrayLiteral(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        let annot = typeAnnot(node.type);

        if (!items.len)
            return annot + '{}';

        return annot + ' { ' + items.join(', ') + ' }';
    }

    fn cgDefaultInit(node: SolvedNode): string
    {
        return cgArrayLiteral(node);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode): string
    {
        let target = GET(node.target) || fail();
        let items  = cgNodes(node.items);

        if (target.kind == 'defctor')
        {
            let head = (target.type || fail()).canon;
            let type = lookupType(head) || fail();

            //
            mut open = ' { ';
            mut close = ' }';
            if (type.flags & F_DESTRUCTOR)
            {
                open = ' { ' + head + '::Data { ';
                close = ' }}';
            }

            return head + open + items.join(', ') + close;
        }

        let id = target.name || fail();

        if (hasNonIdentifierChars(id))
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                if (id == '!')
                    return '!' + boolWrap(head.type, items[0]);

                return node.flags & F_POSTFIX
                     ? items[0] + id
                     : id + items[0];
            }

            if (items.len == 2)
            {
                if (id == '[]')
                {
                    if (head.type.canon == 'string')
                        return 'std::string(1, ' + items[0] + '.at(' + items[1] + '))';

                    // One does not simply index into a map.
                    if (type_isMap(head.type))
                    {
                        if (!(head.type.quals & q_mutref))
                            return cgMapConstGet(items[0], items[1]);

                        return items[0] + '.at(' + items[1] + ')';
                    }

                    return items[0] + '.at(' + items[1] + ')';
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == '=')
                {
                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return '(' + cgNode(head.items[0] || fail()) +
                                '[' + cgNode(head.items[1] || fail()) + '] = ' +
                                    items[1] + ')';
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == '||=')
                {
                    mut left  = items[0];
                    mut right = items[1];

                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            left = cgNode(head.items[0] || fail()) +
                                '[' + cgNode(head.items[1] || fail()) + ']';
                    }

                    let annot = typeAnnot(head.type);

                    return '([&](' + annot + ' _) -> ' + annot + ' { if (!' +
                        boolWrap(head.type, '_') + ') _ = ' +
                            right + '; return _; } (' + left + '))';
                }

                return '(' + items[0] + ' ' + id + ' ' + items[1] + ')';
            }
        }

        if (target.kind == 'var')
            return ID(id);

        if (target.kind == 'field')
        {
            mut sep = '.';
            let parent = lookupType(
                (node.items[0] || fail())
                    .type.canon) || fail();

            if (parent.flags & F_DESTRUCTOR)
                sep = '.data.';

            return items[0] + sep + ID(id);
        }

        if (id == 'len' && items.len == 1)
            return 'int(' + items[0] + '.size())';

        if (id == 'push' && items.len == 2)
            return items[0] + '.push_back(' + items[1] + ')';

        if (id == 'pop' && items.len == 1)
            return items[0] + '.pop_back()';

        if (id == 'unshift' && items.len == 2)
            return '([&](auto& _) { _.insert(_.begin(), ' + items[1] + '); } (' + items[0] + '))';

        if (id == 'insert' && items.len == 3)
            return '([&](auto& _) { _.insert(_.begin() + ' + items[1] + ', ' + items[2] + '); } (' + items[0] + '))';

        if (id == 'splice' && items.len == 3)
            return '([&](auto& _) { let auto& _0 = _.begin() + ' + items[1] + '; _.erase(_0, _0 + ' + items[2] + '); } (' + items[0] + '))';

        if (id == 'grow' && items.len == 2)
            return items[0] + '.resize(' + items[1] + ')';

        if (id == 'shrink' && items.len == 2)
            return items[0] + '.resize(' + items[1] + ')';

        if (id == 'resize' && items.len == 2)
            return items[0] + '.resize(' + items[1] + ')';

        if (id == 'clear' && items.len == 1)
            return items[0] + '.clear()';

        if (id == 'find' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return 'int(' + items[0] + '.find(' + items[1] + '))';

            include('<algorithm>');
            return '([&](let auto& _) { let auto& _0 = _.begin(); let auto& _N = _.end(); let auto& _1 = std::find(_0, _N, ' + items[1] + '); return _1 != _N ? int(_1 - _0) : -1; } (' + items[0] + '))';
        }

        if (id == 'starts' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return '(' + items[0] + '.rfind(' + items[1] + ', 0) == 0)';
        }

        if (id == 'has' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return '(int(' + items[0] + '.find(' + items[1] + ')) >= 0)';

            if (type_isMap(head.type))
                return '(' + items[0] + '.count(' + items[1] + ') != 0)';

            include('<algorithm>');
            return '([&](let auto& _) { let auto& _0 = _.begin(); let auto& _N = _.end(); let auto& _1 = std::find(_0, _N, ' + items[1] + '); return _1 != _N; } (' + items[0] + '))';
        }

        if (id == 'slice' && items.len == 3)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return '([&]() { size_t _0 = ' + items[1] + '; return ' + items[0] + '.substr(_0, ' + items[2] + ' - _0); } ())';

            return '([&](let auto& _) { let auto& _0 = _.begin() + ' + items[1] +'; let auto& _1 = _.begin() + ' + items[2] + '; return ' + typeAnnot(node.type) + '(_0, _1); } (' + items[0] + '))';
        }

        if (id == 'slice' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return items[0] + '.substr(' + items[1] + ')';

            return '([&](let auto& _) { return ' + typeAnnot(node.type) + '(_.begin() + ' + items[1] + ', _.end()); } (' + items[0] + '))';
        }

        if (id == 'sort' && items.len == 1)
        {
            include('<algorithm>');
            return '([&](auto& _) { std::sort(_.begin(), _.end()); } (' + items[0] + '))';
        }

        if (id == 'substr' && items.len == 3)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return items[0] + '.substr(' + items[1] + ', ' + items[2] + ')';
        }

        if (id == 'char' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return 'int(' + items[0] + '[' + items[1] + '])';
        }

        if ((id == 'true' || id == 'false') && !items.len)
            return id;

        if (id == 'throw' && items.len == 1)
            return cgThrow(id, items[0]);

        if (id == 'assert' && items.len == 0)
            return cgThrow(id, '"Assertion failed."');

        if (id == 'move' && items.len == 3)
            return '([&]() { auto* _ = ' + items[0] + '.data(); ' + cgSlide('_ + ' + items[2], '_ + ' + items[1], 'sizeof(*_)') + '; } ())';

        if (id == 'concat' && items.len == 2)
            return cgConcat(items);

        if (id == 'split' && items.len == 2)
            return cgSplit(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'keys' && items.len == 1)
            return cgKeys(items);

        return ID(id) + '(' + items.join(', ') + ')';
    }

    fn cgSlide(destExpr: string, srcExpr: string, numBytesExpr: string): string
    {
        let SLIDE = '::slide';
        if (!_tfwd.has(SLIDE))
        {
            include('<cstring>');

            _tfwd[SLIDE] =
////////////////////////////////////
`
template <size_t N>
inline void fu_MEMSLIDE(void* dest, void* source)
{
    char swap_buffer[N];

    std::memcpy(
        swap_buffer, source, N);

    if (source < dest)
        std::memmove(
            source, (char*)source + N,
            (char*)dest - (char*)source);
    else
        std::memmove(
            (char*)dest + N, dest,
            (char*)source - (char*)dest);

    std::memcpy(
        dest, swap_buffer, N);
}
`
////////////////////////////////////
            ;
        }

        return 'fu_MEMSLIDE<' + numBytesExpr + '>(' + destExpr + ', ' + srcExpr + ')';
    }

    fn annotateString(): string
    {
        let STRING = '::string';
        if (!_ffwd.has(STRING))
        {
            include('<string>');

            _ffwd[STRING] =
////////////////////////////////////
`
inline std::string operator+(let std::string& a, long long b)
{
    return a + std::to_string(b);
}
`
////////////////////////////////////
            ;
        }

        return 'std::string';
    }

    fn annotateNever(): string
    {
        let NEVER = '::NEVER';
        if (!_tfwd.has(NEVER))
        {
            include('<stdexcept>');

            _tfwd[NEVER] =
////////////////////////////////////
`
struct fu_NEVER
{
    fu_NEVER(let fu_NEVER&) = delete;
    void operator=(let fu_NEVER&) = delete;

    template<typename T>
    [[noreturn]] operator T() const
    {
        throw std::runtime_error("fu_NEVER cast");
    }
};
`
////////////////////////////////////
            ;
        }

        return 'fu_NEVER';
    }

    fn cgThrow(kind: string, item: string): string
    {
        let THROW = '::THROW';
        if (!_ffwd.has(THROW))
        {
            annotateNever();
            include('<stdexcept>');

            _ffwd[THROW] =
////////////////////////////////////
`
template <typename T>
[[noreturn]] fu_NEVER fu_THROW(let T& what)
{
    throw std::runtime_error(what);
}
`
////////////////////////////////////
            ;
        }

        if (kind == 'assert')
        {
            // TODO
        }

        return 'fu_THROW(' + item + ')';
    }

    fn cgConcat(items: string[]): string
    {
        let CONCAT = '::CONCAT';
        if (!_ffwd.has(CONCAT))
        {
            include('<vector>');

            _ffwd[CONCAT] =
////////////////////////////////////
`
template <typename T>
std::vector<T> fu_CONCAT(
    let std::vector<T>& a,
    let std::vector<T>& b)
{
    std::vector<T> result;
    result.reserve(a.size() + b.size());

    for (auto& i : a) result.push_back(i);
    for (auto& i : b) result.push_back(i);

    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_CONCAT(' + items.join(', ') + ')';
    }

    fn cgJoin(items: string[]): string
    {
        let JOIN = '::JOIN';
        if (!_ffwd.has(JOIN))
        {
            include('<string>');
            include('<vector>');

            _ffwd[JOIN] =
////////////////////////////////////
`
inline std::string fu_JOIN(
    const std::vector<std::string>& vec,
    const std::string& sep)
{
    size_t len = 0;
    for (size_t i = 0; i < vec.size(); i++)
    {
        if (i)
            len += sep.size();

        len += vec[i].size();
    }

    std::string result;
    result.reserve(len);
    for (size_t i = 0; i < vec.size(); i++)
    {
        if (i)
            result += sep;

        result += vec[i];
    }

    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_JOIN(' + items.join(', ') + ')';
    }

    fn cgSplit(items: string[]): string
    {
        let SPLIT = '::SPLIT';
        if (!_ffwd.has(SPLIT))
        {
            include('<string>');
            include('<vector>');

            _ffwd[SPLIT] =
////////////////////////////////////
`
inline std::vector<std::string> fu_SPLIT(
    std::string s,
    const std::string& sep)
{
    std::vector<std::string> result;

    size_t next;
    while (int(next = s.find(sep)) >= 0)
    {
        result.push_back(s.substr(0, next));
        s = s.substr(next + sep.size());
    }

    result.push_back(s);
    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_SPLIT(' + items.join(', ') + ')';
    }

    fn cgKeys(items: string[]): string
    {
        let KEYS = '::KEYS';
        if (!_ffwd.has(KEYS))
        {
            include('<unordered_map>');
            include('<vector>');

            _ffwd[KEYS] =
////////////////////////////////////
`
template <typename K, typename V>
std::vector<K> fu_KEYS(
    const std::unordered_map<K, V>& map)
{
    std::vector<K> keys;
    keys.reserve(map.size());

    for (auto& kv : map)
        keys.push_back(kv.first);

    return keys;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_KEYS(' + items.join(', ') + ')';
    }

    fn cgMapConstGet(map: string, key: string): string
    {
        let MAP_CONST_GET = '::MAP_CONST_GET';
        if (!_ffwd.has(MAP_CONST_GET))
        {
            include('<unordered_map>');

            _ffwd[MAP_CONST_GET] =
////////////////////////////////////
`
template <typename K, typename V>
let V& fu_MAP_CONST_GET(
    let std::unordered_map<K, V>& map,
    let K& key)
{
    let auto& it = map.find(key);
    if (it == map.end() )
    {
        static let V def {};
        return def;
    }

    return it->second;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_MAP_CONST_GET(' + map + ', ' + key + ')';
    }

    fn cgLiteral(node: SolvedNode): string
    {
        return node.value || fail();
    }

    fn cgEmpty(): string
    {
        return '';
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        let cond = !n0 ? '' : boolWrap(n0.type, cgNode(n0, M_RETBOOL));
        let cons = !n1 ? '' : (stmt ? blockWrapOne(n1) : cgNode(n1));
        let alt  = !n2 ? '' : (stmt ? blockWrapOne_unlessSilly(n2) : cgNode(n2));

        if (stmt)
            return 'if (' + cond + ') ' + cons + (alt ? _indent + 'else ' + alt : '');

        if (cons && alt)
            return '(' + cond + ' ? ' + cons + ' : ' + alt + ')';

        if (cons)
            return '(' + cond + ' && ' + cons + ')';

        if (alt)
            return '(' + cond + ' || ' + alt + ')';

        return fail('TODO');
    }

    fn boolWrap(type: Type, src: string): string
    {
        if (type_isArray(type) || type_isString(type) || type_isMap(type))
            return src + '.size()';

        return src;
    }


    //

    fn isRefLogical(type: Type): bool
    {
        return (type.quals & (q_ref | q_prvalue)) == q_ref;
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (isRefLogical(type))
        {
            let annot = typeAnnot(type);

            mut src = '([&]() -> ' + annot + ' {';

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                src += ' { ' + annot + ' _ = ' + cgNode(item) + '; if (!' + boolWrap(item.type, '_') + ') return _; }';
            }

            let tail = items[items.len - 1] || fail();
            if (!(tail.type == t_never))
                src += ' return';

            src += ' ' + cgNode(tail) + '; }())';
            return src;
        }

        mut src = '(';
        let items = cgNodes(node.items);
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            let type = (node.items[i] || fail())  .type;

            if (i)
                src += ' && ';

            src += boolWrap(type, item);
        }

        return src + ')';
    }

    fn cgOr(node: SolvedNode): string
    {
        let type = node.type;
        if (isRefLogical(type))
        {
            let annot = typeAnnot(type);

            mut src = '([&]() -> ' + annot + ' {';

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == 'and')
                {
                    let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src += ' if (';
                    for (mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src += ' && ';

                        let item = items[i] || fail();
                        src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                    }

                    src += ')';
                }

                src += ' { ' + annot + ' _ = ' + cgNode(tail) + '; if (' + boolWrap(tail.type, '_') + ') return _; }';
            }

            let tail = items[items.len - 1] || fail();
            if (!(tail.type == t_never))
                src += ' return';

            src += ' ' + cgNode(tail) + '; }())';
            return src;
        }

        mut src = '(';
        let items = cgNodes(node.items);
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            let type = (node.items[i] || fail())  .type;

            if (i)
                src += ' || ';

            src += boolWrap(type, item);
        }

        return src + ')';
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == '}' || fail();
        return src.slice(0, src.len - 1) + postfix + '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = !n_init ? '' : cgNode(n_init);
        let cond = !n_cond ? '' : boolWrap(n_cond.type, cgNode(n_cond, M_RETBOOL));
        let post = !n_post ? '' : cgNode(n_post);
        mut body = !n_body ? '' : blockWrapOne(n_body);
        let pcnd = !n_pcnd ? '' : boolWrap(n_pcnd.type, cgNode(n_pcnd, M_RETBOOL));
        mut breakLabel = '';

        if (body && node.value)
        {
            let brk = 'L_' + node.value + '_b';
            let cnt = 'L_' + node.value + '_c';

            if (body.has(cnt))
                body = '{' + postfixBlock(body, _indent +     '    }' + cnt + ':;');
            if (body.has(brk))
                breakLabel = _indent + '    ' + brk + ':;';
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail('TODO extended loop.');

            return 'do' + body + _indent + 'while (' + pcnd + ')' + breakLabel;
        }

        if (init || post || !cond)
            return 'for (' + init + '; ' + cond + '; ' + post + ')' + body + breakLabel;

        return 'while (' + cond + ')' + body + breakLabel;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == 'root')       return cgRoot(node);
        if (k == 'block')      return cgBlock(node);
        if (k == 'fn')         return cgFn(node);
        if (k == 'return')     return cgReturn(node);
        if (k == 'break')      return cgJump(node);
        if (k == 'continue')   return cgJump(node);
        if (k == 'call')       return cgCall(node);
        if (k == 'let')        return cgLet(node);
        if (k == 'if')         return cgIf(node, mode);
        if (k == 'or')         return cgOr(node);
        if (k == 'and')        return cgAnd(node);
        if (k == 'loop')       return cgLoop(node);
        if (k == 'int')        return cgLiteral(node);
        if (k == 'str')        return cgStringLiteral(node);
        if (k == 'arrlit')     return cgArrayLiteral(node);
        if (k == 'definit')    return cgDefaultInit(node);
        if (k == 'empty')      return cgEmpty();

        if (k == 'comma')      return cgParens(node);
        if (k == 'parens')     return cgParens(node);
        if (k == 'label')      return cgParens(node);
        if (k == 'struct')     return cgEmpty();

        if (k == 'copy')       return cgCopyMove(node);
        if (k == 'move')       return cgCopyMove(node);

        return fail('TODO: ' + k);
    }

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == 'move' && !(node.flags & F_ELISION))
        {
            include('<utility>');
            return 'std::move(' + a + ')';
        }

        return a;
    }

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        if (nodes)
        {
            for (mut i = 0; i < nodes.len; i++)
            {
                let node  = nodes[i];
                let src   = node ? cgNode(node, mode) : '';

                result.push(src);
            }
        }

        return result;
    }


    //

    root.kind == 'root' || fail();

    let src = cgNode(root);
    return src;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     The whole thing in one go.

fn compile(
    implicit ctx: &mut TEMP_Context,
    fname: string, src: string): string
{
    let res_lex = lex(
        :fname, :src);

    let res_parse = parse(
        fname, res_lex.tokens);

    let res_solve = solve(
        res_parse);

    let cpp = cpp_codegen(
        res_solve.root, res_solve.scope);

    return cpp;
}

fn compile_testcase(mut src: string): string
{
    let fname = 'testcase';

    //
    if (!src.has('fn ZERO()'))
        src = '\n\nfn ZERO(): i32 {\n' + src + '\n}\n';

    src += '\nfn main(): i32 ZERO();\n\n';

    //
    let implicit mut ctx: TEMP_Context;

    return compile(:fname, :src, :ctx);
}





// A very quick test.

let TEST_SRC = `

    fn test(one: i32)
    {
        let zero = one - 1;
        let two  = one * 2;

        fn inner(i: i32): i32
            i > zero ? outer(i - one) : zero;

        fn outer(i: i32): i32
            two * inner(i);

        return outer(one) + (two - one) * 17;
    }

    fn ZERO(): i32
    {
        return test(1) - 17;
    }

`;

fn ZERO(): i32
{
    let cpp = compile_testcase(TEST_SRC);

    return cpp.find('main()') ? 0 : 101;
}
