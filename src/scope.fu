#import "lexer";
#import "parser";
#import "types";
#import "lifetimes";
#import "stat";


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct);        // canon  -> type info
    specs:      Map(string, SolvedNode);    // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    lex:        ModuleStat;
    parse:      ModuleStat;
    solve:      ModuleStat;
    codegen:    ModuleStat;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in:         ModuleInputs;
    out:        ModuleOutputs;
    stats:      ModuleStats;
};

pub fn MODID(implicit module: Module): i32
    module.modid;


// The temp context -
//  TBD what this will look like in the end -
//   we'll likely need a typespace per module,
//    so everyone can read from immut shared concurrently,
//     and write into their own without having to sync.

pub struct Context
{
    modules: Module[];
    files: Map(string, string);
};

pub fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

pub fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

pub fn getFile(
    implicit ctx: &mut Context,
    path: string)
{
    return ctx.files[path] ||= file_read(path);
}

pub fn getModule(
    implicit ctx: &mut Context,
    fname: string)
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    mut module = Module(modid: i);
        module.fname = fname;

    ctx.modules.push(module);
    return ctx.modules[i];
}

pub fn setModule(
    implicit ctx: &mut Context,
    module: Module)
{
    let current: &mut Module = ctx.modules[module.modid];
        current.fname == module.fname || assert();
        current = module;
}

pub fn lookupStruct(
    implicit module: Module,
    implicit ctx: Context,
    type: Type)
{
    if (type.modid == module.modid)
        return module.out.types[type.canon]
            || assert();

    return ctx.modules[type.modid].out.types[type.canon]
        || assert();
}

pub fn lookupStruct_mut(
    implicit module: &mut Module,
    canon: string)
{
    return module.out.types[canon] || assert();
}


//

pub fn isStruct(type: Type)
{
    return type.canon[0] == '$';
}

pub fn initStruct(
    implicit module: &mut Module,
    id: string, flags: i32)
{
    let canon = "$" + module.modid + id;

    let def = Struct(
        :id || throw("TODO anonymous structs?"),
        :flags);

    // REGISTER STRUCT ///////////
    module.out.types[canon] = def;
    //////////////////////////////

    return Type(ValueType(:canon, copyOrMove(flags, def.fields), MODID));
}

pub fn finalizeStruct(
    canon: string, fields: StructField[]): i32
{
    mut quals: i32 = 0;

    let def: &mut Struct = lookupStruct_mut(canon);
    def.fields = fields || throw("TODO empty structs?");

    if (!fields.someFieldNonTrivial)
        quals |= q_trivial;

    return quals;
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[]): i32
{
    if (flags & F_DESTRUCTOR || someFieldNonCopy(fields))
        return 0;

    return q_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_copy)
            return true;

    return false;
}

fn someFieldNonTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_trivial)
            return true;

    return false;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub struct Target { modid: i32; index: i32; }

pub struct SolvedNode
{
    kind:   string;
    flags:  i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value:  string;
    items:  SolvedNode[];
    token:  TokenIdx;

    type:   Type;
    target: Target;
};

pub struct Template
{
    node: Node;
};

pub struct Partial
{
    via:    Target;
    target: Target;
};

pub struct Overload
{
    kind: string;
    name: string;
    type: Type;

    // Arity.
    min: i32;
    max: i32;

    // TODO pack in single array.
    args: Type[];
    names: string[];
    defaults: SolvedNode[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial: Partial;
    template: Template;
    constant: SolvedNode;
};

pub fn isTemplate(o: Overload)
    o.kind == "template";

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
};


////////////////////////////////

pub fn Scope_lookup(scope: Scope, id: string): Target[]
{
    id || assert();
    mut results: Target[] = [];

    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(item.target);
    }

    return results;
}

pub fn search(
    scope: Scope, id: string,
    scope_iterator: &mut i32): Target
{
    let items = scope.items;

    if (!scope_iterator)
        scope_iterator = items.len;

    while (scope_iterator --> 0)
    {
        let item = items[scope_iterator];
        if (item.id == id)
            return item.target;
    }

    return Target;
}


////////////////////////////////

pub fn Scope_push(scope: &mut Scope): i32
{
    return scope.items.len;
}

pub fn Scope_pop(scope: &mut Scope, memo: i32): void
{
    scope.items.shrink(memo);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,

    min: i32                = 0,
    max: i32                = 0,
    arg_n: string[]         = [],
    arg_t: Type[]           = [],
    arg_d: SolvedNode[]     = [],
    template: Template      = [],
    partial: Partial        = [],
    constant: SolvedNode    = []): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        :kind,
        name: id, :type,
        :min, :max, args: arg_t,
        names: arg_n, defaults: arg_d,
        :partial, :template, :constant);

    scope.items.push(
        ScopeItem( :id, :target ));

    scope.overloads.push(item);

    return target;
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type)
{
    return Scope_add(scope, "type", id, type);
}


//

pub fn Lifetime_fromCallArgs(
    lifetime: Lifetime, args: SolvedNode[]): Lifetime
{
    mut result: Lifetime;

    for (mut i = 0; i < lifetime.regions.len; i++)
    {
        let r = lifetime.regions[i];

        // Use verbatim unless an argument.
        let argIdx = Region_toArgIndex(r);
        if (argIdx < 0)
        {
            result = type_inter(result, r);
            continue;
        }

        // Else replace with actual from callsite,
        //  incrementing the relax depth as much as possible.

        // TODO FIX we can catch dangling references
        //  to temporaries right here.

        let arg     = args[argIdx];
        let actual  = Lifetime_relaxCallArg(arg.type.lifetime, r.relax);
            result  = type_inter(result, actual);
    }

    return result;
}


//

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;
};


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
