#import 'lexer';
#import 'parser';
#import 'types';


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct);        // canon  -> type info
    specs:      Map(string, SolvedNode);    // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    s_lex:      f64;
    s_parse:    f64;
    s_solve:    f64;
    s_cpp:      f64;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in:         ModuleInputs;
    out:        ModuleOutputs;
    stats:      ModuleStats;
};

pub fn MODID(implicit module: Module): i32
    module.modid;


// The temp context -
//  TBD what this will look like in the end -
//   we'll likely need a typespace per module,
//    so everyone can read from immut shared concurrently,
//     and write into their own without having to sync.

pub struct TEMP_Context
{
    modules: Module[];
    files: Map(string, string);
};

pub fn _token(implicit ctx: TEMP_Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

pub fn _fname(implicit ctx: TEMP_Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

pub fn getFile(
    implicit ctx: &mut TEMP_Context,
    path: string)
{
    return ctx.files[path] ||= file_read(path);
}

pub fn getModule(
    implicit ctx: &mut TEMP_Context,
    fname: string): &mut Module
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    mut module = Module(modid: i);
        module.fname = fname;

    ctx.modules.push(module);
    return ctx.modules[i];
}

pub fn setModule(
    implicit ctx: &mut TEMP_Context,
    module: Module)
{
    let current: &mut Module = ctx.modules[module.modid];
        current.fname == module.fname || assert();
        current = module;
}

fn registerType(
    implicit module: &mut Module,
    canon: string, def: Struct): void
{
    module.out.types[canon] = def;
}

pub fn lookupType(
    implicit module: &Module,
    implicit ctx: &TEMP_Context,
    type: Type): &Struct
{
    if (type.modid == module.modid)
        return module.out.types[type.canon]
            || assert();

    return ctx.modules[type.modid].out.types[type.canon]
        || assert();
}

pub fn lookupType_mut(
    implicit module: &mut Module,
    canon: string): &mut Struct
{
    return module.out.types[canon] || assert();
}


//

pub fn initStruct(id: string, flags: i32)
{
    let canon = 's_' + id;
    let def = Struct(
        kind:   'struct',
        id:     id      || throw('TODO anonymous structs?'),
        flags:  flags|0,
    );

    registerType(canon, def);

    return Type(canon, copyOrMove(flags, def.fields), MODID);
}

pub fn finalizeStruct(id: string, fields: StructField[])
{
    let canon = 's_' + id;
    let def: &mut Struct = lookupType_mut(canon);

    def.fields = fields || throw('TODO empty structs?');
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[]): i32
{
    if (flags & F_DESTRUCTOR || someFieldNonCopy(fields))
        return 0;

    return q_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_copy)
            return true;

    return false;
}

fn someFieldNotTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_trivial)
            return true;

    return false;
}


//

pub fn createArray(item: Type): Type
{
    let flags = 0;
    let fields: StructField[] =
    [
        StructField(
            id:  'Item',
            type: item),
    ];

    let canon = 'Array(' + serializeType(item) + ')';

    registerType(canon, Struct(
        kind:   'array',
        id:     canon,
        :fields,
        :flags));

    return Type(canon, copyOrMove(flags, fields), MODID,
        :item.lifetime);
}

pub fn type_isString(type: Type): bool
{
    return type.canon == 'string';
}

pub fn type_isArray(type: Type): bool
{
    return type.canon.starts(with: 'Array(');
}

pub fn tryClear_array(type: Type): Type
{
    if (!type_isArray(type))
        return Type();

    let def = lookupType(type);

    //
    mut t = def.kind == 'array' && def.fields[0].type || assert();
    t.lifetime = type.lifetime;
    return t;
}


//

pub fn type_isMap(type: Type): bool
{
    return type.canon.starts(with: 'Map(');
}

pub fn createMap(key: Type, value: Type): Type
{
    let flags  = 0;
    let fields =
    [
        StructField(id:  'Key',   type: key  ),
        StructField(id:  'Value', type: value),
    ];

    let canon = 'Map(' + serializeType(key) + ',' + serializeType(value) + ')';

    registerType(canon, Struct(
        kind:   'map',
        id:     canon,
        :fields,
        :flags,
    ));

    return Type(canon, copyOrMove(flags, fields), MODID,
        lifetime: type_inter( key.lifetime,
                            value.lifetime ));
}

pub struct MapFields
{
    key:   Type;
    value: Type;
}

pub fn tryClear_map(type: Type): MapFields
{
    if (!type_isMap(type))
        return MapFields();

    let def = lookupType(type);
    def.kind == 'map' || assert();

    //
    mut mf = MapFields(
        key:   def.fields[0].type || assert(),
        value: def.fields[1].type || assert());

    mf.key.lifetime     = type.lifetime;
    mf.value.lifetime   = type.lifetime;

    return mf;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub struct Target { modid: i32; index: i32; }

pub struct SolvedNode
{
    kind:   string;
    flags:  i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value:  string;
    items:  SolvedNode[];
    token:  TokenIdx;

    type:   Type;
    target: Target;
};

pub struct Template
{
    node: Node;
};

pub struct Partial
{
    via:    Target;
    target: Target;
};

pub struct Overload
{
    kind: string;
    name: string;
    type: Type;

    // Arity.
    min: i32;
    max: i32;

    // TODO pack in single array.
    args: Type[];
    names: string[];
    defaults: SolvedNode[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial: Partial;
    template: Template;
    constant: SolvedNode;
};

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
};


////////////////////////////////

pub fn Scope_lookup(scope: Scope, id: string): Target[]
{
    mut results: Target[] = [];

    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(item.target);
    }

    return results;
}

pub fn Scope_push(scope: &mut Scope): i32
{
    return scope.items.len;
}

pub fn Scope_pop(scope: &mut Scope, memo: i32): void
{
    scope.items.shrink(memo);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,

    min: i32                = 0,
    max: i32                = 0,
    arg_n: string[]         = [],
    arg_t: Type[]           = [],
    arg_d: SolvedNode[]     = [],
    template: Template      = [],
    partial: Partial        = [],
    constant: SolvedNode    = []): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        :kind,
        name: id, :type,
        :min, :max, args: arg_t,
        names: arg_n, defaults: arg_d,
        :partial, :template, :constant);

    scope.items.push(
        ScopeItem( :id, :target ));

    scope.overloads.push(item);

    return target;
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type)
{
    return Scope_add(scope, 'type', id, type);
}


//

pub fn Lifetime_invalid(): Lifetime
    Lifetime( raw: 0x7fffffff );

pub fn Lifetime_static(): Lifetime
    Lifetime( raw: 1 );

pub fn Lifetime_fromArgIndex(argIdx: i32): Lifetime
    Lifetime( raw: -1 - argIdx );

pub fn Lifetime_fromCallArgs(
    lifetime: Lifetime, args: SolvedNode[]): Lifetime
{
    if (lifetime.raw >= 0)
        return lifetime;

    let argIdx  = -1 - lifetime.raw;
    let arg     = args[argIdx];

    return arg.type.lifetime;
}


//

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;
};
