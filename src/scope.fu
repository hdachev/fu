import flags;
import types;
import structs;
import helpers;
import module;


//

enum SolverPass
{
    Solving = 0
    RelaxMut
    BorrowCheck
    ArgumentsAtRisk
    MaybeCopyOrMove
    RelaxCopyResize
};

struct ScopeMemo {
    items_len:      i32;
    implicits_len:  i32;
    imports_len:    i32;
    privates_len:   i32;
    usings_len:     i32;
    converts_len:   i32;
    helpers_len:    i32;
};

struct ScopeSkip
{
    start:          i32;
    end:            i32;
};

struct ScopeSkipMemos
{
    items:          ScopeSkip[];
    implicits:      ScopeSkip[];
    imports:        ScopeSkip[];
    privates:       ScopeSkip[];
    usings:         ScopeSkip[];
    converts:       ScopeSkip[];
    helpers:        ScopeSkip[];
};


//

fn target(si: ScopeItem)
    Target(:si.modid, index: (si.packed & 0x3fffffff).i32);

fn ScopeItem_shadows(si: ScopeItem)
    !!(si.packed & (0x1 << 31));

fn ScopeItem_canSkipRest(si: ScopeItem)
    !!(si.packed & (0x1 << 30));

fn ScopeItem_canSkipRest_set(ref si: ScopeItem)
    si.packed |= (0x1 << 30);

fn ScopeItem(id: string, target: Target, shadows: bool)
    ScopeItem(:id, :target.modid,
        packed: target.index.u32 & 0x3fffffff | (shadows && (0x1 << 31)));



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

fn MODID(implicit module: Module): i32
    module.modid;

fn initStruct(implicit module: &mut Module,
    ::kind!, baseprim!: string,
    name: string, asserts: DeclAsserts,
    flat_cnt!: i32)
{
    name[0].u8 - '0'.u8 > 9.u8 || throw (
        "Bad struct name, leading digit: `" ~ name ~ "`.");

    // Alloc a slot.
    let index = module.out.types.len;
    module.out.types ~= Struct(:kind, :name, base: baseprim, :flat_cnt);

    //
    mut canon = createStructCanon(
        :kind, :baseprim, :module.modid, :index, :name);

    // Assume everything, we resolve disappointment.
    let specualtive_quals = !(asserts & A_NOCOPY) && q_rx_copy;


    return Type(ValueType(:canon, quals: specualtive_quals));
}

fn despeculateStruct(mut type: Type)
{
    type.quals &= ~q_rx_copy;
    return type;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

fn Scope_exports(scope: Scope, modid!: i32,
    field_items: ScopeItem[],
    pub_imports: i32[])
{
    mut items:          ScopeItem[] = field_items;
    mut prv_items:      ScopeItem[];

    mut converts:       Target[];
    mut prv_converts:   Target[];

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            (overload.flags & F_PUB ? items : prv_items) ~= item;
        }
    }

    for (mut i = 0; i < scope.converts.len; i++)
    {
        let item = scope.converts[i];
        if (item.modid == modid)
        {
            let overload = scope.overloads[item.index - 1];
            (overload.flags & F_PUB ? converts : prv_converts) ~= item;
        }
    }

    let pub_items   = items.len;
    items          ~= prv_items;

    let pub_cnvrts  = converts.len;
    converts       ~= prv_converts;

    return Scope(
        :items,     :pub_items,
        :converts,  :pub_cnvrts,

        :scope.overloads,
        :scope.extended,

        implicits:  [],
        imports:    pub_imports,
        privates:   [],
        usings:     []);
}


////////////////////////////////

fn each(
    items: [$T],
    scope_skip: ScopeSkip[],
    fn,
    start = 0)
{
    let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

    mut i0 = start;
    for (mut i = 0; i < scope_skip.len + 1; i++)
    {
        let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
        if (ss.end <= i0)
            continue;

        let i1 = ss.start;
        for (shadow mut i = i0; i < i1; i++)
            fn(items[i], i?: i);

        i0 = ss.end;
    }
}

fn reveach(items: [$T], ss: ScopeSkip[], fn)
{
    mut ssi = ss.len - 1;
    mut ssN = ssi >= 0 && ss[ssi].end - 1;

    for (mut i = items.len; i --> 0; )
    {
        if (ssi >= 0 && i == ssN) {
            i   = ss[ssi--].start;
            ssN = ssi >= 0 && ss[ssi].end - 1;
            continue;
        }

        fn(items[i], i);
    }
}

fn search(
    ref items: [ScopeItem], id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip[],
    ref shadows: bool,
    extra_items?: [Target],
    field_items?: [ScopeItem]): Target
{
    shadows = false;

    // Search.
    let NUM_EXTRAS      = extra_items.len;
    let NUM_SPECIALS    = NUM_EXTRAS    + field_items.len;
    let START           = NUM_SPECIALS  + items.len;

    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: items shrunk while we iterated.");

    // Prevent re-entry, otherwise we loop forever
    //  if we're matching the very first item in scope.
    defer scope_iterator ||= -1;

    // We've got to do actual scope items first for shadowing to work correctly.
    {
        ////////////////////////////////////////
        scope_iterator          -= NUM_SPECIALS;
        defer scope_iterator    += NUM_SPECIALS;
        ////////////////////////////////////////

        // Actual scope items,
        //  this is the only stuff we need to scope-skip through.
        mut skiptrap = -1;

        fn nextSkip()
        {
            for (mut i = scope_skip.len; i --> 0; )
            {
                let ss = scope_skip[i];

                let s1 = ss.end - 1;
                if (scope_iterator > s1)
                {
                    skiptrap = s1;
                    break;
                }

                let s0 = ss.start - 1;
                if (scope_iterator > s0)
                    scope_iterator = s0;
            }

            if (skiptrap >= items.len)
                throw ("Scope/search: scope_skip will jump past end of items.");
        }

        // Go.

        let scope_iterator0 = scope_iterator;

        scope_iterator--;
        nextSkip();
        scope_iterator++;

        while (scope_iterator --> 0)
        {
            if (scope_iterator == skiptrap)
            {
                nextSkip();
                scope_iterator++;
                continue;
            }

            let item = items[scope_iterator];
            if (item.id == id)
            {
                shadows = ScopeItem_shadows(item);

                ////////////////////////////////
                if (ScopeItem_canSkipRest(item))
                {
                    // println("     SKIP " id " " scope_iterator);
                    scope_iterator = 0;
                }
                ////////////////////////////////

                return item.target;
            }
        }

        ////////////////////////////////////////////////////////
        if (scope_iterator0 >= 0 && scope_iterator0 < items.len)
        {
            // println("WILL SKIP " id " " scope_iterator0);
            ScopeItem_canSkipRest_set(items[scope_iterator0]);
        }
        ////////////////////////////////////////////////////////
    }

    // Field items, the next batch.
    scope_iterator++;
    {
        //////////////////////////////////////
        scope_iterator          -= NUM_EXTRAS;
        defer scope_iterator    += NUM_EXTRAS;
        //////////////////////////////////////

        while (scope_iterator --> 0)
        {
            let item = field_items[scope_iterator];
            if (item.id == id)
                return item.target;
        }
    }

    // Finally extra items, the simplest loop.
    scope_iterator++;
    {
        while (scope_iterator --> 0)
            return extra_items[scope_iterator];
    }

    return Target;
}


//

fn search(
    dont_search_just_return!: Target,
    scope_iterator: &mut i32)
{
    // Searching & forcing results the same way.
    if (scope_iterator)
        return Target;

    scope_iterator--;
    return dont_search_just_return;
}

fn search(
    items: [ScopeItem], id: string,
    scope_iterator: &mut i32): Target
{
    let START = items.len;

    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: items shrunk while we iterated.");

    defer scope_iterator ||= -1;

    while (scope_iterator --> 0)
    {
        let item = items[scope_iterator];
        if (item.id == id)
            return item.target;
    }

    return Target;
}


////////////////////////////////

fn Scope_snap(scope: Scope, implicit _helpers: Helpers[])
    ScopeMemo(
        items_len:      scope.items     .len,
        implicits_len:  scope.implicits .len,
        imports_len:    scope.imports   .len,
        privates_len:   scope.privates  .len,
        usings_len:     scope.usings    .len,
        converts_len:   scope.converts  .len,
        helpers_len:         _helpers   .len);

fn Scope_pop(ref scope: Scope, implicit ref _helpers: Helpers[], memo: ScopeMemo)
{
    scope.items     .shrink(memo.items_len);
    scope.implicits .shrink(memo.implicits_len);
    scope.imports   .shrink(memo.imports_len);
    scope.privates  .shrink(memo.privates_len);
    scope.usings    .shrink(memo.usings_len);
    scope.converts  .shrink(memo.converts_len);
    _helpers        .shrink(memo.helpers_len);
}


////////////////////////////////

fn Scope_create(
    scope: &mut Scope,
    ::kind = "__no_kind_yet", name!?: string,
    type?: Type, flags!?: Flags,
    status?: SolverStatus,
    nest!?: i32): Target
{
    ref overloads = nest
        ? scope.extended.grow_if_oob(nest).locals
        : scope.overloads;

    let target = Target(
        modid: nest ? -nest : MODID,
        index: overloads.len + 1);

    mut item: Overload;

    item.name           = name;
    item.kind           = kind;
    item.flags          = flags;
    item.type           = type;
    item.status         = status;

    overloads.push(item);

    return target;
}

fn Scope_set(ref scope: Scope, id: string, target: Target, shadows!: bool)
{
    Scope_set(:scope.items, :id, :target, :shadows);
}

fn Scope_set(ref items: ScopeItem[], id: string, target: Target, shadows!: bool)
{
    items.push(ScopeItem( :id, :target, :shadows ));
}

fn Scope_Typedef(scope: &mut Scope,
    id: string, type: Type, flags = F_PUB, name?: string,
    status?: SolverStatus)
{
    let target = Scope_create(:scope, "type", :type, :flags, name: name || id, :status);

    if (id)
        Scope_set(:scope, :id, :target, shadows: !!(flags & F_SHADOW));

    return target;
}


//

fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );
    Scope_Typedef(scope, "i128",   t_i128  );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );
    Scope_Typedef(scope, "u128",   t_u128  );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
