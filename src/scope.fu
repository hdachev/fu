#import 'lexer';
#import 'parser';
#import 'types';
#import 'lifetimes';


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct);        // canon  -> type info
    specs:      Map(string, SolvedNode);    // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    s_lex:      f64;
    s_parse:    f64;
    s_solve:    f64;
    s_cpp:      f64;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in:         ModuleInputs;
    out:        ModuleOutputs;
    stats:      ModuleStats;
};

pub fn MODID(implicit module: Module): i32
    module.modid;


// The temp context -
//  TBD what this will look like in the end -
//   we'll likely need a typespace per module,
//    so everyone can read from immut shared concurrently,
//     and write into their own without having to sync.

pub struct Context
{
    modules: Module[];
    files: Map(string, string);
};

pub fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

pub fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

pub fn getFile(
    implicit ctx: &mut Context,
    path: string)
{
    return ctx.files[path] ||= file_read(path);
}

pub fn getModule(
    implicit ctx: &mut Context,
    fname: string)
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    mut module = Module(modid: i);
        module.fname = fname;

    ctx.modules.push(module);
    return ctx.modules[i];
}

pub fn setModule(
    implicit ctx: &mut Context,
    module: Module)
{
    let current: &mut Module = ctx.modules[module.modid];
        current.fname == module.fname || assert();
        current = module;
}

fn registerType(
    implicit module: &mut Module,
    canon: string, def: Struct): void
{
    module.out.types[canon] = def;
}

pub fn lookupType(
    implicit module: Module,
    implicit ctx: Context,
    type: Type)
{
    if (type.modid == module.modid)
        return module.out.types[type.canon]
            || assert();

    return ctx.modules[type.modid].out.types[type.canon]
        || assert();
}

pub fn lookupType_mut(
    implicit module: &mut Module,
    canon: string)
{
    return module.out.types[canon] || assert();
}


//

pub fn initStruct(id: string, flags: i32)
{
    let canon = 's_' + id;
    let def = Struct(
        kind:   'struct',
        id:     id      || throw('TODO anonymous structs?'),
        flags:  flags|0,
    );

    registerType(canon, def);

    return Type(ValueType(canon, copyOrMove(flags, def.fields), MODID));
}

pub fn finalizeStruct(id: string, fields: StructField[])
{
    let canon = 's_' + id;
    let def: &mut Struct = lookupType_mut(canon);

    def.fields = fields || throw('TODO empty structs?');
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[]): i32
{
    if (flags & F_DESTRUCTOR || someFieldNonCopy(fields))
        return 0;

    return q_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_copy)
            return true;

    return false;
}

fn someFieldNotTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_trivial)
            return true;

    return false;
}


//

pub fn createArray(item: Type): Type
{
    let flags = 0;
    let fields: StructField[] =
    [
        StructField(
            id:  'Item',
            type: item.value),
    ];

    let canon = 'v(' + serializeType(item) + ')';

    registerType(canon, Struct(
        kind:   'array',
        id:     canon,
        :fields,
        :flags));

    return Type(
        ValueType(canon, copyOrMove(flags, fields), MODID),
            :item.lifetime);
}

pub fn type_isString(type: Type): bool
{
    return type.canon == 'string';
}

pub fn type_isArray(type: Type): bool
{
    return type.canon.starts(with: 'v(');
}

pub fn tryClear_array(type: Type): Type
{
    if (!type_isArray(type))
        return Type();

    let def = lookupType(type);

    return Type(
        value: def.kind == 'array' && def.fields[0].type || assert(),
        :type.lifetime);
}


//

pub fn type_isMap(type: Type): bool
{
    return type.canon.starts(with: 'm(');
}

pub fn createMap(key: Type, value: Type): Type
{
    let flags  = 0;
    let fields =
    [
        StructField(id:  'Key',   type: key.value  ),
        StructField(id:  'Value', type: value.value),
    ];

    let canon = 'm(' + serializeType(key) + ',' + serializeType(value) + ')';

    registerType(canon, Struct(
        kind:   'map',
        id:     canon,
        :fields,
        :flags,
    ));

    return Type(
        ValueType(canon, copyOrMove(flags, fields), MODID),
            lifetime: type_inter( key.lifetime,
                                value.lifetime ));
}

pub struct MapFields
{
    key:   Type;
    value: Type;
}

pub fn tryClear_map(type: Type): MapFields
{
    if (!type_isMap(type))
        return MapFields();

    let def = lookupType(type);
        def.kind == 'map' || assert();

    //
    return MapFields(
        key:   Type(value: def.fields[0].type || assert(), :type.lifetime),
        value: Type(value: def.fields[1].type || assert(), :type.lifetime));
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub struct Target { modid: i32; index: i32; }

pub struct SolvedNode
{
    kind:   string;
    flags:  i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value:  string;
    items:  SolvedNode[];
    token:  TokenIdx;

    type:   Type;
    target: Target;
};

pub struct Template
{
    node: Node;
};

pub struct Partial
{
    via:    Target;
    target: Target;
};

pub struct Overload
{
    kind: string;
    name: string;
    type: Type;

    // Arity.
    min: i32;
    max: i32;

    // TODO pack in single array.
    args: Type[];
    names: string[];
    defaults: SolvedNode[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial: Partial;
    template: Template;
    constant: SolvedNode;
};

pub fn isTemplate(o: Overload)
    o.kind == 'template';

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
};


////////////////////////////////

pub fn Scope_lookup(scope: Scope, id: string): Target[]
{
    mut results: Target[] = [];

    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(item.target);
    }

    return results;
}

pub fn Scope_search(
    scope: Scope, id: string,
    scope_iterator: &mut i32): Target
{
    let items = scope.items;

    if (!scope_iterator)
        scope_iterator = items.len;

    while (scope_iterator --> 0)
    {
        let item = items[scope_iterator];
        if (item.id == id)
            return item.target;
    }

    return Target;
}


////////////////////////////////

pub fn Scope_push(scope: &mut Scope): i32
{
    return scope.items.len;
}

pub fn Scope_pop(scope: &mut Scope, memo: i32): void
{
    scope.items.shrink(memo);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,

    min: i32                = 0,
    max: i32                = 0,
    arg_n: string[]         = [],
    arg_t: Type[]           = [],
    arg_d: SolvedNode[]     = [],
    template: Template      = [],
    partial: Partial        = [],
    constant: SolvedNode    = []): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        :kind,
        name: id, :type,
        :min, :max, args: arg_t,
        names: arg_n, defaults: arg_d,
        :partial, :template, :constant);

    scope.items.push(
        ScopeItem( :id, :target ));

    scope.overloads.push(item);

    return target;
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type)
{
    return Scope_add(scope, 'type', id, type);
}


//

pub fn Lifetime_fromCallArgs(
    lifetime: Lifetime, args: SolvedNode[]): Lifetime
{
    mut result: Lifetime;

    for (mut i = 0; i < lifetime.regions.len; i++)
    {
        let r = lifetime.regions[i];

        // Use verbatim unless an argument.
        let argIdx = Region_toArgIndex(r);
        if (argIdx < 0)
        {
            result = type_inter(result, r);
            continue;
        }

        // Else replace with actual from callsite,
        //  incrementing the relax depth as much as possible.

        // TODO FIX we can catch dangling references
        //  to temporaries right here.

        let arg     = args[argIdx];
        let actual  = Lifetime_relaxCallArg(arg.type.lifetime, r.relax);
            result  = type_inter(result, actual);
    }

    return result;
}


//

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;
};


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  'i8',    t_i8    );
    Scope_Typedef(scope, 'i16',    t_i16   );
    Scope_Typedef(scope, 'i32',    t_i32   );
    Scope_Typedef(scope, 'i64',    t_i64   );

    Scope_Typedef(scope,  'u8',    t_u8    );
    Scope_Typedef(scope, 'u16',    t_u16   );
    Scope_Typedef(scope, 'u32',    t_u32   );
    Scope_Typedef(scope, 'u64',    t_u64   );

    Scope_Typedef(scope, 'f32',    t_f32   );
    Scope_Typedef(scope, 'f64',    t_f64   );

    Scope_Typedef(scope, 'bool',   t_bool  );
    Scope_Typedef(scope, 'void',   t_void  );
    Scope_Typedef(scope, 'string', t_string);
    Scope_Typedef(scope, 'never',  t_never );

    return scope;
}
