import flags;
import types;
import structs;
import helpers;
import module;


//

enum SolverPass
{
    Solving = 0
    RelaxMut
    BorrowCheck
    MaybeCopyOrMove
    RelaxCopyResize
};

struct HelpersData
{
    target!?:       Target;
    pass!?:         SolverPass;

    id?:            string;
    mask!?:         HelpersMask;
    local_of!?:     i32;
    locals_start!?: i32;

    ret_expect?:    Type;
    ret_actual?:    Type;
};

fn target(si: ScopeItem)
    Target(:si.modid, index: (si.packed &~ (0x1 << 31)).i32);

fn ScopeItem_shadows(si: ScopeItem)
    !!(si.packed & (0x1 << 31));

fn ScopeItem(id: string, target: Target, shadows: bool)
    ScopeItem(:id, :target.modid,
        packed: target.index.u32 | (shadows && (0x1 << 31)));

fn target_TODOFIX(ref si: ScopeItem, target: Target)
{
    si.modid  = target.modid;
    si.packed = target.index.u32;
    return si;
}



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

fn MODID(implicit module: Module): i32
    module.modid;

fn initStruct(implicit module: &mut Module,
    ::kind!, baseprim!: string,
    name: string, asserts: DeclAsserts)
{
    name[0].u8 - '0'.u8 > 9.u8 || throw (
        "Bad struct name, leading digit: `" ~ name ~ "`.");

    // Alloc a slot.
    let index = module.out.types.len;
    module.out.types ~= Struct(:kind, :name, base: baseprim);

    //
    mut canon = createStructCanon(
        :kind, :baseprim, :module.modid, :index, :name);

    // Assume everything, we resolve disappointment.
    let specualtive_quals = !(asserts & A_NOCOPY) && q_rx_copy;


    return Type(ValueType(:canon, quals: specualtive_quals));
}

fn despeculateStruct(mut type: Type)
{
    type.quals &= ~q_rx_copy;
    return type;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

fn Scope_exports(scope: Scope, modid!: i32, field_items: ScopeItem[])
{
    mut items:          ScopeItem[] = field_items;
    mut prv_items:      ScopeItem[];

    mut converts:       Target[];
    mut prv_converts:   Target[];

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            (overload.flags & F_PUB ? items : prv_items) ~= item;
        }
    }

    for (mut i = 0; i < scope.converts.len; i++)
    {
        let item = scope.converts[i];
        if (item.modid == modid)
        {
            let overload = scope.overloads[item.index - 1];
            (overload.flags & F_PUB ? converts : prv_converts) ~= item;
        }
    }

    let pub_items   = items.len;
    items          ~= prv_items;

    let pub_cnvrts  = converts.len;
    converts       ~= prv_converts;

    return Scope(
        :items,     :pub_items,
        :converts,  :pub_cnvrts,

        :scope.overloads,
        :scope.extended,

        implicits:  [],
        imports:    [],
        privates:   [],
        usings:     []);
}


////////////////////////////////

fn each(
    items: [$T],
    scope_skip: ScopeSkip[],
    fn,
    start = 0)
{
    let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

    mut i0 = start;
    for (mut i = 0; i < scope_skip.len + 1; i++)
    {
        let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
        if (ss.end <= i0)
            continue;

        let i1 = ss.start;
        for (shadow mut i = i0; i < i1; i++)
            fn(items[i], i?: i);

        i0 = ss.end;
    }
}

fn reveach(items: [$T], ss: ScopeSkip[], fn)
{
    mut ssi = ss.len - 1;
    mut ssN = ssi >= 0 && ss[ssi].end - 1;

    for (mut i = items.len; i --> 0; )
    {
        if (ssi >= 0 && i == ssN) {
            i   = ss[ssi--].start;
            ssN = ssi >= 0 && ss[ssi].end - 1;
            continue;
        }

        fn(items[i], i);
    }
}

fn search(
    items: [ScopeItem], id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip[],
    ref shadows: bool,
    dont_search_just_return?: Target,
    extra_items?: [Target],
    field_items?: [ScopeItem]): Target
{
    // Searching & forcing results the same way.
    if (dont_search_just_return)
    {
        if (scope_iterator)
            return Target;

        scope_iterator--;
        return dont_search_just_return;
    }

    // Search.
    let START = items.len + extra_items.len + field_items.len;
    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: items shrunk while we iterated.");

    // Scope skip.
    mut skiptrap = -1;

    fn nextSkip()
    {
        for (mut i = scope_skip.len; i --> 0; )
        {
            let ss = scope_skip[i];

            let s1 = ss.end - 1;
            if (scope_iterator > s1)
            {
                skiptrap = s1;
                break;
            }

            let s0 = ss.start - 1;
            if (scope_iterator > s0)
                scope_iterator = s0;
        }

        if (skiptrap >= items.len)
            throw ("Scope/search: scope_skip will jump past end of items.");
    }

    scope_iterator--;
    nextSkip();
    scope_iterator++;

    // TODO clean this up
    mut TODO_FIX = ScopeItem;
    if (extra_items) TODO_FIX.id = id;

    // TODO unroll into three loops,
    //  for each kind of thing we're searching.
    while (scope_iterator --> 0)
    {
        if (scope_iterator == skiptrap)
        {
            nextSkip();
            if (scope_iterator == -1)
                throw("\n\n\tHERE WE GO - scope-skipped to -1.\n");
        }

        let item = scope_iterator >= items.len
            ? scope_iterator >= items.len + extra_items.len
                ? field_items[scope_iterator - items.len - extra_items.len]
                : TODO_FIX.target_TODOFIX(extra_items[scope_iterator - items.len])
            : items[scope_iterator];

        if (item.id == id)
        {
            // Prevent re-entry, otherwise we loop forever
            //  if we're matching the very first item in scope.
            if (!scope_iterator)
                scope_iterator = -1;

            shadows = ScopeItem_shadows(item);
            return item.target;
        }
    }

    return Target;
}


////////////////////////////////

fn Scope_snap(scope: Scope, implicit _helpers: Helpers[])
    ScopeMemo(
        items_len:      scope.items     .len,
        implicits_len:  scope.implicits .len,
        imports_len:    scope.imports   .len,
        privates_len:   scope.privates  .len,
        usings_len:     scope.usings    .len,
        converts_len:   scope.converts  .len,
        helpers_len:         _helpers   .len);

fn Scope_pop(ref scope: Scope, implicit ref _helpers: Helpers[], memo: ScopeMemo)
{
    scope.items     .shrink(memo.items_len);
    scope.implicits .shrink(memo.implicits_len);
    scope.imports   .shrink(memo.imports_len);
    scope.privates  .shrink(memo.privates_len);
    scope.usings    .shrink(memo.usings_len);
    scope.converts  .shrink(memo.converts_len);
    _helpers        .shrink(memo.helpers_len);
}


////////////////////////////////

fn Scope_create(
    scope: &mut Scope,
    ::kind = "__no_kind_yet", name!?: string,
    type?: Type, flags!?: Flags,
    status?: SolverStatus,
    nest!?: i32): Target
{
    ref overloads = nest
        ? scope.extended.grow_if_oob(nest).locals
        : scope.overloads;

    let target = Target(
        modid: nest ? -nest : MODID,
        index: overloads.len + 1);

    mut item: Overload;

    item.name           = name;
    item.kind           = kind;
    item.flags          = flags;
    item.type           = type;
    item.status         = status;

    overloads.push(item);

    return target;
}

fn Scope_set(ref scope: Scope, id: string, target: Target, shadows!: bool)
{
    Scope_set(:scope.items, :id, :target, :shadows);
}

fn Scope_set(ref items: ScopeItem[], id: string, target: Target, shadows!: bool)
{
    items.push(ScopeItem( :id, :target, :shadows ));
}

fn Scope_Typedef(scope: &mut Scope,
    id: string, type: Type, flags = F_PUB, name?: string,
    status?: SolverStatus)
{
    let target = Scope_create(:scope, "type", :type, :flags, :name, :status);

    if (id)
        Scope_set(:scope, :id, :target, shadows: !!(flags & F_SHADOW));

    return target;
}


//

fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );
    Scope_Typedef(scope, "i128",   t_i128  );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );
    Scope_Typedef(scope, "u128",   t_u128  );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
