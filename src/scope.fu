import lexer;
import parser;
import types;
import lifetimes;
import stat;
import helpers;


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct);        // canon  -> type info
    specs:      Map(string, SolvedNode);    // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    lex:        ModuleStat;
    parse:      ModuleStat;
    solve:      ModuleStat;
    codegen:    ModuleStat;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

pub fn MODID(implicit module: Module): i32
    module.modid;

pub fn lookupStruct_mut(
    implicit module: &mut Module,
    canon: string)
{
    return module.out.types[canon] || assert();
}


//

pub fn isStruct(type: Type)
{
    return type.canon.starts(with: '$');
}

pub fn initStruct(
    implicit module: &mut Module,
    id: string, flags: i32)
{
    let canon = "$" ~ module.modid ~ id;

    let def = Struct(
        :id || throw("TODO anonymous structs?"),
        :flags);

    // REGISTER STRUCT ///////////
    module.out.types[canon] = def;
    //////////////////////////////

    return Type(ValueType(:canon, copyOrMove(flags, def.fields), MODID));
}

pub fn finalizeStruct(
    canon: string, fields: StructField[]): i32
{
    mut quals: i32 = 0;

    let def: &mut Struct = lookupStruct_mut(canon);
    def.fields = fields || throw("TODO empty structs?");

    if (!fields.someFieldNonTrivial)
        quals |= q_trivial;

    return quals;
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[]): i32
{
    if (flags & F_DESTRUCTOR || someFieldNonCopy(fields))
        return 0;

    return q_rx_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_rx_copy)
            return true;

    return false;
}

fn someFieldNonTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_trivial)
            return true;

    return false;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub struct SolvedNode
{
    kind:       string;
    flags?:     i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value?:     string;
    items?:     SolvedNode[];
    token:      TokenIdx;

    type:       Type;
    target?:    Target;
};

pub struct Template
{
    node:       Node;
    imports:    i32[];
};

pub struct Partial
{
    via:        Target;
    target:     Target;
};

pub struct Argument
{
    name?:      string;
    type?:      Type;
    default?:   SolvedNode;
    flags?:     i32;
};

pub struct Overload
{
    kind:       string;
    name:       string;
    type:       Type;
    flags:      i32;

    // Arity.
    min:        i32;
    max:        i32;
    args:       Argument[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial:    Partial;
    template:   Template;
    constant:   SolvedNode;
};

pub fn isTemplate(o: Overload)
    o.kind == "template";

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
    imports:    i32[];
};

pub fn Scope_exports(scope: Scope, modid!: i32)
{
    mut result: ScopeItem[] = [];

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            if (!modid || overload.flags & F_PUB)
                result.push(item);
        }
    }

    let no_imports: i32[];

    return Scope(
        items: result,
        :scope.overloads,
        imports: no_imports);
}


////////////////////////////////

pub fn DEPREC_lookup(scope: Scope, id: string): Target[]
{
    id || assert();
    mut results: Target[] = [];

    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(item.target);
    }

    return results;
}

pub struct ScopeSkip
{
    start: ScopeMemo;
    end:   ScopeMemo;
};

pub fn search(
    scope: Scope, id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip,
    target: Target = [],
    extra_items: ScopeItem[] = []): Target
{
    // Searching & forcing results the same way.
    if (target)
    {
        if (scope_iterator)
            return Target;

        scope_iterator--;
        return target;
    }

    // Search.
    let skip0 = scope_skip.start.items_len - 1;
    let skip1 = scope_skip.end  .items_len - 1;

    let items = scope.items;
    if (!scope_iterator)
        scope_iterator = items.len + extra_items.len;

    while (scope_iterator --> 0)
    {
        if (scope_iterator == skip1)
            scope_iterator  = skip0;

        let item = scope_iterator >= items.len
            ? extra_items[scope_iterator - items.len]
            : items[scope_iterator];

        if (item.id == id)
        {
            // Prevent re-entry, otherwise we loop forever
            //  if we're matching the very first item in scope.
            if (!scope_iterator)
                scope_iterator = -1;

            return item.target;
        }
    }

    return Target;
}


////////////////////////////////

pub struct ScopeMemo
{
    items_len: i32;
    imports_len: i32;
};

pub fn Scope_push(scope: &mut Scope)
    ScopeMemo(
        items_len:   scope.items  .len,
        imports_len: scope.imports.len);

pub fn Scope_pop(scope: &mut Scope, memo: ScopeMemo)
{
    scope.items  .shrink(memo.items_len);
    scope.imports.shrink(memo.imports_len);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,
    flags!: i32,

    min?:           i32,
    max?:           i32,
    args?:          Argument[],
    template?:      Template,
    partial?:       Partial,
    constant?:      SolvedNode): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        :kind, :flags,
        name: id, :type,
        :min, :max, :args,
        :partial, :template, :constant);

    scope.items.push(
        ScopeItem( :id, :target ));

    scope.overloads.push(item);

    return target;
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type, flags: i32 = F_PUB)
{
    return Scope_add(:scope, "type", :id, :type, :flags);
}


//

pub fn Lifetime_fromCallArgs(
    lifetime: Lifetime, args: SolvedNode[]): Lifetime
{
    mut result: Lifetime;

    for (mut i = 0; i < lifetime.regions.len; i++)
    {
        let r = lifetime.regions[i];

        // Use verbatim unless an argument.
        let argIdx = Region_toArgIndex(r);
        if (argIdx < 0)
        {
            result = type_inter(result, r);
            continue;
        }

        // Else replace with actual from callsite,
        //  incrementing the relax depth as much as possible.

        // TODO FIX we can catch dangling references
        //  to temporaries right here.

        let arg     = args[argIdx];
        let actual  = Lifetime_relaxCallArg(arg.type.lifetime, r.relax);
            result  = type_inter(result, actual);
    }

    return result;
}


//

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;
};


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
