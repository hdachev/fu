import parser;
import types;

pub let SS_FINALIZED    = 0x1 << 0;
pub let SS_DIRTY        = 0x1 << 1;
pub let SS_REC_CHECKED  = 0x1 << 2;
pub let SS_RECURSIVE    = 0x1 << 3;

pub let SS_HAS_BREAK    = 0x1 << 4;
pub let SS_HAS_CONTINUE = 0x1 << 5;


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        lexer::LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct); // canon  -> type info
    specs:      Map(string, Target); // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
    solve:      stat::ModuleStat;
    codegen:    stat::ModuleStat;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

////

pub struct Struct
{
    target?:    Target;
    items?:     ScopeItem[];
};

////

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;

    // Stats & such.
    SLOW_resolve:   i32;
};

pub struct ScopeSkip
{
    start:  i32;
    end:    i32;
};

pub struct ScopeMemo
{
    items_len: i32;
    imports_len: i32;
};

pub struct SolvedNode
{
    kind:       string;
    flags?:     i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value?:     string;
    items?:     SolvedNode[];
    token:      TokenIdx;

    type:       Type;
    target?:    Target;
};

pub struct Template
{
    node:       Node;
    imports:    i32[];

    scope_memo: ScopeMemo;
    ss_items:   ScopeSkip[];
    ss_imports: ScopeSkip[];
};

pub struct Partial
{
    via:        Target;
    target:     Target;
};

pub struct Argument
{
    name?:      string;
    type?:      Type;
    default?:   SolvedNode;
    flags?:     i32;
};

pub struct Overload
{
    kind:       string;
    name:       string;
    type:       Type;
    flags:      i32;

    // Arity.
    min:        i32;
    max:        i32;
    args:       Argument[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial:    Partial;
    template:   Template;
    solved:     SolvedNode;

    // Target.index, Target.modid is current module modid.
    //
    // Note that when closures call their enclosing function,
    //  the index we use is the one of the enclosing function.
    //   See CallerNode, that's where we keep track of users.
    used_by?:   i32[]; // <- watch out for closures

    // Solver state. // maybe we need flags enums already
    status?:    u32; // <- u32 to differentiate from flags

    // For locals, if non-zero, index of enclosing fn, obviously same modid.
    local_of?:  i32;
    closes_over?: i32[];
};

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub nocopy struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
    imports:    i32[];
};




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn MODID(implicit module: Module): i32
    module.modid;

pub fn isStruct(type: Type)
{
    return type.canon.starts(with: '$');
}

pub fn initStruct(implicit module: &mut Module, name: string, flags: i32)
{
    let canon = "$" ~ name;

    if (module.out.types.has(canon))
        throw("initStruct already invoked for `" ~ name ~ "`.");

    module.out.types[canon] = Struct;

    // Assume everything, we resolve disappointment.
    let specualtive_quals = flags & F_NOCOPY
        ? q_trivial
        : q_rx_copy | q_trivial;

    return Type(ValueType(:canon, MODID,
        quals: specualtive_quals));
}

pub fn despeculateStruct(mut type: Type)
{
    type.quals &= ~(q_rx_copy | q_trivial);
    return type;
}

pub fn lookupStruct_mut(implicit module: &mut Module, canon: string): &mut Struct
{
    return module.out.types[canon];
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn Scope_exports(scope: Scope, modid!: i32, field_items: ScopeItem[])
{
    mut result: ScopeItem[] = field_items;

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            if (!modid || overload.flags & F_PUB)
                result.push(item);
        }
    }

    let no_imports: i32[];

    return Scope(
        items: result,
        :scope.overloads,
        imports: no_imports);
}


////////////////////////////////

pub fn DEPREC_lookup(scope: Scope, id: string, scope_skip: ScopeSkip[]): Target[]
{
    mut scope_iterator: i32;
    mut results: Target[] = [];

    mut target: Target;
    while (target = scope.items.search(:id, :scope_iterator, :scope_skip))
        results.unshift(target);

    return results;
}

pub fn each(
    items: [$T],
    scope_skip: ScopeSkip[],
    fn,
    start = 0)
{
    let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

    mut i0 = start;
    for (mut i = 0; i < scope_skip.len + 1; i++)
    {
        let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
        if (ss.end <= i0)
            continue;

        let i1 = ss.start;
        for (shadow mut i = i0; i < i1; i++)
            fn(items[i]);

        i0 = ss.end;
    }
}

pub fn search(
    items: [ScopeItem], id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip[],
    target?: Target,
    extra_items?: [ScopeItem],
    field_items?: [ScopeItem]): Target
{
    // Searching & forcing results the same way.
    if (target)
    {
        if (scope_iterator)
            return Target;

        scope_iterator--;
        return target;
    }

    // Search.
    let START = items.len + extra_items.len + field_items.len;
    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: items shrunk while we iterated.");

    // Scope skip.
    mut skiptrap = -1;

    fn nextSkip()
    {
        for (mut i = scope_skip.len; i --> 0; )
        {
            let ss = scope_skip[i];

            let s1 = ss.end - 1;
            if (scope_iterator > s1)
            {
                skiptrap = s1;
                break;
            }

            let s0 = ss.start - 1;
            if (scope_iterator > s0)
                scope_iterator = s0;
        }

        if (skiptrap >= items.len)
            throw ("Scope/search: scope_skip will jump past end of items.");
    }

    scope_iterator--;
    nextSkip();
    scope_iterator++;

    // TODO unroll into three loops,
    //  for each kind of thing we're searching.
    //
    while (scope_iterator --> 0)
    {
        if (scope_iterator == skiptrap)
            nextSkip();

        // TODO clean this up
        let item = scope_iterator >= items.len
            ? scope_iterator >= items.len + extra_items.len
            ? field_items[scope_iterator - items.len - extra_items.len]
            : extra_items[scope_iterator - items.len]
            : items[scope_iterator];

        if (item.id == id)
        {
            // Prevent re-entry, otherwise we loop forever
            //  if we're matching the very first item in scope.
            if (!scope_iterator)
                scope_iterator = -1;

            return item.target;
        }
    }

    return Target;
}


////////////////////////////////

pub fn Scope_snap(scope: &mut Scope)
    ScopeMemo(
        items_len:   scope.items  .len,
        imports_len: scope.imports.len);

pub fn Scope_pop(scope: &mut Scope, memo: ScopeMemo)
{
    scope.items  .shrink(memo.items_len);
    scope.imports.shrink(memo.imports_len);
}

pub fn >(a: ScopeMemo, b: ScopeMemo)
    a.items_len   > b.items_len ||
    a.imports_len > b.imports_len;

pub fn ==(a: ScopeMemo, b: ScopeMemo)
    a.items_len   == b.items_len ||
    a.imports_len == b.imports_len;


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,
    flags!: i32,

    min?:           i32,
    max?:           i32,
    args?:          Argument[],
    template?:      Template,
    partial?:       Partial,
    solved?:        SolvedNode,
    local_of?:      i32,
    name?:          string): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        name: name || id || throw("Falsy Scope_add(id)."),
        :kind, :flags, :type,
        :min, :max, :args,
        :partial, :template, :solved,
        :local_of);

    scope.overloads.push(item);

    if (id)
        scope.items.push(ScopeItem(:id, :target));

    return target;
}

pub fn Scope_create(
    scope: &mut Scope,
    kind = "_no_kind_yet_", name?!: string,
    type?: Type, flags?!: i32,
    min?!: i32, max?!: i32, args?: Argument[],
    solved?: SolvedNode, local_of?!: i32): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    mut item: Overload;

    item.name       = name;
    item.kind       = kind;
    item.flags      = flags;
    item.type       = type;
    item.min        = min;
    item.max        = max;
    item.args       = args;
    item.solved     = solved;
    item.local_of   = local_of;

    scope.overloads.push(item);

    return target;
}

pub fn Scope_set(scope: &mut Scope, id: string, target: Target)
{
    scope.items.push(ScopeItem( :id, :target ));
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type, flags = F_PUB, template?: Template, name?: string)
{
    return Scope_add(:scope, "type", :id, :name, :type, :flags, :template);
}


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
