import parser;
import types;
import lifetimes;

pub let SS_FINALIZED    = 1 << 0;
pub let SS_DIRTY        = 1 << 1;


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        lexer::LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct); // canon  -> type info
    specs:      Map(string, Target); // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
    solve:      stat::ModuleStat;
    codegen:    stat::ModuleStat;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

////

pub struct Struct
{
    id:         string;
    fields?:    StructField[];
    flags:      i32;
    ctor?:      Target;

    items?:     ScopeItem[];
};

pub struct StructField
{
    id:         string;
    type:       ValueType;
};

////

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;

    // Stats & such.
    SLOW_resolve:   i32;
};

pub struct ScopeSkip
{
    start: ScopeMemo;
    end:   ScopeMemo;
};

pub struct ScopeMemo
{
    items_len: i32;
    imports_len: i32;
};

pub struct SolvedNode
{
    kind:       string;
    flags?:     i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value?:     string;
    items?:     SolvedNode[];
    token:      TokenIdx;

    type:       Type;
    target?:    Target;
};

pub struct Template
{
    node:       Node;
    imports:    i32[];
    locals:     ScopeMemo;
};

pub struct Partial
{
    via:        Target;
    target:     Target;
};

pub struct Argument
{
    name?:      string;
    type?:      Type;
    default?:   SolvedNode;
    flags?:     i32;
};

pub struct Overload
{
    kind:       string;
    name:       string;
    type:       Type;
    flags:      i32;

    // Arity.
    min:        i32;
    max:        i32;
    args:       Argument[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    partial:    Partial;
    template:   Template;
    solved:     SolvedNode;

    // Target.index, Target.modid is current module modid.
    //
    // Note that when closures call their enclosing function,
    //  the index we use is the one of the enclosing function.
    //   See CallerNode, that's where we keep track of users.
    used_by?:   i32[]; // <- watch out for closures

    // Solver state.
    status?:    i32;

    // For locals, if non-zero, index of enclosing fn, obviously same modid.
    local_of?:  i32;
    closes_over?: i32[];
};

pub struct ScopeItem
{
    id:         string;
    target:     Target;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
    imports:    i32[];
};




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn MODID(implicit module: Module): i32
    module.modid;

pub fn isStruct(type: Type)
{
    return type.canon.starts(with: '$');
}

pub fn initStruct(
    implicit module: &mut Module,
    id: string, flags: i32)
{
    let canon = "$" ~ id;

    if (module.out.types.has(canon))
        throw("initStruct already invoked for `" ~ id ~ "`.");

    module.out.types[canon] = Struct(
        :id || throw("TODO anonymous structs?"),
        :flags);

    // Assume everything, we resolve disappointment.
    let specualtive_quals = q_rx_copy | q_trivial;

    return Type(ValueType(:canon, MODID,
        quals: specualtive_quals));
}

pub fn despeculateStruct(mut type: Type)
{
    type.quals &= ~(q_rx_copy | q_trivial);
    return type;
}

pub fn lookupStruct_mut(implicit module: &mut Module, canon: string)
{
    return module.out.types[canon] || assert();
}

pub fn finalizeStruct(
    canon: string, fields: StructField[], items: ScopeItem[]): i32
{
    let def: &mut Struct    = lookupStruct_mut(canon);
        def.fields          = fields || throw("TODO empty structs (fields) ?");
        def.items           = items  || throw("TODO empty structs (items)  ?");

    return fields.commonQuals();
}

fn commonQuals(fields: StructField[]): i32
{
    mut commonQuals = -1;

    for (mut i = 0; i < fields.len; i++)
        commonQuals &= fields[i].type.quals;

    return commonQuals;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn Scope_exports(scope: Scope, modid!: i32)
{
    mut result: ScopeItem[] = [];

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            if (!modid || overload.flags & F_PUB)
                result.push(item);
        }
    }

    let no_imports: i32[];

    return Scope(
        items: result,
        :scope.overloads,
        imports: no_imports);
}


////////////////////////////////

pub fn DEPREC_lookup(scope: Scope, id: string): Target[]
{
    id || assert();
    mut results: Target[] = [];

    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(item.target);
    }

    return results;
}

pub fn search(
    scope: Scope, id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip,
    target?: Target,
    extra_items?: ScopeItem[],
    field_items?: ScopeItem[]): Target
{
    // Searching & forcing results the same way.
    if (target)
    {
        if (scope_iterator)
            return Target;

        scope_iterator--;
        return target;
    }

    // Search.
    let items = scope.items;

    let skip0 = scope_skip.start.items_len - 1;
    let skip1 = scope_skip.end  .items_len - 1;
    if (skip1 >= items.len)
        throw ("Scope/search: scope_skip will jump past end of scope.items.");

    let START = items.len + extra_items.len + field_items.len;
    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: scope.items shrunk while we iterated.");

    while (scope_iterator --> 0)
    {
        if (scope_iterator == skip1)
            scope_iterator  = skip0;

        // TODO clean this up
        let item = scope_iterator >= items.len
            ? scope_iterator >= items.len + extra_items.len
            ? field_items[scope_iterator - items.len - extra_items.len]
            : extra_items[scope_iterator - items.len]
            : items[scope_iterator];

        if (item.id == id)
        {
            // Prevent re-entry, otherwise we loop forever
            //  if we're matching the very first item in scope.
            if (!scope_iterator)
                scope_iterator = -1;

            return item.target;
        }
    }

    return Target;
}


////////////////////////////////

pub fn Scope_snap(scope: &mut Scope)
    ScopeMemo(
        items_len:   scope.items  .len,
        imports_len: scope.imports.len);

pub fn Scope_pop(scope: &mut Scope, memo: ScopeMemo)
{
    scope.items  .shrink(memo.items_len);
    scope.imports.shrink(memo.imports_len);
}

pub fn >(a: ScopeMemo, b: ScopeMemo)
    a.items_len   > b.items_len ||
    a.imports_len > b.imports_len;


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,
    flags!: i32,

    min?:           i32,
    max?:           i32,
    args?:          Argument[],
    template?:      Template,
    partial?:       Partial,
    solved?:        SolvedNode,
    local_of?:      i32): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        name: id || throw("Falsy Scope_add(id)."),
        :kind, :flags, :type,
        :min, :max, :args,
        :partial, :template, :solved,
        :local_of);

    if (kind != "field")
        scope.items.push(
            ScopeItem( :id, :target ));

    scope.overloads.push(item);

    return target;
}

pub fn Scope_create(scope: &mut Scope, kind = "_no_kind_yet_"): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    mut item: Overload;
    item.kind = kind;
    scope.overloads.push(item);

    return target;
}

pub fn Scope_set(scope: &mut Scope, id: string, target: Target)
{
    scope.items.push(ScopeItem( :id, :target ));
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type, flags = F_PUB, template?: Template)
{
    return Scope_add(:scope, "type", :id, :type, :flags, :template);
}


//

pub fn Lifetime_fromCallArgs(
    lifetime: Lifetime, args: SolvedNode[]): Lifetime
{
    mut result: Lifetime;

    for (mut i = 0; i < lifetime.regions.len; i++)
    {
        let r = lifetime.regions[i];

        // Use verbatim unless an argument.
        let argIdx = Region_toArgIndex(r);
        if (argIdx < 0)
        {
            result = type_inter(result, r);
            continue;
        }

        // Else replace with actual from callsite,
        //  incrementing the relax depth as much as possible.

        // TODO FIX we can catch dangling references
        //  to temporaries right here.

        let arg     = args[argIdx];
        let actual  = Lifetime_relaxCallArg(arg.type.lifetime, r.relax);
            result  = type_inter(result, actual);
    }

    return result;
}


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
