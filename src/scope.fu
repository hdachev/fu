import parser;
import types;

pub let SS_LAZY         = 0x1 << 0;
pub let SS_DID_START    = 0x1 << 1;
pub let SS_DIRTY        = 0x1 << 2;
pub let SS_FINALIZED    = 0x1 << 3;

pub let SS_UPDATED      = 0x1 << 4;
// ...

pub let SS_TYPE_RECUR   = 0x1 << 16;
pub let SS_FN_RECUR     = 0x1 << 17;
// ...

pub let HM_CanBreak     = 1.i16 << 0;
pub let HM_CanReturn    = 1.i16 << 1;
pub let HM_Anon         = 1.i16 << 2;
pub let HM_Function     = 1.i16 << 3;
pub let HM_Lambda       = 1.i16 << 4;
pub let HM_Struct       = 1.i16 << 5;
pub let HM_LabelUsed    = 1.i16 << 6;


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        lexer::LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Struct[];
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
    solve:      stat::ModuleStat;
    codegen:    stat::ModuleStat;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    out?:       ModuleOutputs;
    stats?:     ModuleStats;
};

////

pub struct Struct
{
    name:       string;

    target?:    Target;
    items?:     ScopeItem[];
    imports?:   i32[];
    converts?:  Target[];
};

////

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;

    // Important solver events for testing.
    notes:  i32;
};

pub struct ScopeSkip
{
    start:  i32;
    end:    i32;
};

pub struct ScopeMemo
{
    items_len:      i32;
    imports_len:    i32;
    usings_len:     i32;
    converts_len:   i32;
    helpers_len:    i32;
};

pub struct SolvedNode
{
    kind:       string;
    flags?:     i32;

    ////////////////////////////////
    // room for one more i32 here //
    ////////////////////////////////

    value?:     string;
    items?:     SolvedNode[];
    token:      TokenIdx;

    type:       Type;
    target?:    Target;
};

pub struct ScopeSkipMemos
{
    items:      ScopeSkip[];
    declash:    ScopeSkip[];

    imports:    ScopeSkip[];
    usings:     ScopeSkip[];
    converts:   ScopeSkip[];

    helpers:    ScopeSkip[];
};

pub struct Template
{
    node:       Node;
    imports:    i32[];

    scope_memo: ScopeMemo;
    scope_skip: ScopeSkipMemos;
};

pub struct Partial
{
    via:        Target;
    target:     Target;
};

pub struct Argument
{
    name?:      string;
    autocall?:  string;

    type?:      Type;
    default?:   SolvedNode;
    flags?:     i32;
};

pub struct Overload
{
    kind:       string;
    name:       string;
    type:       Type;
    flags:      i32;

    // Arity.
    min:        i32;
    max:        i32;
    args:       Argument[];

    // TODO move exotic bloat over to module,
    //  all trailers can fit in the same
    //   [ modid / thing ] slot here.
    template:   Template;
    solved:     SolvedNode;

    // Target.index, Target.modid is current module modid.
    //
    // Note that when closures call their enclosing function,
    //  the index we use is the one of the enclosing function.
    //   See CallerNode, that's where we keep track of users.
    used_by?:   i32[]; // <- watch out for closures

    // Solver state. // maybe we need flags enums already
    status?:    u32; // <- u32 to differentiate from flags

    // For locals, if non-zero, index of enclosing fn, obviously same modid.
    local_of?:  i32;
    closes_over?: i32[];

    // What about this then?
    extra_items?: ScopeItem[];
};

pub struct Helpers
{
    target?!:       i32;
    id?:            string;
    mask?!:         i16;
    local_of?!:     i32;
    kills?!:        i32;

    ret_expect?:    Type;
    ret_actual?:    Type;
    returns?:       i32[];
};

pub struct ScopeItem
{
    id:         string;
    modid:      i32;
    packed:     u32;
};

pub nocopy struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
    imports:    i32[];
    usings:     Target[];
    converts:   Target[];
};

pub fn target(si: ScopeItem)
    Target(:si.modid, index: (si.packed &~ (0x1 << 31)).i32);

pub fn ScopeItem_shadows(si: ScopeItem)
    !!(si.packed & (0x1 << 31));

pub fn ScopeItem(id: string, target: Target, shadows: bool)
    ScopeItem(:id, :target.modid,
        packed: target.index.u32 | (shadows && (0x1 << 31)));

pub fn target_TODOFIX(ref si: ScopeItem, target: Target)
{
    si.modid  = target.modid;
    si.packed = target.index.u32;
    return si;
}



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn MODID(implicit module: Module): i32
    module.modid;

pub fn isStruct(type: Type)
{
    return type.canon.starts(with: '$');
}

pub fn structIndex(canon: string): i32
{
    mut offset = 1;
    return canon[0] == '$' ? parse10i32(:offset, canon) : -1;
}

pub fn initStruct(implicit module: &mut Module, name: string, flags: i32, SELF_TEST!: bool)
{
    name[0].u8 - '0'.u8 > 9.u8 || throw (
        "Bad struct name, leading digit: `" ~ name ~ "`.");

    let index = module.out.types.len;
    let canon = "$" ~ index ~ name;

    if (SELF_TEST)
        for (mut i = 0; i < module.out.types.len; i++)
            if (module.out.types[i].name == name)
                throw ("initStruct/SELF_TEST duplicate: `" ~ name ~ "`.");

    // Alloc a slot.
    module.out.types ~= Struct(:name);

    // Assume everything, we resolve disappointment.
    let specualtive_quals = flags & F_NOCOPY
        ? q_trivial
        : q_rx_copy | q_trivial;

    return Type(ValueType(:canon, MODID,
        quals: specualtive_quals));
}

pub fn despeculateStruct(mut type: Type)
{
    type.quals &= ~(q_rx_copy | q_trivial);
    return type;
}

pub fn lookupStruct_mut(implicit module: &mut Module, canon: string): &mut Struct
{
    return module.out.types[canon.structIndex];
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

pub fn Scope_exports(scope: Scope, modid!: i32, field_items: ScopeItem[])
{
    mut result: ScopeItem[] = field_items;

    for (mut i = 0; i < scope.items.len; i++)
    {
        let item = scope.items[i];
        if (item.target.modid == modid)
        {
            let overload = scope.overloads[item.target.index - 1];
            if (!modid || overload.flags & F_PUB)
                result.push(item);
        }
    }

    let no_imports: i32[];
    let no_usings: Target[];

    return Scope(
        items: result,
        :scope.overloads,
        :scope.converts,
        imports: no_imports,
        usings:  no_usings);
}


////////////////////////////////

pub fn each(
    items: [$T],
    scope_skip: ScopeSkip[],
    fn,
    start = 0)
{
    let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

    mut i0 = start;
    for (mut i = 0; i < scope_skip.len + 1; i++)
    {
        let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
        if (ss.end <= i0)
            continue;

        let i1 = ss.start;
        for (shadow mut i = i0; i < i1; i++)
            fn(items[i]);

        i0 = ss.end;
    }
}

pub fn reveach(items: [$T], ss: ScopeSkip[], fn)
{
    mut ssi = ss.len - 1;
    mut ssN = ssi >= 0 && ss[ssi].end - 1;

    for (mut i = items.len; i --> 0; )
    {
        if (ssi >= 0 && i == ssN) {
            i   = ss[ssi--].start;
            ssN = ssi >= 0 && ss[ssi].end - 1;
            continue;
        }

        fn(items[i], i);
    }
}

pub fn search(
    items: [ScopeItem], id: string,
    scope_iterator: &mut i32,
    scope_skip: ScopeSkip[],
    ref shadows: bool,
    dont_search_just_return?: Target,
    extra_items?: [Target],
    field_items?: [ScopeItem]): Target
{
    // Searching & forcing results the same way.
    if (dont_search_just_return)
    {
        if (scope_iterator)
            return Target;

        scope_iterator--;
        return dont_search_just_return;
    }

    // Search.
    let START = items.len + extra_items.len + field_items.len;
    if (!scope_iterator)
        scope_iterator = START;
    else if (scope_iterator >= START)
        throw ("Scope/search: items shrunk while we iterated.");

    // Scope skip.
    mut skiptrap = -1;

    fn nextSkip()
    {
        for (mut i = scope_skip.len; i --> 0; )
        {
            let ss = scope_skip[i];

            let s1 = ss.end - 1;
            if (scope_iterator > s1)
            {
                skiptrap = s1;
                break;
            }

            let s0 = ss.start - 1;
            if (scope_iterator > s0)
                scope_iterator = s0;
        }

        if (skiptrap >= items.len)
            throw ("Scope/search: scope_skip will jump past end of items.");
    }

    scope_iterator--;
    nextSkip();
    scope_iterator++;

    // TODO clean this up
    mut TODO_FIX = ScopeItem;
    if (extra_items) TODO_FIX.id = id;

    // TODO unroll into three loops,
    //  for each kind of thing we're searching.
    while (scope_iterator --> 0)
    {
        if (scope_iterator == skiptrap)
            nextSkip();

        let item = scope_iterator >= items.len
            ? scope_iterator >= items.len + extra_items.len
            ? field_items[scope_iterator - items.len - extra_items.len]
            : TODO_FIX.target_TODOFIX(extra_items[scope_iterator - items.len])
            : items[scope_iterator];

        if (item.id == id)
        {
            // Prevent re-entry, otherwise we loop forever
            //  if we're matching the very first item in scope.
            if (!scope_iterator)
                scope_iterator = -1;

            shadows = ScopeItem_shadows(item);
            return item.target;
        }
    }

    return Target;
}


////////////////////////////////

pub fn Scope_snap(scope: Scope, implicit _helpers: Helpers[])
    ScopeMemo(
        items_len:    scope.items   .len,
        imports_len:  scope.imports .len,
        usings_len:   scope.usings  .len,
        converts_len: scope.converts.len,
        helpers_len:       _helpers .len);

pub fn Scope_pop(ref scope: Scope, implicit ref _helpers: Helpers[], memo: ScopeMemo)
{
    scope.items   .shrink(memo.items_len);
    scope.imports .shrink(memo.imports_len);
    scope.usings  .shrink(memo.usings_len);
    scope.converts.shrink(memo.converts_len);
    _helpers      .shrink(memo.helpers_len);
}

fn cmp(a: ScopeMemo, b: ScopeMemo)
    a.items_len     - b.items_len     ||
    a.imports_len   - b.imports_len   ||
    a.usings_len    - b.usings_len    ||
    a.converts_len  - b.converts_len  ||
    a.helpers_len   - b.helpers_len;

pub fn  >(a: ScopeMemo, b: ScopeMemo) cmp(a, b)  > 0;
pub fn  <(a: ScopeMemo, b: ScopeMemo) cmp(a, b)  < 0;
pub fn ==(a: ScopeMemo, b: ScopeMemo) cmp(a, b) == 0;


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,
    flags!: i32,

    min?:           i32,
    max?:           i32,
    args?:          Argument[],
    template?:      Template,
    solved?:        SolvedNode,
    local_of?:      i32,
    name?:          string,
    status?:        u32): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    let item = Overload(
        name: name || id || throw("Falsy Scope_add(id)."),
        :kind, :flags, :type,
        :min, :max, :args,
        :template, :solved,
        :local_of,
        :status);

    scope.overloads.push(item);

    if (id)
    {
        let shadows = !!(flags & F_SHADOW);
        Scope_set(:scope, :id, :target, :shadows);
    }

    return target;
}

pub fn Scope_create(
    scope: &mut Scope,
    kind = "_no_kind_yet_", name?!: string,
    type?: Type, flags?!: i32,
    min?!: i32, max?!: i32, args?: Argument[],
    solved?: SolvedNode, local_of?!: i32,
    status?: u32,
    extra_items?: ScopeItem[]): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: scope.overloads.len + 1);

    mut item: Overload;

    item.name           = name;
    item.kind           = kind;
    item.flags          = flags;
    item.type           = type;
    item.min            = min;
    item.max            = max;
    item.args           = args;
    item.solved         = solved;
    item.local_of       = local_of;
    item.status         = status;
    item.extra_items    = extra_items;

    scope.overloads.push(item);

    return target;
}

pub fn Scope_set(ref scope: Scope, id: string, target: Target, shadows!: bool)
{
    Scope_set(:scope.items, :id, :target, :shadows);
}

pub fn Scope_set(ref items: ScopeItem[], id: string, target: Target, shadows!: bool)
{
    items.push(ScopeItem( :id, :target, :shadows ));
}

pub fn Scope_Typedef(scope: &mut Scope, id: string, type: Type, flags = F_PUB, template?: Template, name?: string,
    status?: u32)
{
    return Scope_add(:scope, "type", :id, :name, :type, :flags, :template, :status);
}


//

pub fn listGlobals(implicit module: Module): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  "i8",    t_i8    );
    Scope_Typedef(scope, "i16",    t_i16   );
    Scope_Typedef(scope, "i32",    t_i32   );
    Scope_Typedef(scope, "i64",    t_i64   );

    Scope_Typedef(scope,  "u8",    t_u8    );
    Scope_Typedef(scope, "u16",    t_u16   );
    Scope_Typedef(scope, "u32",    t_u32   );
    Scope_Typedef(scope, "u64",    t_u64   );

    Scope_Typedef(scope, "f32",    t_f32   );
    Scope_Typedef(scope, "f64",    t_f64   );

    Scope_Typedef(scope, "bool",   t_bool  );
    Scope_Typedef(scope, "byte",   t_byte  );
    Scope_Typedef(scope, "void",   t_void  );
    Scope_Typedef(scope, "never",  t_never );

    return scope;
}
