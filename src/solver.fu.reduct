import ansi;
import lifetime;
import module;
pub fn solve(): SolverOutput {;;

    struct Flow
    {
        rg_invalidates:     [];
    };

    struct CurrentFn
    {
        using flow?:        Flow;
    };

    lax mut _current_fn:        CurrentFn;

    fn PASS_borrowCheck() {
        fn flow         = _current_fn.flow;

        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime) lifetime.Lifetime_each: |locid!write, paths!write_paths|
            lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
