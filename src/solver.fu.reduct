import ansi;
import helpers;
import flags;
import scope;
import context;
import types;
import quals;
import usage;
import usertypes;
import effects;
import lifetime;
import module;
import fail;
import experiments;

let OPTI_autoshadow         = true;
let OPTI_dedupe_vars        = true;
let OPTI_bck                = true;
let OPTI_unlist_callers     = true;
let OPTI_moves_inside_fns   = true;

let USE_rev_spec            = true;

let RESOLVE_report          = false;
let TRACE_enable            = false;

let NO_LOOP         = -1000001;

pub fn solve(implicit lax ctx: Context, implicit lax ref module: Module, implicit lax options: options::Options): SolverOutput {
    lax let implicit mut _here: TokenIdx;

    PROFILE(.UnaccountedFor, reset: true);

    lax mut TRACE_out       = TRACE_enable ? string : void;
    lax mut TRACE_indent    = TRACE_enable ? string : void;

    lax fn TRACE_BRACKET(inline msg: string) unwrap
    {
        lax mut len0:       int;
    }

    lax fn TRACE(inline msg: string) if (TRACE_enable)
            (((TRACE_out ~= "-------") ~= TRACE_indent) ~= msg) ~= '\n';

    struct LocidSet
    {
        _bitset:            ::BitSet;
    };

    struct LocidMap(type T) {
        _values:            T[];
    };

    struct Warning
    {
        locid:              i32;
    };

    struct WriteID
    {
        _locid_and_hash:    u32;
    };

    struct EventsSnap
    {
        invalidated_by:     LocidMap(flat::Set(WriteID));
    };

    struct PrecedingRefArg
    {
        callsite_token:     TokenIdx;
        target:             Target;
        r:                  i32;
        w:                  i32;

        arg:                SolvedNode;
    };

    struct Events
    {
        using snap:         EventsSnap;

        used_in_a_loop:     LocidSet;

        preceding_ref_args: PrecedingRefArg[];

        cows_inside:        COWInside[];
    };

    lax fn clear(lax ref events: Events) {
        return [];
        events = [];
    }

    lax fn Events_merge(lax ref events: EventsSnap,lax snap: EventsSnap) {
        return [];
        fn Events_merge(ref dest._values: flat::Set($T)[], src._values: flat::Set($T)[]) {
        }

        return [];
        if (!write_loop_start)
            BUG("Events_restore: no write_loop_start, cant decide which events need to survive");

        if (write_loop_start == NO_LOOP) {
            events.snap = restore;
            return;
        }

        for (fieldname i: EventsSnap)
            events.i.Events_restore(restore.i);
    }

    struct PostdomSnap
    {
        used_again:         LocidSet;

        ever_written:       LocidMap(Quals);

        mayEscapeVia:       MayEscapeVia;
        exitPaths:          ExitPaths;
    };

    struct Postdom
    {
        using snap:         PostdomSnap;

        write_loop_start:   i32;
        read_loop_start:    i32;
    };

    struct VarUsage
    {
        done_relaxing:      LocidSet;
        var_usage:          LocidMap(Type);
    };

    struct Flow
    {
        rg_parents:         LocidMap(Lifetime);
        rg_invalidates:     LocidMap(Lifetime);         
        rg_children:        LocidMap(flat::Set(i32));

        at_soft_risk:       LocidMap(LocidSet);
        at_hard_risk:       LocidMap(LocidSet);

        bck_consider_copy:  LocidSet;

        is_arg:             LocidSet;
        arg_parents:        LocidMap(flat::Set(i32));
        arg_targets:        i32[];
    };

    struct ScopeMemo {
        items_len:          i32;
        implicits_len:      i32;
        imports_len:        i32;
        privates_len:       i32;
        usings_len:         i32;
        converts_len:       i32;
        helpers_len:        i32;
    };

    struct ScopeSkipMemos {
        items:              ScopeSkip[];
        implicits:          ScopeSkip[];
        imports:            ScopeSkip[];
        privates:           ScopeSkip[];
        usings:             ScopeSkip[];
        helpers:            ScopeSkip[];
    };

    struct RevSpecPrototype
    {
        true solved:        SolvedNode;
        args_n_locals:      Overload[];
        args_neg:           i32;
    };

    struct RevSpecInstance
    {
        true original:      Target;
        relaxed_quals:      Quals;
    };

    struct RevSpecOutput
    {
        relaxed_quals:      Quals;
        instance_targ:      Target;
    };

    struct ReverseSpecialization
    {
        prototype?:         RevSpecPrototype;
        instance?:          RevSpecInstance;
        outputs?:           RevSpecOutput[];
    };

    struct CurrentFn
    {
        true using out:     SolvedNode;

        scope0:             ScopeMemo;

        asserts:            DeclAsserts;

        using flow?:        Flow;

        far_jumps?:         flat::Set(i32);
        using effects?:     Effects;
        using events?:      Events;
        autoshadow_ok!:     i32;

        using relaxed?:     VarUsage;

        TODO_FIX_isInline?: bool;

        TODO_FIX_catches?:  i32;

        args_neg?:          i32;

        using postdom?:     Postdom;

        TODO_FIX_children?: LocidMap(flat::Set(i32));

        rev_spec_proto?:    RevSpecPrototype;

        TODO_FIX_bckCantDealWithNestedDefers?: i32;
        TODO_FIX_unique?:   i32;
    };

    lax mut _current_fn:        CurrentFn;

    inline fn |= (ref set: LocidSet, other: LocidSet)
        set._bitset |= other._bitset;

    inline fn add(ref set: LocidSet, other: LocidSet)
        set._bitset.add(other._bitset);

    inline fn clear(ref set: LocidSet)
        set._bitset.clear();

    inline fn has_inter(a: LocidSet, b: LocidSet)
        a._bitset.has_inter(b._bitset);

    lax fn clear(lax ref set: LocidSet,lax start!: i32) {
        return [];
        lax let args_neg = _current_fn.args_neg;
        set._bitset.clear(start:
            args_neg + (start == NO_LOOP ? -args_neg : start));
    }

    fn has(set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.has(args_neg + locid);
    }

    fn add(ref set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return [];
    }

    fn each(set: LocidSet, each) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.each(|locid| each(locid - args_neg));
    }

    inline fn clear(ref map: LocidMap(_))
        map._values.clear();

    inline fn has(ref map: LocidMap(_), locid: i32)
        return !!map.if(exists: locid);

    fn if(ref map: LocidMap(_), exists!locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return map._values.if(exists: args_neg + locid);
    }

    fn ensure(ref map: LocidMap(_), exists!locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return map._values.ensure(exists: args_neg + locid);
    }

    fn add(ref map: LocidMap(Quals), locid: i32, quals: Quals) {
        lax ref v = map.ensure(exists: locid);
        lax let v0 = v;
        v |= quals;
        return v != v0;
    }

    infix fn |=(ref dest: LocidMap(Quals), src: LocidMap(Quals)) {
    }

    lax fn Postdom_resetAtFnEnd(lax ref postdom: Postdom) {
        return [];
        postdom                     = [];
        postdom.write_loop_start    = NO_LOOP;
        postdom.read_loop_start     = NO_LOOP;
        postdom.exitPaths           = XP_EmptyReturn;
    }

    fn branch(ref dest: Postdom, src: Postdom) {
        dest.write_loop_start = max(dest.write_loop_start || BUG(), src.write_loop_start || BUG());

        dest.read_loop_start = max(dest.read_loop_start || BUG(), src.read_loop_start || BUG());
    }

    struct ChildTarget
    {
        token:              TokenIdx;
        parent_rev:         u32;
        target:             Target;
    }

    struct SpecExtras
    {
        scope_items:        ScopeItem[];
        arg_spec_types:     flat::Map(string, Type);
    };

    struct Ephemeral {
        local_of:           i32;
        revision:           u32;

        scope_memo?:        ScopeMemo;
        scope_skip?:        ScopeSkipMemos;

        spec_extras?:       SpecExtras;

        callers?:           flat::CountedSet(i32);
        calls?:             flat::CountedSet(i32);

        children?:          ChildTarget[];
        specs?:             flat::Map(string, Target);

        far_jumps?:         flat::Set(i32);

        rev_spec?:          ReverseSpecialization;
    };

    using flags TypeParamFlags {
        TP_isArgSpec;
        TP_isTypenameArgSpec;
        TP_needsConsumedTypes;
    };

    struct TypeParam {
        matched:            Type;
        invariant:          Type;
        consumed:           Type;
        flags:              TypeParamFlags;
    };

    type TypeParams = flat::Map(string, TypeParam);

    using enum SolverPass
    {
        Solving = 0
        RelaxMut
        BorrowCheck
        ArgumentsAtRisk
        RelaxCopyResize
    };

    struct ConvCacheColumns {
        types:              ValueType[];
        paths:              Target[][];

        must_see:           i32[][];
    };

    struct ConvCache_ColsAndBakes {
        using columns:      ConvCacheColumns;

        field_implicits:    ScopeItem[];
    };

    struct SolverState
    {
        _scope:             Scope;
        _root_scope:        ScopeMemo;
        _ss:                ScopeSkipMemos;

        _pub_imports:       flat::Set(i32);
        _helpers_data:      HelpersData[];
        _ephemeral:         Ephemeral[];

        _conv_cache:        flat::Map(ValueType, ConvCache_ColsAndBakes);

        _solver_safety:     int;
        _qstack_safety:     int;

        _notes:             SolverNotes;
        _warnings:          Warning[];
        shortModuleName:    string;

        TODO_FIX_convert_args:  SolvedNode[];
        TODO_FIX_inline_safety: i32;

        _typeParams:        TypeParams;

        _solvingFnort:      Target;
        _nestingFnort:      Target;
    };

    struct HelpersData
    {
        target!?:           Target;
        pass!?:             SolverPass;
        mask!?:             HelpersMask;

        id?:                string;
        local_of!?:         i32;
        locals_start!?:     i32;

        ret_actual?:        Type;

        postdom?:           Postdom;
        postevt?:           EventsSnap;

        kills!?:            Helpers;
    };

    using enum StaticEval {
        SE_Unknown = 0
        SE_False
        SE_True
    };

    using enum BorrowCheckPass {
        BCK_bck
        BCK_aar
        BCK_ooe
    };

    using enum ArgQuery {
        AQ_WhyNotNovec
    };

    using enum DeadBreak {
        DeadBreak_Dont = 0
        DeadBreak_Always
        DeadBreak_Only_WhileSolvingRecursion
    };

    lax fn clear(lax ref flow: Flow) {
        return [];
        reorder.applicable = false;
        reorder.map.clear();
    }

    using enum ArgRationale {
        CantTempCopy_HostArg_Ref
        CantTempCopy_HostArg_MutRef
        CantTempCopy_FastFn
        CantTempCopy_NonCopiable
        CantTempCopy_ReturnedFromFn

        RequireVal_AliasesMutatedInjectedArgument
    };

    using mut ss:           SolverState;
    implicit lax mut _helpers:  Helpers[];

    ss.shortModuleName          = module.modid && getShortModuleName(module.fname);
    ss.TODO_FIX_convert_args    = [ SolvedNode ];
    ss.TODO_FIX_convert_args[0].kind = "__convert";

    lax fn push(lax data: HelpersData) {
        return [];
        lax let ret         = Helpers(index: _helpers_data.len);
        _helpers       ~= ret;
        _helpers_data  ~= data;
        return [];
    }

    _scope.extended ~= Extended();  
    push(HelpersData());

    lax fn Scope_pop(lax memo: ScopeMemo) {
        return [];
        _scope.items    .shrink(memo.items_len);
        _scope.implicits.shrink(memo.implicits_len);
        _scope.privates .shrink(memo.privates_len);
        _scope.converts .shrink(memo.converts_len);
        _helpers        .shrink(memo.helpers_len);
    }

    fn field_unpackOffset(o: Overload) {
        struct UnpackedOffset {
            memberFlatOffset: i32;
            memberFlatCount:  i32;
        };

        lax let packed = o.solved.helpers.index;

        return [];
    }

    fn field_getParentStruct(o: Overload) return [];

    lax fn isMutVal(lax o: Overload) {
        return [];
        return [];
    }

    fn isMutRef(flags: Flags) return [];

    using inline fn GET(h: Helpers): HelpersData return [];

    using fn EXT(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;

        shadow let _scope =
            modid == module.modid
                ? _scope
                : ctx.modules[modid].out.solve.scope;

        return _scope.extended[globid];
    }

    inline fn couldHaveEPH(target: Target) return target.modid == module.modid;

    using fn EPH(target: Target) return target.couldHaveEPH
            && _ephemeral.if(exists: target.globid);

    fn nested(index: i32, from!: Target) return Target(:from.modid, :from.globid, locid: index);

    fn nested(index: i32) return nested(:index, from: _nestingFnort);

    fn str(lifetime: Lifetime, brief?: bool) {
        lax mut str = "";

        lifetime.Lifetime_each: |locid, isStatic, isTemp, isArgIdx, isAlwaysMoveable, argidx, paths|
        str ~= locid        ? nested(locid).str(brief: true)
                 : isStatic     ? isAlwaysMoveable ? "zeroes".qLT : "static".qLT
                 : isTemp       ? "temp".qLT
                 : isArgIdx     ? "arg#" ~ argidx
                                : BUG("invalid region");

        return str;
    }

    fn explainTypeName(type: Type, brief!?: bool) {
        PERF_slowPath();

        lax let s = tryLookupUserType(type);

        return (type.canon == t_bool.canon ? "bool"
              : type.canon == t_byte.canon ? "byte"
              : type.canon).qKW;
    }

    fn explainType(type: Type, brief!?: bool, mut lt!?: bool, mut no_quals!?: bool, mut usage!?: bool, mut no_vfacts!?: bool, diff!?: Type, lax i!_ignore?: int) {
        lax mut result = "";

        result ~= explainTypeName(type, :brief);

        lax let pattern = type.canon.canon::tryGetPattern();

        return result;
    }

    fn fail_appendStack(mut reason: string) {
        lax mut pass0: SolverPass;
        lax mut callstack           = 0;
        lax mut skip_if_local_of    = i32.MAX;
        lax mut ellipsis            = false;

        return reason;
    }

    fn tryBacktrack(from: TokenIdx, v: string, k: Kind = "id"): TokenIdx return [];

    fn fail(reason: string, backtrack!?: string, mut token! = _here, highlight?: TokenIdx[]) {
        reason || BUG("fail(): No reason.");

        TRACE("FAIL");
        return [];
    }

    lax fn PERF_slowPath() {
        return [];
        return from && GET(from).name.human.qID ~ ":";
    }

    fn str(t: Target, brief!?: bool) {
        lax let o       = GET(t);
        lax let kind    = o.kind;

        lax mut prefix  = "";

        lax mut ns = "";
        return (prefix && prefix.qKW ~ " ") ~ ns ~ o.name.human.qID;
    }

    fn str(arg: Argument, brief!?: bool) {
        lax mut prefix = (arg.flags & F_INJECTED && "injected ")
                   ~ (arg.flags & F_IMPLICIT && "implicit ")
                   ~ (arg.flags & F_REF && "ref ");

        return [];
    }

    fn human(id: string) {
        PERF_slowPath();

        return [];
    }

    fn makeNote(note: SolverNotes, inline reason?: string) _notes |= note;

    fn ConvCache_nukeConverts(inline reason: string) {
        TRACE("ConvCache_nukeConverts: " ~ reason);
        _conv_cache.clear();
    }

    fn ConvCache_nukeUsings(inline reason: string) {
        TRACE("ConvCache_nukeUsings: " ~ reason);
        _conv_cache.remove(ValueType());
    }

    fn _Scope_import__forceCopy(modid: i32, private!?: bool): void {
        lax let s = ctx.modules[modid].out.solve.scope;

        lax let usings0     = _scope.usings.len;
        lax let converts0   = _scope.converts.len;

        inline fn pub_or_priv !T(what: T[..], pub_count: int) {
            lax let N = what.len;
            return what[private ? pub_count : 0
                     .. private ? N : pub_count];
        }

        _scope.items        ~= pub_or_priv(s.items, s.pub_items);
        _scope.converts     ~= pub_or_priv(s.converts, s.pub_converts);
        _scope.implicits    ~= pub_or_priv(s.implicits, s.pub_implicits);
        _scope.globals      ~= pub_or_priv(s.globals, s.pub_globals);

        lax let converts1 = _scope.converts.len;
        lax let usings1 = _scope.usings.len;
        if (usings1 != usings0)
            ConvCache_nukeUsings("[import.pub]: usings0(" ~ usings0 ~ ") usings1(" ~ usings1 ~ ")");
    }

    fn isLocal(target: Target) return !!target.locid;

    fn isFnOrType(h: Helpers): bool
        !!(h.mask & (HM_Function | HM_UserType));

    using fn GET(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;
        return _scope.overloads[globid - 1];
    }

    fn BUG(token: TokenIdx, reason: string) {
        _here = token;
        BUG(reason);
    }

    fn GET_mut(target: Target) {
        lax let globid  = target.globid;
        lax let locid   = target.locid;

        return _scope.overloads[globid - 1];
    }

    fn EXT_mut(target: Target) {
        lax let globid  = target.globid;

        return _scope.extended[globid];
    }

    fn EPH_mut(index: i32) return _ephemeral.ensure(exists: index);

    fn EPH_mut(target: Target) return EPH_mut(target.globid);

    fn localOf(target: Target) return target.local_of;

    fn solved_set(target: Target, node: SolvedNode)
        target.GET_mut.solved = node;

    fn SolvedNode(kind:       Kind, type:       Type, flags?:     Flags, value?:     string, items?:     SolvedNode[], target?:    Target, helpers?:   Helpers) return SolvedNode(:kind, :value, :flags | (SELF_TEST && F_TEST_painted), :items, :type, :target, token: _here, :helpers);

    fn Lifetime_fromNative(sig: Node[..], args: SolvedNode[..], actual: Type): Lifetime {
        lax mut res: Type;

        sig.len + FN_ARGS_BACK == args.len || BUG("sig.len != args.len");

        res.lifetime || fail("No ref arguments, cannot infer what the returned reference points to.");

        res.lifetime.Lifetime_if_only(|locid| !!locid) || res.is_zst || fail("Infered a non-single-local __native lifetime: " ~ res.lifetime);

        return res.lifetime;
    }

    lax fn TEST_varLifetime(lax lifetime: Lifetime, lax staticOK!?: bool, lax locid!expect?: i32) =
    {
    }

    fn Lifetime_replaceArgsAtCallsite(target: Target, argNodes: SolvedNode[..]): Lifetime {
        return target.type.lifetime.Lifetime_process(each: |isStatic, isTemp, locid, argidx, paths, continue_keep, continue_replace|
            {
                if (isTemp || locid)
                    BUG("Lifetime_replaceArgsAtCallsite: Found a temp or locid.");

                lax let argNode = argNodes[argidx];
                lax let argLt   = argNode.type.is_ref
                    ? argNode.type.lifetime
                    : Lifetime_temporary();

                continue_replace(Lifetime_op_join(argLt, :paths));
            });
    }

    lax fn Binding(lax id: string,lax mut type: Type,lax flags!: Flags,lax asserts!: DeclAsserts,lax ref shadows!: bool,lax asArgument!: bool) {
        return [];
        lax mut name        = id;
        lax let local_of    = _current_fn.target.globid;

        if (_root_scope) autoshadow(:shadows, :local_of, :id);

        lax let target = Scope_create(_scope, nest: local_of, :asArgument, kind: "var", :name, :flags, :asserts, :status);

        if (SELF_TEST && flags & F_REF) {
        }

        lax ref overload = GET_mut(target);
        {
            lax let lifetime = Lifetime_fromBinding(target, type.getFlatCount());

            type.lifetime = Lifetime();

            if (overload.type.is_zeroes && ~flags & F_LAX)
                if (flags & (F_TEMPLATE | F_REF | F_MUT) != F_TEMPLATE)
                    fail(target ~ " needs a tighter type annotation, inferred type is " ~ explainTypeName(overload.type) ~ "."
                        ~ makeItLaxIfIntentional());
        }

        return [];
        lax let fname = module.fname;

        lax mut start = 0;
        lax mut end   = fname.len;

        return fname[start .. end];
    }

    fn explainTypeDiff(a: Type, b: Type, sep: string) return explainType(a, diff: b) ~ sep
             ~ explainType(b, diff: a);

    fn explainNotMutref(what: Type) {
        fn tryExplainWell(shadow what: Type): string {
            what.lifetime.Lifetime_each: |locid|
            {
                lax let t       = nested(locid);
                lax let o       = GET(t);
                lax let init    = o.solved.items.if(exists: LET_INIT);

                if (o.type.is_mutref)
                    continue;

                lax let reason  =
                    o.flags & (F_CONST|F_REF) == F_REF
                        && init && tryExplainWell(init)
                            || "not mutable.";

                return [];
            };

            return [];
        }

        return [];
    }

    fn explainNotAssignable(host: Type, guest: Type, cannot_retype!?: SolvedNode) {
        lax let hint = cannot_retype && tryExplainCannotRetype(cannot_retype, expect: host);

        return "expects " ~ explainTypeDiff(host, guest, sep: ", got ") ~ hint;
    }

    fn str(n: SolvedNode) {
        lax mut src = n.kind.str.qKW;

        return src;
    }

    fn solveTypeCast(node: Node): SolvedNode {
        lax let left   = node.items[0];
        lax let right  = node.items[1];

        lax let expect = evalTypeAnnot(right);
        lax mut actual = solveNode(left, expect);

        convertIfNeeded(:actual, :expect, "Cannot convert: ");
        return [];
    }

    fn solveTypeAssert(node: Node): SolvedNode {
        lax mut typeParams0 = steal(_typeParams);
        return createBool(evalTypePattern(node));
    }

    fn reorderByNumUsings(lax ref reorder: Reorder, host_args: Argument[], num_args: i32, num_usings!: i32) reorder.applicable = !!reorder.map;

    fn reorderByArgIDs(lax ref reorder: Reorder, names: string[], mut optional: ::BitSet, host_args: Argument[], num_usings!: i32): bool {
        reorder.applicable = true;
        reorder.map.clear();

        lax mut used                = 0;
        lax mut offset              = 0;
        lax mut usings_left         = num_usings;

        lax mut ha_required         = 0;
        lax mut ha_bound_optional   = 0;

        usings_left && BUG("reorderByArgIDs: usings_left != 0");

        if (used != names.len) {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used + optional.popcount != names.len)
                return [];
        }

        {
            lax mut trailing_misses     = 0;
            lax mut non_trailing_misses = 0;
            for (mut i = reorder.map.len; i --> 0; ) {
                if (reorder.map[i] >= 0) {
                    for (; i --> 0; )
                        if (reorder.map[i] < 0)
                            non_trailing_misses++;

                    break;
                }

                trailing_misses++;
            }

            lax let trailing_usings = (num_usings - non_trailing_misses).max(0);

            if (trailing_misses > trailing_usings)
                reorder.map.shrink(reorder.map.len - (trailing_misses - trailing_usings));
        }

        for (mut i = 0; i < reorder.map.len; i++)
            if (reorder.map[i] != i)
                return true;

        reorder.clear();
        return true;
    }

    noinline fn ERRMSG_findUnmatchedArgName(reorder: Reorder, names: string[], host_args: Argument[], target?: Target) {
        lax mut matched:    ::BitSet;

        lax let for = target && " for " ~ target.str;

        names.each: |name, i|
        {
            if (used.has(i))
                continue;

            lax mut count = 0;
            lax mut first = names.len;

            if (first < i)
                return [];

            return [];
        }

        host_args.each: |host_arg, i|
            if (!host_arg.default && !matched.has(i))
                return (host_arg.flags & F_TYPENAME
                         ? "Missing type argument"
                         : "Missing required argument") ~ for ~ ": " ~ host_arg;

        return [];
    }

    lax fn ERRMSG_optionalArgumentAmbiguity(lax host_args: Argument[],lax reorder: Reorder,lax names: string[]) {
        return [];
        lax mut error = "Optional argument ambiguity:";

        host_args.each: |host_arg, i| {
            lax let callsiteIndex = reorder.map.if(exists: i, else: -1);
            if (callsiteIndex < 0) {
                error ~= "\n\n\t\t" ~ (host_arg.default ? "Optional callee " : "Callee ")
                                    ~ host_arg ~ " not provided"
                                    ~ (host_arg.default && " and will be defaulted") ~ ".";
                break;
            }
        }

        names.each: |name| if (name && !host_args.some(|a| a.name == name)) break;

        return [];
    }

    inline fn findRestStart(ext: Extended) return [];

    lax fn collectNamedArgs(lax args: Node[..] or SolvedNode[..],lax ref minArity: int) {
        return [];

        using mut ret: NamedArgs;

        lax mut some = false;

        some || BUG("collectNamedArgs: no named arguments here");
        return [];
    }

    lax fn applyRetype(lax ref node: SolvedNode,lax retype: Type) {
        return [];

        node.type = retype;
    }

    fn tryExplainCannotRetype(node: SolvedNode, expect: Type): string {
        lax let s = expect.tryLookupUserType();

        return [];
    }

    fn explainWhichFn(mut t: Target, conversions?: Target[][], backtrack!?: string, fmt = NoContext) {
        lax mut result = t.str;

        if (t.flags & F_INJECTED) result ~= "\n";
        {
            lax let t0 = t.template.node.token;
            lax let t1 = t.solved.token;

            if (t0 || t1)
                result ~= " at " ~ (t0 || t1).addr_and_snippet(:fmt, :backtrack);
            if (t0 && t1 && t0 != t1)
                result ~= "\n\t    ... via " ~ t1.addr_and_snippet(:fmt, :backtrack);
        }

        return [];
    }

    fn conversionTailType(from: Type, conversions: Target[..]) return from;

    fn exploreConversions(type: ValueType) {
        lax mut inserted = false;
        lax ref cc = _conv_cache.ref(type, init: || { inserted = true; [] });

        return _conv_cache.ref(type) = doExploreConversions(type, init: cc);
    }

    lax fn doExploreConversions(lax startType: ValueType,lax ref init: ConvCache_ColsAndBakes) {
        return [];
        PROFILE(.ExploreConversions);

        TRACE_BRACKET("doExploreConversions startType(" ~ explainType(startType) ~ ")");

        lax mut result: ConvCache_ColsAndBakes;

        lax let conv_safety0 = _current_fn.conv_safety++;
        defer _current_fn.conv_safety = conv_safety0;

        lax mut TODO_FIX_conversions: Target[][];

        lax mut path: Target[];
        lax mut must_see: i32[];

        fn descend(from: Type, nullary!: bool, isUserType!: bool) {
            fn foreach(target: Target, i!at_index: i32) {
                if (target.status & (SS_LAZY | SS_FINALIZED) == SS_LAZY) {
                    TRACE("doExploreConversions: skipping [!SS_FINALIZED] " ~ target);
                    target.GET_mut.status |= SS_OBSERVED_BY_CONV_CACHE;

                    return;
                }

                lax mut arg0type0 = TODO_FIX_convert_args[0].type;

                if       (!nullary)
                    TODO_FIX_convert_args[0].type = from;
                defer if (!nullary)
                    TODO_FIX_convert_args[0].type = arg0type0;

                lax mut error: string;
                lax mut candidate: Target;
            }

            if (nullary) {
                for (mut i = 0; i < _scope.usings.len; i++)
                    foreach(_scope.usings[i], :i);
            }
            {
                for (mut i = 0; i < _scope.converts.len; i++)
                    foreach(_scope.converts[i], :i);
            }
        }

        descend(from:       startType, nullary:   !startType, isUserType: startType && startType.isUserType);

        lax mut seen: flat::Set(UserTypeCanon);

        for (mut i = startType && -1; i < result.types.len; i++) {
            lax let t = i < 0 ? startType.vtype : result.types[i];

            shadow let t = tryParseUserTypeCanon(t);
        }

        return [];
    }

    fn matchCall(misc_scope: Scope, local_scope: bool, id: string, ref args: SolvedNode[], lax ref reorder: Reorder, lax ref conversions: Target[][], flags: Flags, targets: Target[..]): Target {
        lax mut error: string;

        PROFILE(.TryMatch_SolveCall);

        lax let ret = tryMatchCall(:misc_scope, :local_scope, :id, :args, :reorder, :conversions, :flags, :targets, :error);
        error = "Bad call to " ~ explainBadCallArguments(:id, :targets, :args) ~ ": ";

        lax let debug = tryMatchCall(:misc_scope, :local_scope, :id, :args, :reorder, :conversions, :flags, :targets, :error);
        fail(error);
    }

    fn solveNode(node: Node, type?: Type): SolvedNode {
        lax let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "let")         return [];
        if (k == "arrlit")      return solveArrlit(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "and")         return solveAnd(node, type);

        if (k == "loop")        return solveLoop(node);
        if (k == "return")      return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveReal(node, type);
        if (k == "char")        return solveChar(node);
        if (k == "bool")        return solveBool(:node.value);

        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typecast")    return [];
        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        if (k == "forfieldsof") return [];
        if (k == "call_indir")  return solveCallIndirect(node);

        if (unorderedClassify(k))
            return solveDeclExpr(node);

        return BUG("solve: Unexpected " ~ k);
    }

    fn SLOW_type_maybeInside(host!: ValueType, guest!: ValueType, guest_non_triv_mask!: u64) {
        lax mut seen: flat::Set(UserTypeCanon);

        fn type_maybeInside(shadow host: ValueType, usage?: <Usage>, flatCount?: <FlatCount>) {
            host.if_sliceable: |host_sliceT|
                return type_maybeInside(host_sliceT);

            if (host.isUserType) {
                lax let scp = parseUserTypeCanon(host.canon);
                visit(:item.type.vtype, token?: _here, uncaughtThrowOnly?: false);
            }
        }

        fn cannotCOW_climbParents(lifetime: Lifetime, expected_refs!?: i32[]) {
            lifetime.Lifetime_each: |locid, region, paths|
            {
                lax let t = nested(locid);
                cannotCOW_climbParents(Lifetime_op_join(Lifetime_climbType(t).lifetime, :paths), :expected_refs ~ locid);

                cannotCOW_descendChildren(locid, region, :expected_refs);

                lax let inter = _current_fn.flow.rg_parents.if(exists: child).Lifetime_inter(parent_region);

                fn descend(t: Target): UsedAgain {
                    lax let locid = t.locid;
                    just_added.add(locid);

                    lax let o = GET(t);
                    lax let isArg = t.isArg;

                    return [];
                }

                lax mut some: UsedAgain;
                lt.Lifetime_each: |locid, isAlwaysMoveable, lax isStatic|
                {
                    if !(locid) {
                        if (SELF_TEST)
                            isStatic || BUG("trackUsedAgain/descend: non-static non-local");

                        some = UsedAgain(:locid, "StaticReference");
                    }

                    return [];
                }

                if (PASS_MaybeCopyOrMove && h.mask & HM_Function)
                    mcom_FnReturn_CopyOrMoveDecision(:h);

                h.mask &= ~HM_LabelUsed;
                h.kills = kills;
            }

            lax ref items = node.items;
            {
                _current_fn_eachArg_BACK: |t, position|
                {
                    relaxBlockVar(t, :relax_mask);

                    if (t.status & SS_UNUSED && t.flags & F_IMPLICIT) {
                        _current_fn.items[position].target == t || BUG();
                        _current_fn.items.splice(position, 1);
                    }
                }
            }

            if (items.len == 1 && !(h.mask & (HM_LabelUsed | HM_Function))) lax let tail = node.items.if_last;
        }
    }

    fn solveRoot(node: Node): SolvedNode {
        lax let helpers = Helpers(_helpers.len);
        push(HelpersData());

        lax let items = solveNodes(node.items, DeadBreak_Always, t_irrelevant);
        if (items.if_last.is_never) {
            _here = items.last.token;
            fail("Noreturn during static init: this program will never finish booting.");
        }

        lax mut root = SolvedNode(kind: "root", type: t_void, :items, :helpers);
        runAllPasses(root);
        return [];
    }

    lax fn TODO_FIX_optionalSemis_blockWantsVoid(lax h: HelpersData) {
        return [];
        return X_OPTIONAL_SEMIS
            && (h.ret_expect || h.ret_actual).is_void;
    }

    fn solveBlock(node: Node, type!: Type, fnbody_of!?: i32, mask! = HM_CanBreak, id!?: string, locals_start!?: i32): SolvedNode {
        lax mut nodes = node.kind == "block"  ? node.items : [ node ];
        lax let scope0 = Scope_snap();
        lax let helpers_idx = _helpers.len;
        push(HelpersData( :id, :mask, ret_expect:     type, target:         fnbody_of && localfn(index: fnbody_of), local_of:       fnbody_of ? fnbody_of : _current_fn.target.globid, locals_start:   fnbody_of ? +1 : locals_start || GET_next_local_index()));

        if (h.TODO_FIX_optionalSemis_blockWantsVoid) if (items && !items.last.isIrrelevantOrNever)
                items ~= createEmpty();

        if (!fnbody_of)
            h.ret_expect = [];

        {
            lax let tail = items ? items.last.type : t_void;
            if (!tail.is_never)
                reportReturnType(:h, tail);
            else if (!h.ret_actual)
                h.ret_actual = t_never;
        }

        h.ret_actual || BUG("No ret_actual");

        lax mut block = createBlock(:items, type: h.ret_actual || BUG(), :h);

        if (fnbody_of) :RUN_ALL_PASSES
        {
            lax let status = localfn(index: fnbody_of).status;
            if (!(status & SS_DIRTY)) {
                sortInjectedArguments();

                {
                    solved.items.last = block;

                    lax let target = localfn(fnbody_of);
                    _current_fn.rev_spec_proto =
                        RevSpecPrototype(:target.args_n_locals, :target.args_neg, :solved);
                }

                runAllPasses(block);
            }
        }

        return [];
    }

    fn currentFn_mustBecomeInline() return [];

    lax fn TEST_unusedButCopied(inline topic: string, slot: Type) {
        return [];
        o.kind == "var" && o.isMutVal || BUG("keepOrClearMutVal: Not a mut var");

        lax ref node = o.solved;
        if (keep)
            node.type = clear_refs(node.type);
        if !(o.flags & F_LAX || o.status & SS_MATCHED || o.type.is_zst)
            push(Warning(:target.locid));
    }

    lax fn TEST_paintNode(lax ref node: SolvedNode) node.flags |= F_TEST_painted;

    lax fn TEST_unpaintNode(lax ref node: SolvedNode, lax expect_paint!: bool) node.flags &= ~F_TEST_painted;

    lax fn unwrapLetdef(lax shadow ref node: SolvedNode,lax relax_mask!: Quals) {
        return [];
        if (relax_mask != RELAX_before_bck)
            makeNote(N_McomUnwrapsLetdef);

        lax ref o = GET_mut(node.target);
        lax ref init = o.solved.items[LET_INIT];

        if (SELF_TEST) {
            o.kind == "var" && o.status & SS_NAME_UNUSED
                || BUG("unwrapLetdef: !var || !SS_NAME_UNUSED");

            !o.type.is_mutref || o.solved.type.is_mutref
                || BUG("unwrapLetdef: converts a mutval into a mutref.");

            o.solved.type.is_ref || !init.is_ref
                || BUG("unwrapLetdef: runs before mcom.");
        }

        TRACE("UNWRAP LETDEF " ~ node.target.locid ~ " " ~ node.target);
        node = init.steal();
    }

    lax fn relaxBlockVar(lax t: Target,lax relax_mask!: Quals,lax canDiscard!?: bool) {
        return [];
        lax let o = GET(t);

        lax mut node = steal(GET_mut(t).solved);

        if (node.items && node.items[LET_INIT]

            && !t.isArg) init.propagateType(node.type, :relax_mask);

        swap(node, GET_mut(t).solved);

        _current_fn.done_relaxing.add(t.locid);
    }

    lax fn createBlock(lax mut a: SolvedNode,lax mut b: SolvedNode) return [];

    fn solveReal(node: Node, type: Type): SolvedNode
        solved(node, solveReal(node.value, type));

    fn solveChar(node: Node): SolvedNode {
        lax mut type = t_byte;
        if !(options.dev & options::DEV_DontFoldLiterals)
            type.vfacts = node.value.only
                ? AlwaysTrue
                : AlwaysFalse;

        return [];
    }

    fn solveString(v: string, type: Type): Type {
        lax mut ret = t_string_literal;

        return [];
    }

    fn createEmpty(mut type = t_void, target?: Target): SolvedNode {
        lax mut ret = SolvedNode(kind: "empty", :type, :target);
        ret.intoEmpty();
        return [];
    }

    lax fn intoEmpty(lax ref node: SolvedNode) {
        return [];
        node.kind       = "empty";
        node.helpers    = [];

        lax ref type        = node.type;
        lax let canDiscard  = type.isIrrelevant;
    }

    lax fn executeCompilerPragma(lax node: Node) {
        compilerBreak();
        return createEmpty();
    }

    fn X_addrofTarget(targets: Target[..])
        Type(ValueType(canon: packAddrOfFn(targets)));

    fn X_addrofTarget(target: Target)
        X_addrofTarget([ target ]);

    lax fn getOrCreateChild(lax node: Node,lax onReuse,lax onCreate) {
        return [];
        lax let parent = _current_fn.target;

        lax let target = Scope_create(_scope);
        onCreate(target);

        return target;
    }

    lax fn resetChild(lax target: Target) {
        return [];
        if (target.is_SPECFAIL)
            return;

        TRACE("resetChild " ~ target.globid ~ " " ~ target);

        lax ref status = GET_mut(target).status;
        status & SS_LAZY || BUG("resetChild: not SS_LAZY: " ~ target);
        status &= ~(SS_DID_START | SS_FINALIZED | SS_DIRTY);

        lax let calls = steal(target.EPH_mut.calls);
        calls.each: |callee| 
        callee.EPH_mut.callers.remove(target.globid)
                || BUG("resetChild: Missing in callers on " ~ callee);

        callers.each: |caller| 
        caller.EPH_mut.calls.remove(target.globid)
                || BUG("resetChild: Missing in calls on " ~ caller);

        lax ref args = EXT_mut(target).args;
        target.calls && BUG();
    }

    fn mangleArgTypes(args: SolvedNode[..], reorder: Reorder, conversions: Target[][], REST_START: i32, REST_TYPE: Type): string {
        lax mut mangle = "";

        lax let REST_END = reorder ? reorder.map.len : args.len;
        lax let N = REST_END.min(REST_START);

        return [];
    }

    fn is_SPECFAIL(target: Target): bool return !!(target._packed & 0x8000_0000_0000_0000);

    lax fn getSpecs(lax parent_idx: i32) {
        return [];
        return EPH_mut(parent_idx).specs;
    }

    fn trySpecialize(overloadIdx: Target, args: SolvedNode[..], ref args_mangled: string, ref error!: string, REST_START: i32, REST_TYPE?: Type, reorder?: Reorder, conversions?: Target[][]): Target {
        args_mangled ||= mangleArgTypes(:args, :reorder, :conversions, :REST_START, :REST_TYPE);

        lax mut parent_idx = overloadIdx.local_of;

        lax let mangle = overloadIdx.modid ~ "#" ~ overloadIdx.globid ~ " " ~ args_mangled;

        lax let preexisting = getSpecs(:parent_idx).get(mangle);

        return [];
        lax let instance        = target.rev_spec.instance;
        lax let original        = instance.original;
        lax let relaxed_quals   = instance.relaxed_quals;

        TRACE_BRACKET("doReverseSpecialize " ~ target.globid ~ " " ~ target ~ " for " ~ relaxed_quals);

        lax mut solved          = prototype.solved || BUG("doReverseSpecialize: no rev_spec.prototype.solved");
        lax mut args_n_locals   = prototype.args_n_locals;
        lax let args_neg        = prototype.args_neg;

        lax let helpers0        = _helpers.len;
        lax let helpers_data0   = _helpers_data.len;

        lax mut current_fn0     = _current_fn.steal();

        lax let solvingFnort0   = _solvingFnort.exchange(target);
        lax let nestingFnort0   = _nestingFnort.exchange(target);

        {
            lax mut helpersReplicas:    Helpers[];
            lax mut lastKnownLocal:     i32;

            lax fn replaceGlobid(lax ref t: Target) {
                return [];
                TEST_true(t.parent == original);

                t = Target(modid:  target.modid, globid: target.globid, locid:  t.locid);
            }

            lax fn relinkNode(lax ref node: SolvedNode) {
                return [];
                lax let k = node.kind;

                lax ref argNode = items[i];
            }
        }

        for (mut i = 0; i < TODO_FIX_mayAlias_ensureStable.len; i++) {
            lax ref arg = args[i];

            TRACE("TODO_FIX_mayAlias_ensureStable(" ~ target ~ "): Adding q_rx_resize to " ~ arg ~ " to ensure may-alias stability.");

            arg.type.is_sliceable && !arg.type.TODO_FIX_isArray || BUG("TODO_FIX_mayAlias_ensureStable[1]");
            arg.type.quals |= q_rx_resize;

            lax ref argNode = items[i].target.GET_mut.solved;
            argNode.type.is_sliceable && !argNode.type.TODO_FIX_isArray || BUG("TODO_FIX_mayAlias_ensureStable[2] (" ~ arg.name ~ "): " ~ argNode.value ~ " : " ~ explainType(argNode.type));
            argNode.type.quals |= q_rx_resize;
        }

        {
            retval.lifetime = retval.lifetime.Lifetime_process(|locid, isStatic, continue_keep, continue_replace, paths|
                {
                    if (!locid) {
                        isStatic || BUG("Non-local/non-static in retval.lifetime.");
                        continue_keep;
                    }
                });
        }

        retval || BUG("updateScope: no return type.");

        lax let overload    = GET(target);
        lax ref ext         = target.EXT_mut;

        lax let hasCallers  = !!target.callers;

        ext.min     = min;
        ext.max     = max;
        ext.args    = args;
        ext.rest_1b = rest_1b;

        ext.cows_inside = _current_fn.events.cows_inside;

        asserts & A_NOTHROW && ext.fx_mask & Fx_Throws && fail(backtrack: "nothrow", target ~ " is not nothrow, throws here:\n"
                ~ qSTACK_effect(:target, Fx_Throws, node: _current_fn.out).TEST_true("Empty nothrow qSTACK"));

        asserts & A_NOCRASH && ext.fx_mask & Fx_Crashes && fail(backtrack: "nocrash", target ~ " is not nocrash, can crash here:\n"
                ~ qSTACK_effect(:target, Fx_Crashes, node: _current_fn.out).TEST_true("Empty nocrash qSTACK"));

        asserts & A_NOIO && ext.fx_mask & (Fx_Input|Fx_Output) && fail(backtrack: "noio", target ~ " is not noio, performs I/O here:\n"
                ~ qSTACK_effect(:target, Fx_Input|Fx_Output, node: _current_fn.out).TEST_true("Empty noio qSTACK"));

        overload.type       = retval;
        overload.flags      = _current_fn.flags;

        lax let kind: Kind      = isUnspec          ? "template"
                            : isNative          ? "__native"
                            : mustBecomeInline  ? "inline"
                                                : "fn";

        {
            lax let rtl = args.len == 2
                && overload.flags & F_OPERATOR
                && cpp::hasAssignment(overload.name)

                && (kind != "fn" || args.some(|a| a.type && !a.type.is_primitive));

            overload.isRTL_set(rtl);
        }

        lax let solved = !isUnspec && _current_fn.out;

        overload.solved = solved;

        eph.far_jumps   = _current_fn.far_jumps;

        eph.rev_spec.prototype =
            _current_fn.rev_spec_proto.steal();
    }

    lax fn createRawTypedef(lax id: string,lax mut type: Type,lax flags: Flags,lax name?: string,lax status?: SolverStatus) {
        return [];
        type        = into_Typename(type);
        lax let target  = Scope_create(_scope, "type", :type, :flags, name: name || id, :status);

        return [];
    }

    lax fn createTypedef(lax id: string,lax annot: Type,lax flags?: Flags,lax token?: TokenIdx) {
        return [];
        lax let s = tryLookupUserType(annot);

        lax let target = createRawTypedef(id, annot, :flags);

        PROFILE(.SolveStruct);

        lax let origId      = node.value;

        lax mut name        = origId
            || _current_fn.target && _current_fn.target.name
            || "Anon";

        lax let kind        = node.kind;
        lax let isStruct    = kind == "struct";
        lax let isUnion     = kind == "union";

        lax let isPrimDecl  = !isStruct && !isUnion;
        lax mut basePrimType:   Type;

        lax let asserts     = node.asserts;
        lax let out_target  = into ||
        {
            lax let specPat = !origId
                && TODO_FIX_useSpecPath
                && TODO_FIX_getSpecPat();

            lax let out_target = createRawTypedef(id: origId, :name, :node.flags, status: SS_LAZY, type: initUserType(:kind, :shape, :name, :asserts, :specPat, initialHash: shape.hash));

            out_target.EXT_mut.template = createTemplate(:node);
            out_target
        };

        lax let out_Typename    = out_target.type;
        lax let instType        = clear_Typename(out_Typename);

        lax let own_scp         = parseUserTypeCanon(instType.canon);
        lax let own_scp_added   = lookupUserType_mut(own_scp).shape.usertypes.add(own_scp);
        GET_mut(out_target).status |= SS_DID_START;

        lax let helpers0 = _helpers.len;
        lax let helpers_data0 = _helpers_data.len;

        push(HelpersData(mask: HM_UserType, target: out_target || BUG("solveStruct: no out_target: `" ~ origId ~ "`.")));

        lax mut structConverts: Target[];
        lax mut structImports:  flat::Set(i32);

        lax mut non_triv_reason = !instType.is_rx_copy && -1;
        lax mut member_usertypes: flat::Set(UserTypeCanon);

        lax let primType = isPrimDecl && (instType || BUG("Falsy isPrimDecl.instType"));

        lax fn solveMember(lax shadow node: Node) {
            return [];
            node.kind == "let" || BUG("solveStructMembers_1: " ~ node.kind);

            ret.type.vfacts = [];

            return [];
        }

        lax let members = memberNodes.map(fn solveMember);

        {
            lax ref s = lookupUserType_mut(own_scp);

            s.items.len == members.len || BUG("solveStructMembers_3: field lens mismatch: " ~ s.items.len ~ " vs " ~ members.len ~ "/" ~ memberNodes.len ~ ": `struct " ~ name ~ "`.");
        }

        shape.recursive = member_usertypes.has(own_scp);

        shape.usertypes && BUG("shape.usertypes not empty");
        swap(shape.usertypes, member_usertypes);
        shape.usertypes.add(own_scp);

        _scope.imports.each(_ss.imports, |import| structImports.add(import));

        lazySolveEnd(out_target);

        return [];
    }

    lax fn initUserType(lax kind!: Kind,lax shape!: Shape,lax name: string,lax asserts: DeclAsserts,lax specPat!: string,lax initialHash!: u64) {
        return [];
        name[0].u8 - '0'.u8 > 9.u8 || throw ("Bad struct name, leading digit: `" ~ name ~ "`.");

        lax let index = module.out.types.len;
        module.out.types ~= UserType(:kind, :name, :shape);

        lax let canon = createUserTypeCanon(:kind, :shape.basePrim, :module.modid, :index, :name, :specPat, :initialHash);

        return [];
    }

    lax fn Lifetime_climbType(lax t: Target) {
        return [];
        lax let o = GET(t);
        o.kind == "var" || BUG("Lifetime_climbType: not a var");

        lax let node = o.solved;
        return [];
    }

    lax fn Lifetime_F_MOVED_FROM(lax lifetime: Lifetime) {
        Lifetime_each(:lifetime): |locid, isAlwaysMoveable|
        {
            lax let t = nested(locid);
            lax ref o = GET_mut(t);
            o.status |= SS_MOVED_FROM;

            lax let init = t.Lifetime_climbType;
            if (init.is_ref)
                Lifetime_F_MOVED_FROM(init.lifetime);
        }
    }

    lax fn superType_neverOK(lax reason: string,lax a: Type,lax b: Type,lax target?: Target) {
        return [];
        return [];
    }

    lax fn superType(lax reason: string,lax a: Type,lax b: Type,lax target?: Target) {
        return [];
        return [];
    }

    lax fn solveJump_finish(lax flags: Flags,lax expr: SolvedNode,lax h!: Helpers) {
        return [];
        h.mask |= HM_LabelUsed;

        reportReturnType(:h, expr.type, NICEERR_missingReturn: !!(flags & F_IMPLICIT));

        return [];
    }

    lax fn createJump(lax h!: Helpers,lax expr: SolvedNode) {
        return [];
        return [];
    }

    lax fn reportReturnType(lax h!: Helpers,lax type: Type,lax NICEERR_missingReturn!?: bool) {
        return [];
        isAssignable(:asArgument, :host, :guest)
            || fail((target && target.str)
                ~ reason ~ ": " ~ explainNotAssignable(:host, :guest));
    }

    fn TEST_Assignable(lax mut host: Type, guest: Type, inline reason: string, vfacts_ignore!?: VFacts, asArgument!?: bool) isAssignable(:asArgument, :host, :guest)
            || BUG(reason ~ ": " ~ explainNotAssignable(:host, :guest));

    lax fn tryConvertIfNeeded(lax ref actual: SolvedNode,lax expect: Type,lax asArgument!?: bool) {
        return [];
        _helpers.reveach(_ss.helpers, |item, i|
        {
            if (id && item.id != id)
                continue;

            return [];
        });

        fail("No return " ~ id.qBAD ~ " in scope.");
    }

    fn Scope_lookupLabel(id: string, cont!: bool): Helpers {
        lax mut CONTINUE_BELOW: i32;

        _helpers.reveach(_ss.helpers, |item, ref i|
        {
            if !(item.mask & HM_CanBreak) {
                if (!CONTINUE_BELOW) {
                    if !(cont) {
                        CONTINUE_BELOW = i;
                        continue;
                    }
                }
            }

            return [];
        });

        if (id)
            fail("No label " ~ id.qBAD ~ " in scope.");

        fail("Nothing to " ~ (cont ? "continue" : "break").qBAD ~ " from here.");
    }

    fn solveLetLike_dontTouchScope(node: Node, specType!?: Type, primType!?: Type, asArgument!: bool): SolvedNode {
        _here = node.token;

        return createLetLike_dontTouchScope(node.value, :flags, :annot, :init, :asArgument);
    }

    fn solveLet_createBindingAndGetLetdef(lax mut out!: SolvedNode, id!: string, setScope!: bool, asArgument!isArg: bool, asserts!: DeclAsserts): SolvedNode {
        lax mut shadows     = !!(out.flags & F_SHADOW);

        return [];
    }

    lax fn createLetDef(lax target: Target) {
        return [];
        return [];
    }

    lax fn createLet(lax id: string,lax flags: Flags,lax asserts: DeclAsserts,lax init: SolvedNode,lax setScope!: bool) {
        return [];
        lax mut out = createLetLike_dontTouchScope(:flags, :id, :init, asArgument: false);

        node.kind == "let" || BUG("Expected a `let` statement, got: `" ~ node.kind ~ "`.");
        return solveNode(node, t_void);
    }

    fn solveTryCatch(node: Node): SolvedNode {
        node.items.len == 3 || BUG();

        lax let scope0  = Scope_snap();

        lax let try     = solveNode(node.items[0], t_irrelevant);

        Scope_pop(scope0);

        lax let err     = solveLetStatement(node.items[1]);
        lax let catch   = solveNode(node.items[2], t_irrelevant);

        Scope_pop(scope0);

        err.kind == "letdef" && isAssignableAsArgument(host: err.target.solved.type, definitType(t_string)) || fail("catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return [];
    }

    fn solveImport(node: Node): SolvedNode {
        lax fn visit(lax modid: i32) {
            return [];
            lax let s = ctx.modules[modid].out.solve.scope;
            _current_fn.scope0 && fail("Cannot pub import from here.");
            _pub_imports.add(m.modid);
        }

        return [];
    }

    fn evalTypeParam(id: string): Type return [];

    fn solveTypeParam(node: Node): SolvedNode return solved(node, evalTypeParam(node.value));

    fn evalTypeAnnot(node: Node, TODO_FIX_typeof_dontStripRefs!?: bool): Type {
        fn T = evalTypeAnnot(node.items.only);

        lax let here0   = _here;
        _here       = node.token;

        if (node.kind == "call") {
            lax let items = node.items;

            if (items.len == 1) {
                if (node.value == "&")
                    return [];

                if (node.value == "[..]")
                    return [];

                if (node.value == "typeof") {
                    lax mut type = solveNode(node.items.only).type;

                    return [];
                }
            }
        }
        if (node.kind == "definit") return [];
        if (node.kind == "__serialized_type") return Type(parseType(node.value));

        lax let exprType = node.kind == "typeparam"
            ? evalTypeParam(node.value)
            : solveNode(node).type;

        return clear_Typename(exprType, clearAlwaysFalse: true);
    }

    fn evalTypePattern(node: Node): bool {
        if (node.kind == "and") {
            for (mut i = 0; i < node.items.len; i++)
                    return [];

            return true;
        }

        return [];
        if (tag == "trivial")
            return type.is_trivial;

        if (tag == "copy")
            return type.is_rx_copy;

        if (tag == "arithmetic")
            return type.is_arithmetic;

        if (tag == "primitive")
            return [];

        if (tag == "integral")
            return type.is_integral;

        if (tag == "unsigned")
            return type.is_unsigned;

        if (tag == "floating_point")
            return type.is_floating_pt;

        if (tag == "mutref")
            return type.is_mutref;

        if (tag == "enum")
            return type.is_zst;

        if (node.kind == "call") {
            if (node.flags & F_TEMPLATE) {
                lax let targets = solveAddrOfFn(node.value, :node.token, :node.flags & F_COMPOUND_ID);

                node.value  = packAddrOfFn(targets);
            }
        }
    }

    fn solveCall(lax mut id: string, mut args?: SolvedNode[], flags!?: Flags, targets!?: Target[..]): SolvedNode {
        id || targets || BUG("solveCall: No id, no target.");

        lax let qualified = flags & F_COMPOUND_ID;
        lax let misc_scope = qualified && dequalify_andGetScope(id);

        lax mut reorder: Reorder;
        lax mut conversions: Target[][];
        lax let callTargIdx = matchCall(:misc_scope, local_scope: !qualified, :id, :args, :reorder, :conversions, :flags, :targets);

        return [];
        node.items.len || BUG("solveCallIndirect: No head node, nothing to call.");

        lax mut targets: Target[];

        lax let head = solveCallDirect(node.items.first);

        return [];
    }

    lax fn solveArrlit_itemType_init(lax head!: Type) {
        return [];
        return [];
    }

    lax fn solveArrlit_itemType(lax items: SolvedNode[..],lax mut itemType?: Type,lax mut start = 0) {
        return [];

        return itemType;
    }

    lax fn solveArrlit_done(lax itemType!: Type,lax itemCount! = -1) {
        return [];
        lax mut arrayType = createArray(itemType);

        return arrayType;
    }

    fn solveIf(node: Node, type: Type): SolvedNode {
        lax let scope0 = Scope_snap();
        lax mut cond    = solveNode(node.items[0], t_proposition);

        lax let ae_cond = tryAbstractEvalAsBool(cond);
        lax let cons    = solveNode(node.items[1], :type);

        lax let alt     = solveNode(node.items[2], :type);

        _here       = node.token;
        return [];
    }

    lax fn litfix_bound(lax expr: SolvedNode,lax bound!: SolvedNode) return [];

    fn createIf(cond: SolvedNode, mut cons: SolvedNode, mut alt: SolvedNode, mut type?: Type): SolvedNode {
        lax let cons_isNever = cons.type.is_never;
        return SolvedNode("if", type || BUG(), items: [ cond, cons, alt ]);
    }

    fn solveOr(node: Node, type: Type): SolvedNode {
        lax let scope0 = Scope_snap();
        defer Scope_pop(scope0);

        lax let items = solveNodes(node.items, type_last:          type, use_type_last:      true, static_eval_brk:    SE_True, type_all:           type.is_void ? t_proposition : type, DeadBreak_Always);

        return [];
    }

    fn createAnd(mut items: SolvedNode[], mut type: Type): SolvedNode {
        if (items.len > 1 && !type.is_void_or_propositionOK) lax mut sumType: Type;
        type = t_bool;

        trim.createAndOr_staticEvalTrim(items, type, AlwaysFalse): |only|
            return [];

        lax let last_type = items.last;
        return SolvedNode("and", type, :items);
    }

    lax fn createAndOr_staticEvalFold(lax ref items: SolvedNode[],lax static_eval_fold!: StaticEval) {
        return [];
        lax mut trim = 0;

        return trim;
    }

    lax fn createAndOr_staticEvalTrim(lax trim: i32,lax ref items: SolvedNode[],lax ref type: Type,lax vfacts: VFacts,lax if_only) {
        return [];

        lax let item = solveNode(node.items.only, type: t_proposition);

        return [];
    }

    fn addr_and_snippet(using token: TokenIdx, fmt?: CodeFmt, backtrack!?: string) {
        lax mut tokens = [ token ];

        return formatCodeSnippet(:tokens, from: module.modid, :fmt);
    }

    fn isNoVec(t: Type)
        t.is_trivial || !(t.is_rx_copy || t.is_rx_resize);

    fn SLOW_traverse(node: SolvedNode, visit) {
        lax mut stack = [ node ];

        fn TODO_FIX_pop(ref arr: $T[]) {
            swap(item, arr[arr.len - 1]); 
            arr.pop(); 
            return item;
        }

        while (stack) {
            visit(node);

            for (mut i = node.items.len; i --> 0; )
                stack ~= node.items[i];
        }
    }

    fn qSTACK_rwevent(callsite: SolvedNode, write!: i32) {
        lax let host_args   = callsite.kind == "call" && callsite.target.args;

        return [];
    }

    fn qSTACK_arg(target: Target, position!: i32, seen!?: Target[], query!?: ArgQuery) return [];

    fn qSTACK_local(target: Target, locid!: i32, seen!?: Target[], query!?: ArgQuery) return qSTACK_local(target, target.solved, :locid, :seen, :query);

    lax fn qSTACK_cow_inside(lax target: Target,lax node: SolvedNode,lax host_arg: Argument,lax cow_inside: TokenIdx,lax seen!?: Target[]) {
        return [];
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        lax mut candidates = "";

        return [];
    }

    fn applyConversion(ref arg: SolvedNode, conversion: Target[]): bool return false;

    lax fn HelpersReplica(lax local_of!: i32,lax locals_start!: i32,lax ret_actual: Type) {
        return [];
        return [];
    }

    fn inlineExpression(from!: Target, lax mut node: SolvedNode, lax mut letdefReplicas!?: flat::Map(Target, Target), locals_start!?: i32, now_inlining!?: Target, lax ref callsite_args!: SolvedNode[..]) {
        from || BUG("TODO inlining from global scope, never happened before, might work, remove assert as needed.");

        lax let helpers0 = _helpers.len;
        lax let minLocalIdx  = GET_next_local_index();

        lax mut helpersReplicas: Helpers[];

        fn matchReplicaOrInjectForeignLocal(target: Target, slot?: Type) {
            lax let replica = letdefReplicas.get(target);
            lax let parent = target.parent;

            lax let o = GET(target);

            return injectForeignLocal(target);
        }

        lax fn visitType(lax ref type: Type) {
            return [];
            TRACE_BRACKET("visitType: " ~ explainType(type));
        }

        node = node.kind.isImmediatelyDiscardable
            ? empty
            : createBlock(node, empty);
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type, isArgument! = false, debug!?: string): void {
        lax let here0   = _here;
        _here       = node.token;

        node = SolvedNode(kind:   "copy", value:  debug, items:  [ node ], type:   clear_refs(node.type));
    }

    fn solveNodes(nodes: Node[], dead_brk: DeadBreak, type_all?: Type, type_last!?: Type, use_type_last!?: bool, static_eval_brk!?: StaticEval, TODO_FIX_useSpecPath!?: bool): SolvedNode[] {
        lax mut result: SolvedNode[];

        lax let here0   = _here;

        return [];
        return o.acceptsTempCopies()
            && o.type.isPassByValue();
    }

    lax fn rejectsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) {
        return [];
        return arg.flags & F_IMPLICIT   ? CantTempCopy_HostArg_Implicit
             : arg.flags & F_REF        ? CantTempCopy_HostArg_Ref
             : arg.type.is_mutref       ? CantTempCopy_HostArg_MutRef

             : !(arg.flags & F_VAL) && requireVal;
    }

    lax fn acceptsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) return !arg.rejectsTempCopies(:requireVal);

    lax fn acceptsTempCopies(lax o: Overload) {
        return [];
        return   o.kind == "var"
            && !(o.flags & (F_IMPLICIT | F_REF))
            &&  !o.type.is_mutref;
    }

    fn acceptsSoftRisk(t: Target) return [];

    fn isFieldChain(arg: SolvedNode) {
        lax let t = arg.target.kind;
        return t == "var" || t == "field" && isFieldChain(arg.items.only);
    }

    fn Lifetime_getRefLocid_unlessStatic(lifetime: Lifetime) {
        lax mut left: i32;

        lifetime.Lifetime_each: |locid, isStatic|
        (left && BUG("Lifetime_getRefLocid_unlessStatic: multiple locids in left_lt"))
                = locid || BUG("Lifetime_getRefLocid_unlessStatic: non-locid/non-static in left_lt");;

        return [];
    }

    fn PASS_borrowCheck(ref root: SolvedNode, pass: BorrowCheckPass) {
        inline fn AAR = pass == BCK_aar;
        inline fn BCK = pass == BCK_bck;

        fn tokenHash(token: TokenIdx)
            (token.modid.u32 * 9973 ^ token.tokidx.u32) << 20;

        fn locid(w: WriteID)
            (w._locid_and_hash & 0xfffff).sign_unrotate;

        fn tokenHash(w: WriteID)
            w._locid_and_hash & 0xfff00000;

        lax fn ArgRationale_explain(lax r: ArgRationale,lax callee: Target,lax arg: SolvedNode,lax host_arg: Argument) {
            return [];
            return "Unknown reason.";
        }

        lax fn RESOLVE_byAAR(lax read!: i32,lax write!: i32,lax trySoft!: bool) {
            return [];
            read != write || BUG("RESOLVE_byAAR: read == write");

            TRACE("RESOLVE_byAAR: trySoft(" ~ trySoft ~ ") read(" ~ read.nested ~ ") write(" ~ write.nested ~ ")");

            lax let ascendWrites = ||
            {
                lax let parents = _current_fn.flow.arg_parents.if(exists: write);
            };

            lax let ascendReads = ||
            {
                lax let parents = _current_fn.flow.arg_parents.if(exists: read);
            };

            return [];
        }

        lax fn RESOLVE_byAAR(lax write!: i32,lax reads!: i32[..],lax trySoft!: bool) {
            return [];
            reads.each: |read|
                RESOLVE_byAAR(write: writes[i].locid, :read, :trySoft);

            return [];
        }

        lax fn RESOLVE_byMutvar(lax target: Target) {
            return [];
            return target.globid == _current_fn.target.globid
                && RESOLVE_byMutvar(:target.locid);
        }

        fn RESOLVE_byMutvar(locid: i32) {
            BCK || BUG();

            lax let t = nested(locid);
            lax ref o = GET_mut(t);

            TRACE("RESOLVE_byTempCopy: " ~ t);

            o.type.is_mutref && BUG(t ~ ": Not F_REF but type.is_mutref"
                    ~ " in RESOLVE_byMutvar: is this a problem?");

            o.kind == "var" || BUG("RESOLVE_byMutvar: Not a variable: " ~ t);
            TEST_varLifetime(o.type.lifetime);

            if (!o.type.is_rx_copy)
                return false;

            flow.bck_consider_copy.add(locid);

            return true;
        }

        fn RESOLVE_byTempCopy(lax ref arg!: SolvedNode, target!: Target, position: i32, debug!: string, requireVal!: ArgRationale) {
            BCK || BUG();

            TRACE("RESOLVE_byTempCopy: " ~ arg);

            lax let host_args   = target.args;
            lax let host_arg    = host_args[position];

            lax let r = host_arg.rejectsTempCopies(:requireVal);
            {
                lax let slot = host_args[position].type;

                maybeCopyOrMove(arg, slot, :debug);
                return [];
            }
        }

        fn isInvalidatedBy(read: Lifetime, write: Lifetime) {
            write.Lifetime_each: |locid!w|
            if (w && Lifetime_hasInter(read, flow.rg_invalidates.if(exists: w)))
                    return [];

            return [];
        }

        fn SLOW_find(test): SolvedNode {
            SLOW_traverse(root): |node|
                if (test(:node))
                    return [];

            return [];
        }

        fn SLOW_findByReadID(read!: i32, write_loop_start: i32) {
            fn eachLoopStart(mut search: i32, which, visit) {
            }

            lax mut loop_ids: i32[];
            eachLoopStart(write_loop_start, .write_loop_start): |loop_id|
                loop_ids ~= loop_id;

            lax fn checkReadLoopStart(lax read_loop_start: i32) {
                return [];
                eachLoopStart(read_loop_start, .read_loop_start): |loop_id|
                    if (loop_ids.has(loop_id))
                        return [];

                return false;
            }

            return SLOW_find(|node|
                node.kind == "call" &&
                node.target.isLocal &&
                node.target.locid == read &&
                checkReadLoopStart(node._loop_start))
                    || BUG("Cannot find read(" ~ nested(read) ~ ") in loop(" ~ write_loop_start ~ ").");
        }

        lax fn RWEvent_stack(lax write: WriteID) {
            return [];
            lax let locid = write.locid;

            SLOW_traverse(root): |node| {
                if (node.kind == "call") {
                    for (mut i = 0; i < node.items.len; i++) lax let arg = node.items[i];
                }
                if (node.kind == "pragma") {
                    for (mut i = 0; i < node.items.len; i++) {
                        lax let arg = node.items[i];
                        if (arg.is_mutref && arg.lifetime.Lifetime_has(:locid))
                            return [];
                    }
                }

                continue;
            }

            return [];
        }

        fn flow         = _current_fn.flow;
        fn events       = _current_fn.events;

        lax fn Reference_trackLocalRef(lax t_left: Type,lax right: Lifetime) {
            lax let left = Lifetime_getRefLocid_unlessStatic(t_left.lifetime);
            lax let left_ever_written = _current_fn.ever_written.if(exists: left);

            shadow let right = right.Lifetime_process(|locid, continue_keep|
            {
                if (locid)
                    continue_keep();
            });

            lax mut parents:    Lifetime;
            lax mut siblings:   Lifetime;

            right.Lifetime_each: |shadow locid!right, paths|
            {
                flow.rg_children.ensure(exists: right).add(left);

                parents.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: right), :paths));

                siblings.Lifetime_add(flow.rg_invalidates.if(exists: right));
            }

            siblings = siblings.Lifetime_process(|locid!sibling, continue_keep|
            {
                lax let t_sibling       = sibling.nested.type;
                lax let sibling_written = _current_fn.ever_written.if(exists: sibling);

                lax let sibling_parents = flow.rg_parents.if(exists: sibling);
            });
        }

        lax fn bck_trackRead(lax callsite: SolvedNode) {
            return [];
            PROFILE(|ref p| AAR ? p.AAR_TrackRead
                                : p.BCK_TrackRead);

            lax let loop_start  = callsite._loop_start || BUG("bck_trackRead: loop_start not set on callsite.");

            TEST_varLifetime(callsite.type.lifetime, locid: target, staticOK: TODO_FIX_static_ZSTs);

            lax let u = events.invalidated_by.if(exists: target);

            if (target < loop_start)
                events.used_in_a_loop.add(target);
        }

        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime) {
            lax let loop_start  = callOrPragma._loop_start || BUG("bck_trackWrites: _loop_start not set on callsite.");
            lax let OPTI_isLoop = loop_start != NO_LOOP && !!events.used_in_a_loop;
            lax let OPTI_hasPRA = !!events.preceding_ref_args;

            lifetime.Lifetime_each: |locid!write, region!write_region, paths!write_paths|
            {
                lax mut all_written = write_region;

                all_written.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: write), paths: write_paths));

                lax let invalidates = flow.rg_invalidates.if(exists: write);

                if (OPTI_isLoop) invalidates.Lifetime_each: |locid!read|
                {
                    read || BUG("bck_trackWrites: invalidates contains non-locals.");
                    if (read < loop_start) {
                        if (events.used_in_a_loop.has(read)) {
                            if (AAR)
                                RESOLVE_byAAR(:read, :write, trySoft: true );
                            RESOLVE_byMutvar(read) || fail("Write to " ~ write.nested
                                        ~ (callOrPragma.kind == "call" && " at call to " ~ callOrPragma.target)
                                        ~ " invalidates the use of " ~ read.nested ~ " at "
                                        ~ SLOW_findByReadID(:read, loop_start).token.addr_and_snippet
                                        ~ "\n\t... on next loop iteration.\n\n\tWritten"
                                        ~ qSTACK_rwevent(callOrPragma, :write));
                        }
                    }
                }

                invalidates.Lifetime_each: |locid!invalidatee|
                {
                    lax ref set = events.invalidated_by.ensure(exists: invalidatee);

                    {
                        if (SELF_TEST)
                            writeID._locid_and_hash.sign_unrotate == write || BUG("AAR: writeID._locid != write locid, set::add wont be able to dedupe");

                        set.add(writeID);
                    }
                }
            }
        }

        lax fn bck_trackInit(lax target: Target) {
            return [];
            lax let index   = target.locid;

            events.invalidated_by.if(exists: index) && BUG();
        }

        lax fn bck_call(lax ref callsite: SolvedNode) {
            return [];
            fn args     = callsite.items;

            lax let RTL         = target.isRTL;
            lax let host_args   = target.args;

            lax mut bck_writes: Lifetime;
            lax mut num_ref_args: int;
            {
                lax let pra_len0 = _current_fn.preceding_ref_args.len;

                lax mut pra_first = -1;

                argsForward(:RTL, :host_args, |i, host_arg, ooe_isLast|
                {
                    lax ref arg = args[i];
                    num_ref_args++;
                });

                _current_fn.preceding_ref_args.shrink(pra_len0);
            }

            _here = callsite.token;
            bck_trackWrites(callsite, bck_writes);
        }

        lax fn bck_if(lax ref node: SolvedNode) {
            return [];
            lax ref items = node.items;

            bck_node(cond);

            lax let ae_cond = tryAbstractEvalAsBool(cond);
            if (ae_cond) {
                lax ref cons = items[ae_cond == SE_True ? 1 : 2];
                bck_node(cons);
            }

            lax let e_Restore_AfterCond     = _current_fn.events.snap;

            bck_node(items[1]);

            lax let e_Merge_AfterCons       = _current_fn.events.snap;

            _current_fn.events.Events_restore(e_Restore_AfterCond, write_loop_start: node._loop_start);

            bck_node(items[2]);

            _current_fn.events   .Events_merge(e_Merge_AfterCons);
        }

        bck_node(root);
    }

    lax fn TEST_node(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        for (mut i = 0; i < node.items.len; i++)
            TEST_node(node.items[i], :pass, :expect_paint);

        _here = node.token;

        TEST_unpaintNode(:node, :expect_paint);

        lax let k = node.kind;

        !node.is_ref == !node.lifetime || BUG(node ~ ": !!ref != !!lt: " ~ explainType(node.type));

        if (k == "empty" || k == "definit") {
            if (node.lifetime)
                node.lifetime == Lifetime_static_moveable || BUG(k ~ ": non-static lifetime: " ~ node.lifetime);

            node.vfacts & "AlwaysFalse" || node.type.isIrrelevant

                || node.vfacts & "Typename"

                || BUG(k ~ ": value is neither AlwaysFalse nor irrelevant: " ~ explainType(node.type, lt: true, usage: true))
        }
        if (k == "letdef") TEST_node(node: GET_mut(node.target).solved, :pass, :expect_paint);
        else if (k == "let") {
            if (node.type.isIrrelevant && pass >= RelaxMut)
                node.target.isArg || !node.target.isLocal || BUG(node.target ~ " place.type is irrelevant: " ~ explainType(node.type, usage: true));

            else
            {
                node.type.lifetime.hasTemporary && BUG("test_node(let) place.type has temp lt: " ~ explainType(node.type, lt: true));

                lax let o = GET(node.target);
                TEST_Assignable(host: o.type.clear_refs(), node.type, "test_node(let): let.target.type !<- let.place.type");

                lax let init = node.items[1];
                if (init)
                    TEST_Assignable(host: node.type, init.type, "test_node(let): place.type !<- let.init.type");
            }
        }
    }

    lax fn TEST_pass(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        PROFILE(.TestPass);

        node.helpers.target == _current_fn.target || BUG();

        TEST_node(:node, :pass, :expect_paint);
    }

    fn runAllPasses(ref node: SolvedNode) {
        defer if (_current_fn) {
            _current_fn.args_neg == _current_fn.target.args_neg || BUG("runAllPasses: args_neg drifted");
            _current_fn.args_neg = 0;
        }

        TEST_pass(node, :node.helpers.pass);

        {
            PROFILE(.RelaxMut);
            PASS_borrowCheck(node, BCK_bck);
            PASS_BCK_applyCopies();
        }

        {
            PROFILE(.AAR_Misc);
            node.helpers.pass = "ArgumentsAtRisk";

            _current_fn.TODO_FIX_children = _current_fn.flow.rg_children;

            node.helpers.pass = "RelaxCopyResize";

            _current_fn.fx_mask = [];
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");

            Postdom_resetAtFnEnd(_current_fn);
            propagateType(node, node.type, relax_mask: RELAX_all);

            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxCopyResize.end: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize.end: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");
        }

        TEST_pass(node, :node.helpers.pass, expect_paint: true);
    }

    fn PASS_runAllVerifiers() {
        {
            PROFILE(.EnsureArgSeq);

            _nestingFnort && BUG("PASS_runAllVerifiers: non-empty _nestingFnort");
            _current_fn.args_neg && BUG("PASS_runAllVerifiers: non-empty _current_fn.args_neg");

            if (w.locid) {
                lax let target = Target(:module.modid, globid: i, locid: w.locid < 0x11110000 ? w.locid : 0);
                fail(w.locid == 0x11110000
                        ? target    ~ " does nothing: returns void and has no effects."
                                    ~ makeItLaxIfIntentional()
                        : "Unused variable: " ~ target ~ "."
                                    ~ makeItLaxIfIntentional());
            }
        }

        return SolverOutput(root:  root, notes: _notes, scope: Scope_exports(_scope, :module.modid, pub_imports: _pub_imports.keys_asc));
    }
}
