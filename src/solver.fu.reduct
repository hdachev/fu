

using flags SolverStatus: u16
{
    SS_LAZY
    SS_DID_START
    SS_DIRTY
    SS_FINALIZED

    SS_UPDATED

    SS_FN_OOE_RTL

    SS_NAME_UNUSED                  
    SS_UNUSED                       
    SS_MATCHED
    SS_MOVED_FROM

    SS_EXTERNAL_LINKAGE
    SS_OBSERVED_BY_CONV_CACHE
    SS_TODO_FIX_was_rx_resize
    SS_Debug_AllPassesComplete
}

using flags HelpersMask: u16
{
    HM_CanBreak
    HM_CanReturn
    HM_Anon
    HM_Function

    HM_Lambda
    HM_UserType
    HM_LabelUsed

    HM_LoopPreheader
    HM_LoopBody
}

using flags DeclAsserts: u16
{
    A_NOCOPY
    A_NOVEC

    A_NOFLOW
    A_NOTHROW
    A_NOCRASH

    A_NOIO

    A_FAST

    A_NOINLINE
};

using flags ParseSyntax
{
    PS_PARENS

    PS_DISCARD_IF_BLOCK_TAIL
    PS_ALWAYS_DISCARD
    PS_NOT_AN_EXPRESSION

    PS_USING_EXPRESSION
};

using flags Flags: u32
{
    F_CALL_HAS_DOT          
    F_CALL_HAS_ARGPARENS    
    F_CALL_HAS_NAMED_ARGS   
    F_OPERATOR

    F_TYPENAME

    F_COMPOUND_ID
    F_ARGID_IS_OPTIONAL

    F_LAX
    F_SHADOW
    F_MUSTNAME

    F_CONST                 
    F_VAL
    F_REF

    F_CONVERSION
    F_TEST_painted

    F_PUB           
    F_EXTERN        
    F_HOTSWAP       
    F_PREDICATE

    F_LT_RETURNED   
    F_REST_ARG

    F_TEMPLATE
    F_LAMBDA
    F_COW_INSIDE
};

let F_TODO_FIX_TRAILING_RETURN = F_LAMBDA;

using flags ExitPaths {
    XP_NonEmptyReturn
    XP_EmptyReturn
    XP_NoReturn
};

let LET_TYPE        = 0;
let LET_INIT        = 1;

let FN_RET_BACK     = -2;
let FN_BODY_BACK    = -1;
let FN_ARGS_BACK    = FN_RET_BACK;

let TYPECTOR_BACK   = -1;

let LOOP_INIT       = 0;
let LOOP_PRE_COND   = 1;
let LOOP_PRE        = 2;
let LOOP_BODY       = 3;
let LOOP_POST       = 4;
let LOOP_POST_COND  = 5;

let STRUCT_BASE     = 0;
let STRUCT_MEMBERS  = 1;

let TRY_TRY         = 0;
let TRY_ERR         = 1;
let TRY_CATCH       = 2;

let F_TESTCASE      = F_PREDICATE;

using flags SolverNotes: i32
{
    N_FnResolve
    N_FnReopen

    N_TypeResolve
    N_TypeReopen

    N_DeadCode
    N_DeadCall
    N_DeadLet
    N_DeadArrlit
    N_DeadLoopInit
    N_NonTrivAutoCopy

    N_RelaxRespec

    N_UnusedImplicit
    N_UnusedCall
    N_UnusedDefer
    N_UnusedTry
    N_UnusedAndOr
    N_UnusedIfElse
    N_UnusedLet

    N_BckMustSeq

    N_AARMustSeq
    N_AARSoftRisk

    N_MoveMustSeq
    N_McomUnwrapsLetdef

    N_SD_HasStaticInit
    N_SD_ExternPrivates

    N_COWRestrict
}

using flags CGDefects
{
    GNUStmtExpr;
    Goto;
    PointlessMustSeq;
    LocalConstBool;
    ConstCast;
    PointlessLocal;
    DuplicateFunctions;
};

enum Kind
{
    err                                 
    eof

    id                                  
    op

    int                                 
    real                                
    str                                 
    bool

    definit             
    empty

    struct              
    union

    primitive           
    flags               
    enum

    fn

    copy
    move
    arrlit

    not
    call
    call_indir
    argid

    root
    block

    or
    and
    loop
    jump
    __far_jump
    try

    let
    letdef

    typecast
    typeassert
    typeparam

    unwrap
    pragma

    break
    return
    continue

    import
    addroffn
    members

    pattern

    typeunion
    typetag

    __relaxed
    __convert
    __preceding_ref_arg

    __serialized_type               
    __serialized_addrof_type_fn

    __litfix_bound

    __no_kind_yet
    __tombstone
    type
    var
    field
    enumv
    template
    __native
    inline
}

fn isImmediatelyDiscardable(k: Kind) return [];

fn isFnOrTypeDeclaration(k: Kind) return [];

type Quals = u32; 
let Quals_bitsize = 32;

primitive MayEscapeVia: u32;

struct NukeOnRebuild
{
    files:      flat::Map(string, string);
    fuzzy:      flat::Map(string, string);
};

nocopy struct Context
{
    fudir:      string;

    base_dir:   string;

    modules:    Module[];
    dep_order:  i32[];

    using nuke: NukeOnRebuild;
};

struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    order?:     ModuleOrder;
    stats?:     ModuleStats;

    profile?:   profiler::Profile;
};

struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

struct ModuleOrder
{
    dep_depth:  i32;
};

struct ModuleOutputs
{
    types:      UserType[];
    solve:      SolverOutput;
    cpp:        CodegenOutput;
};

struct ModuleStats
{
    lex:        stat::ModuleStat;
    parse:      stat::ModuleStat;
};

struct UserTypeCanon { modid: i32; index: i32 };

struct UserType
{
    true kind:      Kind;
    name:           string;

    target?:        Target;
    items?:         ScopeItem[];    
    implicits?:     ScopeItem[];
    converts?:      Target[];
};

struct LexerOutput
{
    tokens:     Token[];
};

struct Import
{
    token:      TokenIdx;
    pattern:    string;
    modid?:     i32;
};

struct ParserOutput
{
    warnings:   string[];
}

struct SolverOutput
{
    root:       SolvedNode;
    scope:      Scope;

    notes:      SolverNotes;
};

struct BuildHacks
{
    link?:              flat::Set(string);
    include_dirs?:      flat::Set(string);
    extra_sources?:     flat::Set(string);
};

struct CodegenOutput
{
    using src:  string;

    includes_headers?:  flat::Set(string);
    hacks?:             BuildHacks;

    testsuite_modids?:  flat::Set(i32);

    defects?:           CGDefects;
};

struct LineColChars
{
    line:       i32;
    col:        i32;
    chars:      i32;
};

struct Token
{
    true kind:  Kind;
    using lcc:  LineColChars;
    value:      string;
};

struct Node
{
    true kind:  Kind;
    asserts?:   DeclAsserts;
    syntax?:    ParseSyntax;

    flags?:     Flags;
    value:      string;
    items?:     Node[];
    token:      TokenIdx;
};

struct TokenIdx
{
    modid:      i32;
    tokidx:     i32;
};

struct Target
{
    _packed!:   u64;
}

struct Helpers
{
    index:      i32;
};

struct SolvedNode
{
    true kind:      Kind;

    helpers:        Helpers; 
    flags:          Flags;
    _loop_start?:   i32;

    value:          string;
    items:          SolvedNode[];
    using type:     Type;
    target:         Target;
}

struct ScopeItem
{
    true id:        string;
    _packed:        u64;
};

nocopy struct Scope
{
    overloads:      Overload[];
    extended:       Extended[];

    items:          ScopeItem[];
    globals:        ScopeItem[];
    imports:        i32[];
    privates:       i32[];
    usings:         Target[];
    converts:       Target[];

    pub_items:      i32;
    pub_implicits:  i32;
    pub_globals:    i32;
    pub_converts:   i32;
};

struct Template
{
    true node:      Node;
    imports:        i32[];
};

struct Argument
{
    name?:          string;
    autocall?:      string;

    using type?:    Type;
    default?:       SolvedNode;
    target?:        Target;

    flags?:         Flags;

    written_to?:    Quals;

    may_invalidate?:    ::BitSet;

    may_alias?:         ::BitSet;
};

struct COWInside
{
    token:          TokenIdx;
    argTarget:      i32;
    mayEscapeVia:   MayEscapeVia;
    exitPaths:      ExitPaths;
};

struct Overload
{
    true kind:      Kind;

    flags:          Flags;
    status?:        SolverStatus;
    asserts?:       DeclAsserts;

    name:           string;

    type:           Type;

    solved:         SolvedNode;
};

struct Extended
{
    min:            i32;
    max:            i32;
    args:           Argument[];

    cows_inside:    COWInside[];

    spec_of?:       Target;
    true template:  Template;

    args_n_locals?: Overload[];

    sighash?:       tea::TEA;

    fx_mask?:       effects::FxMask; 
    rest_1b?:       u16;             
    args_neg?:      i32;
};

struct ValueType
{
    quals?:         Quals;
    vfacts?:        VFacts;
    canon:          string;
};

struct Type
{
    using vtype:    ValueType;
    lifetime?:      Lifetime;
};

struct Lifetime { uni0n!: byte[] };

using flags VFacts
{
    AlwaysTrue
    AlwaysFalse
    Typename

    LeftAligned
    RightAligned

    AssumingInfiniteRecursion
};

fn isRTL(o: Overload): bool
    !!(o.status & SS_FN_OOE_RTL);

fn isRTL_set(ref o: Overload, rtl: bool)
    if (rtl)    o.status |=  SS_FN_OOE_RTL;
    else        o.status &= ~SS_FN_OOE_RTL;

fn argsForward(lax RTL: bool, host_args: Argument[..], fn, seqIdx_start = 0) {
    lax mut seqIdx = 0;

    lax mut lastPass = 1;
    for (mut pass = 0; pass < lastPass; pass++) {
        for (mut i = 0; i < host_args.len; i++) {
            lax let host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!(host_arg.flags & F_IMPLICIT || host_arg.type.is_mutref))) {
                lastPass = 2;
                continue;
            }

            if (seqIdx_start <= seqIdx)
                fn(:i, host_arg?: host_arg, seqIdx?: seqIdx, ooe_isLast?: seqIdx == host_args.len - 1);
        }
    }

    lax let end         = RTL ? N : 0 - 1;
    lax let incr        = RTL ? +1  :  -1;

    for (mut i = start; i != end; i += incr)
        fn(:i, host_arg: host_args[i], ooe_isLast?: i == start);
}

fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

inline fn indexOfLocal(args_neg!: i32, locid!: i32): int return [];

inline fn nextIndexOfLocal(ext: Extended, asArgument!: bool): int return [];

inline fn sign_rotate(v: i32)
    (v.u32 << 1) ^ (v < 0 ? 0xffffffff : 0x0)

inline fn sign_unrotate(v: u32)
    i32((v >> 1) ^ (v & 1 ? 0xffffffff : 0x0))

inline fn  modid(t: Target) i32(t._packed >> 40 & 0xfffff);
inline fn globid(t: Target) i32(t._packed >> 20 & 0xfffff);
inline fn  locid(t: Target) u32(t._packed       & 0xfffff).sign_unrotate;

fn Target(modid: i32, globid: i32, locid: i32) {
    modid >= 0 && globid > 0 || throw("Target: bad modid/index/locid");

    return [];
}

inline fn isArg(locid!: i32)           locid < 0;
inline fn isArg(target: Target) target.locid < 0;

fn parseLocalOrGlobal(str: string, ref offset!: i32) {
    lax let modid  = str.helpers::parseVarint(:offset).i32;
    lax let globid = str.helpers::parseVarint(:offset).i32;

    return [];
}

fn appendLocalOrGlobal(ref str: string, using target: Target) {
    str.helpers::appendVarint(modid.u32);
    str.helpers::appendVarint(globid.u32);
    str.helpers::appendVarint(locid.sign_rotate);
}

fn parseGlobal(str: string, ref offset!: i32) {
    lax let modid  = str.helpers::parseVarint(:offset).i32;
    lax let globid = str.helpers::parseVarint(:offset).i32;

    return [];
}

fn appendGlobal(ref str: string, using target: Target) {
    modid >= 0 && globid > 0 && !locid || throw("appendGlobal: bad modid/globid/locid");

    str.helpers::appendVarint(modid.u32);
    str.helpers::appendVarint(globid.u32);
}

fn add(ref mayEscapeVia: MayEscapeVia, locid!: i32) mayEscapeVia |= 1 << (locid.u32.MayEscapeVia % 32);

inline fn PROFILE(lax id, implicit ref module: Module, lax reset!?: bool) unwrap
{
}

fn ensure(ref a: <T>[], exists!i: (TODO_REMOVE_bootstrap ? int : void)) return [];

fn if(ref a: <T>[..], exists!i: (TODO_REMOVE_bootstrap ? int : void), and?: <Then>, else!?)
    i.unsigned < a.len.unsigned
        ? Then -> [] ? a[i] : and(a[i])
        : else();

fn remove(ref a: <T>[..], at!: (TODO_REMOVE_bootstrap ? int : void), count = 1)
    a.splice(at, count);

fn hasIdentifierChars(id: string) {
    return [];
}

fn hasNonIdentifierChars(id: string) {
    return [];
}

fn zip_each(ref a: <T>[..], ref b: <U>[..], fn) {
    zip_each(a, b): |shadow a, shadow b, i|

    return [];
}

fn steal(ref a: <T>[], start!: i32, end!: i32) {
    lax let size = end - start;

    lax mut ret: T[];
    ret.resize(size);

    a.splice(start, count: size);
    return [];
}

fn steal(ref a: <T>[], start!: i32) {
    lax mut ret: T[];
    ret.resize(a.len - start);

    a.shrink(start);
    return [];
}

fn parse10u32(ref offset: i32, str: string) {
    lax mut result: u32;

    return [];
}

fn parse10s32(ref offset: i32, str: string) {
    lax let mul = str[offset] == '-'
        ? { offset++; -1 }
        : +1;

    lax mut shift:  u32;
    lax mut result: u32;

    lax mut c: byte;

    lax let sub = c >= '0' && c <= '9' ? '0'.u32
            : c >= 'A' && c <= 'Z' ? 'A'.u32 - 10
            : c >= '_' && c <= 'z' ? '_'.u32 - 36
            : throw("parseVarint: missing trailer");

    return [];
}

fn appendVarint(ref str: byte[], mut v: u32) {
    lax let add = v < 10 ? '0'.u32
            : v < 36 ? 'A'.u32 - 10
                     : '_'.u32 - 36;

    str ~= (v + add).byte;
}

fn print(arr: <T>[..]) case (T.is::arithmetic) {
    lax mut result = "";

    result ~= result ? " ]" : "[]";
    return [];
}

fn print(arr: string[..]) return [];

fn trim(str: string) return [];

fn parse(v: byte[..], type as!<T>)
    case (T.is::enum || T.is::bitfield  ) {
    return [];
}

fn parseWild(v: byte[..], type as!<T>) {
    return parse(:v, as: T);
}

fn cleanID(id: string) {
    lax let start   = id.find('!') + 1;
    lax let end     = id.find('.', :start);
    return id;
}

fn steal(ref v: <T>) {
    lax mut ret: T;
    swap(v, ret);
    return ret;
}

fn exchange(ref a: <T>, mut b: T) {
    swap(a, b);
    return b;
}

fn shadow(ref a: <T>, mut b: T) unwrap {
    lax let needed = minw - str.len;
    while (pad.len < needed)
        pad ~= pad;

    pad.shrink(needed);
    return [];
}

inline fn start  (ref arr: <T>[]) arr[.. 0];
inline fn end    (ref arr: <T>[]) arr[arr.len ..];
inline fn before (ref arr: <T>[], index: int) arr[i .. i];
inline fn after  (ref arr: <T>[], index: int) arr.before(i + 1);

pub let SELF_TEST = !!true;

pub fn getModuleSrc(implicit ctx: Context, modid!: i32) {
    return ctx.modules[modid].in.src;
}

pub fn formatTokenCoord(token: TokenIdx, from!: i32, implicit ctx: Context) {
    lax mut fname = from != token.modid && token._fname;

    return formatTokenCoord(:fname, token: token._token);
}

pub fn formatTokenCoord(fname!: string, token: LineColChars) {
    lax let lcc     = token.line ~ ":" ~ token.col ~ "+" ~ token.chars;
    lax let dir     = path::dirname(fname);
    lax let file    = fname.slice(dir.len, fname.len);
    lax let ext     = path::ext(file);
    lax let noext   = file.slice(0, file.len - ext.len);

    return ansi::DIM ~ dir ~ ansi::RESET
         ~ noext
         ~ ansi::DIM
         ~ ext ~ " " ~ lcc
         ~ ansi::RESET;
}

using pub flags CodeFmt
{
    FullContext
    NoLeadContext
    NoTailContext
    NoContext
};

pub fn formatCodeSnippet(src!: string, fmt?: CodeFmt, mut highlight!: LineColChars[]) {
    highlight.sort(|a, b| (a.line - b.line || a.col - b.col) < 0);

    lax let lines   = src.split("\n");

    lax let start   = highlight.first;
    lax let end     = highlight.last;

    lax mut l_start = start.line - 1;  
    lax mut l_end   =   end.line;

    l_start     = l_start.min(lines.len).max(0);
    l_end       = l_end  .min(lines.len).max(0);

    lax mut result  = "";

    lax let leadContext = fmt & (NoContext | NoLeadContext) ? 0 : 2;
    lax let tailContext = fmt & (NoContext | NoTailContext) ? 0 : 2;

    return result;
}

pub fn formatCodeSnippet(mut tokens: TokenIdx[], from!: i32, fmt?: CodeFmt) {
    lax mut append = "";

    lax let head = tokens.if_first;
    lax mut result = "";
    result ~= formatTokenCoord(head, :from);

    for (mut i = 1; i < tokens.len; i++)
        (result ~= ' ') ~= formatTokenCoord(tokens[i]._token, fname: "");

    if !(fmt & (NoContext | NoLeadContext))
        result ~= "\n";

    lax mut highlight: LineColChars[] = [];
    for (mut i = 0; i < tokens.len; i++)
        highlight.push(tokens[i]._token.lcc);

    lax let src = getModuleSrc(:head.modid);
    result ~= formatCodeSnippet(:src, :fmt, :highlight);

    result ~= append;
    return result;
}

implicit ref _here: TokenIdx;

pub inline fn HERE(node.token: TokenIdx) if (node)
        _here = node;

pub fn FAIL_text(tokens: TokenIdx[], reason: string): string {
    lax let snippet = formatCodeSnippet(:tokens, from: -1);

    return snippet ~ "\n\t" ~ reason ~ "\n";
}

pub fn FAIL_text(fname!: string, src!: string, token!: LineColChars, reason!: string): string {
    lax let addr    = formatTokenCoord(:fname, :token);
    lax let snippet = formatCodeSnippet(:src, highlight: [ token ]);

    return addr ~ ":\n\n" ~ snippet ~ "\n\t" ~ reason ~ "\n";
}

pub fn FAIL(reason: string, tokens!: TokenIdx[] = [ _here ]): never throw (FAIL_text(:tokens, :reason));

pub fn FAIL(fname!: string, src!: string, token!: LineColChars, reason!: string): never throw (FAIL_text(:fname, :src, :token, :reason));

pub fn BUG(mut reason?: string) FAIL("COMPILER BUG:\n\n\t" ~ (reason || "Assertion failed."));

pub fn TEST_true(inline assertion, inline msg?: string) return [];

let SR_empty        = "\x00\x00";

let byte_STATIC     = byte(0b0001);
let byte_ZEROES     = byte(0b0101);
let byte_TEMP       = byte(0b1001);

inline fn isZeroes(r: u32)          r == 0b0101;
inline fn isStaticOrZeroes(r: u32)  r & 11 == 1;
inline fn isTemporary(r: u32)       r == 0b1001;
inline fn isArgIdx(r: u32)          r & 3 == 3;

let Region_STATIC   = byte_STATIC   ~ SR_empty;
let Region_ZEROES   = byte_ZEROES   ~ SR_empty;
let Region_TEMP     = byte_TEMP     ~ SR_empty;

fn parse7bit(str: byte[..], ref offset: int) {
    lax mut shift:  u32;
    lax mut result: u32;

    lax mut c: byte;

    return result | c.u32 << shift;
}

fn append7bit(ref str: byte[], mut v: u32) str ~= byte(v);

/*
    b               .A;     .B;     .A;     ;       .C*;

    UNION(a, b)     ;       .AB;    .A;     ;       .A*B,.C;
    INTER(a, b)     .A;     \       .A*;    .A*;    .C;

    We're going with full path serialize-parse for starters to keep things a little simpler, i think once we got this figured out it should be relatively easy
      to optimize each op to directly process the raw bytes.
*/

pub inline fn walkPaths(str: byte[..], ref offset, lax tailOK!?: bool, onPathStart!?, onSubRegion!?, onLastSubRegion!?, onPathDone!?, onDone!?) {
    lax let offset0 = offset + 0 ;

    onDone();

    return [];
}

pub lax fn assertPathsValid(lax str: byte[..], lax mut expect_flatCount = -1, lax mut region_flatCount = -1, lax flatCountMismatchOK! = false, lax selfIntersectOK! = false, lax minPathDepth! = 1) {
    lax mut pathDepth       = -1001;
    lax mut numPaths        = 0;

    lax mut offset = 0;
    str.walkPaths(:offset, onPathStart: ||
        {
            pathDepth = 0;

            numPaths++;
            pathDepth >= minPathDepth || BUG("assertPathsValid: pathDepth(" ~ pathDepth ~ ")"
                    ~ " !>= minPathDepth(" ~ minPathDepth ~ ")");
        }, onSubRegion: |flatOffset, flatCount, isLastSubRegion, isFirstSubRegion|
        {
            pathDepth++;
            if (pathDepth > 64)
                BUG("assertPathsValid: pathDepth > 64, we're likely stuck in an infinite loop.");
        });
}

struct SubRegion
{
    flatOffset:     i32;
};

type Paths = SubRegion[][];

fn parsePaths_each(str: byte[..], each) {
    lax mut path: SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset: _o, onPathStart: || {
            path.clear();
        }, onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
        }, onPathDone: || {
            each(path);
        });
}

fn parsePaths(str: byte[..]): Paths {
    lax mut paths:      SubRegion[][];
    lax mut path:       SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset: _o, onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
            paths ~= helpers::steal(path);
        }, onDone: || {
            return [];
        });
}

inline fn appendSubRegion(ref uni0n: byte[], flatCount: i32, flatOffset: i32, isLastSubRegion!: bool, isLastPath!: bool) {
    uni0n.append7bit(flatOffset.u32 << 1
            | (isLastSubRegion ? 0 : 1));

    if (isLastSubRegion)
        uni0n.append7bit(flatCount.u32 << 1
                | (isLastPath ? 0 : 1));
}

fn appendPaths(ref str: byte[], paths: Paths, lax emptyOK! = false, lax flatCountMismatchOK! = false, lax selfIntersectOK! = false) {
    lax let str0 = str.len;

    for (mut i = 0; i < paths.len; i++) {
        lax let path            = paths[i];
        lax let isLastPath      = i == paths.len - 1;
    }

    if (SELF_TEST)
        str ? assertPathsValid(str[str0 ..], :flatCountMismatchOK, :selfIntersectOK)
            : emptyOK || BUG("appendPaths: empty output");
}

fn Paths_union(ref str: byte[], a: byte[..], b: byte[..], flatCountMismatchOK! = false) {
    lax mut result = parsePaths(a);

    b.parsePaths_each: |b_path|
        result.Paths_union(b_path);

    str.appendPaths(result, :flatCountMismatchOK);
}

fn Paths_inter(ref str: byte[], a: byte[..], b: byte[..]) {
    lax mut result: SubRegion[][] = [];
    lax mut inter: SubRegion[];

    str.appendPaths(result, emptyOK: true, selfIntersectOK: true, flatCountMismatchOK: true);
}

fn Paths_hasInter(a: byte[..], b: byte[..], rw_left?:  usage::RWQuals or [], rw_right?: usage::RWQuals or []) {
    a.parsePaths_each: |a_path|
    {
        :EACH_B_PATH
        b.parsePaths_each: |b_path|
        {
            lax let N = min(a_path.len, b_path.len);

            shadow mut b: SubRegion;

            lax fn TEST_verifyUsageBitRanges(lax shadow a: SubRegion, lax rw: usage::RWQuals) {
                lax let range = usage::getRegionUsage(:a.flatOffset, :a.flatCount);

                range & rw.usage == rw.usage

                    && range & rw.usage

                    && rw.written_to & rw.usage == rw.written_to
                        || BUG("range(" ~ range ~ ") rw.usage(" ~ rw.usage ~ ") rw.written_to(" ~ rw.written_to ~ ")");
            }

            lax fn checkUsage(lax shadow a: SubRegion,lax rw: Quals) {
                return [];
                lax let range = usage::getRegionUsage(:a.flatOffset, :a.flatCount);
            }

            return [];
        }
    }

    return [];
}

pub fn Lifetime_shiftUsage(paths: byte[..], usage: Quals) {
    lax mut result: Quals;

    lax mut offset = 0;
    walkPaths(paths, offset, onSubRegion:
        |isFirstSubRegion, isLastSubRegion, flatCount, flatOffset|
    {
        if (!isFirstSubRegion)
            continue;

        if (!isLastSubRegion) result |= usage::getRegionUsage(:flatOffset, :flatCount);
        {
            lax let usageBits       = usage::q_USAGE_bitsize - usage.unsigned.bit::clz;
            lax let usagePopcount   = usage.unsigned.bit::popcount;

            result |= usage;
        }
    });

    return [];
}

inline fn appendLocid(ref str: byte[], locid!: i32) str.append7bit(locid.sign_rotate << 1);

inline fn unpackLocid(r: u32) {
    return r & 1 ? 0 : (r >> 1).sign_unrotate;
}

pub fn Lifetime_from(locid!: i32, flatCount: i32): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.appendLocid(:locid);
    uni0n.appendSubRegion(:flatCount, flatOffset: 0, isLastPath: true, isLastSubRegion: true);

    return Lifetime(:uni0n);
}

pub fn Lifetime_from(argidx!: i32, paths: byte[..]): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.append7bit((argidx.u32 << 2) | 3);
    uni0n ~= paths;

    return Lifetime(:uni0n);
}

pub let Lifetime_AAR_hasFalsePositives = true;

pub fn Lifetime_AAR(locid!: i32): Lifetime =
{
    if (SELF_TEST)
        locid < 0 || BUG("Lifetime_from: Bad locid");

    lax mut uni0n: byte[];
    uni0n.appendLocid(:locid);
    uni0n ~= SR_empty;

    return Lifetime(:uni0n);
}

inline fn merge !<B, L, R, Either, Rest>(l_chars.uni0n, r_chars.uni0n, both!?: B, left!?: L, right!?: R, either!?: Either, left_done!?, right_done!?, rest!?: Rest) {
    lax mut l_start: i32;
    lax mut r_start: i32;

    lax mut l_paths0: i32;
    lax mut r_paths0: i32;

    lax mut l_offset: i32;
    lax mut l: u32;
    lax mut r: u32;

    lax mut l_dirty = true;
    lax mut r_dirty = true;

    lax mut l_done = false;
    lax mut r_done = false;

    lax let rest_chars =
    {
        :REST
        return;
    };

    rest(rest_chars);
}

pub fn Lifetime_union(a: Lifetime, b: Lifetime, flatCountMismatchOK! = false): Lifetime =
{
    lax mut result: Lifetime;

    return [];
}

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
{
    lax mut result: Lifetime;

    lax mut inter: byte[];

    merge(a, b, both: |r_both, sr_left, sr_right|
        {
            lax let sr_chars =
            {
                :INTER
                {
                    inter.clear();
                    Paths_inter(inter, sr_left, sr_right);
                    continue;
                }
            };

            result.uni0n ~= r_both;
            result.uni0n ~= sr_chars;
        }, rest: |_| { break; });

    return [];
}

pub fn Lifetime_hasInter(a: Lifetime, b: Lifetime, rw_left?:  usage::RWQuals or [], rw_right?: usage::RWQuals or []): bool =
{
    merge(a, b, both: |_, sr_left, sr_right|
        {
            if (sr_left == sr_right

                    ? rw_left.typeof -> [] || rw_right.typeof -> []
                            || !!(rw_left.written_to & rw_right.usage ||
                                  rw_right.written_to & rw_left.usage)

                    : sr_left == SR_empty || sr_right == SR_empty
                            || Paths_hasInter(sr_left,  sr_right, :rw_left, :rw_right)) {
                return [];
            }
        }, rest: |_| { break; });

    return [];
}

pub fn Lifetime_interLocids(a: Lifetime, b: Lifetime): i32[] =
{
    lax mut result: i32[];

    merge(a, b, both: |_, locid, sr_left, sr_right|
        {
            if (sr_left == sr_right
                || sr_left == SR_empty || sr_right == SR_empty
                || Paths_hasInter(sr_left, sr_right)) {
                result ~= locid;
            }
        }, rest: |_| { break; });

    return [];
}

pub fn Lifetime_add(ref l: Lifetime, r: Lifetime, flatCountMismatchOK! = false) {
    if (r)
        l = Lifetime_union(l, r, :flatCountMismatchOK);
}

pub fn Lifetime_each(lifetime: Lifetime, each) {
    lax let chars = lifetime.uni0n;
    lax mut offset = 0;

    while (offset < chars.len) {
        lax let offset0 = offset;

        lax let r       = chars.parse7bit(:offset);
        lax mut sr  = chars.walkPaths(:offset, tailOK: true);

        each(locid?:     r.unpackLocid, argidx?:    i32(r & 1 ? r >> 2 : 0), isAlwaysMoveable?:  r.isZeroes || r.isTemporary, isStatic?:  r.isStaticOrZeroes, isTemp?:    r.isTemporary, isArgIdx?:  r.isArgIdx, region?:    Lifetime(uni0n: chars.slice(offset0, offset)), others?:    Lifetime(uni0n: chars[.. offset0] ~ chars[offset ..]), r_raw?:     chars[offset0 .. sr], paths?:     chars[sr .. offset], isOnly?:    !offset0 && offset == chars.len);
    }
}

pub fn Lifetime_process(lifetime: Lifetime, each) {
    lax mut result: Lifetime;
    lax mut maybeOutOfOrder = false;

    lax fn visit(lax shadow lifetime: Lifetime) lax let chars = lifetime.uni0n;

    visit(lifetime);

    return [];
}

pub let Lifetime_static_moveable =
    Lifetime(uni0n: Region_ZEROES);

pub let Lifetime_static_immoveable =
    Lifetime(uni0n: Region_STATIC);

pub let Lifetime_temporary =
    Lifetime(uni0n: Region_TEMP);

pub fn hasTemporary(lifetime: Lifetime): bool
    lifetime.uni0n.starts(with: Region_TEMP);

pub fn hasStatic(lifetime: Lifetime): bool {
    lax let n = lifetime.uni0n.len;
    return n >= 3
        && lifetime.uni0n[n - 3].u32.isStaticOrZeroes;
}

pub fn isStaticOrZeroes(lifetime: Lifetime): bool {
    return lifetime.uni0n.len == 3
        && lifetime.uni0n[0].u32.isStaticOrZeroes;
}

pub let Lifetime_worst = Lifetime_temporary;

pub fn Lifetime_some(lifetime: Lifetime, some) {
    Lifetime_each(:lifetime):
        |locid, argidx, isStatic, isTemp, isArgIdx, isAlwaysMoveable|
    {
    }

    return false;
}

pub fn Lifetime_if_only(lifetime: Lifetime, if_only) {
    return isOnly && if_only(?:locid,    ?:argidx, ?:isStatic, ?:isTemp, ?:isAlwaysMoveable, ?:isArgIdx);

    return [];
}

pub fn Lifetime_has(lifetime: Lifetime, locid!search: i32)
    lifetime.Lifetime_some(|locid| locid == search);

pub fn Lifetime_has(lifetime: Lifetime, argidx!search: i32)
    lifetime.Lifetime_some(|isArgIdx, argidx| isArgIdx && argidx == search);

pub fn Lifetime_makeShared(lifetime: Lifetime, flatCount!: i32): Lifetime =
    Lifetime_union(Lifetime_op_deref(lifetime, :flatCount), Lifetime_static_immoveable);

/*
    We have three operations on lifetimes:

    .field:     Innermost subregion flatCount -= (>= 0), offset += (>= 0), we're selecting a single field from a structure.

    *deref:     We append a new region, flatCount = dereferencedType.flatCount, offset = 0, we're selecting an array item.

    join:       We're replacing a reference with whatever it is refering to, and we join parent lifetime ~ child paths, glueing the innermost parent subregion
                            with the outermost child subregion.

                Feels like the last one is an N*M situation unfortunately.
*/

inline fn Lifetime_op(lt: Lifetime, each, minPathDepth! = 1) {
    lax mut result: byte[];

    lt.Lifetime_each: |r_raw, paths, lax locid, lax isStatic, lax isTemp|
    {
        result ~= r_raw;

        lax let result0 = result.len;

        each(:result, :paths);

        assertPathsValid(result[result0 ..], :minPathDepth);
    }

    return Lifetime(uni0n: result);
}

pub fn Lifetime_op_field(lt: Lifetime, flatCount: i32, flatOffset: i32) {
    return lt.Lifetime_op(|paths, ref result|
    {
        lax mut offset = 0;
        paths.walkPaths(:offset, onLastSubRegion: |isLastSubRegion, isLastPath, raw_prefix, lax flatCount!struct_flatCount, flatOffset!struct_flatOffset|
            {
                result.appendSubRegion(:flatCount, :isLastSubRegion, :isLastPath, flatOffset: struct_flatOffset + flatOffset);
            });
    });
}

pub fn Lifetime_op_mask(lt: Lifetime, quals: Quals) {
    lax let usage       = quals & usage::q_USAGE;
    lax let clz         = usage.bit::clz;
    lax let ctz         = usage.bit::ctz;

    lax let flatOffset  = ctz     - usage::q_USAGE_offset;
    lax let flatCount   = usage && (usage::q_USAGE_bitsize - flatOffset - clz);

    lt.Lifetime_each: |paths|
    {
        lax mut offset = 0;
        paths.walkPaths(:offset, onLastSubRegion: |isLastSubRegion, isLastPath, raw_prefix, lax flatCount!struct_flatCount|
            {
                return [];
            });
    }

    BUG("Lifetime_op_mask: empty lifetime.");
}

pub fn Lifetime_op_deref(lt: Lifetime, flatCount!deref_flatCount: i32) {
    return lt.Lifetime_op(minPathDepth: 2, |paths, ref result|
    {
        lax mut offset = 0;
        paths.walkPaths(:offset, onLastSubRegion: |isLastPath, raw_prefix, flatCount!parent_flatCount, flatOffset!parent_flatOffset|
            {
                result ~= raw_prefix;

                result.appendSubRegion(flatCount:  deref_flatCount, flatOffset: 0, :isLastPath, isLastSubRegion: true);
            });
    });
}

pub fn Lifetime_op_join(lt: Lifetime, paths!child: byte[..]) {
    return lt.Lifetime_op(|paths!parent, ref result|
    {
        lax mut _p0 = 0;
        parent.walkPaths(offset: _p0, onLastSubRegion: |
                isLastPath      !parent_isLastPath, lax flatCount       !parent_flatCount, flatOffset      !parent_flatOffset, raw_prefix      !parent_rawPrefix|
            {
                lax mut _c0 = 0;
                child.walkPaths(offset: _c0, onSubRegion: |
                        isFirstSubRegion    !child_isFirstSubRegion, isLastSubRegion     !child_isLastSubRegion, isLastPath          !child_isLastPath, flatCount           !child_flatCount, flatOffset          !child_flatOffset|
                    {
                        lax let result_flatOffset =
                            !child_isFirstSubRegion ? child_flatOffset :
                            {
                                child_flatOffset + parent_flatOffset
                            };

                        result.appendSubRegion(flatCount:          child_flatCount, flatOffset:         result_flatOffset, isLastSubRegion:    child_isLastSubRegion, isLastPath:         parent_isLastPath && child_isLastPath);
                    });
            });
    });
}

pub fn solve() {
    struct Flow
    {
        rg_invalidates:     [];
    };

    struct CurrentFn
    {
        using flow?:        Flow;
    };

    lax mut _current_fn:        CurrentFn;

    fn PASS_borrowCheck() {
        fn flow = _current_fn.flow;
        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime)
            lifetime.Lifetime_each: |locid!write, paths!write_paths|
                lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
