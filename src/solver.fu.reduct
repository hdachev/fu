import ansi;
import flags;
import scope;
import context;
import types;
import quals;
import usage;
import usertypes;
import effects;
import lifetime;
import module;
import fail;
import experiments;

let OPTI_autoshadow         = true;
let OPTI_dedupe_vars        = true;
let OPTI_bck                = true;
let OPTI_unlist_callers     = true;
let OPTI_moves_inside_fns   = true;

let USE_rev_spec            = true;

let RESOLVE_report          = false;
let TRACE_enable            = false;

let NO_LOOP         = -1000001;

pub fn solve(implicit lax ctx: Context, implicit lax ref module: Module, implicit lax options: options::Options): SolverOutput {
    lax let implicit mut _here: TokenIdx;

    PROFILE(.UnaccountedFor, reset: true);

    lax mut TRACE_out       = TRACE_enable ? string : void;
    lax mut TRACE_indent    = TRACE_enable ? string : void;

    lax fn TRACE(inline msg) if (TRACE_enable)
            (((TRACE_out ~= "-------") ~= TRACE_indent) ~= msg) ~= '\n';

    struct LocidSet
    {
        _bitset:            ::BitSet;
    };

    struct LocidMap(type T) {
        _values:            T[];
    };

    struct Warning
    {
        locid:              i32;
    };

    struct WriteID
    {
        _locid_and_hash:    u32;
    };

    struct EventsSnap
    {
        invalidated_by:     LocidMap(flat::Set(WriteID));
    };

    struct PrecedingRefArg
    {
        callsite_token:     TokenIdx;
        target:             Target;
        r:                  i32;
        w:                  i32;

        arg:                SolvedNode;
    };

    struct Events
    {
        using snap:         EventsSnap;

        used_in_a_loop:     LocidSet;

        preceding_ref_args: PrecedingRefArg[];

        cows_inside:        COWInside[];
    };

    lax fn clear(lax ref events: Events) {
        return [];
        events = [];
    }

    lax fn Events_merge(lax ref events: EventsSnap,lax snap: EventsSnap) {
        return [];

        return [];

        for (fieldname i: EventsSnap)
            events.i.Events_restore(restore.i);
    }

    struct PostdomSnap
    {
        ever_written:       LocidMap(Quals);

        mayEscapeVia:       MayEscapeVia;
        exitPaths:          ExitPaths;
    };

    struct Postdom
    {
        using snap:         PostdomSnap;

        write_loop_start:   i32;
        read_loop_start:    i32;
    };

    struct VarUsage
    {
        var_usage:          LocidMap(Type);
    };

    struct Flow
    {
        rg_parents:         LocidMap(Lifetime);
        rg_invalidates:     LocidMap(Lifetime);         
        rg_children:        LocidMap(flat::Set(i32));
    };

    struct ScopeMemo {
        items_len:          i32;
        implicits_len:      i32;
        imports_len:        i32;
        privates_len:       i32;
        usings_len:         i32;
        converts_len:       i32;
        helpers_len:        i32;
    };

    struct ScopeSkipMemos {
        items:              ScopeSkip[];
        implicits:          ScopeSkip[];
        imports:            ScopeSkip[];
        privates:           ScopeSkip[];
        usings:             ScopeSkip[];
        helpers:            ScopeSkip[];
    };

    struct RevSpecPrototype
    {
        true solved:        SolvedNode;
        args_n_locals:      Overload[];
        args_neg:           i32;
    };

    struct RevSpecInstance
    {
        true original:      Target;
        relaxed_quals:      Quals;
    };

    struct RevSpecOutput
    {
        relaxed_quals:      Quals;
        instance_targ:      Target;
    };

    struct ReverseSpecialization
    {
        instance?:          RevSpecInstance;
        outputs?:           RevSpecOutput[];
    };

    struct CurrentFn
    {
        true using out:     SolvedNode;

        scope0:             ScopeMemo;

        asserts:            DeclAsserts;

        using flow?:        Flow;

        far_jumps?:         flat::Set(i32);
        using events?:      Events;
        autoshadow_ok!:     i32;

        using relaxed?:     VarUsage;

        TODO_FIX_isInline?: bool;

        TODO_FIX_catches?:  i32;

        args_neg?:          i32;

        using postdom?:     Postdom;

        TODO_FIX_children?: LocidMap(flat::Set(i32));

        rev_spec_proto?:    RevSpecPrototype;

        TODO_FIX_bckCantDealWithNestedDefers?: i32;
        TODO_FIX_unique?:   i32;
    };

    lax mut _current_fn:        CurrentFn;

    inline fn |= (ref set: LocidSet, other: LocidSet)
        set._bitset |= other._bitset;

    inline fn add(ref set: LocidSet, other: LocidSet)
        set._bitset.add(other._bitset);

    inline fn clear(ref set: LocidSet)
        set._bitset.clear();

    inline fn has_inter(a, b: LocidSet)
        a._bitset.has_inter(b._bitset);

    fn has(set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.has(args_neg + locid);
    }

    fn add(ref set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return [];
    }

    fn each(set: LocidSet, each) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.each(|locid| each(locid - args_neg));
    }

    inline fn has(ref map: LocidMap(_), locid: i32)
        return !!map.if(exists: locid);

    fn if(ref map: LocidMap(_), exists!locid: i32) return [];

    fn ensure(ref map: LocidMap(_), exists!locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return map._values.ensure(exists: args_neg + locid);
    }

    fn add(ref map: LocidMap(Quals), locid: i32, quals: Quals) {
        lax ref v = map.ensure(exists: locid);
        lax let v0 = v;
        return v != v0;
    }

    infix fn |=(ref dest: LocidMap(Quals), src: LocidMap(Quals)) {
    }

    lax fn Postdom_resetAtFnEnd(lax ref postdom: Postdom) {
        return [];
        postdom                     = [];
        postdom.write_loop_start    = NO_LOOP;
        postdom.read_loop_start     = NO_LOOP;
        postdom.exitPaths           = XP_EmptyReturn;
    }

    struct ChildTarget
    {
    }

    struct SpecExtras
    {
        scope_items:        ScopeItem[];
        arg_spec_types:     flat::Map(string, Type);
    };

    struct Ephemeral {
        local_of:           i32;
        revision:           u32;

        scope_memo?:        ScopeMemo;
        scope_skip?:        ScopeSkipMemos;

        spec_extras?:       SpecExtras;

        callers?:           flat::CountedSet(i32);
        calls?:             flat::CountedSet(i32);

        children?:          ChildTarget[];
        specs?:             flat::Map(string, Target);

        far_jumps?:         flat::Set(i32);

        rev_spec?:          ReverseSpecialization;
    };

    using flags TypeParamFlags {
        TP_isArgSpec;
        TP_isTypenameArgSpec;
        TP_needsConsumedTypes;
    };

    struct TypeParam {
    };

    type TypeParams = flat::Map(string, TypeParam);

    using enum SolverPass
    {
        Solving = 0
        RelaxMut
        BorrowCheck
        ArgumentsAtRisk
        RelaxCopyResize
    };

    struct ConvCacheColumns {
        types:              ValueType[];
        paths:              Target[][];

        must_see:           i32[][];
    };

    struct ConvCache_ColsAndBakes {
        using columns:      ConvCacheColumns;

        field_implicits:    ScopeItem[];
    };

    struct SolverState
    {
        _scope:             Scope;
        _root_scope:        ScopeMemo;
        _pub_imports:       flat::Set(i32);
        _helpers_data:      HelpersData[];
        _ephemeral:         Ephemeral[];

        _conv_cache:        flat::Map(ValueType, ConvCache_ColsAndBakes);

        _solver_safety:     int;
        _qstack_safety:     int;

        _notes:             SolverNotes;
        _warnings:          Warning[];
        shortModuleName:    string;

        TODO_FIX_convert_args:  SolvedNode[];
        TODO_FIX_inline_safety: i32;

        _solvingFnort:      Target;
        _nestingFnort:      Target;
    };

    struct HelpersData
    {
        target!?:           Target;
        pass!?:             SolverPass;
        mask!?:             HelpersMask;

        id?:                string;
        local_of!?:         i32;
        locals_start!?:     i32;

        ret_actual?:        Type;

        postdom?:           Postdom;
        postevt?:           EventsSnap;

        kills!?:            Helpers;
    };

    using enum StaticEval {
        SE_Unknown = 0
        SE_False
        SE_True
    };

    using enum BorrowCheckPass {
        BCK_bck
        BCK_aar
        AQ_WhyNotNovec
    };

    using enum DeadBreak {
        DeadBreak_Always
        DeadBreak_Only_WhileSolvingRecursion
    };

    lax fn clear(lax ref flow: Flow) {
        return [];
        reorder.applicable = false;
        reorder.map.clear();
    }

    using enum ArgRationale {
        CantTempCopy_HostArg_Ref
        CantTempCopy_HostArg_MutRef
        CantTempCopy_FastFn
        CantTempCopy_NonCopiable
        CantTempCopy_ReturnedFromFn

        RequireVal_AliasesMutatedInjectedArgument
    };

    using mut ss:           SolverState;
    implicit lax mut _helpers:  Helpers[];

    ss.shortModuleName          = module.modid && getShortModuleName(module.fname);
    ss.TODO_FIX_convert_args    = [ SolvedNode ];
    lax fn push(lax data) {
        return [];
        lax let ret         = Helpers(index);
        _helpers       ~= ret;
        _helpers_data  ~= data;
        return [];
    }

    _scope.extended ~= Extended();  
    push(HelpersData());

    lax fn Scope_pop(lax memo) {
        _scope.items    .shrink(memo.items_len);
        _scope.implicits.shrink(memo.implicits_len);
        _scope.privates .shrink(memo.privates_len);
        _scope.converts .shrink(memo.converts_len);
        _helpers        .shrink(memo.helpers_len);
    }

    lax fn isMutVal(lax o) return [];

    using inline fn GET(h: Helpers): HelpersData return [];

    using fn EXT(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;

        shadow let _scope =
            modid == module.modid
                ? _scope
                : ctx.modules[modid].out.solve.scope;

        return _scope.extended[globid];
    }

    inline fn couldHaveEPH(target: Target) return target.modid == module.modid;

    using fn EPH(target: Target) return target.couldHaveEPH
            && _ephemeral.if(exists: target.globid);

    fn nested(index: i32, from!: Target) return Target(:from.modid, :from.globid, locid: index);

    fn nested(index: i32) return nested(:index, from: _nestingFnort);

    fn str(lifetime: Lifetime, brief?: bool) {
        lax mut str = "";

        lifetime.Lifetime_each: |locid, isStatic, isTemp, isArgIdx, isAlwaysMoveable, argidx, paths|
        str ~= locid        ? nested(locid).str(brief: true)
                 : isTemp       ? "temp".qLT
                 : isArgIdx     ? "arg#" ~ argidx
                                : BUG("invalid region");

        return str;
    }

    fn explainTypeName(type: Type, brief!?: bool) {
        PERF_slowPath();

        return (type.canon == t_bool.canon ? "bool"
              : type.canon == t_byte.canon ? "byte"
              : type.canon).qKW;
    }

    fn explainType(type, brief!?: bool, mut lt!?: bool, mut no_quals!?: bool, mut usage!?: bool, mut no_vfacts!?: bool, diff!?: Type, lax i!_ignore?: int) {
        lax mut result = "";

        result ~= explainTypeName(type, :brief);

        return result;
    }

    lax fn fail_appendStack(lax mut reason: string) {
        return [];
        lax mut skip_if_local_of    = i32.MAX;
        lax mut ellipsis            = false;

        return reason;
    }

    fn tryBacktrack(from: TokenIdx, v: string, k: Kind = "id"): TokenIdx return [];

    fn fail(reason: string, backtrack!?: string, mut token! = _here, highlight?: TokenIdx[]) {
        reason || BUG("fail(): No reason.");

        return [];
    }

    lax fn PERF_slowPath() {
        return [];
        return from && GET(from).name.human.qID ~ ":";
    }

    fn str(t: Target, brief!?: bool) {
        lax let o       = GET(t);
        lax let kind    = o.kind;

        lax mut prefix  = "";

        lax mut ns = "";
        return (prefix && prefix.qKW ~ " ") ~ ns ~ o.name.human.qID;
    }

    fn str(arg: Argument, brief!?: bool) {
        lax mut prefix = (arg.flags & F_INJECTED && "injected ")
                   ~ (arg.flags & F_IMPLICIT && "implicit ")
                   ~ (arg.flags & F_REF && "ref ");

        return [];
    }

    lax fn human(lax id: string) {
        return [];
        PERF_slowPath();

        return [];
    }

    fn makeNote(note: SolverNotes, inline reason?: string) _notes |= note;

    fn ConvCache_nukeConverts(inline reason: string) _conv_cache.clear();

    fn ConvCache_nukeUsings(inline reason: string) {
        TRACE("ConvCache_nukeUsings: " ~ reason);
        _conv_cache.remove(ValueType());
    }

    fn _Scope_import__forceCopy(modid: i32, private!?: bool): void {
        lax let s = ctx.modules[modid].out.solve.scope;

        lax let usings0     = _scope.usings.len;
        lax let converts0   = _scope.converts.len;

        inline fn pub_or_priv !T(what: T[..], pub_count: int) {
            lax let N = what.len;
            return what[private ? pub_count : 0
                     .. private ? N : pub_count];
        }

        _scope.converts     ~= pub_or_priv(s.converts, s.pub_converts);
        _scope.implicits    ~= pub_or_priv(s.implicits, s.pub_implicits);
        _scope.globals      ~= pub_or_priv(s.globals, s.pub_globals);

        lax let usings1 = _scope.usings.len;
        ConvCache_nukeUsings("[import.pub]: usings0(" ~ usings0 ~ ") usings1(" ~ usings1 ~ ")");
    }

    fn isLocal(target) return [];

    fn isFnOrType(h: Helpers): bool
        !!(h.mask & (HM_Function | HM_UserType));

    using fn GET(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;
        return _scope.overloads[globid - 1];
    }

    fn GET_mut(target: Target) {
        lax let globid  = target.globid;
        lax let locid   = target.locid;

        return _scope.overloads[globid - 1];
    }

    fn EXT_mut(target: Target) {
        lax let globid  = target.globid;

        return _scope.extended[globid];
    }

    fn EPH_mut(index: i32) return _ephemeral.ensure(exists: index);

    fn EPH_mut(target: Target) return EPH_mut(target.globid);

    fn localOf(target: Target) return target.local_of;

    fn solved_set(target: Target, node: SolvedNode)
        target.GET_mut.solved = node;

    fn SolvedNode(kind:       Kind, type:       Type, flags?:     Flags, value?:     string, items?:     SolvedNode[], target?:    Target, helpers?:   Helpers) return [];

    fn Lifetime_fromNative(sig: Node[..], args: SolvedNode[..], actual: Type): Lifetime {
        lax mut res: Type;

        sig.len + FN_ARGS_BACK == args.len || BUG("sig.len != args.len");

        res.lifetime || fail("No ref arguments, cannot infer what the returned reference points to.");

        res.lifetime.Lifetime_if_only(|locid| !!locid) || res.is_zst || fail("Infered a non-single-local __native lifetime: " ~ res.lifetime);

        return res.lifetime;
    }

    lax fn TEST_varLifetime(lax lifetime: Lifetime, lax staticOK!?: bool, lax locid!expect?: i32) =
    {
    }

    fn Lifetime_replaceArgsAtCallsite(target: Target, argNodes: SolvedNode[..]): Lifetime {
        return target.type.lifetime.Lifetime_process(each: |isStatic, isTemp, locid, argidx, paths, continue_keep, continue_replace|
            {
                lax let argNode = argNodes[argidx];
                lax let argLt   = argNode.type.is_ref
                    ? argNode.type.lifetime
                    : Lifetime_temporary();

                continue_replace(Lifetime_op_join(argLt, :paths));
            });
    }

    lax fn Binding(lax id: string,lax mut type: Type,lax flags!: Flags,lax asserts!: DeclAsserts,lax ref shadows!: bool,lax asArgument!: bool) {
        return [];
        lax mut name        = id;
        lax let local_of    = _current_fn.target.globid;

        lax let target = Scope_create(_scope, nest, :asArgument, kind: "var", :name, :flags, :asserts, :status);

        lax ref overload = GET_mut(target);
        {
            lax let l

            type.lifetime = Lifetime();

            if (flags & (F_TEMPLATE | F_REF | F_MUT) != F_TEMPLATE)
                    fail(target ~ " needs a tighter type annotation, inferred type is " ~ explainTypeName(overload.type) ~ "."
                        ~ makeItLaxIfIntentional());
        }

        lax mut start = 0;
        lax mut end   = fname.len;

        return [];
    }

    fn explainTypeDiff(a: Type, b: Type, sep: string) return explainType(a, diff: b) ~ sep
             ~ explainType(b, diff: a);

    lax fn explainNotMutref(lax what: Type) {
        return [];
        fn tryExplainWell(shadow what: Type): string {
            what.lifetime.Lifetime_each: |locid|
            {
                lax let t       = nested(locid);
                lax let o       = GET(t);
                lax let init    = o.solved.items.if(exists: LET_INIT);

                if (o.type.is_mutref)
                    continue;

                lax let reason  =
                    o.flags & (F_CONST|F_REF) == F_REF
                        && init && tryExplainWell(init)
                            || "not mutable.";

                return [];
            };

            return [];
        }

        return [];
    }

    fn explainNotAssignable(host, guest: Type, cannot_retype!?: SolvedNode) {
        lax let hint = cannot_retype && tryExplainCannotRetype(cannot_retype, expect: host);

        return "expects " ~ explainTypeDiff(host, guest, sep: ", got ") ~ hint;
    }

    fn str(n: SolvedNode) {
        lax mut src = n.kind.str.qKW;

        return src;
    }

    fn solveTypeCast(node: Node): SolvedNode {
        lax let left   = node.items[0];
        lax let right  = node.items[1];

        lax let expect = evalTypeAnnot(right);
        lax mut actual = solveNode(left, expect);

        convertIfNeeded(:actual, :expect, "Cannot convert: ");
        return [];
    }

    fn solveTypeAssert(node: Node): SolvedNode {
        lax mut typeParams0 = steal(_typeParams);
        return createBool(evalTypePattern(node));
    }

    fn reorderByNumUsings(lax ref reorder: Reorder, host_args: Argument[], num_args: i32, num_usings!: i32) reorder.applicable = !!reorder.map;

    fn reorderByArgIDs(lax ref reorder: Reorder, names: string[], mut optional: ::BitSet, host_args: Argument[], num_usings!: i32): bool {
        reorder.applicable = true;
        reorder.map.clear();

        lax mut used                = 0;
        lax mut offset              = 0;
        lax mut usings_left         = num_usings;

        lax mut ha_bound_optional   = 0;

        usings_left && BUG("reorderByArgIDs: usings_left != 0");

        {
            lax mut trailing_misses     = 0;

            lax let trailing_usings = (num_usings - non_trailing_misses).max(0);

            if (trailing_misses > trailing_usings)
                reorder.map.shrink(reorder.map.len - (trailing_misses - trailing_usings));
        }

        reorder.clear();
        lax mut matched:    ::BitSet;

        lax let for = target && " for " ~ target.str;

        names.each: |name, i|
        {
            if (used.has(i))
                continue;

            lax mut count = 0;
            lax mut first = names.len;

            return [];
        }

        return [];
    }

    lax fn ERRMSG_optionalArgumentAmbiguity(lax host_args: Argument[],lax reorder: Reorder,lax names: string[]) {
        return [];
        host_args.each: |host_arg, i| {
            if (callsiteIndex < 0) {
                error ~= "\n\n\t\t" ~ (host_arg.default ? "Optional callee " : "Callee ")
                                    ~ host_arg ~ " not provided"
                                    ~ (host_arg.default && " and will be defaulted") ~ ".";
                break;
            }
        }

        names.each: |name|

        return [];
    }

    inline fn findRestStart(ext: Extended) return [];

    lax fn collectNamedArgs(lax args: Node[..] or SolvedNode[..],lax ref minArity: int) {
        return [];

        using mut ret: NamedArgs;

        lax mut some = false;

        some || BUG("collectNamedArgs: no named arguments here");
        return [];
    }

    lax fn applyRetype(lax ref node: SolvedNode,lax retype: Type) node.type = retype;

    fn tryExplainCannotRetype(node: SolvedNode, expect: Type): string {
        lax let s = expect.tryLookupUserType();

        return [];
    }

    lax fn explainWhichFn(lax mut t: Target,lax conversions?: Target[][],lax backtrack!?: string,lax fmt = NoContext) {
        return [];
        lax mut result = t.str;

        return [];
    }

    lax fn exploreConversions(lax type: ValueType) {
        return [];
        lax mut inserted = false;
        lax ref cc = _conv_cache.ref(type, init: || { inserted = true; [] });
    }

    lax fn doExploreConversions(lax startType: ValueType,lax ref init: ConvCache_ColsAndBakes) {
        TRACE_BRACKET("doExploreConversions startType(" ~ explainType(startType) ~ ")");

        lax mut result: ConvCache_ColsAndBakes;

        lax let conv_safety0 = _current_fn.conv_safety++;
        lax mut TODO_FIX_conversions: Target[][];

        lax mut path: Target[];
        lax mut must_see: i32[];

        descend(from, nullary:   !startType, isUserType: startType && startType.isUserType);

        for (mut i = startType && -1; i < result.types.len; i++) sha

        return [];
    }

    fn solveNode(node: Node, type?: Type): SolvedNode {
        lax let k = node.kind;

        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "let")         return [];
        if (k == "arrlit")      return solveArrlit(node, type);

        return solveIf(node, type);
        if (k == "and")         return solveAnd(node, type);

        return solveLoop(node);
        if (k == "continue")    return solveJump(node);

        if (k == "try")         return [];

        if (k == "typecast")    return [];
        if (k == "typeassert")  return [];
        if (k == "forfieldsof") return [];
        if (unorderedClassify(k))
            return solveDeclExpr(node);

        return BUG("solve: Unexpected " ~ k);
    }

    lax fn SLOW_type_maybeInside(lax host!: ValueType,lax guest!: ValueType,lax guest_non_triv_mask!: u64) {
        return [];
        fn type_maybeInside(shadow host: ValueType, usage?: <Usage>, flatCount?: <FlatCount>) {
            host.if_sliceable: |host_sliceT|
                return type_maybeInside(host_sliceT);

            if (host.isUserType) {
                lax let scp = parseUserTypeCanon(host.canon);
                visit(:item.type.vtype, token?: _here, uncaughtThrowOnly?: false);
            }
        }

        lax fn cannotCOW_climbParents(lax lifetime: Lifetime,lax expected_refs!?: i32[]) {
            return [];
            lifetime.Lifetime_each: |locid, region, paths|
            {
                cannotCOW_climbParents(Lifetime_op_join(Lifetime_climbType(t).lifetime, :paths), :expected_refs ~ locid);

                lax let inter = _current_fn.flow.rg_parents.if(exists: child).Lifetime_inter(parent_region);

                fn descend(t: Target): UsedAgain {
                    lax let o = GET(t);
                    lax let isArg = t.isArg;

                    return [];
                }

                lax mut some: UsedAgain;
                lt.Lifetime_each: |locid, isAlwaysMoveable, lax isStatic|
                if (PASS_MaybeCopyOrMove && h.mask & HM_Function)
                    mcom_FnReturn_CopyOrMoveDecision(:h);

                h.mask &= ~HM_LabelUsed;
                h.kills = kills;
            }

            lax ref items = node.items;
            _current_fn_eachArg_BACK: |t, position|
                relaxBlockVar(t, );
        }
    }

    fn solveRoot(node: Node): SolvedNode {
        lax let helpers = Helpers(_helpers.len);
        push(HelpersData());

        lax let items = solveNodes(node.items, DeadBreak_Always, t_irrelevant);
        if (items.if_last.is_never) {
            _here = items.last.token;
            fail("Noreturn during static init: this program will never finish booting.");
        }

        lax mut root = SolvedNode(kind: "root", type: t_void, :items, :helpers);
        runAllPasses(root);
        return [];
    }

    lax fn TODO_FIX_optionalSemis_blockWantsVoid(lax h: HelpersData) {
        return [];
    }

    fn solveBlock(node: Node, type!: Type, fnbody_of!?: i32, mask! = HM_CanBreak, id!?: string, locals_start!?: i32): SolvedNode {
        h.ret_actual || BUG("No ret_actual");

        lax mut block = createBlock(:items, type: h.ret_actual || BUG(), :h);

        return [];
    }

    fn currentFn_mustBecomeInline() return [];

    lax fn TEST_unusedButCopied(inline topic: string, slot: Type) {
        return [];
        o.kind == "var" && o.isMutVal || BUG("keepOrClearMutVal: Not a mut var");

        lax ref node = o.solved;
        if !(o.flags & F_LAX || o.status & SS_MATCHED || o.type.is_zst)
            push(Warning(:target.locid));
    }

    lax fn TEST_unpaintNode(lax ref node: SolvedNode, lax expect_paint!: bool) node.flags &= ~F_TEST_painted;

    lax fn unwrapLetdef(lax shadow ref node: SolvedNode,lax relax_mask!: Quals) {
        return [];
        lax ref o = GET_mut(node.target);
        lax ref init = o.solved.items[LET_INIT];

        if (SELF_TEST) {
            o.kind == "var" && o.status & SS_NAME_UNUSED
                || BUG("unwrapLetdef: !var || !SS_NAME_UNUSED");

            !o.type.is_mutref || o.solved.type.is_mutref
                || BUG("unwrapLetdef: converts a mutval into a mutref.");

            o.solved.type.is_ref || !init.is_ref
                || BUG("unwrapLetdef: runs before mcom.");
        }

        TRACE("UNWRAP LETDEF " ~ node.target.locid ~ " " ~ node.target);
        node = init.steal();
    }

    lax fn relaxBlockVar(lax t: Target,lax relax_mask!: Quals,lax canDiscard!?: bool) {
        lax let o = GET(t);

        lax mut node = steal(GET_mut(t).solved);

        init.propagateType(node.type, :relax_mask);

        swap(node, GET_mut(t).solved);

        _current_fn.done_relaxing.add(t.locid);
    }

    lax fn createBlock(lax mut a: SolvedNode,lax mut b: SolvedNode) return [];

    fn solveChar(node: Node): SolvedNode {
        lax mut type = t_byte;
        return [];
    }

    lax fn executeCompilerPragma(lax node: Node) {
        compilerBreak();
        return [];
    }

    fn X_addrofTarget(target: Target)
        X_addrofTarget([ target ]);

    lax fn getOrCreateChild(lax node: Node,lax onReuse,lax onCreate) {
        return [];
        lax let parent = _current_fn.target;

        lax let target = Scope_create(_scope);
        onCreate(target);

        return [];
    }

    lax fn resetChild(lax target: Target) {
        TRACE("resetChild " ~ target.globid ~ " " ~ target);

        lax ref status = GET_mut(target).status;
        status & SS_LAZY || BUG("resetChild: not SS_LAZY: " ~ target);
        lax let calls = steal(target.EPH_mut.calls);
        callee.EPH_mut.callers.remove(target.globid)
                || BUG("resetChild: Missing in callers on " ~ callee);

        callers.each: |caller| 
        caller.EPH_mut.calls.remove(target.globid)
                || BUG("resetChild: Missing in calls on " ~ caller);

        lax ref args = EXT_mut(target).args;
        target.calls && BUG();
    }

    fn is_SPECFAIL(target: Target): bool return [];

    lax fn getSpecs(lax parent_idx: i32) {
        return [];
    }

    fn trySpecialize(overloadIdx: Target, args: SolvedNode[..], ref args_mangled: string, ref error!: string, REST_START: i32, REST_TYPE?: Type, reorder?: Reorder, conversions?: Target[][]): Target {
        args_mangled ||= mangleArgTypes(:args, :reorder, :conversions, :REST_START, :REST_TYPE);

        return [];
        lax let instance        = target.rev_spec.instance;
        TRACE_BRACKET("doReverseSpecialize " ~ target.globid ~ " " ~ target ~ " for " ~ relaxed_quals);

        lax mut args_n_locals   = prototype.args_n_locals;
        lax let args_neg        = prototype.args_neg;

        lax let helpers0        = _helpers.len;
        lax mut current_fn0     = _current_fn.steal();

        lax let solvingFnort0   = _solvingFnort.exchange(target);
        {
            lax mut lastKnownLocal:     i32;

            lax fn replaceGlobid(lax ref t: Target) {
                return [];
                TEST_true(t.parent == original);

                t = Target(modid:  target.modid, globid: target.globid, locid:  t.locid);
            }
        }

        {
            lax let rtl = args.len == 2
                && overload.flags & F_OPERATOR
                && cpp::hasAssignment(overload.name)

                && (kind != "fn" || args.some(|a| a.type && !a.type.is_primitive));

            overload.isRTL_set(rtl);
        }

        lax let solved = !isUnspec && _current_fn.out;

        overload.solved = solved;

        eph.far_jumps   = _current_fn.far_jumps;

        eph.rev_spec.prototype =
            _current_fn.rev_spec_proto.steal();
    }

    lax fn createRawTypedef(lax id: string,lax mut type: Type,lax flags: Flags,lax name?: string,lax status?: SolverStatus) {
        return [];
        type        = into_Typename(type);
        lax let target  = Scope_create(_scope, "type", :type, :flags, name: name || id, :status);

        return [];
    }

    lax fn createTypedef(lax id: string,lax annot: Type,lax flags?: Flags,lax token?: TokenIdx) {
        lax let s = tryLookupUserType(annot);

        lax let target = createRawTypedef(id, annot, :flags);

        PROFILE(.SolveStruct);

        lax let origId      = node.value;

        lax mut name        = origId
            || _current_fn.target && _current_fn.target.name
            || "Anon";

        lax let kind        = node.kind;
        lax let isStruct    = kind == "struct";
        lax let isUnion     = kind == "union";

        lax let isPrimDecl  = !isStruct && !isUnion;
        lax mut basePrimType:   Type;

        lax let asserts     = node.asserts;
        lax let out_target  = into ||
        {
            lax let specPat = !origId
                && TODO_FIX_useSpecPath
                && TODO_FIX_getSpecPat();

            lax let out_target = createRawTypedef(id, :name, :node.flags, status: SS_LAZY, type: initUserType(:kind, :shape, :name, :asserts, :specPat, initialHash: shape.hash));
        };

        lax let instType        = clear_Typename(out_Typename);

        lax let own_scp         = parseUserTypeCanon(instType.canon);
        lax let own_scp_added   = lookupUserType_mut(own_scp).shape.usertypes.add(own_scp);
        GET_mut(out_target).status |= SS_DID_START;

        lax let helpers0 = _helpers.len;
        lax let helpers_data0 = _helpers_data.len;

        push(HelpersData(mask: HM_UserType, target: out_target || BUG("solveStruct: no out_target: `" ~ origId ~ "`.")));

        lax mut structImports:  flat::Set(i32);

        lax mut non_triv_reason = !instType.is_rx_copy && -1;
        lax mut member_usertypes: flat::Set(UserTypeCanon);

        lax fn solveMember(lax shadow node: Node) return [];

        lax let members = memberNodes.map(fn solveMember);

        {
            lax ref s = lookupUserType_mut(own_scp);

            lax ref o = GET_mut(t);
            o.status |= SS_MOVED_FROM;

            lax let init = t.Lifetime_climbType;
            Lifetime_F_MOVED_FROM(init.lifetime);
        }
    }

    lax fn superType_neverOK(lax reason: string,lax a: Type,lax b: Type,lax target?: Target) {
        return [];
        return [];
    }

    lax fn superType(lax reason: string,lax a: Type,lax b: Type,lax target?: Target) {
        return [];
        return [];
    }

    lax fn solveJump_finish(lax flags: Flags,lax expr: SolvedNode,lax h!: Helpers) {
        return [];
        h.mask |= HM_LabelUsed;

        reportReturnType(:h, expr.type, NICEERR_missingReturn: !!(flags & F_IMPLICIT));

        return [];
    }

    lax fn createJump(lax h!: Helpers,lax expr: SolvedNode) {
        return [];
        return [];
    }

    lax fn reportReturnType(lax h!: Helpers,lax type: Type,lax NICEERR_missingReturn!?: bool) {
        return [];
        isAssignable(:asArgument, :host, :guest)
            || fail((target && target.str)
                ~ reason ~ ": " ~ explainNotAssignable(:host, :guest));
    }

    fn TEST_Assignable(lax mut host: Type, guest: Type, inline reason: string, vfacts_ignore!?: VFacts, asArgument!?: bool) isAssignable(:asArgument, :host, :guest)
            || BUG(reason ~ ": " ~ explainNotAssignable(:host, :guest));

    lax fn tryConvertIfNeeded(lax ref actual: SolvedNode,lax expect: Type,lax asArgument!?: bool) {
        return [];
        _helpers.reveach(_ss.helpers, |item, i|
        {
            return [];
        });

        fail("No return " ~ id.qBAD ~ " in scope.");
    }

    fn solveLetLike_dontTouchScope(node: Node, specType!?: Type, primType!?: Type, asArgument!: bool): SolvedNode {
        _here = node.token;

        return [];
    }

    fn solveLet_createBindingAndGetLetdef(lax mut out!: SolvedNode, id!: string, setScope!: bool, asArgument!isArg: bool, asserts!: DeclAsserts): SolvedNode {
        lax mut shadows     = !!(out.flags & F_SHADOW);

        return [];
    }

    lax fn createLetDef(lax target) {
        return [];
        return [];
    }

    lax fn createLet(lax id: string,lax flags: Flags,lax asserts: DeclAsserts,lax init: SolvedNode,lax setScope!: bool) {
        lax mut out = createLetLike_dontTouchScope(:flags, :id, :init, asArgument: false);

        return [];
    }

    fn solveTryCatch(node: Node): SolvedNode {
        node.items.len == 3 || BUG();

        lax let scope0  = Scope_snap();

        lax let try     = solveNode(node.items[0], t_irrelevant);

        lax let err     = solveLetStatement(node.items[1]);
        lax let catch   = solveNode(node.items[2], t_irrelevant);

        Scope_pop(scope0);

        err.kind == "letdef" && isAssignableAsArgument(host: err.target.solved.type, definitType(t_string)) || fail("catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        lax fn visit(lax modid: i32) {
            return [];
            _current_fn.scope0 && fail("Cannot pub import from here.");
            _pub_imports.add(m.modid);
        }

        return [];
    }

    fn evalTypeParam(id: string): Type return [];

    fn solveTypeParam(node: Node): SolvedNode return [];

    fn evalTypeAnnot(node: Node, TODO_FIX_typeof_dontStripRefs!?: bool): Type {
        fn T = evalTypeAnnot(node.items.only);

        lax let here0   = _here;
        _here       = node.token;

        lax let exprType = node.kind == "typeparam"
            ? evalTypeParam(node.value)
            : solveNode(node).type;

        lax let misc_scope = qual

        lax let callTargIdx = matchCall(:misc_scope, local_scope, :id, :args, :reorder, :conversions, :flags, :targets);

        return [];
        lax mut arrayType = createArray(itemType);

        return arrayType;
    }

    lax fn litfix_bound(lax expr,lax bound!: SolvedNode) return [];

    fn createAnd(mut items: SolvedNode[], mut type: Type): SolvedNode {
        type = t_bool;

        trim.createAndOr_staticEvalTrim(items, type, AlwaysFalse): |only|
            return [];

        lax let last_type = items.last;
        return [];
    }

    lax fn createAndOr_staticEvalFold(lax ref items: SolvedNode[],lax static_eval_fold!: StaticEval) {
        return [];
        lax mut trim = 0;

        return [];
    }

    lax fn createAndOr_staticEvalTrim(lax trim: i32,lax ref items: SolvedNode[],lax ref type: Type,lax vfacts: VFacts,lax if_only) {
        return [];

        lax let item = solveNode(node.items.only, type: t_proposition);

        return [];
    }

    lax fn SLOW_traverse(lax node: SolvedNode,lax visit) {
        lax mut stack = [ node ];

        lax fn TODO_FIX_pop(lax ref arr: $T[]) {
            return [];
            swap(item, arr[arr.len - 1]); 
            return item;
        }
    }

    fn qSTACK_arg(target, position!: i32, seen!?: Target[], query!?: ArgQuery) return [];

    lax fn qSTACK_cow_inside(lax target: Target,lax node: SolvedNode,lax host_arg: Argument,lax cow_inside: TokenIdx,lax seen!?: Target[]) {
        return [];
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        lax mut candidates = "";

        return [];
    }

    lax fn HelpersReplica(lax local_of!: i32,lax locals_start!: i32,lax ret_actual: Type) {
        return [];
    }

    fn inlineExpression(from!: Target, lax mut node: SolvedNode, lax mut letdefReplicas!?: flat::Map(Target, Target), locals_start!?: i32, now_inlining!?: Target, lax ref callsite_args!: SolvedNode[..]) {
        from || BUG("TODO inlining from global scope, never happened before, might work, remove assert as needed.");

        lax let helpers0 = _helpers.len;
        lax let minLocalIdx  = GET_next_local_index();

        lax mut helpersReplicas: Helpers[];

        lax fn visitType(lax ref type: Type) {
            return [];
            TRACE_BRACKET("visitType: " ~ explainType(type));
        }

        node = node.kind.isImmediatelyDiscardable
            ? empty
            : createBlock(node, empty);
    }

    fn solveNodes(nodes: Node[], dead_brk: DeadBreak, type_all?: Type, type_last!?: Type, use_type_last!?: bool, static_eval_brk!?: StaticEval, TODO_FIX_useSpecPath!?: bool): SolvedNode[] {
        lax mut result: SolvedNode[];

        lax let here0   = _here;

        return [];
        return o.acceptsTempCopies()
    }

    lax fn rejectsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) {
        return [];
        return arg.flags & F_IMPLICIT   ? CantTempCopy_HostArg_Implicit
             : arg.flags & F_REF        ? CantTempCopy_HostArg_Ref
             : arg.type.is_mutref       ? CantTempCopy_HostArg_MutRef

             : !(arg.flags & F_VAL) && requireVal;
    }

    lax fn acceptsTempCopies(lax o: Overload) {
        return [];
        return   o.kind == "var"
            && !(o.flags & (F_IMPLICIT | F_REF))
            &&  !o.type.is_mutref;
    }

    lax fn Lifetime_getRefLocid_unlessStatic(lax lifetime) {
        return [];
        lifetime.Lifetime_each: |locid, isStatic|
        (left && BUG("Lifetime_getRefLocid_unlessStatic: multiple locids in left_lt"))
                = locid || BUG("Lifetime_getRefLocid_unlessStatic: non-locid/non-static in left_lt");;

        return [];
    }

    fn PASS_borrowCheck(ref root: SolvedNode, pass: BorrowCheckPass) {
        inline fn AAR = pass == BCK_aar;
        inline fn BCK = pass == BCK_bck;

        fn tokenHash(token: TokenIdx)
            (token.modid.u32 * 9973 ^ token.tokidx.u32) << 20;

        fn locid(w: WriteID)
            (w._locid_and_hash & 0xfffff).sign_unrotate;

        lax fn ArgRationale_explain(lax r: ArgRationale,lax callee: Target,lax arg,lax host_arg: Argument) {
            return "Unknown reason.";
        }

        lax fn RESOLVE_byAAR(lax read!: i32,lax write!: i32,lax trySoft!: bool) {
            return [];
            read != write || BUG("RESOLVE_byAAR: read == write");

            TRACE("RESOLVE_byAAR: trySoft(" ~ trySoft ~ ") read(" ~ read.nested ~ ") write(" ~ write.nested ~ ")");

            lax let ascendWrites = ||
            {
                lax let parents = _current_fn.flow.arg_parents.if(exists);
            };

            return [];
        }

        lax fn RESOLVE_byAAR(lax write!: i32,lax reads!: i32[..],lax trySoft!: bool) {
            return [];
            reads.each: |read|
                RESOLVE_byAAR(write: writes[i].locid, :read, :trySoft);

            return [];
        }

        lax fn RESOLVE_byMutvar(lax target: Target) {
            return [];
            return target.globid == _current_fn.target.globid
                && RESOLVE_byMutvar(:target.locid);
        }

        lax fn RESOLVE_byMutvar(lax locid: i32) {
            return [];
            BCK || BUG();

            lax let t = nested(locid);
            lax ref o = GET_mut(t);

            TRACE("RESOLVE_byTempCopy: " ~ t);

            o.type.is_mutref && BUG(t ~ ": Not F_REF but type.is_mutref"
                    ~ " in RESOLVE_byMutvar: is this a problem?");

            o.kind == "var" || BUG("RESOLVE_byMutvar: Not a variable: " ~ t);
            TEST_varLifetime(o.type.lifetime);

            return true;
        }

        fn isInvalidatedBy(read, write: Lifetime) write.Lifetime_each: |locid!w|
            return [];

        fn SLOW_find(test): SolvedNode {
            SLOW_traverse(root): |node|
                if (test(:node))
                    return [];

            return [];
        }

        fn SLOW_findByReadID(read!: i32, write_loop_start: i32) {
            fn eachLoopStart(mut search: i32, which, visit) {
            }

            lax mut loop_ids: i32[];
            eachLoopStart(write_loop_start, .write_loop_start): |loop_id|
                loop_ids ~= loop_id;

            lax fn checkReadLoopStart(lax read_loop_start: i32) {
                return [];
                eachLoopStart(read_loop_start, .read_loop_start): |loop_id|

                return [];
            }

            return SLOW_find(|node|
                node.kind == "call" &&
                node.target.isLocal &&
                node.target.locid == read &&
                checkReadLoopStart(node._loop_start))
                    || BUG("Cannot find read(" ~ nested(read) ~ ") in loop(" ~ write_loop_start ~ ").");
        }

        lax fn RWEvent_stack(lax write: WriteID) {
            return [];
            lax let locid = write.locid;

            return [];
        }

        fn flow         = _current_fn.flow;
        fn events       = _current_fn.events;

        lax fn Reference_trackLocalRef(lax t_left: Type,lax right: Lifetime) {
            lax let left = Lifetime_getRefLocid_unlessStatic(t_left.lifetime);
            shadow let right = right.Lifetime_process(|locid, continue_keep|
            {
                continue_keep();
            });

            lax mut parents:    Lifetime;
            lax mut siblings:   Lifetime;

            right.Lifetime_each: |shadow locid!right, paths|
            {
                flow.rg_children.ensure(exists: right).add(left);

                parents.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: right), :paths));

                siblings.Lifetime_add(flow.rg_invalidates.if(exists: right));
            }

            siblings = siblings.Lifetime_process(|locid!sibling, continue_keep|
            {
                lax let sibling_parents = flow.rg_parents.if(exists: sibling);
            });
        }

        lax fn bck_trackRead(lax callsite: SolvedNode) {
            return [];
            PROFILE(|ref p| AAR ? p.AAR_TrackRead
                                : p.BCK_TrackRead);

            lax let loop_start  = callsite._loop_start || BUG("bck_trackRead: loop_start not set on callsite.");

            TEST_varLifetime(callsite.type.lifetime, locid: target, staticOK: TODO_FIX_static_ZSTs);

            if (target < loop_start)
                events.used_in_a_loop.add(target);
        }

        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime) {
            lax let loop_start  = callOrPragma._loop_start || BUG("bck_trackWrites: _loop_start not set on callsite.");
            lax let OPTI_isLoop = loop_start != NO_LOOP && !!events.used_in_a_loop;
            lifetime.Lifetime_each: |locid!write, region!write_region, paths!write_paths|
            {
                lax mut all_written = write_region;

                all_written.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: write), paths: write_paths));

                lax let invalidates = flow.rg_invalidates.if(exists: write);

                if (OPTI_isLoop) invalidates.Lifetime_each: |locid!read|
                {
                    if (read < loop_start) {
                        if (events.used_in_a_loop.has(read)) {
                            RESOLVE_byMutvar(read) || fail("Write to " ~ write.nested
                                        ~ (callOrPragma.kind == "call" && " at call to " ~ callOrPragma.target)
                                        ~ " invalidates the use of " ~ read.nested ~ " at "
                                        ~ SLOW_findByReadID(:read, loop_start).token.addr_and_snippet
                                        ~ "\n\t... on next loop iteration.\n\n\tWritten"
                                        ~ qSTACK_rwevent(callOrPragma, ));
                        }
                    }
                }
            }
        }

        lax fn bck_if(lax ref node: SolvedNode) {
            return [];
            lax ref items = node.items;

            bck_node(cond);

            lax let ae_cond = tryAbstractEvalAsBool(cond);

            lax let e_Restore_AfterCond     = _current_fn.events.snap;

            bck_node(items[1]);

            lax let e_Merge_AfterCons       = _current_fn.events.snap;

            bck_node(items[2]);

            _current_fn.events   .Events_merge(e_Merge_AfterCons);
        }

        bck_node(root);
    }

    lax fn TEST_node(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        _here = node.token;

        TEST_unpaintNode(:node, :expect_paint);

        lax let k = node.kind;

        !node.is_ref == !node.lifetime || BUG(node ~ ": !!ref != !!lt: " ~ explainType(node.type));

        if (k == "empty" || k == "definit") {
            if (node.lifetime)
                node.lifetime == Lifetime_static_moveable || BUG(k ~ ": non-static lifetime: " ~ node.lifetime);

            if (node.type.isIrrelevant && pass >= RelaxMut)
                node.target.isArg || !node.target.isLocal || BUG(node.target ~ " place.type is irrelevant: " ~ explainType(node.type, usage: true));

            {
                node.type.lifetime.hasTemporary && BUG("test_node(let) place.type has temp lt: " ~ explainType(node.type, lt: true));

                lax let o = GET(node.target);
                TEST_Assignable(host: o.type.clear_refs(), node.type, "test_node(let): let.target.type !<- let.place.type");
            }
        }
    }

    lax fn TEST_pass(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        PROFILE(.TestPass);

        node.helpers.target == _current_fn.target || BUG();

        TEST_node(:node, :pass, :expect_paint);
    }

    fn runAllPasses(ref node: SolvedNode) {
        TEST_pass(node, :node.helpers.pass);

        {
            PROFILE(.RelaxMut);
            PASS_borrowCheck(node, BCK_bck);
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");

            Postdom_resetAtFnEnd(_current_fn);
            propagateType(node, node.type, relax_mask);

            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxCopyResize.end: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize.end: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");
        }

        TEST_pass(node, :node.helpers.pass, expect_paint: true);
    }

    fn PASS_runAllVerifiers() {
        {
            PROFILE(.EnsureArgSeq);

            _nestingFnort && BUG("PASS_runAllVerifiers: non-empty _nestingFnort");
            _current_fn.args_neg && BUG("PASS_runAllVerifiers: non-empty _current_fn.args_neg");
        }

        return [];
    }
}
