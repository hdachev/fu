

using flags SolverStatus: u16
{
    SS_LAZY

    SS_UPDATED

    SS_FN_OOE_RTL

    SS_NAME_UNUSED                  
    SS_MATCHED
    SS_MOVED_FROM

    SS_EXTERNAL_LINKAGE
    SS_OBSERVED_BY_CONV_CACHE
    SS_Debug_AllPassesComplete
}

using flags HelpersMask: u16
{
    HM_CanBreak
    HM_CanReturn
    HM_Anon
    HM_Function

    HM_Lambda
    HM_UserType

    HM_LoopPreheader
    HM_LoopBody
}

using flags DeclAsserts: u16
{};

using flags Flags: u32
{
    F_CALL_HAS_DOT          
    F_CALL_HAS_NAMED_ARGS   
    F_OPERATOR

    F_COMPOUND_ID
    F_ARGID_IS_OPTIONAL

    F_LAX
    F_SHADOW
    F_MUSTNAME

    F_CONST

    F_CONVERSION
    F_TEST_painted

    F_PUB           
    F_EXTERN        
    F_HOTSWAP       
    F_PREDICATE

    F_LT_RETURNED   
    F_TEMPLATE
    F_LAMBDA
    F_COW_INSIDE
};

let F_TODO_FIX_TRAILING_RETURN = F_LAMBDA;

using flags ExitPaths {};

let LET_TYPE        = 0;
let LET_INIT        = 1;

let FN_RET_BACK     = -2;
let FN_BODY_BACK    = -1;

let LOOP_INIT       = 0;
let LOOP_PRE_COND   = 1;
let LOOP_PRE        = 2;
let LOOP_BODY       = 3;
let LOOP_POST       = 4;
let LOOP_POST_COND  = 5;

let STRUCT_BASE     = 0;

let TRY_TRY         = 0;
let TRY_ERR         = 1;
let TRY_CATCH       = 2;

using flags SolverNotes: i32
{}

using flags CGDefects
{};

enum Kind
{}

fn isImmediatelyDiscardable(k) return [];

type Quals = u32; 
primitive MayEscapeVia: u32;

struct NukeOnRebuild
{};

nocopy struct Context
{
    fudir:      string;

    base_dir:   string;

    modules:    Module[];
    dep_order:  i32[];

    using nuke: NukeOnRebuild;
};

struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;

    profile?:   profiler::Profile;
};

struct ModuleInputs
{
    lex:        LexerOutput;
    parse:      ParserOutput;
};

struct ModuleOutputs
{
    types:      UserType[];
};

struct ModuleStats
{};

struct UserType
{
    true kind:      Kind;
    name:           string;

    items?:         ScopeItem[];
};

struct LexerOutput
{
    tokens:     Token[];
};

struct Import
{};

struct ParserOutput
{
    warnings:   string[];
}

struct SolverOutput
{
    root:       SolvedNode;
    scope:      Scope;
};

struct BuildHacks
{};

struct LineColChars
{
    line:       i32;
    col:        i32;
    chars:      i32;
};

struct Token
{
    true kind:  Kind;
    using lcc:  LineColChars;
};

struct Node
{
    true kind:  Kind;
    asserts?:   DeclAsserts;
};

struct TokenIdx
{
    modid:      i32;
    tokidx:     i32;
};

struct Target
{
    _packed!:   u64;
}

struct Helpers
{
    index:      i32;
};

struct SolvedNode
{
    helpers:        Helpers; 
    flags:          Flags;
    _loop_start?:   i32;

    value:          string;
    items:          SolvedNode[];
    target:         Target;
}

struct ScopeItem
{
    true id:        string;
    _packed:        u64;
};

nocopy struct Scope
{
    items:          ScopeItem[];
    globals:        ScopeItem[];
    privates:       i32[];
    usings:         Target[];

    pub_items:      i32;
    pub_implicits:  i32;
    pub_globals:    i32;
    pub_converts:   i32;
};

struct Template
{};

struct Argument
{
    may_alias?:         ::BitSet;
};

struct COWInside
{
    token:          TokenIdx;
    argTarget:      i32;
    mayEscapeVia:   MayEscapeVia;
    exitPaths:      ExitPaths;
};

struct Overload
{};

struct Extended
{
    min:            i32;
    max:            i32;
    args:           Argument[];

    cows_inside:    COWInside[];

    args_n_locals?: Overload[];
};

struct ValueType
{
    quals?:         Quals;
    vfacts?:        VFacts;
    canon:          string;
};

struct Type
{
    using vtype:    ValueType;
};

struct Lifetime { uni0n!: byte[] };

using flags VFacts
{
    AlwaysTrue
    AlwaysFalse
    Typename

    LeftAligned
    RightAligned

    AssumingInfiniteRecursion
};

fn isRTL_set(ref o, rtl)

fn argsForward(lax RTL, host_args) {
    lax mut lastPass = 1;

    lax let end         = RTL ? N : 0 - 1;
    lax let incr        = RTL ? +1  :  -1;

    for (mut i = start; i != end; i += incr)
        fn(:i, host_arg, ooe_isLast?: i == start);
}

fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

inline fn nextIndexOfLocal(ext, asArgument!: bool): int return [];

inline fn sign_rotate(v)
    (v.u32 << 1) ^ (v < 0 ? 0xffffffff : 0x0)

inline fn sign_unrotate(v: u32)
    i32((v >> 1) ^ (v & 1 ? 0xffffffff : 0x0))

inline fn globid(t: Target) i32(t._packed >> 20 & 0xfffff);
inline fn  locid(t) u32(t._packed       & 0xfffff).sign_unrotate;

fn Target(modid, globid, locid: i32) {}

inline fn isArg(target: Target) target.locid < 0;

fn parseLocalOrGlobal(str, ref offset!: i32) {}

fn parseGlobal(str: string, ref offset!: i32) {}

fn appendGlobal(ref str: string, using target: Target) {}

fn add(ref mayEscapeVia, locid!: i32) mayEscapeVia |= 1 << (locid.u32.MayEscapeVia % 32);

fn if(ref a: <T>[..], exists!i: (TODO_REMOVE_bootstrap ? int : void), and?: <Then>, else!?)
    i.unsigned < a.len.unsigned
        ? Then -> [] ? a[i] : and(a[i])
        :

fn hasNonIdentifierChars(id) return [];

fn zip_each(ref a, ref b) zip_each(a, b): |shadow a, shadow b, i|

    return [];

fn steal(ref a, start!, end!: i32) {}

fn parse10u32(ref offset) {}

fn parse10s32(ref offset, str: string) {}

fn print(arr) return [];

fn trim(str: string) return [];

fn parse(v)

fn parseWild(v: byte[..], type as!<T>) return [];

fn cleanID(id: string) {}

fn steal(ref v: <T>) {}

fn exchange(ref a: <T>, mut b: T) swap(a, b);

fn shadow(ref a: <T>, mut b: T) unwrap {}

inline fn start  (ref arr) arr[.. 0];
inline fn end    (ref arr: <T>[]) arr[arr.len ..];

pub let SELF_TEST = !!true;

pub fn formatTokenCoord(token, from!: i32, implicit ctx: Context) {
    lax mut fname = from != token.modid && token._fname;

    return formatTokenCoord(:fname, token: token._token);
}

pub fn formatTokenCoord(fname!: string, token: LineColChars) {
    lax let lcc     = token.line ~ "" ~ token.chars;
    lax let dir     = path::dirname(fname);
    lax let file    = fname.slice(dir.len, fname.len);
    lax let ext     = path::ext(file);
    lax let noext   = file.slice(0, file.len - ext.len);

    return ansi::DIM ~ dir ~ ansi::RESET
         ~ noext
         ~ ansi::DIM
         ~ ext ~ "" ~ lcc
         ~ ansi::RESET;
}

pub fn formatCodeSnippet(src!, fmt?, mut highlight!: LineColChars[]) {
    highlight.sort(|a, b| (a.line - b.line) < 0);

    lax let lines   = src.split("");

    lax let start   = highlight.first;
    lax let end     = highlight.last;

    lax mut l_start = start.line - 1;  
    lax mut l_end   =   end.line;

    l_start     = l_start.min(lines.len).max(0);
    lax mut result  = "";

    return result;
}

pub fn formatCodeSnippet(mut tokens, from!, fmt?) {
    lax mut append = "";

    lax let head = tokens.if_first;
    lax mut result = "";
    result ~= formatTokenCoord(head, :from);

    lax mut highlight: LineColChars[] = [];
    result ~= append;
    return result;
}

implicit ref _here: TokenIdx;

pub inline fn HERE(node.token) _here = node;

pub fn FAIL_text(tokens, reason: string): string {
    lax let snippet = formatCodeSnippet(:tokens, from: -1);

    return snippet ~ "";
}

pub fn FAIL_text(fname!: string, src!: string, token!, reason!): string {
    lax let addr    = formatTokenCoord(:fname, :token);
    return addr ~ ":\n\n" ~ snippet ~ "\n\t" ~ reason ~ "\n";
}

pub fn FAIL(reason, tokens!: TokenIdx[] = [ _here ]): never throw (FAIL_text(:tokens, :reason));

pub fn BUG(mut reason?: string) FAIL("COMPILER BUG:\n\n\t" ~ (reason || "Assertion failed."));

let SR_empty        = "\x00\x00";

let byte_STATIC     = byte(0b0001);
let byte_ZEROES     = byte(0b0101);
let byte_TEMP       = byte(0b1001);

inline fn isZeroes(r: u32)          r == 0b0101;
inline fn isStaticOrZeroes(r: u32)  r & 11 == 1;
inline fn isTemporary(r: u32)       r == 0b1001;
inline fn isArgIdx(r)          r & 3 == 3;

let Region_STATIC   = byte_STATIC   ~ SR_empty;
let Region_ZEROES   = byte_ZEROES   ~ SR_empty;
let Region_TEMP     = byte_TEMP     ~ SR_empty;

fn parse7bit(str, ref offset: int) {
    lax mut shift:  u32;
    lax mut result: u32;

    lax mut c: byte;

    return result | c.u32 << shift;
}

fn append7bit(ref str, mut v) str ~= byte(v);

/*
    We're going with full path serialize-parse for starters to keep things a little simpler, i think once we got this figured out it should be relatively easy
*/

pub inline fn walkPaths(str: byte[..], ref offset, lax tailOK!?: bool, onPathStart!?, onSubRegion!?, onLastSubRegion!?, onPathDone!?, onDone!?) {
    lax let offset0 = offset + 0 ;

    onDone();

    return [];
}

pub lax fn assertPathsValid(lax str: byte[..], lax mut region_flatCount = -1, lax flatCountMismatchOK! = false, lax selfIntersectOK! = false, lax minPathDepth! = 1) {}

struct SubRegion
{
    flatOffset:     i32;
};

type Paths = SubRegion[][];

fn parsePaths_each(str) {
    lax mut path: SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset, onPathStart: || {}, onPathDone);
}

fn parsePaths(str: byte[..]): Paths {
    lax mut paths:      SubRegion[][];
    lax mut path:       SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset: _o, onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
            paths ~= helpers::steal(path);
        }, onDone: || {
            return [];
        });
}

inline fn appendSubRegion(ref uni0n: byte[], flatCount: i32, flatOffset: i32, isLastSubRegion!: bool, isLastPath!: bool) uni0n.append7bit(flatCount.u32 << 1
                | (isLastPath ? 0 : 1));

fn Paths_inter(ref str, a: byte[..], b: byte[..]) {}

fn Paths_hasInter(a: byte[..], b: byte[..], rw_left?:  usage::RWQuals or [], rw_right?: usage::RWQuals or []) {
    return [];
}

pub fn Lifetime_shiftUsage(paths, usage) {
    lax mut offset = 0;
    walkPaths(paths, offset, onSubRegion);

    return [];
}

inline fn appendLocid(ref str: byte[], locid!: i32) str.append7bit(locid.sign_rotate << 1);

inline fn unpackLocid(r) return r & 1 ? 0 : (r >> 1).sign_unrotate;

pub fn Lifetime_from(locid!, flatCount: i32): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.appendLocid(:locid);
    uni0n.appendSubRegion(:flatCount, flatOffset, isLastPath: true, isLastSubRegion: true);

    return L
}

pub fn Lifetime_from(argidx!, paths: byte[..]): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.append7bit((argidx.u32 << 2) | 3);

    return L
}

pub let Lifetime_AAR_hasFalsePositives = true;

pub fn Lifetime_AAR(locid!): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.appendLocid();
    uni0n ~= SR_empty;

    return Lifetime(:uni0n);
}

inline fn merge !<B, L, R, Either, Rest>(l_chars.uni0n, r_chars.uni0n, both!?, left!?, right!?: R, either!?, rest!?: Rest) {}

pub fn Lifetime_union(a, b: Lifetime, flatCountMismatchOK! = false): Lifetime =
{}

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
{
    lax mut result: Lifetime;

    merge(a, b, both: |r_both, sr_left, sr_right|
        {
            lax let sr_chars =
            {};
        }, rest: |_| {});

    return [];
}

pub fn Lifetime_interLocids(a: Lifetime, b: Lifetime): i32[] =
{
    merge(a, b, both: |_, locid, sr_left, sr_right|
        {}, rest: |_| {});

    return [];
}

pub fn Lifetime_add(ref l: Lifetime, r: Lifetime, flatCountMismatchOK! = false) {}

pub fn Lifetime_each(lifetime: Lifetime, each) {
    lax let chars = lifetime.uni0n;
    lax mut offset = 0;

    {
        lax let offset0 = offset;

        lax let r       = chars.parse7bit(:offset);
        lax mut sr  = chars.walkPaths(:offset, tailOK: true);

        each(locid?:     r.unpackLocid, argidx?:    i32(r & 1 ? r >> 2 : 0), isAlwaysMoveable?:  r.isZeroes || r.isTemporary, isStatic?:  r.isStaticOrZeroes, isTemp?:    r.isTemporary, isArgIdx?:  r.isArgIdx, region?:    Lifetime(uni0n: chars.slice(offset0, offset)), others?:    Lifetime(uni0n: chars[.. offset0] ~ chars[offset ..]), r_raw?:     chars[offset0 .. sr], paths?:     chars[sr .. offset], isOnly?:    !offset0);
    }
}

pub let Lifetime_temporary =
    Lifetime(uni0n: Region_TEMP);

pub fn hasTemporary(lifetime: Lifetime): bool
    lifetime.uni0n.starts(with: Region_TEMP);

pub fn hasStatic(lifetime: Lifetime): bool return [];

pub let Lifetime_worst = Lifetime_temporary;

pub fn Lifetime_some(lifetime: Lifetime, some) {}

pub fn Lifetime_has(lifetime: Lifetime, locid!search: i32)
    lifetime.Lifetime_some(|isArgIdx, argidx| isArgIdx);

pub fn Lifetime_makeShared(lifetime, flatCount!): Lifetime =
    Lifetime_union(Lifetime_op_deref(lifetime, :flatCount), Lifetime_static_immoveable);

/*
    We have three operations on lifetimes:

    *deref:     We append a new region, flatCount = dereferencedType.flatCount, offset = 0, we're selecting an array item.

                            with the outermost child subregion.

*/

inline fn Lifetime_op(lt: Lifetime, each, minPathDepth! = 1) {}

pub fn Lifetime_op_field(lt, flatCount, flatOffset: i32) {
    return lt.Lifetime_op(minPathDepth: 2, |paths, ref result|
    {
        paths.walkPaths(:offset, onLastSubRegion: |isLastPath, raw_prefix, flatCount!parent_flatCount, flatOffset!parent_flatOffset|
            {});
    });
}

pub fn solve() {
    struct Flow
    {
        rg_invalidates:     [];
    };

    struct CurrentFn
    {
        using flow?:        Flow;
    };

    lax mut _current_fn:        CurrentFn;

    fn PASS_borrowCheck() {
        fn flow = _current_fn.flow;
        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime)
            lifetime.Lifetime_each: |locid!write, paths!write_paths|
                lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
