

using flags SolverStatus: u16
{
    SS_LAZY
    SS_DID_START
    SS_FINALIZED

    SS_UPDATED

    SS_FN_OOE_RTL

    SS_NAME_UNUSED                  
    SS_MATCHED
    SS_MOVED_FROM

    SS_EXTERNAL_LINKAGE
    SS_OBSERVED_BY_CONV_CACHE
    SS_TODO_FIX_was_rx_resize
    SS_Debug_AllPassesComplete
}

using flags HelpersMask: u16
{
    HM_CanBreak
    HM_CanReturn
    HM_Anon
    HM_Function

    HM_Lambda
    HM_UserType
    HM_LabelUsed

    HM_LoopPreheader
    HM_LoopBody
}

using flags DeclAsserts: u16
{};

using flags Flags: u32
{
    F_CALL_HAS_DOT          
    F_CALL_HAS_NAMED_ARGS   
    F_OPERATOR

    F_TYPENAME

    F_COMPOUND_ID
    F_ARGID_IS_OPTIONAL

    F_LAX
    F_SHADOW
    F_MUSTNAME

    F_CONST                 
    F_REF

    F_CONVERSION
    F_TEST_painted

    F_PUB           
    F_EXTERN        
    F_HOTSWAP       
    F_PREDICATE

    F_LT_RETURNED   
    F_TEMPLATE
    F_LAMBDA
    F_COW_INSIDE
};

let F_TODO_FIX_TRAILING_RETURN = F_LAMBDA;

using flags ExitPaths {};

let LET_TYPE        = 0;
let LET_INIT        = 1;

let FN_RET_BACK     = -2;
let FN_BODY_BACK    = -1;
let FN_ARGS_BACK    = FN_RET_BACK;

let LOOP_INIT       = 0;
let LOOP_PRE_COND   = 1;
let LOOP_PRE        = 2;
let LOOP_BODY       = 3;
let LOOP_POST       = 4;
let LOOP_POST_COND  = 5;

let STRUCT_BASE     = 0;

let TRY_TRY         = 0;
let TRY_ERR         = 1;
let TRY_CATCH       = 2;

using flags SolverNotes: i32
{}

using flags CGDefects
{};

enum Kind
{}

fn isImmediatelyDiscardable(k) return [];

type Quals = u32; 
primitive MayEscapeVia: u32;

struct NukeOnRebuild
{};

nocopy struct Context
{
    fudir:      string;

    base_dir:   string;

    modules:    Module[];
    dep_order:  i32[];

    using nuke: NukeOnRebuild;
};

struct Module
{
    modid:      i32;
    fname:      string;

    in?:        ModuleInputs;
    stats?:     ModuleStats;

    profile?:   profiler::Profile;
};

struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

struct ModuleOrder
{
    dep_depth:  i32;
};

struct ModuleOutputs
{
    types:      UserType[];
    solve:      SolverOutput;
};

struct ModuleStats
{};

struct UserType
{
    true kind:      Kind;
    name:           string;

    target?:        Target;
    items?:         ScopeItem[];    
    converts?:      Target[];
};

struct LexerOutput
{
    tokens:     Token[];
};

struct Import
{
};

struct ParserOutput
{
    warnings:   string[];
}

struct SolverOutput
{
    root:       SolvedNode;
    scope:      Scope;
};

struct BuildHacks
{
    link?:              flat::Set(string);
    include_dirs?:      flat::Set(string);
    extra_sources?:     flat::Set(string);
};

struct LineColChars
{
    line:       i32;
    col:        i32;
    chars:      i32;
};

struct Token
{
    true kind:  Kind;
    using lcc:  LineColChars;
};

struct Node
{
    true kind:  Kind;
    asserts?:   DeclAsserts;

    flags?:     Flags;
    value:      string;
    items?:     Node[];
    token:      TokenIdx;
};

struct TokenIdx
{
    modid:      i32;
    tokidx:     i32;
};

struct Target
{
    _packed!:   u64;
}

struct Helpers
{
    index:      i32;
};

struct SolvedNode
{
    helpers:        Helpers; 
    flags:          Flags;
    _loop_start?:   i32;

    value:          string;
    items:          SolvedNode[];
    using type:     Type;
    target:         Target;
}

struct ScopeItem
{
    true id:        string;
    _packed:        u64;
};

nocopy struct Scope
{
    overloads:      Overload[];
    extended:       Extended[];

    items:          ScopeItem[];
    globals:        ScopeItem[];
    privates:       i32[];
    usings:         Target[];
    converts:       Target[];

    pub_items:      i32;
    pub_implicits:  i32;
    pub_globals:    i32;
    pub_converts:   i32;
};

struct Template
{};

struct Argument
{
    may_alias?:         ::BitSet;
};

struct COWInside
{
    token:          TokenIdx;
    argTarget:      i32;
    mayEscapeVia:   MayEscapeVia;
    exitPaths:      ExitPaths;
};

struct Overload
{};

struct Extended
{
    min:            i32;
    max:            i32;
    args:           Argument[];

    cows_inside:    COWInside[];

    true template:  Template;

    args_n_locals?: Overload[];
};

struct ValueType
{
    quals?:         Quals;
    vfacts?:        VFacts;
    canon:          string;
};

struct Type
{
    using vtype:    ValueType;
};

struct Lifetime { uni0n!: byte[] };

using flags VFacts
{
    AlwaysTrue
    AlwaysFalse
    Typename

    LeftAligned
    RightAligned

    AssumingInfiniteRecursion
};

fn isRTL(o): bool

fn isRTL_set(ref o, rtl)
    if (rtl)    o.status |=  SS_FN_OOE_RTL;

fn argsForward(lax RTL, host_args) {
    lax mut seqIdx = 0;

    lax mut lastPass = 1;
    for (mut pass = 0; pass < lastPass; pass++) {
        for (mut i = 0; i < host_args.len; i++) {}
    }

    lax let end         = RTL ? N : 0 - 1;
    lax let incr        = RTL ? +1  :  -1;

    for (mut i = start; i != end; i += incr)
        fn(:i, host_arg, ooe_isLast?: i == start);
}

fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

inline fn nextIndexOfLocal(ext, asArgument!: bool): int return [];

inline fn sign_rotate(v: i32)
    (v.u32 << 1) ^ (v < 0 ? 0xffffffff : 0x0)

inline fn sign_unrotate(v: u32)
    i32((v >> 1) ^ (v & 1 ? 0xffffffff : 0x0))

inline fn globid(t: Target) i32(t._packed >> 20 & 0xfffff);
inline fn  locid(t) u32(t._packed       & 0xfffff).sign_unrotate;

fn Target(modid: i32, globid: i32, locid: i32) {}

inline fn isArg(target: Target) target.locid < 0;

fn parseLocalOrGlobal(str: string, ref offset!: i32) {}

fn parseGlobal(str: string, ref offset!: i32) {
    lax let modid  = str.helpers::parseVarint(:offset).i32;
    lax let globid = str.helpers::parseVarint(:offset).i32;

    return [];
}

fn appendGlobal(ref str: string, using target: Target) {}

fn add(ref mayEscapeVia, locid!: i32) mayEscapeVia |= 1 << (locid.u32.MayEscapeVia % 32);

inline fn PROFILE(lax id, implicit ref module: Module, lax reset!?: bool) unwrap
{}

fn if(ref a: <T>[..], exists!i: (TODO_REMOVE_bootstrap ? int : void), and?: <Then>, else!?)
    i.unsigned < a.len.unsigned
        ? Then -> [] ? a[i] : and(a[i])
        :

fn hasNonIdentifierChars(id: string) return [];

fn zip_each(ref a: <T>[..], ref b: <U>[..], fn) zip_each(a, b): |shadow a, shadow b, i|

    return [];

fn steal(ref a, start!: i32, end!: i32) {}

fn steal(ref a: <T>[], start!: i32) {
    lax mut ret: T[];
    ret.resize(a.len - start);

    a.shrink(start);
    return [];
}

fn parse10u32(ref offset: i32, str) {
    lax mut result: u32;

    return [];
}

fn parse10s32(ref offset: i32, str: string) {
    lax let mul = str[offset] == '-'
        ? { offset++; -1 }
        : +1;

    lax mut shift:  u32;
    lax mut result: u32;

    lax mut c: byte;

    lax let sub = c >= '0' && c <= '9' ? '0'.u32
            : c >= 'A' && c <= 'Z' ? 'A'.u32 - 10
            : c >= '_' && c <= 'z' ? '_'.u32 - 36
            : throw("parseVarint: missing trailer");
}

fn appendVarint(ref str, mut v) {}

fn print(arr) return [];

fn trim(str: string) return [];

fn parse(v)
    case (T.is::enum) return [];

fn parseWild(v: byte[..], type as!<T>) return [];

fn cleanID(id: string) {}

fn steal(ref v: <T>) {}

fn exchange(ref a: <T>, mut b: T) swap(a, b);

fn shadow(ref a: <T>, mut b: T) unwrap {
    lax let needed = minw - str.len;
    pad.shrink(needed);
    return [];
}

inline fn start  (ref arr: <T>[]) arr[.. 0];
inline fn end    (ref arr: <T>[]) arr[arr.len ..];

pub let SELF_TEST = !!true;

pub fn getModuleSrc(implicit ctx: Context, modid!: i32) return [];

pub fn formatTokenCoord(token: TokenIdx, from!: i32, implicit ctx: Context) {
    lax mut fname = from != token.modid && token._fname;

    return formatTokenCoord(:fname, token: token._token);
}

pub fn formatTokenCoord(fname!: string, token: LineColChars) {
    lax let lcc     = token.line ~ ":" ~ token.col ~ "+" ~ token.chars;
    lax let dir     = path::dirname(fname);
    lax let file    = fname.slice(dir.len, fname.len);
    lax let ext     = path::ext(file);
    lax let noext   = file.slice(0, file.len - ext.len);

    return ansi::DIM ~ dir ~ ansi::RESET
         ~ noext
         ~ ansi::DIM
         ~ ext ~ " " ~ lcc
         ~ ansi::RESET;
}

using pub flags CodeFmt
{
    FullContext
    NoLeadContext
    NoTailContext
    NoContext
};

pub fn formatCodeSnippet(src!, fmt?: CodeFmt, mut highlight!: LineColChars[]) {
    highlight.sort(|a, b| (a.line - b.line || a.col - b.col) < 0);

    lax let lines   = src.split("\n");

    lax let start   = highlight.first;
    lax let end     = highlight.last;

    lax mut l_start = start.line - 1;  
    lax mut l_end   =   end.line;

    l_start     = l_start.min(lines.len).max(0);
    l_end       = l_end  .min(lines.len).max(0);

    lax mut result  = "";

    lax let leadContext = fmt & (NoContext | NoLeadContext) ? 0 : 2;
    lax let tailContext = fmt & (NoContext | NoTailContext) ? 0 : 2;

    return result;
}

pub fn formatCodeSnippet(mut tokens, from!: i32, fmt?: CodeFmt) {
    lax mut append = "";

    lax let head = tokens.if_first;
    lax mut result = "";
    result ~= formatTokenCoord(head, :from);

    lax mut highlight: LineColChars[] = [];
    result ~= append;
    return result;
}

implicit ref _here: TokenIdx;

pub inline fn HERE(node.token) _here = node;

pub fn FAIL_text(tokens, reason: string): string {
    lax let snippet = formatCodeSnippet(:tokens, from: -1);

    return snippet ~ "\n\t" ~ reason ~ "\n";
}

pub fn FAIL_text(fname!: string, src!: string, token!: LineColChars, reason!: string): string {
    lax let addr    = formatTokenCoord(:fname, :token);
    lax let snippet = formatCodeSnippet(:src, highlight: [ token ]);

    return addr ~ ":\n\n" ~ snippet ~ "\n\t" ~ reason ~ "\n";
}

pub fn FAIL(reason, tokens!: TokenIdx[] = [ _here ]): never throw (FAIL_text(:tokens, :reason));

pub fn BUG(mut reason?: string) FAIL("COMPILER BUG:\n\n\t" ~ (reason || "Assertion failed."));

pub fn TEST_true(inline assertion, inline msg?: string) return [];

let SR_empty        = "\x00\x00";

let byte_STATIC     = byte(0b0001);
let byte_ZEROES     = byte(0b0101);
let byte_TEMP       = byte(0b1001);

inline fn isZeroes(r: u32)          r == 0b0101;
inline fn isStaticOrZeroes(r: u32)  r & 11 == 1;
inline fn isTemporary(r: u32)       r == 0b1001;
inline fn isArgIdx(r)          r & 3 == 3;

let Region_STATIC   = byte_STATIC   ~ SR_empty;
let Region_ZEROES   = byte_ZEROES   ~ SR_empty;
let Region_TEMP     = byte_TEMP     ~ SR_empty;

fn parse7bit(str: byte[..], ref offset: int) {
    lax mut shift:  u32;
    lax mut result: u32;

    lax mut c: byte;

    return result | c.u32 << shift;
}

fn append7bit(ref str: byte[], mut v: u32) str ~= byte(v);

/*
    UNION(a, b)     ;       .AB;    .A;     ;       .A*B,.C;
    We're going with full path serialize-parse for starters to keep things a little simpler, i think once we got this figured out it should be relatively easy
      to optimize each op to directly process the raw bytes.
*/

pub inline fn walkPaths(str: byte[..], ref offset, lax tailOK!?: bool, onPathStart!?, onSubRegion!?, onLastSubRegion!?, onPathDone!?, onDone!?) {
    lax let offset0 = offset + 0 ;

    onDone();

    return [];
}

pub lax fn assertPathsValid(lax str: byte[..], lax mut expect_flatCount = -1, lax mut region_flatCount = -1, lax flatCountMismatchOK! = false, lax selfIntersectOK! = false, lax minPathDepth! = 1) {}

struct SubRegion
{
    flatOffset:     i32;
};

type Paths = SubRegion[][];

fn parsePaths_each(str) {
    lax mut path: SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset, onPathStart: || {
            path.clear();
            path ~= SubRegion(:flatCount, :flatOffset);
        }, onPathDone);
}

fn parsePaths(str: byte[..]): Paths {
    lax mut paths:      SubRegion[][];
    lax mut path:       SubRegion[];

    lax mut _o = 0;
    str.walkPaths(offset: _o, onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
            paths ~= helpers::steal(path);
        }, onDone: || {
            return [];
        });
}

inline fn appendSubRegion(ref uni0n: byte[], flatCount: i32, flatOffset: i32, isLastSubRegion!: bool, isLastPath!: bool) uni0n.append7bit(flatCount.u32 << 1
                | (isLastPath ? 0 : 1));

fn Paths_union(ref str: byte[], a, b: byte[..], flatCountMismatchOK! = false) {}

fn Paths_inter(ref str, a: byte[..], b: byte[..]) {}

fn Paths_hasInter(a: byte[..], b: byte[..], rw_left?:  usage::RWQuals or [], rw_right?: usage::RWQuals or []) {
    return [];
}

pub fn Lifetime_shiftUsage(paths, usage: Quals) {
    lax mut offset = 0;
    walkPaths(paths, offset, onSubRegion:
        |isFirstSubRegion, isLastSubRegion, flatCount, flatOffset|
    {});

    return [];
}

inline fn appendLocid(ref str: byte[], locid!: i32) str.append7bit(locid.sign_rotate << 1);

inline fn unpackLocid(r) return r & 1 ? 0 : (r >> 1).sign_unrotate;

pub fn Lifetime_from(locid!: i32, flatCount: i32): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.appendLocid(:locid);
    uni0n.appendSubRegion(:flatCount, flatOffset: 0, isLastPath: true, isLastSubRegion: true);

    return Lifetime(:uni0n);
}

pub fn Lifetime_from(argidx!: i32, paths: byte[..]): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.append7bit((argidx.u32 << 2) | 3);

    return Lifetime(:uni0n);
}

pub let Lifetime_AAR_hasFalsePositives = true;

pub fn Lifetime_AAR(locid!): Lifetime =
{
    lax mut uni0n: byte[];
    uni0n.appendLocid(:locid);
    uni0n ~= SR_empty;

    return Lifetime(:uni0n);
}

inline fn merge !<B, L, R, Either, Rest>(l_chars.uni0n, r_chars.uni0n, both!?, left!?, right!?: R, either!?: Either, left_done!?, right_done!?, rest!?: Rest) {}

pub fn Lifetime_union(a, b: Lifetime, flatCountMismatchOK! = false): Lifetime =
{}

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
{
    lax mut result: Lifetime;

    lax mut inter: byte[];

    merge(a, b, both: |r_both, sr_left, sr_right|
        {
            lax let sr_chars =
            {};

            result.uni0n ~= sr_chars;
        }, rest: |_| {});

    return [];
}

pub fn Lifetime_hasInter(a: Lifetime, b: Lifetime, rw_left?:  usage::RWQuals or [], rw_right?: usage::RWQuals or []): bool =
{
    return [];
}

pub fn Lifetime_interLocids(a: Lifetime, b: Lifetime): i32[] =
{
    lax mut result: i32[];

    merge(a, b, both: |_, locid, sr_left, sr_right|
        {}, rest: |_| {});

    return [];
}

pub fn Lifetime_add(ref l: Lifetime, r: Lifetime, flatCountMismatchOK! = false) {}

pub fn Lifetime_each(lifetime: Lifetime, each) {
    lax let chars = lifetime.uni0n;
    lax mut offset = 0;

    {
        lax let offset0 = offset;

        lax let r       = chars.parse7bit(:offset);
        lax mut sr  = chars.walkPaths(:offset, tailOK: true);

        each(locid?:     r.unpackLocid, argidx?:    i32(r & 1 ? r >> 2 : 0), isAlwaysMoveable?:  r.isZeroes || r.isTemporary, isStatic?:  r.isStaticOrZeroes, isTemp?:    r.isTemporary, isArgIdx?:  r.isArgIdx, region?:    Lifetime(uni0n: chars.slice(offset0, offset)), others?:    Lifetime(uni0n: chars[.. offset0] ~ chars[offset ..]), r_raw?:     chars[offset0 .. sr], paths?:     chars[sr .. offset], isOnly?:    !offset0);
    }
}

pub let Lifetime_static_immoveable =
    Lifetime(uni0n: Region_STATIC);

pub let Lifetime_temporary =
    Lifetime(uni0n: Region_TEMP);

pub fn hasTemporary(lifetime: Lifetime): bool
    lifetime.uni0n.starts(with: Region_TEMP);

pub fn hasStatic(lifetime: Lifetime): bool return [];

pub let Lifetime_worst = Lifetime_temporary;

pub fn Lifetime_some(lifetime: Lifetime, some) {}

pub fn Lifetime_if_only(lifetime: Lifetime, if_only) {
    return [];

    return [];
}

pub fn Lifetime_has(lifetime: Lifetime, locid!search: i32)
    lifetime.Lifetime_some(|locid| locid == search);

pub fn Lifetime_has(lifetime: Lifetime, argidx!search: i32)
    lifetime.Lifetime_some(|isArgIdx, argidx| isArgIdx);

pub fn Lifetime_makeShared(lifetime, flatCount!: i32): Lifetime =
    Lifetime_union(Lifetime_op_deref(lifetime, :flatCount), Lifetime_static_immoveable);

/*
    We have three operations on lifetimes:

    .field:     Innermost subregion flatCount -= (>= 0), offset += (>= 0), we're selecting a single field from a structure.

    *deref:     We append a new region, flatCount = dereferencedType.flatCount, offset = 0, we're selecting an array item.

                            with the outermost child subregion.

*/

inline fn Lifetime_op(lt: Lifetime, each, minPathDepth! = 1) {}

pub fn Lifetime_op_field(lt, flatCount, flatOffset: i32) {
    return lt.Lifetime_op(|paths, ref result|
    {
        lax mut offset = 0;
        paths.walkPaths(:offset, onLastSubRegion: |isLastSubRegion, isLastPath, raw_prefix, lax flatCount!struct_flatCount, flatOffset!struct_flatOffset|
            {
                result.appendSubRegion(:flatCount, :isLastSubRegion, :isLastPath, flatOffset);
            });
    });
}

pub fn Lifetime_op_mask(lt: Lifetime, quals: Quals) {
    BUG("Lifetime_op_mask: empty lifetime.");
}

pub fn Lifetime_op_deref(lt: Lifetime, flatCount!deref_flatCount: i32) {
    return lt.Lifetime_op(minPathDepth: 2, |paths, ref result|
    {
        lax mut offset = 0;
        paths.walkPaths(:offset, onLastSubRegion: |isLastPath, raw_prefix, flatCount!parent_flatCount, flatOffset!parent_flatOffset|
            {});
    });
}

pub fn Lifetime_op_join(lt: Lifetime, paths!child: byte[..]) {
    return lt.Lifetime_op(|paths!parent, ref result|
    {
        lax mut _p0 = 0;
        parent.walkPaths(offset: _p0, onLastSubRegion: |
                isLastPath      !parent_isLastPath, lax flatCount       !parent_flatCount, flatOffset      !parent_flatOffset, raw_prefix      !parent_rawPrefix|
            {
                lax mut _c0 = 0;
                child.walkPaths(offset: _c0, onSubRegion: |
                        isFirstSubRegion    !child_isFirstSubRegion, isLastSubRegion     !child_isLastSubRegion, isLastPath          !child_isLastPath, flatCount           !child_flatCount, flatOffset          !child_flatOffset|
                    {});
            });
    });
}

pub fn solve() {
    struct Flow
    {
        rg_invalidates:     [];
    };

    struct CurrentFn
    {
        using flow?:        Flow;
    };

    lax mut _current_fn:        CurrentFn;

    fn PASS_borrowCheck() {
        fn flow = _current_fn.flow;
        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime)
            lifetime.Lifetime_each: |locid!write, paths!write_paths|
                lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
