import ansi;
import flags;
import scope;
import context;
import types;
import quals;
import usage;
import usertypes;
import lifetime;
import module;
import fail;
import experiments;

let OPTI_autoshadow         = true;
let OPTI_bck                = true;
let OPTI_unlist_callers     = true;
let OPTI_moves_inside_fns   = true;

let USE_rev_spec            = true;

let RESOLVE_report          = false;
let TRACE_enable            = false;

let NO_LOOP         = -1000001;

pub fn solve(implicit lax ctx: Context, implicit lax ref module: Module, implicit lax options: options::Options): SolverOutput {
    lax let implicit mut _here: TokenIdx;

    PROFILE(.UnaccountedFor, reset: true);

    lax mut TRACE_out       = TRACE_enable ? string : void;
    lax mut TRACE_indent    = TRACE_enable ? string : void;

    lax fn TRACE(inline msg) if (TRACE_enable)
            (((TRACE_out ~= "-------") ~= TRACE_indent) ~= msg) ~= '\n';

    struct LocidSet
    {
        _bitset:            ::BitSet;
    };

    struct LocidMap(type T) {
        _values:            T[];
    };

    struct Warning
    {
        locid:              i32;
    };

    struct WriteID
    {
        _locid_and_hash:    u32;
    };

    struct EventsSnap
    {
        invalidated_by:     LocidMap(flat::Set(WriteID));
    };

    struct PrecedingRefArg
    {
        callsite_token:     TokenIdx;
        r:                  i32;
        w:                  i32;

        arg:                SolvedNode;
    };

    struct Events
    {
        using snap:         EventsSnap;

        used_in_a_loop:     LocidSet;

        preceding_ref_args: PrecedingRefArg[];

        cows_inside:        COWInside[];
    };

    lax fn clear(lax ref events: Events) {
        return [];
        events = [];
    }

    lax fn Events_merge(lax ref events: EventsSnap,lax snap) {
        return [];

        return [];

        for (fieldname i: EventsSnap)
            events.i.Events_restore(restore.i);
    }

    struct PostdomSnap
    {
        ever_written:       LocidMap(Quals);

        mayEscapeVia:       MayEscapeVia;
        exitPaths:          ExitPaths;
    };

    struct Postdom
    {
        using snap:         PostdomSnap;

        write_loop_start:   i32;
        read_loop_start:    i32;
    };

    struct VarUsage
    {
    };

    struct Flow
    {
        rg_parents:         LocidMap(Lifetime);
        rg_invalidates:     LocidMap(Lifetime);         
        rg_children:        LocidMap(flat::Set(i32));
    };

    struct ScopeMemo {
        items_len:          i32;
        implicits_len:      i32;
        privates_len:       i32;
        usings_len:         i32;
        converts_len:       i32;
        helpers_len:        i32;
    };

    struct ScopeSkipMemos {
        items:              ScopeSkip[];
        implicits:          ScopeSkip[];
        imports:            ScopeSkip[];
        privates:           ScopeSkip[];
        usings:             ScopeSkip[];
        helpers:            ScopeSkip[];
    };

    struct RevSpecPrototype
    {
        true solved:        SolvedNode;
        args_n_locals:      Overload[];
        args_neg:           i32;
    };

    struct RevSpecInstance
    {
        true original:      Target;
        relaxed_quals:      Quals;
    };

    struct RevSpecOutput
    {
        relaxed_quals:      Quals;
        instance_targ:      Target;
    };

    struct ReverseSpecialization
    {
        instance?:          RevSpecInstance;
        outputs?:           RevSpecOutput[];
    };

    struct CurrentFn
    {
        true using out:     SolvedNode;

        asserts:            DeclAsserts;

        using flow?:        Flow;

        far_jumps?:         flat::Set(i32);
        using events?:      Events;
        autoshadow_ok!:     i32;

        using relaxed?:     VarUsage;

        TODO_FIX_isInline?: bool;

        TODO_FIX_catches?:  i32;

        args_neg?:          i32;

        using postdom?:     Postdom;

        TODO_FIX_children?: LocidMap(flat::Set(i32));

        rev_spec_proto?:    RevSpecPrototype;

        TODO_FIX_unique?:   i32;
    };

    lax mut _current_fn:        CurrentFn;

    inline fn add(ref set, other)
        set._bitset.add(other._bitset);

    inline fn clear(ref set)
        set._bitset.clear();

    inline fn has_inter(a, b)
        a._bitset.has_inter(b._bitset);

    fn has(set: LocidSet, locid) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.has(args_neg + locid);
    }

    fn add(ref set, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return [];
    }

    fn each(set: LocidSet, each) {
        return set._bitset.each(|locid| each(locid - args_neg));
    }

    inline fn has(ref map: LocidMap(_), locid: i32)
        return !!map.if(exists: locid);

    fn if(ref map: LocidMap(_), exists!locid: i32) return [];

    fn ensure(ref map: LocidMap(_), exists!locid) {
        lax let args_neg = _current_fn.args_neg;
        lax ref v = map.ensure(exists: locid);
        return v != v0;
    }

    infix fn |=(ref dest: LocidMap(Quals), src: LocidMap(Quals)) {
    }

    struct SpecExtras
    {
        scope_items:        ScopeItem[];
        arg_spec_types:     flat::Map(string, Type);
    };

    struct Ephemeral {
        local_of:           i32;
        scope_memo?:        ScopeMemo;
        scope_skip?:        ScopeSkipMemos;

        spec_extras?:       SpecExtras;

        calls?:             flat::CountedSet(i32);

        specs?:             flat::Map(string, Target);

        far_jumps?:         flat::Set(i32);

        rev_spec?:          ReverseSpecialization;
    };

    using flags TypeParamFlags {
        TP_isArgSpec;
        TP_isTypenameArgSpec;
        TP_needsConsumedTypes;
    };

    struct TypeParam {
    };

    using enum SolverPass
    {
        Solving = 0
        RelaxMut
        BorrowCheck
        ArgumentsAtRisk
        RelaxCopyResize
    };

    struct ConvCacheColumns {
        types:              ValueType[];
        paths:              Target[][];

        must_see:           i32[][];
    };

    struct ConvCache_ColsAndBakes {
        using columns:      ConvCacheColumns;

        field_implicits:    ScopeItem[];
    };

    struct SolverState
    {
        _scope:             Scope;
        _root_scope:        ScopeMemo;
        _pub_imports:       flat::Set(i32);
        _helpers_data:      HelpersData[];
        _ephemeral:         Ephemeral[];

        _conv_cache:        flat::Map(ValueType, ConvCache_ColsAndBakes);

        _solver_safety:     int;
        _qstack_safety:     int;

        shortModuleName:    string;

        TODO_FIX_convert_args:  SolvedNode[];
        _solvingFnort:      Target;
        _nestingFnort:      Target;
    };

    struct HelpersData
    {
        target!?:           Target;
        pass!?:             SolverPass;
        mask!?:             HelpersMask;

        id?:                string;
        local_of!?:         i32;
        locals_start!?:     i32;

        ret_actual?:        Type;

        postdom?:           Postdom;
        kills!?:            Helpers;
    };

    using enum StaticEval {
        SE_Unknown = 0
        SE_False
        SE_True
    };

    using enum BorrowCheckPass {
        BCK_bck
        BCK_aar
        AQ_WhyNotNovec
    };

    using enum DeadBreak {
        DeadBreak_Always
        DeadBreak_Only_WhileSolvingRecursion
    };

    lax fn clear(lax ref flow: Flow) {
        return [];
        reorder.applicable = false;
        reorder.map.clear();
    }

    using enum ArgRationale {
        CantTempCopy_HostArg_Ref
        CantTempCopy_HostArg_MutRef
        CantTempCopy_FastFn
        CantTempCopy_NonCopiable
        CantTempCopy_ReturnedFromFn

        RequireVal_AliasesMutatedInjectedArgument
    };

    using mut ss:           SolverState;
    implicit lax mut _helpers:  Helpers[];

    ss.TODO_FIX_convert_args    = [ SolvedNode ];
    lax fn push(lax data) {
        return [];
        lax let ret         = Helpers(index);
        _helpers       ~= ret;
        _helpers_data  ~= data;
        return [];
    }

    _scope.extended ~= Extended();  
    lax fn Scope_pop(lax memo) {
        _scope.implicits.shrink(memo.implicits_len);
        _scope.converts .shrink(memo.converts_len);
        _helpers        .shrink(memo.helpers_len);
    }

    lax fn isMutVal(lax o) return [];

    using inline fn GET(h: Helpers): HelpersData return [];

    inline fn couldHaveEPH(target: Target) return [];

    using fn EPH(target: Target) return target.couldHaveEPH
            && _ephemeral.if(exists: target.globid);

    fn nested(index: i32, from!: Target) return Target(:from.modid, :from.globid, locid: index);

    fn nested(index: i32) return nested(:index, from: _nestingFnort);

    fn str(lifetime: Lifetime, brief?: bool) {
        lax mut str = "";

        lifetime.Lifetime_each: |locid, isStatic, isTemp, isArgIdx, isAlwaysMoveable, argidx, paths|
        str ~= locid        ? nested(locid).str(brief: true)
                 : isTemp       ? "temp".qLT
                 : isArgIdx     ? "arg#" ~ argidx
                                : BUG("invalid region");

        return str;
    }

    fn explainTypeName(type: Type, brief!?: bool) return (type.canon == t_bool.canon ? "bool"
              : type.canon == t_byte.canon ? "byte"
              : type.canon).qKW;

    fn explainType(type, brief!?: bool, mut lt!?: bool, mut no_quals!?: bool, mut usage!?: bool, mut no_vfacts!?: bool, diff!?: Type, lax i!_ignore?: int) {
        lax mut result = "";

        result ~= explainTypeName(type, :brief);

        return result;
    }

    lax fn fail_appendStack(lax mut reason: string) {
        lax mut skip_if_local_of    = i32.MAX;
        lax mut ellipsis            = false;
    }

    fn tryBacktrack(from: TokenIdx, v: string, k: Kind = "id"): TokenIdx return [];

    fn fail(reason: string, backtrack!?: string, mut token! = _here, highlight?: TokenIdx[]) reason || BUG("fail(): No reason.");

    fn str(t: Target, brief!?: bool) {
        lax let o       = GET(t);
        lax let kind    = o.kind;

        lax mut prefix  = "";

        lax mut ns = "";
        return (prefix && prefix.qKW ~ " ") ~ ns ~ o.name.human.qID;
    }

    fn str(arg: Argument, brief!?: bool) {
        lax mut prefix = (arg.flags & F_INJECTED && "injected ")
                   ~ (arg.flags & F_IMPLICIT && "implicit ")
                   ~ (arg.flags & F_REF && "ref ");

        return [];
    }

    lax fn human(lax id) {
        return [];
        return [];
    }

    fn makeNote(note, inline reason?: string) _notes |= note;

    fn ConvCache_nukeConverts(inline reason) _conv_cache.clear();

    fn ConvCache_nukeUsings(inline reason: string) {
        TRACE("ConvCache_nukeUsings: " ~ reason);
        _conv_cache.remove(ValueType());
    }

    fn _Scope_import__forceCopy(modid: i32, private!?: bool): void {
        lax let s = ctx.modules[modid].out.solve.scope;

        lax let usings0     = _scope.usings.len;
        lax let converts0   = _scope.converts.len;

        inline fn pub_or_priv !T(what: T[..], pub_count: int) {
            lax let N = what.len;
            return what[private ? pub_count : 0
                     .. private ? N : pub_count];
        }

        _scope.converts     ~= pub_or_priv(s.converts, s.pub_converts);
        _scope.implicits    ~= pub_or_priv(s.implicits, s.pub_implicits);
        _scope.globals      ~= pub_or_priv(s.globals, s.pub_globals);

        lax let usings1 = _scope.usings.len;
        ConvCache_nukeUsings("[import.pub]: usings0(" ~ usings0 ~ ") usings1(" ~ usings1 ~ ")");
    }

    fn isFnOrType(h): bool
        !!(h.mask & (HM_Function | HM_UserType));

    using fn GET(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;
        return _scope.overloads[globid - 1];
    }

    fn EXT_mut(target: Target) {
        lax let globid  = target.globid;

        return _scope.extended[globid];
    }

    fn EPH_mut(index: i32) return _ephemeral.ensure(exists: index);

    fn EPH_mut(target: Target) return EPH_mut(target.globid);

    fn localOf(target: Target) return target.local_of;

    fn SolvedNode(kind:       Kind, type:       Type, flags?:     Flags, value?, items?:     SolvedNode[], target?:    Target, helpers?:   Helpers) return [];

    fn Lifetime_fromNative(sig: Node[..], args: SolvedNode[..], actual: Type): Lifetime {
        lax mut res: Type;

        sig.len + FN_ARGS_BACK == args.len || BUG("sig.len != args.len");

        res.lifetime || fail("No ref arguments, cannot infer what the returned reference points to.");

        res.lifetime.Lifetime_if_only(|locid| !!locid) || res.is_zst || fail("Infered a non-single-local __native lifetime: " ~ res.lifetime);

        return res.lifetime;
    }

    lax fn TEST_varLifetime(lax lifetime, lax staticOK!?: bool, lax locid!expect?: i32) =
    {
    }

    lax fn Binding(lax id,lax mut type: Type,lax flags!: Flags,lax asserts!: DeclAsserts,lax ref shadows!: bool,lax asArgument!: bool) {
        return [];
        lax mut name        = id;
        lax let local_of    = _current_fn.target.globid;

        lax let target = Scope_create(_scope, nest, :asArgument, kind: "var", :name, :flags, :asserts, :status);

        lax mut end   = fname.len;

        return [];
    }

    lax fn explainNotMutref(lax what: Type) {
        return [];

        return [];
    }

    fn explainNotAssignable(host, guest: Type, cannot_retype!?: SolvedNode) {
        lax let hint = cannot_retype && tryExplainCannotRetype(cannot_retype, expect: host);

        return "expects " ~ explainTypeDiff(host, guest, sep) ~ hint;
    }

    fn str(n: SolvedNode) {
        lax mut src = n.kind.str.qKW;

        return src;
    }

    fn solveTypeCast(node: Node): SolvedNode {
        lax let left   = node.items[0];
        lax let right  = node.items[1];

        lax let expect = evalTypeAnnot(right);
        lax mut actual = solveNode(left, expect);

        convertIfNeeded(:actual, :expect, "Cannot convert: ");
        lax mut typeParams0 = steal(_typeParams);
        reorder.applicable = true;
        reorder.map.clear();

        lax mut used                = 0;
        lax mut usings_left         = num_usings;

        lax mut ha_bound_optional   = 0;

        usings_left && BUG("reorderByArgIDs: usings_left != 0");

        {
            lax mut trailing_misses     = 0;

            lax let trailing_usings = (num_usings - non_trailing_misses).max(0);

            lax mut count = 0;
            lax mut first = names.len;

            return [];
        }

        return [];
    }

    lax fn ERRMSG_optionalArgumentAmbiguity(lax host_args,lax reorder,lax names: string[]) {
        names.each: |name|

        return [];
    }

    inline fn findRestStart(ext: Extended) return [];

    lax fn collectNamedArgs(lax args: Node[..] or SolvedNode[..],lax ref minArity: int) {
    }

    lax fn applyRetype(lax ref node: SolvedNode,lax retype) node.type = retype;

    lax fn explainWhichFn(lax mut t: Target,lax conversions?: Target[][],lax backtrack!?: string,lax fmt = NoContext) {
        lax mut result = t.str;

        return [];
    }

    lax fn exploreConversions(lax type) {
        return [];
        lax mut inserted = false;
        lax ref cc = _conv_cache.ref(type, init);
    }

    lax fn doExploreConversions(lax startType,lax ref init: ConvCache_ColsAndBakes) {
        TRACE_BRACKET("doExploreConversions startType(" ~ explainType(startType) ~ ")");

        lax mut result: ConvCache_ColsAndBakes;

        lax let conv_safety0 = _current_fn.conv_safety++;
        lax mut path: Target[];
        lax mut must_see: i32[];

        descend(from, nullary, isUserType: startType && startType.isUserType);

        for (mut i = startType && -1; i < result.types.len; i++) sha

        return [];
    }

    fn solveNode(node: Node, type?: Type): SolvedNode {
        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        return solveIf(node, type);
        return solveLoop(node);
        if (k == "continue")    return solveJump(node);

        if (k == "try")         return [];

        if (k == "typecast")    return [];
        if (k == "typeassert")  return [];
        if (k == "forfieldsof") return [];
        if (unorderedClassify(k))
            return solveDeclExpr(node);

        return BUG("solve: Unexpected " ~ k);
    }

    lax fn SLOW_type_maybeInside(lax host!: ValueType,lax guest!: ValueType,lax guest_non_triv_mask!: u64) {
        return [];
        lax fn cannotCOW_climbParents(lax lifetime,lax expected_refs!?: i32[]) {
            return [];
            lifetime.Lifetime_each: |locid, region, paths|
            {
                lax let inter = _current_fn.flow.rg_parents.if(exists).Lifetime_inter(parent_region);

                lax mut some: UsedAgain;
                lt.Lifetime_each: |locid, isAlwaysMoveable, lax isStatic|
                if (PASS_MaybeCopyOrMove && h.mask & HM_Function)
                    mcom_FnReturn_CopyOrMoveDecision(:h);

                h.mask &= ~HM_LabelUsed;
                h.kills = kills;
            }

            lax ref items = node.items;
            _current_fn_eachArg_BACK: |t, position|
                relaxBlockVar(t, );
        }
    }

    fn solveRoot(node): SolvedNode {
        lax let helpers = Helpers(_helpers.len);
        push(HelpersData());

        lax let items = solveNodes(node.items, DeadBreak_Always, t_irrelevant);

        lax mut root = SolvedNode(kind: "root", type: t_void, :items, :helpers);
        runAllPasses(root);
        return [];
    }

    lax fn TODO_FIX_optionalSemis_blockWantsVoid(lax h) return [];

    fn solveBlock(node, type!: Type, fnbody_of!?: i32, mask! = HM_CanBreak, id!?: string, locals_start!?: i32): SolvedNode {
        h.ret_actual || BUG("No ret_actual");

        return [];
    }

    lax fn TEST_unusedButCopied(inline topic: string, slot) {
        o.kind == "var" && o.isMutVal || BUG("keepOrClearMutVal: Not a mut var");

        lax ref node = o.solved;
        if !(o.flags & F_LAX || o.status & SS_MATCHED || o.type.is_zst)
            push(Warning(:target.locid));
    }

    lax fn TEST_unpaintNode(lax ref node: SolvedNode, lax expect_paint!: bool) node.flags &= ~F_TEST_painted;

    fn solveChar(node: Node): SolvedNode {
        lax mut type = t_byte;
        return [];
    }

    lax fn executeCompilerPragma(lax node: Node) {
        compilerBreak();
        return [];
    }

    fn X_addrofTarget(target: Target)
        X_addrofTarget([ target ]);

    lax fn getOrCreateChild(lax node: Node,lax onReuse,lax onCreate) {
        return [];
        lax let parent = _current_fn.target;

        lax let target = Scope_create(_scope);
        onCreate(target);

        return [];
    }

    lax fn resetChild(lax target: Target) {
        TRACE("resetChild " ~ target.globid ~ " " ~ target);

        lax ref status = GET_mut(target).status;
        lax let calls = steal(target.EPH_mut.calls);
        callee.EPH_mut.callers.remove(target.globid)
                || BUG("resetChild: Missing in callers on " ~ callee);

        callers.each: |caller| 
        lax ref args = EXT_mut(target).args;
        args_mangled ||= mangleArgTypes(:args, :reorder, :conversions, :REST_START, :REST_TYPE);

        return [];
        lax let instance        = target.rev_spec.instance;
        TRACE_BRACKET("doReverseSpecialize " ~ target.globid ~ " " ~ target ~ " for " ~ relaxed_quals);

        lax mut args_n_locals   = prototype.args_n_locals;
        lax let args_neg        = prototype.args_neg;

        lax let helpers0        = _helpers.len;
        lax mut current_fn0     = _current_fn.steal();

        lax let solvingFnort0   = _solvingFnort.exchange(target);
        {
            lax mut lastKnownLocal:     i32;

            lax fn replaceGlobid(lax ref t: Target) {
                return [];
                TEST_true(t.parent == original);
            }
        }

        {
            lax let rtl = args.len == 2
                && overload.flags & F_OPERATOR
                && cpp::hasAssignment(overload.name)

                && (kind != "fn" || args.some(|a| a.type && !a.type.is_primitive));

            overload.isRTL_set(rtl);
        }

        lax let solved = !isUnspec && _current_fn.out;

        overload.solved = solved;

        eph.far_jumps   = _current_fn.far_jumps;

        eph.rev_spec.prototype =
            _current_fn.rev_spec_proto.steal();
    }

    lax fn createRawTypedef(lax id,lax mut type: Type,lax flags: Flags,lax name?: string,lax status?: SolverStatus) {
        type        = into_Typename(type);
        lax let target = createRawTypedef(id, annot, :flags);

        PROFILE(.SolveStruct);

        lax let origId      = node.value;

        lax mut name        = origId
            || _current_fn.target && _current_fn.target.name
            || "Anon";

        lax let kind        = node.kind;
        lax let isStruct    = kind == "struct";
        lax mut basePrimType:   Type;

        lax let asserts     = node.asserts;
        lax let out_target  = into ||
        {
            lax let specPat = !origId
                && TODO_FIX_useSpecPath
                && TODO_FIX_getSpecPat();

            lax let out_target = createRawTypedef(id, :name, :node.flags, status: SS_LAZY, type: initUserType(:kind, :shape, :name, :asserts, :specPat, initialHash: shape.hash));
        };

        lax let own_scp         = parseUserTypeCanon(instType.canon);
        lax let own_scp_added   = lookupUserType_mut(own_scp).shape.usertypes.add(own_scp);
        lax let helpers0 = _helpers.len;
        lax let helpers_data0 = _helpers_data.len;

        push(HelpersData(mask: HM_UserType, target: out_target || BUG("solveStruct: no out_target: `" ~ origId ~ "`.")));

        lax mut structImports:  flat::Set(i32);

        lax mut member_usertypes: flat::Set(UserTypeCanon);

        lax fn solveMember(lax shadow node: Node) return [];

        lax let members = memberNodes.map(fn solveMember);

        {
            lax ref o = GET_mut(t);
            o.status |= SS_MOVED_FROM;

            lax let init = t.Lifetime_climbType;
            Lifetime_F_MOVED_FROM(init.lifetime);
        }
    }

    lax fn superType_neverOK(lax reason,lax a,lax b,lax target?: Target) {
    }

    lax fn superType(lax reason,lax a,lax b: Type,lax target?: Target) {
        return [];
        return [];
    }

    lax fn solveJump_finish(lax flags: Flags,lax expr: SolvedNode,lax h!: Helpers) {
        h.mask |= HM_LabelUsed;

        reportReturnType(:h, expr.type, NICEERR_missingReturn: !!(flags & F_IMPLICIT));

        return [];
    }

    lax fn createJump(lax h!: Helpers,lax expr) return [];

    lax fn reportReturnType(lax h!: Helpers,lax type: Type,lax NICEERR_missingReturn!?: bool) isAssignable(:asArgument, :host, :guest)
            || fail((target && target.str)
                ~ reason ~ ": " ~ explainNotAssignable(:host, :guest));

    lax fn tryConvertIfNeeded(lax ref actual: SolvedNode,lax expect: Type,lax asArgument!?: bool) {
        return [];
        _helpers.reveach(_ss.helpers, |item, i|
        {
            return [];
        });

        fail("No return " ~ id.qBAD ~ " in scope.");
    }

    fn solveLetLike_dontTouchScope(node: Node, specType!?: Type, primType!?: Type, asArgument!: bool): SolvedNode {
        return [];
    }

    fn solveLet_createBindingAndGetLetdef(lax mut out!: SolvedNode, id!: string, setScope!: bool, asArgument!isArg: bool, asserts!: DeclAsserts): SolvedNode {
        lax mut shadows     = !!(out.flags & F_SHADOW);

        return [];
    }

    lax fn createLetDef(lax target) {
        return [];
        return [];
    }

    lax fn createLet(lax id,lax flags: Flags,lax asserts,lax init: SolvedNode,lax setScope!: bool) {
        return [];
    }

    fn solveTryCatch(node): SolvedNode {
        lax let scope0  = Scope_snap();

        lax let try     = solveNode(node.items[0], t_irrelevant);

        lax let catch   = solveNode(node.items[2], t_irrelevant);

        Scope_pop(scope0);

        err.kind == "letdef" && isAssignableAsArgument(host, definitType(t_string)) || fail("catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return [];
    }

    fn evalTypeParam(id: string): Type return [];

    fn solveTypeParam(node: Node): SolvedNode return [];

    fn evalTypeAnnot(node: Node, TODO_FIX_typeof_dontStripRefs!?: bool): Type {
        fn T = evalTypeAnnot(node.items.only);

        lax let here0   = _here;
        _here       = node.token;

        lax let exprType = node.kind == "typeparam"
            ? evalTypeParam(node.value)
            : solveNode(node).type;

        lax let callTargIdx = matchCall(:misc_scope, local_scope, :id, :args, :reorder, :conversions, :flags, :targets);

        return [];
        lax mut arrayType = createArray(itemType);

        return [];
    }

    lax fn litfix_bound(lax expr,lax bound!: SolvedNode) return [];

    fn createAnd(mut items, mut type: Type): SolvedNode {
        type = t_bool;

        lax let last_type = items.last;
        return [];
    }

    lax fn createAndOr_staticEvalFold(lax ref items: SolvedNode[],lax static_eval_fold!: StaticEval) {
        return [];
        lax mut trim = 0;

        return [];
    }

    lax fn createAndOr_staticEvalTrim(lax trim: i32,lax ref items: SolvedNode[],lax ref type: Type,lax vfacts: VFacts,lax if_only) {
        return [];

        lax let item = solveNode(node.items.only, type: t_proposition);

        return [];
    }

    lax fn SLOW_traverse(lax node: SolvedNode,lax visit) {
        lax mut stack = [ node ];

        lax fn TODO_FIX_pop(lax ref arr: $T[]) {
            return [];
            swap(item, arr[arr.len - 1]); 
            return item;
        }
    }

    lax fn qSTACK_cow_inside(lax target,lax node: SolvedNode,lax host_arg: Argument,lax cow_inside: TokenIdx,lax seen!?: Target[]) {
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        lax mut candidates = "";

        return [];
    }

    lax fn HelpersReplica(lax local_of!: i32,lax locals_start!: i32,lax ret_actual) return [];

    fn solveNodes(nodes, dead_brk, type_all?: Type, type_last!?: Type, use_type_last!?: bool, static_eval_brk!?: StaticEval, TODO_FIX_useSpecPath!?: bool): SolvedNode[] {
        lax let here0   = _here;

        return [];
        return o.acceptsTempCopies()
    }

    lax fn rejectsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) {
        return [];
        return arg.flags & F_IMPLICIT   ? CantTempCopy_HostArg_Implicit
             : arg.flags & F_REF        ? CantTempCopy_HostArg_Ref
             : arg.type.is_mutref       ? CantTempCopy_HostArg_MutRef

             : !(arg.flags & F_VAL) && requireVal;
    }

    fn PASS_borrowCheck(ref root: SolvedNode, pass: BorrowCheckPass) {
        inline fn BCK = pass == BCK_bck;

        fn tokenHash(token)
            (token.modid.u32 * 9973 ^ token.tokidx.u32) << 20;

        fn locid(w: WriteID)
            (w._locid_and_hash & 0xfffff).sign_unrotate;

        lax fn ArgRationale_explain(lax r: ArgRationale,lax callee: Target,lax arg,lax host_arg) return "Unknown reason.";

        lax fn RESOLVE_byAAR(lax write!: i32,lax reads!: i32[..],lax trySoft!: bool) {
            return [];
            reads.each: |read|
                RESOLVE_byAAR(write: writes[i].locid, :read, :trySoft);

            return [];
            return [];
        }

        lax fn RESOLVE_byMutvar(lax locid: i32) {
            return [];
            BCK || BUG();

            lax let t = nested(locid);
            TRACE("RESOLVE_byTempCopy: " ~ t);

            o.type.is_mutref && BUG(t ~ ": Not F_REF but type.is_mutref"
                    ~ " in RESOLVE_byMutvar: is this a problem?");

            TEST_varLifetime(o.type.lifetime);

            return true;
        }

        fn SLOW_find(test): SolvedNode {
            SLOW_traverse(root): |node|
                if (test())
                    return [];

            return [];
        }

        fn SLOW_findByReadID(read!, write_loop_start) {
            fn eachLoopStart(mut search: i32, which, visit) {
            }

            lax mut loop_ids: i32[];
            eachLoopStart(write_loop_start, .write_loop_start): |loop_id|
                loop_ids ~= loop_id;

            lax fn checkReadLoopStart(lax read_loop_start) {
                return [];
                eachLoopStart(read_loop_start, .read_loop_start): |loop_id|

                return [];
            }

            return SLOW_find(|node|
                node.target.isLocal &&
                node.target.locid == read &&
                checkReadLoopStart(node._loop_start))
                    || BUG("Cannot find read(" ~ nested(read) ~ ") in loop(" ~ write_loop_start ~ ").");
        }

        lax fn RWEvent_stack(lax write) {
            lax let locid = write.locid;

            return [];
        }

        fn flow         = _current_fn.flow;
        fn events       = _current_fn.events;

        lax fn Reference_trackLocalRef(lax t_left,lax right: Lifetime) {
            lax let left = Lifetime_getRefLocid_unlessStatic(t_left.lifetime);
            shadow let right = right.Lifetime_process(|locid, continue_keep|
            {
                continue_keep();
            });

            lax mut parents:    Lifetime;
            lax mut siblings:   Lifetime;

            siblings = siblings.Lifetime_process(|locid!sibling, continue_keep|
            {
                lax let sibling_parents = flow.rg_parents.if(exists: sibling);
            });
        }

        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime) {
            lax let loop_start  = callOrPragma._loop_start || BUG("bck_trackWrites: _loop_start not set on callsite.");
            lax let OPTI_isLoop = loop_start != NO_LOOP && !!events.used_in_a_loop;
            lifetime.Lifetime_each: |locid!write, region!write_region, paths!write_paths|
            {
                lax mut all_written = write_region;

                all_written.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: write), paths: write_paths));

                lax let invalidates = flow.rg_invalidates.if(exists: write);

                if (OPTI_isLoop) invalidates.Lifetime_each: |locid!read|
                {
                    if (read < loop_start) {
                        if (events.used_in_a_loop.has(read)) {
                            RESOLVE_byMutvar(read) || fail("Write to " ~ write.nested
                                        ~ (callOrPragma.kind == "call" && " at call to " ~ callOrPragma.target)
                                        ~ " invalidates the use of " ~ read.nested ~ " at "
                                        ~ SLOW_findByReadID(:read, loop_start).token.addr_and_snippet
                                        ~ "\n\t... on next loop iteration.\n\n\tWritten"
                                        ~ qSTACK_rwevent(callOrPragma, ));
                        }
                    }
                }
            }
        }

        bck_node(root);
    }

    lax fn TEST_node(lax ref node: SolvedNode, lax pass, lax expect_paint!?: bool) {
        TEST_unpaintNode(:node, :expect_paint);

        lax let k = node.kind;

        !node.is_ref == !node.lifetime || BUG(node ~ ": !!ref != !!lt: " ~ explainType(node.type));
    }

    lax fn TEST_pass(lax ref node: SolvedNode, lax pass, lax expect_paint!?: bool) {
        node.helpers.target == _current_fn.target || BUG();

        TEST_node(:node, :pass, :expect_paint);
    }

    fn runAllPasses(ref node: SolvedNode) {
        TEST_pass(node, :node.helpers.pass);

        {
            PROFILE(.RelaxMut);
            PASS_borrowCheck(node, BCK_bck);
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");

            Postdom_resetAtFnEnd(_current_fn);
            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxCopyResize.end: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
        }

        TEST_pass(node, :node.helpers.pass, expect_paint: true);
    }

    fn PASS_runAllVerifiers() {
        {
            PROFILE(.EnsureArgSeq);

            _nestingFnort && BUG("PASS_runAllVerifiers: non-empty _nestingFnort");
            _current_fn.args_neg && BUG("PASS_runAllVerifiers: non-empty _current_fn.args_neg");
        }
    }
}
