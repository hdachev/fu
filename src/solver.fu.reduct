import ansi;
import helpers;
import flags;
import scope;
import context;
import types;
import quals;
import usage;
import usertypes;
import effects;
import lifetime;
import module;
import fail;
import experiments;

let OPTI_autoshadow         = true;
let OPTI_dedupe_vars        = true;
let OPTI_bck                = true;
let OPTI_unlist_callers     = true;
let OPTI_moves_inside_fns   = true;

let USE_rev_spec            = true;

let RESOLVE_report          = false;
let TRACE_enable            = false;

let NO_LOOP         = -1000001;

pub fn solve(implicit lax ctx: Context, implicit lax ref module: Module, implicit lax options: options::Options): SolverOutput {
    lax let implicit mut _here: TokenIdx;

    PROFILE(.UnaccountedFor, reset: true);

    lax mut TRACE_out       = TRACE_enable ? string : void;
    lax mut TRACE_indent    = TRACE_enable ? string : void;

    lax fn TRACE_BRACKET(inline msg: string) unwrap
    {
        lax mut indent0:    string;
        lax mut len0:       int;

        if (TRACE_enable) {
            len0    = TRACE_out.len;
            indent0 = TRACE_indent ~ '\t';
            swap(TRACE_indent, indent0);
        }

        defer if (TRACE_enable) {
            if (TRACE_out.len > len0) {
                TRACE_out.splice(len0, 0, indent0 ~ "< " ~ msg ~ " >\n");
                TRACE_out ~= indent0 ~ "</" ~ msg ~ " >\n";
            }

            swap(indent0, TRACE_indent);
        }
    }

    lax fn TRACE(inline msg: string) {
        if (TRACE_enable)
            (((TRACE_out ~= "-------") ~= TRACE_indent) ~= msg) ~= '\n';
    }

    defer if (TRACE_enable) {
        println("TRACE\n\n" ~ (TRACE_out || "nothing") ~ "\n");
    }

    struct LocidSet
    {
        _bitset:            ::BitSet;
    };

    struct LocidMap(type T) {
        _values:            T[];
    };

    struct Warning
    {
        locid:              i32;
    };

    struct WriteID
    {
        _locid_and_hash:    u32;
    };

    struct EventsSnap
    {
        invalidated_by:     LocidMap(flat::Set(WriteID));
    };

    struct PrecedingRefArg
    {
        callsite_token:     TokenIdx;
        target:             Target;
        r:                  i32;
        w:                  i32;

        arg:                SolvedNode;
    };

    struct Events
    {
        using snap:         EventsSnap;

        used_in_a_loop:     LocidSet;

        preceding_ref_args: PrecedingRefArg[];

        cows_inside:        COWInside[];
    };

    fn clear(ref events: Events) {
        events = [];
    }

    fn Events_merge(ref events: EventsSnap, snap: EventsSnap) {
        fn Events_merge(ref dest._values: flat::Set($T)[], src._values: flat::Set($T)[]) {
        }

        return [];
        if (!write_loop_start)
            BUG("Events_restore: no write_loop_start, cant decide which events need to survive");

        if (write_loop_start == NO_LOOP) {
            events.snap = restore;
            return;
        }

        for (fieldname i: EventsSnap)
            events.i.Events_restore(restore.i);
    }

    struct PostdomSnap
    {
        used_again:         LocidSet;

        ever_written:       LocidMap(Quals);

        mayEscapeVia:       MayEscapeVia;
        exitPaths:          ExitPaths;
    };

    struct Postdom
    {
        using snap:         PostdomSnap;

        write_loop_start:   i32;
        read_loop_start:    i32;
    };

    struct VarUsage
    {
        done_relaxing:      LocidSet;
        var_usage:          LocidMap(Type);
    };

    struct Flow
    {
        rg_parents:         LocidMap(Lifetime);
        rg_invalidates:     LocidMap(Lifetime);         
        rg_children:        LocidMap(flat::Set(i32));

        at_soft_risk:       LocidMap(LocidSet);
        at_hard_risk:       LocidMap(LocidSet);

        bck_consider_copy:  LocidSet;

        is_arg:             LocidSet;
        arg_parents:        LocidMap(flat::Set(i32));
        arg_targets:        i32[];
    };

    struct ScopeMemo {
        items_len:          i32;
        implicits_len:      i32;
        imports_len:        i32;
        privates_len:       i32;
        usings_len:         i32;
        converts_len:       i32;
        helpers_len:        i32;
    };

    struct ScopeSkipMemos {
        items:              ScopeSkip[];
        implicits:          ScopeSkip[];
        imports:            ScopeSkip[];
        privates:           ScopeSkip[];
        usings:             ScopeSkip[];
        converts:           ScopeSkip[];
        helpers:            ScopeSkip[];
    };

    struct RevSpecPrototype
    {
        true solved:        SolvedNode;
        args_n_locals:      Overload[];
        args_neg:           i32;
    };

    struct RevSpecInstance
    {
        true original:      Target;
        relaxed_quals:      Quals;
    };

    struct RevSpecOutput
    {
        relaxed_quals:      Quals;
        instance_targ:      Target;
    };

    struct ReverseSpecialization
    {
        prototype?:         RevSpecPrototype;
        instance?:          RevSpecInstance;
        outputs?:           RevSpecOutput[];
    };

    struct CurrentFn
    {
        true using out:     SolvedNode;

        scope0:             ScopeMemo;

        asserts:            DeclAsserts;

        using flow?:        Flow;

        far_jumps?:         flat::Set(i32);
        using effects?:     Effects;
        using events?:      Events;
        autoshadow_ok!:     i32;

        using relaxed?:     VarUsage;

        TODO_FIX_isInline?: bool;

        TODO_FIX_catches?:  i32;

        already_inlined?:   Target[];
        conv_safety?:       int;
        args_neg?:          i32;

        using postdom?:     Postdom;

        TODO_FIX_children?: LocidMap(flat::Set(i32));

        rev_spec_proto?:    RevSpecPrototype;

        TODO_FIX_bckCantDealWithNestedDefers?: i32;
        TODO_FIX_unique?:   i32;
    };

    lax mut _current_fn:        CurrentFn;

    inline fn |= (ref set: LocidSet, other: LocidSet)
        set._bitset |= other._bitset;

    inline fn add(ref set: LocidSet, other: LocidSet)
        set._bitset.add(other._bitset);

    inline fn clear(ref set: LocidSet)
        set._bitset.clear();

    inline fn has_inter(a: LocidSet, b: LocidSet)
        a._bitset.has_inter(b._bitset);

    lax fn clear(lax ref set: LocidSet,lax start!: i32) {
        return [];
        lax let args_neg = _current_fn.args_neg;
        set._bitset.clear(start:
            args_neg + (start == NO_LOOP ? -args_neg : start));
    }

    fn has(set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.has(args_neg + locid);
    }

    fn add(ref set: LocidSet, locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.add(args_neg + locid);
    }

    fn each(set: LocidSet, each) {
        lax let args_neg = _current_fn.args_neg;
        return set._bitset.each(|locid| each(locid - args_neg));
    }

    inline fn clear(ref map: LocidMap(_))
        map._values.clear();

    inline fn has(ref map: LocidMap(_), locid: i32)
        return !!map.if(exists: locid);

    fn clear(ref map: LocidMap(_), start!: i32) {
        lax let args_neg = _current_fn.args_neg;
        lax let i = start + args_neg;
        lax let args_neg = _current_fn.args_neg;
        return map._values[args_neg + locid];
    }

    fn if(ref map: LocidMap(_), exists!locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return map._values.if(exists: args_neg + locid);
    }

    fn ensure(ref map: LocidMap(_), exists!locid: i32) {
        lax let args_neg = _current_fn.args_neg;
        return map._values.ensure(exists: args_neg + locid);
    }

    fn add(ref map: LocidMap(Quals), locid: i32, quals: Quals) {
        lax ref v = map.ensure(exists: locid);
        lax let v0 = v;
        v |= quals;
        return v != v0;
    }

    infix fn |=(ref dest: LocidMap(Quals), src: LocidMap(Quals)) {
    }

    lax fn Postdom_resetAtFnEnd(lax ref postdom: Postdom) {
        return [];
        postdom                     = [];
        postdom.write_loop_start    = NO_LOOP;
        postdom.read_loop_start     = NO_LOOP;
        postdom.exitPaths           = XP_EmptyReturn;
    }

    fn branch(ref dest: Postdom, src: Postdom) {
        dest.write_loop_start = max(dest.write_loop_start || BUG(), src.write_loop_start || BUG());

        dest.read_loop_start = max(dest.read_loop_start || BUG(), src.read_loop_start || BUG());
    }

    struct ChildTarget
    {
        token:              TokenIdx;
        parent_rev:         u32;
        target:             Target;
    }

    struct SpecExtras
    {
        scope_items:        ScopeItem[];
        arg_spec_types:     flat::Map(string, Type);
    };

    struct Ephemeral {
        local_of:           i32;
        revision:           u32;

        scope_memo?:        ScopeMemo;
        scope_skip?:        ScopeSkipMemos;

        spec_extras?:       SpecExtras;

        callers?:           flat::CountedSet(i32);
        calls?:             flat::CountedSet(i32);

        children?:          ChildTarget[];
        specs?:             flat::Map(string, Target);

        far_jumps?:         flat::Set(i32);

        rev_spec?:          ReverseSpecialization;
    };

    using flags TypeParamFlags {
        TP_isArgSpec;
        TP_isTypenameArgSpec;
        TP_needsConsumedTypes;
    };

    struct TypeParam {
        matched:            Type;
        invariant:          Type;
        consumed:           Type;
        flags:              TypeParamFlags;
    };

    type TypeParams = flat::Map(string, TypeParam);

    using enum SolverPass
    {
        Solving = 0
        RelaxMut
        BorrowCheck
        ArgumentsAtRisk
        MaybeCopyOrMove
        RelaxCopyResize
    };

    struct ConvCacheColumns {
        types:              ValueType[];
        paths:              Target[][];

        must_see:           i32[][];
    };

    struct ConvCache_ColsAndBakes {
        using columns:      ConvCacheColumns;

        field_items:        ScopeItem[];
        field_implicits:    ScopeItem[];
    };

    struct SolverState
    {
        _scope:             Scope;
        _root_scope:        ScopeMemo;
        _ss:                ScopeSkipMemos;

        _pub_imports:       flat::Set(i32);
        _helpers_data:      HelpersData[];
        _ephemeral:         Ephemeral[];

        _conv_cache:        flat::Map(ValueType, ConvCache_ColsAndBakes);

        _solver_safety:     int;
        _qstack_safety:     int;

        _notes:             SolverNotes;
        _warnings:          Warning[];
        shortModuleName:    string;

        TODO_FIX_convert_args:  SolvedNode[];
        TODO_FIX_inline_safety: i32;

        _typeParams:        TypeParams;

        _solvingFnort:      Target;
        _nestingFnort:      Target;
    };

    struct HelpersData
    {
        target!?:           Target;
        pass!?:             SolverPass;
        mask!?:             HelpersMask;

        id?:                string;
        local_of!?:         i32;
        locals_start!?:     i32;

        ret_expect?:        Type;
        ret_actual?:        Type;

        postdom?:           Postdom;
        loop_PREVITER?:     Postdom;

        postevt?:           EventsSnap;

        kills!?:            Helpers;
    };

    using enum StaticEval {
        SE_Unknown = 0
        SE_False
        SE_True
    };

    using enum BorrowCheckPass {
        BCK_bck
        BCK_aar
        BCK_ooe
    };

    using enum ArgQuery {
        AQ_WhyNotNovec
    };

    using enum DeadBreak {
        DeadBreak_Dont = 0
        DeadBreak_Always
        DeadBreak_Only_WhileSolvingRecursion
    };

    struct Reorder {
        true applicable:    bool;
        map:                i32[];
    };

    lax fn clear(lax ref flow: Flow) {
        return [];
        reorder.applicable = false;
        reorder.map.clear();
    }

    fn LocalScope_union(local: ScopeSkipMemos, eph: Ephemeral) {
        fn reveal(shadow local: ScopeSkip[], shadow eph: ScopeSkip[], eph_end: i32) {
            shadow mut result: ScopeSkip[];

            :NEXT_LOCAL

            return result;
        }

        lax mut result = local;
        return result;
    }

    using enum ArgRationale {
        CantTempCopy_HostArg_Ref
        CantTempCopy_HostArg_MutRef
        CantTempCopy_HostArg_Implicit

        CantTempCopy_FastFn
        CantTempCopy_NonCopiable
        CantTempCopy_ReturnedFromFn

        RequireVal_AliasesMutatedInjectedArgument
    };

    primitive UsedAgain: u32;

    enum UsedAgainReason: u8 {
        None = 0
        WrongPass
        UsedAgain
        UsedInALoop
        ArgReference
        StaticReference
    };

    using mut ss:           SolverState;
    implicit lax mut _helpers:  Helpers[];

    ss.shortModuleName          = module.modid && getShortModuleName(module.fname);
    ss.TODO_FIX_convert_args    = [ SolvedNode ];
    ss.TODO_FIX_convert_args[0].kind = "__convert";

    fn push(data: HelpersData) {
        lax let ret         = Helpers(index: _helpers_data.len);
        _helpers       ~= ret;
        _helpers_data  ~= data;
        return ret;
    }

    _scope.extended ~= Extended();  
    push(HelpersData());

    fn Scope_pop(memo: ScopeMemo) {
        _scope.items    .shrink(memo.items_len);
        _scope.implicits.shrink(memo.implicits_len);
        _scope.imports  .shrink(memo.imports_len);
        _scope.privates .shrink(memo.privates_len);
        _scope.usings   .shrink(memo.usings_len);
        _scope.converts .shrink(memo.converts_len);
        _helpers        .shrink(memo.helpers_len);
    }

    fn Scope_snap() {
        ScopeMemo(items_len:     _scope.items     .len, implicits_len: _scope.implicits .len, imports_len:   _scope.imports   .len, privates_len:  _scope.privates  .len, usings_len:    _scope.usings    .len, converts_len:  _scope.converts  .len, helpers_len:         _helpers   .len)
    }

    fn field_packOffset(ref o: Overload, memberFlatOffset!: i32, memberFlatCount!: i32) {
        lax let packed = memberFlatOffset | memberFlatCount << 16;

        o.solved.helpers = Helpers(packed);
    }

    fn field_unpackOffset(o: Overload) {
        struct UnpackedOffset {
            memberFlatOffset: i32;
            memberFlatCount:  i32;
        };

        lax let packed = o.solved.helpers.index;

        return UnpackedOffset(memberFlatOffset: packed & 0xffff, memberFlatCount:  packed >> 16);
    }

    fn field_getParentStruct(o: Overload) {
        return o.solved.target || BUG("field_getParentStruct: solved.target not set.");
    }

    fn isMutVal(o: Overload) {
        return !(~o.flags & (F_MUT | F_VAL));
    }

    fn isMutRef(flags: Flags) {
        return !(~flags & (F_MUT | F_REF));
    }

    using inline fn GET(h: Helpers): HelpersData {
        return _helpers_data[h.index];
    }

    using fn EXT(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;

        shadow let _scope =
            modid == module.modid
                ? _scope
                : ctx.modules[modid].out.solve.scope;

        return _scope.extended[globid];
    }

    inline fn couldHaveEPH(target: Target) {
        return target.modid == module.modid;
    }

    using fn EPH(target: Target) {
        return target.couldHaveEPH
            && _ephemeral.if(exists: target.globid);
    }

    fn GET_next_local_index() {
        lax let globid = _current_fn.target.globid;
        return _scope.extended[globid].nextIndexOfLocal(asArgument: false);
    }

    fn nested(index: i32, from!: Target) {
        return Target(:from.modid, :from.globid, locid: index);
    }

    fn nested(index: i32) {
        return nested(:index, from: _nestingFnort);
    }

    fn str(lifetime: Lifetime, brief?: bool) {
        lax mut str = "";

        lifetime.Lifetime_each: |locid, isStatic, isTemp, isArgIdx, isAlwaysMoveable, argidx, paths|
        {
            if (str)
                str ~= "|".qLT;

            str ~= locid        ? nested(locid).str(brief: true)
                 : isStatic     ? isAlwaysMoveable ? "zeroes".qLT : "static".qLT
                 : isTemp       ? "temp".qLT
                 : isArgIdx     ? "arg#" ~ argidx
                                : BUG("invalid region");

            if (locid && !brief) {
                lax mut type: Type;

                lax mut offset = 0;
                paths.lifetime::walkPaths(:offset, onSubRegion: |flatCount, mut flatOffset, isFirstSubRegion, isLastSubRegion, isLastPath|
                {
                    :NEXT_TYPE
                    for (;;) {
                        lax let s = type.tryLookupUserType();
                        if (flatCount >= s.shape.flatCount)
                            break;

                        for (mut i = 0; i < s.items.len; i++) {
                            lax let o           = GET(s.items[i].target);
                            using let _     = o.field_unpackOffset;
                        }

                        break;
                    }

                    if (!isLastSubRegion) {
                        if (type.is_sliceable)
                            type = type.clear_sliceable();

                        str ~= "*";
                    }

                    if (isLastSubRegion && !isLastPath)
                        str ~= ", ";
                });
            }
        }

        return str;
    }

    fn explainTypeName(type: Type, brief!?: bool) {
        PERF_slowPath();

        lax let s = tryLookupUserType(type);
        if (let itemType = tryClear_sliceable(type)) {
            if (itemType == t_byte)
                return "string".qKW;

            return explainTypeName(itemType, :brief)
                ~ (type.TODO_FIX_isArray ? "[]" : "[..]").qKW;
        }

        if (type.is_zeroes)
            return "[]".qKW;

        return (type.canon == t_bool.canon ? "bool"
              : type.canon == t_byte.canon ? "byte"
              : type.canon).qKW;
    }

    fn explainType(type: Type, brief!?: bool, mut lt!?: bool, mut no_quals!?: bool, mut usage!?: bool, mut no_vfacts!?: bool, diff!?: Type, lax i!_ignore?: int) {
        if (!type)
            return "< Empty Type >";

        lax mut result = "";

        if (!no_quals)
            result ~= explainQuals(type.quals, lt && type.lifetime);

        result ~= explainTypeName(type, :brief);

        lax let pattern = type.canon.canon::tryGetPattern();

        if (usage) {
            fn appendUsage(shadow type: Type, shadow usage: Quals) {
                result ~= " { ";

                if (!usage) {
                    result ~= "- ";
                }
                {
                    lax let s = tryLookupUserType(type);
                    if (!s) {
                        result ~= "* ";
                    }
                    else
                    {
                        for (mut i = 0; i < s.items.len; i++) {
                            lax let f           = s.items[i].target;
                            lax let o           = GET(f);
                            using let _     = o.field_unpackOffset;

                            lax let match       = USAGE_fieldUsageFromStructUsage(quals: o.type.usage, usage, :memberFlatOffset, :memberFlatCount);
                        }
                    }
                }

                result ~= "}";
            }

            appendUsage(type, type.quals & q_USAGE);
        }

        return result;
    }

    fn fail_appendStack(mut reason: string) {
        lax mut pass0: SolverPass;
        lax mut callstack           = 0;
        lax mut skip_if_local_of    = i32.MAX;
        lax mut ellipsis            = false;

        return reason;
    }

    fn tryBacktrack(from: TokenIdx, v: string, k: Kind = "id"): TokenIdx {
        lax mut here = from;

        return [];
    }

    fn fail(reason: string, backtrack!?: string, mut token! = _here, highlight?: TokenIdx[]) {
        reason || BUG("fail(): No reason.");

        if (backtrack)
            token = token.tryBacktrack(backtrack) || token;

        TRACE("FAIL");
        return FAIL(reason.fail_appendStack(), tokens: token ~ highlight);
    }

    lax fn PERF_slowPath() {
        if (SELF_TEST && options.dev & options::DEV_HappyPathOnly)
            println("DEV_HappyPathOnly: we ended up on a slow path.");
    }

    lax fn str_IDns(lax from: Target) {
        return [];
        return from && GET(from).name.human.qID ~ ":";
    }

    fn str(t: Target, brief!?: bool) {
        lax let o       = GET(t);
        lax let kind    = o.kind;

        lax mut prefix  = "";
        if (!brief) {
            prefix  = kind.str;
            if (kind == "var") {
                prefix = (o.flags & F_INJECTED && "injected ")
                       ~ (o.flags & F_IMPLICIT && "implicit ")

                       ~ (o.flags & F_CONST && "const ")
                       ~ (o.flags & F_MUT   && "mut ")
                       ~ (o.flags & (F_REF | F_MUT | F_CONST) == F_REF
                            && (o.type.is_mutref ? "mut " : "const "))

                       ~ (o.flags & F_REF && "ref ")
                       ~ (t.isArg && "arg ")
                            || "let ";

                prefix.pop();
            }
        }

        lax mut ns = "";
        if (kind == "field")
            ns = str_IDns(o.field_getParentStruct());

        return (prefix && prefix.qKW ~ " ") ~ ns ~ o.name.human.qID;
    }

    fn str(arg: Argument, brief!?: bool) {
        lax mut prefix = (arg.flags & F_INJECTED && "injected ")
                   ~ (arg.flags & F_IMPLICIT && "implicit ")
                   ~ (arg.flags & F_REF && "ref ");

        prefix ~= "arg";

        lax mut ns = "";

        return prefix.qKW ~ " " ~ ns ~ arg.name.human.qID;
    }

    fn human(id: string) {
        PERF_slowPath();

        lax let t = hacks::tryParseClosureID(:id).target;
        if (!t) {
            if (id.has('\n'))
                return id.replace(all: '\n', with: ' ').trim();

            return id;
        }

        return GET(t.parent).name ~ ":" ~ GET(t).name;
    }

    fn makeNote(note: SolverNotes, inline reason?: string) {
        _notes |= note;
    }

    fn ConvCache_nukeConverts(inline reason: string) {
        TRACE("ConvCache_nukeConverts: " ~ reason);
        _conv_cache.clear();
    }

    fn ConvCache_nukeUsings(inline reason: string) {
        TRACE("ConvCache_nukeUsings: " ~ reason);
        _conv_cache.remove(ValueType());
    }

    fn _Scope_import__forceCopy(modid: i32, private!?: bool): void {
        lax let s = ctx.modules[modid].out.solve.scope;

        lax let usings0     = _scope.usings.len;
        lax let converts0   = _scope.converts.len;

        inline fn pub_or_priv !T(what: T[..], pub_count: int) {
            lax let N = what.len;
            return what[private ? pub_count : 0
                     .. private ? N : pub_count];
        }

        _scope.items        ~= pub_or_priv(s.items, s.pub_items);
        _scope.converts     ~= pub_or_priv(s.converts, s.pub_converts);
        _scope.implicits    ~= pub_or_priv(s.implicits, s.pub_implicits);
        _scope.globals      ~= pub_or_priv(s.globals, s.pub_globals);

        lax let converts1 = _scope.converts.len;
        lax let usings1 = _scope.usings.len;
        if (usings1 != usings0)
            ConvCache_nukeUsings("[import.pub]: usings0(" ~ usings0 ~ ") usings1(" ~ usings1 ~ ")");
    }

    fn Scope_import(modid: i32) {
        _scope.imports.each(_ss.imports): |m|
            if (m == modid)
                return false;

        modid || BUG("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
        return true;
    }

    fn isLocal(target: Target) {
        return !!target.locid;
    }

    fn parent(target: Target) {
        target.isLocal || BUG("Using .parent on a non-local");
        return Target(:target.modid, :target.globid, locid: 0);
    }

    fn localfn(index: i32) {
        return Target(:module.modid, globid: index, locid: 0);
    }

    fn isFnOrType(h: Helpers): bool
        !!(h.mask & (HM_Function | HM_UserType));

    using fn GET(target: Target) {
        lax let modid   = target.modid;
        lax let globid  = target.globid;
        lax let locid   = target.locid;

        if (locid) {
            if (SELF_TEST && _scope.extended.len <= globid)
                BUG("Invalid local target -modid.");

            lax let ext = _scope.extended[globid];
            return ext.args_n_locals[ext.indexOfLocal(:locid)];
        }

        return _scope.overloads[globid - 1];
    }

    fn BUG(token: TokenIdx, reason: string) {
        _here = token;
        BUG(reason);
    }

    fn GET_mut(target: Target) {
        lax let globid  = target.globid;
        lax let locid   = target.locid;

        return _scope.overloads[globid - 1];
    }

    fn EXT_mut(target: Target) {
        lax let globid  = target.globid;

        return _scope.extended[globid];
    }

    fn EPH_mut(index: i32) {
        return _ephemeral.ensure(exists: index);
    }

    fn EPH_mut(target: Target) {
        return EPH_mut(target.globid);
    }

    fn localOf(target: Target) {
        if (target.isLocal)
            return target.globid;

        return target.local_of;
    }

    fn solved_set(target: Target, node: SolvedNode)
        target.GET_mut.solved = node;

    fn SolvedNode(kind:       Kind, type:       Type, flags?:     Flags, value?:     string, items?:     SolvedNode[], target?:    Target, helpers?:   Helpers) {
        return SolvedNode(:kind, :value, :flags | (SELF_TEST && F_TEST_painted), :items, :type, :target, token: _here, :helpers);
    }

    fn Lifetime_fromNative(sig: Node[..], args: SolvedNode[..], actual: Type): Lifetime {
        lax mut res: Type;

        sig.len + FN_ARGS_BACK == args.len || BUG("sig.len != args.len");
        for (mut i = 0; i < args.len; i++) {
            if (sig[i].flags & F_REF) {
                res && fail("Multiple ref arguments, cannot infer what the returned reference points to.");

                res = args[i].target.type;
                res.lifetime || fail("Missing ref argument lifetime.");
            }
        }

        res.lifetime || fail("No ref arguments, cannot infer what the returned reference points to.");

        res.lifetime.Lifetime_if_only(|locid| !!locid) || res.is_zst || fail("Infered a non-single-local __native lifetime: " ~ res.lifetime);

        if (!isAssignable(host: actual, res)) {
            lax let flatCount = actual.getFlatCount();

            return Lifetime_makeShared(res.lifetime, :flatCount);
        }

        return res.lifetime;
    }

    fn TEST_Lifetime(lifetime: Lifetime, lax type!: Type, lax tempsOK!?: bool, lax argPositionsOK!?: bool): Lifetime {
        return lifetime;
    }

    lax fn TEST_varLifetime(lax lifetime: Lifetime, lax staticOK!?: bool, lax locid!expect?: i32) =
    {
        if (SELF_TEST && !lifetime.Lifetime_if_only(|locid, isStatic|
                    locid && (!expect || locid == expect)
                        || isStatic && staticOK)) {
            BUG("Bad local lifetime: " ~ lifetime);
        }
    }

    fn Lifetime_fromBinding(target: Target, flatCount: i32): Lifetime {
        target.locid || target.modid == module.modid || BUG("not from this module");

        if (TODO_FIX_static_ZSTs && !flatCount)
            return Lifetime_static_moveable;

        lax let locid = target.locid;
        if (locid)
            return Lifetime_from(:locid, :flatCount);

        return Lifetime_static_immoveable;
    }

    fn Lifetime_replaceArgsAtCallsite(target: Target, argNodes: SolvedNode[..]): Lifetime {
        return target.type.lifetime.Lifetime_process(each: |isStatic, isTemp, locid, argidx, paths, continue_keep, continue_replace|
            {
                if (isStatic)
                    continue_keep();

                if (isTemp || locid)
                    BUG("Lifetime_replaceArgsAtCallsite: Found a temp or locid.");

                lax let argNode = argNodes[argidx];
                lax let argLt   = argNode.type.is_ref
                    ? argNode.type.lifetime
                    : Lifetime_temporary();

                continue_replace(Lifetime_op_join(argLt, :paths));
            });
    }

    fn autoshadow(ref shadows: bool, local_of: i32, id: string) {
        if (!shadows && local_of && shouldAutoshadow(id))
            shadows = true;
    }

    fn shouldAutoshadow(id: string) {
        _scope.items.each(_ss.items): |item, i|
            if (i >= _root_scope.items_len)
                if (item.id == id)
                    return false;

        return true;
    }

    lax fn Binding(lax id: string,lax mut type: Type,lax flags!: Flags,lax asserts!: DeclAsserts,lax ref shadows!: bool,lax asArgument!: bool) {
        return [];
        lax mut name        = id;
        lax let local_of    = _current_fn.target.globid;

        if (_root_scope) {
            autoshadow(:shadows, :local_of, :id);
        }

        lax let status = (type.quals & q_rx_resize && SS_TODO_FIX_was_rx_resize);

        lax let target = Scope_create(_scope, nest: local_of, :asArgument, kind: "var", :name, :flags, :asserts, :status);

        if (SELF_TEST && flags & F_REF) {
            type.is_ref || BUG("Binding(" ~ flags ~ " " ~ name ~ ") !type.is_ref:\n\n\t\t" ~ explainType(type));
            !(flags & F_MUT) || type.is_mutref || BUG("Binding(" ~ flags ~ " " ~ name ~ ") !type.is_mutref:\n\n\t\t" ~ explainType(type, lt: true));
        }

        lax ref overload = GET_mut(target);
        {
            lax let lifetime = Lifetime_fromBinding(target, type.getFlatCount());

            type.lifetime = Lifetime();

            overload.type = flags & F_MUT
                ? add_mutref(type, lifetime)
                : add_ref   (type, lifetime);

            if (overload.type.is_zeroes && ~flags & F_LAX)
                if (flags & (F_TEMPLATE | F_REF | F_MUT) != F_TEMPLATE)
                    fail(target ~ " needs a tighter type annotation, inferred type is " ~ explainTypeName(overload.type) ~ "."
                        ~ makeItLaxIfIntentional());
        }

        return target;
    }

    fn makeItLaxIfIntentional() {
        return " Make it " ~ "lax".qKW ~ " if this is intentional.";
    }

    fn createTemplate(node: Node): Template {
        return Template(node, imports:   !_current_fn && _scope.imports);
    }

    fn solveDefinit(type: Type): SolvedNode {
        return SolvedNode(kind: "definit", :type);
    }

    lax fn getModule(lax modid!: i32) {
        return [];
        return ctx.modules[modid];
    }

    lax fn trimmedName(lax shadow module: Module) {
        return [];
        lax let fname = module.fname;

        lax mut start = 0;
        lax mut end   = fname.len;

        return fname[start .. end];
    }

    fn explainTypeDiff(a: Type, b: Type, sep: string) {
        return explainType(a, diff: b) ~ sep
             ~ explainType(b, diff: a);
    }

    fn explainNotMutref(what: Type) {
        fn tryExplainWell(shadow what: Type): string {
            what.lifetime.Lifetime_each: |locid|
            {
                if (!locid)
                    continue;

                lax let t       = nested(locid);
                lax let o       = GET(t);
                lax let init    = o.solved.items.if(exists: LET_INIT);

                if (o.type.is_mutref)
                    continue;

                lax let reason  =
                    o.flags & (F_CONST|F_REF) == F_REF
                        && init && tryExplainWell(init)
                            || "not mutable.";

                return "a ref to "  ~ t.explainWhichFn(fmt: FullContext)
                                    ~ "\n\t    ... which is " ~ reason;
            };

            return "";
        }

        return "expects a mutref, got " ~ (tryExplainWell(what) || explainType(what, lt: true));
    }

    fn explainNotAssignable(host: Type, guest: Type, cannot_retype!?: SolvedNode) {
        if (host.is_mutref) {
            if (!guest.is_mutref)
                return explainNotMutref(guest);
        }

        lax let hint = cannot_retype && tryExplainCannotRetype(cannot_retype, expect: host);

        return "expects " ~ explainTypeDiff(host, guest, sep: ", got ") ~ hint;
    }

    fn str(n: SolvedNode) {
        lax mut src = n.kind.str.qKW;

        if (n.kind == "call" || n.kind == "let" || n.kind == "letdef")
            src ~= "(" ~ n.target ~ ")";
        else if (n.value)
            src ~= "(" ~ n.value.qID ~ ")";

        if (n.type)
            src ~= " -> " ~ explainType(n.type);

        return src;
    }

    fn solveTypeCast(node: Node): SolvedNode {
        lax let left   = node.items[0];
        lax let right  = node.items[1];

        lax let expect = evalTypeAnnot(right);
        lax mut actual = solveNode(left, expect);

        convertIfNeeded(:actual, :expect, "Cannot convert: ");
        return actual;
    }

    fn solveTypeAssert(node: Node): SolvedNode {
        lax mut typeParams0 = steal(_typeParams);
        defer swap(_typeParams, typeParams0);

        return createBool(evalTypePattern(node));
    }

    fn reorderByNumUsings(lax ref reorder: Reorder, host_args: Argument[], num_args: i32, num_usings!: i32) {
        reorder.map.clear();

        if (num_usings) {
            for (mut i = 0; i < host_args.len; i++) {
                lax let x = i - num_usings;
                reorder.map.push(x >= 0 && x < num_args ? x : -1);
            }
        }

        reorder.applicable = !!reorder.map;
    }

    fn reorderByArgIDs(lax ref reorder: Reorder, names: string[], mut optional: ::BitSet, host_args: Argument[], num_usings!: i32): bool {
        reorder.applicable = true;
        reorder.map.clear();

        lax mut used                = 0;
        lax mut offset              = 0;
        lax mut usings_left         = num_usings;

        lax mut ha_required         = 0;
        lax mut ha_bound_optional   = 0;

        for (mut i = 0; i < host_args.len; i++) {
            lax let host_arg = host_args[i];

            if (host_arg.flags & F_INJECTED)
                continue;

            lax mut idx = names.find(host_arg.name);
            if (idx < 0) {
                if (usings_left > 0) {
                    usings_left--;
                }
                else
                {
                    for (shadow mut i = offset; i < names.len; i++) {
                        offset++;
                        if (!names[i]) {
                            idx = i;
                            break;
                        }
                    }
                }
            }
            else
            {
                used++;
                optional.remove(idx);
            }

            reorder.map.push(idx);

            if !(host_arg.default || host_arg.flags & F_IMPLICIT)
                ha_required++;
            else if (idx >= 0)
                ha_bound_optional++;
        }

        if (ha_bound_optional + ha_required > names.len + num_usings)
            return false;

        usings_left && BUG("reorderByArgIDs: usings_left != 0");

        if (used != names.len) {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used + optional.popcount != names.len)
                return false;
        }

        {
            lax mut trailing_misses     = 0;
            lax mut non_trailing_misses = 0;
            for (mut i = reorder.map.len; i --> 0; ) {
                if (reorder.map[i] >= 0) {
                    for (; i --> 0; )
                        if (reorder.map[i] < 0)
                            non_trailing_misses++;

                    break;
                }

                trailing_misses++;
            }

            lax let trailing_usings = (num_usings - non_trailing_misses).max(0);

            if (trailing_misses > trailing_usings)
                reorder.map.shrink(reorder.map.len - (trailing_misses - trailing_usings));
        }

        if (reorder.map.len != names.len)
            return true;

        for (mut i = 0; i < reorder.map.len; i++)
            if (reorder.map[i] != i)
                return true;

        reorder.clear();
        return true;
    }

    noinline fn ERRMSG_findUnmatchedArgName(reorder: Reorder, names: string[], host_args: Argument[], target?: Target) {
        lax mut used:       ::BitSet;
        lax mut matched:    ::BitSet;

        for (mut i = 0; i < reorder.map.len; i++) {
            lax let pos = reorder.map[i];
            if (pos >= 0) {
                used.add(pos);
                matched.add(i);
            }
        }

        lax let for = target && " for " ~ target.str;

        names.each: |name, i|
        {
            if (used.has(i))
                continue;

            lax mut count = 0;
            lax mut first = names.len;

            names.each: |n, shadow i|
                if (n == name)
                    if (!count++)
                        first = i;

            if (first < i)
                return "Duplicate :named arguments" ~ for ~ ": " ~ "arg".qBAD_KW ~ " " ~ names[i].qBAD ~ " explicitly provided " ~ count ~ " times.";

            return "Named :argument mismatch" ~ for ~ ": no " ~ "arg".qBAD_KW ~ " " ~ names[i].qBAD ~ ".";
        }

        host_args.each: |host_arg, i|
            if (!host_arg.default && !matched.has(i))
                return (host_arg.flags & F_TYPENAME
                         ? "Missing type argument"
                         : "Missing required argument") ~ for ~ ": " ~ host_arg;

        return "Named :argument mismatch" ~ for ~ ": BUG failing to explain what's wrong.";
    }

    lax fn ERRMSG_optionalArgumentAmbiguity(lax host_args: Argument[],lax reorder: Reorder,lax names: string[]) {
        return [];
        lax mut error = "Optional argument ambiguity:";

        host_args.each: |host_arg, i| {
            lax let callsiteIndex = reorder.map.if(exists: i, else: -1);
            if (callsiteIndex < 0) {
                error ~= "\n\n\t\t" ~ (host_arg.default ? "Optional callee " : "Callee ")
                                    ~ host_arg ~ " not provided"
                                    ~ (host_arg.default && " and will be defaulted") ~ ".";
                break;
            }
        }

        names.each: |name| {
            if (name && !host_args.some(|a| a.name == name)) {
                break;
            }
        }

        return error ~= "\n\n\t\tCannot distinguish from a typo."
                        ~ "\n\t\tEnsure all optional arguments on either side match to resolve this error.";
    }

    inline fn findRestStart(ext: Extended) {
        return ext.rest_1b ? ext.rest_1b.int - 1 : ext.args.len;
    }

    lax fn collectNamedArgs(lax args: Node[..] or SolvedNode[..],lax ref minArity: int) {
        return [];

        using mut ret: NamedArgs;

        lax mut some = false;

        some || BUG("collectNamedArgs: no named arguments here");
        return ret;
    }

    lax fn applyRetype(lax ref node: SolvedNode,lax retype: Type) {
        return [];
        if (node.kind == "if") {
            applyRetype(node.items[1], retype);
            applyRetype(node.items[2], retype);
        }
        else if (node.kind == "block" || node.kind == "argid") {
            node.helpers.mask & HM_LabelUsed && BUG("Trying to retype a labelled block, we cant do this still.");

            applyRetype(node.items.last, retype);
        }

        node.type = retype;
    }

    fn tryExplainCannotRetype(node: SolvedNode, expect: Type): string {
        lax mut hint: string;

        lax let s = expect.tryLookupUserType();
        if ((s.kind == "enum" || s.kind == "flags")
                && isAssignable(host: t_string_literal, node.type)) {
            lax mut ok = true;

            struct Suggestion {
                dist:   int;
                target: Target;
            };

            lax mut suggestions:    Suggestion[];
            lax mut token:          TokenIdx;

            lax fn visit(lax n: SolvedNode) {
                return [];
                if (!ok)
                    return;

                lax let k = n.kind;
                if (k == "str") {
                    if (token)
                        return;

                    if (tryRetyping(n, :expect).is_primitive)
                        return;

                    for (mut i = 0; i < s.items.len; i++) {
                        lax let member = s.items[i];
                        lax let dist = ::levenshtein(n.value, member.id);
                        if (dist < min(5, n.value.len >> 1))
                            suggestions ~= Suggestion(:dist, :member.target);
                    }

                    token = n.token;
                }
                else if (k == "if" || k == "or" || k == "and" || k == "block") {
                    lax let start = k == "if" ? 1
                              : k == "or" ? 0
                              : n.items.len - 1;

                    for (mut i = start; i < n.items.len; i++)
                        visit(n.items[i]);
                }
                else
                {
                    ok = false;
                }
            }

            visit(node);

            if (ok && token && suggestions) {
                hint ~= "\n\n\t\tCannot retype the string literal at " ~ token.addr_and_snippet;
                hint ~= "\n\t\tDid you mean:\n";

                suggestions.each: |.target|
                    hint ~= "\n\t\t" ~ target.explainWhichFn();
            }
        }

        return hint;
    }

    fn explainWhichFn(mut t: Target, conversions?: Target[][], backtrack!?: string, fmt = NoContext) {
        lax mut result = t.str;

        if (t.flags & F_INJECTED) {
            result ~= "\n";
        }
        else
        {
            lax let t0 = t.template.node.token;
            lax let t1 = t.solved.token;

            if (t0 || t1)
                result ~= " at " ~ (t0 || t1).addr_and_snippet(:fmt, :backtrack);
            if (t0 && t1 && t0 != t1)
                result ~= "\n\t    ... via " ~ t1.addr_and_snippet(:fmt, :backtrack);
        }

        return result;
    }

    fn explainConversion(shadow path: Target[..], prefix!?: string) {
        lax mut res = "";
        for (mut i = 0; i < path.len; i++) {
            res ~= "\t    ";
            if (!i && prefix) res ~= prefix;
            res ~= "using".qKW ~ " ";
            res ~= path[i].explainWhichFn(backtrack: "using");
        }

        return res;
    }

    fn make_field_reference(from: Type, field: Overload, TODO_FIX_useTemporaryLifetime!?: bool) {
        using let _ = field_unpackOffset(field);

        lax let quals = !from.is_zeroes && from.quals;

        return make_field_reference(to:         field.type, quals:      quals, lifetime:   TODO_FIX_useTemporaryLifetime
                ? Lifetime_temporary
                : TODO_FIX_static_ZSTs && !memberFlatCount
                    ? Lifetime_static_moveable
                    : from.lifetime, :memberFlatCount, :memberFlatOffset);
    }

    fn conversionTailType(from: Type, conversions: Target[..]) {
        for (mut i = conversions.len; i --> 0; ) {
            lax let lastConv = conversions[i];
            if (lastConv.kind == "field")
                return make_field_reference(from: conversionTailType(:from, conversions[.. i]), field: lastConv, TODO_FIX_useTemporaryLifetime: true);

            return lastConv.type;
        }

        return from;
    }

    fn exploreConversions(type: ValueType) {
        lax mut inserted = false;
        lax ref cc = _conv_cache.ref(type, init: || { inserted = true; [] });
        if (!inserted) {
            return cc;
        }

        return _conv_cache.ref(type) = doExploreConversions(type, init: cc);
    }

    lax fn doExploreConversions(lax startType: ValueType,lax ref init: ConvCache_ColsAndBakes) {
        return [];
        PROFILE(.ExploreConversions);

        TRACE_BRACKET("doExploreConversions startType(" ~ explainType(startType) ~ ")");

        lax mut result: ConvCache_ColsAndBakes;

        lax let conv_safety0 = _current_fn.conv_safety++;
        defer _current_fn.conv_safety = conv_safety0;

        lax mut TODO_FIX_reorder: Reorder;
        lax mut TODO_FIX_conversions: Target[][];

        lax mut path: Target[];
        lax mut must_see: i32[];

        fn descend(from: Type, nullary!: bool, isUserType!: bool) {
            fn foreach(target: Target, i!at_index: i32) {
                if (target.status & (SS_LAZY | SS_FINALIZED) == SS_LAZY) {
                    TRACE("doExploreConversions: skipping [!SS_FINALIZED] " ~ target);
                    target.GET_mut.status |= SS_OBSERVED_BY_CONV_CACHE;

                    return;
                }

                lax mut arg0type0 = TODO_FIX_convert_args[0].type;

                if       (!nullary)
                    TODO_FIX_convert_args[0].type = from;
                defer if (!nullary)
                    TODO_FIX_convert_args[0].type = arg0type0;

                lax mut error: string;
                lax mut candidate: Target;
            }

            if (nullary) {
                for (mut i = 0; i < _scope.usings.len; i++)
                    foreach(_scope.usings[i], :i);
            }
            else
            {
                if (isUserType) {
                    lax let inner = lookupUserType(from).converts;

                    for (mut i = 0; i < inner.len; i++)
                        foreach(inner[i], i: -1);
                }

                for (mut i = 0; i < _scope.converts.len; i++)
                    foreach(_scope.converts[i], :i);
            }
        }

        descend(from:       startType, nullary:   !startType, isUserType: startType && startType.isUserType);

        lax mut seen: flat::Set(UserTypeCanon);

        for (mut i = startType && -1; i < result.types.len; i++) {
            lax let t = i < 0 ? startType.vtype : result.types[i];

            shadow let t = tryParseUserTypeCanon(t);
        }

        return result;
    }

    fn tryConvert(expect: Type or Node, actual?: Type, retype?: SolvedNode): Target[] {
        type Expect = typeof(expect);

        PROFILE(Expect -> Type
            ? .TryConvertExact
            : .TryConvertGeneric);

        lax mut match: Target[];

        lax let cc = exploreConversions(actual);

        :NEXT_TYPE

        return match;
    }

    fn convCache_considerFieldItems(type: Type, flags: Flags) {
        return [];
    }

    fn explainBadCallArguments(id: string, targets: Target[..], args: SolvedNode[..]) {
        return (targets.len == 1 ? targets[0].str : id.qID)
             ~ (args && " with args (" ~ args.map(.explainType).join(", ") ~ ")");
    }

    fn matchCall(misc_scope: Scope, local_scope: bool, id: string, ref args: SolvedNode[], lax ref reorder: Reorder, lax ref conversions: Target[][], flags: Flags, targets: Target[..]): Target {
        lax mut error: string;

        PROFILE(.TryMatch_SolveCall);

        lax let ret = tryMatchCall(:misc_scope, :local_scope, :id, :args, :reorder, :conversions, :flags, :targets, :error);
        if (ret)
            return ret;

        error = "Bad call to " ~ explainBadCallArguments(:id, :targets, :args) ~ ": ";

        lax let debug = tryMatchCall(:misc_scope, :local_scope, :id, :args, :reorder, :conversions, :flags, :targets, :error);
        if (debug)
            BUG("Did match on second pass: " ~ debug);

        fail(error);
    }

    fn solveNode(node: Node, type?: Type): SolvedNode {
        HERE(node);

        lax let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "argid")       return solveArgID(node, :type);

        if (k == "let")         return solveLet(node, asArgument: false);
        if (k == "call")        return solveCallDirect(node);
        if (k == "arrlit")      return solveArrlit(node, type);

        if (k == "not")         return solveNot(node);
        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "and")         return solveAnd(node, type);

        if (k == "loop")        return solveLoop(node);
        if (k == "return")      return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveReal(node, type);
        if (k == "str")         return solveString(node, type);
        if (k == "char")        return solveChar(node);
        if (k == "bool")        return solveBool(:node.value);

        if (k == "definit")     return solveDefinit(type);

        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typecast")    return solveTypeCast(node);
        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "typeparam")   return solveTypeParam(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        if (k == "forfieldsof") return solveForFieldsOf(node);
        if (k == "pragma")      return executeCompilerPragma(node);
        if (k == "empty")       return createEmpty();
        if (k == "unwrap")      return createUnwrap();
        if (k == "call_indir")  return solveCallIndirect(node);

        if (unorderedClassify(k))
            return solveDeclExpr(node);

        return BUG("solve: Unexpected " ~ k);
    }

    lax fn isTypeDecl(lax kind: Kind) {
        return [];
        return kind == "struct"    || kind == "union"
            || kind == "primitive" || kind == "enum"  || kind == "flags";
    }

    fn unorderedClassify(kind: Kind): i32 {
        if (kind == "fn")
            return 1;

        if (kind.isTypeDecl)
            return 10;

        return 0;
    }

    fn unorderedPrep_A(node: Node, TODO_FIX_useSpecPath!?: bool): SolvedNode {
        lax let kind = node.kind;

        if (kind == "fn")
            return uPrepFn_A(node);

        if (kind.isTypeDecl)
            return uPrepStruct(node, :TODO_FIX_useSpecPath);

        BUG("TODO: unorderedPrep_A(" ~ node.kind ~ ").");
    }

    fn unorderedPrep_B(nodes: Node[..], results: SolvedNode[..], unorderedClass: i32) {
        lax mut hasSnap = false;
        lax mut lastSnap: ScopeMemo;

        for (mut i = nodes.len; i --> 0; ) {
            lax let target  = results[i].target;
            lax ref eph     = target.EPH_mut;
        }
    }

    fn _current_fn_eachArg_FWD(visit) {
        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++) {
            lax let t = _current_fn.items[i].target;
            if (t && t.isArg.TEST_true)
                visit(t, position?: i);
        }
    }

    fn types_mayAlias(a: ValueType, b: ValueType) {
        a.if_sliceable: |sliceT|
            if (sliceT.is_reinterpretable)
                return true;

        b.if_sliceable: |sliceT|
            if (sliceT.is_reinterpretable)
                return true;

        lax let a_non_triv_mask = getShape(a).non_triv_mask;
        if (!a_non_triv_mask)
            return false;

        lax let b_non_triv_mask = getShape(b).non_triv_mask;
        if (!b_non_triv_mask)
            return false;

        lax let inter = a_non_triv_mask & b_non_triv_mask;

        return false;
    }

    fn type_mayPointInto(host: ValueType, guest: ValueType) {
        if (guest.is_reinterpretable || guest.if_sliceable(.is_reinterpretable))
            return !!(host.quals & q_USAGE);

        lax let guest_non_triv_mask = getShape(guest).non_triv_mask;
        if (!guest_non_triv_mask)
            return false;

        lax let host_non_triv_mask = getShape(host).non_triv_mask;
        if (host_non_triv_mask & guest_non_triv_mask
                              != guest_non_triv_mask)
            return false;

        return SLOW_type_maybeInside(:host, :guest, :guest_non_triv_mask);
    }

    fn SLOW_type_maybeInside(host!: ValueType, guest!: ValueType, guest_non_triv_mask!: u64) {
        lax mut seen: flat::Set(UserTypeCanon);

        fn type_maybeInside(shadow host: ValueType, usage?: <Usage>, flatCount?: <FlatCount>) {
            host.if_sliceable: |host_sliceT|
                return type_maybeInside(host_sliceT);

            if (host.isUserType) {
                lax let scp = parseUserTypeCanon(host.canon);
                lax let s   = lookupUserType(scp);

                if (!(Usage -> []) || seen.add(scp)) {
                    for (mut i = 0; i < s.items.len; i++) {
                        lax let f           = s.items[i].target.GET;
                        lax let fieldType   = f.type;

                        if (Usage -> []) {
                            if (type_maybeInside(host: fieldType))
                                return true;
                        }
                    }
                }
            }

            return false;
        }

        lax let usage = host.usage;
        if (usage == getMaxUsage(getFlatCount(host)))
            return type_maybeInside(:host);
        else
            return type_maybeInside(:host, :usage);
    }

    fn validateCOW(item: SolvedNode, here! = _here, callee?: Target, host_arg?: Argument, calleeReturnDiscarded!?: bool) {
        PROFILE(.ValidateCOW);

        fn eachCOWInside(visit) {
            if (callee) {
                lax let callee_cows = callee.cows_inside;
                for (shadow mut i = 0; i < callee_cows.len; i++) {
                    lax let callee_cow = callee_cows[i];

                    if (calleeReturnDiscarded && !callee_cow.mayEscapeVia)
                        continue;

                    if (callee_cow.argTarget == host_arg.target.locid) {
                        visit(:callee_cow.vtype, token?: callee_cow.token, uncaughtThrowOnly?:
                                callee_cow.exitPaths == XP_NoReturn
                                    && !_current_fn.TODO_FIX_catches);
                    }
                }
            }
            else
            {
                visit(:item.type.vtype, token?: _here, uncaughtThrowOnly?: false);
            }
        }

        fn cannotCOW_climbParents(lifetime: Lifetime, expected_refs!?: i32[]) {
            lifetime.Lifetime_each: |locid, region, paths|
            {
                lax let t = nested(locid);
                if (SELF_TEST)
                    t.kind == "var" || BUG("cannotCOW_climbParents found a non-var: " ~ t);

                cannotCOW_climbParents(Lifetime_op_join(Lifetime_climbType(t).lifetime, :paths), :expected_refs ~ locid);

                cannotCOW_descendChildren(locid, region, :expected_refs);

                lax ref flow = _current_fn.flow;
                if (t.isArg) {
                    lax let arg_targets = flow.arg_targets;
                    for (shadow mut i = 0; i < arg_targets.len; i++) {
                        if (!t || t == locid)
                            continue;

                        lax let o = GET(nested(t));
                        if (!o.solved.type.is_mutref)
                            continue;

                        if (flow.at_hard_risk.if(exists: t).has(locid))
                            continue;

                        lax fn needsHardRisk(lax shadow index: i32) {
                            return [];
                            eachLiveChildMutref(index): |child| {
                                lax let reason = needsHardRisk(child);
                                eachCOWInside: |vtype, uncaughtThrowOnly| {
                                    if (type_mayPointInto(host: vtype, o.type))
                                        return index;
                                }
                            }

                            return 0;
                        }

                        lax let reason = needsHardRisk(t);
                        if (reason) {
                            makeNote(N_COWRestrict, nested(locid) ~ " at risk from " ~ nested(t) ~ " via " ~ nested(reason));

                            flow.at_soft_risk.ensure(exists: t).add(locid);

                            fn TODO_FIX_slicesAgain() {
                                return nested(t).type.is_sliceable;
                            }

                            if (reason != t || TODO_FIX_slicesAgain)
                                flow.at_hard_risk.ensure(exists: t).add(locid);
                        }
                    }

                    eachCOWInside: |vtype, token, uncaughtThrowOnly|
                    {
                        lax let mayEscapeVia = _current_fn.postdom.mayEscapeVia;
                        lax let exitPaths    =
                            uncaughtThrowOnly
                                ? XP_NoReturn
                                : _current_fn.postdom.exitPaths || BUG("No current_fn.exitPaths");

                        lax ref my_cows = _current_fn.events.cows_inside;

                        my_cows ~= COWInside(:vtype, :token, argTarget: locid, :mayEscapeVia, :exitPaths);
                    }
                }
            }
        }

        lax fn cannotCOW_descendChildren(lax parent_locid: i32,lax parent_region: Lifetime,lax expected_refs!: i32[]) {
            return [];
            parent_locid.eachLiveChildMutref: |child, t, o|
            {
                lax let inter = _current_fn.flow.rg_parents.if(exists: child).Lifetime_inter(parent_region);
                if (_current_fn.ever_written.has(child)) {
                    eachCOWInside: |vtype, token|
                    {
                        if (type_mayPointInto(host: vtype, o.type)) {
                            lax let cow_inside = token;

                            lax mut err = !callee
                                ? "A copy is needed, but "
                                : host_arg ~ " to " ~ callee ~ " is indirectly copied from:\n"
                                    ~ qSTACK_cow_inside(callee, callee.solved, :host_arg, :cow_inside)
                                    ~ "\n\t... but "

                            err ~= "COW will break due to pre-existing mutref: "
                                    ~ explainWhichFn(t, fmt: FullContext);

                            err ~= "\n\tBoth refer to: "
                                    ~ explainWhichFn(nested(parent_locid), fmt: FullContext);

                            _here = here;
                            fail(err);
                        }
                    }
                }

                cannotCOW_descendChildren(child, inter, :expected_refs);
            }
        }

        cannotCOW_climbParents(item.type.lifetime);
    }

    lax fn propagateType(lax ref node: SolvedNode,lax slot: Type,lax relax_mask!: Quals,lax kills!?: Helpers) {
        return [];
        lax let k = node.kind;

        lax let here0   = _here;
        _here       = node.token;
        inline fn PASS_MoveOnLastUse    = relax_mask == RELAX_all;
        inline fn PASS_MaybeCopyOrMove  = relax_mask == RELAX_all;

        inline fn UsedAgain(locid!: i32, reason: UsedAgainReason)
            UsedAgain(locid.sign_rotate << 8 | reason.u32);

        fn trackUsedAgain(lt: Lifetime) {
            lax mut just_added: LocidSet;

            fn descend(shadow lt: Lifetime, ref bitset: LocidSet): UsedAgain {
                fn descend(t: Target): UsedAgain {
                    lax let locid = t.locid;
                    if (!bitset.add(locid))
                        return UsedAgain(:locid, "UsedAgain");

                    just_added.add(locid);

                    lax let o = GET(t);
                    lax let isArg = t.isArg;
                    lax let letNode = o.solved;
                    if (letNode.is_ref) {
                        if (isArg)
                            return !o.isMutVal && UsedAgain(:locid, "ArgReference");

                        lax let usedAgain = descend(Lifetime_climbType(t).lifetime, :bitset);
                        if (usedAgain)
                            return usedAgain;
                    }
                    else if (isArg) {
                        BUG("trackUsedAgain/descend: o.isArg but !o.solved.is_ref");
                    }

                    return locid < _current_fn.write_loop_start
                        && UsedAgain(:locid, "UsedInALoop");
                }

                lax mut some: UsedAgain;
                lt.Lifetime_each: |locid, isAlwaysMoveable, lax isStatic|
                {
                    if !(locid) {
                        if (SELF_TEST)
                            isStatic || BUG("trackUsedAgain/descend: non-static non-local");

                        some = UsedAgain(:locid, "StaticReference");
                    }
                    else if !(just_added.has(locid)) {
                        lax let usedAgain = descend(nested(locid));
                        if (usedAgain && !some)
                            some = usedAgain;
                    }
                }

                return some;
            }

            return PASS_MoveOnLastUse
                 ? descend(:lt, _current_fn.postdom.used_again)
                 : UsedAgain(locid: 0, "WrongPass");
        }

        fn callarg_trackWrites(lt: Lifetime, usage: Quals) {
            lt.Lifetime_each: |locid, paths|
            {
                if (!locid)
                    continue;

                if (_current_fn.ever_written.add(locid, usage)) {
                    lax let t = nested(locid);
                    lax let o = GET(t);

                    lax let asserts = o.asserts;
                    {
                        lax let target          = _current_fn.out.target;
                        lax mut fail_fn         = target;
                        lax mut fail_arg_token  = t.solved.token;
                        lax mut backtrack_token = _current_fn.out.token;

                        lax let cid = hacks::tryParseClosureID(id: o.name);
                        if (cid.target.isLocal) {
                            fail_fn         = cid.target.parent;
                            fail_arg_token  = cid.target.solved.token;
                            backtrack_token = fail_fn.solved.token;
                        }

                        if (asserts & A_PURE)
                            fail(backtrack: "pure", fail_fn ~ " is not pure, writes to " ~ t ~ ":\n"
                                ~ qSTACK_local(:target, :locid, :node), token: backtrack_token, highlight: [ fail_arg_token ]);

                        if (asserts & A_PURE_CTX && o.flags & F_INJECTED)
                            fail(backtrack: "purectx", fail_fn ~ " is not purectx, writes to " ~ t ~ ":\n"
                                ~ qSTACK_local(:target, :locid, :node), token: backtrack_token, highlight: [ fail_arg_token ]);
                    }

                    if (SELF_TEST)
                        t.type.usage & usage == usage || BUG("callarg_trackWrites: written_to(" ~ usage ~ ") quals(" ~ t.type.usage ~ ") " ~ t);

                    if !(o.flags & F_VAL)
                        callarg_trackWrites(Lifetime_climbType(t).lifetime, usage);

                    if (t.isArg)
                        _current_fn.postdom.mayEscapeVia.add(:locid);
                }
            }
        }

        lax fn Breakable_begin(lax loop_PREVITER?: bool) {
            return [];
            if (node.helpers)
                node.helpers.postdom = _current_fn.postdom;

            if (loop_PREVITER && PASS_MaybeCopyOrMove)
                _current_fn.postdom.branch(node.helpers.loop_PREVITER);
        }

        fn Breakable_end(loop_PREVITER?: bool) {
            if (loop_PREVITER && !PASS_MaybeCopyOrMove) {
                lax ref previter    = node.helpers.loop_PREVITER;
                previter        = _current_fn.postdom;

                lax let loop_start  = node.helpers.locals_start;

                for (fieldname i: PostdomSnap)
                    if !(typeof(previter.i).is::primitive)
                        previter.i.clear(start: loop_start);
            }

            lax let ext = EXT(t);

            if (ext.template.node.asserts & A_NODISCARD)
                fail("Return value of " ~ t ~ ": "
                    ~ "nodiscard".qBAD ~ " "
                    ~ explainType(t.type) ~ " is getting discarded here.");

            if (t.fx_mask & Fx_NotDeadCode)
                return false;

            lax let host_args = ext.args;
            for (mut i = 0; i < host_args.len; i++)
                if (host_args[i].written_to)
                    return false;

            return true;
        }

        lax let canDiscard      = slot.isIrrelevant;
        lax let relaxed_quals   = node.type.try_relax(:slot, :relax_mask);

        inline fn discardType(shadow ref node: SolvedNode, shadow relax_mask!: Quals, shadow kills!?: Helpers) {
            return propagateType(node, t_irrelevant, :relax_mask, :kills);
        }

        fn discardIntoBlock() {
            node = createBlock(:node.items, slot);

            return propagateType(:slot, node, :relax_mask);
        }

        lax fn trackVarUsage(lax locid: i32,lax shadow slot: Type) {
            return [];
            PROFILE(.TrackVarUsage);

            if (SELF_TEST) {
                lax let t = nested(locid);
                TEST_unusedButCopied("trackVarUsage " ~ t, slot);

                if (slot.lifetime.hasTemporary)
                    BUG(t ~ ", trackVarUsage: slot is ref2temp: " ~ slot.explainType(lt: true));

                usage = slot;
                return true;
            }
            else
            {
                usage = type_tryIntersect(usage, slot) || BUG(nested(locid) ~ ": Usage intersection failure: "
                                  ~ explainTypeDiff(usage, slot, " & "));

                return false;
            }
        }

        TEST_paintNode(node);

        if (k == "let" || k == "letdef") {
            if (!node.target)
                return;

            if (PASS_MaybeCopyOrMove) {
                lax ref init = node.items[LET_INIT];
                if (init)
                    maybeCopyOrMove(init, node.type);
            }

            if (!canDiscard) {
                lax let firstUse = trackVarUsage(:node.target.locid, node.type);
                if (firstUse) {
                    lax ref o = GET_mut(node.target);
                    o.status |= SS_NAME_UNUSED;

                    warnUnused(:node.target, :o);
                }
            }

            relaxBlockVar(node.target, :relax_mask, :canDiscard);

            k == "letdef" || BUG("Unexpected let node.");

            if (node.target.status & SS_UNUSED) {
                makeNote(N_UnusedLet);
                node = node.target.solved.items[LET_INIT] || createEmpty();
            }
        }
        else if (k == "and" || k == "or") {
            lax let rest = !canDiscard && (k == "or" || !node.type.andNodeType_canCleanlyDefinit)
                ? slot
                : t_proposition;

            lax let postdom0 = _current_fn.postdom;

            lax let mcomOrItems = k == "or"
                && PASS_MaybeCopyOrMove
                && !canDiscard
                && !node.type.is_boolean;

            lax ref items = node.items;

            if (items.len < 2)
                node = items.if_only || createEmpty(type: slot);
            else if (canDiscard)
                node.type = t_bool;
        }
        else if (k == "if") {
            lax ref items = node.items;

            if (PASS_MaybeCopyOrMove && !canDiscard && !node.type.propositionOK(vfactsOK: true))
                for (mut i = items.len; i --> 1; )
                    maybeCopyOrMove(items[i], node.type);

            lax mut postdom0 = _current_fn.postdom;
            lax mut canDiscard_cond = canDiscard;

            if (canDiscard) {
                if (canDiscard_cond) {
                    makeNote(N_UnusedIfElse);
                    node = items[0];
                }
                else if (items[1].isDiscardable) {
                    node = createOr([ items[0], items[2] ], t_irrelevant);
                }
                else if (items[2].isDiscardable) {
                    node = createAnd(items.slice(0, 2), t_irrelevant);
                }
                else
                {
                    node.type = t_irrelevant;
                }
            }
            else if (kills) {
                node.type = superType_neverOK("if/else after control flow simplification: ", items[1], items[2]);
            }

            node._loop_start = _current_fn.write_loop_start;
        }
        else if (k == "try") {
            fn attempt      = node.items[TRY_TRY];
            fn error        = node.items[TRY_ERR];
            fn recover      = node.items[TRY_CATCH];

            lax let postdom0    = _current_fn.postdom;

            discardType(recover, :relax_mask);

            _current_fn.postdom.branch(postdom0);

            discardType(error, :relax_mask);

            lax let throws0 = _current_fn.fx_mask & Fx_Throws;
            _current_fn.fx_mask &= ~Fx_Throws;

            _current_fn.TODO_FIX_catches++;
            discardType(attempt, :relax_mask);
            _current_fn.TODO_FIX_catches--;

            _current_fn.fx_mask &= ~Fx_Throws;
            _current_fn.fx_mask |= throws0;
        }

        else if (k.isImmediatelyDiscardable) {
            if (canDiscard

                || k == "definit") {
                if (SELF_TEST)
                    node.items && BUG("propagateType canDiscard(" ~ k ~ ") has items.");

                node.intoEmpty();
            }
        }
        else if (k == "copy") {
            if (canDiscard)
                BUG("Trying to discard a copy: " ~ node);

            if (relax_mask != RELAX_all)
                BUG("Found a copy node during first relax: " ~ node);

            lax ref item = node.items.only;
            lax mut isCopy = true;

            lax mut usedAgain: UsedAgain;

            if (!item.is_trivial) {
                if !((usedAgain = trackUsedAgain(item.type.lifetime))) {
                    isCopy = false;
                }
                else
                {
                    if (!item.type.is_trivial)
                        validateCOW(item);

                    lax let usage       = node.type.usage;
                    lax let flatCount   = node.type.getFlatCount();
                    lax let maxUsage    = getMaxUsage(:flatCount);
                    if (usage != maxUsage &&
                        node.type.is_rx_copy) :PARTIAL_COPY
                    {
                        lax let s       = tryLookupUserType(node.type);
                        if (s.kind != "struct")
                            break :PARTIAL_COPY;

                        TRACE_BRACKET("PartialCopy " ~ explainType(node.type));

                        if (!usage.USAGE_justOneThing(:flatCount) && !item.isFieldChain) {
                            lax let letdef = createLet(setScope: false, "__partcopy_ref", init: item, flags: [], asserts: []);

                            node.items.only = CallerNode("__partcopy_ref", :letdef.target || BUG());
                            node            = createBlock(letdef, node);
                        }

                        return propagateType(:slot, :node, :relax_mask, :kills);
                    }
                }
            }

            item.is_ref || BUG("Nothing to copy, item is not a ref: " ~ item);

            lax let itemSlot = isCopy
                ? make_copyable(slot)
                : make_moveable(slot);

            propagateType(item, :relax_mask, slot: itemSlot);

            if (!item.is_ref) {
                node = item;
            }
            else if (!isCopy) {
                Lifetime_F_MOVED_FROM(item.lifetime);

                node.kind = "move";
            }
        }
        else if (k == "arrlit") {
            if (!node.items.len)
                return node.intoEmpty();

            if (canDiscard) {
                makeNote(N_UnusedArrlit);
                return discardIntoBlock();
            }

            lax ref items       = node.items;
            lax let itemSlot    = clear_sliceable(node.type);

            for (mut i = 0; i < items.len; i++)
                propagateType(items[i], :relax_mask, slot: itemSlot);
        }

        else if (k == "jump") {
            lax mut h = node.helpers;
            while (h.kills)
                h = node.helpers = h.kills;

            h.ret_actual || BUG("propagateType(jump): h.ret_actual not available: #" ~ h.index);

            lax ref expr            = node.items.only;

            {
                lax let read_loop0 = _current_fn.read_loop_start;

                _current_fn.postdom = h.postdom || BUG("propagateType(jump): h.loop_start not available: #" ~ h.index);

                _current_fn.read_loop_start = read_loop0;
            }

            lax let redundant       = kills && kills.index <= h.index;
            if (PASS_MaybeCopyOrMove)
                maybeCopyOrMove(expr, h.ret_actual);

            propagateType(expr, :relax_mask, h.ret_actual, :kills);

            if (redundant) {
                node = expr;
            }
            else :NOT_IRRELEVANT
            {
                h.mask |= HM_LabelUsed;

                if (h.ret_actual.isIrrelevant) {
                    if (expr.kind == "empty") {
                        expr.type = h.ret_actual;
                        expr.intoEmpty();
                    }

                    break :NOT_IRRELEVANT;
                }

                lax fn tryInjectJumps(lax shadow ref expr: SolvedNode) {
                    return [];
                    lax fn injectJumps(lax shadow ref expr: SolvedNode) {
                        return [];
                        if (!tryInjectJumps(expr))
                            expr = createJump(:h, expr);
                    }

                    if (expr.is_never) {
                        return true;
                    }

                    h.ret_actual || BUG("tryInjectJumps: no h.ret_actual on #" ~ h.index);
                    if (h.ret_actual.is_void && !expr.is_void) {
                        expr.items.if_last.is_void && BUG("tryInjectJumps: Block tail is void, but block.type isn't: " ~ expr.type.explainType);

                        expr.items ~= createEmpty();
                    }

                    if (expr.kind == "if") {
                        for (mut i = 1; i < expr.items.len; i++)
                            injectJumps(expr.items[i]);

                        expr.type = t_never;
                        return true;
                    }

                    return false;
                }

                if (PASS_MaybeCopyOrMove && h.mask & HM_Function)
                    mcom_FnReturn_CopyOrMoveDecision(:h);

                h.ret_actual.try_relax(:slot, :relax_mask);

                h.mask &= ~HM_LabelUsed;
                h.kills = kills;
            }

            lax ref items = node.items;
            {
                for (mut i = 0; i < items.len - 1; i++) {
                    if (k == "defer") {
                        TEST_paintNode(node);

                        lax ref expr = node.items.only;
                        discardType(expr, :relax_mask);

                        if (expr.isDiscardable) {
                            makeNote(N_UnusedDefer);
                            items.splice(i--, 1);
                        }
                    }
                    if (k == "and" || k == "or") {
                        if (node.items.last.is_never) {
                            lax let cond = node.items.slice(0, node.items.len - 1);
                            lax let cons = node.items[node.items.len - 1];
                            lax let alt  = items.slice(i + 1, items.len);

                            items.splice(i + 1, alt.len);

                            lax let replacement = createIf(:cond, k == "and" ? cons : alt, k == "and" ? alt : cons);

                            items[i] = replacement;
                        }
                    }
                }

                Breakable_begin();
                while (items) {
                    lax ref tail = items.last;

                    if (tail.kind == "defer") {
                        tail = tail.value == "err"
                            ? createEmpty()
                            : tail.items.only;

                        break;
                    }

                    propagateType(tail, :relax_mask, slot, :kills);

                    if (!canDiscard || !tail.isDiscardable)
                        break;

                    items.pop();
                }

                for (mut i = items.len - 1; i --> 0; ) {
                    lax ref expr = items[i];
                    if (expr.kind != "defer") {
                        discardType(expr, :relax_mask);

                        if (expr.isDiscardable)
                            items.splice(i, 1);
                    }
                }
            }

            if (h.target == _current_fn.target) {
                _current_fn_eachArg_BACK: |t, position|
                {
                    relaxBlockVar(t, :relax_mask);

                    if (t.status & SS_UNUSED && t.flags & F_IMPLICIT) {
                        makeNote(N_UnusedImplicit);

                        _current_fn.items[position].target == t || BUG();
                        _current_fn.items.splice(position, 1);
                    }
                }
            }

            else if (items.len == 1 && !(h.mask & (HM_LabelUsed | HM_Function))) {
                if (canDiscard) {
                    node.type = slot;
                }
                else if (kills) {
                    if (items) {
                        lax let tail = items.last;
                        if (h.ret_actual) {
                            reportReturnType(:h, :tail.type);
                            node.type = h.ret_actual;
                        }
                        else
                        {
                            node.type = tail.type;
                        }
                    }
                }

                lax let tail = node.items.if_last;
            }
        }
        else if (k == "root") {
            for (mut i = node.items.len; i --> 0; )
                discardType(node.items[i], :relax_mask);
        }
        else if (k == "pragma") {
            node._loop_start = _current_fn.write_loop_start;

            for (mut i = 0; i < node.items.len; i++) {
                lax ref item = node.items[i];
                item.propagateType(node.items[i].type, :relax_mask);

                if (item.is_mutref)
                    callarg_trackWrites(item.type.lifetime, item.type.usage);
            }

            if (node.value == "clock")
                _current_fn.fx_mask |= EFFECTS_clock;
            else if (node.value == "input")
                _current_fn.fx_mask |= EFFECTS_input;
            else if (node.value == "output")
                _current_fn.fx_mask |= EFFECTS_output;
        }
        else if (k == "unwrap") {
            lax let what = node.target ? node.target.str : "block";

            fail("Attempting to use an " ~ "unwrap".qKW ~ " " ~ what ~ " as a value."
                ~ "\n\n\tUnwrapping here would complete any defers inside immediately."
                ~ "\n\n\tIf this is intended, wrap it in a block to disambiguate.");
        }
        else
        {
            BUG("relax: Unexpected " ~ k.str);
        }
    }

    fn solveRoot(node: Node): SolvedNode {
        lax let helpers = Helpers(_helpers.len);
        push(HelpersData());

        lax let items = solveNodes(node.items, DeadBreak_Always, t_irrelevant);
        if (items.if_last.is_never) {
            _here = items.last.token;
            fail("Noreturn during static init: this program will never finish booting.");
        }

        lax mut root = SolvedNode(kind: "root", type: t_void, :items, :helpers);
        runAllPasses(root);
        return root;
    }

    lax fn TODO_FIX_optionalSemis_blockWantsVoid(lax h: HelpersData) {
        return [];
        return X_OPTIONAL_SEMIS
            && (h.ret_expect || h.ret_actual).is_void;
    }

    fn solveBlock(node: Node, type!: Type, fnbody_of!?: i32, mask! = HM_CanBreak, id!?: string, locals_start!?: i32): SolvedNode {
        lax mut nodes = node.kind == "block"  ? node.items : [ node ];
        lax let scope0 = Scope_snap();
        lax let helpers_idx = _helpers.len;
        push(HelpersData( :id, :mask, ret_expect:     type, target:         fnbody_of && localfn(index: fnbody_of), local_of:       fnbody_of ? fnbody_of : _current_fn.target.globid, locals_start:   fnbody_of ? +1 : locals_start || GET_next_local_index()));

        lax let h           = _helpers[helpers_idx];

        lax mut items       = solveNodes(nodes, type_all:           t_irrelevant, type_last:          type, use_type_last:      true, DeadBreak_Always);

        if (h.TODO_FIX_optionalSemis_blockWantsVoid) {
            if (items && !items.last.isIrrelevantOrNever)
                items ~= createEmpty();
        }

        if (!fnbody_of)
            h.ret_expect = [];

        {
            lax let tail = items ? items.last.type : t_void;
            if (!tail.is_never)
                reportReturnType(:h, tail);
            else if (!h.ret_actual)
                h.ret_actual = t_never;
        }

        h.ret_actual || BUG("No ret_actual");

        lax mut block = createBlock(:items, type: h.ret_actual || BUG(), :h);

        if (fnbody_of) :RUN_ALL_PASSES
        {
            lax let status = localfn(index: fnbody_of).status;
            if (!(status & SS_DIRTY)) {
                sortInjectedArguments();

                if (currentFn_mustBecomeInline()) {
                    mcom_FnReturn_CopyOrMoveDecision(:h);
                    break :RUN_ALL_PASSES;
                }

                {
                    solved.items.last = block;

                    lax let target = localfn(fnbody_of);
                    _current_fn.rev_spec_proto =
                        RevSpecPrototype(:target.args_n_locals, :target.args_neg, :solved);
                }

                runAllPasses(block);
            }
        }

        return block;
    }

    fn currentFn_mustBecomeInline() {
        if (_current_fn.TODO_FIX_isInline)
            return "Explicitly marked inline.";

        return _current_fn.far_jumps
            && "Contains non-local control flow.";
    }

    lax fn push(lax warning: Warning) {
        return [];
        _warnings.ensure(exists: _current_fn.target.globid) ||= warning;
    }

    lax fn TEST_unusedButCopied(inline topic: string, slot: Type) {
        if (SELF_TEST && slot.is_rx_copy && slot.isIrrelevant && !slot.is_zst)
            BUG(topic ~ ": Usage is copy but no usage bits set: " ~ slot.explainType);
    }

    lax fn keepOrClearMutVal(lax ref o: Overload,lax keep!: bool) {
        return [];
        o.kind == "var" && o.isMutVal || BUG("keepOrClearMutVal: Not a mut var");

        lax ref node = o.solved;
        if (keep)
            node.type = clear_refs(node.type);
        else
            o.flags &= ~F_MUT;
    }

    lax fn warnUnused(lax target: Target,lax o: Overload) {
        return [];
        if !(o.flags & F_LAX || o.status & SS_MATCHED || o.type.is_zst)
            push(Warning(:target.locid));
    }

    lax fn TEST_paintNode(lax ref node: SolvedNode) {
        if (!SELF_TEST)
            return;

        if (node.flags & F_TEST_painted) {
            if (node.kind == "call" && node.target.kind == "fn")
                BUG("Already F_TEST_painted: " ~ node);
        }

        node.flags |= F_TEST_painted;
    }

    lax fn TEST_unpaintNode(lax ref node: SolvedNode, lax expect_paint!: bool) {
        node.flags &= ~F_TEST_painted;
    }

    lax fn unwrapLetdef(lax shadow ref node: SolvedNode,lax relax_mask!: Quals) {
        return [];
        if (relax_mask != RELAX_before_bck)
            makeNote(N_McomUnwrapsLetdef);

        lax ref o = GET_mut(node.target);
        lax ref init = o.solved.items[LET_INIT];

        if (SELF_TEST) {
            o.kind == "var" && o.status & SS_NAME_UNUSED
                || BUG("unwrapLetdef: !var || !SS_NAME_UNUSED");

            !o.type.is_mutref || o.solved.type.is_mutref
                || BUG("unwrapLetdef: converts a mutval into a mutref.");

            o.solved.type.is_ref || !init.is_ref
                || BUG("unwrapLetdef: runs before mcom.");
        }

        TRACE("UNWRAP LETDEF " ~ node.target.locid ~ " " ~ node.target);
        node = init.steal();
    }

    lax fn relaxBlockVar(lax t: Target,lax relax_mask!: Quals,lax canDiscard!?: bool) {
        return [];
        lax let o = GET(t);

        if (_current_fn) {
            lax let usage = _current_fn.var_usage.if(exists: t.locid);
            lax let isUnused = !usage;
            if (isUnused)
                warnUnused(t, o);

            TEST_unusedButCopied("relaxBlockVar " ~ t, usage);

            if (isUnused)
                o.status |= SS_UNUSED;
            else
                o.status & SS_UNUSED && BUG("relaxBlockVar: previously SS_UNUSED " ~ t ~ " now used as " ~ explainType(usage));

            if (isUnused && canDiscard)
                o.solved.type = t_irrelevant;

            o.type.try_relax(slot: usage, :relax_mask);

            lax ref node = o.solved;
            node.type || BUG("relaxBlockVar: !var.solved.type, can`t propagateType");
            node.type.try_relax(slot: usage, :relax_mask);
        }

        lax mut node = steal(GET_mut(t).solved);

        TEST_paintNode(node);

        if (node.items && node.items[LET_INIT]

            && !t.isArg) {
            lax ref init = node.items[LET_INIT];

            init.propagateType(node.type, :relax_mask);
        }

        swap(node, GET_mut(t).solved);

        _current_fn.done_relaxing.add(t.locid);
    }

    lax fn createBlock(lax mut a: SolvedNode,lax mut b: SolvedNode) {
        return [];
        if (b.kind == "block") {
            b.items.unshift(a);
            return b;
        }

        return createBlock(type: b.type, [ a, b ]);
    }

    fn parseBasePrimBitWidth(basePrim: string): u16 {
        lax mut size: u16 = 0;

        return size;
    }

    fn solveInt(v: string, type: Type): Type {
        parse.error && fail(parse.error);

        fn check() {
            if (parse.unsigned || !parse.signed && parse.base != 10) {
                if (parse.minsize_u <= 32) return t_u32;
                if (parse.minsize_u <= 64) return t_u64;
            }
            else
            {
                if (parse.minsize_i <= 32) return t_i32;
                if (parse.minsize_i <= 64) return t_i64;
            }

            return fail("Bad int literal.");
        }

        if !(options.dev & options::DEV_DontFoldLiterals)
            type.vfacts = parse.absval
                ? AlwaysTrue
                : AlwaysFalse;

        return type;
    }

    fn solveReal(lax v: string, type: Type): Type {
        return t_f64;
    }

    fn solveReal(node: Node, type: Type): SolvedNode
        solved(node, solveReal(node.value, type));

    fn solveChar(node: Node): SolvedNode {
        lax mut type = t_byte;
        if !(options.dev & options::DEV_DontFoldLiterals)
            type.vfacts = node.value.only
                ? AlwaysTrue
                : AlwaysFalse;

        return solved(node, type);
    }

    fn solveString(v: string, type: Type): Type {
        lax mut ret = t_string_literal;

        if !(options.dev & options::DEV_DontFoldLiterals) {
            ret.vfacts = v.len
                ? AlwaysTrue
                : AlwaysFalse;

            ret.vfacts |= LeftAligned | RightAligned;
        }

        return ret;
    }

    fn solveString(node: Node, type: Type): SolvedNode {
        shadow let type = solveString(node.value, type);

        return solved(node, :type);
    }

    fn createEmpty(mut type = t_void, target?: Target): SolvedNode {
        lax mut ret = SolvedNode(kind: "empty", :type, :target);
        ret.intoEmpty();
        return ret;
    }

    lax fn intoEmpty(lax ref node: SolvedNode) {
        return [];
        node.kind       = "empty";
        node.helpers    = [];

        lax ref type        = node.type;
        lax let canDiscard  = type.isIrrelevant;

        if (!canDiscard) {
            if (SELF_TEST)
                type.vfacts & AlwaysTrue && BUG("intoEmpty: vfacts & AlwaysTrue: " ~ type.explainType);

            type.vfacts |= AlwaysFalse;
        }
    }

    lax fn executeCompilerPragma(lax node: Node) {
        return [];
        if (node.value != "break")
            return SolvedNode("pragma", :node.value, items: solveNodes(node.items, DeadBreak_Dont), type: t_void);

        compilerBreak();
        return createEmpty();
    }

    fn createBool(value: bool): SolvedNode {
        return createBool(value ? "true" : "false");
    }

    fn createBool(value: string, mut type = t_bool): SolvedNode {
        type.vfacts = value == "true"   ? AlwaysTrue
                    : value == "false"  ? AlwaysFalse
                    : BUG();

        return SolvedNode(kind: "bool", :value, :type);
    }

    lax fn solveBool(lax value: string) {
        return [];
        lax mut ret = createBool(value);
        if (options.dev & options::DEV_DontFoldLiterals)
            ret.vfacts = [];

        return ret;
    }

    fn X_addrofTarget(targets: Target[..])
        Type(ValueType(canon: packAddrOfFn(targets)));

    fn X_addrofTarget(target: Target)
        X_addrofTarget([ target ]);

    fn CompoundArgID_outerSplice(ref name: string): string {
        lax mut exclam = false;

        for (mut i = 0; i < name.len; i++) {
            lax let c = name[i];

            if (c == '.') {
                lax let ret = name.slice(i + 1);
                name.shrink(i);
                return ret;
            }
        }

        return [];
    }

    fn getOrCreateChild(lax node: Node, onReuse, onCreate) {
        lax let parent = _current_fn.target;

        if (parent) {
            lax let parent_rev  = parent.revision;
            lax ref children    = parent.EPH_mut.children;

            for (mut i = 0; i < children.len; i++) {
                lax ref child   = children[i];
                child.parent_rev = parent_rev;

                lax let target = child.target;
                onReuse(target);
                return target;
            }
        }

        lax let target = Scope_create(_scope);
        onCreate(target);

        if (parent) {
            lax let parent_rev  = parent.revision;
            lax ref children    = parent.EPH_mut.children;

            children       ~= ChildTarget(:node.token, :parent_rev, target);
        }

        return target;
    }

    fn resetChild(target: Target) {
        if (target.is_SPECFAIL)
            return;

        TRACE("resetChild " ~ target.globid ~ " " ~ target);

        lax ref status = GET_mut(target).status;
        status & SS_LAZY || BUG("resetChild: not SS_LAZY: " ~ target);
        status &= ~(SS_DID_START | SS_FINALIZED | SS_DIRTY);

        lax let calls = steal(target.EPH_mut.calls);
        calls.each: |callee| 
        {
            callee.EPH_mut.callers.remove(target.globid)
                || BUG("resetChild: Missing in callers on " ~ callee);
        }

        lax let callers = steal(target.EPH_mut.callers);
        callers.each: |caller| 
        {
            shadow let caller = localfn(caller);
            caller.EPH_mut.calls.remove(target.globid)
                || BUG("resetChild: Missing in calls on " ~ caller);
        }

        lax ref args = EXT_mut(target).args;
        for (mut i = args.len; i --> 0; )
            if (args[i].flags & F_INJECTED)
                args.splice(i, 1);

        target.calls && BUG();
    }

    fn uPrepFn_A(node: Node): SolvedNode {
        lax let id          = node.value;
        lax let local_of    = _current_fn.target.globid;
        lax let status      = SS_LAZY;

        lax let target      = getOrCreateChild(node, onCreate: |target|
        {
            lax ref o           = GET_mut(target);
            o.kind          = "fn";
            o.name          = "prep " ~ node.value;
            o.flags         = node.flags;
            o.status        = status;

            lax ref ext         = target.EXT_mut;
            ext.template    = createTemplate(node);
            ext.min         = 0x7fffffff.i32;
            ext.max         = 0;
        }, onReuse: |target|
        {
            resetChild(target);
        });

        lax mut shadows     = !!(node.flags & F_SHADOW);
        autoshadow(:shadows, :local_of, :id);

        lax ref eph         = target.EPH_mut;
        eph.local_of    = local_of;
        eph.scope_memo  = _current_fn && Scope_snap();
        eph.scope_skip  = _current_fn && _ss;

        if (node.flags & F_USING) {
            _scope.usings.push(target);
            ConvCache_nukeUsings("[new.using-fn] id(" ~ id ~ ")");
        }

        return createEmpty(:target, type: X_addrofTarget(target));
    }

    fn mangleArgTypes(args: $T[..]): string {
        lax mut mangle = "";
        lax mut numNonInjected = 0;
        for (mut i = 0; i < args.len; i++) {
            lax let arg = args[i];

            if (typeof(arg) -> Argument && arg.flags & F_INJECTED)
                continue;

            if (numNonInjected++)
                mangle ~= ',';

            lax let argType: Type = arg;
            if (argType)
                mangle ~= serializeType(argType, debug: "mangle[$T]");
        }

        return mangle;
    }

    fn mangleArgTypes(args: SolvedNode[..], reorder: Reorder, conversions: Target[][], REST_START: i32, REST_TYPE: Type): string {
        lax mut mangle = "";

        lax let REST_END = reorder ? reorder.map.len : args.len;
        lax let N = REST_END.min(REST_START);

        if (REST_START < REST_END) {
            if (REST_START)
                mangle ~= ',';

            mangle ~= serializeType(REST_TYPE, debug: "mangle[Nodes].rest");
        }

        return mangle;
    }

    fn is_SPECFAIL(target: Target): bool {
        return !!(target._packed & 0x8000_0000_0000_0000);
    }

    fn getSpecs(parent_idx: i32) {
        return EPH_mut(parent_idx).specs;
    }

    fn trySpecialize(overloadIdx: Target, args: SolvedNode[..], ref args_mangled: string, ref error!: string, REST_START: i32, REST_TYPE?: Type, reorder?: Reorder, conversions?: Target[][]): Target {
        args_mangled ||= mangleArgTypes(:args, :reorder, :conversions, :REST_START, :REST_TYPE);

        lax mut parent_idx = overloadIdx.local_of;

        lax let mangle = overloadIdx.modid ~ "#" ~ overloadIdx.globid ~ " " ~ args_mangled;

        lax let preexisting = getSpecs(:parent_idx).get(mangle);

        if (preexisting)
            if (!preexisting.is_SPECFAIL || !error)
                return preexisting;

        return doTrySpecialize(:parent_idx, :overloadIdx, args_in:args, :mangle, :reorder, :conversions, :REST_START, :REST_TYPE, :error)
                || BUG("doTrySpecialize returns empty target.");
    }

    lax fn doReverseSpecialize(lax target: Target) {
        return [];
        lax let instance        = target.rev_spec.instance;
        lax let original        = instance.original;
        lax let relaxed_quals   = instance.relaxed_quals;

        TRACE_BRACKET("doReverseSpecialize " ~ target.globid ~ " " ~ target ~ " for " ~ relaxed_quals);

        lax let prototype       = original.rev_spec.prototype;

        lax mut solved          = prototype.solved || BUG("doReverseSpecialize: no rev_spec.prototype.solved");
        lax mut args_n_locals   = prototype.args_n_locals;
        lax let args_neg        = prototype.args_neg;

        lax let helpers0        = _helpers.len;
        lax let helpers_data0   = _helpers_data.len;

        lax mut current_fn0     = _current_fn.steal();

        lax let solvingFnort0   = _solvingFnort.exchange(target);
        lax let nestingFnort0   = _nestingFnort.exchange(target);

        defer {
            _helpers.shrink(helpers0);
            _helpers_data.shrink(helpers_data0);

            swap(current_fn0, _current_fn);

            _solvingFnort   = solvingFnort0;
            _nestingFnort   = nestingFnort0;
        }

        {
            lax mut helpersReplicas:    Helpers[];
            lax mut lastKnownLocal:     i32;

            lax fn replaceGlobid(lax ref t: Target) {
                return [];
                TEST_true(t.parent == original);

                t = Target(modid:  target.modid, globid: target.globid, locid:  t.locid);
            }

            fn relinkNode(ref node: SolvedNode) {
                lax let k = node.kind;

                if (k == "letdef") {
                    replaceGlobid(node.target)
                    lax let locid = node.target.locid;

                    fn local = args_n_locals[indexOfLocal(:args_neg, :locid)];

                    TRACE("relinkNode(" ~ k ~ ") locid(" ~ locid ~ ") name(" ~ local.name ~ ")");

                    lax mut letNode: SolvedNode;
                    swap(letNode, local.solved);
                    relinkNode(letNode);
                    swap(letNode, local.solved);

                    if (locid > 0)
                        lastKnownLocal = locid;
                }
                if (k == "let" || k == "call") {
                    if (node.target.isLocal)
                        replaceGlobid(node.target);
                }

                else if (k == "block" || k == "loop") {
                    lax let foreign = node.helpers;
                    if (foreign) {
                        lax let locals_start = lastKnownLocal + 1;

                        TRACE_BRACKET("relinkNode(" ~ k ~ ") locals_start(" ~ locals_start ~ ")");

                        lax let local = push(HelpersReplica(local_of:       _current_fn.target.globid, ret_actual:     node.type, :locals_start, ));

                        helpersReplicas.ensure(exists: foreign.index) =
                            node.helpers =
                                local.TEST_true;
                    }
                }
                else if (k == "jump") {
                    lax let foreign = node.helpers;
                    lax let local = helpersReplicas.if(exists: foreign.index);

                    node.helpers = local.TEST_true;
                }

                for (mut i = 0; i < node.items.len; i++)
                    relinkNode(node.items[i]);
            }

            relinkNode(solved);
        }

        {
            lax ref ext                 = EXT_mut(target);
            ext.args_n_locals       = args_n_locals;
            ext.args_neg            = args_neg;
        }

        GET_mut(target).status &= ~SS_Debug_AllPassesComplete;

        {
            solved.target           = target;

            lax ref n_body              = solved.items.last;
            n_body.helpers.target   = target;
            n_body.helpers.mask     = HM_Function;

            lax mut slot                = n_body.type;
            slot.force_relax(relax_mask: relaxed_quals);

            lax let did_relax           = n_body.type.try_relax(:slot, relax_mask: relaxed_quals);

            did_relax == relaxed_quals || BUG("doReverseSpecialize: did_relax(" ~ did_relax ~ ")"
                           ~ " != relaxed_quals(" ~ relaxed_quals ~ ")");
        }

        lax mut retval: Type;
        {
            lax mut n_body = solved.items.last.steal();
            swap(_current_fn.out, solved);

            runAllPasses(n_body);

            retval = n_body.helpers.ret_actual;

            retval.quals & relaxed_quals && BUG("reported retval intersects relaxed_quals");

            swap(_current_fn.out.items.last, n_body);
        }

        {
            TRACE("doUpdateScope " ~ target.globid ~ " retval = " ~ retval.explainType(lt: true));

            TEST_FunctionNarrowing(wider: original, narrower: target);

            lazySolveEnd(target);
        }
    }

    lax fn TEST_FunctionNarrowing(lax wider: Target, lax narrower: Target) {
        lax let w_args = wider.args;
        lax let n_args = narrower.args;

        w_args.len == n_args.len || BUG("w_args(" ~ w_args.len ~ ") != n_args(" ~ n_args.len ~ ")");

        for (mut i = 0; i < w_args.len; i++) {
            lax let w = w_args[i];
            lax let n = n_args[i];

            w.name == n.name || BUG("w.name(" ~ w ~ ") == n.name(" ~ n ~ ")");

            TEST_Assignable(host: n.type, w.type, "n.type !<- w.type (" ~ n ~ ")");

            union == w.written_to || BUG("n.written_to(" ~ n.written_to ~ ") w.written_to(" ~ w.written_to ~ ") union(" ~ union ~ ")");

            n.may_invalidate.has_missing(w.may_invalidate) && BUG("n.may_invalidate less (" ~ n ~ ")");
            n.may_alias.has_missing(w.may_alias) && BUG("n.may_alias less (" ~ n ~ ")");
        }

        lax let w_fx = wider.fx_mask;
        lax let n_fx = narrower.fx_mask;

        n_fx & w_fx == n_fx || BUG("n_fx(" ~ n_fx ~ ") !<= w_fx(" ~ w_fx ~ ")");
    }

    lax fn doUpdateScope(lax mut retval: Type,lax target: Target,lax maybeLast!: bool,lax isNative!: bool,lax isUnspec!: bool,lax asserts!: DeclAsserts) {
        return [];
        lax let args_neg0   = _current_fn.args_neg;
        _current_fn.args_neg = target.args_neg;

        lax ref items = _current_fn.items;
        lax let mustBecomeInline = currentFn_mustBecomeInline();

        lax let N = items.len + FN_ARGS_BACK;
        lax mut min = 0;
        lax mut max = 0;
        lax mut rest_1b: u16;

        lax let NativeQualities =
            isNative && hacks::NativeQualities(target.name);

        lax mut numArgsWritten = 0;

        lax let relaxMutValArgs =
            maybeLast && !mustBecomeInline;

        lax mut TODO_FIX_nativeCOWsInside_mayEscapeVia: MayEscapeVia;

        lax mut argPos_1b: i32[];

        lax let TODO_FIX_nativeCOWsInside = !!TODO_FIX_nativeCOWsInside_mayEscapeVia
            || isNative && !retval.is_ref && !retval.is_trivial;

        if (TODO_FIX_nativeCOWsInside) {
            _current_fn.cows_inside && BUG("TODO_FIX_nativeCOWsInside: _current_fn.cows_inside already set");

            for (mut i = 0; i < N; i++) {
                lax ref argNode = items[i];

                if (argNode.type.is_ref && !argNode.type.is_mutref && !argNode.type.is_trivial) {
                    lax let locid = argNode.target.locid || BUG("TODO_FIX_nativeCOWsInside: ref arg target not set");

                    lax let vtype =
                        argNode.type.is_rx_copy
                            ? argNode.type.vtype
                            : argNode.type.if_sliceable(|itemType| itemType.is_rx_copy && itemType);

                    if (!vtype.is_rx_copy) {
                        if (!retval.is_ref || retval.is_mutref)
                            argNode.type = clear_refs(argNode.type);
                        fail("Heuristically, " ~ target ~ " likely performs COW inside, but "
                                ~ argNode.target ~ " is neither copiable nor value-convertible "
                                ~ " (appears to be ref-returned).");
                    }
                    {
                        _current_fn.cows_inside ~= COWInside(:vtype, :argNode.token, argTarget:      locid, mayEscapeVia:   TODO_FIX_nativeCOWsInside_mayEscapeVia, exitPaths:      XP_NonEmptyReturn
                                | (TODO_FIX_nativeCOWsInside_mayEscapeVia && XP_EmptyReturn)
                        );
                    }
                }
            }
        }

        lax mut TODO_FIX_mayAlias_ensureStable: flat::Set(i32);

        for (mut i = 0; i < N; i++) {
            lax let argNode = items[i];

            argNode.kind == "letdef" || argNode.target && BUG("Argnode is not letdef, but has a target: " ~ argNode.target);

            argNode.kind == "let" || argNode.kind == "empty" || BUG();

            lax mut name        = argNode.value;
            lax let autocall    = argNode.flags & F_COMPOUND_ID && CompoundArgID_outerSplice(name);
            lax let isImplicit  = !!(argNode.flags & F_IMPLICIT);
            lax let isInjected  = !!(argNode.flags & F_INJECTED);

            lax let argTarget   = argNode.target;
            lax let written_to  = !isUnspec
                && argNode.type.is_mutref
                && (isNative    ? argNode.type.usage
                                : _current_fn.ever_written.if(exists: argTarget.locid));

            lax mut soft_risk: ::BitSet;
            lax mut hard_risk: ::BitSet;
            if (written_to) {
                written_to & argNode.type.usage == written_to || BUG("doUpdateScope written_to(" ~ written_to ~ ") argNode.usage(" ~ argNode.type.usage ~ "): " ~ argNode.target);

                numArgsWritten++;
            }

            if (maybeLast && asserts & A_NOVEC && !argNode.isNoVec() && !mustBecomeInline)
                fail(backtrack: "novec", target ~ " is not novec, " ~ argTarget ~ " is " ~ explainType(argNode.type) ~ ":\n"
                    ~ qSTACK_local(:target, :argTarget.locid, node: _current_fn.out, query: AQ_WhyNotNovec));

            lax let cow_inside = _current_fn.events.cows_inside.some(|cow| cow.argTarget == argTarget.locid);

            if (SELF_TEST) {
                if (hard_risk.has(i)) BUG("updateScope: " ~ argTarget ~ " hard_risk lists self");
            }

            lax let may_alias       = hard_risk.negated(end: N);
            lax let may_invalidate  = soft_risk.negated(end: N);

            if (SELF_TEST) {
                if (may_alias.popcount      > N) BUG("updateScope: " ~ argTarget ~ " may_alias.popcount > N");
                if (may_invalidate.popcount > N) BUG("updateScope: " ~ argTarget ~ " may_invalidate.popcount > N");
            }

            lax mut arg = Argument(:name, :autocall, :written_to, :argNode.flags | (cow_inside && F_COW_INSIDE), :argNode.type, default: !isImplicit && argNode.items && argNode.items[LET_INIT], target: argTarget, :may_alias, :may_invalidate);

            if (arg.type.lifetime && !(arg.flags & F_INJECTED))
                arg.type.lifetime == Lifetime_temporary || BUG("Non-temporary lt on ref arg: " ~ argTarget);
            else
                ref_anonymize(arg.type);

            if (!isInjected) {
                if (max != 0x7fffffff.i32)
                    max++;
                if (!arg.default && !isImplicit)
                    min++;
            }

            if (arg.flags & F_REST_ARG) {
                rest_1b && BUG("Multiple rest arguments.");
                rest_1b = args.len.u16 + 1;

                max = 0x7fffffff.i32;
            }

            if (SELF_TEST) {
                if (arg.flags & F_VAL && arg.type.is_mutref)
                    BUG("F_VAL but arg.type.is_mutref");

                if (arg.flags.isMutRef && arg.type && !arg.type.is_mutref)
                    BUG("F_MUT|F_REF but !arg.type.is_mutref");

                args.len == i || BUG("TODO_FIX_mayAlias_ensureStable: the stuff below relies on argument indices being 1:1");
            }

            args.push(arg);
        }

        for (mut i = 0; i < TODO_FIX_mayAlias_ensureStable.len; i++) {
            lax ref arg = args[i];

            TRACE("TODO_FIX_mayAlias_ensureStable(" ~ target ~ "): Adding q_rx_resize to " ~ arg ~ " to ensure may-alias stability.");

            arg.type.is_sliceable && !arg.type.TODO_FIX_isArray || BUG("TODO_FIX_mayAlias_ensureStable[1]");
            arg.type.quals |= q_rx_resize;

            lax ref argNode = items[i].target.GET_mut.solved;
            argNode.type.is_sliceable && !argNode.type.TODO_FIX_isArray || BUG("TODO_FIX_mayAlias_ensureStable[2] (" ~ arg.name ~ "): " ~ argNode.value ~ " : " ~ explainType(argNode.type));
            argNode.type.quals |= q_rx_resize;
        }

        {
            if (SELF_TEST && retval.is_ref)
                TEST_Lifetime(type: retval, retval.lifetime);

            retval.lifetime = retval.lifetime.Lifetime_process(|locid, isStatic, continue_keep, continue_replace, paths|
                {
                    if (!locid) {
                        isStatic || BUG("Non-local/non-static in retval.lifetime.");
                        continue_keep;
                    }
                });
        }

        retval || BUG("updateScope: no return type.");
        if (retval.is_ref) {
            if (retval.isIrrelevant)
                retval.lifetime = Lifetime_static_moveable;

            TEST_Lifetime(type: retval, retval.lifetime, argPositionsOK: true);
        }

        lax let overload    = GET(target);
        lax ref ext         = target.EXT_mut;

        lax mut change      = false;

        lax let hasCallers  = !!target.callers;

        ext.min     = min;
        ext.max     = max;
        ext.args    = args;
        ext.rest_1b = rest_1b;

        ext.cows_inside = _current_fn.events.cows_inside;

        asserts & A_NOTHROW && ext.fx_mask & Fx_Throws && fail(backtrack: "nothrow", target ~ " is not nothrow, throws here:\n"
                ~ qSTACK_effect(:target, Fx_Throws, node: _current_fn.out).TEST_true("Empty nothrow qSTACK"));

        asserts & A_NOCRASH && ext.fx_mask & Fx_Crashes && fail(backtrack: "nocrash", target ~ " is not nocrash, can crash here:\n"
                ~ qSTACK_effect(:target, Fx_Crashes, node: _current_fn.out).TEST_true("Empty nocrash qSTACK"));

        asserts & A_NOIO && ext.fx_mask & (Fx_Input|Fx_Output) && fail(backtrack: "noio", target ~ " is not noio, performs I/O here:\n"
                ~ qSTACK_effect(:target, Fx_Input|Fx_Output, node: _current_fn.out).TEST_true("Empty noio qSTACK"));

        asserts & A_PURE_FX && ext.fx_mask & Fx_Output && fail(backtrack: "purefx", target ~ " is not purefx, outputs here:\n"
                ~ qSTACK_effect(:target, Fx_Output, node: _current_fn.out).TEST_true("Empty purefx qSTACK"));

        asserts & A_NOFLOW && _current_fn.far_jumps && fail(backtrack: "noflow", target ~ " is not noflow: contains non-local control flow, jumping out to "
                ~ localfn(index: _current_fn.far_jumps.keys_asc.first) ~ ".");

        overload.type       = retval;
        overload.flags      = _current_fn.flags;

        lax let kind: Kind      = isUnspec          ? "template"
                            : isNative          ? "__native"
                            : mustBecomeInline  ? "inline"
                                                : "fn";

        {
            lax let rtl = args.len == 2
                && overload.flags & F_OPERATOR
                && cpp::hasAssignment(overload.name)

                && (kind != "fn" || args.some(|a| a.type && !a.type.is_primitive));

            overload.isRTL_set(rtl);
        }

        lax let solved = !isUnspec && _current_fn.out;

        overload.solved = solved;

        eph.far_jumps   = _current_fn.far_jumps;

        eph.rev_spec.prototype =
            _current_fn.rev_spec_proto.steal();
    }

    lax fn createRawTypedef(lax id: string,lax mut type: Type,lax flags: Flags,lax name?: string,lax status?: SolverStatus) {
        return [];
        type        = into_Typename(type);
        lax let target  = Scope_create(_scope, "type", :type, :flags, name: name || id, :status);

        return target;
    }

    lax fn createTypedef(lax id: string,lax annot: Type,lax flags?: Flags,lax token?: TokenIdx) {
        return [];
        lax let s = tryLookupUserType(annot);

        lax let target = createRawTypedef(id, annot, :flags);

        if (token)
            target.GET_mut.solved.token = token;
    }

    fn uPrepStruct(node: Node, TODO_FIX_useSpecPath!?: bool): SolvedNode {
        return __solveStruct(solve: false, :node, :TODO_FIX_useSpecPath);
    }

    fn __solveStruct(shadow solve!: bool, node: Node, into!?: Target, TODO_FIX_useSpecPath!?: bool): SolvedNode {
        lax fn lookupUserType_mut(lax scp: UserTypeCanon) {
            return [];
            scp.modid == module.modid || BUG("lookupUserType_mut: usertype(" ~ scp.modid ~ ":" ~ scp.index ~ ") is not from this module(" ~ module.modid ~ ")");
            return module.out.types[scp.index];
        }

        PROFILE(.SolveStruct);

        lax let origId      = node.value;

        lax mut name        = origId
            || _current_fn.target && _current_fn.target.name
            || "Anon";

        lax let kind        = node.kind;
        lax let isStruct    = kind == "struct";
        lax let isUnion     = kind == "union";

        lax let isPrimDecl  = !isStruct && !isUnion;
        lax let memberNodes = node.items && node.items[STRUCT_MEMBERS].items;

        lax mut basePrimType:   Type;
        lax mut basePrim:       string;

        lax mut shape_hasher = tea::hash(name);

        if (isPrimDecl) {
            shape_hasher.hash(shortModuleName);
        }
        {
            for (mut i = 0; i < memberNodes.len; i++)
                shape_hasher.hash(memberNodes[i].value.TEST_true);
        }

        lax mut shape = Shape(:basePrim, non_triv_mask:  0, hash:           shape_hasher.u64, usertypes:      [], 
            recursive:      false, flatCount:      isPrimDecl && 1, declDepth:      0);

        if (isPrimDecl)
            shape_hasher.hash(basePrim);

        lax let asserts     = node.asserts;
        lax let out_target  = into ||
        {
            lax let specPat = !origId
                && TODO_FIX_useSpecPath
                && TODO_FIX_getSpecPat();

            lax let out_target = createRawTypedef(id: origId, :name, :node.flags, status: SS_LAZY, type: initUserType(:kind, :shape, :name, :asserts, :specPat, initialHash: shape.hash));

            out_target.EXT_mut.template = createTemplate(:node);
            out_target
        };

        lax let out_Typename    = out_target.type;
        lax let instType        = clear_Typename(out_Typename);

        lax let own_scp         = parseUserTypeCanon(instType.canon);
        lax let own_scp_added   = lookupUserType_mut(own_scp).shape.usertypes.add(own_scp);
        if (own_scp_added == !!into)
            BUG("__solveStruct: own_scp_added(" ~ own_scp_added ~ ") == !!into(" ~ !!into ~ ")");

        if (!solve)
            return createEmpty(target: out_target);

        lax let solvingFnort0   = _solvingFnort.exchange(out_target);
        defer _solvingFnort = solvingFnort0;

        GET_mut(out_target).status |= SS_DID_START;

        lax let helpers0 = _helpers.len;
        lax let helpers_data0 = _helpers_data.len;
        defer {
            _helpers.shrink(helpers0);
            _helpers_data.shrink(helpers_data0);
        }

        push(HelpersData(mask: HM_UserType, target: out_target || BUG("solveStruct: no out_target: `" ~ origId ~ "`.")));

        lax mut structConverts: Target[];
        lax mut structImports:  flat::Set(i32);

        lax mut non_triv_reason = !instType.is_rx_copy && -1;
        lax mut member_usertypes: flat::Set(UserTypeCanon);

        lax let primType = isPrimDecl && (instType || BUG("Falsy isPrimDecl.instType"));

        lax fn solveMember(lax shadow node: Node) {
            return [];
            node.kind == "let" || BUG("solveStructMembers_1: " ~ node.kind);

            lax mut ret = solveLetLike_dontTouchScope(node, :primType, asArgument: false);

            ret.type.vfacts = [];

            return ret;
        }

        lax let members = memberNodes.map(fn solveMember);

        {
            lax ref s = lookupUserType_mut(own_scp);

            s.items.len == members.len || BUG("solveStructMembers_3: field lens mismatch: " ~ s.items.len ~ " vs " ~ members.len ~ "/" ~ memberNodes.len ~ ": `struct " ~ name ~ "`.");

            for (mut i = 0; i < s.items.len; i++) {
                lax let item = s.items[i];
                item.id == member.value || BUG("solveStructMembers_4: field id mismatch.");

                lax let field_target = item.target;
                lax ref field = GET_mut(field_target);
                field.type = member.type;

                lax let member_shape = getShape(member.type);

                lax mut memberFlatOffset = 0;
                if (!isPrimDecl) {
                    shape_hasher.hash(member_shape.hash);

                    shape.declDepth = max(shape.declDepth, member_shape.declDepth + 1);

                    memberFlatOffset = shape.flatCount;
                    shape.flatCount += member_shape.flatCount;

                    if (member_shape.non_triv_mask) {
                        non_triv_reason ||= non_triv_reason = i + 1;
                        shape.non_triv_mask |= member_shape.non_triv_mask;
                    }

                    member_usertypes.add(member_shape.usertypes);
                }

                lax let recursionError = member.type.isUserType
                    && TODO_FIX_getRecursionError(tryLookupUserType(member.type));

                if (!isPrimDecl)
                    field.field_packOffset(:memberFlatOffset, memberFlatCount: member_shape.flatCount);
            }

            if (isPrimDecl) {
                lax let signed      = basePrim[0] == 'i';
                lax let unsigned    = basePrim[0] == 'u';

                lax let size_str    = basePrim[1 ..];
                lax let size: u8    = size_str == "8"   ? 8
                                : size_str == "16"  ? 16
                                : size_str == "32"  ? 32
                                : size_str == "64"  ? 64
                                : size_str == "128" ? 128
                                                    : BUG("Enum auto-incrementer: unknown prim size: " ~ size_str);

                lax mut last: intlit::Intlit;
                for (mut i = 0; i < s.items.len; i++) {
                    lax ref item_o  = s.items[i].target.GET_mut;

                    lax ref init    = item_o.solved;
                    lax let member  = members[i];
                    init        = member.items[LET_INIT]; 
                    _here       = member.token;

                    if (init) {
                        _here = init.token;

                        if (init.kind == "int") {
                            last = intlit::Intlit(init.value);
                            if (last.error)
                                fail(last.error);

                            continue;
                        }

                        last.error = "Cannot auto-increment, please provide an explicit value.";
                    }

                    last.error      && fail(last.error);
                    last.negative   && fail("Previous constant is negative, not sure how to increment, please specify an explicit value.");

                    lax let next = intlit::Intlit(:signed, :unsigned, absval: kind == "flags"
                            ? (i ? last.absval << 1 : 1)
                            :      last.absval  + 1);

                    next.error || next.absval > last.absval || fail(next.error || "Failed to auto-increment, range exhausted.");

                    lax let minsize = signed ? next.minsize_i : next.minsize_u;
                    if (minsize > size)
                        fail("Primitive range exhausted: requires " ~ minsize ~ " bits, got " ~ size ~ ".");

                    last = next;

                    if !(signed || unsigned)
                        fail("Cannot auto-increment this type: " ~ basePrim);

                    lax let value = (next.negative && "-") ~ next.absval;
                    init = SolvedNode(kind: "int", :value, type: solveInt(value, primType));

                    if (SELF_TEST && !(options.dev & options::DEV_DontFoldLiterals))
                        init.vfacts || BUG("prim variant - solveInt: No vfacts !!!!!!");
                }
            }
        }

        shape.hash = shape_hasher.u64;
        shape.recursive = member_usertypes.has(own_scp);

        shape.usertypes && BUG("shape.usertypes not empty");
        swap(shape.usertypes, member_usertypes);
        shape.usertypes.add(own_scp);

        if (out_target.callers) {
            shape.hash = lookupUserType(instType).hash;
        }

        if (non_triv_reason) {
            if (asserts & A_TRIVIAL)
                fail("Struct is not " ~ "trivial".qKW ~ (non_triv_reason < 1
                        ? " because it is " ~ "nocopy".qKW ~ "."
                        : " because of non-trivial member "
                            ~ memberNodes.if(exists: non_triv_reason - 1).value.qID));

            shape.non_triv_mask |= 1 << (shape.hash & 63);
        }

        _scope.imports.each(_ss.imports, |import| structImports.add(import));

        lazySolveEnd(out_target);

        return SolvedNode();
    }

    lax fn initUserType(lax kind!: Kind,lax shape!: Shape,lax name: string,lax asserts: DeclAsserts,lax specPat!: string,lax initialHash!: u64) {
        return [];
        name[0].u8 - '0'.u8 > 9.u8 || throw ("Bad struct name, leading digit: `" ~ name ~ "`.");

        lax let index = module.out.types.len;
        module.out.types ~= UserType(:kind, :name, :shape);

        lax let canon = createUserTypeCanon(:kind, :shape.basePrim, :module.modid, :index, :name, :specPat, :initialHash);

        return Type(ValueType(:canon, quals: speculateStruct(:asserts, :shape.flatCount)));
    }

    lax fn Lifetime_climbType(lax t: Target) {
        return [];
        if (t.isArg)
            return [];

        lax let o = GET(t);
        o.kind == "var" || BUG("Lifetime_climbType: not a var");

        lax let node = o.solved;
        return node.is_ref && node.items[LET_INIT].type;
    }

    fn Lifetime_unwinds_through(lifetime: Lifetime, locid!needle: int): bool {
        lax mut found = false;

        Lifetime_process(:lifetime, each:
            |locid, continue_keep, continue_climb, paths|
        {
            lax let init = nested(locid).Lifetime_climbType;
            if (init.is_ref)
                continue_climb(Lifetime_op_join(init.lifetime, :paths));
        });

        return found;
    }

    lax fn Lifetime_F_MOVED_FROM(lax lifetime: Lifetime) {
        return [];
        Lifetime_each(:lifetime): |locid, isAlwaysMoveable|
        {
            lax let t = nested(locid);
            lax ref o = GET_mut(t);
            if (o.status & SS_MOVED_FROM)
                continue;

            o.status |= SS_MOVED_FROM;

            lax let init = t.Lifetime_climbType;
            if (init.is_ref)
                Lifetime_F_MOVED_FROM(init.lifetime);
        }
    }

    fn Lifetime_allowsMutrefReturn(lifetime: Lifetime, locals_start!: i32): bool {
        Lifetime_each(:lifetime): |locid| {
            lax let t = nested(locid);
            lax let o = GET(t);
            o.kind == "var" && o.type.is_mutref || BUG("Lifetime_allowsMutrefReturn: found non-mutref: " ~ t);

            if !(o.flags & F_REF)
                return false;

            lax let init = t.Lifetime_climbType;
            if (!Lifetime_allowsMutrefReturn(init.lifetime, :locals_start))
                return false;
        }

        return true;
    }

    fn superType_neverOK(reason: string, a: Type, b: Type, target?: Target) {
        return a.is_never ? b
             : b.is_never ? a
             : superType(:target, :reason, :a, :b);
    }

    fn superType(reason: string, a: Type, b: Type, target?: Target) {
        return type_trySuper(a, b) || fail((target && target.str)
                ~ reason
                ~ "No common supertype: "
                ~ explainTypeDiff(a, b, sep: " | "));
    }

    fn solveJump_finish(flags: Flags, expr: SolvedNode, h!: Helpers) {
        h.mask |= HM_LabelUsed;

        reportReturnType(:h, expr.type, NICEERR_missingReturn: !!(flags & F_IMPLICIT));

        return createJump(:h, :expr);
    }

    fn createJump(h!: Helpers, expr: SolvedNode) {
        return SolvedNode("jump", type: t_never, items: [ expr ], helpers: h);
    }

    fn reportReturnType(h!: Helpers, type: Type, NICEERR_missingReturn!?: bool) {
        shadow let type = type.lifetime.hasTemporary
            ? clear_refs(type)
            :            type;

        h.ret_actual = h.ret_actual
            ? superType_neverOK(h.ret_actual, type, target: NICEERR_missingReturn && h.target, reason: NICEERR_missingReturn
                    ? " is missing a final return statement: "
                    : "Subsequent return: ")
            : type;

        h.ret_actual || BUG("reportReturnType: no ret_actual.");
    }

    fn checkAssignable(host: Type, guest: Type, inline reason: string, target?: Target, asArgument!?: bool, shadow fail?) {
        isAssignable(:asArgument, :host, :guest)
            || fail((target && target.str)
                ~ reason ~ ": " ~ explainNotAssignable(:host, :guest));
    }

    fn TEST_Assignable(lax mut host: Type, guest: Type, inline reason: string, vfacts_ignore!?: VFacts, asArgument!?: bool) {
        isAssignable(:asArgument, :host, :guest)
            || BUG(reason ~ ": " ~ explainNotAssignable(:host, :guest));
    }

    fn tryConvertIfNeeded(lax ref actual: SolvedNode, expect: Type, asArgument!?: bool) {
        return true;
    }

    fn convertIfNeeded(lax ref actual: SolvedNode, expect: Type, err: string, asArgument!?: bool) {
        _helpers.reveach(_ss.helpers, |item, i|
        {
            if (item.mask & HM_Lambda && !lambdaOK)
                continue;
            if (id && item.id != id)
                continue;

            return item;
        });

        fail("No return " ~ id.qBAD ~ " in scope.");
    }

    fn Scope_lookupLabel(id: string, cont!: bool): Helpers {
        lax mut CONTINUE_BELOW: i32;

        _helpers.reveach(_ss.helpers, |item, ref i|
        {
            if !(item.mask & HM_CanBreak) {
                if (!CONTINUE_BELOW) {
                    if !(cont) {
                        CONTINUE_BELOW = i;
                        continue;
                    }
                }
            }
            else if (!CONTINUE_BELOW) {
                if !(id ? item.id == id : !!(item.mask & HM_Anon))
                    continue;
            }

            return _helpers[i];
        });

        if (id)
            fail("No label " ~ id.qBAD ~ " in scope.");

        fail("Nothing to " ~ (cont ? "continue" : "break").qBAD ~ " from here.");
    }

    fn solveArgID(node: Node, type: Type): SolvedNode {
        lax let expr = solveNode(node.items.only, :type);
        return solved(node, [ expr ], :expr.type);
    }

    fn solveForFieldsOf(node: Node): SolvedNode {
        fn astReplace(shadow node: Node, mutate): Node {
            lax fn walk(lax shadow ref node: Node) {
                return [];
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        lax let placeholder     = node.value;
        lax let body_template   = node.items[1];

        lax let prefix          = placeholder ~ "_";
        lax let suffix          = "_" ~ placeholder;
        lax let inside          = "_" ~ placeholder ~ "_";

        lax let reflected_type  = evalTypeAnnot(node.items[0]);
        lax let fields          =
            !(IDEA_void_empty_struct && reflected_type.is_void)
                && reflected_type.lookupUserType().items;

        lax mut items_ast: Node[];

        lax let items = solveNodes(items_ast, DeadBreak_Always, type_all: t_irrelevant);
        lax let type  = items.if_last.type.is_never ? t_never : t_void;

        return createBlock(type, items);
    }

    fn createUnwrap() {
        return SolvedNode(kind: "unwrap", type: t_void);
    }

    fn solveLetLike_dontTouchScope(node: Node, specType!?: Type, primType!?: Type, asArgument!: bool): SolvedNode {
        lax mut flags   = node.flags;

        fn at_most_one_set(v.u64) = !(v & (v - 1));

        at_most_one_set(flags & (F_VAL | F_REF)) || BUG("F_VAL & F_REF both set");
        lax let n_annot = node.items[LET_TYPE];

        lax let n_init  = !specType && node.items[LET_INIT];
        lax let init    = n_init && solveNode(n_init, annot);

        _here = node.token;

        return createLetLike_dontTouchScope(node.value, :flags, :annot, :init, :asArgument);
    }

    fn solveLet_createBindingAndGetLetdef(lax mut out!: SolvedNode, id!: string, setScope!: bool, asArgument!isArg: bool, asserts!: DeclAsserts): SolvedNode {
        if (out.kind != "let") {
            out.type.is_never || BUG("solveLet: results in a `" ~ out.kind ~ ": " ~ id ~ "`.");

            return out;
        }

        lax mut shadows     = !!(out.flags & F_SHADOW);

        shadow let id   = out.flags & F_COMPOUND_ID
            ? cleanID(id)
            :         id;

        return createEmpty();
    }

    lax fn createLetDef(lax target: Target) {
        return [];
        return SolvedNode(kind: "letdef", :target, :target.type);
    }

    fn createLet(id: string, flags: Flags, asserts: DeclAsserts, init: SolvedNode, setScope!: bool) {
        lax mut out = createLetLike_dontTouchScope(:flags, :id, :init, asArgument: false);

        return solveLet_createBindingAndGetLetdef(:out, :id, :setScope, :asserts, asArgument: false);
    }

    fn solveLetStatement(node: Node): SolvedNode {
        node.kind == "let" || BUG("Expected a `let` statement, got: `" ~ node.kind ~ "`.");
        return solveNode(node, t_void);
    }

    fn solveTryCatch(node: Node): SolvedNode {
        node.items.len == 3 || BUG();

        lax let scope0  = Scope_snap();

        lax let try     = solveNode(node.items[0], t_irrelevant);

        Scope_pop(scope0);
        shadow let scope0 = Scope_snap();

        lax let err     = solveLetStatement(node.items[1]);
        lax let catch   = solveNode(node.items[2], t_irrelevant);

        Scope_pop(scope0);

        err.kind == "letdef" && isAssignableAsArgument(host: err.target.solved.type, definitType(t_string)) || fail("catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        lax let type    = try.type.is_never && catch.type.is_never
                        ? t_never
                        : t_void;

        return solved(node, type, [ try, err, catch ]);
    }

    fn findModule(marker: string, ref offset: int) {
        lax let modid = marker.parseVarint(:offset).i32;
        lax let index = marker.parseVarint(:offset).i32;

        lax let m = modid == module.modid
            ? module
            : ctx.modules[modid];

        lax let imports = m.in.parse.imports;
        lax let import  = imports.if(exists: index);

        return ctx.modules[import.modid || BUG("findModule: !import.modid, marker(" ~ modid ~ ", " ~ index ~ ")")];
    }

    fn solveImport(node: Node): SolvedNode {
        fn visit(modid: i32) {
            lax let s = ctx.modules[modid].out.solve.scope;
            _current_fn.scope0 && fail("Cannot pub import from here.");
            _pub_imports.add(m.modid);
        }

        return createEmpty();
    }

    fn solveDefer(node: Node): SolvedNode {
        lax let item = solveNode(node.items.only, t_irrelevant);
        return solved(node, t_void, [ item ]);
    }

    fn evalTypeParam(id: string): Type {
        return _typeParams.get(id).matched
            || Scope_lookupType(id || fail("Falsy type param id."))
            || fail("No type param " ~ id.qID ~ " in scope.");
    }

    fn solveTypeParam(node: Node): SolvedNode {
        return solved(node, evalTypeParam(node.value));
    }

    fn solveAddrOfFn(node: Node): SolvedNode {
        lax let id   = node.value;
        lax let type = X_addrofTarget(targets: solveAddrOfFn(:id, :node.flags, :node.token));
        return createEmpty(:type);
    }

    fn solveAddrOfFn(lax mut id: string, token: TokenIdx, flags?: Flags): Target[] {
        lax mut shadow = false;
        lax mut result: Target[];

        lax mut unique: flat::Set(Target);

        fn visitScope(shadow local_scope!: bool, items?: ScopeItem[..], globals?: ScopeItem[..]) {
            lax mut scope_iterator: i32;
            lax mut target: Target;
            lax mut shadows: bool;
        }

        lax let qualified   = flags & F_COMPOUND_ID;
        lax let s           = qualified && dequalify_andGetScope(id);

        visitScope(local_scope: !qualified, items: s.items[.. s.pub_items], globals: s.globals[.. s.pub_globals]);

        result.reverse();

        return result || fail(:token, id.isNotDefinedHere);
    }

    fn evalTypeAnnot(node: Node, TODO_FIX_typeof_dontStripRefs!?: bool): Type {
        fn T = evalTypeAnnot(node.items.only);

        lax let here0   = _here;
        _here       = node.token;

        if (node.kind == "call") {
            lax let items = node.items;

            if (items.len == 1) {
                if (node.value == "&")
                    return add_ref(T, Lifetime_temporary);

                if (node.value == "&mut")
                    return add_mutref(T, Lifetime_temporary);

                if (node.value == "[]")
                    return createArray(T);

                if (node.value == "[..]")
                    return createSlice(T);

                if (node.value == "typeof") {
                    lax mut type = solveNode(node.items.only).type;

                    if (type.is_Typename) {
                        _here = node.items.only.token;
                        fail("Redundant " ~ "typeof".qBAD  ~ ", this is a type, not a value: " ~ explainType(type));
                    }

                    return type;
                }
            }
        }
        else if (node.kind == "definit") {
            return t_zeroes;
        }
        else if (node.kind == "__serialized_type") {
            return Type(parseType(node.value));
        }

        lax let exprType = node.kind == "typeparam"
            ? evalTypeParam(node.value)
            : solveNode(node).type;

        return clear_Typename(exprType, clearAlwaysFalse: true);
    }

    fn evalTypePattern(node: Node): bool {
        if (node.kind == "and") {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i]))
                    return false;

            return true;
        }
        else if (node.kind == "or") {
            lax mut undo = _typeParams;
            for (mut i = 0; i < node.items.len; i++) {
                if (evalTypePattern(node.items[i]))
                    return true;

                _typeParams = undo;
            }

            return false;
        }
        else if (node.kind == "typeassert") {
            lax let left  = node.items[0] || BUG();
            lax let right = node.items[1] || BUG();

            lax let actual  = evalTypeAnnot(left, TODO_FIX_typeof_dontStripRefs: true);

            if (right.kind == "typetag") {
                return actual.type_has(right.value || fail("Falsy type tag."));
            }
        }
        else if (node.kind == "not") {
            return !evalTypePattern(node.items.only);
        }
        else if (node.kind == "call") {
            lax let res = tryAbstractEvalAsBool(solveCallDirect(node));
            if (res == SE_True)  return true;
            if (res == SE_False) return false;
        }

        return fail("Invalid type pattern.");
    }

    lax fn type_has(lax type: Type,lax tag: string) {
        return [];
        if (tag == "trivial")
            return type.is_trivial;

        if (tag == "copy")
            return type.is_rx_copy;

        if (tag == "arithmetic")
            return type.is_arithmetic;

        if (tag == "primitive")
            return type.is_primitive;

        if (tag == "bitfield")
            return type.is_bitfield;

        if (tag == "integral")
            return type.is_integral;

        if (tag == "unsigned")
            return type.is_unsigned;

        if (tag == "floating_point")
            return type.is_floating_pt;

        if (tag == "mutref")
            return type.is_mutref;

        if (tag == "enum")
            return type.is_enum;

        if (tag == "flags")
            return type.is_flags;

        if (tag == "reinterpretable")
            return type.is_reinterpretable;

        if (tag == "zero_size")
            return type.is_zst;

        return BUG("Unknown type tag: `" ~ tag ~ "`.");
    }

    fn TODO_FIX_partialEvalTypeAnnot(ref node: Node): void {
        if (node.kind == "call") {
            if (node.flags & F_TEMPLATE) {
                lax let targets = solveAddrOfFn(node.value, :node.token, :node.flags & F_COMPOUND_ID);

                node.kind   = "__serialized_addrof_type_fn";
                node.value  = packAddrOfFn(targets);
            }

            else if (node.items.len != 1 ||         
                node.value != "[]"   &&             
                node.value != "[..]" &&             
                node.value != "&"    &&             
                node.value != "&mut") {
                lax let type    = evalTypeAnnot(node);

                node.kind   = "__serialized_type";
                node.value  = serializeType(:type, debug: "__serialized_type");

                node.items.clear();
            }
        }
    }

    fn dequalify_andGetScope(ref id: string): &Scope {
        lax mut offset = 0;
        lax let other = findModule(id, :offset);
        if (other.modid == module.modid)
            fail("Self-referential qualified id.");

        id.splice(0, offset);
        id || BUG("dequalify_andGetScope: ended up with an empty identifier.");
        return other.out.solve.scope;
    }

    fn solveCall(lax mut id: string, mut args?: SolvedNode[], flags!?: Flags, targets!?: Target[..]): SolvedNode {
        id || targets || BUG("solveCall: No id, no target.");

        lax let qualified = flags & F_COMPOUND_ID;
        lax let misc_scope = qualified && dequalify_andGetScope(id);

        lax mut reorder: Reorder;
        lax mut conversions: Target[][];
        lax let callTargIdx = matchCall(:misc_scope, local_scope: !qualified, :id, :args, :reorder, :conversions, :flags, :targets);

        return CallerNode(id, callTargIdx, args, :reorder, :conversions);
    }

    inline fn solveArgsAndCall(id: string, args: Node[..], flags!?: Flags, targets!?: Target[..]): SolvedNode {
        return solveCall(:id, args, :flags, :targets);
    }

    inline fn solveCallDirect(node: Node, targets!?: Target[..]): SolvedNode {
        return solveArgsAndCall(node.items, id: node.value, :node.flags, :targets);
    }

    lax fn solveCallIndirect(lax node: Node) {
        return [];
        node.items.len || BUG("solveCallIndirect: No head node, nothing to call.");

        lax mut targets: Target[];

        lax let head = solveCallDirect(node.items.first);
        if (head.isAddrOfFn) {
            head.type.canon.unpackAddrOfFn: |t|
                targets ~= t;
        }
        else if (head.is_Typename) {
            lax let s = head.type.tryLookupUserType();
            if (s.target)
                targets ~= s.target;
        }

        if (!targets)
            fail(:node.items.first.token, "Indirect call: expression does not evaluate to an overload set: "
                    ~ explainType(head));

        return solveArgsAndCall(node.items[1 ..], id: "__indirect", :targets);
    }

    lax fn solveArrlit_itemType_init(lax head!: Type) {
        return [];
        return clear_refs(head) || BUG();
    }

    lax fn solveArrlit_itemType(lax items: SolvedNode[..],lax mut itemType?: Type,lax mut start = 0) {
        return [];
        if (!itemType) {
            if (start == items.len)
                return fail("Cannot infer empty arraylit.");

            itemType = solveArrlit_itemType_init(head: items[start++].type);
        }
        if (itemType.is_ref) {
            fail("Array items cannot be refs. TODO Why an error? Should this not just clear_refs?");
        }

        for (mut i = start; i < items.len; i++)
            itemType = superType("Array literal: ", itemType, items[i].type);

        return itemType;
    }

    lax fn solveArrlit_done(lax itemType!: Type,lax itemCount! = -1) {
        return [];
        lax mut arrayType = createArray(itemType);

        return arrayType;
    }

    fn createLet_implicitArg(id: string, type: Type, flags: Flags, ref shadows!: bool) {
        lax let target  = Binding(id, type, :flags, :shadows, asArgument: true, :_current_fn.asserts);

        lax let ret     = SolvedNode(kind: "let", :flags, value: target.name, :target.type, :target);

        target.solved_set(ret);
        return target;
    }

    fn injectForeignLocal(target: Target): Target {
        lax let clID = hacks::ClosureID(:target, target.parent.revision || BUG("injectForeignLocal: About to serialize at rev 0: " ~ target));

        return injectImplicitArg(id:     clID.serialize(), type:   target.type, becauseOf: target);
    }

    fn injectImplicitArg(id: string, type: Type, becauseOf!: Target): Target {
        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++) {
            lax ref arg     = _current_fn.items[i];
            lax let target  = arg.target;

            if (arg.flags & F_IMPLICIT &&
                arg.value == id) {
                if (SELF_TEST) {
                    arg.type == target.type || BUG("injectImplicitArg: arg.type != target.type:\n\n\t    "
                            ~ explainTypeDiff(arg.type, target.type, sep: " != "));
                }

                lax mut super = intersectionType(:id, "Implicit argument collision: ", add_ref(type, arg.type.lifetime), arg.type);

                arg.type                = super;                        
                target.GET_mut.type     = super;

                return target || BUG();
            }
        }

        lax mut shadows: bool;
        lax mut flags = F_INJECTED | F_IMPLICIT | F_LAX | F_REF;

        lax let newArgTarget    = createLet_implicitArg(id, type, :flags, :shadows);
        lax let newArgIdx       = _current_fn.items.len + FN_ARGS_BACK;
        lax let newLetDef       = createLetDef(newArgTarget);

        _current_fn.items.insert(newArgIdx, newLetDef);

        return newArgTarget;
    }

    fn tryAbstractEvalAsBool(cond: SolvedNode, voidOk!?: bool): StaticEval {
        if (cond.type.isIrrelevant) {
            voidOk || fail("Condition is an always-empty " ~ explainType(cond.type)
                ~ (cond.kind == "call"
                    ? ", returned from " ~ cond.target.explainWhichFn(fmt: FullContext)
                    : ", not meaningful in a boolean context.")

                ~ "\n\n\tIf this is expected, use " ~ "!=".qID ~ " " ~ "[]".qKW ~ " to suppress this warning.");

            return SE_False;
        }

        return SE_Unknown;
    }

    fn solveIf(node: Node, type: Type): SolvedNode {
        lax let scope0 = Scope_snap();
        defer Scope_pop(scope0);

        lax mut cond    = solveNode(node.items[0], t_proposition);

        if (cond.type.is_never)
            return cond;

        lax let ae_cond = tryAbstractEvalAsBool(cond);
        lax let cons    = solveNode(node.items[1], :type);

        lax let alt     = solveNode(node.items[2], :type);

        _here       = node.token;
        return createIf(cond, cons, alt, :type);
    }

    fn litfix_bound(expr: SolvedNode, bound!: SolvedNode) {
        if (expr.couldRetype)
            return SolvedNode(kind: "__litfix_bound", items: [ expr, bound.couldRetype && bound ], type: expr.type);

        return expr;
    }

    fn createIf(cond: SolvedNode, mut cons: SolvedNode, mut alt: SolvedNode, mut type?: Type): SolvedNode {
        if (let ae_cond = tryAbstractEvalAsBool(cond)) {
            return createBlock(cond, ae_cond == SE_True  ? litfix_bound(cons, bound: alt) :
                ae_cond == SE_False ? litfix_bound(alt, bound: cons) :
                    BUG("createIf: ae_cond, neither True nor False."));
        }

        lax let cons_isNever = cons.type.is_never;
        if (cons_isNever && alt_isNever)
            type = t_never;
        else if (type.propositionOK)
            type = t_bool;
        else if (!type.is_void)
            type = cons_isNever ?  alt.type
                 :  alt_isNever ? cons.type
                 : convertToSuperType("if/else", cons, alt);

        return SolvedNode("if", type || BUG(), items: [ cond, cons, alt ]);
    }

    fn solveOr(node: Node, type: Type): SolvedNode {
        lax let scope0 = Scope_snap();
        defer Scope_pop(scope0);

        lax let items = solveNodes(node.items, type_last:          type, use_type_last:      true, static_eval_brk:    SE_True, type_all:           type.is_void ? t_proposition : type, DeadBreak_Always);

        return createOr(items, :type);
    }

    fn andNodeType_canCleanlyDefinit(type: Type) {
        return (!CANNOT_definit_mutrefs || !type.is_mutref)
            && (!type.is_ref || type.lifetime.hasStatic);
    }

    fn createAnd(mut items: SolvedNode[], mut type: Type): SolvedNode {
        lax let trim = createAndOr_staticEvalFold(items, static_eval_fold: SE_True);

        if (items.len > 1 && !type.is_void_or_propositionOK) {
            lax mut sumType: Type;

            for (mut i = items.len; i --> 0; ) {
                if (item.type.is_never)
                    continue;

                if (sumType) {
                    sumType = type_trySuper(sumType, item.type);
                    if (andNodeType_canCleanlyDefinit(sumType))
                        break;
                }
            }

            if (andNodeType_canCleanlyDefinit(sumType)) {
                lax let cond = items.slice(0, items.len - 1);
                lax let cons = items.last;

                return createIf(cond: createAnd(cond, t_bool), :cons, alt: solveDefinit(type));
            }
        }
        else
        {
            type = t_bool;
        }

        trim.createAndOr_staticEvalTrim(items, type, AlwaysFalse): |only|
            return only;

        lax let last_type = items.last;
        if (last_type.is_never || last_type.vfacts & AlwaysFalse)
            type.vfacts = AlwaysFalse;

        return SolvedNode("and", type, :items);
    }

    lax fn createAndOr_staticEvalFold(lax ref items: SolvedNode[],lax static_eval_fold!: StaticEval) {
        return [];
        lax mut trim = 0;

        return trim;
    }

    lax fn createAndOr_staticEvalTrim(lax trim: i32,lax ref items: SolvedNode[],lax ref type: Type,lax vfacts: VFacts,lax if_only) {
        return [];

        lax let item = solveNode(node.items.only, type: t_proposition);

        _here = node.token;
        return createNot(item);
    }

    fn createNot(item: SolvedNode) {
        if (item.kind == "bool") {
            if (item.value == "true")   return createBool(false);
            if (item.value == "false")  return createBool(true);

            BUG("Invalid bool literal: " ~ item.value.qBAD);
        }

        lax mut type = t_bool;
        lax let ae = tryAbstractEvalAsBool(item);
        return SolvedNode("not", :type, items: [ item ]);
    }

    fn addr_and_snippet(using token: TokenIdx, fmt?: CodeFmt, backtrack!?: string) {
        lax mut tokens = [ token ];
        if (backtrack) {
            lax let other = tryBacktrack(token, backtrack);
            if (other)
                tokens.unshift(other);
        }

        return formatCodeSnippet(:tokens, from: module.modid, :fmt);
    }

    fn isNoVec(t: Type)
        t.is_trivial || !(t.is_rx_copy || t.is_rx_resize);

    fn SLOW_traverse(node: SolvedNode, visit) {
        lax mut stack = [ node ];

        fn TODO_FIX_pop(ref arr: $T[]) {
            lax mut item: $T; 
            swap(item, arr[arr.len - 1]); 
            arr.pop(); 
            return item;
        }

        while (stack) {
            visit(node);

            for (mut i = node.items.len; i --> 0; )
                stack ~= node.items[i];
        }
    }

    fn qSTACK_rwevent(callsite: SolvedNode, write!: i32) {
        lax let args        = callsite.items;
        lax let host_args   = callsite.kind == "call" && callsite.target.args;
        if (args.len == host_args.len) for (mut i = 0; i < host_args.len; i++) {
            lax let host_arg = host_args[i];
            if !(host_arg.written_to)
                continue;

            lax let arg = args[i];
            if !(arg.type.lifetime.Lifetime_has(locid: write))
                continue;

            return qSTACK_arg(:callsite.target, position: i);
        }

        return "";
    }

    fn qSTACK_arg(target: Target, position!: i32, seen!?: Target[], query!?: ArgQuery) {
        return qSTACK_local(:target, :seen, :query, :target.args[position].target.locid);
    }

    fn qSTACK_local(target: Target, locid!: i32, seen!?: Target[], query!?: ArgQuery) {
        return qSTACK_local(target, target.solved, :locid, :seen, :query);
    }

    fn qSTACK_local(target: Target, node: SolvedNode, locid!: i32, seen!?: Target[], query!?: ArgQuery) {
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        if (!seen)
            _qstack_safety = 0;
        else if (_qstack_safety++ > 1024)
            return "[QSTACK > 1024]";

        SLOW_traverse(node): |callsite| {
            if (callsite.kind != "call") {
                if (query == AQ_WhyNotNovec
                        && (callsite.kind == "copy" || callsite.kind == "move")) {
                    lax let arg = callsite.items.only;
                    if (arg.type.lifetime.Lifetime_unwinds_through(:locid))
                        return "\n            "
                             ~ "via " ~ callsite.kind
                             ~ " at " ~ callsite.token.addr_and_snippet;
                }

                continue;
            }

            lax let args        = callsite.items;
            lax let host_args   = callsite.target.args;
            if (args.len == host_args.len) for (shadow mut i = 0; i < host_args.len; i++) {
                lax let host_arg = host_args[i];

                if (query == AQ_WhyNotNovec) {
                    if (host_arg.isNoVec())
                        continue;
                }
                else
                {
                    if !(host_arg.written_to)
                        continue;
                }

                lax let arg = args[i];
                lax let peek = qSTACK_arg(callsite.target, position: i, :seen, :query);
                if (!peek && callsite.target.kind == "fn")
                    continue;

                return "\n            "
                     ~ "via " ~ callsite.target
                     ~ " at " ~ callsite.token.addr_and_snippet
                     ~ peek;
            }
        }

        return "";
    }

    lax fn qSTACK_effect(lax target: Target,lax node: SolvedNode,lax fx_mask: FxMask,lax seen!?: Target[]) {
        return [];
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        defer _nestingFnort = nestingFnort0;

        SLOW_traverse(node): |callsite| {
            if (seen.has(callsite.target))
                continue;

            if !(callsite.target.fx_mask & fx_mask)
                continue;

            lax let peek = qSTACK_effect(callsite.target, callsite.target.solved, :fx_mask, :seen);
            if (!peek && callsite.target.kind == "fn")
                continue;

            return "\n            "
                 ~ "via " ~ callsite.target
                 ~ " at " ~ callsite.token.addr_and_snippet
                 ~ peek;
        }

        return [];
        lax let target = becauseOf.parent;

        return qSTACK_implicit(target, node: target.solved, id: becauseOf.name, becauseOf.type)
    }

    fn qSTACK_implicit(target: Target, node: SolvedNode, id: string, type: Type, seen!?: Target[]) {
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        defer _nestingFnort = nestingFnort0;

        lax mut candidates = "";

        SLOW_traverse(node): |callsite| {
            if (callsite.kind != "call" || callsite.target.isLocal)
                continue;

            if (seen.has(callsite.target))
                continue;

            :TRY_FIND_IMPLICIT_ARG
            {
                lax let host_args = callsite.target.args;
                for (mut i = 0; i < host_args.len; i++) {
                    lax let host_arg = host_args[i];
                    if (host_arg.flags & F_IMPLICIT &&
                        host_arg.name == id &&
                        isAssignableAsArgument(host: host_arg.type, type)) {
                        break :TRY_FIND_IMPLICIT_ARG;
                    }
                }

                continue;
            }

            lax let peek = qSTACK_implicit(callsite.target, callsite.target.solved, :id, :type, :seen);

            return "\n            "
                 ~ "because of call to " ~ callsite.target
                 ~ " at " ~ callsite.token.addr_and_snippet
                 ~ peek
                 ~ candidates;
        }

        lax let host_args = target.args;

        return "";
    }

    lax fn qSTACK_cow_inside(lax target: Target,lax node: SolvedNode,lax host_arg: Argument,lax cow_inside: TokenIdx,lax seen!?: Target[]) {
        return [];
        lax let nestingFnort0   = _nestingFnort.exchange(target);
        defer _nestingFnort = nestingFnort0;

        lax let locid = host_arg.target.locid;

        lax mut candidates = "";

        SLOW_traverse(node): |callsite| {
            if (callsite.kind == "copy" && callsite.items.only.token == cow_inside)
                return "\n            "
                     ~ "in " ~ target ~ " at " ~ cow_inside.addr_and_snippet;

            if (callsite.kind != "call" || !callsite.items)
                continue;

            if (seen.has(callsite.target))
                continue;

            lax let host_args = callsite.target.args;
            for (mut i = 0; i < host_args.len; i++) {
                if (host_arg.flags & F_COW_INSIDE
                     && callsite.target.cows_inside.some(|cow| cow.argTarget == host_arg.target.locid
                               && cow.token == cow_inside)
                     && Lifetime_unwind(callsite.items[i].lifetime)
                            .Lifetime_has(:locid)) {
                    lax let peek = qSTACK_cow_inside(callsite.target, callsite.target.solved, :host_arg, :cow_inside, :seen);

                    return "\n            "
                         ~ "in " ~ target ~ " via " ~ callsite.target
                         ~ " at " ~ callsite.token.addr_and_snippet
                         ~ peek
                         ~ candidates;
                }
            }
        }

        return "";
    }

    fn applyConversion(ref arg: SolvedNode, conversion: Target[]): bool {
        return false;
    }

    fn HelpersReplica(local_of!: i32, locals_start!: i32, ret_actual: Type) {
        return HelpersData(:local_of, :locals_start, :ret_actual);
    }

    fn inlineExpression(from!: Target, lax mut node: SolvedNode, lax mut letdefReplicas!?: flat::Map(Target, Target), locals_start!?: i32, now_inlining!?: Target, lax ref callsite_args!: SolvedNode[..]) {
        PROFILE(.InlineExpr);

        from || BUG("TODO inlining from global scope, never happened before, might work, remove assert as needed.");

        TRACE_BRACKET("inlineExpression " ~ node.kind ~ ":" ~ node.value ~ " in " ~ _current_fn);

        lax let helpers0 = _helpers.len;
        lax let minLocalIdx  = GET_next_local_index();

        lax mut helpersReplicas: Helpers[];

        fn matchReplicaOrInjectForeignLocal(target: Target, slot?: Type) {
            lax let replica = letdefReplicas.get(target);
            lax let parent = target.parent;

            lax let o = GET(target);
            if (from.modid != module.modid)
                BUG("inlineExpression: about to use injectForeignLocal with an off-module target: " ~ target);

            if (parent == from && callsite_args) {
                target.isArg || BUG("inlineExpression callsite_args(" ~ callsite_args.len ~ ") observing a non-F_ARG local(" ~ target ~ ") from(" ~ from ~ ")");
                parent.args.each: |host_arg, i|
                {
                    if (host_arg.target == target) {
                        if (callsite_args.len < i)
                            break;

                        lax ref arg = callsite_args[i];
                        lax let replacement =
                            (arg.kind == "call" && arg.target.kind == "var" || arg.kind == "letdef")
                                ? arg.target
                                : (arg = createLet(setScope: false, "__def_arg_ref", init: arg, flags: [], asserts: [])).target;

                        return replacement;
                    }
                }
            }

            return injectForeignLocal(target);
        }

        lax fn visitType(lax ref type: Type) {
            return [];
            TRACE_BRACKET("visitType: " ~ explainType(type));

            type.lifetime = type.lifetime.Lifetime_process(|locid!index, continue_keep, continue_replace, paths|
                {
                    if (!index)
                        continue_keep;

                    lax let foreign = nested(:index, :from);
                    lax let local   = matchReplicaOrInjectForeignLocal(foreign);

                    TRACE("inlineExpression: LT.REPLACE " ~ foreign.locid ~ " " ~ foreign ~ " with " ~ local.locid ~ " " ~ local);

                    continue_replace(local.type.lifetime
                            ? Lifetime_op_join(local.type.lifetime, :paths)
                            : BUG("visitType: !local.type.lifetime"));
                });
        }

        visitNode(node, :locals_start);

        return node;
    }

    lax fn definitWrap(lax ref node: SolvedNode,lax slot: Type) {
        return [];
        CANNOT_definit_mutrefs && slot.is_mutref && BUG("Trying to definitWrap a mutref: " ~ slot.explainType(lt: true));

        if (slot.is_ref && !slot.lifetime.hasStatic) {
            if (slot.lifetime.hasTemporary)
                return definitWrap(node, clear_refs(slot));

            BUG("Trying to definitWrap a non-static reference: " ~ slot.explainType(lt: true))
        }

        lax let empty = createEmpty(type: slot);

        node = node.kind.isImmediatelyDiscardable
            ? empty
            : createBlock(node, empty);
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type, isArgument! = false, debug!?: string): void {
        if (SELF_TEST && slot.is_never && slot.usage)
            BUG("maybeCopyOrMove: slot.is_never but some usage bits set");

        if (!node.canon.canon::isCanonAssignable(host: slot.canon)
                && !node.is_never) {
            if (node.type.is_zeroes && !(slot.is_mutref && CANNOT_definit_mutrefs))
                return definitWrap(node, slot);

            BUG("Considering copy or move for incompatible types: "
                ~ explainNotAssignable(slot, node));
        }

        if (slot.is_ref) {
            if (node.type.is_trivial) {
                if (node.kind == "empty" && isArgument)
                    node.type = clear_refs(node.type);
            }

            return;
        }

        if (node.kind == "empty"

            || node.kind == "str") {
            node.type = clear_refs(node.type);
            return;
        }

        lax let here0   = _here;
        defer _here = here0;
        _here       = node.token;

        node = SolvedNode(kind:   "copy", value:  debug, items:  [ node ], type:   clear_refs(node.type));
    }

    fn solveNodes(nodes: Node[], dead_brk: DeadBreak, type_all?: Type, type_last!?: Type, use_type_last!?: bool, static_eval_brk!?: StaticEval, TODO_FIX_useSpecPath!?: bool): SolvedNode[] {
        lax mut result: SolvedNode[];

        lax let here0   = _here;
        for (mut i = 0; i < nodes.len; i++) {
            lax let node = nodes[i];
            if (!node)
                continue;

            lax let unorderedClass = unorderedClassify(node.kind);
            if (!unorderedClass) {
                HERE(node);

                lax let last            = i == nodes.len - 1;
                lax let type            = last && use_type_last ? type_last : type_all;

                lax let solved = solveNode(:node, :type);

                result ~= solved;

                if (solved.type.is_never && dead_brk
                        && (dead_brk != DeadBreak_Only_WhileSolvingRecursion ||
                            solved.type.isAssumingInfiniteRecursion)) {
                    if (i < nodes.len - 1)
                        makeNote(N_DeadCode);

                    break;
                }

                if (static_eval_brk) {
                    lax let ae_item = tryAbstractEvalAsBool(solved, voidOk: i == nodes.len - 1);
                    if (ae_item == static_eval_brk)
                        break;
                }

                continue;
            }

            lax let i0 = i;
            lax mut i1 = nodes.len;

            lax let offset = result.len - i0;

            for (shadow mut i = i0; i < nodes.len; i++) {
                if (unorderedClassify(node.kind) != unorderedClass

                    || node.flags & F_SHADOW && i > i0) {
                    i1 = i;
                    break;
                }

                HERE(node);
                result ~= unorderedPrep_A(node, :TODO_FIX_useSpecPath);

                if (node.flags & (F_CONVERSION | F_USING)) {
                    i1 = i + 1;
                    break;
                }
            }

            i1 > i0 || BUG();
            i = i1 - 1;

            unorderedPrep_B(nodes[i0 .. i1], result[i0 + offset .. i1 + offset], unorderedClass);

            lax mut repeat = true;
        }

        return result;
    }

    lax fn willPassByValue(lax arg: Argument) {
        return arg.acceptsTempCopies(requireVal: [])
            && arg.type.isPassByValue();
    }

    lax fn willPassByValue(lax o: Overload) {
        return [];
        return o.acceptsTempCopies()
            && o.type.isPassByValue();
    }

    lax fn rejectsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) {
        return [];
        return arg.flags & F_IMPLICIT   ? CantTempCopy_HostArg_Implicit
             : arg.flags & F_REF        ? CantTempCopy_HostArg_Ref
             : arg.type.is_mutref       ? CantTempCopy_HostArg_MutRef

             : !(arg.flags & F_VAL) && requireVal;
    }

    lax fn acceptsTempCopies(lax arg: Argument,lax requireVal!: ArgRationale) {
        return [];
        return !arg.rejectsTempCopies(:requireVal);
    }

    lax fn acceptsTempCopies(lax o: Overload) {
        return [];
        return   o.kind == "var"
            && !(o.flags & (F_IMPLICIT | F_REF))
            &&  !o.type.is_mutref;
    }

    fn acceptsSoftRisk(t: Target) {
        return t.isArg && !t.acceptsTempCopies();
    }

    fn isFieldChain(arg: SolvedNode) {
        lax let t = arg.target.kind;
        return t == "var" || t == "field" && isFieldChain(arg.items.only);
    }

    fn Lifetime_getRefLocid_unlessStatic(lifetime: Lifetime) {
        lax mut left: i32;

        lifetime.Lifetime_each: |locid, isStatic|
        {
            (left && BUG("Lifetime_getRefLocid_unlessStatic: multiple locids in left_lt"))
                = locid || BUG("Lifetime_getRefLocid_unlessStatic: non-locid/non-static in left_lt");
        };

        return left;
    }

    fn PASS_borrowCheck(ref root: SolvedNode, pass: BorrowCheckPass) {
        inline fn AAR = pass == BCK_aar;
        inline fn BCK = pass == BCK_bck;

        fn cannotFailAfterBCK(reason: string)
            BCK && fail(reason)
                || BUG(pass ~ " is trying to emit an error:\n\n\t" ~ reason);

        fn tokenHash(token: TokenIdx)
            (token.modid.u32 * 9973 ^ token.tokidx.u32) << 20;

        fn WriteID(locid: i32, token: TokenIdx)
            WriteID(locid.sign_rotate | (BCK && token.tokenHash));

        fn locid(w: WriteID)
            (w._locid_and_hash & 0xfffff).sign_unrotate;

        fn tokenHash(w: WriteID)
            w._locid_and_hash & 0xfff00000;

        fn ArgRationale_explain(r: ArgRationale, callee: Target, arg: SolvedNode, host_arg: Argument) {
            if (r == CantTempCopy_HostArg_Ref)
                return host_arg ~ " is " ~ "ref".qBAD;
            if (r == CantTempCopy_HostArg_MutRef)
                return host_arg ~ " is a mutref: " ~ explainType(arg);

            if (r == CantTempCopy_ReturnedFromFn)
                return host_arg ~ " is ref-returned from " ~ callee;

            if (r == RequireVal_AliasesMutatedInjectedArgument)
                return host_arg ~ " needs an explicit " ~ "ref".qKW ~ " or " ~ "val".qKW ~ " for disambiguation:"
                    ~ "\n\n\t\t- Use " ~ "ref".qKW ~ " if you want " ~ host_arg.str(brief: true)
                                       ~ " to reflect changes made to the aliased injected arg."
                    ~ "\n\n\t\t- Use " ~ "val".qKW ~ " if you want " ~ host_arg.str(brief: true)
                                       ~ " to remain constant throughout " ~ callee;

            return "Unknown reason.";
        }

        lax fn RESOLVE_byAAR(lax read!: i32,lax write!: i32,lax trySoft!: bool) {
            return [];
            AAR || BUG();

            read != write || BUG("RESOLVE_byAAR: read == write");

            TRACE("RESOLVE_byAAR: trySoft(" ~ trySoft ~ ") read(" ~ read.nested ~ ") write(" ~ write.nested ~ ")");

            lax let ascendWrites = ||
            {
                lax let parents = _current_fn.flow.arg_parents.if(exists: write);
            };

            lax let ascendReads = ||
            {
                lax let parents = _current_fn.flow.arg_parents.if(exists: read);
            };

            lax let firstTry_to_ascendWrites = write > read;
            return true;
        }

        lax fn RESOLVE_byAAR(lax write!: i32,lax reads!: i32[..],lax trySoft!: bool) {
            return [];
            reads.each: |read|
                if (read && read != write)
                    RESOLVE_byAAR(:read, :write, :trySoft);

            return true;
        }

        lax fn RESOLVE_byAAR(lax writes!: WriteID[],lax read!: i32,lax trySoft!: bool) {
            return [];
            for (mut i = 0; i < writes.len; i++)
                RESOLVE_byAAR(write: writes[i].locid, :read, :trySoft);

            return true;
        }

        lax fn RESOLVE_byMutvar(lax target: Target) {
            return [];
            return target.globid == _current_fn.target.globid
                && RESOLVE_byMutvar(:target.locid);
        }

        fn RESOLVE_byMutvar(locid: i32) {
            BCK || BUG();

            lax let t = nested(locid);
            lax ref o = GET_mut(t);

            TRACE("RESOLVE_byTempCopy: " ~ t);

            if (!o.acceptsTempCopies)
                return false;

            o.type.is_mutref && BUG(t ~ ": Not F_REF but type.is_mutref"
                    ~ " in RESOLVE_byMutvar: is this a problem?");

            o.kind == "var" || BUG("RESOLVE_byMutvar: Not a variable: " ~ t);
            TEST_varLifetime(o.type.lifetime);

            if (!o.type.is_rx_copy)
                return false;

            flow.bck_consider_copy.add(locid);

            return true;
        }

        fn RESOLVE_byTempCopy(lax ref callsite!: SolvedNode, position: i32, debug!: string, requireVal!: ArgRationale) {
            lax let target      = callsite.target;
            lax ref arg         = callsite.items[position];

            return RESOLVE_byTempCopy(:arg, :target, :position, :debug, :requireVal);
        }

        fn RESOLVE_byTempCopy(lax ref arg!: SolvedNode, target!: Target, position: i32, debug!: string, requireVal!: ArgRationale) {
            BCK || BUG();

            TRACE("RESOLVE_byTempCopy: " ~ arg);

            lax let host_args   = target.args;
            lax let host_arg    = host_args[position];

            if (arg.kind == "call" && RESOLVE_byMutvar(arg.target))
                return [];

            lax let r = host_arg.rejectsTempCopies(:requireVal);
            if (host_arg.flags & F_LT_RETURNED)
                return CantTempCopy_ReturnedFromFn;

            {
                lax let slot = host_args[position].type;

                maybeCopyOrMove(arg, slot, :debug);
                return [];
            }
        }

        fn isInvalidatedBy(read: Lifetime, write: Lifetime) {
            write.Lifetime_each: |locid!w|
            {
                if (w && Lifetime_hasInter(read, flow.rg_invalidates.if(exists: w)))
                    return true;
            }

            return false;
        }

        fn softRiskSafe(arg: SolvedNode) {
            return isFieldChain(arg);
        }

        fn SLOW_find(test): SolvedNode {
            SLOW_traverse(root): |node|
                if (test(:node))
                    return node;

            return [];
        }

        fn SLOW_findByReadID(read!: i32, write_loop_start: i32) {
            fn eachLoopStart(mut search: i32, which, visit) {
                for (mut i = _helpers_data.len; i --> 0; ) {
                    lax let h = _helpers_data[i];
                    if (h.locals_start == search) {
                        lax let parent = h.postdom.which;
                        visit(search);
                        search = parent;
                    }
                }
            }

            lax mut loop_ids: i32[];
            eachLoopStart(write_loop_start, .write_loop_start): |loop_id|
                loop_ids ~= loop_id;

            lax fn checkReadLoopStart(lax read_loop_start: i32) {
                return [];
                eachLoopStart(read_loop_start, .read_loop_start): |loop_id|
                    if (loop_ids.has(loop_id))
                        return true;

                return false;
            }

            return SLOW_find(|node|
                node.kind == "call" &&
                node.target.isLocal &&
                node.target.locid == read &&
                checkReadLoopStart(node._loop_start))
                    || BUG("Cannot find read(" ~ nested(read) ~ ") in loop(" ~ write_loop_start ~ ").");
        }

        fn RWEvent_stack(write: WriteID) {
            lax let locid = write.locid;

            SLOW_traverse(root): |node| {
                if (node.token.tokenHash != write.tokenHash)
                    continue;
                if (node.kind != "call" && node.kind != "pragma")
                    continue;

                if (node.kind == "call") {
                    for (mut i = 0; i < node.items.len; i++) {
                        lax let arg = node.items[i];
                    }
                }
                if (node.kind == "pragma") {
                    for (mut i = 0; i < node.items.len; i++) {
                        lax let arg = node.items[i];
                        if (arg.is_mutref && arg.lifetime.Lifetime_has(:locid))
                            return arg.token.addr_and_snippet
                                 ~ "\n\tvia pragma " ~ node.value.qID;
                    }
                }

                continue;
            }

            return "\n\n\tCOMPILER BUG: RWEvent_stack could not find write to " ~ nested(write.locid);
        }

        fn flow         = _current_fn.flow;
        fn events       = _current_fn.events;

        fn Reference_trackLocalRef(t_left: Type, right: Lifetime) {
            lax let left = Lifetime_getRefLocid_unlessStatic(t_left.lifetime);
            if (!left)
                return;

            lax let left_ever_written = _current_fn.ever_written.if(exists: left);

            shadow let right = right.Lifetime_process(|locid, continue_keep|
            {
                if (locid)
                    continue_keep();
            });

            lax mut parents:    Lifetime;
            lax mut siblings:   Lifetime;

            parents.Lifetime_add(right);

            right.Lifetime_each: |shadow locid!right, paths|
            {
                flow.rg_children.ensure(exists: right).add(left);

                parents.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: right), :paths));

                siblings.Lifetime_add(flow.rg_invalidates.if(exists: right));
            }

            siblings = siblings.Lifetime_process(|locid!sibling, continue_keep|
            {
                lax let t_sibling       = sibling.nested.type;
                lax let sibling_written = _current_fn.ever_written.if(exists: sibling);

                lax let sibling_parents = flow.rg_parents.if(exists: sibling);
            });

            if (parents) {
                (flow.rg_parents.ensure(exists: left)
                    && BUG("rg_parents already set"))
                        = parents;

                parents.Lifetime_each: |locid!parent|
                {
                    if (SELF_TEST && !parent)
                        BUG("Reference_trackLocalRef: parents has non-locals.");

                    flow.rg_invalidates.ensure(exists: parent)
                        .Lifetime_add(t_left.lifetime);
                }
            }
        }

        lax fn bck_trackRead(lax callsite: SolvedNode) {
            return [];
            if (!callsite.target.isLocal)
                return;

            PROFILE(|ref p| AAR ? p.AAR_TrackRead
                                : p.BCK_TrackRead);

            _here           = callsite.token;
            lax let target      = callsite.target.locid;
            lax let loop_start  = callsite._loop_start || BUG("bck_trackRead: loop_start not set on callsite.");

            TEST_varLifetime(callsite.type.lifetime, locid: target, staticOK: TODO_FIX_static_ZSTs);

            lax let u = events.invalidated_by.if(exists: target);
            if (u) {
                if (AAR ? !RESOLVE_byAAR(read: target, writes: u.keys_asc, trySoft: true )
                        : !RESOLVE_byMutvar(target)) {
                    lax let first = u.keys_asc.first;

                    fail("Cannot access"
                        ~ " " ~ target.nested ~ ", reference invalidated by write to"
                        ~ " " ~ first.locid.nested ~ " at "
                        ~ RWEvent_stack(first));
                }

                if (OPTI_bck)
                    events.invalidated_by[target] = [];
            }

            if (target < loop_start)
                events.used_in_a_loop.add(target);
        }

        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime) {
            PROFILE(|ref p| AAR ? p.AAR_TrackWrites
                                : p.BCK_TrackWrites);

            lax let loop_start  = callOrPragma._loop_start || BUG("bck_trackWrites: _loop_start not set on callsite.");
            lax let OPTI_isLoop = loop_start != NO_LOOP && !!events.used_in_a_loop;
            lax let OPTI_hasPRA = !!events.preceding_ref_args;

            lifetime.Lifetime_each: |locid!write, region!write_region, paths!write_paths|
            {
                lax mut all_written = write_region;

                all_written.Lifetime_add(Lifetime_op_join(flow.rg_parents.if(exists: write), paths: write_paths));

                lax let invalidates = flow.rg_invalidates.if(exists: write);

                if (SELF_TEST && invalidates.Lifetime_has(locid: write))
                    BUG("flow.invalidates[write].has(write): " ~ nested(write));

                if (OPTI_isLoop) invalidates.Lifetime_each: |locid!read|
                {
                    read || BUG("bck_trackWrites: invalidates contains non-locals.");
                    if (read < loop_start) {
                        if (events.used_in_a_loop.has(read)) {
                            if (AAR)
                                RESOLVE_byAAR(:read, :write, trySoft: true );
                            RESOLVE_byMutvar(read) || fail("Write to " ~ write.nested
                                        ~ (callOrPragma.kind == "call" && " at call to " ~ callOrPragma.target)
                                        ~ " invalidates the use of " ~ read.nested ~ " at "
                                        ~ SLOW_findByReadID(:read, loop_start).token.addr_and_snippet
                                        ~ "\n\t... on next loop iteration.\n\n\tWritten"
                                        ~ qSTACK_rwevent(callOrPragma, :write));
                        }
                    }
                }

                lax let writeID = WriteID(locid: write, token: callOrPragma.token);

                invalidates.Lifetime_each: |locid!invalidatee|
                {
                    lax ref set = events.invalidated_by.ensure(exists: invalidatee);
                    if (BCK) {
                        set.keys_asc ||= [ writeID ];
                    }
                    {
                        if (SELF_TEST)
                            writeID._locid_and_hash.sign_unrotate == write || BUG("AAR: writeID._locid != write locid, set::add wont be able to dedupe");

                        set.add(writeID);
                    }
                }
            }
        }

        lax fn bck_trackInit(lax target: Target) {
            return [];
            lax let index   = target.locid;

            events.invalidated_by.if(exists: index) && BUG();
        }

        fn bck_call(ref callsite: SolvedNode) {
            fn target   = callsite.target;
            fn args     = callsite.items;

            lax let RTL         = target.isRTL;
            lax let host_args   = target.args;

            lax mut bck_writes: Lifetime;
            lax mut num_ref_args: int;
            {
                lax let pra_len0 = _current_fn.preceding_ref_args.len;

                lax mut pra_first = -1;

                argsForward(:RTL, :host_args, |i, host_arg, ooe_isLast|
                {
                    lax ref arg = args[i];
                    if !(host_arg.is_ref && arg.is_ref)
                        continue;

                    num_ref_args++;

                    if (host_arg.written_to) {
                        if (SELF_TEST) {
                            host_arg.is_mutref || BUG(host_arg.name.human.qID ~ ": host_arg.written but !host_arg.is_mutref");
                            arg.is_mutref      || BUG(host_arg.name.human.qID ~ ": host_arg.written but !arg.is_mutref");
                        }

                        bck_writes.Lifetime_add(arg.lifetime, flatCountMismatchOK: true);
                    }
                });

                _current_fn.preceding_ref_args.shrink(pra_len0);
            }

            if (!bck_writes)
                return;

            _here = callsite.token;
            bck_trackWrites(callsite, bck_writes);
        }

        lax fn bck_loop(lax ref node: SolvedNode) {
            return [];
            lax let used_in_a_loop0 = _current_fn.events.used_in_a_loop;
            _current_fn.events.used_in_a_loop.clear(start: node._loop_start);

            lax ref items = node.items;

            bck_node(items[0]);

            for (mut i = 1; i < items.len; i++)
                bck_node(items[i]);

            lax let read_loop_start =
                node.helpers.postdom.read_loop_start || BUG("bck_loop: read_loop_start not set.");

            _current_fn.events.used_in_a_loop.clear(start: read_loop_start);
            _current_fn.events.used_in_a_loop.add(used_in_a_loop0);
        }

        lax fn bck_if(lax ref node: SolvedNode) {
            return [];
            lax ref items = node.items;

            lax ref cond = items[0];
            bck_node(cond);

            lax let ae_cond = tryAbstractEvalAsBool(cond);
            if (ae_cond) {
                lax ref cons = items[ae_cond == SE_True ? 1 : 2];
                bck_node(cons);

                node = createBlock(items[0], cons);
                return;
            }

            lax let e_Restore_AfterCond     = _current_fn.events.snap;

            bck_node(items[1]);

            lax let e_Merge_AfterCons       = _current_fn.events.snap;

            _current_fn.events.Events_restore(e_Restore_AfterCond, write_loop_start: node._loop_start);

            bck_node(items[2]);

            _current_fn.events   .Events_merge(e_Merge_AfterCons);
        }

        bck_node(root);
    }

    lax fn TEST_node(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        if (!SELF_TEST)
            return;

        for (mut i = 0; i < node.items.len; i++)
            TEST_node(node.items[i], :pass, :expect_paint);

        _here = node.token;

        if (node.is_never && node.usage)
            BUG("node.is_never but some usage bits set");

        TEST_unpaintNode(:node, :expect_paint);

        lax let k = node.kind;

        !node.is_ref == !node.lifetime || BUG(node ~ ": !!ref != !!lt: " ~ explainType(node.type));

        if (k == "call") {
            lax let t           = node.target;
            lax let o           = GET(t);
            lax let host_args   = t.args;
            lax let args        = node.items;

            fn err(reason: string)
                BUG(node ~ " " ~ t ~ ": " ~ reason);

            host_args.len == args.len || k == "type" && !args.len || err("host_args.len (" ~ host_args.len ~ ") != args.len (" ~ args.len ~ "):"
                    ~ "\n\t\t" ~ mangleArgTypes(args)
                    ~ "\n\t\t" ~ explainWhichFn(t));

            if (o.kind == "type" && o.type.tryLookupUserType.kind == "struct") {
            }
            else for (mut i = 0; i < args.len; i++) {
                lax let host_arg = host_args[i];
                lax let arg      = args[i];

                if (host_arg.isIrrelevant) {
                    if (o.kind == "field")
                        node.type.isIrrelevant || !arg.type.isIrrelevant || BUG("Relevant data out of an irrelevant struct: getting a " ~ explainType(node) ~ " from a " ~ explainType(arg));

                    continue;
                }

                isAssignableAsArgument(host: host_arg.type, arg.type) || err("Arg #" ~ i ~ ", " ~ host_arg.name.human.qID ~ " not assignable to host_arg: "
                        ~ explainNotAssignable(host_arg.type, arg.type));

                if (pass >= RelaxCopyResize)
                    host_arg.type.is_ref || !arg.type.is_ref || err("Missing copy or move for arg #" ~ i ~ ", " ~ host_arg.name.human.qID ~ ": "
                            ~ explainNotAssignable(host_arg.type, arg.type));
            }

            if (o.kind != "field") {
                if (o.kind == "var" && o.type.isIrrelevant)
                    BUG("Call to irrelevant local: " ~ t);

                lax let expect = node.type;

                shadow let expect = o.kind == "type" && node.value == "__partcopy_s"
                    ? clear_vfacts(expect) : expect;

                isAssignable(host: expect, o.type) || err("Return value not assignable to node.type: "
                        ~ explainNotAssignable(expect, o.type));
            }
        }

        else if (k == "empty" || k == "definit") {
            if (node.lifetime)
                node.lifetime == Lifetime_static_moveable || BUG(k ~ ": non-static lifetime: " ~ node.lifetime);

            node.vfacts & "AlwaysFalse" || node.type.isIrrelevant

                || node.vfacts & "Typename"

                || BUG(k ~ ": value is neither AlwaysFalse nor irrelevant: " ~ explainType(node.type, lt: true, usage: true))
        }
        else if (k == "letdef") {
            TEST_node(node: GET_mut(node.target).solved, :pass, :expect_paint);
        }
        else if (k == "let") {
            if (node.type.isIrrelevant && pass >= RelaxMut)
                node.target.isArg || !node.target.isLocal || BUG(node.target ~ " place.type is irrelevant: " ~ explainType(node.type, usage: true));

            else
            {
                node.items[0] && BUG("let.items[0] not empty: " ~ node.items[0].kind);

                node.type.lifetime.hasTemporary && BUG("test_node(let) place.type has temp lt: " ~ explainType(node.type, lt: true));

                lax let o = GET(node.target);
                TEST_Assignable(host: o.type.clear_refs(), node.type, "test_node(let): let.target.type !<- let.place.type");

                lax let init = node.items[1];
                if (init)
                    TEST_Assignable(host: node.type, init.type, "test_node(let): place.type !<- let.init.type");
            }
        }
    }

    lax fn TEST_pass(lax ref node: SolvedNode, lax pass: SolverPass, lax expect_paint!?: bool) {
        PROFILE(.TestPass);

        node.helpers.target == _current_fn.target || BUG();

        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++)
            TEST_unpaintNode(_current_fn.items[i], expect_paint: false);

        TEST_node(:node, :pass, :expect_paint);
    }

    fn runAllPasses(ref node: SolvedNode) {
        defer if (_current_fn) {
            _current_fn.args_neg == _current_fn.target.args_neg || BUG("runAllPasses: args_neg drifted");
            _current_fn.args_neg = 0;
        }

        TEST_pass(node, :node.helpers.pass);

        {
            PROFILE(.RelaxMut);
            node.helpers.pass = "RelaxMut";

            _current_fn.var_usage  && BUG("_current_fn.var_usage not empty before propagateType.");
            _current_fn.postdom    && BUG("_current_fn.postdom not empty before propagateType.");

            Postdom_resetAtFnEnd(_current_fn);
            propagateType(node, node.type, relax_mask: RELAX_before_bck);

            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxMut.end: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxMut.end: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");
        }

        TEST_pass(node, :node.helpers.pass, expect_paint: true);

        {
            PROFILE(.BCK_Misc);
            node.helpers.pass = "BorrowCheck";

            PASS_borrowCheck(node, BCK_bck);
            PASS_BCK_applyCopies();
        }

        {
            PROFILE(.AAR_Misc);
            node.helpers.pass = "ArgumentsAtRisk";

            _current_fn.TODO_FIX_children = _current_fn.flow.rg_children;

            PROFILE(.RelaxCopyResize);
            node.helpers.pass = "RelaxCopyResize";

            _current_fn.fx_mask = [];
            _current_fn.relaxed = [];

            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxCopyResize: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");

            Postdom_resetAtFnEnd(_current_fn);
            propagateType(node, node.type, relax_mask: RELAX_all);

            _current_fn.read_loop_start  == NO_LOOP || BUG("RelaxCopyResize.end: read_loop_start(" ~ _current_fn.read_loop_start ~ ")");
            _current_fn.write_loop_start == NO_LOOP || BUG("RelaxCopyResize.end: write_loop_start(" ~ _current_fn.write_loop_start ~ ")");
        }

        TEST_pass(node, :node.helpers.pass, expect_paint: true);

        if (_current_fn) {
            if (currentFn_mustBecomeInline)
                BUG("runAllPasses: currentFn_mustBecomeInline after all.");

            _current_fn.target.GET_mut.status |= SS_Debug_AllPassesComplete;
        }
    }

    fn compilerBreak() {
        println("[[[ BREAKPOINT HERE ]]]");
    }

    fn Scope_observeDefects() {
        lax mut hasLets         = false;
        lax mut hasPubTemplates = false;

        lax mut privates: Target[];
    }

    fn nestingFnort_ensureArgSequencing() {
        lax mut _may_alias: ::BitSet[];
        lax mut _argPos_1b: i32[];

        _nestingFnort.args.each: |host_arg, i|
        {
            if (!host_arg.type.is_ref)
                continue;

            _argPos_1b.ensure(exists: (-1) - host_arg.target.locid) = i + 1;

            lax let may_alias = host_arg.written_to && host_arg.may_alias;
        }

        struct Regions {
            locids:     LocidSet;
            arguments:  ::BitSet;
        };

        fn has_inter(a: Regions, b: Regions)
            a.locids.has_inter(b.locids) ||
            a.arguments.has_inter(b.arguments);

        infix fn |=(ref a: Regions, b: Regions)
            for (fieldname i: Regions)
                a.i |= b.i;

        struct Unsequenced {
            writes:     Regions;
            moves:      Regions;
            reads:      Regions;
        };

        fn clear(ref events: Unsequenced)
            for (fieldname i: Unsequenced)
                events.i.clear();

        infix fn |=(ref events: Unsequenced, other: Unsequenced)
            for (fieldname i: Unsequenced)
                events.i |= other.i;

        lax fn flag(lax ref regions: Regions,lax lifetime: Lifetime,lax dontUse_may_alias!?: bool ) {
            return [];
            lifetime.Lifetime_each: |locid|
            {
                if (locid && regions.locids.add(locid)) {
                    lax let argPos_1b = _argPos_1b.if(exists: (-1) - locid);
                    if (argPos_1b) {
                        lax let i = argPos_1b - 1;
                        lax let may_alias = !dontUse_may_alias
                                     && _may_alias.if(exists: i);

                        if (may_alias) {
                            if (SELF_TEST && !may_alias.has(i))
                                BUG("ensureArgSequencing: may_alias does not list self [2]");

                            regions.arguments |= may_alias;
                        }
                        else
                        {
                            regions.arguments.add(i);
                        }
                    }

                    regions.flag(nested(locid).Lifetime_climbType.lifetime, :dontUse_may_alias);
                }
            }
        }

        lax mut _unseqDepth = 0;
        lax mut _inner: Unsequenced;

        lax fn visit(lax ref node: SolvedNode) {
            return [];
            lax let unsequencedOutside = !!_unseqDepth;

            if (node.kind == "move") {
                if (_unseqDepth)
                    if (node.kind == "move")
                        _inner.moves.flag(node.items.only.type.lifetime);
            }

            for (mut i = 0; i < node.items.len; i++)
                visit(node.items[i]);
        }

        lax mut root = GET_mut(_nestingFnort).solved.items.last.steal();
        visit(root);
        swap(root, GET_mut(_nestingFnort).solved.items.last);
    }

    lax fn hash(lax ref hash: tea::TEA,lax type: Type) {
        return [];
        hash.hash(tea::TEA((type.quals & q_TAGS).u32, type.lifetime.uni0n.len && 1.u32));

        hash.hash(type.getShape().hash);
    }

    fn computeFnSighash_asIfCycleRoot(fn_target:          Target, lax ref name_counts!:   flat::Map(string, u32)) {
        lax mut already_hashing:    Target[];
        lax mut cycle_participants: flat::Set(Target);

        lax fn computeFnSighash(lax shadow fn_target: Target) {
            return [];
            lax mut hash: tea::TEA;

            fn sighashNode(n: SolvedNode) {
                hash.hash(tea::TEA(n.kind.u32, 
                        n.items.len.u32));

                for (mut i = 0; i < n.items.len; i++)
                    sighashNode(n.items[i]);

                if (n.kind == "letdef") {
                    sighashNode(n.target.solved);
                }
                else if (n.kind == "let") {
                    hash.hash(n.target.locid.u64);
                    hash.hash(n.type);
                }
            }

            lax let o = GET(fn_target);
            o.kind == "fn" || BUG("computeFnSighash: Not a fn: " ~ fn_target);

            lax let sighash =
                (EXT_mut(fn_target).sighash && BUG("sighash already set")) =
                    hash.non_zero;

            return sighash;
        }

        lax let cycle_root_hash = computeFnSighash(fn_target);

        cycle_participants.each: |target|
            EXT_mut(target).sighash.hash(cycle_root_hash);
    }

    fn PASS_runAllVerifiers() {
        {
            PROFILE(.ComputeSighashes);

            lax mut name_counts: flat::Map(string, u32);
        }

        {
            PROFILE(.EnsureArgSeq);

            _nestingFnort && BUG("PASS_runAllVerifiers: non-empty _nestingFnort");
            _current_fn.args_neg && BUG("PASS_runAllVerifiers: non-empty _current_fn.args_neg");

            for (mut i = 0; i < _scope.overloads.len; i++) {
                lax ref o = _scope.overloads[i];
            }
        }

        _nestingFnort = [];
        _current_fn.args_neg = [];
    }

    if (module.modid) {
        _scope.imports ~= module.modid;

        _Scope_import__forceCopy(0);
    }

    {
        lax let root = solveNode(module.in.parse.root.steal());

        _current_fn && BUG("non-empty _current_fn.");

        PASS_runAllVerifiers();

        _helpers_data[0] && BUG("non-empty _helpers_data[0].");

        Scope_observeDefects();

        for (mut i = 0; i < _warnings.len; i++) {
            lax let w = _warnings[i];
            if (w.locid) {
                lax let target = Target(:module.modid, globid: i, locid: w.locid < 0x11110000 ? w.locid : 0);
                _here = target.solved.token;

                fail(w.locid == 0x11110000
                        ? target    ~ " does nothing: returns void and has no effects."
                                    ~ makeItLaxIfIntentional()
                        : "Unused variable: " ~ target ~ "."
                                    ~ makeItLaxIfIntentional());
            }
        }

        return SolverOutput(root:  root, notes: _notes, scope: Scope_exports(_scope, :module.modid, pub_imports: _pub_imports.keys_asc));
    }
}
