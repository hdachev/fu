#define TODO_FIX_REMOVE_copying_push

#include <cstdint>
#include <utility>
#include <fu/int.h>
#include <fu/str.h>
#include <fu/vec.h>
#include <algorithm>
#include <fu/view.h>
#include <fu/defer.h>
#include <fu/never.h>
#include <fu/print.h>
#include <fu/assert.h>
#include <fu/decstr.h>
#include <fu/default.h>
#include <fu/static_ref.h>
#include <fu/vec/concat.h>
#include <fu/init_priority.h>
#include <fu/vec/view_swap.h>
#include <fu/vec/concat_one.h>
#include <fu/vec/view_assign.h>
#include <fu/vec/LEGACY_slice.h>

struct s_SolverOutput;
struct s_SolvedNode;
enum s_Kind: fu::u8;
struct s_Helpers;
typedef unsigned s_Flags;
struct s_TokenIdx;
struct s_Type;
struct s_ValueType;
typedef fu::u8 s_VFacts;
struct s_Lifetime;
struct s_Target;
struct s_Scope;
struct s_Overload;
typedef uint16_t s_SolverStatus;
typedef uint16_t s_DeclAsserts;
struct s_Extended;
struct s_Argument;
struct s_BitSet;
struct s_COWInside;
typedef unsigned s_MayEscapeVia;
typedef fu::u8 s_ExitPaths;
struct s_Template;
struct s_Node;
typedef fu::u8 s_ParseSyntax;
struct s_TEA;
typedef uint16_t s_FxMask;
struct s_ScopeItem;
typedef int s_SolverNotes;
struct s_Context;
struct s_Module;
struct s_ModuleInputs;
struct s_LexerOutput;
struct s_Token;
struct s_LineColChars;
struct s_ParserOutput;
struct s_Import;
struct s_ModuleOrder;
struct s_ModuleOutputs;
struct s_UserType;
struct s_Set_95BJOojOc45;
struct s_Shape;
struct s_CodegenOutput;
struct s_Set_6ARmtH0K78f;
struct s_BuildHacks;
typedef fu::u8 s_CGDefects;
struct s_ModuleStats;
struct s_ModuleStat;
struct s_Profile;
struct s_Sample_Time;
struct s_NukeOnRebuild;
struct s_Map_cUwKMz9CPyg;
struct s_Options;
struct s_Lint;
typedef fu::u8 s_DevOptions;
struct s_CurrentFn;
struct s_ScopeMemo;
struct s_Flow;
struct s_LocidMap_93S9qlGbUSi;
struct s_LocidMap_OjaSaYAvjq2;
struct s_Set_95BJOojOc45;
struct s_LocidMap_I7YkM5C62o7;
struct s_LocidSet;
struct s_Effects;
struct s_Events;
struct s_EventsSnap;
struct s_LocidMap_OrMuSNs7d4i;
struct s_Set_2i2v33LNlqd;
struct s_WriteID;
struct s_PrecedingRefArg;
struct s_VarUsage;
struct s_LocidMap_EcBtE1sFv98;
struct s_Postdom;
struct s_PostdomSnap;
struct s_LocidMap_DC5gktNgm89;
struct s_RevSpecPrototype;
struct s_SolverState;
struct s_ScopeSkipMemos;
struct s_ScopeSkip;
struct s_HelpersData;
enum s_SolverPass: fu::u8;
typedef uint16_t s_HelpersMask;
struct s_Ephemeral;
struct s_SpecExtras;
struct s_Map_pdTv4gjINIj;
struct s_Set_6ARmtH0K78f;
struct s_CountedSet_95BJOojOc45;
struct s_Map_2goAfCfe5Ta;
struct s_ChildTarget;
struct s_Map_CIvvfLLMMzl;
struct s_ReverseSpecialization;
struct s_RevSpecInstance;
struct s_RevSpecOutput;
struct s_Map_j5rW2s1zJ22;
struct s_Set_7aI0knTMWY7;
struct s_ConvCache_ColsAndBakes;
struct s_ConvCacheColumns;
struct s_Warning;
struct s_Map_lhf7SV3Fyjf;
struct s_TypeParam;
typedef fu::u8 s_TypeParamFlags;
enum s_DeadBreak: fu::u8;
enum s_StaticEval: fu::u8;
struct s_ClosureID;
struct s_UnpackedOffset;
typedef fu::u8 s_CodeFmt;
struct s_Reorder;
struct s_NamedArgs_AWe2QSUTLw0;
struct s_Set_ukcriy4HHQd;
struct s_UserTypeCanon;
struct s_Intlit;
struct s_Map_uccvP8a6Yhg;
struct s_Set_aQNJhbMknMf;
typedef unsigned s_UsedAgain;
enum s_UsedAgainReason: fu::u8;
struct s_RetypeOrder;
struct s_NamedArgs_uE7WdS56SGd;
struct s_NativeQualities;
enum s_ArgQuery: fu::u8;
enum s_ArgRationale: fu::u8;
enum s_BorrowCheckPass: fu::u8;
struct s_RWQuals;
struct s_SubRegion;
struct s_Map_4FUR4uzUhqd;
struct s_Unsequenced;
struct s_Regions;
fu::str getShortModuleName_1qjplDUo(const fu::str&, const s_TokenIdx&, const s_Context&);
s_Type into_Typename_9CJmuVSD(s_Type&&);
s_Target Scope_create_z0QqoZ5t(s_Scope&, s_Kind, const fu::str&, const s_Type&, s_Flags, s_DeclAsserts, s_SolverStatus, int, bool, const s_Module&);
void Scope_set_z0QqoZ5t(s_Scope&, const fu::str&, const s_Target&, bool);
static s_SolvedNode solveNode_gDsnGKHT(const s_Node&, const s_Type&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool is_never_9CJmuVSD(const s_ValueType&);
unsigned is_AssumeNever_WhileSolvingRecursion_9CJmuVSD(const s_ValueType&);
fu::str qBAD_e44UlzzA(const fu::str&);
const s_Token& _token_xQNS19Zn(const s_TokenIdx&, const s_Context&);
[[noreturn]] fu::never BUG_u9Gbkniv(fu::str&&, const s_TokenIdx&, const s_Context&);
fu::str qDIM_e44UlzzA(fu::view<char>);
bool is_mutref_9CJmuVSD(const s_Type&, const s_TokenIdx&, const s_Context&);
s_ClosureID tryParseClosureID_UvH3gYAB(fu::view<char>, const s_TokenIdx&, const s_Context&);
fu::str trim_V5IuMsej(const fu::str&);
s_Target Target_xQNS19Zn(int, int, int);
fu::str qID_e44UlzzA(const fu::str&);
fu::str qKW_e44UlzzA(const fu::str&);
const s_UserType& tryLookupUserType_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_Type tryClear_sliceable_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
static fu::str explainTypeName_gDsnGKHT(const s_Type&, bool, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool TODO_FIX_isArray_9CJmuVSD(const s_Type&);
bool is_zeroes_9CJmuVSD(const s_ValueType&);
fu::str formatTokenCoord_u9Gbkniv(const s_TokenIdx&, int, const s_Context&);
[[noreturn]] fu::never FAIL_u9Gbkniv(fu::view<char>, const fu::vec<s_TokenIdx>&, const s_Context&);
bool isIrrelevant_9CJmuVSD(const s_Type&);
bool isCanonAssignable_Ot6wT82z(fu::view<char>, fu::view<char>, const s_TokenIdx&, const s_Context&);
fu::str explainVFacts_9CJmuVSD(s_VFacts);
fu::str explainQuals_9CJmuVSD(unsigned, const s_Lifetime&);
unsigned parse7bit(fu::view<char>, int&);
fu::str qLT_e44UlzzA(const fu::str&);
s_Target target_z0QqoZ5t(const s_ScopeItem&);
bool is_sliceable_hxWWgdZ1(const s_ValueType&);
s_Type clear_sliceable_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
fu::view<char> tryGetPattern_Ot6wT82z(fu::view<char>);
s_Target parseGlobal_xQNS19Zn(fu::view<char>, int&);
bool scan(fu::view<char>, char, int&, bool&);
s_ValueType parseType_1qjplDUo(fu::view<char>, const s_TokenIdx&, const s_Context&, const s_Module&);
static fu::str explainType_gDsnGKHT(const s_Type&, bool, bool, bool, bool, bool, const s_Type&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
unsigned USAGE_fieldUsageFromStructUsage_CaGDtmWo(unsigned, unsigned, int, int);
unsigned getMaxUsage_CaGDtmWo(int);
static void appendUsage_gDsnGKHT(const s_Type&, unsigned, fu::str&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
fu::str formatCodeSnippet_k53poh8o(fu::vec<s_TokenIdx>&&, int, s_CodeFmt, const s_Context&);
static fu::str explainWhichFn_gDsnGKHT(s_Target&&, fu::view<fu::vec<s_Target>>, fu::view<char>, s_CodeFmt, const s_CurrentFn&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
fu::str packAddrOfFn_9CJmuVSD(fu::view<s_Target>);
bool hasStatic_7Yz9ezW2(const s_Lifetime&);
static s_Type evalTypeAnnot_gDsnGKHT(const s_Node&, bool, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_Type add_ref_9CJmuVSD(s_Type&&, const s_Lifetime&, const s_TokenIdx&, const s_Context&);
s_Type add_mutref_9CJmuVSD(s_Type&&, const s_Lifetime&, const s_TokenIdx&, const s_Context&);
s_Type createArray_9CJmuVSD(const s_Type&);
s_Type createSlice_9CJmuVSD(const s_Type&, const s_Lifetime&, const s_TokenIdx&, const s_Context&);
bool is_Typename_9CJmuVSD(const s_Type&);
s_Type relax_typeParam_9CJmuVSD(s_Type&&);
s_Type clear_Typename_9CJmuVSD(s_Type&&, bool);
unsigned parseVarint_V5IuMsej(int&, fu::view<char>);
bool add_ZwXYCruz(s_BitSet&, int);
bool isUserType_27MV22ZA(const s_ValueType&);
static s_Target tryMatchCall_gDsnGKHT(fu::str&&, s_Reorder&, fu::vec<fu::vec<s_Target>>&, fu::str&, bool, const s_Scope&, fu::view<s_SolvedNode>, s_Flags, fu::view<s_Target>, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_Type make_field_reference_9CJmuVSD(unsigned, const s_Lifetime&, s_Type&&, int, int, const s_TokenIdx&, const s_Context&);
static void descend_gDsnGKHT(const s_Type&, bool, bool, s_ConvCache_ColsAndBakes&, s_Reorder&, fu::vec<fu::vec<s_Target>>&, fu::vec<s_Target>&, fu::vec<int>&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_UserTypeCanon tryParseUserTypeCanon_1qjplDUo(const s_ValueType&);
const s_UserType& lookupUserType_1qjplDUo(const s_UserTypeCanon&, const s_Module&, const s_Context&, const s_TokenIdx&);
const s_Set_95BJOojOc45& lookupTypeImports_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
int modidOfOrigin_27MV22ZA(const s_Type&);
bool has_ZwXYCruz(const s_BitSet&, int);
const s_Target& search_FjkYY9fz(fu::view<s_Target>, int&);
s_Target search_z0QqoZ5t(fu::view_mut<s_ScopeItem>, fu::view<char>, int&, fu::view<s_ScopeSkip>, bool&, fu::view<s_Target>, fu::view<s_ScopeItem>, const s_TokenIdx&, const s_Context&);
s_Target search_KHWeNbCZ(fu::view<s_ScopeItem>, fu::view<char>, int&, fu::view<s_ScopeItem>);
static void relinkNode_gDsnGKHT(s_SolvedNode&, const s_Target&, const s_Target&, fu::view_mut<s_Overload>, int, fu::vec<s_Helpers>&, int&, const s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, const s_TokenIdx&, const s_Context&);
void force_relax_9CJmuVSD(s_Type&, unsigned);
unsigned try_relax_9CJmuVSD(s_Type&, const s_Type&, unsigned);
static void TEST_node_gDsnGKHT(s_SolvedNode&, s_SolverPass, bool, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool is_ref_9CJmuVSD(const s_Type&);
bool isAssignableAsArgument_9CJmuVSD(const s_ValueType&, const s_ValueType&, bool, const s_TokenIdx&, const s_Context&);
static fu::str tryExplainWell_gDsnGKHT(const s_Type&, const s_CurrentFn&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Type clear_refs_9CJmuVSD(s_Type&&);
s_Type clear_vfacts_9CJmuVSD(s_Type&&);
bool isAssignable_9CJmuVSD(const s_Type&, const s_Type&, bool, bool, const s_TokenIdx&, const s_Context&);
fu::str serializeType_1qjplDUo(const s_ValueType&, fu::view<char>);
s_Lifetime Lifetime_union_7Yz9ezW2(const s_Lifetime&, const s_Lifetime&, bool, const s_TokenIdx&, const s_Context&);
bool is_void_or_propositionOK_9CJmuVSD(const s_Type&, bool, const s_TokenIdx&, const s_Context&);
bool hasTemporary_7Yz9ezW2(const s_Lifetime&);
bool is_trivial_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
static void check_gDsnGKHT(const s_Lifetime&, bool&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void definitWrap_gDsnGKHT(s_SolvedNode&, const s_Type&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool isImmediatelyDiscardable_UVY6Qzz1(s_Kind);
bool is_rx_copy_9CJmuVSD(const s_ValueType&);
bool is_zst_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_Type type_tryIntersect_9CJmuVSD(const s_Type&, const s_Type&, const s_TokenIdx&, const s_Context&);
static void propagateType_gDsnGKHT(s_SolvedNode&, const s_Type&, unsigned, const s_Helpers&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool is_boolean_hxWWgdZ1(const s_ValueType&);
s_BitSet& operator|=(s_BitSet&, const s_BitSet&);
bool propositionOK_9CJmuVSD(const s_Type&, bool, const s_TokenIdx&, const s_Context&);
s_Type type_trySuper_9CJmuVSD(const s_Type&, const s_Type&, bool, const s_TokenIdx&, const s_Context&);
static s_SolvedNode createAnd_gDsnGKHT(fu::vec<s_SolvedNode>&&, s_Type&&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_Type definitType_9CJmuVSD(s_Type&&, bool, const s_TokenIdx&, const s_Context&);
static int couldRetype_gDsnGKHT(const s_SolvedNode&);
bool is_void_9CJmuVSD(const s_ValueType&);
bool is_arithmetic_hxWWgdZ1(const s_ValueType&);
s_Intlit Intlit_u8re8TwO(fu::view<char>);
bool is_primitive_hxWWgdZ1(const s_ValueType&);
int basePrimPrefixLen_hxWWgdZ1(fu::view<char>);
static s_Type tryRetyping_gDsnGKHT(const s_SolvedNode&, const s_Type&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void applyRetype_gDsnGKHT(s_SolvedNode&, const s_Type&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Type clear_all_9CJmuVSD(s_Type&&);
static bool applyConversion_gDsnGKHT(s_SolvedNode&, fu::view<s_Target>, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool isRTL_xQNS19Zn(const s_Overload&);
static void visitNode_gDsnGKHT(s_SolvedNode&, int, const s_Target&, fu::view_mut<s_SolvedNode>, s_Map_uccvP8a6Yhg&, const s_Target&, int, fu::vec<s_Helpers>&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool isStaticOrZeroes_7Yz9ezW2(const s_Lifetime&);
int getFlatCount_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_Lifetime Lifetime_from_7Yz9ezW2(int, int, const s_TokenIdx&, const s_Context&);
static s_SolvedNode CallerNode_gDsnGKHT(const fu::str&, s_Target&&, fu::vec<s_SolvedNode>&&, const s_Reorder&, fu::view<fu::vec<s_Target>>, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static fu::str qSTACK_implicit_FDl5ha9X(const s_Target&, const s_SolvedNode&, fu::view<char>, const s_Type&, fu::view<s_Target>, const s_CurrentFn&, s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Type clear_mutref_9CJmuVSD(s_Type&&);
fu::str cleanID_V5IuMsej(const fu::str&);
bool isAddrOfFn_9CJmuVSD(const s_Type&);
s_Target parseLocalOrGlobal_xQNS19Zn(fu::view<char>, int&);
void Scope_set_FjkYY9fz(fu::vec<s_ScopeItem>&, const fu::str&, const s_Target&, bool);
fu::str serialize_UvH3gYAB(const s_ClosureID&, const s_TokenIdx&, const s_Context&);
static bool Lifetime_allowsMutrefReturn_gDsnGKHT(const s_Lifetime&, int, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Lifetime Lifetime_op_join_7Yz9ezW2(const s_Lifetime&, fu::view<char>, const s_TokenIdx&, const s_Context&);
void Lifetime_add_7Yz9ezW2(s_Lifetime&, const s_Lifetime&, bool, const s_TokenIdx&, const s_Context&);
void assertPathsValid_7Yz9ezW2(fu::view<char>, int, int, bool, int, const s_TokenIdx&, const s_Context&);
void clear_Na55O4zv(s_BitSet&, int);
s_Type USAGE_structUsageFromFieldUsage_GgXYS4ZV(s_Type&&, int);
static s_UsedAgain descend_FDl5ha9X(const s_Lifetime&, s_LocidSet&, s_LocidSet&, const s_CurrentFn&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
unsigned mask_retval_relaxable_9CJmuVSD(const s_Type&, unsigned, const s_TokenIdx&, const s_Context&);
static void ensureLazySolved_gDsnGKHT(const s_Target&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static s_Type conversionTailType_gDsnGKHT(const s_Type&, fu::view<s_Target>, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
static s_Type Scope_lookupType_gDsnGKHT(const fu::str&, s_Flags, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
void ref_anonymize_9CJmuVSD(s_Type&);
s_Type tryClear_ref_9CJmuVSD(const s_Type&, const s_TokenIdx&, const s_Context&);
s_Type tryClear_mutref_9CJmuVSD(const s_Type&, const s_TokenIdx&, const s_Context&);
s_Type tryClear_array_9CJmuVSD(const s_Type&, const s_TokenIdx&, const s_Context&, const s_Module&);
static bool trySolveTypeParams_gDsnGKHT(const s_Node&, s_Type&&, fu::str&, bool, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool remove_Na55O4zv(s_BitSet&, int);
int popcount_ZwXYCruz(const s_BitSet&);
fu::str qBAD_KW_e44UlzzA(const fu::str&);
static void intoTombstone_gDsnGKHT(const s_Target&, s_SolverState&, const s_Module&);
static bool evalTypePattern_gDsnGKHT(const s_Node&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
bool is_bitfield_hxWWgdZ1(const s_ValueType&);
bool is_integral_hxWWgdZ1(const s_ValueType&);
bool is_unsigned_hxWWgdZ1(const s_ValueType&);
bool is_floating_pt_hxWWgdZ1(const s_ValueType&);
bool is_enum_hxWWgdZ1(const s_ValueType&);
bool is_flags_hxWWgdZ1(const s_ValueType&);
bool is_reinterpretable_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
static fu::vec<s_SolvedNode> solveNodes_gDsnGKHT(fu::view<s_Node>, s_DeadBreak, const s_Type&, const s_Type&, bool, s_StaticEval, bool, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static s_SolvedNode solveCall_FDl5ha9X(fu::str&&, fu::vec<s_SolvedNode>&&, s_Flags, fu::view<s_Target>, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static void TODO_FIX_partialEvalTypeAnnot_gDsnGKHT(s_Node&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_Lifetime Lifetime_makeShared_7Yz9ezW2(const s_Lifetime&, int, const s_TokenIdx&, const s_Context&);
s_NativeQualities NativeQualities_UvH3gYAB(fu::view<char>);
void add_xQNS19Zn(s_MayEscapeVia&, int);
void add_range_ZwXYCruz(s_BitSet&, int);
void remove_ZwXYCruz(s_BitSet&, const s_BitSet&);
bool is_rx_resize_9CJmuVSD(const s_ValueType&);
static void visit_FDl5ha9X(const s_Lifetime&, bool&, int, bool&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static fu::str qSTACK_local_FDl5ha9X(const s_Target&, const s_SolvedNode&, int, fu::view<s_Target>, s_ArgQuery, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_BitSet negated_ZwXYCruz(const s_BitSet&, int);
s_Lifetime Lifetime_from_UkiI9X8L(int, fu::view<char>, const s_TokenIdx&, const s_Context&);
bool isPassByValue_hxWWgdZ1(const s_ValueType&);
static fu::str qSTACK_effect_gDsnGKHT(const s_Target&, const s_SolvedNode&, s_FxMask, fu::view<s_Target>, const s_CurrentFn&, s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool hasAssignment_vRqJr3WR(fu::view<char>);
void isRTL_set_xQNS19Zn(s_Overload&, bool);
static bool astChange_gDsnGKHT(const s_SolvedNode&, const s_SolvedNode&);
bool isIrrelevantOrNever_9CJmuVSD(const s_Type&);
static void visit_q5Q6zgXB(const s_Lifetime&, s_Lifetime&, bool&, bool, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void runAllPasses_gDsnGKHT(s_SolvedNode&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static bool lazySolveStart_gDsnGKHT(const s_Target&, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
static void cannotCOW_climbParents_gDsnGKHT(const s_Lifetime&, fu::view<int>, const s_SolvedNode&, const s_TokenIdx&, const s_Target&, const s_Argument&, bool, s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Lifetime Lifetime_inter_7Yz9ezW2(const s_Lifetime&, const s_Lifetime&, const s_TokenIdx&, const s_Context&);
s_Shape getShape_1qjplDUo(const s_ValueType&, const s_TokenIdx&, const s_Context&, const s_Module&);
inline static bool type_maybeInside_0pJee81r(const s_ValueType&, const s_ValueType&, uint64_t, s_Set_ukcriy4HHQd&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_UserTypeCanon parseUserTypeCanon_27MV22ZA(fu::view<char>);
inline static bool type_maybeInside_x0HhL7Vy(const s_ValueType&, unsigned, const s_ValueType&, uint64_t, s_Set_ukcriy4HHQd&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
bool Lifetime_has_7Yz9ezW2(const s_Lifetime&, int);
static fu::str qSTACK_cow_inside_gDsnGKHT(const s_Target&, const s_SolvedNode&, const s_Argument&, const s_TokenIdx&, fu::view<s_Target>, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void cannotCOW_descendChildren_gDsnGKHT(int, const s_Lifetime&, fu::view<int>, const s_SolvedNode&, const s_TokenIdx&, const s_Target&, const s_Argument&, bool, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static int needsHardRisk_gDsnGKHT(int, const s_Overload&, const s_SolvedNode&, const s_Target&, const s_Argument&, bool, const s_CurrentFn&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_Type USAGE_fieldUsageFromStructUsage_GgXYS4ZV(s_Type&&, unsigned, int, int);
unsigned Lifetime_shiftUsage_7Yz9ezW2(fu::view<char>, unsigned, const s_TokenIdx&, const s_Context&);
static void callarg_trackWrites_gDsnGKHT(const s_Lifetime&, unsigned, const s_SolvedNode&, s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool USAGE_justOneThing_9CJmuVSD(unsigned, int);
static bool isFieldChain_gDsnGKHT(const s_SolvedNode&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
bool is_rx_move_9CJmuVSD(const s_Type&);
s_Type make_copyable_9CJmuVSD(s_Type&&);
s_Type make_moveable_9CJmuVSD(s_Type&&);
static void Lifetime_F_MOVED_FROM_gDsnGKHT(const s_Lifetime&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static bool tryInjectJumps_gDsnGKHT(s_SolvedNode&, const s_Helpers&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static bool RESOLVE_byAAR_gDsnGKHT(int, int, bool, s_BorrowCheckPass, s_CurrentFn&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void bck_node_gDsnGKHT(s_SolvedNode&, const s_SolvedNode&, s_BorrowCheckPass, s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_RWQuals USAGE_structUsageFromFieldUsage_z5tFO59K(const s_RWQuals&, int);
unsigned getRegionUsage_CaGDtmWo(int, int);
fu::vec<int> Lifetime_interLocids_7Yz9ezW2(const s_Lifetime&, const s_Lifetime&, const s_TokenIdx&, const s_Context&);
void add_Na55O4zv(s_BitSet&, const s_BitSet&);
static void verifyCopyNotRedundant_gDsnGKHT(const s_Lifetime&, bool&, const s_CurrentFn&, const s_SolverState&, const s_TokenIdx&, const s_Context&, const s_Module&);
s_Lifetime Lifetime_AAR_7Yz9ezW2(int, const s_TokenIdx&, const s_Context&);
void clear_ZwXYCruz(s_BitSet&);
bool has_missing_ZwXYCruz(const s_BitSet&, const s_BitSet&);
static s_SolvedNode __solveStruct_gDsnGKHT(bool, const s_Node&, const s_Target&, bool, s_CurrentFn&, s_SolverState&, fu::vec<s_Helpers>&, s_TokenIdx&, const s_Context&, s_Module&, const s_Options&);
s_TEA hash_s9RCxn8L(fu::view<char>);
void hash_l6RUR9Sz(s_TEA&, fu::view<char>);
void appendGlobal_xQNS19Zn(fu::str&, const s_Target&);
fu::str createUserTypeCanon_27MV22ZA(s_Kind, fu::view<char>, int, int, fu::view<char>, uint64_t);
unsigned speculateStruct_9CJmuVSD(s_DeclAsserts, int);
s_UserType& lookupUserType_mut_1qjplDUo(fu::view<char>, s_Module&, const s_TokenIdx&, const s_Context&);
s_Type despeculateStruct_9CJmuVSD(s_Type&&);
void hash_qRo1x0wq(s_TEA&, uint64_t);
static fu::str TODO_FIX_getRecursionError_gDsnGKHT(const s_UserType&, const s_Type&, const s_CurrentFn&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
s_Intlit Intlit_MpuZ8TbN(uint64_t, bool, fu::str&&, bool, bool, uint64_t);
s_Type make_non_copyable_9CJmuVSD(s_Type&&);
void USAGE_setMaxUsage_CaGDtmWo(s_Type&, int);
static void visit_p7GM6uKi(int, s_SolverState&, const s_TokenIdx&, const s_Context&);
static void walk_gDsnGKHT(s_Node&, fu::view<char>, fu::view<char>, fu::view<char>, fu::view<char>, const s_ScopeItem&);
void hash_lweHUmk8(s_TEA&, const s_TEA&);
static void sighashNode_gDsnGKHT(const s_SolvedNode&, const s_Target&, s_TEA&, s_Map_4FUR4uzUhqd&, fu::vec<s_Target>&, s_Set_aQNJhbMknMf&, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static const s_TEA& computeFnSighash_gDsnGKHT(const s_Target&, s_Map_4FUR4uzUhqd&, fu::vec<s_Target>&, s_Set_aQNJhbMknMf&, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
void hash_qw8SyzVJ(s_TEA&, unsigned);
s_TEA& non_zero_lweHUmk8(s_TEA&);
static void flag_gDsnGKHT(s_Regions&, const s_Lifetime&, bool, fu::view<s_BitSet>, fu::view<int>, const s_CurrentFn&, const s_SolverState&, fu::view<s_Helpers>, const s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
static void visit_CLRxF4GH(s_SolvedNode&, fu::view<s_BitSet>, fu::view<int>, int&, s_Unsequenced&, const s_CurrentFn&, s_SolverState&, fu::view<s_Helpers>, s_TokenIdx&, const s_Context&, const s_Module&, const s_Options&);
bool has_inter_ZwXYCruz(const s_BitSet&, const s_BitSet&);
s_Scope Scope_exports_z0QqoZ5t(const s_Scope&, int, const fu::vec<int>&);

                                #ifndef DEF_s_Kind
                                #define DEF_s_Kind
enum s_Kind: fu::u8
{
    s_Kind_sof = 1u,
    s_Kind_err = 2u,
    s_Kind_eof = 3u,
    s_Kind_id = 4u,
    s_Kind_op = 5u,
    s_Kind_int = 6u,
    s_Kind_real = 7u,
    s_Kind_char = 8u,
    s_Kind_str = 9u,
    s_Kind_bool = 10u,
    s_Kind_definit = 11u,
    s_Kind_empty = 12u,
    s_Kind_struct = 13u,
    s_Kind_union = 14u,
    s_Kind_primitive = 15u,
    s_Kind_flags = 16u,
    s_Kind_enum = 17u,
    s_Kind_fn = 18u,
    s_Kind_copy = 19u,
    s_Kind_move = 20u,
    s_Kind_arrlit = 21u,
    s_Kind_not = 22u,
    s_Kind_call = 23u,
    s_Kind_call_indir = 24u,
    s_Kind_argid = 25u,
    s_Kind_root = 26u,
    s_Kind_block = 27u,
    s_Kind_if = 28u,
    s_Kind_or = 29u,
    s_Kind_and = 30u,
    s_Kind_loop = 31u,
    s_Kind_jump = 32u,
    s_Kind___far_jump = 33u,
    s_Kind_defer = 34u,
    s_Kind_try = 35u,
    s_Kind_let = 36u,
    s_Kind_letdef = 37u,
    s_Kind_typecast = 38u,
    s_Kind_typeassert = 39u,
    s_Kind_typeparam = 40u,
    s_Kind_unwrap = 41u,
    s_Kind_pragma = 42u,
    s_Kind_break = 43u,
    s_Kind_return = 44u,
    s_Kind_continue = 45u,
    s_Kind_import = 46u,
    s_Kind_addroffn = 47u,
    s_Kind_forfieldsof = 48u,
    s_Kind_members = 49u,
    s_Kind_fnbranch = 50u,
    s_Kind_pattern = 51u,
    s_Kind_typeunion = 52u,
    s_Kind_typetag = 53u,
    s_Kind___relaxed = 54u,
    s_Kind___convert = 55u,
    s_Kind___preceding_ref_arg = 56u,
    s_Kind___serialized_type = 57u,
    s_Kind___serialized_addrof_type_fn = 58u,
    s_Kind___litfix_bound = 59u,
    s_Kind___no_kind_yet = 60u,
    s_Kind___tombstone = 61u,
    s_Kind_type = 62u,
    s_Kind_var = 63u,
    s_Kind_field = 64u,
    s_Kind_enumv = 65u,
    s_Kind_template = 66u,
    s_Kind___native = 67u,
    s_Kind_inline = 68u,
};
                                #endif

                                #ifndef DEF_s_Flags
                                #define DEF_s_Flags
inline constexpr s_Flags s_Flags_F_CALL_HAS_DOT = 1u;
inline constexpr s_Flags s_Flags_F_CALL_HAS_ARGPARENS = 2u;
inline constexpr s_Flags s_Flags_F_CALL_HAS_NAMED_ARGS = 4u;
inline constexpr s_Flags s_Flags_F_OPERATOR = 8u;
inline constexpr s_Flags s_Flags_F_TYPENAME = 16u;
inline constexpr s_Flags s_Flags_F_COMPOUND_ID = 32u;
inline constexpr s_Flags s_Flags_F_ARGID_IS_OPTIONAL = 64u;
inline constexpr s_Flags s_Flags_F_LAX = 128u;
inline constexpr s_Flags s_Flags_F_SHADOW = 256u;
inline constexpr s_Flags s_Flags_F_MUSTNAME = 512u;
inline constexpr s_Flags s_Flags_F_MUT = 1024u;
inline constexpr s_Flags s_Flags_F_CONST = 2048u;
inline constexpr s_Flags s_Flags_F_VAL = 4096u;
inline constexpr s_Flags s_Flags_F_REF = 8192u;
inline constexpr s_Flags s_Flags_F_IMPLICIT = 16384u;
inline constexpr s_Flags s_Flags_F_USING = 32768u;
inline constexpr s_Flags s_Flags_F_CONVERSION = 65536u;
inline constexpr s_Flags s_Flags_F_TEST_painted = 131072u;
inline constexpr s_Flags s_Flags_F_PUB = 262144u;
inline constexpr s_Flags s_Flags_F_EXTERN = 524288u;
inline constexpr s_Flags s_Flags_F_HOTSWAP = 1048576u;
inline constexpr s_Flags s_Flags_F_PREDICATE = 2097152u;
inline constexpr s_Flags s_Flags_F_LT_RETURNED = 4194304u;
inline constexpr s_Flags s_Flags_F_REST_ARG = 8388608u;
inline constexpr s_Flags s_Flags_F_INJECTED = 16777216u;
inline constexpr s_Flags s_Flags_F_TEMPLATE = 33554432u;
inline constexpr s_Flags s_Flags_F_INLINE = 67108864u;
inline constexpr s_Flags s_Flags_F_LAMBDA = 134217728u;
inline constexpr s_Flags s_Flags_F_COW_INSIDE = 268435456u;

inline constexpr s_Flags MASK_s_Flags
    = s_Flags_F_CALL_HAS_DOT
    | s_Flags_F_CALL_HAS_ARGPARENS
    | s_Flags_F_CALL_HAS_NAMED_ARGS
    | s_Flags_F_OPERATOR
    | s_Flags_F_TYPENAME
    | s_Flags_F_COMPOUND_ID
    | s_Flags_F_ARGID_IS_OPTIONAL
    | s_Flags_F_LAX
    | s_Flags_F_SHADOW
    | s_Flags_F_MUSTNAME
    | s_Flags_F_MUT
    | s_Flags_F_CONST
    | s_Flags_F_VAL
    | s_Flags_F_REF
    | s_Flags_F_IMPLICIT
    | s_Flags_F_USING
    | s_Flags_F_CONVERSION
    | s_Flags_F_TEST_painted
    | s_Flags_F_PUB
    | s_Flags_F_EXTERN
    | s_Flags_F_HOTSWAP
    | s_Flags_F_PREDICATE
    | s_Flags_F_LT_RETURNED
    | s_Flags_F_REST_ARG
    | s_Flags_F_INJECTED
    | s_Flags_F_TEMPLATE
    | s_Flags_F_INLINE
    | s_Flags_F_LAMBDA
    | s_Flags_F_COW_INSIDE;
                                #endif

                                #ifndef DEF_s_VFacts
                                #define DEF_s_VFacts
inline constexpr s_VFacts s_VFacts_AlwaysTrue = s_VFacts(1u);
inline constexpr s_VFacts s_VFacts_AlwaysFalse = s_VFacts(2u);
inline constexpr s_VFacts s_VFacts_Typename = s_VFacts(4u);
inline constexpr s_VFacts s_VFacts_LeftAligned = s_VFacts(8u);
inline constexpr s_VFacts s_VFacts_RightAligned = s_VFacts(16u);

inline constexpr s_VFacts MASK_s_VFacts
    = s_VFacts_AlwaysTrue
    | s_VFacts_AlwaysFalse
    | s_VFacts_Typename
    | s_VFacts_LeftAligned
    | s_VFacts_RightAligned;
                                #endif

                                #ifndef DEF_s_SolverStatus
                                #define DEF_s_SolverStatus
inline constexpr s_SolverStatus s_SolverStatus_SS_LAZY = s_SolverStatus(1u);
inline constexpr s_SolverStatus s_SolverStatus_SS_DID_START = s_SolverStatus(2u);
inline constexpr s_SolverStatus s_SolverStatus_SS_DIRTY = s_SolverStatus(4u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FINALIZED = s_SolverStatus(8u);
inline constexpr s_SolverStatus s_SolverStatus_SS_UPDATED = s_SolverStatus(16u);
inline constexpr s_SolverStatus s_SolverStatus_SS_TYPE_RECUR = s_SolverStatus(32u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FN_RECUR = s_SolverStatus(64u);
inline constexpr s_SolverStatus s_SolverStatus_SS_FN_OOE_RTL = s_SolverStatus(128u);
inline constexpr s_SolverStatus s_SolverStatus_SS_NAME_UNUSED = s_SolverStatus(256u);
inline constexpr s_SolverStatus s_SolverStatus_SS_UNUSED = s_SolverStatus(512u);
inline constexpr s_SolverStatus s_SolverStatus_SS_MATCHED = s_SolverStatus(1024u);
inline constexpr s_SolverStatus s_SolverStatus_SS_MOVED_FROM = s_SolverStatus(2048u);
inline constexpr s_SolverStatus s_SolverStatus_SS_EXTERNAL_LINKAGE = s_SolverStatus(4096u);
inline constexpr s_SolverStatus s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE = s_SolverStatus(8192u);
inline constexpr s_SolverStatus s_SolverStatus_SS_TODO_FIX_was_rx_resize = s_SolverStatus(16384u);
inline constexpr s_SolverStatus s_SolverStatus_SS_Debug_AllPassesComplete = s_SolverStatus(32768u);

inline constexpr s_SolverStatus MASK_s_SolverStatus
    = s_SolverStatus_SS_LAZY
    | s_SolverStatus_SS_DID_START
    | s_SolverStatus_SS_DIRTY
    | s_SolverStatus_SS_FINALIZED
    | s_SolverStatus_SS_UPDATED
    | s_SolverStatus_SS_TYPE_RECUR
    | s_SolverStatus_SS_FN_RECUR
    | s_SolverStatus_SS_FN_OOE_RTL
    | s_SolverStatus_SS_NAME_UNUSED
    | s_SolverStatus_SS_UNUSED
    | s_SolverStatus_SS_MATCHED
    | s_SolverStatus_SS_MOVED_FROM
    | s_SolverStatus_SS_EXTERNAL_LINKAGE
    | s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE
    | s_SolverStatus_SS_TODO_FIX_was_rx_resize
    | s_SolverStatus_SS_Debug_AllPassesComplete;
                                #endif

                                #ifndef DEF_s_DeclAsserts
                                #define DEF_s_DeclAsserts
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOCOPY = s_DeclAsserts(1u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOVEC = s_DeclAsserts(2u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_TRIVIAL = s_DeclAsserts(4u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NODISCARD = s_DeclAsserts(8u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE = s_DeclAsserts(16u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE_CTX = s_DeclAsserts(32u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_PURE_FX = s_DeclAsserts(64u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOFLOW = s_DeclAsserts(128u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOTHROW = s_DeclAsserts(256u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOCRASH = s_DeclAsserts(512u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOIO = s_DeclAsserts(1024u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_FAST = s_DeclAsserts(2048u);
inline constexpr s_DeclAsserts s_DeclAsserts_A_NOINLINE = s_DeclAsserts(4096u);

inline constexpr s_DeclAsserts MASK_s_DeclAsserts
    = s_DeclAsserts_A_NOCOPY
    | s_DeclAsserts_A_NOVEC
    | s_DeclAsserts_A_TRIVIAL
    | s_DeclAsserts_A_NODISCARD
    | s_DeclAsserts_A_PURE
    | s_DeclAsserts_A_PURE_CTX
    | s_DeclAsserts_A_PURE_FX
    | s_DeclAsserts_A_NOFLOW
    | s_DeclAsserts_A_NOTHROW
    | s_DeclAsserts_A_NOCRASH
    | s_DeclAsserts_A_NOIO
    | s_DeclAsserts_A_FAST
    | s_DeclAsserts_A_NOINLINE;
                                #endif

                                #ifndef DEF_s_MayEscapeVia
                                #define DEF_s_MayEscapeVia
                                #endif

                                #ifndef DEF_s_ExitPaths
                                #define DEF_s_ExitPaths
inline constexpr s_ExitPaths s_ExitPaths_XP_NonEmptyReturn = s_ExitPaths(1u);
inline constexpr s_ExitPaths s_ExitPaths_XP_EmptyReturn = s_ExitPaths(2u);
inline constexpr s_ExitPaths s_ExitPaths_XP_NoReturn = s_ExitPaths(4u);

inline constexpr s_ExitPaths MASK_s_ExitPaths
    = s_ExitPaths_XP_NonEmptyReturn
    | s_ExitPaths_XP_EmptyReturn
    | s_ExitPaths_XP_NoReturn;
                                #endif

                                #ifndef DEF_s_ParseSyntax
                                #define DEF_s_ParseSyntax
inline constexpr s_ParseSyntax s_ParseSyntax_PS_PARENS = s_ParseSyntax(1u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_DISCARD_IF_BLOCK_TAIL = s_ParseSyntax(2u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_ALWAYS_DISCARD = s_ParseSyntax(4u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_NOT_AN_EXPRESSION = s_ParseSyntax(8u);
inline constexpr s_ParseSyntax s_ParseSyntax_PS_USING_EXPRESSION = s_ParseSyntax(16u);

inline constexpr s_ParseSyntax MASK_s_ParseSyntax
    = s_ParseSyntax_PS_PARENS
    | s_ParseSyntax_PS_DISCARD_IF_BLOCK_TAIL
    | s_ParseSyntax_PS_ALWAYS_DISCARD
    | s_ParseSyntax_PS_NOT_AN_EXPRESSION
    | s_ParseSyntax_PS_USING_EXPRESSION;
                                #endif

                                #ifndef DEF_s_FxMask
                                #define DEF_s_FxMask
inline constexpr s_FxMask s_FxMask_Fx_NotDeadCode = s_FxMask(1u);
inline constexpr s_FxMask s_FxMask_Fx_NonDeterministic = s_FxMask(2u);
inline constexpr s_FxMask s_FxMask_Fx_DontMoveUp = s_FxMask(4u);
inline constexpr s_FxMask s_FxMask_Fx_DontMoveDown = s_FxMask(8u);
inline constexpr s_FxMask s_FxMask_Fx_Input = s_FxMask(16u);
inline constexpr s_FxMask s_FxMask_Fx_Output = s_FxMask(32u);
inline constexpr s_FxMask s_FxMask_Fx_Throws = s_FxMask(64u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes = s_FxMask(128u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Div0 = s_FxMask(256u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_OOB = s_FxMask(512u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Assert = s_FxMask(1024u);
inline constexpr s_FxMask s_FxMask_Fx_Crashes_Exit = s_FxMask(2048u);
inline constexpr s_FxMask s_FxMask_Fx_Syscall = s_FxMask(4096u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks = s_FxMask(8192u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks_Alloc = s_FxMask(16384u);
inline constexpr s_FxMask s_FxMask_Fx_Blocks_Await = s_FxMask(32768u);

inline constexpr s_FxMask MASK_s_FxMask
    = s_FxMask_Fx_NotDeadCode
    | s_FxMask_Fx_NonDeterministic
    | s_FxMask_Fx_DontMoveUp
    | s_FxMask_Fx_DontMoveDown
    | s_FxMask_Fx_Input
    | s_FxMask_Fx_Output
    | s_FxMask_Fx_Throws
    | s_FxMask_Fx_Crashes
    | s_FxMask_Fx_Crashes_Div0
    | s_FxMask_Fx_Crashes_OOB
    | s_FxMask_Fx_Crashes_Assert
    | s_FxMask_Fx_Crashes_Exit
    | s_FxMask_Fx_Syscall
    | s_FxMask_Fx_Blocks
    | s_FxMask_Fx_Blocks_Alloc
    | s_FxMask_Fx_Blocks_Await;
                                #endif

                                #ifndef DEF_s_SolverNotes
                                #define DEF_s_SolverNotes
inline constexpr s_SolverNotes s_SolverNotes_N_FnRecursion = 1;
inline constexpr s_SolverNotes s_SolverNotes_N_FnResolve = 2;
inline constexpr s_SolverNotes s_SolverNotes_N_FnReopen = 4;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeRecursion = 8;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeResolve = 16;
inline constexpr s_SolverNotes s_SolverNotes_N_TypeReopen = 32;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadCode = 64;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadCall = 128;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadLet = 256;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadArrlit = 512;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadLoopInit = 1024;
inline constexpr s_SolverNotes s_SolverNotes_N_DeadConv = 2048;
inline constexpr s_SolverNotes s_SolverNotes_N_NonTrivAutoCopy = 4096;
inline constexpr s_SolverNotes s_SolverNotes_N_RelaxRespec = 8192;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedImplicit = 16384;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedCall = 32768;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedDefer = 65536;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedTry = 131072;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedAndOr = 262144;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedIfElse = 524288;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedArrlit = 1048576;
inline constexpr s_SolverNotes s_SolverNotes_N_UnusedLet = 2097152;
inline constexpr s_SolverNotes s_SolverNotes_N_BckMustSeq = 4194304;
inline constexpr s_SolverNotes s_SolverNotes_N_AARMustSeq = 8388608;
inline constexpr s_SolverNotes s_SolverNotes_N_AARSoftRisk = 16777216;
inline constexpr s_SolverNotes s_SolverNotes_N_MoveMustSeq = 33554432;
inline constexpr s_SolverNotes s_SolverNotes_N_McomUnwrapsLetdef = 67108864;
inline constexpr s_SolverNotes s_SolverNotes_N_SD_HasStaticInit = 134217728;
inline constexpr s_SolverNotes s_SolverNotes_N_SD_ExternPrivates = 268435456;
inline constexpr s_SolverNotes s_SolverNotes_N_COWRestrict = 536870912;

inline constexpr s_SolverNotes MASK_s_SolverNotes
    = s_SolverNotes_N_FnRecursion
    | s_SolverNotes_N_FnResolve
    | s_SolverNotes_N_FnReopen
    | s_SolverNotes_N_TypeRecursion
    | s_SolverNotes_N_TypeResolve
    | s_SolverNotes_N_TypeReopen
    | s_SolverNotes_N_DeadCode
    | s_SolverNotes_N_DeadCall
    | s_SolverNotes_N_DeadLet
    | s_SolverNotes_N_DeadArrlit
    | s_SolverNotes_N_DeadLoopInit
    | s_SolverNotes_N_DeadConv
    | s_SolverNotes_N_NonTrivAutoCopy
    | s_SolverNotes_N_RelaxRespec
    | s_SolverNotes_N_UnusedImplicit
    | s_SolverNotes_N_UnusedCall
    | s_SolverNotes_N_UnusedDefer
    | s_SolverNotes_N_UnusedTry
    | s_SolverNotes_N_UnusedAndOr
    | s_SolverNotes_N_UnusedIfElse
    | s_SolverNotes_N_UnusedArrlit
    | s_SolverNotes_N_UnusedLet
    | s_SolverNotes_N_BckMustSeq
    | s_SolverNotes_N_AARMustSeq
    | s_SolverNotes_N_AARSoftRisk
    | s_SolverNotes_N_MoveMustSeq
    | s_SolverNotes_N_McomUnwrapsLetdef
    | s_SolverNotes_N_SD_HasStaticInit
    | s_SolverNotes_N_SD_ExternPrivates
    | s_SolverNotes_N_COWRestrict;
                                #endif

                                #ifndef DEF_s_Helpers
                                #define DEF_s_Helpers
struct s_Helpers
{
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Target
                                #define DEF_s_Target
struct s_Target
{
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || _packed
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Lifetime
                                #define DEF_s_Lifetime
struct s_Lifetime
{
    fu::str uni0n;
    explicit operator bool() const noexcept
    {
        return false
            || uni0n
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BitSet
                                #define DEF_s_BitSet
struct s_BitSet
{
    fu::vec<fu::u8> _data;
    explicit operator bool() const noexcept
    {
        return false
            || _data
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TEA
                                #define DEF_s_TEA
struct s_TEA
{
    unsigned v0;
    unsigned v1;
    explicit operator bool() const noexcept
    {
        return false
            || v0
            || v1
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeItem
                                #define DEF_s_ScopeItem
struct s_ScopeItem
{
    fu::str id;
    uint64_t _packed;
    explicit operator bool() const noexcept
    {
        return false
            || id
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TokenIdx
                                #define DEF_s_TokenIdx
struct s_TokenIdx
{
    int modid;
    int tokidx;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || tokidx
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ValueType
                                #define DEF_s_ValueType
struct s_ValueType
{
    unsigned quals;
    s_VFacts vfacts;
    fu::str canon;
    explicit operator bool() const noexcept
    {
        return false
            || quals
            || vfacts
            || canon
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Scope
                                #define DEF_s_Scope
struct s_Scope
{
    fu::vec<s_Overload> overloads;
    fu::vec<s_Extended> extended;
    fu::vec<s_ScopeItem> items;
    fu::vec<s_ScopeItem> implicits;
    fu::vec<s_ScopeItem> globals;
    fu::vec<int> imports;
    fu::vec<int> privates;
    fu::vec<s_Target> usings;
    fu::vec<s_Target> converts;
    int pub_items;
    int pub_implicits;
    int pub_globals;
    int pub_converts;
    s_Scope(const s_Scope&) = delete;
    s_Scope(s_Scope&&) = default;
    s_Scope& operator=(const s_Scope&) = delete;
    s_Scope& operator=(s_Scope&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || overloads
            || extended
            || items
            || implicits
            || globals
            || imports
            || privates
            || usings
            || converts
            || pub_items
            || pub_implicits
            || pub_globals
            || pub_converts
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Type
                                #define DEF_s_Type
struct s_Type
{
    s_ValueType vtype;
    s_Lifetime lifetime;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || lifetime
        ;
    }
};
                                #endif

                                #ifndef DEF_s_COWInside
                                #define DEF_s_COWInside
struct s_COWInside
{
    s_ValueType vtype;
    s_TokenIdx token;
    int argTarget;
    s_MayEscapeVia mayEscapeVia;
    s_ExitPaths exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || vtype
            || token
            || argTarget
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Node
                                #define DEF_s_Node
struct s_Node
{
    s_Kind kind;
    s_DeclAsserts asserts;
    s_ParseSyntax syntax;
    s_Flags flags;
    fu::str value;
    fu::vec<s_Node> items;
    s_TokenIdx token;
    s_Node(const s_Node&) = default;
    s_Node(s_Node&&) = default;
    s_Node& operator=(s_Node&&) = default;
    s_Node& operator=(const s_Node& selfrec) { return *this = s_Node(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Template
                                #define DEF_s_Template
struct s_Template
{
    s_Node node;
    fu::vec<int> imports;
    explicit operator bool() const noexcept
    {
        return false
            || node
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolvedNode
                                #define DEF_s_SolvedNode
struct s_SolvedNode
{
    s_Kind kind;
    s_Helpers helpers;
    s_Flags flags;
    int _loop_start;
    fu::str value;
    fu::vec<s_SolvedNode> items;
    s_TokenIdx token;
    s_Type type;
    s_Target target;
    s_SolvedNode(const s_SolvedNode&) = default;
    s_SolvedNode(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(s_SolvedNode&&) = default;
    s_SolvedNode& operator=(const s_SolvedNode& selfrec) { return *this = s_SolvedNode(selfrec); }
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Overload
                                #define DEF_s_Overload
struct s_Overload
{
    s_Kind kind;
    s_Flags flags;
    s_SolverStatus status;
    s_DeclAsserts asserts;
    fu::str name;
    s_Type type;
    s_SolvedNode solved;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Extended
                                #define DEF_s_Extended
struct s_Extended
{
    int min;
    int max;
    fu::vec<s_Argument> args;
    fu::vec<s_COWInside> cows_inside;
    s_Target spec_of;
    s_Template tEmplate;
    fu::vec<s_Overload> args_n_locals;
    s_TEA sighash;
    s_FxMask fx_mask;
    int args_neg;
    explicit operator bool() const noexcept
    {
        return false
            || tEmplate
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverOutput
                                #define DEF_s_SolverOutput
struct s_SolverOutput
{
    s_SolvedNode root;
    s_Scope scope;
    s_SolverNotes notes;
    s_SolverOutput(const s_SolverOutput&) = delete;
    s_SolverOutput(s_SolverOutput&&) = default;
    s_SolverOutput& operator=(const s_SolverOutput&) = delete;
    s_SolverOutput& operator=(s_SolverOutput&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || scope
            || notes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Argument
                                #define DEF_s_Argument
struct s_Argument
{
    fu::str name;
    fu::str autocall;
    s_Type type;
    s_SolvedNode dEfault;
    s_Target target;
    s_Flags flags;
    unsigned written_to;
    s_BitSet may_invalidate;
    s_BitSet may_alias;
    explicit operator bool() const noexcept
    {
        return false
            || name
            || autocall
            || type
            || dEfault
            || target
            || flags
            || written_to
            || may_invalidate
            || may_alias
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CGDefects
                                #define DEF_s_CGDefects
inline constexpr s_CGDefects s_CGDefects_GNUStmtExpr = s_CGDefects(1u);
inline constexpr s_CGDefects s_CGDefects_Goto = s_CGDefects(2u);
inline constexpr s_CGDefects s_CGDefects_PointlessMustSeq = s_CGDefects(4u);
inline constexpr s_CGDefects s_CGDefects_LocalConstBool = s_CGDefects(8u);
inline constexpr s_CGDefects s_CGDefects_ConstCast = s_CGDefects(16u);
inline constexpr s_CGDefects s_CGDefects_PointlessLocal = s_CGDefects(32u);
inline constexpr s_CGDefects s_CGDefects_IrrelevantLiteral = s_CGDefects(64u);
inline constexpr s_CGDefects s_CGDefects_DuplicateFunctions = s_CGDefects(128u);

inline constexpr s_CGDefects MASK_s_CGDefects
    = s_CGDefects_GNUStmtExpr
    | s_CGDefects_Goto
    | s_CGDefects_PointlessMustSeq
    | s_CGDefects_LocalConstBool
    | s_CGDefects_ConstCast
    | s_CGDefects_PointlessLocal
    | s_CGDefects_IrrelevantLiteral
    | s_CGDefects_DuplicateFunctions;
                                #endif

                                #ifndef DEF_s_Sample_Time
                                #define DEF_s_Sample_Time
struct s_Sample_Time
{
    double time;
    explicit operator bool() const noexcept
    {
        return false
            || time
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOrder
                                #define DEF_s_ModuleOrder
struct s_ModuleOrder
{
    int dep_depth;
    explicit operator bool() const noexcept
    {
        return false
            || dep_depth
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LexerOutput
                                #define DEF_s_LexerOutput
struct s_LexerOutput
{
    fu::vec<s_Token> tokens;
    explicit operator bool() const noexcept
    {
        return false
            || tokens
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_95BJOojOc45
                                #define DEF_s_Set_95BJOojOc45
struct s_Set_95BJOojOc45
{
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_6ARmtH0K78f
                                #define DEF_s_Set_6ARmtH0K78f
struct s_Set_6ARmtH0K78f
{
    fu::vec<fu::str> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LineColChars
                                #define DEF_s_LineColChars
struct s_LineColChars
{
    int line;
    int col;
    int chars;
    explicit operator bool() const noexcept
    {
        return false
            || line
            || col
            || chars
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleStat
                                #define DEF_s_ModuleStat
struct s_ModuleStat
{
    double time;
    int alloc_count;
    int alloc_bytes;
    explicit operator bool() const noexcept
    {
        return false
            || time
            || alloc_count
            || alloc_bytes
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Shape
                                #define DEF_s_Shape
struct s_Shape
{
    fu::str basePrim;
    uint64_t non_triv_mask;
    uint64_t hash;
    int flatCount;
    int declDepth;
    explicit operator bool() const noexcept
    {
        return false
            || basePrim
            || non_triv_mask
            || hash
            || flatCount
            || declDepth
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Profile
                                #define DEF_s_Profile
struct s_Profile
{
    s_Sample_Time now;
    explicit operator bool() const noexcept
    {
        return false
            || now
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Token
                                #define DEF_s_Token
struct s_Token
{
    s_Kind kind;
    s_LineColChars lcc;
    fu::str value;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_cUwKMz9CPyg
                                #define DEF_s_Map_cUwKMz9CPyg
struct s_Map_cUwKMz9CPyg
{
    s_Set_6ARmtH0K78f keys;
    fu::vec<fu::str> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Import
                                #define DEF_s_Import
struct s_Import
{
    s_TokenIdx token;
    fu::str pattern;
    int modid;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || pattern
            || modid
        ;
    }
};
                                #endif

                                #ifndef DEF_s_BuildHacks
                                #define DEF_s_BuildHacks
struct s_BuildHacks
{
    s_Set_6ARmtH0K78f link;
    s_Set_6ARmtH0K78f include_dirs;
    s_Set_6ARmtH0K78f extra_sources;
    explicit operator bool() const noexcept
    {
        return false
            || link
            || include_dirs
            || extra_sources
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleStats
                                #define DEF_s_ModuleStats
struct s_ModuleStats
{
    s_ModuleStat lex;
    s_ModuleStat parse;
    s_ModuleStat solve;
    s_ModuleStat codegen;
    explicit operator bool() const noexcept
    {
        return false
            || lex
            || parse
            || solve
            || codegen
        ;
    }
};
                                #endif

                                #ifndef DEF_s_UserType
                                #define DEF_s_UserType
struct s_UserType
{
    s_Kind kind;
    fu::str name;
    s_Target target;
    fu::vec<s_ScopeItem> items;
    fu::vec<s_ScopeItem> implicits;
    s_Set_95BJOojOc45 imports;
    fu::vec<s_Target> converts;
    s_Shape shape;
    explicit operator bool() const noexcept
    {
        return false
            || kind
        ;
    }
};
                                #endif

                                #ifndef DEF_s_NukeOnRebuild
                                #define DEF_s_NukeOnRebuild
struct s_NukeOnRebuild
{
    s_Map_cUwKMz9CPyg files;
    s_Map_cUwKMz9CPyg fuzzy;
    explicit operator bool() const noexcept
    {
        return false
            || files
            || fuzzy
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ParserOutput
                                #define DEF_s_ParserOutput
struct s_ParserOutput
{
    s_Node root;
    fu::vec<s_Import> imports;
    fu::vec<fu::str> warnings;
    explicit operator bool() const noexcept
    {
        return false
            || root
            || imports
            || warnings
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CodegenOutput
                                #define DEF_s_CodegenOutput
struct s_CodegenOutput
{
    fu::str src;
    s_Set_6ARmtH0K78f includes_headers;
    s_BuildHacks hacks;
    s_Set_95BJOojOc45 testsuite_modids;
    s_CGDefects defects;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || includes_headers
            || hacks
            || testsuite_modids
            || defects
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleInputs
                                #define DEF_s_ModuleInputs
struct s_ModuleInputs
{
    fu::str src;
    s_LexerOutput lex;
    s_ParserOutput parse;
    explicit operator bool() const noexcept
    {
        return false
            || src
            || lex
            || parse
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Context
                                #define DEF_s_Context
struct s_Context
{
    fu::str fudir;
    fu::str base_dir;
    fu::vec<s_Module> modules;
    fu::vec<int> dep_order;
    s_NukeOnRebuild nuke;
    s_Context(const s_Context&) = delete;
    s_Context(s_Context&&) = default;
    s_Context& operator=(const s_Context&) = delete;
    s_Context& operator=(s_Context&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || fudir
            || base_dir
            || modules
            || dep_order
            || nuke
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ModuleOutputs
                                #define DEF_s_ModuleOutputs
struct s_ModuleOutputs
{
    fu::vec<s_UserType> types;
    s_SolverOutput solve;
    s_CodegenOutput cpp;
    s_ModuleOutputs(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs(s_ModuleOutputs&&) = default;
    s_ModuleOutputs& operator=(const s_ModuleOutputs&) = delete;
    s_ModuleOutputs& operator=(s_ModuleOutputs&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || solve
            || cpp
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Module
                                #define DEF_s_Module
struct s_Module
{
    int modid;
    fu::str fname;
    s_ModuleInputs in;
    s_ModuleOrder order;
    s_ModuleOutputs out;
    s_ModuleStats stats;
    s_Profile profile;
    s_Module(const s_Module&) = delete;
    s_Module(s_Module&&) = default;
    s_Module& operator=(const s_Module&) = delete;
    s_Module& operator=(s_Module&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || fname
            || in
            || order
            || out
            || stats
            || profile
        ;
    }
};
                                #endif

                                #ifndef DEF_s_DevOptions
                                #define DEF_s_DevOptions
inline constexpr s_DevOptions s_DevOptions_DEV_Print = s_DevOptions(1u);
inline constexpr s_DevOptions s_DevOptions_DEV_Parallel = s_DevOptions(2u);
inline constexpr s_DevOptions s_DevOptions_DEV_ExpectFail = s_DevOptions(4u);
inline constexpr s_DevOptions s_DevOptions_DEV_HappyPathOnly = s_DevOptions(8u);
inline constexpr s_DevOptions s_DevOptions_DEV_DontFoldLiterals = s_DevOptions(16u);
inline constexpr s_DevOptions s_DevOptions_DEV_IgnoreDefects = s_DevOptions(32u);
inline constexpr s_DevOptions s_DevOptions_DEV_CG_LifetimeAnnots = s_DevOptions(64u);

inline constexpr s_DevOptions MASK_s_DevOptions
    = s_DevOptions_DEV_Print
    | s_DevOptions_DEV_Parallel
    | s_DevOptions_DEV_ExpectFail
    | s_DevOptions_DEV_HappyPathOnly
    | s_DevOptions_DEV_DontFoldLiterals
    | s_DevOptions_DEV_IgnoreDefects
    | s_DevOptions_DEV_CG_LifetimeAnnots;
                                #endif

                                #ifndef DEF_s_Lint
                                #define DEF_s_Lint
struct s_Lint
{
    int maxwarn;
    explicit operator bool() const noexcept
    {
        return false
            || maxwarn
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Options
                                #define DEF_s_Options
struct s_Options
{
    s_Lint lint;
    s_SolverNotes break_notes;
    s_CGDefects break_defects;
    s_DevOptions dev;
    unsigned shuffle;
    explicit operator bool() const noexcept
    {
        return false
            || lint
            || break_notes
            || break_defects
            || dev
            || shuffle
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Effects
                                #define DEF_s_Effects
struct s_Effects
{
    s_FxMask fx_mask;
    explicit operator bool() const noexcept
    {
        return false
            || fx_mask
        ;
    }
};
                                #endif

                                #ifndef DEF_s_WriteID
                                #define DEF_s_WriteID
struct s_WriteID
{
    unsigned _locid_and_hash;
    explicit operator bool() const noexcept
    {
        return false
            || _locid_and_hash
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_95BJOojOc45
                                #define DEF_s_Set_95BJOojOc45
struct s_Set_95BJOojOc45
{
    fu::vec<int> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_2i2v33LNlqd
                                #define DEF_s_Set_2i2v33LNlqd
struct s_Set_2i2v33LNlqd
{
    fu::vec<s_WriteID> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_EcBtE1sFv98
                                #define DEF_s_LocidMap_EcBtE1sFv98
struct s_LocidMap_EcBtE1sFv98
{
    fu::vec<s_Type> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_DC5gktNgm89
                                #define DEF_s_LocidMap_DC5gktNgm89
struct s_LocidMap_DC5gktNgm89
{
    fu::vec<unsigned> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_93S9qlGbUSi
                                #define DEF_s_LocidMap_93S9qlGbUSi
struct s_LocidMap_93S9qlGbUSi
{
    fu::vec<s_Lifetime> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_I7YkM5C62o7
                                #define DEF_s_LocidMap_I7YkM5C62o7
struct s_LocidMap_I7YkM5C62o7
{
    fu::vec<s_LocidSet> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_OjaSaYAvjq2
                                #define DEF_s_LocidMap_OjaSaYAvjq2
struct s_LocidMap_OjaSaYAvjq2
{
    fu::vec<s_Set_95BJOojOc45> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidMap_OrMuSNs7d4i
                                #define DEF_s_LocidMap_OrMuSNs7d4i
struct s_LocidMap_OrMuSNs7d4i
{
    fu::vec<s_Set_2i2v33LNlqd> _values;
    explicit operator bool() const noexcept
    {
        return false
            || _values
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeMemo
                                #define DEF_s_ScopeMemo
struct s_ScopeMemo
{
    int items_len;
    int implicits_len;
    int imports_len;
    int privates_len;
    int usings_len;
    int converts_len;
    int helpers_len;
    explicit operator bool() const noexcept
    {
        return false
            || items_len
            || implicits_len
            || imports_len
            || privates_len
            || usings_len
            || converts_len
            || helpers_len
        ;
    }
};
                                #endif

                                #ifndef DEF_s_LocidSet
                                #define DEF_s_LocidSet
struct s_LocidSet
{
    s_BitSet _bitset;
    explicit operator bool() const noexcept
    {
        return false
            || _bitset
        ;
    }
};
                                #endif

                                #ifndef DEF_s_EventsSnap
                                #define DEF_s_EventsSnap
struct s_EventsSnap
{
    s_LocidMap_OrMuSNs7d4i invalidated_by;
    explicit operator bool() const noexcept
    {
        return false
            || invalidated_by
        ;
    }
};
                                #endif

                                #ifndef DEF_s_VarUsage
                                #define DEF_s_VarUsage
struct s_VarUsage
{
    s_LocidSet done_relaxing;
    s_LocidMap_EcBtE1sFv98 var_usage;
    explicit operator bool() const noexcept
    {
        return false
            || done_relaxing
            || var_usage
        ;
    }
};
                                #endif

                                #ifndef DEF_s_PostdomSnap
                                #define DEF_s_PostdomSnap
struct s_PostdomSnap
{
    s_LocidSet used_again;
    s_LocidMap_DC5gktNgm89 ever_written;
    s_MayEscapeVia mayEscapeVia;
    s_ExitPaths exitPaths;
    explicit operator bool() const noexcept
    {
        return false
            || used_again
            || ever_written
            || mayEscapeVia
            || exitPaths
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Events
                                #define DEF_s_Events
struct s_Events
{
    s_EventsSnap snap;
    s_LocidSet used_in_a_loop;
    fu::vec<s_PrecedingRefArg> preceding_ref_args;
    fu::vec<s_COWInside> cows_inside;
    explicit operator bool() const noexcept
    {
        return false
            || snap
            || used_in_a_loop
            || preceding_ref_args
            || cows_inside
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Flow
                                #define DEF_s_Flow
struct s_Flow
{
    s_LocidMap_93S9qlGbUSi rg_parents;
    s_LocidMap_93S9qlGbUSi rg_invalidates;
    s_LocidMap_OjaSaYAvjq2 rg_children;
    s_LocidMap_I7YkM5C62o7 at_soft_risk;
    s_LocidMap_I7YkM5C62o7 at_hard_risk;
    s_LocidSet bck_consider_copy;
    s_LocidSet is_arg;
    s_LocidMap_OjaSaYAvjq2 arg_parents;
    fu::vec<int> arg_targets;
    explicit operator bool() const noexcept
    {
        return false
            || rg_parents
            || rg_invalidates
            || rg_children
            || at_soft_risk
            || at_hard_risk
            || bck_consider_copy
            || is_arg
            || arg_parents
            || arg_targets
        ;
    }
};
                                #endif

                                #ifndef DEF_s_RevSpecPrototype
                                #define DEF_s_RevSpecPrototype
struct s_RevSpecPrototype
{
    s_SolvedNode solved;
    fu::vec<s_Overload> args_n_locals;
    int args_neg;
    explicit operator bool() const noexcept
    {
        return false
            || solved
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Postdom
                                #define DEF_s_Postdom
struct s_Postdom
{
    s_PostdomSnap snap;
    int write_loop_start;
    int read_loop_start;
    explicit operator bool() const noexcept
    {
        return false
            || snap
            || write_loop_start
            || read_loop_start
        ;
    }
};
                                #endif

                                #ifndef DEF_s_PrecedingRefArg
                                #define DEF_s_PrecedingRefArg
struct s_PrecedingRefArg
{
    s_TokenIdx callsite_token;
    s_Target target;
    int r;
    int w;
    s_SolvedNode arg;
    explicit operator bool() const noexcept
    {
        return false
            || callsite_token
            || target
            || r
            || w
            || arg
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CurrentFn
                                #define DEF_s_CurrentFn
struct s_CurrentFn
{
    s_SolvedNode out;
    s_ScopeMemo scope0;
    s_DeclAsserts asserts;
    s_Flow flow;
    s_Set_95BJOojOc45 far_jumps;
    s_Effects effects;
    s_Events events;
    int autoshadow_ok;
    s_VarUsage relaxed;
    bool TODO_FIX_isInline;
    int TODO_FIX_catches;
    fu::vec<s_Target> already_inlined;
    int conv_safety;
    int args_neg;
    s_Postdom postdom;
    s_LocidMap_OjaSaYAvjq2 TODO_FIX_children;
    s_RevSpecPrototype rev_spec_proto;
    int TODO_FIX_bckCantDealWithNestedDefers;
    int TODO_FIX_unique;
    explicit operator bool() const noexcept
    {
        return false
            || out
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverPass
                                #define DEF_s_SolverPass
enum s_SolverPass: fu::u8
{
    s_SolverPass_Solving = 0u,
    s_SolverPass_RelaxMut = 1u,
    s_SolverPass_BorrowCheck = 2u,
    s_SolverPass_ArgumentsAtRisk = 3u,
    s_SolverPass_MaybeCopyOrMove = 4u,
    s_SolverPass_RelaxCopyResize = 5u,
};
                                #endif

                                #ifndef DEF_s_HelpersMask
                                #define DEF_s_HelpersMask
inline constexpr s_HelpersMask s_HelpersMask_HM_CanBreak = s_HelpersMask(1u);
inline constexpr s_HelpersMask s_HelpersMask_HM_CanReturn = s_HelpersMask(2u);
inline constexpr s_HelpersMask s_HelpersMask_HM_Anon = s_HelpersMask(4u);
inline constexpr s_HelpersMask s_HelpersMask_HM_Function = s_HelpersMask(8u);
inline constexpr s_HelpersMask s_HelpersMask_HM_Lambda = s_HelpersMask(16u);
inline constexpr s_HelpersMask s_HelpersMask_HM_UserType = s_HelpersMask(32u);
inline constexpr s_HelpersMask s_HelpersMask_HM_LabelUsed = s_HelpersMask(64u);
inline constexpr s_HelpersMask s_HelpersMask_HM_LoopPreheader = s_HelpersMask(128u);
inline constexpr s_HelpersMask s_HelpersMask_HM_LoopBody = s_HelpersMask(256u);

inline constexpr s_HelpersMask MASK_s_HelpersMask
    = s_HelpersMask_HM_CanBreak
    | s_HelpersMask_HM_CanReturn
    | s_HelpersMask_HM_Anon
    | s_HelpersMask_HM_Function
    | s_HelpersMask_HM_Lambda
    | s_HelpersMask_HM_UserType
    | s_HelpersMask_HM_LabelUsed
    | s_HelpersMask_HM_LoopPreheader
    | s_HelpersMask_HM_LoopBody;
                                #endif

                                #ifndef DEF_s_TypeParamFlags
                                #define DEF_s_TypeParamFlags
inline constexpr s_TypeParamFlags s_TypeParamFlags_TP_isArgSpec = s_TypeParamFlags(1u);
inline constexpr s_TypeParamFlags s_TypeParamFlags_TP_isTypenameArgSpec = s_TypeParamFlags(2u);
inline constexpr s_TypeParamFlags s_TypeParamFlags_TP_needsConsumedTypes = s_TypeParamFlags(4u);

inline constexpr s_TypeParamFlags MASK_s_TypeParamFlags
    = s_TypeParamFlags_TP_isArgSpec
    | s_TypeParamFlags_TP_isTypenameArgSpec
    | s_TypeParamFlags_TP_needsConsumedTypes;
                                #endif

                                #ifndef DEF_s_Warning
                                #define DEF_s_Warning
struct s_Warning
{
    int locid;
    explicit operator bool() const noexcept
    {
        return false
            || locid
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeSkip
                                #define DEF_s_ScopeSkip
struct s_ScopeSkip
{
    int start;
    int end;
    explicit operator bool() const noexcept
    {
        return false
            || start
            || end
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_6ARmtH0K78f
                                #define DEF_s_Set_6ARmtH0K78f
struct s_Set_6ARmtH0K78f
{
    fu::vec<fu::str> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_7aI0knTMWY7
                                #define DEF_s_Set_7aI0knTMWY7
struct s_Set_7aI0knTMWY7
{
    fu::vec<s_ValueType> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ConvCacheColumns
                                #define DEF_s_ConvCacheColumns
struct s_ConvCacheColumns
{
    fu::vec<s_ValueType> types;
    fu::vec<fu::vec<s_Target>> paths;
    fu::vec<fu::vec<int>> must_see;
    explicit operator bool() const noexcept
    {
        return false
            || types
            || paths
            || must_see
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ScopeSkipMemos
                                #define DEF_s_ScopeSkipMemos
struct s_ScopeSkipMemos
{
    fu::vec<s_ScopeSkip> items;
    fu::vec<s_ScopeSkip> implicits;
    fu::vec<s_ScopeSkip> imports;
    fu::vec<s_ScopeSkip> privates;
    fu::vec<s_ScopeSkip> usings;
    fu::vec<s_ScopeSkip> converts;
    fu::vec<s_ScopeSkip> helpers;
    explicit operator bool() const noexcept
    {
        return false
            || items
            || implicits
            || imports
            || privates
            || usings
            || converts
            || helpers
        ;
    }
};
                                #endif

                                #ifndef DEF_s_RevSpecInstance
                                #define DEF_s_RevSpecInstance
struct s_RevSpecInstance
{
    s_Target original;
    unsigned relaxed_quals;
    explicit operator bool() const noexcept
    {
        return false
            || original
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_2goAfCfe5Ta
                                #define DEF_s_Map_2goAfCfe5Ta
struct s_Map_2goAfCfe5Ta
{
    s_Set_95BJOojOc45 keys;
    fu::vec<int> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_pdTv4gjINIj
                                #define DEF_s_Map_pdTv4gjINIj
struct s_Map_pdTv4gjINIj
{
    s_Set_6ARmtH0K78f keys;
    fu::vec<s_Type> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_CIvvfLLMMzl
                                #define DEF_s_Map_CIvvfLLMMzl
struct s_Map_CIvvfLLMMzl
{
    s_Set_6ARmtH0K78f keys;
    fu::vec<s_Target> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_lhf7SV3Fyjf
                                #define DEF_s_Map_lhf7SV3Fyjf
struct s_Map_lhf7SV3Fyjf
{
    s_Set_6ARmtH0K78f keys;
    fu::vec<s_TypeParam> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_RevSpecOutput
                                #define DEF_s_RevSpecOutput
struct s_RevSpecOutput
{
    unsigned relaxed_quals;
    s_Target instance_targ;
    explicit operator bool() const noexcept
    {
        return false
            || relaxed_quals
            || instance_targ
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_j5rW2s1zJ22
                                #define DEF_s_Map_j5rW2s1zJ22
struct s_Map_j5rW2s1zJ22
{
    s_Set_7aI0knTMWY7 keys;
    fu::vec<s_ConvCache_ColsAndBakes> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ChildTarget
                                #define DEF_s_ChildTarget
struct s_ChildTarget
{
    s_TokenIdx token;
    unsigned parent_rev;
    s_Target target;
    explicit operator bool() const noexcept
    {
        return false
            || token
            || parent_rev
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ConvCache_ColsAndBakes
                                #define DEF_s_ConvCache_ColsAndBakes
struct s_ConvCache_ColsAndBakes
{
    s_ConvCacheColumns columns;
    fu::vec<s_ScopeItem> field_items;
    fu::vec<s_ScopeItem> field_implicits;
    explicit operator bool() const noexcept
    {
        return false
            || columns
            || field_items
            || field_implicits
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CountedSet_95BJOojOc45
                                #define DEF_s_CountedSet_95BJOojOc45
struct s_CountedSet_95BJOojOc45
{
    s_Map_2goAfCfe5Ta counts;
    explicit operator bool() const noexcept
    {
        return false
            || counts
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SpecExtras
                                #define DEF_s_SpecExtras
struct s_SpecExtras
{
    fu::vec<s_ScopeItem> scope_items;
    s_Map_pdTv4gjINIj arg_spec_types;
    explicit operator bool() const noexcept
    {
        return false
            || scope_items
            || arg_spec_types
        ;
    }
};
                                #endif

                                #ifndef DEF_s_TypeParam
                                #define DEF_s_TypeParam
struct s_TypeParam
{
    s_Type matched;
    s_Type invariant;
    s_Type consumed;
    s_TypeParamFlags flags;
    explicit operator bool() const noexcept
    {
        return false
            || matched
            || invariant
            || consumed
            || flags
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SolverState
                                #define DEF_s_SolverState
struct s_SolverState
{
    s_Scope _scope;
    s_ScopeMemo _root_scope;
    s_ScopeSkipMemos _ss;
    s_Set_95BJOojOc45 _pub_imports;
    fu::vec<s_HelpersData> _helpers_data;
    fu::vec<s_Ephemeral> _ephemeral;
    s_Map_j5rW2s1zJ22 _conv_cache;
    int _solver_safety;
    int _qstack_safety;
    s_SolverNotes _notes;
    fu::vec<s_Warning> _warnings;
    fu::str shortModuleName;
    fu::vec<s_SolvedNode> TODO_FIX_convert_args;
    int TODO_FIX_inline_safety;
    s_Map_lhf7SV3Fyjf _typeParams;
    s_Target _solvingFnort;
    s_Target _nestingFnort;
    s_SolverState(const s_SolverState&) = delete;
    s_SolverState(s_SolverState&&) = default;
    s_SolverState& operator=(const s_SolverState&) = delete;
    s_SolverState& operator=(s_SolverState&&) = default;
    explicit operator bool() const noexcept
    {
        return false
            || _scope
            || _root_scope
            || _ss
            || _pub_imports
            || _helpers_data
            || _ephemeral
            || _conv_cache
            || _solver_safety
            || _qstack_safety
            || _notes
            || _warnings
            || shortModuleName
            || TODO_FIX_convert_args
            || TODO_FIX_inline_safety
            || _typeParams
            || _solvingFnort
            || _nestingFnort
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ReverseSpecialization
                                #define DEF_s_ReverseSpecialization
struct s_ReverseSpecialization
{
    s_RevSpecPrototype prototype;
    s_RevSpecInstance instance;
    fu::vec<s_RevSpecOutput> outputs;
    explicit operator bool() const noexcept
    {
        return false
            || prototype
            || instance
            || outputs
        ;
    }
};
                                #endif

                                #ifndef DEF_s_HelpersData
                                #define DEF_s_HelpersData
struct s_HelpersData
{
    s_Target target;
    s_SolverPass pass;
    s_HelpersMask mask;
    fu::str id;
    int local_of;
    int locals_start;
    s_Type ret_expect;
    s_Type ret_actual;
    s_Postdom postdom;
    s_Postdom loop_PREVITER;
    s_EventsSnap postevt;
    s_Helpers kills;
    explicit operator bool() const noexcept
    {
        return false
            || target
            || pass
            || mask
            || id
            || local_of
            || locals_start
            || ret_expect
            || ret_actual
            || postdom
            || loop_PREVITER
            || postevt
            || kills
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Ephemeral
                                #define DEF_s_Ephemeral
struct s_Ephemeral
{
    int local_of;
    unsigned revision;
    s_ScopeMemo scope_memo;
    s_ScopeSkipMemos scope_skip;
    s_SpecExtras spec_extras;
    s_CountedSet_95BJOojOc45 callers;
    s_CountedSet_95BJOojOc45 calls;
    fu::vec<s_ChildTarget> children;
    s_Map_CIvvfLLMMzl specs;
    s_Set_95BJOojOc45 far_jumps;
    s_ReverseSpecialization rev_spec;
    explicit operator bool() const noexcept
    {
        return false
            || local_of
            || revision
            || scope_memo
            || scope_skip
            || spec_extras
            || callers
            || calls
            || children
            || specs
            || far_jumps
            || rev_spec
        ;
    }
};
                                #endif

                                #ifndef DEF_s_DeadBreak
                                #define DEF_s_DeadBreak
enum s_DeadBreak: fu::u8
{
    s_DeadBreak_DeadBreak_Dont = 0u,
    s_DeadBreak_DeadBreak_Always = 1u,
    s_DeadBreak_DeadBreak_Only_WhileSolvingRecursion = 2u,
};
                                #endif

                                #ifndef DEF_s_StaticEval
                                #define DEF_s_StaticEval
enum s_StaticEval: fu::u8
{
    s_StaticEval_SE_Unknown = 0u,
    s_StaticEval_SE_False = 1u,
    s_StaticEval_SE_True = 2u,
};
                                #endif

                                #ifndef DEF_s_ClosureID
                                #define DEF_s_ClosureID
struct s_ClosureID
{
    s_Target target;
    unsigned revision;
    explicit operator bool() const noexcept
    {
        return false
            || target
        ;
    }
};
                                #endif

                                #ifndef DEF_s_UnpackedOffset
                                #define DEF_s_UnpackedOffset
struct s_UnpackedOffset
{
    int memberFlatOffset;
    int memberFlatCount;
    explicit operator bool() const noexcept
    {
        return false
            || memberFlatOffset
            || memberFlatCount
        ;
    }
};
                                #endif

                                #ifndef DEF_s_CodeFmt
                                #define DEF_s_CodeFmt
inline constexpr s_CodeFmt s_CodeFmt_FullContext = s_CodeFmt(1u);
inline constexpr s_CodeFmt s_CodeFmt_NoLeadContext = s_CodeFmt(2u);
inline constexpr s_CodeFmt s_CodeFmt_NoTailContext = s_CodeFmt(4u);
inline constexpr s_CodeFmt s_CodeFmt_NoContext = s_CodeFmt(8u);

inline constexpr s_CodeFmt MASK_s_CodeFmt
    = s_CodeFmt_FullContext
    | s_CodeFmt_NoLeadContext
    | s_CodeFmt_NoTailContext
    | s_CodeFmt_NoContext;
                                #endif

                                #ifndef DEF_s_Reorder
                                #define DEF_s_Reorder
struct s_Reorder
{
    bool applicable;
    fu::vec<int> map;
    explicit operator bool() const noexcept
    {
        return false
            || applicable
        ;
    }
};
                                #endif

                                #ifndef DEF_s_NamedArgs_AWe2QSUTLw0
                                #define DEF_s_NamedArgs_AWe2QSUTLw0
struct s_NamedArgs_AWe2QSUTLw0
{
    fu::vec<fu::str> names;
    s_BitSet optional;
    explicit operator bool() const noexcept
    {
        return false
            || names
            || optional
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_ukcriy4HHQd
                                #define DEF_s_Set_ukcriy4HHQd
struct s_Set_ukcriy4HHQd
{
    fu::vec<s_UserTypeCanon> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_UserTypeCanon
                                #define DEF_s_UserTypeCanon
struct s_UserTypeCanon
{
    int modid;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || modid
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Intlit
                                #define DEF_s_Intlit
struct s_Intlit
{
    fu::u8 base;
    fu::u8 minsize_i;
    fu::u8 minsize_u;
    fu::u8 minsize_f;
    bool sIgned;
    bool uNsigned;
    bool negative;
    uint64_t absval;
    fu::str error;
    explicit operator bool() const noexcept
    {
        return false
            || base
            || minsize_i
            || minsize_u
            || minsize_f
            || sIgned
            || uNsigned
            || negative
            || absval
            || error
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Set_aQNJhbMknMf
                                #define DEF_s_Set_aQNJhbMknMf
struct s_Set_aQNJhbMknMf
{
    fu::vec<s_Target> keys_asc;
    explicit operator bool() const noexcept
    {
        return false
            || keys_asc
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_uccvP8a6Yhg
                                #define DEF_s_Map_uccvP8a6Yhg
struct s_Map_uccvP8a6Yhg
{
    s_Set_aQNJhbMknMf keys;
    fu::vec<s_Target> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_UsedAgain
                                #define DEF_s_UsedAgain
                                #endif

                                #ifndef DEF_s_UsedAgainReason
                                #define DEF_s_UsedAgainReason
enum s_UsedAgainReason: fu::u8
{
    s_UsedAgainReason_None = 0u,
    s_UsedAgainReason_WrongPass = 1u,
    s_UsedAgainReason_UsedAgain = 2u,
    s_UsedAgainReason_UsedInALoop = 3u,
    s_UsedAgainReason_ArgReference = 4u,
    s_UsedAgainReason_StaticReference = 5u,
};
                                #endif

                                #ifndef DEF_s_RetypeOrder
                                #define DEF_s_RetypeOrder
struct s_RetypeOrder
{
    int retype_score;
    int index;
    explicit operator bool() const noexcept
    {
        return false
            || retype_score
            || index
        ;
    }
};
                                #endif

                                #ifndef DEF_s_NamedArgs_uE7WdS56SGd
                                #define DEF_s_NamedArgs_uE7WdS56SGd
struct s_NamedArgs_uE7WdS56SGd
{
    fu::vec<fu::str> names;
    s_BitSet optional;
    explicit operator bool() const noexcept
    {
        return false
            || names
            || optional
        ;
    }
};
                                #endif

                                #ifndef DEF_s_NativeQualities
                                #define DEF_s_NativeQualities
struct s_NativeQualities
{
    int name_start_idx;
    bool MayAlias;
    explicit operator bool() const noexcept
    {
        return false
            || name_start_idx
            || MayAlias
        ;
    }
};
                                #endif

                                #ifndef DEF_s_ArgQuery
                                #define DEF_s_ArgQuery
enum s_ArgQuery: fu::u8
{
    s_ArgQuery_AQ_WhyNotNovec = 1u,
};
                                #endif

                                #ifndef DEF_s_ArgRationale
                                #define DEF_s_ArgRationale
enum s_ArgRationale: fu::u8
{
    s_ArgRationale_CantTempCopy_HostArg_Ref = 1u,
    s_ArgRationale_CantTempCopy_HostArg_MutRef = 2u,
    s_ArgRationale_CantTempCopy_HostArg_Implicit = 3u,
    s_ArgRationale_CantTempCopy_FastFn = 4u,
    s_ArgRationale_CantTempCopy_NonCopiable = 5u,
    s_ArgRationale_CantTempCopy_ReturnedFromFn = 6u,
    s_ArgRationale_RequireVal_AliasesMutatedInjectedArgument = 7u,
};
                                #endif

                                #ifndef DEF_s_BorrowCheckPass
                                #define DEF_s_BorrowCheckPass
enum s_BorrowCheckPass: fu::u8
{
    s_BorrowCheckPass_BCK_bck = 1u,
    s_BorrowCheckPass_BCK_aar = 2u,
    s_BorrowCheckPass_BCK_ooe = 3u,
};
                                #endif

                                #ifndef DEF_s_RWQuals
                                #define DEF_s_RWQuals
struct s_RWQuals
{
    unsigned usage;
    unsigned written_to;
    explicit operator bool() const noexcept
    {
        return false
            || usage
            || written_to
        ;
    }
};
                                #endif

                                #ifndef DEF_s_SubRegion
                                #define DEF_s_SubRegion
struct s_SubRegion
{
    int flatCount;
    int flatOffset;
    explicit operator bool() const noexcept
    {
        return false
            || flatCount
            || flatOffset
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Map_4FUR4uzUhqd
                                #define DEF_s_Map_4FUR4uzUhqd
struct s_Map_4FUR4uzUhqd
{
    s_Set_6ARmtH0K78f keys;
    fu::vec<unsigned> vals;
    explicit operator bool() const noexcept
    {
        return false
            || keys
            || vals
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Regions
                                #define DEF_s_Regions
struct s_Regions
{
    s_LocidSet locids;
    s_BitSet arguments;
    explicit operator bool() const noexcept
    {
        return false
            || locids
            || arguments
        ;
    }
};
                                #endif

                                #ifndef DEF_s_Unsequenced
                                #define DEF_s_Unsequenced
struct s_Unsequenced
{
    s_Regions writes;
    s_Regions moves;
    s_Regions reads;
    explicit operator bool() const noexcept
    {
        return false
            || writes
            || moves
            || reads
        ;
    }
};
                                #endif

#ifndef fu_NO_fdefs

static s_Helpers push_gDsnGKHT(const s_HelpersData& data, s_SolverState& ss, fu::vec<s_Helpers>& _helpers)
{
    const s_Helpers ret = s_Helpers { ss._helpers_data.size() };
    _helpers += s_Helpers(ret);
    ss._helpers_data += s_HelpersData(data);
    return ret;
}

                                #ifndef DEF_clear_LqmWP5WQ68f
                                #define DEF_clear_LqmWP5WQ68f
inline void clear_LqmWP5WQ(s_Map_j5rW2s1zJ22& _)
{

    {
        s_Set_7aI0knTMWY7& __1 = _.keys;
        __1.keys_asc.clear();
    };
    _.vals.clear();
}
                                #endif

                                #ifndef DEF_x3Cx3E_F82w14kIpjk
                                #define DEF_x3Cx3E_F82w14kIpjk
inline int x3Cx3E_F82w14kI(const unsigned a, const unsigned b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_Si1HLHsuLXe
                                #define DEF_x3Cx3E_Si1HLHsuLXe
inline int x3Cx3E_Si1HLHsu(const s_VFacts a, const s_VFacts b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_XrkW2YUZsRk
                                #define DEF_x3Cx3E_XrkW2YUZsRk
inline int x3Cx3E_XrkW2YUZ(const int a, const int b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_OFzwR3BaA9j
                                #define DEF_x3Cx3E_OFzwR3BaA9j
inline int x3Cx3E_OFzwR3Ba(const char a, const char b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_bv5nK4Klcs3
                                #define DEF_x3Cx3E_bv5nK4Klcs3
inline int x3Cx3E_bv5nK4Kl(fu::view<char> a, fu::view<char> b)
{
    int cmp = x3Cx3E_XrkW2YUZ(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_OFzwR3Ba(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_VHap4TnOou0
                                #define DEF_x3Cx3E_VHap4TnOou0
inline int x3Cx3E_VHap4TnO(const s_ValueType& a, const s_ValueType& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_F82w14kI(a.quals, b.quals)))
        return cmp;
    else if ((cmp = x3Cx3E_Si1HLHsu(a.vfacts, b.vfacts)))
        return cmp;

    if ((cmp = x3Cx3E_bv5nK4Kl(a.canon, b.canon)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF___GX1qIKtw2kc
                                #define DEF___GX1qIKtw2kc
inline static void _GX1qIKtw(const int i, s_Set_7aI0knTMWY7& _, fu::vec<s_ConvCache_ColsAndBakes>& values)
{
    _.keys_asc.splice(i, 1);
    values.splice(i, 1);
}
                                #endif

                                #ifndef DEF_remove_qacjtO9IiMc
                                #define DEF_remove_qacjtO9IiMc
inline bool remove_qacjtO9I(s_Map_j5rW2s1zJ22& _, const s_ValueType& key)
{

    {
        s_Set_7aI0knTMWY7& __1 = _.keys;
        fu::vec<s_ConvCache_ColsAndBakes>& values = _.vals;
        fu::view<s_ValueType> keys_asc = __1.keys_asc;
        int lo = 0;
        int hi = keys_asc.size();
        while (lo < hi)
        {
            const int i = ((hi + lo) >> 1);
            const int cmp = x3Cx3E_VHap4TnO(keys_asc[i], key);
            if (cmp == 0)
            {
                _GX1qIKtw(i, __1, values);
                return true;
            }
            else if (cmp < 0)
                lo = (i + 1);
            else
                hi = i;

        };
    };
    return false;
}
                                #endif

static void _Scope_import__forceCopy_gDsnGKHT(const int modid, const bool pRivate, s_SolverState& ss, const s_Context& ctx)
{
    const s_Scope& s = ctx.modules[modid].out.solve.scope;
    const int usings0 = ss._scope.usings.size();
    const int converts0 = ss._scope.converts.size();
    fu::view<s_ScopeItem> BL_1_v {};
    ss._scope.items += (__extension__ (
    {
        fu::view<s_ScopeItem> what = s.items;
        const int pub_count = s.pub_items;
        const int N = what.size();
        BL_1_v = (fu::get_view(what, (pRivate ? pub_count : 0), (pRivate ? N : pub_count)));
    (void)0;}), static_cast<fu::view<s_ScopeItem>&&>(BL_1_v));
    fu::view<s_Target> BL_2_v {};
    ss._scope.converts += (__extension__ (
    {
        fu::view<s_Target> what = s.converts;
        const int pub_count = s.pub_converts;
        const int N = what.size();
        BL_2_v = (fu::get_view(what, (pRivate ? pub_count : 0), (pRivate ? N : pub_count)));
    (void)0;}), static_cast<fu::view<s_Target>&&>(BL_2_v));
    fu::view<s_ScopeItem> BL_3_v {};
    ss._scope.implicits += (__extension__ (
    {
        fu::view<s_ScopeItem> what = s.implicits;
        const int pub_count = s.pub_implicits;
        const int N = what.size();
        BL_3_v = (fu::get_view(what, (pRivate ? pub_count : 0), (pRivate ? N : pub_count)));
    (void)0;}), static_cast<fu::view<s_ScopeItem>&&>(BL_3_v));
    fu::view<s_ScopeItem> BL_4_v {};
    ss._scope.globals += (__extension__ (
    {
        fu::view<s_ScopeItem> what = s.globals;
        const int pub_count = s.pub_globals;
        const int N = what.size();
        BL_4_v = (fu::get_view(what, (pRivate ? pub_count : 0), (pRivate ? N : pub_count)));
    (void)0;}), static_cast<fu::view<s_ScopeItem>&&>(BL_4_v));
    const int converts1 = ss._scope.converts.size();
    if (converts1 != converts0)
        clear_LqmWP5WQ(ss._conv_cache);

    const int usings1 = ss._scope.usings.size();
    if (usings1 != usings0)
    {
        remove_qacjtO9I(ss._conv_cache, s_ValueType{});
    };
}

                                #ifndef DEF_t_i8
                                #define DEF_t_i8
extern const s_Type t_i8;
                                #endif

static s_Target createRawTypedef_gDsnGKHT(const fu::str& id, s_Type&& type, const s_Flags flags, const fu::str& name, const s_SolverStatus status, s_SolverState& ss, const s_Module& module)
{
    type = into_Typename_9CJmuVSD(s_Type(type));
    const s_Target target = Scope_create_z0QqoZ5t(ss._scope, s_Kind_type, (name ? name : id), type, flags, s_DeclAsserts{}, status, 0, false, module);
    if (id)
        Scope_set_z0QqoZ5t(ss._scope, id, target, !!(flags & s_Flags_F_SHADOW));

    return target;
}

                                #ifndef DEF_t_i16
                                #define DEF_t_i16
extern const s_Type t_i16;
                                #endif

                                #ifndef DEF_t_i32
                                #define DEF_t_i32
extern const s_Type t_i32;
                                #endif

                                #ifndef DEF_t_i64
                                #define DEF_t_i64
extern const s_Type t_i64;
                                #endif

                                #ifndef DEF_t_i128
                                #define DEF_t_i128
extern const s_Type t_i128;
                                #endif

                                #ifndef DEF_t_u8
                                #define DEF_t_u8
extern const s_Type t_u8;
                                #endif

                                #ifndef DEF_t_u16
                                #define DEF_t_u16
extern const s_Type t_u16;
                                #endif

                                #ifndef DEF_t_u32
                                #define DEF_t_u32
extern const s_Type t_u32;
                                #endif

                                #ifndef DEF_t_u64
                                #define DEF_t_u64
extern const s_Type t_u64;
                                #endif

                                #ifndef DEF_t_u128
                                #define DEF_t_u128
extern const s_Type t_u128;
                                #endif

                                #ifndef DEF_t_f32
                                #define DEF_t_f32
extern const s_Type t_f32;
                                #endif

                                #ifndef DEF_t_f64
                                #define DEF_t_f64
extern const s_Type t_f64;
                                #endif

                                #ifndef DEF_t_bool
                                #define DEF_t_bool
extern const s_Type t_bool;
                                #endif

                                #ifndef DEF_t_byte
                                #define DEF_t_byte
extern const s_Type t_byte;
                                #endif

                                #ifndef DEF_t_void
                                #define DEF_t_void
extern const s_Type t_void;
                                #endif

                                #ifndef DEF_t_never
                                #define DEF_t_never
extern const s_Type t_never;
                                #endif

                                #ifndef DEF_steal_3blx9gasb7e
                                #define DEF_steal_3blx9gasb7e
inline s_Node steal_3blx9gas(s_Node& v)
{
    /*MOV*/ s_Node ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static bool isTypeDecl_gDsnGKHT(const s_Kind kind)
{
    return (kind == s_Kind_struct) || (kind == s_Kind_union) || (kind == s_Kind_primitive) || (kind == s_Kind_enum) || (kind == s_Kind_flags);
}

static int unorderedClassify_gDsnGKHT(const s_Kind kind)
{
    if (kind == s_Kind_fn)
        return 1;
    else if (isTypeDecl_gDsnGKHT(kind))
        return 10;
    else
        return 0;

}

                                #ifndef DEF_str_cVIkXcxdYa6
                                #define DEF_str_cVIkXcxdYa6
inline fu::str str_cVIkXcxd(const s_SolverNotes n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & s_SolverNotes_N_FnRecursion)
            res += ("N_FnRecursion"_fu + ", "_fu);

        if (n & s_SolverNotes_N_FnResolve)
            res += ("N_FnResolve"_fu + ", "_fu);

        if (n & s_SolverNotes_N_FnReopen)
            res += ("N_FnReopen"_fu + ", "_fu);

        if (n & s_SolverNotes_N_TypeRecursion)
            res += ("N_TypeRecursion"_fu + ", "_fu);

        if (n & s_SolverNotes_N_TypeResolve)
            res += ("N_TypeResolve"_fu + ", "_fu);

        if (n & s_SolverNotes_N_TypeReopen)
            res += ("N_TypeReopen"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadCode)
            res += ("N_DeadCode"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadCall)
            res += ("N_DeadCall"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadLet)
            res += ("N_DeadLet"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadArrlit)
            res += ("N_DeadArrlit"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadLoopInit)
            res += ("N_DeadLoopInit"_fu + ", "_fu);

        if (n & s_SolverNotes_N_DeadConv)
            res += ("N_DeadConv"_fu + ", "_fu);

        if (n & s_SolverNotes_N_NonTrivAutoCopy)
            res += ("N_NonTrivAutoCopy"_fu + ", "_fu);

        if (n & s_SolverNotes_N_RelaxRespec)
            res += ("N_RelaxRespec"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedImplicit)
            res += ("N_UnusedImplicit"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedCall)
            res += ("N_UnusedCall"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedDefer)
            res += ("N_UnusedDefer"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedTry)
            res += ("N_UnusedTry"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedAndOr)
            res += ("N_UnusedAndOr"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedIfElse)
            res += ("N_UnusedIfElse"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedArrlit)
            res += ("N_UnusedArrlit"_fu + ", "_fu);

        if (n & s_SolverNotes_N_UnusedLet)
            res += ("N_UnusedLet"_fu + ", "_fu);

        if (n & s_SolverNotes_N_BckMustSeq)
            res += ("N_BckMustSeq"_fu + ", "_fu);

        if (n & s_SolverNotes_N_AARMustSeq)
            res += ("N_AARMustSeq"_fu + ", "_fu);

        if (n & s_SolverNotes_N_AARSoftRisk)
            res += ("N_AARSoftRisk"_fu + ", "_fu);

        if (n & s_SolverNotes_N_MoveMustSeq)
            res += ("N_MoveMustSeq"_fu + ", "_fu);

        if (n & s_SolverNotes_N_McomUnwrapsLetdef)
            res += ("N_McomUnwrapsLetdef"_fu + ", "_fu);

        if (n & s_SolverNotes_N_SD_HasStaticInit)
            res += ("N_SD_HasStaticInit"_fu + ", "_fu);

        if (n & s_SolverNotes_N_SD_ExternPrivates)
            res += ("N_SD_ExternPrivates"_fu + ", "_fu);

        if (n & s_SolverNotes_N_COWRestrict)
            res += ("N_COWRestrict"_fu + ", "_fu);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_x3Dx3D_KFMeZhJSBE8
                                #define DEF_x3Dx3D_KFMeZhJSBE8
inline bool operator==(fu::view<char> a, fu::view<char> b)
{
    return !x3Cx3E_bv5nK4Kl(a, b);
}
                                #endif

static s_TokenIdx tryBacktrack_gDsnGKHT(const s_TokenIdx& from, fu::view<char> v, const s_Kind k, const s_Context& ctx)
{
    s_TokenIdx here { from };
    while (here.tokidx-- > 0)
    {
        const s_Token& token = _token_xQNS19Zn(here, ctx);
        if (token.kind != k)
            break;
        else if (token.value == v)
            return here;

    };
    return s_TokenIdx{};
}

                                #ifndef DEF_MAX_u3ymTS2igIk
                                #define DEF_MAX_u3ymTS2igIk
inline int MAX_u3ymTS2i()
{
    return 2147483647;
}
                                #endif

static bool isFnOrType_gDsnGKHT(const s_Helpers& h, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    return !!s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask((s_HelpersMask_HM_Function | s_HelpersMask_HM_UserType))));
}

static const s_Overload& GET_gDsnGKHT(const s_Target& target, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const int modid = int(unsigned(((target._packed >> 40ull) & 0xfffffull)));
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    const s_Scope& _scope = ((modid == module.modid) ? ss._scope : ctx.modules[modid].out.solve.scope);
    if ((globid > 0) && (_scope.overloads.size() >= globid))
    {
        if (locid)
        {
            if ((_scope.extended.size() <= globid))
                BUG_u9Gbkniv("Invalid local target -modid."_fu, _here, ctx);
            else
            {
                const s_Extended& ext = _scope.extended[globid];
                return ext.args_n_locals[((ext.args_neg - ((locid > 0) ? 1 : 0)) + locid)];
            };
        }
        else
            return _scope.overloads[(globid - 1)];

    }
    else
        BUG_u9Gbkniv("GET: bad globid"_fu, _here, ctx);

}

static const s_Extended& EXT_gDsnGKHT(const s_Target& target, const s_SolverState& ss, const s_Context& ctx, const s_Module& module)
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v))
        return (*(const s_Extended*)fu::NIL);
    else
    {
        const int modid = int(unsigned(((target._packed >> 40ull) & 0xfffffull)));
        const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
        const s_Scope& _scope = ((modid == module.modid) ? ss._scope : ctx.modules[modid].out.solve.scope);
        return _scope.extended[globid];
    };
}

                                #ifndef DEF_uNsigned_fAw9WufW9A7
                                #define DEF_uNsigned_fAw9WufW9A7
inline unsigned uNsigned_fAw9WufW(const int v)
{
    return unsigned(v);
}
                                #endif

                                #ifndef DEF_iF_4WLXog4i1hk
                                #define DEF_iF_4WLXog4i1hk
inline const s_Ephemeral& iF_4WLXog4i(fu::view<s_Ephemeral> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Ephemeral*)fu::NIL);

}
                                #endif

static const s_Ephemeral& EPH_gDsnGKHT(const s_Target& target, const s_SolverState& ss, const s_Module& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return iF_4WLXog4i(ss._ephemeral, int(unsigned(((target._packed >> 20ull) & 0xfffffull))));
    else
        return (*(const s_Ephemeral*)fu::NIL);

}

                                #ifndef DEF_str_b1DlaKrHoN3
                                #define DEF_str_b1DlaKrHoN3
inline fu::str str_b1DlaKrH(const s_SolverPass n)
{
    if (n == s_SolverPass_Solving)
        return "Solving"_fu;
    else if (n == s_SolverPass_RelaxMut)
        return "RelaxMut"_fu;
    else if (n == s_SolverPass_BorrowCheck)
        return "BorrowCheck"_fu;
    else if (n == s_SolverPass_ArgumentsAtRisk)
        return "ArgumentsAtRisk"_fu;
    else if (n == s_SolverPass_MaybeCopyOrMove)
        return "MaybeCopyOrMove"_fu;
    else if (n == s_SolverPass_RelaxCopyResize)
        return "RelaxCopyResize"_fu;

    return fu::i64dec(int64_t(n));
}
                                #endif

                                #ifndef DEF_x7E_3lDd4lqoIHf
                                #define DEF_x7E_3lDd4lqoIHf
inline fu::str x7E_3lDd4lqo(fu::view<char> a, fu::view<char> b)
{
    return a + b;
}
                                #endif

                                #ifndef DEF_max_yeUdQhUA9W5
                                #define DEF_max_yeUdQhUA9W5
inline int max_yeUdQhUA(const int a, const int b)
{
    if ((a >= b))
        return a;
    else
        return b;

}
                                #endif

                                #ifndef DEF_str_WkqQ7QhOMvg
                                #define DEF_str_WkqQ7QhOMvg
inline fu::str str_WkqQ7QhO(const s_Kind n)
{
    if (n == s_Kind_sof)
        return "sof"_fu;
    else if (n == s_Kind_err)
        return "err"_fu;
    else if (n == s_Kind_eof)
        return "eof"_fu;
    else if (n == s_Kind_id)
        return "id"_fu;
    else if (n == s_Kind_op)
        return "op"_fu;
    else if (n == s_Kind_int)
        return "int"_fu;
    else if (n == s_Kind_real)
        return "real"_fu;
    else if (n == s_Kind_char)
        return "char"_fu;
    else if (n == s_Kind_str)
        return "str"_fu;
    else if (n == s_Kind_bool)
        return "bool"_fu;
    else if (n == s_Kind_definit)
        return "definit"_fu;
    else if (n == s_Kind_empty)
        return "empty"_fu;
    else if (n == s_Kind_struct)
        return "struct"_fu;
    else if (n == s_Kind_union)
        return "union"_fu;
    else if (n == s_Kind_primitive)
        return "primitive"_fu;
    else if (n == s_Kind_flags)
        return "flags"_fu;
    else if (n == s_Kind_enum)
        return "enum"_fu;
    else if (n == s_Kind_fn)
        return "fn"_fu;
    else if (n == s_Kind_copy)
        return "copy"_fu;
    else if (n == s_Kind_move)
        return "move"_fu;
    else if (n == s_Kind_arrlit)
        return "arrlit"_fu;
    else if (n == s_Kind_not)
        return "not"_fu;
    else if (n == s_Kind_call)
        return "call"_fu;
    else if (n == s_Kind_call_indir)
        return "call_indir"_fu;
    else if (n == s_Kind_argid)
        return "argid"_fu;
    else if (n == s_Kind_root)
        return "root"_fu;
    else if (n == s_Kind_block)
        return "block"_fu;
    else if (n == s_Kind_if)
    {
        return "if"_fu;
    }
    else if (n == s_Kind_or)
        return "or"_fu;
    else if (n == s_Kind_and)
        return "and"_fu;
    else if (n == s_Kind_loop)
        return "loop"_fu;
    else if (n == s_Kind_jump)
        return "jump"_fu;
    else if (n == s_Kind___far_jump)
        return "__far_jump"_fu;
    else if (n == s_Kind_defer)
        return "defer"_fu;
    else if (n == s_Kind_try)
        return "try"_fu;
    else if (n == s_Kind_let)
        return "let"_fu;
    else if (n == s_Kind_letdef)
        return "letdef"_fu;
    else if (n == s_Kind_typecast)
        return "typecast"_fu;
    else if (n == s_Kind_typeassert)
        return "typeassert"_fu;
    else if (n == s_Kind_typeparam)
        return "typeparam"_fu;
    else if (n == s_Kind_unwrap)
        return "unwrap"_fu;
    else if (n == s_Kind_pragma)
        return "pragma"_fu;
    else if (n == s_Kind_break)
        return "break"_fu;
    else if (n == s_Kind_return)
        return "return"_fu;
    else if (n == s_Kind_continue)
        return "continue"_fu;
    else if (n == s_Kind_import)
        return "import"_fu;
    else if (n == s_Kind_addroffn)
        return "addroffn"_fu;
    else if (n == s_Kind_forfieldsof)
        return "forfieldsof"_fu;
    else if (n == s_Kind_members)
        return "members"_fu;
    else if (n == s_Kind_fnbranch)
        return "fnbranch"_fu;
    else if (n == s_Kind_pattern)
        return "pattern"_fu;
    else if (n == s_Kind_typeunion)
        return "typeunion"_fu;
    else if (n == s_Kind_typetag)
        return "typetag"_fu;
    else if (n == s_Kind___relaxed)
        return "__relaxed"_fu;
    else if (n == s_Kind___convert)
        return "__convert"_fu;
    else if (n == s_Kind___preceding_ref_arg)
        return "__preceding_ref_arg"_fu;
    else if (n == s_Kind___serialized_type)
        return "__serialized_type"_fu;
    else if (n == s_Kind___serialized_addrof_type_fn)
        return "__serialized_addrof_type_fn"_fu;
    else if (n == s_Kind___litfix_bound)
        return "__litfix_bound"_fu;
    else if (n == s_Kind___no_kind_yet)
        return "__no_kind_yet"_fu;
    else if (n == s_Kind___tombstone)
        return "__tombstone"_fu;
    else if (n == s_Kind_type)
        return "type"_fu;
    else if (n == s_Kind_var)
        return "var"_fu;
    else if (n == s_Kind_field)
        return "field"_fu;
    else if (n == s_Kind_enumv)
        return "enumv"_fu;
    else if (n == s_Kind_template)
        return "template"_fu;
    else if (n == s_Kind___native)
        return "__native"_fu;
    else if (n == s_Kind_inline)
        return "inline"_fu;

    return fu::i64dec(int64_t(n));
}
                                #endif

static const s_Target& field_getParentStruct_gDsnGKHT(const s_Overload& o, const s_TokenIdx& _here, const s_Context& ctx)
{
    return o.solved.target ? o.solved.target : BUG_u9Gbkniv("field_getParentStruct: solved.target not set."_fu, _here, ctx);
}

static void PERF_slowPath_gDsnGKHT(const s_Options& options)
{
    // Hoisted:
    fu::str x {};

    if (options.dev & s_DevOptions_DEV_HappyPathOnly)
    {
        fu::println((fu::slate<1, fu::str> { static_cast<fu::str&&>((x = "DEV_HappyPathOnly: we ended up on a slow path."_fu, x)) }));
    };
}

                                #ifndef DEF_find_yP7FbxFZnZ0
                                #define DEF_find_yP7FbxFZnZ0
inline int find_yP7FbxFZ(fu::view<char> haystack, const char needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_J81b5Q24qw3
                                #define DEF_has_J81b5Q24qw3
inline bool has_J81b5Q24(fu::view<char> a, const char b)
{
    return (find_yP7FbxFZ(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_find_tnDs1wBzL75
                                #define DEF_find_tnDs1wBzL75
inline int find_tnDs1wBz(fu::view<char> haystack, const char needle, const int start)
{
    fu::view<char> slice = fu::get_view(haystack, start);
    const int res = find_yP7FbxFZ(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_P6nnQeDFu8l
                                #define DEF_replace_P6nnQeDFu8l
inline fu::str replace_P6nnQeDF(const fu::str& str, const char all, const char with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = 1;
        while (((next = find_tnDs1wBz(str, all, last)) >= 0))
        {

            {
                fu::str substr = fu::slice(str, last, next);
                const bool first = !last;
                if (!first)
                    result += with;

                result += substr;
            };
            last = (next + N);
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

static bool isLocal_gDsnGKHT(const s_Target& target)
{
    int BL_1_v {};
    return !!(__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
}

static s_Target parent_gDsnGKHT(const s_Target& target, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (isLocal_gDsnGKHT(target))
        return Target_xQNS19Zn(int(unsigned(((target._packed >> 40ull) & 0xfffffull))), int(unsigned(((target._packed >> 20ull) & 0xfffffull))), 0);
    else
        BUG_u9Gbkniv("Using .parent on a non-local"_fu, _here, ctx);

}

static fu::str human_gDsnGKHT(const fu::str& id, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    PERF_slowPath_gDsnGKHT(options);
    const s_Target t = tryParseClosureID_UvH3gYAB(id, _here, ctx).target;
    if (!t)
    {
        if (has_J81b5Q24(id, '\n'))
            return trim_V5IuMsej(replace_P6nnQeDF(id, '\n', ' '));
        else
            return fu::str(id);

    }
    else
        return (GET_gDsnGKHT(parent_gDsnGKHT(t, _here, ctx), ss, _here, ctx, module).name + ":"_fu) + GET_gDsnGKHT(t, ss, _here, ctx, module).name;

}

static fu::str str_IDns_gDsnGKHT(const s_Target& from, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (from)
        return qID_e44UlzzA(human_gDsnGKHT(GET_gDsnGKHT(from, ss, _here, ctx, module).name, ss, _here, ctx, module, options)) + ":"_fu;
    else
    {
        return fu::str{};
    };
}

static fu::str str_FDl5ha9X(const s_Target& t, const bool brief, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
    const s_Kind kind = o.kind;
    fu::str prefix = ""_fu;
    if (!brief)
    {
        prefix = str_WkqQ7QhO(kind);
        if (kind == s_Kind_var)
        {
            int BL_3_v {};
            fu::str _0 {};
            prefix = ((_0 = ((((((((o.flags & s_Flags_F_INJECTED) ? "injected "_fu : fu::str{}) + ((o.flags & s_Flags_F_IMPLICIT) ? "implicit "_fu : fu::str{})) + ((o.flags & s_Flags_F_CONST) ? "const "_fu : fu::str{})) + ((o.flags & s_Flags_F_MUT) ? "mut "_fu : fu::str{})) + (((o.flags & ((s_Flags_F_REF | s_Flags_F_MUT) | s_Flags_F_CONST)) == s_Flags_F_REF) ? (is_mutref_9CJmuVSD(o.type, _here, ctx) ? "mut "_fu : "const "_fu) : fu::str{})) + ((o.flags & s_Flags_F_REF) ? "ref "_fu : fu::str{})) + (((__extension__ (
            {
                const unsigned v = unsigned((t._packed & 0xfffffull));
                BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_3_v) < 0) ? "arg "_fu : fu::str{}))) ? static_cast<fu::str&&>(_0) : "let "_fu);
            prefix.pop();
        };
    };
    fu::str ns = ""_fu;
    if (kind == s_Kind_field)
        ns = str_IDns_gDsnGKHT(field_getParentStruct_gDsnGKHT(o, _here, ctx), ss, _here, ctx, module, options);

    return ((prefix ? (qKW_e44UlzzA(prefix) + " "_fu) : fu::str{}) + ns) + qID_e44UlzzA(human_gDsnGKHT(o.name, ss, _here, ctx, module, options));
}

                                #ifndef DEF_x7Ex3D_DKVpwRY7qT3
                                #define DEF_x7Ex3D_DKVpwRY7qT3
inline fu::view<char> x7Ex3D_DKVpwRY7(fu::str& a, fu::view<char> b)
{
    return (a += b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_imrGV5eVAvi
                                #define DEF_x3Cx3E_imrGV5eVAvi
inline int x3Cx3E_imrGV5eV(const s_Lifetime& a, const s_Lifetime& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_bv5nK4Kl(a.uni0n, b.uni0n)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_BJ686ShoLva
                                #define DEF_x3Cx3E_BJ686ShoLva
inline int x3Cx3E_BJ686Sho(const s_Type& a, const s_Type& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_VHap4TnO(a.vtype, b.vtype)))
        return cmp;
    else if ((cmp = x3Cx3E_imrGV5eV(a.lifetime, b.lifetime)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x3Dx3D_tUaLhVGEZ55
                                #define DEF_x3Dx3D_tUaLhVGEZ55
inline bool operator==(const s_Type& a, const s_Type& b)
{
    return !x3Cx3E_BJ686Sho(a, b);
}
                                #endif

static fu::str explainTypeName_gDsnGKHT(const s_Type& type, const bool brief, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    PERF_slowPath_gDsnGKHT(options);
    const s_UserType& s = tryLookupUserType_1qjplDUo(type.vtype, _here, ctx, module);
    if (s.kind)
    {
        return (!brief ? (qKW_e44UlzzA(str_WkqQ7QhO(s.kind)) + " "_fu) : fu::str{}) + qID_e44UlzzA(s.name);
    }
    else if (s_Type itemType = tryClear_sliceable_1qjplDUo(type.vtype, _here, ctx, module))
    {
        if (itemType == t_byte)
            return qKW_e44UlzzA("string"_fu);
        else
            return explainTypeName_gDsnGKHT(itemType, brief, _here, ctx, module, options) + qKW_e44UlzzA((TODO_FIX_isArray_9CJmuVSD(type) ? "[]"_fu : "[..]"_fu));

    }
    else if (is_zeroes_9CJmuVSD(type.vtype))
        return qKW_e44UlzzA("[]"_fu);
    else
        return qKW_e44UlzzA(((type.vtype.canon == t_bool.vtype.canon) ? "bool"_fu : ((type.vtype.canon == t_byte.vtype.canon) ? "byte"_fu : fu::str(type.vtype.canon))));

}

                                #ifndef DEF___mC17ZeXJtr9
                                #define DEF___mC17ZeXJtr9
inline static void _mC17ZeXJ(const s_Argument& arg, const int i, fu::str& reason, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (i)
        reason += ", "_fu;

    reason += explainTypeName_gDsnGKHT(arg.type, true, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_sRcJJyzDJbk
                                #define DEF_each_sRcJJyzDJbk
inline void each_sRcJJyzD(fu::view<s_Argument> a, fu::str& reason, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
        _mC17ZeXJ(a[i], i, reason, _here, ctx, module, options);

}
                                #endif

static fu::str fail_appendStack_gDsnGKHT(/*MOV*/ fu::str&& reason, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_SolverPass pass0 {};
    int callstack = 0;
    int skip_if_local_of = MAX_u3ymTS2i();
    bool ellipsis = false;
    for (int i = _helpers.size(); i-- > 0; )
    {
        const s_Helpers& h = _helpers[i];
        if (isFnOrType_gDsnGKHT(h, ss, _here, ctx))
        {
            const s_Overload& o = GET_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, ss, _here, ctx, module);
            const s_Extended& ext = EXT_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, ss, ctx, module);
            const s_Ephemeral& eph = EPH_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, ss, module);
            if (o.kind == s_Kind_fn)
            {
                if ((eph.local_of >= skip_if_local_of))
                {
                    if (!ellipsis)
                    {
                        ellipsis = true;
                        reason += ("\n                "_fu + qDIM_e44UlzzA("..."_fu));
                    };
                    continue;
                }
                else
                {
                    ellipsis = false;
                    if (!ext.spec_of)
                    {
                        skip_if_local_of = eph.local_of;
                    };
                };
            };
            if (!callstack++)
                reason += "\n"_fu;

            s_SolverPass _0 {};
            fu::str pass = (((_0 = pass0, (_0 != (pass0 = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).pass))) || (callstack == 1)) ? x7E_3lDd4lqo(str_b1DlaKrH((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).pass), " "_fu) : fu::str{});
            reason += (fu::get_view_start0("\n                "_fu, max_yeUdQhUA((17 - pass.size()), 1)) + pass);
            x7Ex3D_DKVpwRY7(reason, str_FDl5ha9X((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, false, ss, _here, ctx, module, options));
            if (ext.args)
            {
                reason += "("_fu;
                each_sRcJJyzD(ext.args, reason, _here, ctx, module, options);
                reason += ")"_fu;
            };
            const s_TokenIdx& token = o.solved.token;
            if (token)
                reason += (" at "_fu + formatTokenCoord_u9Gbkniv(token, module.modid, ctx));

        };
    };
    return static_cast<fu::str&&>(reason);
}

[[noreturn]] static fu::never fail_gDsnGKHT(const fu::str& reason, fu::view<char> backtrack, s_TokenIdx&& token, fu::view<s_TokenIdx> highlight, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (reason)
    {
        if (backtrack)
        {
            s_TokenIdx _0 {};
            token = ((_0 = tryBacktrack_gDsnGKHT(token, backtrack, s_Kind_id, ctx)) ? _0 : s_TokenIdx(token));
        };
        FAIL_u9Gbkniv(fail_appendStack_gDsnGKHT(fu::str(reason), ss, _helpers, _here, ctx, module, options), (token + highlight), ctx);
    }
    else
        BUG_u9Gbkniv("fail(): No reason."_fu, _here, ctx);

}

[[noreturn]] static fu::never BUG_gDsnGKHT(/*MOV*/ fu::str&& reason, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fail_gDsnGKHT(("COMPILER BUG:\n\n\t"_fu + (reason ? static_cast<fu::str&&>(reason) : "Assertion failed."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_q_TAGS
                                #define DEF_q_TAGS
extern const unsigned q_TAGS;
                                #endif

                                #ifndef DEF_q_USAGE
                                #define DEF_q_USAGE
extern const unsigned q_USAGE;
                                #endif

                                #ifndef DEF_x21x3D_A5lxvl9TXgh
                                #define DEF_x21x3D_A5lxvl9TXgh
inline bool operator!=(const s_Lifetime& a, const s_Lifetime& b)
{
    return !!x3Cx3E_imrGV5eV(a, b);
}
                                #endif

static s_Target nested_gDsnGKHT(const int index, const s_Target& from, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (index != 0)
        return Target_xQNS19Zn(int(unsigned(((from._packed >> 40ull) & 0xfffffull))), int(unsigned(((from._packed >> 20ull) & 0xfffffull))), index);
    else
        BUG_u9Gbkniv("nested(): bad locid"_fu, _here, ctx);

}

static s_Target nested_FDl5ha9X(const int index, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    return nested_gDsnGKHT(index, ss._nestingFnort, _here, ctx);
}

static s_UnpackedOffset field_unpackOffset_gDsnGKHT(const s_Overload& o, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (o.kind == s_Kind_field)
    {
        const int packed = o.solved.helpers.index;
        return s_UnpackedOffset { (packed & 0xffff), (packed >> 16) };
    }
    else
        BUG_u9Gbkniv("field_unpackOffset: Not a field."_fu, _here, ctx);

}

                                #ifndef DEF___THA4ND4xFp2
                                #define DEF___THA4ND4xFp2
inline static void _THA4ND4x(const int flatCount, int flatOffset, const bool isFirstSubRegion, const bool isLastSubRegion, const bool isLastPath, const int locid, s_Type& type, fu::str& str, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (isFirstSubRegion)
        type = GET_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _here, ctx, module).type;

    for (; ; )
    { {
        const s_UserType& s = tryLookupUserType_1qjplDUo(type.vtype, _here, ctx, module);
        if ((flatCount >= s.shape.flatCount))
            break;
        else
        {
            for (int i = 0; i < s.items.size(); i++)
            {
                const s_Overload& o = GET_gDsnGKHT(target_z0QqoZ5t(s.items[i]), ss, _here, ctx, module);
                const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(o, _here, ctx);
                if ((_.memberFlatOffset + _.memberFlatCount) > flatOffset)
                {
                    type = o.type;
                    flatOffset -= _.memberFlatOffset;
                    str += ("."_fu + qID_e44UlzzA(human_gDsnGKHT(o.name, ss, _here, ctx, module, options)));
                    goto BL_3;
                };
            };
            break;
        };
      } BL_3:;
    };
    if (!isLastSubRegion)
    {
        if (is_sliceable_hxWWgdZ1(type.vtype))
            type = clear_sliceable_1qjplDUo(type.vtype, _here, ctx, module);

        str += "*"_fu;
    };
    if (isLastSubRegion && !isLastPath)
        str += ", "_fu;

}
                                #endif

                                #ifndef DEF___HEfVkWwGE6g
                                #define DEF___HEfVkWwGE6g
inline static void _HEfVkWwG(const int locid, const bool isStatic, const bool isTemp, const bool isArgIdx, const bool isAlwaysMoveable, const int argidx, fu::view<char> paths, const bool brief, fu::str& str, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (str)
        str += qLT_e44UlzzA("|"_fu);

    str += (locid ? str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), true, ss, _here, ctx, module, options) : (isStatic ? (isAlwaysMoveable ? qLT_e44UlzzA("zeroes"_fu) : qLT_e44UlzzA("static"_fu)) : (isTemp ? qLT_e44UlzzA("temp"_fu) : (isArgIdx ? x7E_3lDd4lqo("arg#"_fu, fu::i64dec(argidx)) : BUG_u9Gbkniv("invalid region"_fu, _here, ctx)))));
    if (locid && !brief)
    {
        s_Type type {};
        int offset = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(paths, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(paths, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                _THA4ND4x(flatCount, flatOffset, isFirstSubRegion, isLastSubRegion, isLastPath, locid, type, str, ss, _here, ctx, module, options);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        if (!(offset == paths.size()))
            BUG_u9Gbkniv("walkPaths(!tailOK): excess bytes"_fu, _here, ctx);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_1dpkeCRF4w1
                                #define DEF_Lifetime_each_1dpkeCRF4w1
inline void Lifetime_each_1dpkeCRF(const s_Lifetime& lifetime, const bool brief, fu::str& str, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0;

    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        _HEfVkWwG(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v)), ((r & 11u) == 1u), (r == 0b1001u), ((r & 3u) == 3u), ((r == 0b0101u) || (r == 0b1001u)), int(((r & 1u) ? (r >> 2u) : 0u)), fu::get_view(chars, sr, offset), brief, str, ss, _here, ctx, module, options);
    };
}
                                #endif

static fu::str str_gDsnGKHT(const s_Lifetime& lifetime, const bool brief, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::str str = ""_fu;
    Lifetime_each_1dpkeCRF(lifetime, brief, str, ss, _here, ctx, module, options);
    return /*NRVO*/ str;
}

                                #ifndef DEF___PRppODCZTzk
                                #define DEF___PRppODCZTzk
inline static void _PRppODCZ(fu::view<char> argSpecType, const bool isFirst, fu::str& result, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!isFirst)
        result += ", "_fu;

    result += explainType_gDsnGKHT(s_Type { parseType_1qjplDUo(argSpecType, _here, ctx, module), s_Lifetime{} }, true, false, true, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_eachArgSpecType_i3l1kyYvJ44
                                #define DEF_eachArgSpecType_i3l1kyYvJ44
inline void eachArgSpecType_i3l1kyYv(fu::view<char> subPattern, fu::str& result, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int offset = 0;
    for (; ; )
    {
        const int start = offset;
        bool isLastArgSpecType {};
        scan(subPattern, ':', offset, isLastArgSpecType);
        _PRppODCZ(fu::get_view(subPattern, start, offset), !start, result, ss, _here, ctx, module, options);
        if (isLastArgSpecType)
            break;
        else
            offset++;

    };
}
                                #endif

                                #ifndef DEF___tfjPsJ2KoUi
                                #define DEF___tfjPsJ2KoUi
inline static void _tfjPsJ2K(fu::view<char> pattern, fu::str& result, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    result += "("_fu;
    eachArgSpecType_i3l1kyYv(pattern, result, ss, _here, ctx, module, options);
    result += ")"_fu;
}
                                #endif

                                #ifndef DEF_eachSubPattern_z2k9julBlsi
                                #define DEF_eachSubPattern_z2k9julBlsi
inline void eachSubPattern_z2k9julB(fu::view<char> pattern, fu::str& result, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int offset = 0;
    for (; ; )
    {
        parseGlobal_xQNS19Zn(pattern, offset);
        const int start = offset;
        bool isLastSubPattern {};
        scan(pattern, '|', offset, isLastSubPattern);
        _tfjPsJ2K(fu::get_view(pattern, start, offset), result, ss, _here, ctx, module, options);
        if (isLastSubPattern)
            break;
        else
            offset++;

    };
}
                                #endif

                                #ifndef DEF_ends_JkFJYOhRS8a
                                #define DEF_ends_JkFJYOhRS8a
inline bool ends_JkFJYOhR(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view(a, (a.size() - with.size()), a.size()) == with);
}
                                #endif

                                #ifndef DEF_remove_WM9P6c9M9mb
                                #define DEF_remove_WM9P6c9M9mb
inline void remove_WM9P6c9M(fu::str& a, const int at, const int count)
{
    a.splice(at, count);
}
                                #endif

static void appendUsage_gDsnGKHT(const s_Type& type, const unsigned usage, fu::str& result, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    result += " { "_fu;
    if (!usage)
        result += "- "_fu;
    else
    {
        const s_UserType& s = tryLookupUserType_1qjplDUo(type.vtype, _here, ctx, module);
        if (!s)
            result += "* "_fu;
        else
        {
            for (int i = 0; i < s.items.size(); i++)
            {
                const s_Target f = target_z0QqoZ5t(s.items[i]);
                const s_Overload& o = GET_gDsnGKHT(f, ss, _here, ctx, module);
                const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(o, _here, ctx);
                unsigned BL_7_v {};
                const unsigned match = USAGE_fieldUsageFromStructUsage_CaGDtmWo((__extension__ (
                {
                    const s_ValueType& type_1 = o.type.vtype;
                    BL_7_v = ((type_1.quals & q_USAGE));
                (void)0;}), BL_7_v), usage, _.memberFlatOffset, _.memberFlatCount);
                if (match)
                {
                    result += qID_e44UlzzA(human_gDsnGKHT(o.name, ss, _here, ctx, module, options));
                    if (match != getMaxUsage_CaGDtmWo(_.memberFlatCount))
                        appendUsage_gDsnGKHT(o.type, match, result, ss, _here, ctx, module, options);
                    else
                        result += ", "_fu;

                };
            };
        };
    };
    if (ends_JkFJYOhR(result, ", "_fu))
        remove_WM9P6c9M(result, (result.size() - 2), 1);

    result += "}"_fu;
}

static fu::str explainType_gDsnGKHT(const s_Type& type, const bool brief, bool lt, bool no_quals, bool usage, bool no_vfacts, const s_Type& diff, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!type)
        return "< Empty Type >"_fu;
    else
    {
        if (diff)
        {
            no_quals = true;
            no_vfacts = true;
            if (isCanonAssignable_Ot6wT82z(type.vtype.canon, diff.vtype.canon, _here, ctx) || isCanonAssignable_Ot6wT82z(diff.vtype.canon, type.vtype.canon, _here, ctx))
            {
                no_quals = ((type.vtype.quals & q_TAGS) == (diff.vtype.quals & q_TAGS));
                no_vfacts = (type.vtype.vfacts == diff.vtype.vfacts);
                usage = ((type.vtype.quals & q_USAGE) != (diff.vtype.quals & q_USAGE));
                lt = (type.lifetime != diff.lifetime);
            };
        };
        /*MOV*/ fu::str result = ""_fu;
        if (!no_vfacts && type.vtype.vfacts)
            result += explainVFacts_9CJmuVSD(type.vtype.vfacts);

        if (!no_quals)
        {
            result += explainQuals_9CJmuVSD(type.vtype.quals, (lt ? type.lifetime : (*(const s_Lifetime*)fu::NIL)));
        };
        if (lt && type.lifetime)
        {
            result += (str_gDsnGKHT(type.lifetime, brief, ss, _here, ctx, module, options) + " "_fu);
        };
        result += explainTypeName_gDsnGKHT(type, brief, _here, ctx, module, options);
        fu::view<char> pattern = tryGetPattern_Ot6wT82z(type.vtype.canon);
        if (pattern)
            eachSubPattern_z2k9julB(pattern, result, ss, _here, ctx, module, options);

        if (usage)
            appendUsage_gDsnGKHT(type, (type.vtype.quals & q_USAGE), result, ss, _here, ctx, module, options);

        return /*NRVO*/ result;
    };
}

static fu::str addr_and_snippet_gDsnGKHT(const s_TokenIdx& token, const s_CodeFmt fmt, fu::view<char> backtrack, const s_Context& ctx, const s_Module& module)
{
    /*MOV*/ fu::vec<s_TokenIdx> tokens = fu::vec<s_TokenIdx> { fu::slate<1, s_TokenIdx> { s_TokenIdx(token) } };
    if (backtrack)
    {
        const s_TokenIdx other = tryBacktrack_gDsnGKHT(token, backtrack, s_Kind_id, ctx);
        if (other)
        {
            tokens.unshift(s_TokenIdx(other));
        };
    };
    return formatCodeSnippet_k53poh8o(static_cast<fu::vec<s_TokenIdx>&&>(tokens), module.modid, fmt, ctx);
}

                                #ifndef DEF_x3Cx3E_f3YaHn9VgJd
                                #define DEF_x3Cx3E_f3YaHn9VgJd
inline int x3Cx3E_f3YaHn9V(const s_TokenIdx& a, const s_TokenIdx& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XrkW2YUZ(a.modid, b.modid)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.tokidx, b.tokidx)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x21x3D_G9w5M5D1cOc
                                #define DEF_x21x3D_G9w5M5D1cOc
inline bool operator!=(const s_TokenIdx& a, const s_TokenIdx& b)
{
    return !!x3Cx3E_f3YaHn9V(a, b);
}
                                #endif

                                #ifndef DEF_x3Cx3E_ZAz3Jw6Ldo7
                                #define DEF_x3Cx3E_ZAz3Jw6Ldo7
inline int x3Cx3E_ZAz3Jw6L(const uint64_t a, const uint64_t b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_B3HLYN6fNTl
                                #define DEF_x3Cx3E_B3HLYN6fNTl
inline int x3Cx3E_B3HLYN6f(const s_Target& a, const s_Target& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_ZAz3Jw6L(a._packed, b._packed)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x21x3D_Vtc8H9t5If4
                                #define DEF_x21x3D_Vtc8H9t5If4
inline bool operator!=(const s_Target& a, const s_Target& b)
{
    return !!x3Cx3E_B3HLYN6f(a, b);
}
                                #endif

static fu::str str_wyx7msfr(const s_Argument& arg, const bool brief, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::str prefix = ((((arg.flags & s_Flags_F_INJECTED) ? "injected "_fu : fu::str{}) + ((arg.flags & s_Flags_F_IMPLICIT) ? "implicit "_fu : fu::str{})) + ((arg.flags & s_Flags_F_REF) ? "ref "_fu : fu::str{}));
    prefix += "arg"_fu;
    fu::str ns = ""_fu;
    if (arg.target && !brief)
    {
        const s_Target parent = parent_gDsnGKHT(arg.target, _here, ctx);
        if (parent != _current_fn.out.target)
            ns = str_IDns_gDsnGKHT(parent, ss, _here, ctx, module, options);

    };
    return ((qKW_e44UlzzA(prefix) + " "_fu) + ns) + qID_e44UlzzA(human_gDsnGKHT(arg.name, ss, _here, ctx, module, options));
}

static fu::str explainConversion_gDsnGKHT(fu::view<s_Target> path, fu::view<char> prefix, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::str res = ""_fu;
    for (int i = 0; i < path.size(); i++)
    {
        if (!i)
            res += "\n"_fu;

        res += "\t    "_fu;
        if (!i && prefix)
            res += prefix;

        res += (qKW_e44UlzzA("using"_fu) + " "_fu);
        res += explainWhichFn_gDsnGKHT(s_Target(path[i]), fu::view<fu::vec<s_Target>>{}, "using"_fu, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options);
    };
    return /*NRVO*/ res;
}

static fu::str explainWhichFn_gDsnGKHT(s_Target&& t, fu::view<fu::vec<s_Target>> conversions, fu::view<char> backtrack, const s_CodeFmt fmt, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::str result = str_FDl5ha9X(t, false, ss, _here, ctx, module, options);
    while (GET_gDsnGKHT(t, ss, _here, ctx, module).flags & s_Flags_F_INJECTED)
    {
        const s_ClosureID cid = tryParseClosureID_UvH3gYAB(GET_gDsnGKHT(t, ss, _here, ctx, module).name, _here, ctx);
        if (!cid)
            break;
        else
            t = cid.target;

    };
    if (GET_gDsnGKHT(t, ss, _here, ctx, module).flags & s_Flags_F_INJECTED)
        result += "\n"_fu;
    else
    {
        const s_TokenIdx& t0 = EXT_gDsnGKHT(t, ss, ctx, module).tEmplate.node.token;
        const s_TokenIdx& t1 = GET_gDsnGKHT(t, ss, _here, ctx, module).solved.token;
        if (t0 || t1)
            result += (" at "_fu + addr_and_snippet_gDsnGKHT((t0 ? t0 : t1), fmt, backtrack, ctx, module));

        if (t0 && t1 && (t0 != t1))
            result += ("\n\t    ... via "_fu + addr_and_snippet_gDsnGKHT(t1, fmt, backtrack, ctx, module));

        for (int i = 0; i < conversions.size(); i++)
        {
            fu::view<s_Target> c = conversions[i];
            if (c)
            {
                result += explainConversion_gDsnGKHT(c, ((EXT_gDsnGKHT(t, ss, ctx, module).args.size() > 1) ? x7E_3lDd4lqo(str_wyx7msfr(EXT_gDsnGKHT(t, ss, ctx, module).args[i], false, _current_fn, ss, _here, ctx, module, options), ": "_fu) : fu::str{}), _current_fn, ss, _here, ctx, module, options);
            };
        };
    };
    return /*NRVO*/ result;
}

static s_StaticEval tryAbstractEvalAsBool_gDsnGKHT(const s_SolvedNode& cond, const bool voidOk, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (cond.type.vtype.vfacts & s_VFacts((s_VFacts_AlwaysTrue | s_VFacts_AlwaysFalse)))
    {
        if (!s_VFacts((cond.type.vtype.vfacts & s_VFacts_AlwaysTrue)))
            return s_StaticEval_SE_False;
        else if (!s_VFacts((cond.type.vtype.vfacts & s_VFacts_AlwaysFalse)))
            return s_StaticEval_SE_True;
        else
            BUG_gDsnGKHT("Expression both AlwaysTrue and AlwaysFalse."_fu, ss, _helpers, _here, ctx, module, options);

    }
    else if (isIrrelevant_9CJmuVSD(cond.type))
    {
        if (voidOk)
            return s_StaticEval_SE_False;
        else
        {
            fail_gDsnGKHT(((((((("Condition is an always-empty "_fu + explainType_gDsnGKHT(cond.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + ((cond.kind == s_Kind_call) ? (", returned from "_fu + explainWhichFn_gDsnGKHT(s_Target(cond.target), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options)) : ", not meaningful in a boolean context."_fu)) + "\n\n\tIf this is expected, use "_fu) + qID_e44UlzzA("!="_fu)) + " "_fu) + qKW_e44UlzzA("[]"_fu)) + " to suppress this warning."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
        return s_StaticEval_SE_Unknown;

}

                                #ifndef DEF_ensure_uvbrpQsfxY1
                                #define DEF_ensure_uvbrpQsfxY1
inline s_Ephemeral& ensure_uvbrpQsf(fu::vec<s_Ephemeral>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static s_Ephemeral& EPH_mut_gDsnGKHT(const int index, s_SolverState& ss)
{
    return ensure_uvbrpQsf(ss._ephemeral, index);
}

static s_Ephemeral& EPH_mut_FDl5ha9X(const s_Target& target, s_SolverState& ss, const s_Module& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return EPH_mut_gDsnGKHT(int(unsigned(((target._packed >> 20ull) & 0xfffffull))), ss);
    else
        fu::fail("EPH_mut: modid is off."_fu);

}

static bool is_SPECFAIL_gDsnGKHT(const s_Target& target)
{
    return !!(target._packed & 0x8000000000000000ull);
}

static s_Overload& GET_mut_gDsnGKHT(const s_Target& target, s_SolverState& ss, const s_Module& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    if ((globid > 0) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (locid)
        {
            s_Extended& ext = ss._scope.extended.mutref(globid);
            int BL_4_v {};
            return ext.args_n_locals.mutref((__extension__ (
            {
                const s_Extended& ext_1 = ext;
                BL_4_v = (((ext_1.args_neg - ((locid > 0) ? 1 : 0)) + locid));
            (void)0;}), BL_4_v));
        }
        else
            return ss._scope.overloads.mutref((globid - 1));

    }
    else
        fu::fail("GET_mut: bad modid/globid"_fu);

}

                                #ifndef DEF_steal_W9jpf1Xa0Sa
                                #define DEF_steal_W9jpf1Xa0Sa
inline s_CountedSet_95BJOojOc45 steal_W9jpf1Xa(s_CountedSet_95BJOojOc45& v)
{
    /*MOV*/ s_CountedSet_95BJOojOc45 ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static s_Target localfn_gDsnGKHT(const int index, const s_Module& module)
{
    return Target_xQNS19Zn(module.modid, index, 0);
}

                                #ifndef DEF___AjiZDloeu61
                                #define DEF___AjiZDloeu61
inline static void _AjiZDloe(const int i, s_Set_95BJOojOc45& _, fu::vec<int>& values)
{
    _.keys_asc.splice(i, 1);
    values.splice(i, 1);
}
                                #endif

                                #ifndef DEF_remove_FWIESLiDix6
                                #define DEF_remove_FWIESLiDix6
inline bool remove_FWIESLiD(s_Map_2goAfCfe5Ta& _, const int key)
{

    {
        s_Set_95BJOojOc45& __1 = _.keys;
        fu::vec<int>& values = _.vals;
        fu::view<int> keys_asc = __1.keys_asc;
        int lo = 0;
        int hi = keys_asc.size();
        while (lo < hi)
        {
            const int i = ((hi + lo) >> 1);
            const int cmp = x3Cx3E_XrkW2YUZ(keys_asc[i], key);
            if (cmp == 0)
            {
                _AjiZDloe(i, __1, values);
                return true;
            }
            else if (cmp < 0)
                lo = (i + 1);
            else
                hi = i;

        };
    };
    return false;
}
                                #endif

                                #ifndef DEF_remove_L2yJ8xElNU4
                                #define DEF_remove_L2yJ8xElNU4
inline bool remove_L2yJ8xEl(s_CountedSet_95BJOojOc45& _, const int key)
{
    return remove_FWIESLiD(_.counts, key);
}
                                #endif

                                #ifndef DEF___Oaq1hho2bog
                                #define DEF___Oaq1hho2bog
inline static void _Oaq1hho2(const int callee, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target callee_1 = localfn_gDsnGKHT(callee, module);
    int _0 {};
    if (!((_0 = int(unsigned(((target._packed >> 20ull) & 0xfffffull))), remove_L2yJ8xEl(EPH_mut_FDl5ha9X(callee_1, ss, module).callers, _0))))
        BUG_gDsnGKHT(x7E_3lDd4lqo("resetChild: Missing in callers on "_fu, str_FDl5ha9X(callee_1, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF___JiHyHnktyz6
                                #define DEF___JiHyHnktyz6
inline static void _JiHyHnkt(const int key, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    _Oaq1hho2(key, target, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_lffEks6ARCi
                                #define DEF_each_lffEks6ARCi
inline void each_lffEks6A(const s_Map_2goAfCfe5Ta& _, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _JiHyHnkt(key, target, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_each_J47jFkVgvoi
                                #define DEF_each_J47jFkVgvoi
inline void each_J47jFkVg(const s_CountedSet_95BJOojOc45& _, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_lffEks6A(_.counts, target, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF___eqeim5ID2sk
                                #define DEF___eqeim5ID2sk
inline static void _eqeim5ID(const int caller, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target caller_1 = localfn_gDsnGKHT(caller, module);
    int _0 {};
    if (!((_0 = int(unsigned(((target._packed >> 20ull) & 0xfffffull))), remove_L2yJ8xEl(EPH_mut_FDl5ha9X(caller_1, ss, module).calls, _0))))
        BUG_gDsnGKHT(x7E_3lDd4lqo("resetChild: Missing in calls on "_fu, str_FDl5ha9X(caller_1, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF___HnzHntFYNFb
                                #define DEF___HnzHntFYNFb
inline static void _HnzHntFY(const int key, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    _eqeim5ID(key, target, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_UqJ7GQkO8O9
                                #define DEF_each_UqJ7GQkO8O9
inline void each_UqJ7GQkO(const s_Map_2goAfCfe5Ta& _, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _HnzHntFY(key, target, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_each_J4yvdGu0Mi8
                                #define DEF_each_J4yvdGu0Mi8
inline void each_J4yvdGu0(const s_CountedSet_95BJOojOc45& _, const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_UqJ7GQkO(_.counts, target, ss, _helpers, _here, ctx, module, options);
}
                                #endif

static s_Extended& EXT_mut_gDsnGKHT(const s_Target& target, s_SolverState& ss, const s_Module& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    int BL_1_v {};
    if ((globid > 0) && (globid < ss._scope.extended.size()) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid) && !(__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v))
        return ss._scope.extended.mutref(globid);
    else
        fu::fail("EXT_mut: bad modid/globid/locid"_fu);

}

static void resetChild_gDsnGKHT(const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(is_SPECFAIL_gDsnGKHT(target)))
    {
        s_SolverStatus& status = GET_mut_gDsnGKHT(target, ss, module).status;
        if (status & s_SolverStatus_SS_LAZY)
        {
            status &= s_SolverStatus(~s_SolverStatus((s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_FINALIZED)) | s_SolverStatus_SS_DIRTY)));
            s_CountedSet_95BJOojOc45 calls = steal_W9jpf1Xa(EPH_mut_FDl5ha9X(target, ss, module).calls);
            each_J47jFkVg(calls, target, ss, _helpers, _here, ctx, module, options);
            s_CountedSet_95BJOojOc45 callers = steal_W9jpf1Xa(EPH_mut_FDl5ha9X(target, ss, module).callers);
            each_J4yvdGu0(callers, target, ss, _helpers, _here, ctx, module, options);
            fu::vec<s_Argument>& args = EXT_mut_gDsnGKHT(target, ss, module).args;
            for (int i = args.size(); i-- > 0; )
            {
                if (args[i].flags & s_Flags_F_INJECTED)
                    args.splice(i, 1);

            };
            if (EPH_gDsnGKHT(target, ss, module).calls)
            {
                BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
            BUG_gDsnGKHT(x7E_3lDd4lqo("resetChild: not SS_LAZY: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
}

                                #ifndef DEF___H94u7na9mNa
                                #define DEF___H94u7na9mNa
inline static void _H94u7na9(const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    resetChild_gDsnGKHT(target, ss, _helpers, _here, ctx, module, options);
}
                                #endif

static s_Template createTemplate_gDsnGKHT(const s_Node& node, const s_CurrentFn& _current_fn, const s_SolverState& ss)
{
    return s_Template { s_Node(node), fu::vec<int>((!_current_fn ? ss._scope.imports : (*(const fu::vec<int>*)fu::NIL))) };
}

                                #ifndef DEF___1fKJWie67q9
                                #define DEF___1fKJWie67q9
inline static void _1fKJWie6(const s_Target& target, const s_Node& node, const s_SolverStatus status, const s_CurrentFn& _current_fn, s_SolverState& ss, const s_Module& module)
{
    s_Overload& o = GET_mut_gDsnGKHT(target, ss, module);
    o.kind = s_Kind_fn;
    o.name = ("prep "_fu + node.value);
    o.flags = node.flags;
    o.status = status;
    s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
    ext.tEmplate = createTemplate_gDsnGKHT(node, _current_fn, ss);
    ext.min = int(0x7fffffffu);
    ext.max = 0;
}
                                #endif

                                #ifndef DEF_getOrCreateChild_iVtaDR92O2g
                                #define DEF_getOrCreateChild_iVtaDR92O2g
inline static s_Target getOrCreateChild_iVtaDR92(const s_Node& node, const s_Node& node_1, const s_SolverStatus status, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target& parent = _current_fn.out.target;
    if (parent)
    {
        const unsigned parent_rev = EPH_gDsnGKHT(parent, ss, module).revision;
        fu::view_mut<s_ChildTarget> children = EPH_mut_FDl5ha9X(parent, ss, module).children;
        for (int i = 0; i < children.size(); i++)
        {
            s_ChildTarget& child = children.mutref(i);
            if (!((child.token != node.token) || (child.parent_rev == parent_rev)))
            {
                child.parent_rev = parent_rev;
                const s_Target target { child.target };
                _H94u7na9(target, ss, _helpers, _here, ctx, module, options);
                return target;
            };
        };
    };
    const s_Target target = Scope_create_z0QqoZ5t(ss._scope, s_Kind___no_kind_yet, (*(const fu::str*)fu::NIL), (*(const s_Type*)fu::NIL), s_Flags{}, s_DeclAsserts{}, s_SolverStatus{}, 0, false, module);
    _1fKJWie6(target, node_1, status, _current_fn, ss, module);
    if (parent)
    {
        const unsigned parent_rev = EPH_gDsnGKHT(parent, ss, module).revision;
        fu::vec<s_ChildTarget>& children = EPH_mut_FDl5ha9X(parent, ss, module).children;
        children += s_ChildTarget { s_TokenIdx(node.token), parent_rev, s_Target(target) };
    };
    return target;
}
                                #endif

static bool shouldAutoshadow_gDsnGKHT(fu::view<char> id, const s_SolverState& ss)
{

    {
        fu::view<s_ScopeItem> items = ss._scope.items;
        fu::view<s_ScopeSkip> scope_skip = ss._ss.items;
        const int start = 0;
        const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const s_ScopeSkip& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const s_ScopeItem& item = items[i_1];
                    const int i_2 = i_1;
                    if ((i_2 >= ss._root_scope.items_len) && (item.id == id))
                        return false;

                };
                i0 = ss_1.end;
            };
        };
    };
    return true;
}

static void autoshadow_gDsnGKHT(bool& shadows, const int local_of, fu::view<char> id, const s_CurrentFn& _current_fn, const s_SolverState& ss)
{
    if (!(!_current_fn.autoshadow_ok))
    {
        if (!shadows && local_of && shouldAutoshadow_gDsnGKHT(id, ss))
            shadows = true;

    };
}

static s_ScopeMemo Scope_snap_gDsnGKHT(const s_SolverState& ss, fu::view<s_Helpers> _helpers)
{
    return s_ScopeMemo { ss._scope.items.size(), ss._scope.implicits.size(), ss._scope.imports.size(), ss._scope.privates.size(), ss._scope.usings.size(), ss._scope.converts.size(), _helpers.size() };
}

static s_Type X_addrofTarget_gDsnGKHT(fu::view<s_Target> targets)
{
    return s_Type { s_ValueType { 0u, s_VFacts{}, packAddrOfFn_9CJmuVSD(targets) }, s_Lifetime{} };
}

static s_Type X_addrofTarget_FDl5ha9X(const s_Target& target)
{
    return X_addrofTarget_gDsnGKHT((fu::slate<1, s_Target> { s_Target(target) }));
}

static s_SolvedNode SolvedNode_gDsnGKHT(const s_Kind kind, const s_Type& type, const s_Flags flags, const fu::str& value, const fu::vec<s_SolvedNode>& items, const s_Target& target, const s_Helpers& helpers, const s_TokenIdx& _here)
{
    return s_SolvedNode { kind, s_Helpers(helpers), (flags | s_Flags_F_TEST_painted), 0, fu::str(value), fu::vec<s_SolvedNode>(items), s_TokenIdx(_here), s_Type(type), s_Target(target) };
}

                                #ifndef DEF_Lifetime_static_moveable
                                #define DEF_Lifetime_static_moveable
extern const s_Lifetime Lifetime_static_moveable;
                                #endif

static void intoEmpty_gDsnGKHT(s_SolvedNode& node, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    node.kind = s_Kind_empty;
    node.helpers = s_Helpers{};
    if (node.items)
        BUG_gDsnGKHT("intoEmpty: !!node.items"_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        s_Type& type = node.type;
        const bool canDiscard = isIrrelevant_9CJmuVSD(type);
        if (type.lifetime)
        {
            if (canDiscard || hasStatic_7Yz9ezW2(type.lifetime))
            {
                type.lifetime = Lifetime_static_moveable;
            }
            else
            {
                BUG_gDsnGKHT(x7E_3lDd4lqo("intoEmpty: non-static non-irrelevant lifetime: "_fu, str_gDsnGKHT(type.lifetime, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            };
        };
        if (!canDiscard)
        {
            if (type.vtype.vfacts & s_VFacts_AlwaysTrue)
                BUG_gDsnGKHT(("intoEmpty: vfacts & AlwaysTrue: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            else
                type.vtype.vfacts |= s_VFacts_AlwaysFalse;

        };
    };
}

static s_SolvedNode createEmpty_gDsnGKHT(const s_Type& type, const s_Target& target, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode ret = SolvedNode_gDsnGKHT(s_Kind_empty, type, s_Flags{}, (*(const fu::str*)fu::NIL), (*(const fu::vec<s_SolvedNode>*)fu::NIL), target, s_Helpers{}, _here);
    intoEmpty_gDsnGKHT(ret, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ ret;
}

static s_SolvedNode uPrepFn_A_gDsnGKHT(const s_Node& node, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const fu::str& id = node.value;
    int BL_1_v {};
    const int local_of = (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v);
    const s_SolverStatus status = s_SolverStatus_SS_LAZY;
    const s_Target target = getOrCreateChild_iVtaDR92(node, node, status, _current_fn, ss, _helpers, _here, ctx, module, options);
    bool shadows = !!(node.flags & s_Flags_F_SHADOW);
    autoshadow_gDsnGKHT(shadows, local_of, id, _current_fn, ss);
    if (~node.flags & s_Flags_F_LAMBDA)
        Scope_set_z0QqoZ5t(ss._scope, id, target, shadows);

    s_Ephemeral& eph = EPH_mut_FDl5ha9X(target, ss, module);
    eph.local_of = local_of;
    eph.scope_memo = (_current_fn ? Scope_snap_gDsnGKHT(ss, _helpers) : s_ScopeMemo{});
    eph.scope_skip = (_current_fn ? ss._ss : (*(const s_ScopeSkipMemos*)fu::NIL));
    if (node.flags & s_Flags_F_CONVERSION)
    {
        ss._scope.converts.push(s_Target(target));
        clear_LqmWP5WQ(ss._conv_cache);
    };
    if (node.flags & s_Flags_F_USING)
    {
        ss._scope.usings.push(s_Target(target));
        remove_qacjtO9I(ss._conv_cache, s_ValueType{});
    };
    return createEmpty_gDsnGKHT(X_addrofTarget_FDl5ha9X(target), target, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_STRUCT_MEMBERS
                                #define DEF_STRUCT_MEMBERS
inline constexpr int STRUCT_MEMBERS = 1;
                                #endif

                                #ifndef DEF_STRUCT_BASE
                                #define DEF_STRUCT_BASE
inline constexpr int STRUCT_BASE = 0;
                                #endif

                                #ifndef DEF_only_CiCfNZS0A49
                                #define DEF_only_CiCfNZS0A49
inline const s_Node& only_CiCfNZS0(fu::view<s_Node> s)
{
    fu_ASSERT((s.size() == 1));
    return s[0];
}
                                #endif

static s_Type T_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    return evalTypeAnnot_gDsnGKHT(only_CiCfNZS0(node.items), false, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_Lifetime_temporary
                                #define DEF_Lifetime_temporary
extern const s_Lifetime Lifetime_temporary;
                                #endif

                                #ifndef DEF_t_zeroes
                                #define DEF_t_zeroes
extern const s_Type t_zeroes;
                                #endif

                                #ifndef DEF_get_Dwbqj0k3uyl
                                #define DEF_get_Dwbqj0k3uyl
inline const s_TypeParam& get_Dwbqj0k3(const s_Set_6ARmtH0K78f& _, fu::view<char> key, fu::view<s_TypeParam> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(const s_TypeParam*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_usbzfpQ2g72
                                #define DEF_get_usbzfpQ2g72
inline const s_TypeParam& get_usbzfpQ2(const s_Map_lhf7SV3Fyjf& _, fu::view<char> key)
{
    return get_Dwbqj0k3(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_iF_iT2RVAPHbbb
                                #define DEF_iF_iT2RVAPHbbb
inline const s_Import& iF_iT2RVAPH(fu::view<s_Import> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Import*)fu::NIL);

}
                                #endif

static const s_Module& findModule_gDsnGKHT(fu::view<char> marker, int& offset, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int modid = int(parseVarint_V5IuMsej(offset, marker));
    const int index = int(parseVarint_V5IuMsej(offset, marker));
    const s_Module& m = ((modid == module.modid) ? module : ctx.modules[modid]);
    fu::view<s_Import> imports = m.in.parse.imports;
    const s_Import& import = iF_iT2RVAPH(imports, index);
    return ctx.modules[(import.modid ? import.modid : BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("findModule: !import.modid, marker("_fu, fu::i64dec(modid)) + ", "_fu), fu::i64dec(index)) + ")"_fu), ss, _helpers, _here, ctx, module, options))];
}

static const s_Scope& dequalify_andGetScope_gDsnGKHT(fu::str& id, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int offset = 0;
    const s_Module& other = findModule_gDsnGKHT(id, offset, ss, _helpers, _here, ctx, module, options);
    if (other.modid == module.modid)
    {
        fail_gDsnGKHT("Self-referential qualified id."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        id.splice(0, offset);
        if (id)
            return other.out.solve.scope;
        else
        {
            BUG_gDsnGKHT("dequalify_andGetScope: ended up with an empty identifier."_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
}

                                #ifndef DEF___gm6tzz31oB1
                                #define DEF___gm6tzz31oB1
inline static int _gm6tzz31(int& count)
{
    return count++;
}
                                #endif

                                #ifndef DEF_each_44cVCiCBbq2
                                #define DEF_each_44cVCiCBbq2
inline void each_44cVCiCB(fu::view<s_Target> items, fu::view<s_ScopeSkip> scope_skip, const int start, int& count)
{
    const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const s_ScopeSkip& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _gm6tzz31(count);

            i0 = ss.end;
        };
    };
}
                                #endif

                                #ifndef DEF_count_oMVVE0WpyVc
                                #define DEF_count_oMVVE0WpyVc
inline int count_oMVVE0Wp(fu::view<s_Target> items, fu::view<s_ScopeSkip> scope_skip)
{
    int count = 0;
    each_44cVCiCB(items, scope_skip, 0, count);
    return count;
}
                                #endif

                                #ifndef DEF_collectNamedArgs_qT83fNIjM06
                                #define DEF_collectNamedArgs_qT83fNIjM06
inline static s_NamedArgs_AWe2QSUTLw0 collectNamedArgs_qT83fNIj(fu::view<s_SolvedNode> args, int& minArity, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_NamedArgs_AWe2QSUTLw0 ret {};
    bool some = false;
    for (int i = 0; i < args.size(); i++)
    {
        const s_SolvedNode& arg = args[i];
        const fu::str* _0;
        ret.names.push(((arg.kind == s_Kind_argid) ? fu::str((*(_0 = &(((some = true), arg.value))) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options))) : ""_fu));
        if (arg.flags & s_Flags_F_ARGID_IS_OPTIONAL)
        {
            minArity--;
            add_ZwXYCruz(ret.optional, i);
        };
    };
    if (some)
        return /*NRVO*/ ret;
    else
        BUG_gDsnGKHT("collectNamedArgs: no named arguments here"_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_first_5wdN9pnXeR7
                                #define DEF_first_5wdN9pnXeR7
inline const s_SolvedNode& first_5wdN9pnX(fu::view<s_SolvedNode> s)
{
    return s[0];
}
                                #endif

                                #ifndef DEF___ueUcRLGq6qe
                                #define DEF___ueUcRLGq6qe
inline static void _ueUcRLGq(bool& inserted)
{
    inserted = true;
    return;
}
                                #endif

                                #ifndef DEF_bfind_hh3rJCExFQ4
                                #define DEF_bfind_hh3rJCExFQ4
inline static int bfind_hh3rJCEx(fu::view<s_ValueType> keys_asc, const s_ValueType& key, s_Set_7aI0knTMWY7& _, const s_ValueType& key_1, fu::vec<s_ConvCache_ColsAndBakes>& values, bool& inserted)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_VHap4TnO(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, (_ueUcRLGq(inserted), s_ConvCache_ColsAndBakes{}));
    _.keys_asc.insert(i, s_ValueType(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_ONqtNkofy8c
                                #define DEF_ref_ONqtNkofy8c
inline s_ConvCache_ColsAndBakes& ref_ONqtNkof(s_Set_7aI0knTMWY7& _, const s_ValueType& key, fu::vec<s_ConvCache_ColsAndBakes>& values, bool& inserted)
{
    const int idx = bfind_hh3rJCEx(_.keys_asc, key, _, key, values, inserted);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_eAB3hRSVkch
                                #define DEF_ref_eAB3hRSVkch
inline s_ConvCache_ColsAndBakes& ref_eAB3hRSV(s_Map_j5rW2s1zJ22& _, const s_ValueType& key, bool& inserted)
{
    return ref_ONqtNkof(_.keys, key, _.vals, inserted);
}
                                #endif

                                #ifndef DEF_Lifetime_worst
                                #define DEF_Lifetime_worst
extern const fu::static_ref<s_Lifetime> Lifetime_worst;
                                #endif

                                #ifndef DEF_x3Dx3D_LQEv05vYad8
                                #define DEF_x3Dx3D_LQEv05vYad8
inline bool operator==(const s_Target& a, const s_Target& b)
{
    return !x3Cx3E_B3HLYN6f(a, b);
}
                                #endif

                                #ifndef DEF_find_H5f3kK8GJS5
                                #define DEF_find_H5f3kK8GJS5
inline int find_H5f3kK8G(fu::view<s_Target> haystack, const s_Target& needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_AOZqRgIbEp7
                                #define DEF_has_AOZqRgIbEp7
inline bool has_AOZqRgIb(fu::view<s_Target> a, const s_Target& b)
{
    return (find_H5f3kK8G(a, b) >= 0);
}
                                #endif

static s_Type make_field_reference_gDsnGKHT(const s_Type& from, const s_Overload& field, const bool TODO_FIX_useTemporaryLifetime, const s_TokenIdx& _here, const s_Context& ctx)
{
    const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(field, _here, ctx);
    const unsigned quals = (!is_zeroes_9CJmuVSD(from.vtype) ? from.vtype.quals : 0u);
    return make_field_reference_9CJmuVSD(quals, (TODO_FIX_useTemporaryLifetime ? Lifetime_temporary : (!_.memberFlatCount ? Lifetime_static_moveable : from.lifetime)), s_Type(field.type), _.memberFlatOffset, _.memberFlatCount, _here, ctx);
}

                                #ifndef DEF_only_m9oK8BbAL7f
                                #define DEF_only_m9oK8BbAL7f
inline const fu::vec<s_Target>& only_m9oK8BbA(fu::view<fu::vec<s_Target>> s)
{
    fu_ASSERT((s.size() == 1));
    return s[0];
}
                                #endif

static void foreach_gDsnGKHT(const s_Target& target, const int at_index, const s_Type& from, const bool nullary, s_ConvCache_ColsAndBakes& result, s_Reorder& TODO_FIX_reorder, fu::vec<fu::vec<s_Target>>& TODO_FIX_conversions, fu::vec<s_Target>& path, fu::vec<int>& must_see, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (!(has_AOZqRgIb(path, target)))
    {
        if (s_SolverStatus((GET_gDsnGKHT(target, ss, _here, ctx, module).status & s_SolverStatus((s_SolverStatus_SS_LAZY | s_SolverStatus_SS_FINALIZED)))) == s_SolverStatus_SS_LAZY)
            GET_mut_gDsnGKHT(target, ss, module).status |= s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE;
        else
        {
            /*MOV*/ s_Type arg0type0 { ss.TODO_FIX_convert_args[0].type };
            if (!nullary)
                ss.TODO_FIX_convert_args.mutref(0).type = s_Type(from);

            fu_DEFER(if (!nullary)
                ss.TODO_FIX_convert_args.mutref(0).type = static_cast<s_Type&&>(arg0type0););
            fu::str error {};
            s_Target candidate {};
            if (nullary || (candidate = tryMatchCall_gDsnGKHT(""_fu, TODO_FIX_reorder, TODO_FIX_conversions, error, false, (*(const s_Scope*)fu::NIL), fu::vec<s_SolvedNode>(ss.TODO_FIX_convert_args), s_Flags_F_CONVERSION, (fu::slate<1, s_Target> { s_Target(target) }), _current_fn, ss, _helpers, _here, ctx, module, options)))
            {
                const s_Target& target_1 = (nullary ? target : candidate);
                s_Overload convert { GET_gDsnGKHT(target_1, ss, _here, ctx, module) };
                if (convert.type)
                {
                    s_Type convertType = ((convert.kind != s_Kind_field) ? s_Type(convert.type) : make_field_reference_gDsnGKHT(from, convert, true, _here, ctx));
                    const bool isUserType = isUserType_27MV22ZA(convertType.vtype);
                    if (int(unsigned(((target_1._packed >> 40ull) & 0xfffffull))) == module.modid)
                        GET_mut_gDsnGKHT(target_1, ss, module).status |= s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE;

                    if (!(s_SolverStatus((convert.status & s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_FINALIZED)))) == s_SolverStatus_SS_DID_START))
                    {
                        const int path0 = path.size();
                        const int must_see0 = must_see.size();
                        if (TODO_FIX_conversions)
                            path += only_m9oK8BbA(TODO_FIX_conversions);

                        path += s_Target(target_1);
                        if ((at_index >= 0))
                            must_see += (nullary ? -(at_index + 1) : +(at_index + 1));

                        result.columns.types += s_ValueType(convertType.vtype);
                        result.columns.paths += fu::vec<s_Target>(path);
                        result.columns.must_see += fu::vec<int>(must_see);
                        if (isUserType || ss._scope.converts.size())
                            descend_gDsnGKHT(convertType, false, isUserType, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, _helpers, _here, ctx, module, options);

                        path.shrink(path0);
                        must_see.shrink(must_see0);
                    };
                }
                else
                    BUG_gDsnGKHT((x7E_3lDd4lqo("No convert.type, perhaps a `using inline fn` without a return type annotation: "_fu, str_FDl5ha9X(target_1, false, ss, _here, ctx, module, options)) + "."_fu), ss, _helpers, _here, ctx, module, options);

            };
        };
    };
}

static const s_UserType& lookupUserType_gDsnGKHT(const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_UserType* _0;
    return *(_0 = &(tryLookupUserType_1qjplDUo(type.vtype, _here, ctx, module))) ? *_0 : fail_gDsnGKHT(("Not a struct nor custom primitive: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static void descend_gDsnGKHT(const s_Type& from, const bool nullary, const bool isUserType, s_ConvCache_ColsAndBakes& result, s_Reorder& TODO_FIX_reorder, fu::vec<fu::vec<s_Target>>& TODO_FIX_conversions, fu::vec<s_Target>& path, fu::vec<int>& must_see, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (nullary)
        for (int i = 0; i < ss._scope.usings.size(); i++)
            foreach_gDsnGKHT(s_Target(ss._scope.usings[i]), i, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, _helpers, _here, ctx, module, options);

    else
    {
        if (isUserType)
        {
            fu::vec<s_Target> inner { lookupUserType_gDsnGKHT(from, ss, _helpers, _here, ctx, module, options).converts };
            for (int i = 0; i < inner.size(); i++)
                foreach_gDsnGKHT(s_Target(inner[i]), -1, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, _helpers, _here, ctx, module, options);

        };
        for (int i = 0; i < ss._scope.converts.size(); i++)
            foreach_gDsnGKHT(s_Target(ss._scope.converts[i]), i, from, nullary, result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, _helpers, _here, ctx, module, options);

    };
}

                                #ifndef DEF_x3Cx3E_eRAb0qSOD13
                                #define DEF_x3Cx3E_eRAb0qSOD13
inline int x3Cx3E_eRAb0qSO(const s_UserTypeCanon& a, const s_UserTypeCanon& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XrkW2YUZ(a.modid, b.modid)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.index, b.index)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_add_RcxQmqfhPl4
                                #define DEF_add_RcxQmqfhPl4
inline bool add_RcxQmqfh(s_Set_ukcriy4HHQd& _, const s_UserTypeCanon& key)
{
    fu::view<s_UserTypeCanon> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_eRAb0qSO(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, s_UserTypeCanon(key));
    return true;
}
                                #endif

static s_ConvCache_ColsAndBakes doExploreConversions_gDsnGKHT(const s_ValueType& startType, s_ConvCache_ColsAndBakes& init, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Type startType_1 = (startType ? s_Type { s_ValueType(startType), s_Lifetime(Lifetime_worst.ref) } : s_Type{});
    if (startType_1)
    {
        const s_UserType& s = tryLookupUserType_1qjplDUo(startType_1.vtype, _here, ctx, module);
        init.field_items = s.items;
        init.field_implicits = s.implicits;
    };
    /*MOV*/ s_ConvCache_ColsAndBakes result {};
    const int conv_safety0 = _current_fn.conv_safety++;
    if ((conv_safety0 >= 128))
    {
        fail_gDsnGKHT(("Conversion stack got too deep, exploring: "_fu + explainType_gDsnGKHT(startType_1, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        fu_DEFER(_current_fn.conv_safety = conv_safety0);
        s_Reorder TODO_FIX_reorder {};
        fu::vec<fu::vec<s_Target>> TODO_FIX_conversions {};
        fu::vec<s_Target> path {};
        fu::vec<int> must_see {};
        descend_gDsnGKHT(startType_1, !startType_1, (startType_1 ? isUserType_27MV22ZA(startType_1.vtype) : false), result, TODO_FIX_reorder, TODO_FIX_conversions, path, must_see, _current_fn, ss, _helpers, _here, ctx, module, options);
        s_Set_ukcriy4HHQd seen {};
        for (int i = (startType_1 ? -1 : 0); i < result.columns.types.size(); i++)
        {
            const s_ValueType& t = ((i < 0) ? startType_1.vtype : result.columns.types[i]);
            const s_UserTypeCanon t_1 = tryParseUserTypeCanon_1qjplDUo(t);
            if (t_1 && add_RcxQmqfh(seen, t_1))
            {
                const s_UserType& s = lookupUserType_1qjplDUo(t_1, module, ctx, _here);
                result.field_items += s.items;
                result.field_implicits += s.implicits;
            };
        };
        return /*NRVO*/ result;
    };
}

                                #ifndef DEF_bfind_wQFfOC5iUPa
                                #define DEF_bfind_wQFfOC5iUPa
inline static int bfind_wQFfOC5i(fu::view<s_ValueType> keys_asc, const s_ValueType& key, s_Set_7aI0knTMWY7& _, const s_ValueType& key_1, fu::vec<s_ConvCache_ColsAndBakes>& values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_VHap4TnO(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, s_ConvCache_ColsAndBakes{});
    _.keys_asc.insert(i, s_ValueType(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_43DxMPty7a1
                                #define DEF_ref_43DxMPty7a1
inline s_ConvCache_ColsAndBakes& ref_43DxMPty(s_Set_7aI0knTMWY7& _, const s_ValueType& key, fu::vec<s_ConvCache_ColsAndBakes>& values)
{
    const int idx = bfind_wQFfOC5i(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_mRfPyUhlrh9
                                #define DEF_ref_mRfPyUhlrh9
inline s_ConvCache_ColsAndBakes& ref_mRfPyUhl(s_Map_j5rW2s1zJ22& _, const s_ValueType& key)
{
    return ref_43DxMPty(_.keys, key, _.vals);
}
                                #endif

static const s_ConvCache_ColsAndBakes& exploreConversions_FDl5ha9X(const s_ValueType& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    bool inserted = false;
    s_ConvCache_ColsAndBakes& cc = ref_eAB3hRSV(ss._conv_cache, type, inserted);
    if (!inserted)
        return cc;
    else
        return (ref_mRfPyUhl(ss._conv_cache, type) = doExploreConversions_gDsnGKHT(type, cc, _current_fn, ss, _helpers, _here, ctx, module, options));

}

static const fu::vec<s_ScopeItem>& convCache_considerFieldItems_gDsnGKHT(const s_Type& type, const s_Flags flags, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    for (int i = 0; i < 1; i++)
    {
        const s_ConvCache_ColsAndBakes& cc = exploreConversions_FDl5ha9X(type.vtype, _current_fn, ss, _helpers, _here, ctx, module, options);
        const fu::vec<s_ScopeItem>& items = ((flags & s_Flags_F_IMPLICIT) ? cc.field_implicits : cc.field_items);
        if (2 > 1)
            return items;

    };
    return (*(const fu::vec<s_ScopeItem>*)fu::NIL);
}

                                #ifndef DEF___ZCCkdMRiNT8
                                #define DEF___ZCCkdMRiNT8
inline static bool _ZCCkdMRi(const int modid, s_BitSet& seen)
{
    return add_ZwXYCruz(seen, modid);
}
                                #endif

                                #ifndef DEF_each_5BXVOqlbDw2
                                #define DEF_each_5BXVOqlbDw2
inline void each_5BXVOqlb(fu::view<int> items, fu::view<s_ScopeSkip> scope_skip, const int start, s_BitSet& seen)
{
    const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const s_ScopeSkip& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _ZCCkdMRi(items[i_1], seen);

            i0 = ss.end;
        };
    };
}
                                #endif

static void visitTypeImports_gDsnGKHT(const s_Type& type, fu::view<char> id, const bool local_scope, fu::vec<s_Target>& extra_items, s_BitSet& seen, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Set_95BJOojOc45& visit = lookupTypeImports_1qjplDUo(type.vtype, _here, ctx, module);
    for (int i = -1; i < visit.keys_asc.size(); i++)
    {
        int BL_3_v {};
        const int modid = ((i >= 0) ? (__extension__ (
        {
            const int i_1 = i;
            BL_3_v = (visit.keys_asc[i_1]);
        (void)0;}), BL_3_v) : modidOfOrigin_27MV22ZA(type));
        if (!(has_ZwXYCruz(seen, modid)))
        {
            if (!seen)
            {
                add_ZwXYCruz(seen, 0);
                add_ZwXYCruz(seen, module.modid);
                each_5BXVOqlb(ss._scope.imports, (local_scope ? ss._ss.imports : fu::view<s_ScopeSkip>{}), 0, seen);
            };
            if (!(!add_ZwXYCruz(seen, modid)))
            {
                const s_Scope& s = ctx.modules[modid].out.solve.scope;
                for (int i_1 = 0; i_1 < s.pub_items; i_1++)
                {
                    if (s.items[i_1].id == id)
                        extra_items.push(target_z0QqoZ5t(s.items[i_1]));

                };
            };
        };
    };
}

                                #ifndef DEF___E2wptbsI9b2
                                #define DEF___E2wptbsI9b2
inline static void _E2wptbsI(const s_Target& u, fu::view<char> id, const bool local_scope, fu::vec<s_Target>& extra_items, s_BitSet& seen, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Type* _0;
    fu::never BL_1_v {};
    visitTypeImports_gDsnGKHT((*(_0 = &(GET_gDsnGKHT(u, ss, _here, ctx, module).type)) ? *_0 : (__extension__ (
    {
        return;
    (void)0;}), static_cast<fu::never&&>(BL_1_v))), id, local_scope, extra_items, seen, ss, _here, ctx, module);
}
                                #endif

                                #ifndef DEF_each_V5AlXe60gk5
                                #define DEF_each_V5AlXe60gk5
inline void each_V5AlXe60(fu::view<s_Target> items, fu::view<s_ScopeSkip> scope_skip, const int start, fu::view<char> id, const bool local_scope, fu::vec<s_Target>& extra_items, s_BitSet& seen, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const s_ScopeSkip& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss_1.end <= i0)))
        {
            const int i1 = ss_1.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _E2wptbsI(items[i_1], id, local_scope, extra_items, seen, ss, _here, ctx, module);

            i0 = ss_1.end;
        };
    };
}
                                #endif

static void clear_iUdwqyBn(s_Reorder& reorder)
{
    reorder.applicable = false;
    reorder.map.clear();
}

                                #ifndef DEF_str_tqiEnBQ6386
                                #define DEF_str_tqiEnBQ6386
inline fu::str str_tqiEnBQ6(const s_SolverStatus n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & s_SolverStatus_SS_LAZY)
            res += ("SS_LAZY"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_DID_START)
            res += ("SS_DID_START"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_DIRTY)
            res += ("SS_DIRTY"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_FINALIZED)
            res += ("SS_FINALIZED"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_UPDATED)
            res += ("SS_UPDATED"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_TYPE_RECUR)
            res += ("SS_TYPE_RECUR"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_FN_RECUR)
            res += ("SS_FN_RECUR"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_FN_OOE_RTL)
            res += ("SS_FN_OOE_RTL"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_NAME_UNUSED)
            res += ("SS_NAME_UNUSED"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_UNUSED)
            res += ("SS_UNUSED"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_MATCHED)
            res += ("SS_MATCHED"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_MOVED_FROM)
            res += ("SS_MOVED_FROM"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_EXTERNAL_LINKAGE)
            res += ("SS_EXTERNAL_LINKAGE"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE)
            res += ("SS_OBSERVED_BY_CONV_CACHE"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_TODO_FIX_was_rx_resize)
            res += ("SS_TODO_FIX_was_rx_resize"_fu + ", "_fu);

        if (n & s_SolverStatus_SS_Debug_AllPassesComplete)
            res += ("SS_Debug_AllPassesComplete"_fu + ", "_fu);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_steal_07W3lQmYYA3
                                #define DEF_steal_07W3lQmYYA3
inline s_CurrentFn steal_07W3lQmY(s_CurrentFn& v)
{
    /*MOV*/ s_CurrentFn ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF_exchange_EqG2aXizAi4
                                #define DEF_exchange_EqG2aXizAi4
inline s_Target exchange_EqG2aXiz(s_Target& a, s_Target&& b)
{
    std::swap(a, b);
    return b;
}
                                #endif

static void replaceGlobid_gDsnGKHT(s_Target& t, const s_Target& target, const s_Target& original, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (parent_gDsnGKHT(t, _here, ctx) == original)
    {
        int BL_2_v {};
        t = Target_xQNS19Zn(int(unsigned(((target._packed >> 40ull) & 0xfffffull))), int(unsigned(((target._packed >> 20ull) & 0xfffffull))), (__extension__ (
        {
            const s_Target& t_1 = t;
            const unsigned v = unsigned((t_1._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v));
    }
    else
    {
        BUG_u9Gbkniv(fu::str{}, _here, ctx);
    };
}

static s_Overload& local_gDsnGKHT(const int locid, fu::view_mut<s_Overload> args_n_locals, const int args_neg)
{
    return args_n_locals.mutref(((args_neg - ((locid > 0) ? 1 : 0)) + locid));
}

static s_HelpersData HelpersReplica_gDsnGKHT(const int local_of, const int locals_start, const s_Type& ret_actual)
{
    return s_HelpersData { s_Target{}, s_SolverPass{}, s_HelpersMask{}, fu::str{}, local_of, locals_start, s_Type{}, s_Type(ret_actual), s_Postdom{}, s_Postdom{}, s_EventsSnap{}, s_Helpers{} };
}

                                #ifndef DEF_ensure_DRUGaYT7Vhk
                                #define DEF_ensure_DRUGaYT7Vhk
inline s_Helpers& ensure_DRUGaYT7(fu::vec<s_Helpers>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_iF_5Rs0gQD7uD4
                                #define DEF_iF_5Rs0gQD7uD4
inline const s_Helpers& iF_5Rs0gQD7(fu::view<s_Helpers> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Helpers*)fu::NIL);

}
                                #endif

static void relinkNode_gDsnGKHT(s_SolvedNode& node, const s_Target& target, const s_Target& original, fu::view_mut<s_Overload> args_n_locals, const int args_neg, fu::vec<s_Helpers>& helpersReplicas, int& lastKnownLocal, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, const s_TokenIdx& _here, const s_Context& ctx)
{
    const s_Kind k = node.kind;
    if (k == s_Kind_letdef)
    {
        replaceGlobid_gDsnGKHT(node.target, target, original, _here, ctx);
        int BL_2_v {};
        const int locid = (__extension__ (
        {
            const s_Target& t = node.target;
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v);
        s_SolvedNode letNode {};
        std::swap(letNode, local_gDsnGKHT(locid, args_n_locals, args_neg).solved);
        relinkNode_gDsnGKHT(letNode, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, _helpers, _here, ctx);
        std::swap(letNode, local_gDsnGKHT(locid, args_n_locals, args_neg).solved);
        if (locid > 0)
            lastKnownLocal = locid;

    }
    else if ((k == s_Kind_let) || (k == s_Kind_call))
    {
        if (isLocal_gDsnGKHT(node.target))
            replaceGlobid_gDsnGKHT(node.target, target, original, _here, ctx);

    }
    else if ((k == s_Kind_block) || (k == s_Kind_loop))
    {
        const s_Helpers foreign { node.helpers };
        if (foreign)
        {
            const int locals_start = (lastKnownLocal + 1);
            int BL_8_v {};
            const s_Helpers local = push_gDsnGKHT(HelpersReplica_gDsnGKHT((__extension__ (
            {
                const s_Target& t = _current_fn.out.target;
                BL_8_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_8_v), locals_start, node.type), ss, _helpers);
            ensure_DRUGaYT7(helpersReplicas, foreign.index) = s_Helpers((node.helpers = (local ? local : BUG_u9Gbkniv(fu::str{}, _here, ctx))));
        };
    }
    else if (k == s_Kind_jump)
    {
        const s_Helpers& foreign = node.helpers;
        const s_Helpers& local = iF_5Rs0gQD7(helpersReplicas, foreign.index);
        node.helpers = (local ? local : BUG_u9Gbkniv(fu::str{}, _here, ctx));
    };
    for (int i = 0; i < node.items.size(); i++)
    {
        s_SolvedNode* _0;
        (_0 = &(node.items.mutref(i)), relinkNode_gDsnGKHT(*_0, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, _helpers, _here, ctx));
    };
}

                                #ifndef DEF_last_fjKdEPCDEdh
                                #define DEF_last_fjKdEPCDEdh
inline s_SolvedNode& last_fjKdEPCD(fu::view_mut<s_SolvedNode> s)
{
    return s.mutref((s.size() - 1));
}
                                #endif

                                #ifndef DEF_steal_46agKNQYY81
                                #define DEF_steal_46agKNQYY81
inline s_SolvedNode steal_46agKNQY(s_SolvedNode& v)
{
    /*MOV*/ s_SolvedNode ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static fu::str currentFn_mustBecomeInline_gDsnGKHT(const s_CurrentFn& _current_fn)
{
    if (_current_fn.TODO_FIX_isInline)
        return "Explicitly marked inline."_fu;
    else if (_current_fn.far_jumps)
        return "Contains non-local control flow."_fu;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF_FN_RET_BACK
                                #define DEF_FN_RET_BACK
inline constexpr int FN_RET_BACK = -2;
                                #endif

                                #ifndef DEF_FN_ARGS_BACK
                                #define DEF_FN_ARGS_BACK
inline constexpr int FN_ARGS_BACK = FN_RET_BACK;
                                #endif

static fu::str str_iUdwqyBn(const s_SolvedNode& n, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::str src = qKW_e44UlzzA(str_WkqQ7QhO(n.kind));
    if ((n.kind == s_Kind_call) || (n.kind == s_Kind_let) || (n.kind == s_Kind_letdef))
        src += (x7E_3lDd4lqo("("_fu, str_FDl5ha9X(n.target, false, ss, _here, ctx, module, options)) + ")"_fu);
    else if (n.value)
        src += (("("_fu + qID_e44UlzzA(n.value)) + ")"_fu);

    if (n.type)
        src += (" -> "_fu + explainType_gDsnGKHT(n.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options));

    return /*NRVO*/ src;
}

static void TEST_unpaintNode_gDsnGKHT(s_SolvedNode& node, const bool expect_paint, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (expect_paint)
    {
        if (!((node.flags & s_Flags_F_TEST_painted) || !node))
            BUG_gDsnGKHT(x7E_3lDd4lqo("Not F_TEST_painted: "_fu, str_iUdwqyBn(node, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
    node.flags &= ~s_Flags_F_TEST_painted;
}

                                #ifndef DEF_LET_INIT
                                #define DEF_LET_INIT
inline constexpr int LET_INIT = 1;
                                #endif

                                #ifndef DEF_iF_4RlV5f26RNf
                                #define DEF_iF_4RlV5f26RNf
inline const s_SolvedNode& iF_4RlV5f26(fu::view<s_SolvedNode> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_SolvedNode*)fu::NIL);

}
                                #endif

static fu::str tryExplainWell_gDsnGKHT(const s_Type& what, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    {
        const s_Lifetime& lifetime = what.lifetime;
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            if (!(!locid))
            {
                const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
                const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
                const s_SolvedNode& init = iF_4RlV5f26(o.solved.items, LET_INIT);
                if (!(is_mutref_9CJmuVSD(o.type, _here, ctx)))
                {
                    fu::str _0 {};
                    fu::str reason = ((_0 = ((((o.flags & (s_Flags_F_CONST | s_Flags_F_REF)) == s_Flags_F_REF) && init) ? tryExplainWell_gDsnGKHT(init.type, _current_fn, ss, _here, ctx, module, options) : fu::str{})) ? static_cast<fu::str&&>(_0) : "not mutable."_fu);
                    return (("a ref to "_fu + explainWhichFn_gDsnGKHT(s_Target(t), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    ... which is "_fu) + reason;
                };
            };
        };
    };
    return ""_fu;
}

static fu::str explainNotMutref_gDsnGKHT(const s_Type& what, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::str _0 {};
    return "expects a mutref, got "_fu + ((_0 = tryExplainWell_gDsnGKHT(what, _current_fn, ss, _here, ctx, module, options)) ? static_cast<fu::str&&>(_0) : explainType_gDsnGKHT(what, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options));
}

static fu::str explainTypeDiff_gDsnGKHT(const s_Type& a, const s_Type& b, fu::view<char> sep, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return (explainType_gDsnGKHT(a, false, false, false, false, false, b, ss, _here, ctx, module, options) + sep) + explainType_gDsnGKHT(b, false, false, false, false, false, a, ss, _here, ctx, module, options);
}

static fu::str explainNotAssignable_gDsnGKHT(const s_Type& host, const s_Type& guest, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (is_mutref_9CJmuVSD(host, _here, ctx))
    {
        if (!is_mutref_9CJmuVSD(guest, _here, ctx))
            return explainNotMutref_gDsnGKHT(guest, _current_fn, ss, _here, ctx, module, options);

    };
    return "expects "_fu + explainTypeDiff_gDsnGKHT(host, guest, ", got "_fu, ss, _here, ctx, module, options);
}

[[noreturn]] static fu::never err_gDsnGKHT(fu::view<char> reason, const s_SolvedNode& node, const s_Target& t, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    BUG_gDsnGKHT(((x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), " "_fu), str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ": "_fu) + reason), ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_mangleArgTypes_qHvSnPWHolg
                                #define DEF_mangleArgTypes_qHvSnPWHolg
inline static fu::str mangleArgTypes_qHvSnPWH(fu::view<s_SolvedNode> args)
{
    /*MOV*/ fu::str mangle = ""_fu;
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const s_SolvedNode& arg = args[i];
        if (numNonInjected++)
            mangle += ',';

        const s_Type& argType = arg.type;
        if (argType)
            mangle += serializeType_1qjplDUo(argType.vtype, "mangle[$T]"_fu);

    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF_if_last_iOPO4E2Xkgb
                                #define DEF_if_last_iOPO4E2Xkgb
inline const s_SolvedNode& if_last_iOPO4E2X(fu::view<s_SolvedNode> s)
{
    if (s.size())
        return s[(s.size() - 1)];
    else
        return (*(const s_SolvedNode*)fu::NIL);

}
                                #endif

static void checkLt_gDsnGKHT(const s_Type& actual, fu::view<char> actualCopy, const s_SolvedNode& expect, fu::view<char> expectCopy, const s_SolvedNode& node, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!is_ref_9CJmuVSD(expect.type) || isIrrelevant_9CJmuVSD(expect.type)))
    {
        s_Lifetime uNion = Lifetime_union_7Yz9ezW2(expect.type.lifetime, actual.lifetime, false, _here, ctx);
        if (uNion != expect.type.lifetime)
        {
            s_Lifetime debug = Lifetime_union_7Yz9ezW2(expect.type.lifetime, actual.lifetime, false, _here, ctx);
            BUG_gDsnGKHT(x7E_3lDd4lqo((((((((((((((x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), ": "_fu) + actualCopy) + " mentions a lifetime not listed in "_fu) + expectCopy) + ":"_fu) + "\n\n\t\t"_fu) + actualCopy) + ":\t"_fu) + explainType_gDsnGKHT(actual, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + "\n\n\t\t"_fu) + expectCopy) + ":\t"_fu) + explainType_gDsnGKHT(expect.type, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + "\n\n\t\tUNION:\t\t"_fu), str_gDsnGKHT(debug, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        };
    };
}

static bool andNodeType_canCleanlyDefinit_gDsnGKHT(const s_Type& type, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (!is_mutref_9CJmuVSD(type, _here, ctx))
    {
        return !is_ref_9CJmuVSD(type) || hasStatic_7Yz9ezW2(type.lifetime);
    }
    else
        return false;

}

                                #ifndef DEF_only_LqU08rcLVAb
                                #define DEF_only_LqU08rcLVAb
inline const s_SolvedNode& only_LqU08rcL(fu::view<s_SolvedNode> s)
{
    fu_ASSERT((s.size() == 1));
    return s[0];
}
                                #endif

                                #ifndef DEF_TRY_ERR
                                #define DEF_TRY_ERR
inline constexpr int TRY_ERR = 1;
                                #endif

                                #ifndef DEF_x3Dx3D_86lTquhEWvi
                                #define DEF_x3Dx3D_86lTquhEWvi
inline bool operator==(const s_Lifetime& a, const s_Lifetime& b)
{
    return !x3Cx3E_imrGV5eV(a, b);
}
                                #endif

                                #ifndef DEF_Lifetime_each_bXsEW5EXQXi
                                #define DEF_Lifetime_each_bXsEW5EXQXi
inline void Lifetime_each_bXsEW5EX(const s_Lifetime& lifetime, bool& notPointless, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        const int locid = ((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v));
        if (!(!locid))
        {
            const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
            const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
            if (o.kind == s_Kind_var)
            {
                if (is_mutref_9CJmuVSD(o.type, _here, ctx))
                    notPointless = true;
                else if (!(locid < 0))
                {
                    check_gDsnGKHT(o.solved.type.lifetime, notPointless, ss, _helpers, _here, ctx, module, options);
                };
                if (notPointless)
                    return;

            }
            else
            {
                BUG_gDsnGKHT(x7E_3lDd4lqo("let.init::copy.expr.lifetime, locid not a var: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            };
        };
    };
}
                                #endif

static void check_gDsnGKHT(const s_Lifetime& lifetime, bool& notPointless, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    Lifetime_each_bXsEW5EX(lifetime, notPointless, ss, _helpers, _here, ctx, module, options);
}

static void TEST_node_gDsnGKHT(s_SolvedNode& node, const s_SolverPass pass, const bool expect_paint, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        s_SolvedNode* _0;
        (_0 = &(node.items.mutref(i)), TEST_node_gDsnGKHT(*_0, pass, expect_paint, _current_fn, ss, _helpers, _here, ctx, module, options));
    };
    _here = node.token;
    unsigned BL_3_v {};
    if (is_never_9CJmuVSD(node.type.vtype) && (__extension__ (
    {
        const s_ValueType& type = node.type.vtype;
        BL_3_v = ((type.quals & q_USAGE));
    (void)0;}), BL_3_v))
        BUG_gDsnGKHT("node.is_never but some usage bits set"_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        TEST_unpaintNode_gDsnGKHT(node, expect_paint, ss, _helpers, _here, ctx, module, options);
        const s_Kind k = node.kind;
        if (!is_ref_9CJmuVSD(node.type) == !node.type.lifetime)
        {
            if (k == s_Kind_call)
            {
                const s_Target& t = node.target;
                const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
                const s_Kind k_1 = o.kind;
                fu::view<s_Argument> host_args = EXT_gDsnGKHT(t, ss, ctx, module).args;
                fu::view<s_SolvedNode> args = node.items;
                if ((host_args.size() == args.size()) || ((k_1 == s_Kind_type) && !args.size()))
                {
                    if (!((o.kind == s_Kind_type) && (tryLookupUserType_1qjplDUo(o.type.vtype, _here, ctx, module).kind == s_Kind_struct)))
                    {
                        for (int i_1 = 0; i_1 < args.size(); i_1++)
                        {
                            const s_Argument& host_arg = host_args[i_1];
                            const s_SolvedNode& arg = args[i_1];
                            if (isIrrelevant_9CJmuVSD(host_arg.type))
                            {
                                if (o.kind == s_Kind_field)
                                {
                                    if (!(isIrrelevant_9CJmuVSD(node.type) || !isIrrelevant_9CJmuVSD(arg.type)))
                                        BUG_gDsnGKHT(((("Relevant data out of an irrelevant struct: getting a "_fu + explainType_gDsnGKHT(node.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " from a "_fu) + explainType_gDsnGKHT(arg.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                                };
                            }
                            else if (isAssignableAsArgument_9CJmuVSD(host_arg.type.vtype, arg.type.vtype, false, _here, ctx))
                            {
                                if ((pass >= s_SolverPass_RelaxCopyResize))
                                {
                                    if (!(is_ref_9CJmuVSD(host_arg.type) || !is_ref_9CJmuVSD(arg.type)))
                                        err_gDsnGKHT(((((x7E_3lDd4lqo("Missing copy or move for arg #"_fu, fu::i64dec(i_1)) + ", "_fu) + qID_e44UlzzA(human_gDsnGKHT(host_arg.name, ss, _here, ctx, module, options))) + ": "_fu) + explainNotAssignable_gDsnGKHT(host_arg.type, arg.type, _current_fn, ss, _here, ctx, module, options)), node, t, ss, _helpers, _here, ctx, module, options);

                                };
                            }
                            else
                                err_gDsnGKHT(((((x7E_3lDd4lqo("Arg #"_fu, fu::i64dec(i_1)) + ", "_fu) + qID_e44UlzzA(human_gDsnGKHT(host_arg.name, ss, _here, ctx, module, options))) + " not assignable to host_arg: "_fu) + explainNotAssignable_gDsnGKHT(host_arg.type, arg.type, _current_fn, ss, _here, ctx, module, options)), node, t, ss, _helpers, _here, ctx, module, options);

                        };
                    };
                    if (o.kind != s_Kind_field)
                    {
                        if ((o.kind == s_Kind_var) && isIrrelevant_9CJmuVSD(o.type))
                            BUG_gDsnGKHT(x7E_3lDd4lqo("Call to irrelevant local: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                        else
                        {
                            const s_Type& expect = node.type;
                            /*MOV*/ s_Type expect_1 = ((o.kind == s_Kind_field) ? clear_refs_9CJmuVSD(s_Type(expect)) : s_Type(expect));
                            s_Type expect_2 = (((o.kind == s_Kind_type) && (node.value == "__partcopy_s"_fu)) ? clear_vfacts_9CJmuVSD(static_cast<s_Type&&>(expect_1)) : static_cast<s_Type&&>(expect_1));
                            if (!(isAssignable_9CJmuVSD(expect_2, o.type, false, false, _here, ctx)))
                                err_gDsnGKHT(("Return value not assignable to node.type: "_fu + explainNotAssignable_gDsnGKHT(expect_2, o.type, _current_fn, ss, _here, ctx, module, options)), node, t, ss, _helpers, _here, ctx, module, options);

                        };
                    };
                }
                else
                {
                    err_gDsnGKHT((((((x7E_3lDd4lqo((x7E_3lDd4lqo("host_args.len ("_fu, fu::i64dec(host_args.size())) + ") != args.len ("_fu), fu::i64dec(args.size())) + "):"_fu) + "\n\t\t"_fu) + mangleArgTypes_qHvSnPWH(args)) + "\n\t\t"_fu) + explainWhichFn_gDsnGKHT(s_Target(t), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)), node, t, ss, _helpers, _here, ctx, module, options);
                };
            }
            else if ((k == s_Kind_block) || (k == s_Kind_and) || (k == s_Kind_or) || (k == s_Kind_if))
            {
                if (k == s_Kind_block)
                {
                    checkLt_gDsnGKHT(if_last_iOPO4E2X(node.items).type, "block.tail"_fu, node, x7E_3lDd4lqo(str_WkqQ7QhO(node.kind), ".type"_fu), node, ss, _helpers, _here, ctx, module, options);
                    const s_HelpersData* BL_26_v;
                    const s_HelpersData* BL_27_v;
                    if ((__extension__ (
                    {
                        const s_Helpers& h = node.helpers;
                        BL_26_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                    (void)0;}), *BL_26_v).ret_actual && !s_HelpersMask(((__extension__ (
                    {
                        const s_Helpers& h = node.helpers;
                        BL_27_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                    (void)0;}), *BL_27_v).mask & s_HelpersMask_HM_Function)))
                    {
                        const s_HelpersData* BL_29_v;
                        checkLt_gDsnGKHT((__extension__ (
                        {
                            const s_Helpers& h = node.helpers;
                            BL_29_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                        (void)0;}), *BL_29_v).ret_actual, "helpers.ret_actual"_fu, node, x7E_3lDd4lqo(str_WkqQ7QhO(node.kind), ".type"_fu), node, ss, _helpers, _here, ctx, module, options);
                    };
                }
                else if ((k == s_Kind_and) || (k == s_Kind_or))
                {
                    if ((node.items.size() >= 2))
                    {
                        const int start = (andNodeType_canCleanlyDefinit_gDsnGKHT(node.type, _here, ctx) ? (node.items.size() - 1) : 0);
                        for (int i_1 = start; i_1 < node.items.size(); i_1++)
                        {
                            const s_SolvedNode& item = node.items[i_1];
                            checkLt_gDsnGKHT(node.type, (x7E_3lDd4lqo(x7E_3lDd4lqo(str_WkqQ7QhO(k), ".items["_fu), fu::i64dec(i_1)) + "]"_fu), node, x7E_3lDd4lqo(str_WkqQ7QhO(node.kind), ".type"_fu), node, ss, _helpers, _here, ctx, module, options);
                            if (is_never_9CJmuVSD(item.type.vtype))
                            {
                                if (i_1 < (node.items.size() - 1))
                                    BUG_gDsnGKHT(x7E_3lDd4lqo("and/or has a never halfway: "_fu, str_iUdwqyBn(item, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                            }
                            else
                            {
                                if (!((pass < s_SolverPass_RelaxCopyResize) && is_zeroes_9CJmuVSD(item.type.vtype)))
                                {
                                    if (!is_void_or_propositionOK_9CJmuVSD(node.type, true, _here, ctx))
                                    {
                                        if (hasTemporary_7Yz9ezW2(node.type.lifetime))
                                            continue;
                                        else
                                        {
                                            s_Type host { node.type };
                                            const s_Type& guest = item.type;
                                            const s_VFacts vfacts_ignore = ((i_1 < (node.items.size() - 1)) ? ((k == s_Kind_and) ? s_VFacts_AlwaysFalse : s_VFacts_AlwaysTrue) : s_VFacts{});
                                            const bool asArgument = false;
                                            if (vfacts_ignore)
                                                host.vtype.vfacts &= s_VFacts(~vfacts_ignore);

                                            if (!(isAssignable_9CJmuVSD(host, guest, false, asArgument, _here, ctx)))
                                                BUG_gDsnGKHT((((x7E_3lDd4lqo("and/or type !<- item["_fu, fu::i64dec(i_1)) + "]"_fu) + ": "_fu) + explainNotAssignable_gDsnGKHT(host, guest, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                                        };
                                    };
                                };
                            };
                        };
                    }
                    else
                        BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), ".len: "_fu), fu::i64dec(node.items.size())), ss, _helpers, _here, ctx, module, options);

                }
                else if (k == s_Kind_if)
                {
                    if (node.items.size() == 3)
                    {
                        if (is_never_9CJmuVSD(node.type.vtype))
                        {
                            if (is_never_9CJmuVSD(node.items[1].type.vtype))
                            {
                                if (!(is_never_9CJmuVSD(node.items[2].type.vtype)))
                                    BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), " never.alt not never: "_fu), str_iUdwqyBn(node.items[2], ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                            }
                            else
                                BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), " never.cons not never: "_fu), str_iUdwqyBn(node.items[1], ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                        };
                        checkLt_gDsnGKHT(node.items[1].type, "if.then"_fu, node, x7E_3lDd4lqo(str_WkqQ7QhO(node.kind), ".type"_fu), node, ss, _helpers, _here, ctx, module, options);
                        checkLt_gDsnGKHT(node.items[2].type, "if.else"_fu, node, x7E_3lDd4lqo(str_WkqQ7QhO(node.kind), ".type"_fu), node, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), ".len: "_fu), fu::i64dec(node.items.size())), ss, _helpers, _here, ctx, module, options);

                };
                fu::view<s_SolvedNode> items = node.items;
                for (int i_1 = 0; i_1 < items.size(); i_1++)
                {
                    if (!(items[i_1].kind))
                        BUG_gDsnGKHT((x7E_3lDd4lqo(x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), ": No .kind on item["_fu), fu::i64dec(i_1)) + "]."_fu), ss, _helpers, _here, ctx, module, options);

                };
            }
            else if (k == s_Kind_jump)
            {
                if ((pass >= s_SolverPass_RelaxCopyResize))
                {
                    const s_Helpers& h = node.helpers;
                    const s_SolvedNode& expr = only_LqU08rcL(node.items);
                    if (!(isAssignable_9CJmuVSD((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual, expr.type, false, false, _here, ctx)))
                        BUG_gDsnGKHT(((x7E_3lDd4lqo(((((("BROKEN JUMP TYPE"_fu + "\n\t\tret_actual: "_fu) + ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual ? explainType_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options) : qBAD_e44UlzzA("N/A"_fu))) + "\n\t\tret_expect: "_fu) + ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect ? explainType_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options) : qBAD_e44UlzzA("N/A"_fu))) + "\n\t\texpr: "_fu), str_iUdwqyBn(expr, ss, _here, ctx, module, options)) + "\n\n\t"_fu) + explainNotAssignable_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual, expr.type, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                };
            }
            else if (k == s_Kind_try)
            {
                if (node.items.size() == 3)
                {
                    const s_SolvedNode& err = node.items[TRY_ERR];
                    if (!((err.kind == s_Kind_letdef) || (err.kind == s_Kind_empty)))
                        BUG_gDsnGKHT(x7E_3lDd4lqo("TRY_ERR not a letdef/empty: "_fu, str_iUdwqyBn(node.items[TRY_ERR], ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                }
                else
                    BUG_gDsnGKHT("try.items.len != 3"_fu, ss, _helpers, _here, ctx, module, options);

            }
            else if ((k == s_Kind_empty) || (k == s_Kind_definit))
            {
                if (node.type.lifetime)
                {
                    if (!(node.type.lifetime == Lifetime_static_moveable))
                    {
                        BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_WkqQ7QhO(k), ": non-static lifetime: "_fu), str_gDsnGKHT(node.type.lifetime, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                    };
                };
                if (!(s_VFacts((node.type.vtype.vfacts & s_VFacts_AlwaysFalse)) || isIrrelevant_9CJmuVSD(node.type) || s_VFacts((node.type.vtype.vfacts & s_VFacts_Typename))))
                    BUG_gDsnGKHT((x7E_3lDd4lqo(str_WkqQ7QhO(k), ": value is neither AlwaysFalse nor irrelevant: "_fu) + explainType_gDsnGKHT(node.type, false, true, false, true, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            }
            else if (k == s_Kind_letdef)
            {
                s_SolvedNode* _1;
                (_1 = &(GET_mut_gDsnGKHT(node.target, ss, module).solved), TEST_node_gDsnGKHT(*_1, pass, expect_paint, _current_fn, ss, _helpers, _here, ctx, module, options));
            }
            else if (k == s_Kind_let)
            {
                if (isIrrelevant_9CJmuVSD(node.type) && (pass >= s_SolverPass_RelaxMut))
                {
                    bool BL_68_v {};
                    if (!((__extension__ (
                    {
                        const s_Target& target = node.target;
                        int BL_69_v {};
                        BL_68_v = (((__extension__ (
                        {
                            const unsigned v = unsigned((target._packed & 0xfffffull));
                            BL_69_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                        (void)0;}), BL_69_v) < 0));
                    (void)0;}), BL_68_v) || !isLocal_gDsnGKHT(node.target)))
                        BUG_gDsnGKHT((x7E_3lDd4lqo(str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options), " place.type is irrelevant: "_fu) + explainType_gDsnGKHT(node.type, false, false, false, true, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                };
                if (node.items.size() != 2)
                {
                    bool BL_72_v {};
                    if (!(node.target && (__extension__ (
                    {
                        const s_Target& target = node.target;
                        int BL_73_v {};
                        BL_72_v = (((__extension__ (
                        {
                            const unsigned v = unsigned((target._packed & 0xfffffull));
                            BL_73_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                        (void)0;}), BL_73_v) < 0));
                    (void)0;}), BL_72_v) && (GET_gDsnGKHT(node.target, ss, _here, ctx, module).flags & s_Flags_F_INJECTED)))
                        BUG_gDsnGKHT(x7E_3lDd4lqo("let.items.len: "_fu, fu::i64dec(node.items.size())), ss, _helpers, _here, ctx, module, options);

                }
                else if (node.items[0])
                    BUG_gDsnGKHT(x7E_3lDd4lqo("let.items[0] not empty: "_fu, str_WkqQ7QhO(node.items[0].kind)), ss, _helpers, _here, ctx, module, options);
                else if (hasTemporary_7Yz9ezW2(node.type.lifetime))
                    BUG_gDsnGKHT(("test_node(let) place.type has temp lt: "_fu + explainType_gDsnGKHT(node.type, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                else
                {
                    const s_Overload& o = GET_gDsnGKHT(node.target, ss, _here, ctx, module);

                    {
                        s_Type host = clear_refs_9CJmuVSD(s_Type(o.type));
                        const s_Type& guest = node.type;
                        const bool asArgument = false;
                        if (!(isAssignable_9CJmuVSD(host, guest, false, asArgument, _here, ctx)))
                            BUG_gDsnGKHT((("test_node(let): let.target.type !<- let.place.type"_fu + ": "_fu) + explainNotAssignable_gDsnGKHT(host, guest, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                    };
                    const s_SolvedNode& init = node.items[1];
                    if (init)
                    {
                        s_Type host { node.type };
                        const s_Type& guest = init.type;
                        const bool asArgument = false;
                        if (!(isAssignable_9CJmuVSD(host, guest, false, asArgument, _here, ctx)))
                            BUG_gDsnGKHT((("test_node(let): place.type !<- let.init.type"_fu + ": "_fu) + explainNotAssignable_gDsnGKHT(host, guest, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                    };
                    if ((init.kind == s_Kind_copy) && !is_trivial_1qjplDUo(init.type.vtype, _here, ctx, module) && !s_SolverStatus((o.status & s_SolverStatus_SS_MOVED_FROM)) && !is_mutref_9CJmuVSD(o.type, _here, ctx))
                    {
                        const s_SolvedNode& expr = only_LqU08rcL(init.items);
                        if (is_ref_9CJmuVSD(expr.type))
                        {
                            bool notPointless = false;
                            check_gDsnGKHT(expr.type.lifetime, notPointless, ss, _helpers, _here, ctx, module, options);
                            if (!(notPointless))
                            {
                                BUG_gDsnGKHT(x7E_3lDd4lqo("test_node(let) Pointless copy "_fu, str_gDsnGKHT(expr.type.lifetime, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                            };
                        }
                        else
                            BUG_gDsnGKHT("test_node(let) init::copy, !expr.is_ref"_fu, ss, _helpers, _here, ctx, module, options);

                    };
                };
            };
        }
        else
            BUG_gDsnGKHT((x7E_3lDd4lqo(str_iUdwqyBn(node, ss, _here, ctx, module, options), ": !!ref != !!lt: "_fu) + explainType_gDsnGKHT(node.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
}

static void TEST_pass_gDsnGKHT(s_SolvedNode& node, const s_SolverPass pass, const bool expect_paint, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_HelpersData* BL_1_v;
    if ((__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_1_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_1_v).target == _current_fn.out.target)
    {
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            s_SolvedNode* _0;
            (_0 = &(_current_fn.out.items.mutref(i)), TEST_unpaintNode_gDsnGKHT(*_0, false, ss, _helpers, _here, ctx, module, options));
        };
        TEST_node_gDsnGKHT(node, pass, expect_paint, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF_NO_LOOP
                                #define DEF_NO_LOOP
inline constexpr int NO_LOOP = -1000001;
                                #endif

static void Postdom_resetAtFnEnd_gDsnGKHT(s_Postdom& postdom)
{
    postdom = s_Postdom{};
    postdom.write_loop_start = NO_LOOP;
    postdom.read_loop_start = NO_LOOP;
    postdom.snap.exitPaths = s_ExitPaths_XP_EmptyReturn;
}

                                #ifndef DEF_RELAX_before_bck
                                #define DEF_RELAX_before_bck
extern const unsigned RELAX_before_bck;
                                #endif

static void TEST_paintNode_gDsnGKHT(s_SolvedNode& node, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (node.flags & s_Flags_F_TEST_painted)
    {
        if ((node.kind == s_Kind_call) && (GET_gDsnGKHT(node.target, ss, _here, ctx, module).kind == s_Kind_fn))
            BUG_gDsnGKHT(x7E_3lDd4lqo("Already F_TEST_painted: "_fu, str_iUdwqyBn(node, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
    node.flags |= s_Flags_F_TEST_painted;
}

                                #ifndef DEF_RELAX_all
                                #define DEF_RELAX_all
extern const unsigned RELAX_all;
                                #endif

                                #ifndef DEF_CANNOT_definit_mutrefs
                                #define DEF_CANNOT_definit_mutrefs
inline constexpr bool CANNOT_definit_mutrefs = true;
                                #endif

static s_SolvedNode createBlock_gDsnGKHT(const s_Type& type, const fu::vec<s_SolvedNode>& items, const s_Helpers& h, const s_TokenIdx& _here)
{
    return SolvedNode_gDsnGKHT(s_Kind_block, type, s_Flags{}, (*(const fu::str*)fu::NIL), items, s_Target{}, h, _here);
}

static s_SolvedNode createBlock_FDl5ha9X(/*MOV*/ s_SolvedNode&& a, /*MOV*/ s_SolvedNode&& b, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (isImmediatelyDiscardable_UVY6Qzz1(a.kind) || ((a.kind == s_Kind_call) && (GET_gDsnGKHT(a.target, ss, _here, ctx, module).kind == s_Kind_var)))
        return static_cast<s_SolvedNode&&>(b);
    else if (b.kind == s_Kind_block)
    {
        b.items.unshift(static_cast<s_SolvedNode&&>(a));
        return static_cast<s_SolvedNode&&>(b);
    }
    else
    {
        return createBlock_gDsnGKHT(b.type, fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { static_cast<s_SolvedNode&&>(a), s_SolvedNode(b) } }, s_Helpers{}, _here);
    };
}

static void definitWrap_gDsnGKHT(s_SolvedNode& node, const s_Type& slot, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (is_mutref_9CJmuVSD(slot, _here, ctx))
        BUG_gDsnGKHT(("Trying to definitWrap a mutref: "_fu + explainType_gDsnGKHT(slot, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
    else if (is_ref_9CJmuVSD(slot) && !hasStatic_7Yz9ezW2(slot.lifetime))
    {
        if (hasTemporary_7Yz9ezW2(slot.lifetime))
            definitWrap_gDsnGKHT(node, clear_refs_9CJmuVSD(s_Type(slot)), ss, _helpers, _here, ctx, module, options);
        else
            BUG_gDsnGKHT(("Trying to definitWrap a non-static reference: "_fu + explainType_gDsnGKHT(slot, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        /*MOV*/ s_SolvedNode empty = createEmpty_gDsnGKHT(slot, s_Target{}, ss, _helpers, _here, ctx, module, options);
        node = (isImmediatelyDiscardable_UVY6Qzz1(node.kind) ? static_cast<s_SolvedNode&&>(empty) : createBlock_FDl5ha9X(s_SolvedNode(node), static_cast<s_SolvedNode&&>(empty), ss, _here, ctx, module));
    };
}

static void maybeCopyOrMove_gDsnGKHT(s_SolvedNode& node, const s_Type& slot, const bool isArgument, const fu::str& debug, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(isIrrelevant_9CJmuVSD(slot)))
    {
        unsigned BL_2_v {};
        if (is_never_9CJmuVSD(slot.vtype) && (__extension__ (
        {
            const s_ValueType& type = slot.vtype;
            BL_2_v = ((type.quals & q_USAGE));
        (void)0;}), BL_2_v))
            BUG_gDsnGKHT("maybeCopyOrMove: slot.is_never but some usage bits set"_fu, ss, _helpers, _here, ctx, module, options);
        else if (!isCanonAssignable_Ot6wT82z(slot.vtype.canon, node.type.vtype.canon, _here, ctx) && !is_never_9CJmuVSD(node.type.vtype))
        {
            if (is_zeroes_9CJmuVSD(node.type.vtype) && !(is_mutref_9CJmuVSD(slot, _here, ctx) && CANNOT_definit_mutrefs))
                definitWrap_gDsnGKHT(node, slot, ss, _helpers, _here, ctx, module, options);
            else
                BUG_gDsnGKHT(("Considering copy or move for incompatible types: "_fu + explainNotAssignable_gDsnGKHT(slot, node.type, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        }
        else if (is_ref_9CJmuVSD(slot))
        {
            if (is_trivial_1qjplDUo(node.type.vtype, _here, ctx, module))
            {
                if ((node.kind == s_Kind_empty) && isArgument)
                    node.type = clear_refs_9CJmuVSD(s_Type(node.type));

            };
        }
        else
        {
            if (!(!is_ref_9CJmuVSD(node.type)))
            {
                if ((node.kind == s_Kind_empty) || (node.kind == s_Kind_str))
                    node.type = clear_refs_9CJmuVSD(s_Type(node.type));
                else
                {
                    const s_TokenIdx here0 { _here };
                    fu_DEFER(_here = here0);
                    _here = node.token;
                    node = SolvedNode_gDsnGKHT(s_Kind_copy, clear_refs_9CJmuVSD(s_Type(node.type)), s_Flags{}, debug, fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } }, s_Target{}, s_Helpers{}, _here);
                };
            };
        };
    };
}

                                #ifndef DEF_ensure_HTTEW0RD407
                                #define DEF_ensure_HTTEW0RD407
inline s_Type& ensure_HTTEW0RD(fu::vec<s_Type>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_rsEucHaxRp2
                                #define DEF_ensure_rsEucHaxRp2
inline static s_Type& ensure_rsEucHax(s_LocidMap_EcBtE1sFv98& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_HTTEW0RD(map._values, (args_neg + locid));
}
                                #endif

static bool trackVarUsage_gDsnGKHT(const int locid, const s_Type& slot, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    {
        const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
        if (is_rx_copy_9CJmuVSD(slot.vtype) && isIrrelevant_9CJmuVSD(slot) && !is_zst_1qjplDUo(slot.vtype, _here, ctx, module))
            BUG_gDsnGKHT(((x7E_3lDd4lqo("trackVarUsage "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ": Usage is copy but no usage bits set: "_fu) + explainType_gDsnGKHT(slot, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else if (hasTemporary_7Yz9ezW2(slot.lifetime))
            BUG_gDsnGKHT((x7E_3lDd4lqo(str_FDl5ha9X(t, false, ss, _here, ctx, module, options), ", trackVarUsage: slot is ref2temp: "_fu) + explainType_gDsnGKHT(slot, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else if (isIrrelevant_9CJmuVSD(slot))
            BUG_gDsnGKHT((x7E_3lDd4lqo(str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options), ", trackVarUsage: slot is irrelevant: "_fu) + explainType_gDsnGKHT(slot, false, false, false, true, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
    s_Type& usage = ensure_rsEucHax(_current_fn.relaxed.var_usage, locid, _current_fn);
    if (!usage)
    {
        usage = slot;
        return true;
    }
    else
    {
        s_Type _0 {};
        usage = ((_0 = type_tryIntersect_9CJmuVSD(usage, slot, _here, ctx)) ? static_cast<s_Type&&>(_0) : BUG_gDsnGKHT((x7E_3lDd4lqo(str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options), ": Usage intersection failure: "_fu) + explainTypeDiff_gDsnGKHT(usage, slot, " & "_fu, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options));
        return false;
    };
}

                                #ifndef DEF_ensure_8RIgQELPTc3
                                #define DEF_ensure_8RIgQELPTc3
inline s_Warning& ensure_8RIgQELP(fu::vec<s_Warning>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static void push_FDl5ha9X(const s_Warning& warning, const s_CurrentFn& _current_fn, s_SolverState& ss)
{
    int BL_1_v {};
    s_Warning& a = ensure_8RIgQELP(ss._warnings, (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v));
    if (!(a))
        a = warning;

}

static void warnUnused_gDsnGKHT(const s_Target& target, const s_Overload& o, const s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (!((o.flags & s_Flags_F_LAX) || s_SolverStatus((o.status & s_SolverStatus_SS_MATCHED)) || is_zst_1qjplDUo(o.type.vtype, _here, ctx, module)))
    {
        int BL_2_v {};
        push_FDl5ha9X(s_Warning { (__extension__ (
        {
            const unsigned v = unsigned((target._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v) }, _current_fn, ss);
    };
}

static void unwrapLetdef_gDsnGKHT(s_SolvedNode& node, const unsigned relax_mask, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (relax_mask != RELAX_before_bck)
    {
        const s_SolverNotes note = s_SolverNotes_N_McomUnwrapsLetdef;
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            ss._notes |= note;

    };
    s_Overload& o = GET_mut_gDsnGKHT(node.target, ss, module);
    s_SolvedNode& init = o.solved.items.mutref(LET_INIT);
    if ((o.kind == s_Kind_var) && s_SolverStatus((o.status & s_SolverStatus_SS_NAME_UNUSED)))
    {
        if (!is_mutref_9CJmuVSD(o.type, _here, ctx) || is_mutref_9CJmuVSD(o.solved.type, _here, ctx))
        {
            if (!(is_ref_9CJmuVSD(o.solved.type) || !is_ref_9CJmuVSD(init.type)))
                BUG_gDsnGKHT("unwrapLetdef: runs before mcom."_fu, ss, _helpers, _here, ctx, module, options);

        }
        else
            BUG_gDsnGKHT("unwrapLetdef: converts a mutval into a mutref."_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT("unwrapLetdef: !var || !SS_NAME_UNUSED"_fu, ss, _helpers, _here, ctx, module, options);

    node = steal_46agKNQY(init);
}

                                #ifndef DEF_iF_Erio8Rir0T5
                                #define DEF_iF_Erio8Rir0T5
inline const s_Type& iF_Erio8Rir(fu::view<s_Type> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Type*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_DSxLaV2V8B4
                                #define DEF_iF_DSxLaV2V8B4
inline static const s_Type& iF_DSxLaV2V(const s_LocidMap_EcBtE1sFv98& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_Erio8Rir(map._values, (args_neg + locid));
}
                                #endif

static bool isMutVal_gDsnGKHT(const s_Overload& o)
{
    return !(~o.flags & (s_Flags_F_MUT | s_Flags_F_VAL));
}

static void keepOrClearMutVal_gDsnGKHT(s_Overload& o, const bool keep, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if ((o.kind == s_Kind_var) && isMutVal_gDsnGKHT(o))
    {
        s_SolvedNode& node = o.solved;
        if (keep)
            node.type = clear_refs_9CJmuVSD(s_Type(node.type));
        else
            o.flags &= ~s_Flags_F_MUT;

    }
    else
        BUG_gDsnGKHT("keepOrClearMutVal: Not a mut var"_fu, ss, _helpers, _here, ctx, module, options);

}

static bool add_gDsnGKHT(s_LocidSet& set, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return add_ZwXYCruz(set._bitset, (args_neg + locid));
}

static void relaxBlockVar_gDsnGKHT(const s_Target& t, const unsigned relax_mask, const bool canDiscard, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
    if (_current_fn)
    {
        int BL_2_v {};
        const s_Type& usage = iF_DSxLaV2V(_current_fn.relaxed.var_usage, (__extension__ (
        {
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v), _current_fn);
        const bool isUnused = !usage;
        if (isUnused)
            warnUnused_gDsnGKHT(t, o, _current_fn, ss, _here, ctx, module);

        if (is_rx_copy_9CJmuVSD(usage.vtype) && isIrrelevant_9CJmuVSD(usage) && !is_zst_1qjplDUo(usage.vtype, _here, ctx, module))
            BUG_gDsnGKHT(((x7E_3lDd4lqo("relaxBlockVar "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ": Usage is copy but no usage bits set: "_fu) + explainType_gDsnGKHT(usage, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else
        {
            s_Overload& o_1 = GET_mut_gDsnGKHT(t, ss, module);
            if (isUnused)
                o_1.status |= s_SolverStatus_SS_UNUSED;
            else if (o_1.status & s_SolverStatus_SS_UNUSED)
                BUG_gDsnGKHT(((x7E_3lDd4lqo("relaxBlockVar: previously SS_UNUSED "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + " now used as "_fu) + explainType_gDsnGKHT(usage, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            if (isUnused && canDiscard)
                o_1.solved.type = t_void;

            try_relax_9CJmuVSD(o_1.type, usage, relax_mask);
            s_SolvedNode& node = o_1.solved;
            if (node.type)
            {
                try_relax_9CJmuVSD(node.type, usage, relax_mask);
                if (isMutVal_gDsnGKHT(o_1))
                {
                    int BL_11_v {};
                    if (!((__extension__ (
                    {
                        const unsigned v = unsigned((t._packed & 0xfffffull));
                        BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                    (void)0;}), BL_11_v) < 0))
                        keepOrClearMutVal_gDsnGKHT(o_1, is_mutref_9CJmuVSD(usage, _here, ctx), ss, _helpers, _here, ctx, module, options);

                };
            }
            else
                BUG_gDsnGKHT("relaxBlockVar: !var.solved.type, can`t propagateType"_fu, ss, _helpers, _here, ctx, module, options);

        };
    };
    s_SolvedNode node = steal_46agKNQY(GET_mut_gDsnGKHT(t, ss, module).solved);
    TEST_paintNode_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);
    int BL_14_v {};
    if (node.items && node.items[LET_INIT] && !((__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_14_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_14_v) < 0))
    {
        s_SolvedNode& init = node.items.mutref(LET_INIT);
        propagateType_gDsnGKHT(init, node.type, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (is_ref_9CJmuVSD(node.type))
        {
            if ((init.kind == s_Kind_letdef) && s_SolverStatus((GET_gDsnGKHT(init.target, ss, _here, ctx, module).status & s_SolverStatus_SS_NAME_UNUSED)))
                unwrapLetdef_gDsnGKHT(init, relax_mask, ss, _helpers, _here, ctx, module, options);

            node.type.lifetime = init.type.lifetime;
        };
    };
    std::swap(node, GET_mut_gDsnGKHT(t, ss, module).solved);
    int BL_18_v {};
    add_gDsnGKHT(_current_fn.relaxed.done_relaxing, (__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_18_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_18_v), _current_fn);
}

                                #ifndef DEF_t_proposition
                                #define DEF_t_proposition
extern const s_Type t_proposition;
                                #endif

static bool isDiscardable_FDl5ha9X(const s_SolvedNode& node, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (node.items)
        return false;
    else if ((node.kind == s_Kind_call) || (node.kind == s_Kind_letdef))
        return false;
    else if ((node.kind == s_Kind_block) || isImmediatelyDiscardable_UVY6Qzz1(node.kind))
        return true;
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo("TODO: isDiscardable("_fu, str_WkqQ7QhO(node.kind)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_x3Cx3E_cOuytDg4nz6
                                #define DEF_x3Cx3E_cOuytDg4nz6
inline int x3Cx3E_cOuytDg4(const s_MayEscapeVia a, const s_MayEscapeVia b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_Fhv3qj2faB1
                                #define DEF_x3Cx3E_Fhv3qj2faB1
inline int x3Cx3E_Fhv3qj2f(const s_ExitPaths a, const s_ExitPaths b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_SCjWC3jwOii
                                #define DEF_x3Cx3E_SCjWC3jwOii
inline int x3Cx3E_SCjWC3jw(const fu::u8 a, const fu::u8 b)
{
    if (a < b)
        return -1;
    else if (a > b)
        return +1;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_2B3yLELSkLi
                                #define DEF_x3Cx3E_2B3yLELSkLi
inline int x3Cx3E_2B3yLELS(fu::view<fu::u8> a, fu::view<fu::u8> b)
{
    int cmp = x3Cx3E_XrkW2YUZ(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_SCjWC3jw(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_IrVuuMbF0I2
                                #define DEF_x3Cx3E_IrVuuMbF0I2
inline int x3Cx3E_IrVuuMbF(const s_BitSet& a, const s_BitSet& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_2B3yLELS(a._data, b._data)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_rs5tDW3Cj6c
                                #define DEF_x3Cx3E_rs5tDW3Cj6c
inline int x3Cx3E_rs5tDW3C(const s_LocidSet& a, const s_LocidSet& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_IrVuuMbF(a._bitset, b._bitset)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_6XH4H97vGqg
                                #define DEF_x3Cx3E_6XH4H97vGqg
inline int x3Cx3E_6XH4H97v(fu::view<unsigned> a, fu::view<unsigned> b)
{
    int cmp = x3Cx3E_XrkW2YUZ(a.size(), b.size());
    for (int i = 0; (i < a.size()) && !cmp; i++)
        cmp = x3Cx3E_F82w14kI(a[i], b[i]);

    return cmp;
}
                                #endif

                                #ifndef DEF_x3Cx3E_UloJhXar3vc
                                #define DEF_x3Cx3E_UloJhXar3vc
inline int x3Cx3E_UloJhXar(const s_LocidMap_DC5gktNgm89& a, const s_LocidMap_DC5gktNgm89& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_6XH4H97v(a._values, b._values)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Cx3E_eU8gdWA8xJ1
                                #define DEF_x3Cx3E_eU8gdWA8xJ1
inline int x3Cx3E_eU8gdWA8(const s_PostdomSnap& a, const s_PostdomSnap& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_cOuytDg4(a.mayEscapeVia, b.mayEscapeVia)))
        return cmp;
    else if ((cmp = x3Cx3E_Fhv3qj2f(a.exitPaths, b.exitPaths)))
        return cmp;

    if ((cmp = x3Cx3E_rs5tDW3C(a.used_again, b.used_again)))
        return cmp;
    else if ((cmp = x3Cx3E_UloJhXar(a.ever_written, b.ever_written)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF_x3Cx3E_buShAFSoi5c
                                #define DEF_x3Cx3E_buShAFSoi5c
inline int x3Cx3E_buShAFSo(const s_Postdom& a, const s_Postdom& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XrkW2YUZ(a.write_loop_start, b.write_loop_start)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.read_loop_start, b.read_loop_start)))
        return cmp;

    if ((cmp = x3Cx3E_eU8gdWA8(a.snap, b.snap)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x3Dx3D_O64pacrOAQf
                                #define DEF_x3Dx3D_O64pacrOAQf
inline bool operator==(const s_Postdom& a, const s_Postdom& b)
{
    return !x3Cx3E_buShAFSo(a, b);
}
                                #endif

                                #ifndef DEF_ensure_NX8DJxmgfmj
                                #define DEF_ensure_NX8DJxmgfmj
inline unsigned& ensure_NX8DJxmg(fu::vec<unsigned>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static void operator|=(s_LocidMap_DC5gktNgm89& dest, const s_LocidMap_DC5gktNgm89& src)
{
    for (int i = src._values.size(); i-- > 0; )
    {
        const unsigned src_1 = src._values[i];
        if (src_1)
            ensure_NX8DJxmg(dest._values, i) |= src_1;

    };
}

static void branch_gDsnGKHT(s_Postdom& dest, const s_Postdom& src, const s_TokenIdx& _here, const s_Context& ctx)
{

    {

        {
            const s_LocidSet& other = src.snap.used_again;
            s_LocidSet& set = dest.snap.used_again;
            set._bitset |= other._bitset;
        };
        dest.snap.ever_written |= src.snap.ever_written;
        dest.snap.mayEscapeVia |= src.snap.mayEscapeVia;
        dest.snap.exitPaths |= src.snap.exitPaths;
    };
    dest.write_loop_start = max_yeUdQhUA((dest.write_loop_start ? dest.write_loop_start : BUG_u9Gbkniv(fu::str{}, _here, ctx)), (src.write_loop_start ? src.write_loop_start : BUG_u9Gbkniv(fu::str{}, _here, ctx)));
    dest.read_loop_start = max_yeUdQhUA((dest.read_loop_start ? dest.read_loop_start : BUG_u9Gbkniv(fu::str{}, _here, ctx)), (src.read_loop_start ? src.read_loop_start : BUG_u9Gbkniv(fu::str{}, _here, ctx)));
}

                                #ifndef DEF_if_only_2GSkLHW1BX6
                                #define DEF_if_only_2GSkLHW1BX6
inline const s_SolvedNode& if_only_2GSkLHW1(fu::view<s_SolvedNode> s)
{
    if (s.size() == 1)
        return s[0];
    else
        return (*(const s_SolvedNode*)fu::NIL);

}
                                #endif

static int createAndOr_staticEvalFold_gDsnGKHT(fu::vec<s_SolvedNode>& items, const s_StaticEval static_eval_fold, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int trim = 0;
    for (int i = (items.size() - 1); i-- > 0; )
    {
        const s_StaticEval se = tryAbstractEvalAsBool_gDsnGKHT(items[i], false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (se == static_eval_fold)
        {
            /*MOV*/ s_SolvedNode cond { items[i] };
            items.splice(i, 1);
            if (trim)
                trim--;

            s_SolvedNode& cons = items.mutref(i);
            cons = createBlock_FDl5ha9X(static_cast<s_SolvedNode&&>(cond), s_SolvedNode(cons), ss, _here, ctx, module);
        }
        else if (se)
            trim = (i + 1);

    };
    return trim;
}

                                #ifndef DEF_last_31malqbtYj8
                                #define DEF_last_31malqbtYj8
inline const s_SolvedNode& last_31malqbt(fu::view<s_SolvedNode> s)
{
    return s[(s.size() - 1)];
}
                                #endif

static s_SolvedNode createOr_gDsnGKHT(fu::vec<s_SolvedNode>&& items, s_Type&& type, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    {
        const int trim = createAndOr_staticEvalFold_gDsnGKHT(items, s_StaticEval_SE_False, _current_fn, ss, _helpers, _here, ctx, module, options);
        const s_VFacts vfacts = s_VFacts_AlwaysTrue;
        if (trim)
        {
            items.shrink(trim);
            type.vtype.vfacts |= vfacts;
        };
        if (items.size() < 2)
        {
            const s_SolvedNode& only = only_LqU08rcL(items);
            return s_SolvedNode(only);
        };
    };
    if (!is_void_or_propositionOK_9CJmuVSD(type, false, _here, ctx))
    { {
        /*MOV*/ s_Type sumType {};
        for (int i = items.size(); i-- > 0; )
        {
            const s_SolvedNode& item = items[i];
            if (!(is_never_9CJmuVSD(item.type.vtype)))
            {
                if (sumType)
                {
                    s_Type _0 {};
                    fu::never BL_9_v {};
                    sumType = ((_0 = type_trySuper_9CJmuVSD(sumType, item.type, false, _here, ctx)) ? static_cast<s_Type&&>(_0) : (__extension__ (
                    {
                        for (int i_1 = 0; i_1 < items.size(); i_1++)
                        {
                            const s_SolvedNode& item_1 = items[i_1];
                            if (item_1.type.vtype.canon == t_bool.vtype.canon)
                            {
                                type = t_bool;
                                goto BL_4;
                            };
                        };
                        fail_gDsnGKHT(("Ambiguous ||, incompatible operands in a non-bool context: "_fu + explainTypeDiff_gDsnGKHT(item.type, sumType, " || "_fu, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    (void)0;}), static_cast<fu::never&&>(BL_9_v)));
                }
                else
                    sumType = item.type;

            };
        };
        if (!sumType)
            type = t_bool;
        else
            type = static_cast<s_Type&&>(sumType);

      } BL_4:;
    }
    else
        type = t_bool;

    const s_Type& last_type = last_31malqbt(items).type;
    if (is_never_9CJmuVSD(last_type.vtype) || s_VFacts((last_type.vtype.vfacts & s_VFacts_AlwaysTrue)))
        type.vtype.vfacts = s_VFacts_AlwaysTrue;

    return SolvedNode_gDsnGKHT(s_Kind_or, type, s_Flags{}, (*(const fu::str*)fu::NIL), items, s_Target{}, s_Helpers{}, _here);
}

static s_SolvedNode solveDefinit_gDsnGKHT(const s_Type& type, const s_TokenIdx& _here, const s_Context& ctx)
{
    s_Type type_1 = definitType_9CJmuVSD(s_Type(type), false, _here, ctx);
    return SolvedNode_gDsnGKHT(s_Kind_definit, type_1, s_Flags{}, (*(const fu::str*)fu::NIL), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, s_Helpers{}, _here);
}

                                #ifndef DEF_min_O25D0jcUwAc
                                #define DEF_min_O25D0jcUwAc
inline int min_O25D0jcU(const int a, const int b)
{
    if ((a <= b))
        return a;
    else
        return b;

}
                                #endif

static int couldRetype_gDsnGKHT(const s_SolvedNode& node)
{
    if (node.kind == s_Kind_real)
        return 1;
    else if (node.kind == s_Kind_int)
        return 2;
    else if (node.kind == s_Kind_definit)
        return 3;
    else if (is_zeroes_9CJmuVSD(node.type.vtype))
        return 3;
    else if (node.kind == s_Kind_str)
        return 3;
    else if (node.kind == s_Kind_if)
        return min_O25D0jcU(couldRetype_gDsnGKHT(node.items[1]), couldRetype_gDsnGKHT(node.items[2]));
    else if (node.kind == s_Kind_block)
    {
        if (!node.helpers)
            return couldRetype_gDsnGKHT(last_31malqbt(node.items));
        else
            return 0;

    }
    else if (node.kind == s_Kind_argid)
        return couldRetype_gDsnGKHT(only_LqU08rcL(node.items));
    else
        return 0;

}

static s_SolvedNode litfix_bound_gDsnGKHT(const s_SolvedNode& expr, const s_SolvedNode& bound, const s_TokenIdx& _here)
{
    if (couldRetype_gDsnGKHT(expr))
    {
        return SolvedNode_gDsnGKHT(s_Kind___litfix_bound, expr.type, s_Flags{}, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode(expr), s_SolvedNode((couldRetype_gDsnGKHT(bound) ? bound : (*(const s_SolvedNode*)fu::NIL))) } }, s_Target{}, s_Helpers{}, _here);
    }
    else
        return s_SolvedNode(expr);

}

static fu::view<char> getBasePrim_FDl5ha9X(const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int offset = basePrimPrefixLen_hxWWgdZ1(type.vtype.canon);
    if (offset < type.vtype.canon.size())
        return lookupUserType_gDsnGKHT(type, ss, _helpers, _here, ctx, module, options).shape.basePrim;
    else
        return type.vtype.canon;

}

static bool want_gDsnGKHT(const s_Type& t, fu::view<char> c)
{
    return c == t.vtype.canon;
}

static const s_Type& check_FDl5ha9X(const s_Type& type, const s_Intlit& parse, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (type && is_primitive_hxWWgdZ1(type.vtype))
    {
        fu::view<char> c = getBasePrim_FDl5ha9X(type, ss, _helpers, _here, ctx, module, options);
        if (!parse.uNsigned)
        {
            if (((parse.minsize_f <= fu::u8(32u)) && want_gDsnGKHT(t_f32, c)) || ((parse.minsize_f <= fu::u8(64u)) && want_gDsnGKHT(t_f64, c)) || ((parse.minsize_i <= fu::u8(32u)) && want_gDsnGKHT(t_i32, c)) || ((parse.minsize_i <= fu::u8(64u)) && want_gDsnGKHT(t_i64, c)) || ((parse.minsize_i <= fu::u8(16u)) && want_gDsnGKHT(t_i16, c)) || ((parse.minsize_i <= fu::u8(8u)) && want_gDsnGKHT(t_i8, c)))
                return type;

        };
        if (!parse.sIgned)
        {
            if (((parse.minsize_u <= fu::u8(32u)) && want_gDsnGKHT(t_u32, c)) || ((parse.minsize_u <= fu::u8(64u)) && want_gDsnGKHT(t_u64, c)) || ((parse.minsize_u <= fu::u8(16u)) && want_gDsnGKHT(t_u16, c)) || ((parse.minsize_u <= fu::u8(8u)) && want_gDsnGKHT(t_u8, c)))
                return type;

        };
    };
    if (parse.uNsigned || (!parse.sIgned && (parse.base != fu::u8(10u))))
    {
        if ((parse.minsize_u <= fu::u8(32u)))
            return t_u32;
        else if ((parse.minsize_u <= fu::u8(64u)))
            return t_u64;

    }
    else if ((parse.minsize_i <= fu::u8(32u)))
        return t_i32;
    else if ((parse.minsize_i <= fu::u8(64u)))
        return t_i64;

    fail_gDsnGKHT("Bad int literal."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static s_Type solveInt_gDsnGKHT(fu::view<char> v, const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Intlit parse = Intlit_u8re8TwO(v);
    if (parse.error)
    {
        fail_gDsnGKHT(parse.error, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        /*MOV*/ s_Type type_1 = clear_refs_9CJmuVSD(s_Type(check_FDl5ha9X(type, parse, ss, _helpers, _here, ctx, module, options)));
        if (!s_DevOptions((options.dev & s_DevOptions_DEV_DontFoldLiterals)))
            type_1.vtype.vfacts = (parse.absval ? s_VFacts_AlwaysTrue : s_VFacts_AlwaysFalse);

        return /*NRVO*/ type_1;
    };
}

static const s_Type& solveReal_gDsnGKHT(const s_Type& type)
{
    if (type.vtype.canon == t_f32.vtype.canon)
        return t_f32;
    else
        return t_f64;

}

                                #ifndef DEF_t_string_literal
                                #define DEF_t_string_literal
extern const s_Type t_string_literal;
                                #endif

static s_Type solveString_gDsnGKHT(fu::view<char> v, const s_Type& type, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (type && is_primitive_hxWWgdZ1(type.vtype))
    {
        fu::view<s_ScopeItem> a = tryLookupUserType_1qjplDUo(type.vtype, _here, ctx, module).items;
        for (int i = 0; i < a.size(); i++)
        {
            const s_ScopeItem& member = a[i];
            if (member.id == v)
                return s_Type(GET_gDsnGKHT(target_z0QqoZ5t(member), ss, _here, ctx, module).type);

        };
    };
    /*MOV*/ s_Type ret { t_string_literal };
    if (!s_DevOptions((options.dev & s_DevOptions_DEV_DontFoldLiterals)))
    {
        ret.vtype.vfacts = (v.size() ? s_VFacts_AlwaysTrue : s_VFacts_AlwaysFalse);
        ret.vtype.vfacts |= s_VFacts((s_VFacts_LeftAligned | s_VFacts_RightAligned));
    };
    return /*NRVO*/ ret;
}

static s_Type tryRetyping_gDsnGKHT(const s_SolvedNode& node, const s_Type& expect, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if ((node.kind == s_Kind_definit) || is_zeroes_9CJmuVSD(node.type.vtype))
        return definitType_9CJmuVSD(s_Type(expect), false, _here, ctx);
    else
    {
        if (is_arithmetic_hxWWgdZ1(node.type.vtype) && is_arithmetic_hxWWgdZ1(expect.vtype))
        {
            if (node.kind == s_Kind_int)
                return solveInt_gDsnGKHT(node.value, expect, ss, _helpers, _here, ctx, module, options);
            else if (node.kind == s_Kind_real)
                return s_Type(solveReal_gDsnGKHT(expect));

        };
        if (node.kind == s_Kind_str)
            return solveString_gDsnGKHT(node.value, expect, ss, _here, ctx, module, options);
        else if (node.kind == s_Kind_if)
        {
            s_Type left = tryRetyping_gDsnGKHT(node.items[1], expect, ss, _helpers, _here, ctx, module, options);
            s_Type right = tryRetyping_gDsnGKHT(node.items[2], expect, ss, _helpers, _here, ctx, module, options);
            if (left && right)
                return type_trySuper_9CJmuVSD(left, right, false, _here, ctx);
            else
            {
                return s_Type{};
            };
        }
        else if ((node.kind == s_Kind_block) || (node.kind == s_Kind_argid))
        {
            const s_HelpersData* BL_11_v;
            if (!s_HelpersMask(((__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_11_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_11_v).mask & s_HelpersMask_HM_LabelUsed)) && node.items)
                return tryRetyping_gDsnGKHT(last_31malqbt(node.items), expect, ss, _helpers, _here, ctx, module, options);
            else
            {
                return s_Type{};
            };
        }
        else
        {
            return s_Type{};
        };
    };
}

static void applyRetype_gDsnGKHT(s_SolvedNode& node, const s_Type& retype, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if ((node.kind == s_Kind_definit) || is_zeroes_9CJmuVSD(node.type.vtype))
        definitWrap_gDsnGKHT(node, retype, ss, _helpers, _here, ctx, module, options);
    else
    {
        if (node.kind == s_Kind_if)
        {
            s_SolvedNode* _0;
            (_0 = &(node.items.mutref(1)), applyRetype_gDsnGKHT(*_0, retype, ss, _helpers, _here, ctx, module, options));
            s_SolvedNode* _1;
            (_1 = &(node.items.mutref(2)), applyRetype_gDsnGKHT(*_1, retype, ss, _helpers, _here, ctx, module, options));
        }
        else if ((node.kind == s_Kind_block) || (node.kind == s_Kind_argid))
        {
            const s_HelpersData* BL_5_v;
            if ((__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_5_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_5_v).mask & s_HelpersMask_HM_LabelUsed)
                BUG_gDsnGKHT("Trying to retype a labelled block, we cant do this still."_fu, ss, _helpers, _here, ctx, module, options);
            else
            {
                s_SolvedNode* _2;
                (_2 = &(last_fjKdEPCD(node.items)), applyRetype_gDsnGKHT(*_2, retype, ss, _helpers, _here, ctx, module, options));
            };
        };
        node.type = retype;
    };
}

                                #ifndef DEF_tryConvert_2QnVRhSKhE6
                                #define DEF_tryConvert_2QnVRhSKhE6
inline static fu::vec<s_Target> tryConvert_2QnVRhSK(const s_Type& expect, const s_Type& actual, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<s_Target> match {};
    const s_ConvCache_ColsAndBakes& cc = exploreConversions_FDl5ha9X(actual.vtype, _current_fn, ss, _helpers, _here, ctx, module, options);
    for (int i = 0; i < cc.columns.types.size(); i++)
    { {
        const s_ValueType& convertType = cc.columns.types[i];
        if (isAssignableAsArgument_9CJmuVSD(expect.vtype, convertType, false, _here, ctx))
        {
            const fu::vec<s_Target>& path = cc.columns.paths[i];
            fu::view<int> ms = cc.columns.must_see[i];
            for (int i_1 = 0; i_1 < ms.size(); i_1++)
            {
                const int ms_1 = ms[i_1];
                const bool isUsing = (ms_1 < 0);
                const int index = ((isUsing ? -ms_1 : +ms_1) - 1);
                fu::view<s_ScopeSkip> skips = (isUsing ? ss._ss.usings : ss._ss.converts);
                fu::view<s_Target> which = (isUsing ? ss._scope.usings : ss._scope.converts);
                if ((index >= 0) && (index < which.size()))
                {
                    for (int i_2 = 0; i_2 < skips.size(); i_2++)
                    {
                        const s_ScopeSkip& skip = skips[i_2];
                        if ((skip.start <= index) && (skip.end > index))
                            goto BL_2;

                    };
                }
                else
                    BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("ConvCache.must_see ms("_fu, fu::i64dec(ms_1)) + ") isUsing("_fu), fu::booldec(isUsing)) + ") index("_fu), fu::i64dec(index)) + ") is out of bounds("_fu), fu::i64dec(which.size())) + ")"_fu), ss, _helpers, _here, ctx, module, options);

            };
            if (match)
            {
                fu::str suffix = ((("\n"_fu + explainConversion_gDsnGKHT(match, fu::view<char>{}, _current_fn, ss, _here, ctx, module, options)) + "\n\tand:\n"_fu) + explainConversion_gDsnGKHT(path, fu::view<char>{}, _current_fn, ss, _here, ctx, module, options));
                if (actual)
                {
                    fail_gDsnGKHT(((((("Conversion ambiguity, multiple ways to convert "_fu + explainType_gDsnGKHT(actual, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " into "_fu) + explainType_gDsnGKHT(expect, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + ":"_fu) + suffix), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    fail_gDsnGKHT(((((qBAD_e44UlzzA("using"_fu) + " ambiguity, multiple ways to obtain a "_fu) + explainType_gDsnGKHT(expect, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " in this scope:"_fu) + suffix), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
                match = (path ? path : BUG_gDsnGKHT("Empty conversion path in cache."_fu, ss, _helpers, _here, ctx, module, options));

        };
      } BL_2:;
    };
    return /*NRVO*/ match;
}
                                #endif

static fu::view<char> explain_wyx7msfr(const s_Type& a, const s_Type& b, fu::view<s_Target> chain, fu::str& bConv, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return (bConv += ((("\n\t"_fu + explainTypeDiff_gDsnGKHT(a, b, " -> "_fu, ss, _here, ctx, module, options)) + ":"_fu) + explainConversion_gDsnGKHT(chain, fu::view<char>{}, _current_fn, ss, _here, ctx, module, options)));
}

static int findRestStart_gDsnGKHT(const s_Extended& ext)
{
    for (int i = ext.args.size(); i-- > 0; )
    {
        const s_Argument& arg = ext.args[i];
        if (arg.flags & s_Flags_F_REST_ARG)
            return i;
        else if (!(arg.flags & s_Flags_F_IMPLICIT))
            break;

    };
    return ext.args.size();
}

static s_Type solveArrlit_itemType_init_gDsnGKHT(const s_Type& head, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Type _0 {};
    return (_0 = clear_refs_9CJmuVSD(s_Type(head))) ? static_cast<s_Type&&>(_0) : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
}

static s_Type superType_gDsnGKHT(fu::view<char> reason, const s_Type& a, const s_Type& b, const s_Target& target, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Type _0 {};
    return (_0 = type_trySuper_9CJmuVSD(a, b, false, _here, ctx)) ? static_cast<s_Type&&>(_0) : fail_gDsnGKHT(((((target ? str_FDl5ha9X(target, false, ss, _here, ctx, module, options) : fu::str{}) + reason) + "No common supertype: "_fu) + explainTypeDiff_gDsnGKHT(a, b, " | "_fu, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static s_Type solveArrlit_itemType_gDsnGKHT(fu::view<s_SolvedNode> items, /*MOV*/ s_Type&& itemType, int start, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!itemType)
    {
        if (start == items.size())
        {
            fail_gDsnGKHT("Cannot infer empty arraylit."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            itemType = solveArrlit_itemType_init_gDsnGKHT(items[start++].type, ss, _helpers, _here, ctx, module, options);

    }
    else if (is_ref_9CJmuVSD(itemType))
    {
        fail_gDsnGKHT("Array items cannot be refs. TODO Why an error? Should this not just clear_refs?"_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    };
    for (int i = start; i < items.size(); i++)
    {
        itemType = superType_gDsnGKHT("Array literal: "_fu, itemType, items[i].type, s_Target{}, ss, _helpers, _here, ctx, module, options);
    };
    return static_cast<s_Type&&>(itemType);
}

static s_Type solveArrlit_done_gDsnGKHT(const s_Type& itemType, const int itemCount, const s_Options& options)
{
    /*MOV*/ s_Type arrayType = createArray_9CJmuVSD(itemType);
    if (!s_DevOptions((options.dev & s_DevOptions_DEV_DontFoldLiterals)))
    {
        if ((itemCount >= 0) && !s_DevOptions((options.dev & s_DevOptions_DEV_DontFoldLiterals)))
            arrayType.vtype.vfacts = (itemCount ? s_VFacts_AlwaysTrue : s_VFacts_AlwaysFalse);

        arrayType.vtype.vfacts |= s_VFacts((s_VFacts_LeftAligned | s_VFacts_RightAligned));
    };
    return /*NRVO*/ arrayType;
}

static s_SolvedNode createArrlit_gDsnGKHT(const fu::vec<s_SolvedNode>& items, const s_Type& itemType, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Type itemType_1 = solveArrlit_itemType_gDsnGKHT(items, s_Type(itemType), 0, ss, _helpers, _here, ctx, module, options);
    return SolvedNode_gDsnGKHT(s_Kind_arrlit, solveArrlit_done_gDsnGKHT(itemType_1, items.size(), options), s_Flags{}, (*(const fu::str*)fu::NIL), items, s_Target{}, s_Helpers{}, _here);
}

static int GET_next_local_index_gDsnGKHT(const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    int BL_1_v {};
    const int globid = (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v);
    if (!globid)
        return 0;
    else if ((globid > 0) && (globid < ss._scope.extended.size()))
    {
        const s_Extended& ext = ss._scope.extended[globid];
        return ext.args_n_locals.size() + (1 - ext.args_neg);
    }
    else
        BUG_u9Gbkniv("GET_next_local_index: bad globid"_fu, _here, ctx);

}

                                #ifndef DEF_remove_CU2cEQmHmJf
                                #define DEF_remove_CU2cEQmHmJf
inline void remove_CU2cEQmH(fu::vec<s_SolvedNode>& a, const int at, const int count)
{
    a.splice(at, count);
}
                                #endif

                                #ifndef DEF_update_50rEtWGGDbh
                                #define DEF_update_50rEtWGGDbh
inline bool update_50rEtWGG(s_Set_aQNJhbMknMf& _, const s_Target& key, fu::vec<s_Target>& values, const s_Target& value)
{
    fu::view<s_Target> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_B3HLYN6f(keys_asc[i], key);
        if (cmp == 0)
        {
            values.mutref(i) = s_Target(value);
            return false;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, s_Target(key));
    values.insert(i, s_Target(value));
    return true;
}
                                #endif

                                #ifndef DEF_set_PvI5nIDTzUi
                                #define DEF_set_PvI5nIDTzUi
inline bool set_PvI5nIDT(s_Map_uccvP8a6Yhg& _, const s_Target& key, const s_Target& value)
{
    return update_50rEtWGG(_.keys, key, _.vals, value);
}
                                #endif

                                #ifndef DEF_Lifetime_static_immoveable
                                #define DEF_Lifetime_static_immoveable
extern const s_Lifetime Lifetime_static_immoveable;
                                #endif

static s_Lifetime Lifetime_fromBinding_gDsnGKHT(const s_Target& target, const int flatCount, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) || (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (!flatCount)
        {
            return s_Lifetime(Lifetime_static_moveable);
        }
        else
        {
            int BL_5_v {};
            const int locid = (__extension__ (
            {
                const unsigned v = unsigned((target._packed & 0xfffffull));
                BL_5_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_5_v);
            if (locid)
            {
                return Lifetime_from_7Yz9ezW2(locid, flatCount, _here, ctx);
            }
            else
            {
                return s_Lifetime(Lifetime_static_immoveable);
            };
        };
    }
    else
        BUG_gDsnGKHT("not from this module"_fu, ss, _helpers, _here, ctx, module, options);

}

static void TEST_LifetimeEqual_gDsnGKHT(const s_Lifetime& a, fu::view<char> aa, const s_Lifetime& b, fu::view<char> bb, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(a == b))
    {
        BUG_gDsnGKHT((x7E_3lDd4lqo((((((x7E_3lDd4lqo((((("visitNode TEST_LifetimeEqual:"_fu + "\n\n\t    "_fu) + aa) + ":\t"_fu) + "("_fu), str_gDsnGKHT(a, false, ss, _here, ctx, module, options)) + ")"_fu) + "\n\n\t    "_fu) + bb) + ":\t"_fu) + "("_fu), str_gDsnGKHT(b, false, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF_get_EdWFVkLWAQ1
                                #define DEF_get_EdWFVkLWAQ1
inline const s_Target& get_EdWFVkLW(const s_Set_aQNJhbMknMf& _, const s_Target& key, fu::view<s_Target> values)
{
    fu::view<s_Target> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_B3HLYN6f(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(const s_Target*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_K8LYAgh477e
                                #define DEF_get_K8LYAgh477e
inline const s_Target& get_K8LYAgh4(const s_Map_uccvP8a6Yhg& _, const s_Target& key)
{
    return get_EdWFVkLW(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_TODO_FIX_pop_08mGYIdwv3b
                                #define DEF_TODO_FIX_pop_08mGYIdwv3b
inline static s_SolvedNode TODO_FIX_pop_08mGYIdw(fu::vec<s_SolvedNode>& arr)
{
    /*MOV*/ s_SolvedNode item {};
    std::swap(item, arr.mutref((arr.size() - 1)));
    arr.pop();
    return /*NRVO*/ item;
}
                                #endif

static fu::str qSTACK_implicit_FDl5ha9X(const s_Target& target, const s_SolvedNode& node, fu::view<char> id, const s_Type& type, fu::view<s_Target> seen, const s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    fu::str candidates = ""_fu;
    fu::vec<s_Target> seen_1 = (seen + target);

    {
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            s_SolvedNode BL_4_v {};
            s_SolvedNode node_3 = (__extension__ (
            {
                const s_SolvedNode& __partcopy_ref = ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
                BL_4_v = (s_SolvedNode { __partcopy_ref.kind, {}, {}, {}, {}, fu::vec<s_SolvedNode>(__partcopy_ref.items), s_TokenIdx(__partcopy_ref.token), {}, s_Target(__partcopy_ref.target) });
            (void)0;}), static_cast<s_SolvedNode&&>(BL_4_v));

            { {
                if (node_3.kind == s_Kind_let)
                {
                    const s_Target& candidate = node_3.target;
                    if (candidate && !(GET_gDsnGKHT(candidate, ss, _here, ctx, module).flags & s_Flags_F_INJECTED) && (GET_gDsnGKHT(candidate, ss, _here, ctx, module).name == id) && isAssignableAsArgument_9CJmuVSD(type.vtype, GET_gDsnGKHT(candidate, ss, _here, ctx, module).type.vtype, false, _here, ctx))
                    {
                        candidates += (x7E_3lDd4lqo("\n        Possible candidate in "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + ": "_fu);
                        if (!(GET_gDsnGKHT(candidate, ss, _here, ctx, module).flags & s_Flags_F_IMPLICIT))
                            candidates += qBAD_e44UlzzA("NOT implicit "_fu);

                        candidates += explainWhichFn_gDsnGKHT(s_Target(candidate), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options);
                    };
                };
                if (!((node_3.kind != s_Kind_call) || isLocal_gDsnGKHT(node_3.target)))
                {
                    if (!(has_AOZqRgIb(seen_1, node_3.target)))
                    {

                        { {
                            fu::view<s_Argument> host_args = EXT_gDsnGKHT(node_3.target, ss, ctx, module).args;
                            for (int i = 0; i < host_args.size(); i++)
                            {
                                const s_Argument& host_arg = host_args[i];
                                if ((host_arg.flags & s_Flags_F_IMPLICIT) && (host_arg.name == id) && isAssignableAsArgument_9CJmuVSD(host_arg.type.vtype, type.vtype, false, _here, ctx))
                                    goto BL_11;

                            };
                            goto BL_5;
                          } BL_11:;
                        };
                        fu::str peek = qSTACK_implicit_FDl5ha9X(s_Target(node_3.target), s_SolvedNode(GET_gDsnGKHT(node_3.target, ss, _here, ctx, module).solved), id, type, seen_1, _current_fn, ss, _here, ctx, module, options);
                        return (((x7E_3lDd4lqo(("\n            "_fu + "because of call to "_fu), str_FDl5ha9X(node_3.target, false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + peek) + candidates;
                    };
                };
              } BL_5:;
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += s_SolvedNode(node_3.items[i]);

        };
    };
    fu::view<s_Argument> host_args = EXT_gDsnGKHT(target, ss, ctx, module).args;
    for (int i = 0; i < host_args.size(); i++)
    {
        const s_Argument& host_arg = host_args[i];
        if ((host_arg.flags & s_Flags_F_IMPLICIT) && (host_arg.name == id) && isAssignableAsArgument_9CJmuVSD(host_arg.type.vtype, type.vtype, false, _here, ctx))
        {
            return ("\n            "_fu + "because of "_fu) + explainWhichFn_gDsnGKHT(s_Target(host_arg.target), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options);
        };
    };
    return ""_fu;
}

static fu::str qSTACK_implicit_gDsnGKHT(const s_Target& becauseOf, const s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target target = parent_gDsnGKHT(becauseOf, _here, ctx);
    return qSTACK_implicit_FDl5ha9X(target, s_SolvedNode(GET_gDsnGKHT(target, ss, _here, ctx, module).solved), fu::str(GET_gDsnGKHT(becauseOf, ss, _here, ctx, module).name), s_Type(GET_gDsnGKHT(becauseOf, ss, _here, ctx, module).type), fu::view<s_Target>{}, _current_fn, ss, _here, ctx, module, options);
}

static s_Type intersectionType_gDsnGKHT(fu::view<char> reason, const s_Type& a, const s_Type& b, const fu::str& id, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Type _0 {};
    return (_0 = type_tryIntersect_9CJmuVSD(a, b, _here, ctx)) ? static_cast<s_Type&&>(_0) : fail_gDsnGKHT(((((id ? (qID_e44UlzzA(id) + ": "_fu) : fu::str{}) + reason) + "Cannot intersect types: "_fu) + explainTypeDiff_gDsnGKHT(a, b, " & "_fu, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_q_rx_resize
                                #define DEF_q_rx_resize
extern const unsigned q_rx_resize;
                                #endif

                                #ifndef DEF_str_WkH36txjVGe
                                #define DEF_str_WkH36txjVGe
inline fu::str str_WkH36txj(const s_Flags n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & s_Flags_F_CALL_HAS_DOT)
            res += ("F_CALL_HAS_DOT"_fu + ", "_fu);

        if (n & s_Flags_F_CALL_HAS_ARGPARENS)
            res += ("F_CALL_HAS_ARGPARENS"_fu + ", "_fu);

        if (n & s_Flags_F_CALL_HAS_NAMED_ARGS)
            res += ("F_CALL_HAS_NAMED_ARGS"_fu + ", "_fu);

        if (n & s_Flags_F_OPERATOR)
            res += ("F_OPERATOR"_fu + ", "_fu);

        if (n & s_Flags_F_TYPENAME)
            res += ("F_TYPENAME"_fu + ", "_fu);

        if (n & s_Flags_F_COMPOUND_ID)
            res += ("F_COMPOUND_ID"_fu + ", "_fu);

        if (n & s_Flags_F_ARGID_IS_OPTIONAL)
            res += ("F_ARGID_IS_OPTIONAL"_fu + ", "_fu);

        if (n & s_Flags_F_LAX)
            res += ("F_LAX"_fu + ", "_fu);

        if (n & s_Flags_F_SHADOW)
            res += ("F_SHADOW"_fu + ", "_fu);

        if (n & s_Flags_F_MUSTNAME)
            res += ("F_MUSTNAME"_fu + ", "_fu);

        if (n & s_Flags_F_MUT)
            res += ("F_MUT"_fu + ", "_fu);

        if (n & s_Flags_F_CONST)
            res += ("F_CONST"_fu + ", "_fu);

        if (n & s_Flags_F_VAL)
            res += ("F_VAL"_fu + ", "_fu);

        if (n & s_Flags_F_REF)
            res += ("F_REF"_fu + ", "_fu);

        if (n & s_Flags_F_IMPLICIT)
            res += ("F_IMPLICIT"_fu + ", "_fu);

        if (n & s_Flags_F_USING)
            res += ("F_USING"_fu + ", "_fu);

        if (n & s_Flags_F_CONVERSION)
            res += ("F_CONVERSION"_fu + ", "_fu);

        if (n & s_Flags_F_TEST_painted)
            res += ("F_TEST_painted"_fu + ", "_fu);

        if (n & s_Flags_F_PUB)
            res += ("F_PUB"_fu + ", "_fu);

        if (n & s_Flags_F_EXTERN)
            res += ("F_EXTERN"_fu + ", "_fu);

        if (n & s_Flags_F_HOTSWAP)
            res += ("F_HOTSWAP"_fu + ", "_fu);

        if (n & s_Flags_F_PREDICATE)
            res += ("F_PREDICATE"_fu + ", "_fu);

        if (n & s_Flags_F_LT_RETURNED)
            res += ("F_LT_RETURNED"_fu + ", "_fu);

        if (n & s_Flags_F_REST_ARG)
            res += ("F_REST_ARG"_fu + ", "_fu);

        if (n & s_Flags_F_INJECTED)
            res += ("F_INJECTED"_fu + ", "_fu);

        if (n & s_Flags_F_TEMPLATE)
            res += ("F_TEMPLATE"_fu + ", "_fu);

        if (n & s_Flags_F_INLINE)
            res += ("F_INLINE"_fu + ", "_fu);

        if (n & s_Flags_F_LAMBDA)
            res += ("F_LAMBDA"_fu + ", "_fu);

        if (n & s_Flags_F_COW_INSIDE)
            res += ("F_COW_INSIDE"_fu + ", "_fu);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

static fu::str makeItLaxIfIntentional_gDsnGKHT()
{
    return (" Make it "_fu + qKW_e44UlzzA("lax"_fu)) + " if this is intentional."_fu;
}

static s_Target Binding_gDsnGKHT(const fu::str& id, /*MOV*/ s_Type&& type, const s_Flags flags, const s_DeclAsserts asserts, bool& shadows, const bool asArgument, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const fu::str& name = id;
    int BL_1_v {};
    const int local_of = (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v);
    if (ss._root_scope)
        autoshadow_gDsnGKHT(shadows, local_of, id, _current_fn, ss);

    const s_SolverStatus status = ((type.vtype.quals & q_rx_resize) ? s_SolverStatus_SS_TODO_FIX_was_rx_resize : s_SolverStatus{});
    const s_Target target = Scope_create_z0QqoZ5t(ss._scope, s_Kind_var, name, (*(const s_Type*)fu::NIL), flags, asserts, status, local_of, asArgument, module);
    if (flags & s_Flags_F_REF)
    {
        if (is_ref_9CJmuVSD(type))
        {
            if (!(!(flags & s_Flags_F_MUT) || is_mutref_9CJmuVSD(type, _here, ctx)))
                BUG_gDsnGKHT(((((x7E_3lDd4lqo("Binding("_fu, str_WkH36txj(flags)) + " "_fu) + name) + ") !type.is_mutref:\n\n\t\t"_fu) + explainType_gDsnGKHT(type, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        }
        else
            BUG_gDsnGKHT(((((x7E_3lDd4lqo("Binding("_fu, str_WkH36txj(flags)) + " "_fu) + name) + ") !type.is_ref:\n\n\t\t"_fu) + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
    s_Overload& overload = GET_mut_gDsnGKHT(target, ss, module);

    {
        s_Lifetime lifetime = Lifetime_fromBinding_gDsnGKHT(target, getFlatCount_1qjplDUo(type.vtype, _here, ctx, module), ss, _helpers, _here, ctx, module, options);
        type.lifetime = s_Lifetime{};
        overload.type = ((flags & s_Flags_F_MUT) ? add_mutref_9CJmuVSD(static_cast<s_Type&&>(type), lifetime, _here, ctx) : add_ref_9CJmuVSD(static_cast<s_Type&&>(type), lifetime, _here, ctx));
        if (is_zeroes_9CJmuVSD(overload.type.vtype) && (~flags & s_Flags_F_LAX) && ((flags & ((s_Flags_F_TEMPLATE | s_Flags_F_REF) | s_Flags_F_MUT)) != s_Flags_F_TEMPLATE))
        {
            fail_gDsnGKHT((((x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " needs a tighter type annotation, inferred type is "_fu) + explainTypeName_gDsnGKHT(overload.type, false, _here, ctx, module, options)) + "."_fu) + makeItLaxIfIntentional_gDsnGKHT()), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    };
    return target;
}

static const s_SolvedNode& solved_set_FDl5ha9X(const s_Target& target, const s_SolvedNode& node, s_SolverState& ss, const s_Module& module)
{
    return (GET_mut_gDsnGKHT(target, ss, module).solved = s_SolvedNode(node));
}

static s_Target createLet_implicitArg_gDsnGKHT(const fu::str& id, const s_Type& type, const s_Flags flags, bool& shadows, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target target = Binding_gDsnGKHT(id, s_Type(type), flags, _current_fn.asserts, shadows, true, _current_fn, ss, _helpers, _here, ctx, module, options);
    s_SolvedNode ret = SolvedNode_gDsnGKHT(s_Kind_let, GET_gDsnGKHT(target, ss, _here, ctx, module).type, flags, GET_gDsnGKHT(target, ss, _here, ctx, module).name, (*(const fu::vec<s_SolvedNode>*)fu::NIL), target, s_Helpers{}, _here);
    solved_set_FDl5ha9X(target, ret, ss, module);
    return target;
}

static s_SolvedNode createLetDef_gDsnGKHT(const s_Target& target, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    return SolvedNode_gDsnGKHT(s_Kind_letdef, GET_gDsnGKHT(target, ss, _here, ctx, module).type, s_Flags{}, (*(const fu::str*)fu::NIL), (*(const fu::vec<s_SolvedNode>*)fu::NIL), target, s_Helpers{}, _here);
}

static s_Target injectImplicitArg_gDsnGKHT(const fu::str& id, const s_Type& type, const s_Target& becauseOf, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!_current_fn.out.items || (_current_fn.out.flags & s_Flags_F_EXTERN))
    {
        fu::str _0 {};
        fu::str _1 {};
        (_1 = (_0 = (x7E_3lDd4lqo((((("No implicit "_fu + qBAD_e44UlzzA(human_gDsnGKHT(id, ss, _here, ctx, module, options))) + ": "_fu) + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " in scope, needed to call "_fu), str_FDl5ha9X(parent_gDsnGKHT(becauseOf, _here, ctx), false, ss, _here, ctx, module, options)) + ":\n"_fu), (static_cast<fu::str&&>(_0) + qSTACK_implicit_gDsnGKHT(becauseOf, _current_fn, ss, _here, ctx, module, options))), fail_gDsnGKHT(static_cast<fu::str&&>(_1), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
    }
    else
    {
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            s_SolvedNode& arg = _current_fn.out.items.mutref(i);
            const s_Target& target = arg.target;
            s_SolvedNode& arg_1 = ((arg.kind == s_Kind_letdef) ? GET_mut_gDsnGKHT(target, ss, module).solved : arg);
            if ((arg_1.flags & s_Flags_F_IMPLICIT) && (arg_1.value == id))
            {
                if (arg_1.type == GET_gDsnGKHT(target, ss, _here, ctx, module).type)
                {
                    /*MOV*/ s_Type super = intersectionType_gDsnGKHT("Implicit argument collision: "_fu, add_ref_9CJmuVSD(s_Type(type), arg_1.type.lifetime, _here, ctx), arg_1.type, id, ss, _helpers, _here, ctx, module, options);
                    arg_1.type = super;
                    GET_mut_gDsnGKHT(target, ss, module).type = static_cast<s_Type&&>(super);
                    return (target ? target : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                }
                else
                {
                    BUG_gDsnGKHT(("injectImplicitArg: arg.type != target.type:\n\n\t    "_fu + explainTypeDiff_gDsnGKHT(arg_1.type, GET_gDsnGKHT(target, ss, _here, ctx, module).type, " != "_fu, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                };
            };
        };
        bool shadows {};
        const s_Flags flags = (((s_Flags_F_INJECTED | s_Flags_F_IMPLICIT) | s_Flags_F_LAX) | s_Flags_F_REF);
        const s_Target newArgTarget = createLet_implicitArg_gDsnGKHT(id, type, flags, shadows, _current_fn, ss, _helpers, _here, ctx, module, options);
        const int newArgIdx = (_current_fn.out.items.size() + FN_ARGS_BACK);
        /*MOV*/ s_SolvedNode newLetDef = createLetDef_gDsnGKHT(newArgTarget, ss, _here, ctx, module);
        _current_fn.out.items.insert(newArgIdx, static_cast<s_SolvedNode&&>(newLetDef));
        return newArgTarget;
    };
}

                                #ifndef DEF___1YGzaHGr2D1
                                #define DEF___1YGzaHGr2D1
[[noreturn]] inline static fu::never _1YGzaHGr(fu::view<char> reason, const s_Target& becauseOf, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::str _0 {};
    fu::str _1 {};
    (_1 = (_0 = (x7E_3lDd4lqo((reason + "\n\n\tNeeded to call "_fu), str_FDl5ha9X(parent_gDsnGKHT(becauseOf, _here, ctx), false, ss, _here, ctx, module, options)) + ":\n"_fu), (static_cast<fu::str&&>(_0) + qSTACK_implicit_gDsnGKHT(becauseOf, _current_fn, ss, _here, ctx, module, options))), fail_gDsnGKHT(static_cast<fu::str&&>(_1), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
}
                                #endif

static s_SolvedNode bindImplicitArg_gDsnGKHT(const fu::str& name, const s_Type& type, const s_Target& becauseOf, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_ClosureID cid = tryParseClosureID_UvH3gYAB(name, _here, ctx);
    if (cid && (parent_gDsnGKHT(cid.target, _here, ctx) == _current_fn.out.target))
    {
        if (cid.revision == EPH_gDsnGKHT(_current_fn.out.target, ss, module).revision)
        {
            if (GET_gDsnGKHT(cid.target, ss, _here, ctx, module).kind == s_Kind_var)
            {
                return CallerNode_gDsnGKHT("__closure"_fu, s_Target(cid.target), fu::vec<s_SolvedNode>{}, (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            }
            else
                BUG_gDsnGKHT(x7E_3lDd4lqo("ClosureID.target is not a var: "_fu, str_FDl5ha9X(cid.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        }
        else
            BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("ClosureID.revision mismatch: "_fu, str_FDl5ha9X(cid.target, false, ss, _here, ctx, module, options)) + "\n\tCaptured at: "_fu), fu::u64dec(cid.revision)) + "\n\tCurrent rev: "_fu), fu::u64dec(EPH_gDsnGKHT(_current_fn.out.target, ss, module).revision)), ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        fu::str error {};
        s_Reorder reorder {};
        fu::vec<fu::vec<s_Target>> conversions {};
        s_Target _0 {};
        const s_Target target = ((_0 = (!cid ? tryMatchCall_gDsnGKHT(fu::str(name), reorder, conversions, error, true, (*(const s_Scope*)fu::NIL), fu::view<s_SolvedNode>{}, s_Flags_F_IMPLICIT, fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options) : s_Target{})) ? _0 : (_0 = injectImplicitArg_gDsnGKHT(name, type, becauseOf, _current_fn, ss, _helpers, _here, ctx, module, options)) ? _0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        /*MOV*/ s_SolvedNode call = CallerNode_gDsnGKHT("__implicit"_fu, s_Target(target), fu::vec<s_SolvedNode>{}, reorder, conversions, _current_fn, ss, _helpers, _here, ctx, module, options);

        {
            const s_Type& guest = call.type;
            const bool asArgument = true;
            if (!(isAssignable_9CJmuVSD(type, guest, false, asArgument, _here, ctx)))
            {
                _1YGzaHGr((((fu::str{} + x7E_3lDd4lqo(str_FDl5ha9X(becauseOf, false, ss, _here, ctx, module, options), " type mismatch"_fu)) + ": "_fu) + explainNotAssignable_gDsnGKHT(type, guest, _current_fn, ss, _here, ctx, module, options)), becauseOf, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        return /*NRVO*/ call;
    };
}

static bool tryConvertIfNeeded_gDsnGKHT(s_SolvedNode& actual, const s_Type& expect, const bool asArgument, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (!isAssignable_9CJmuVSD(expect, actual.type, false, asArgument, _here, ctx))
    {
        fu::vec<s_Target> conv = tryConvert_2QnVRhSK(expect, actual.type, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (!conv)
            return false;
        else
            applyConversion_gDsnGKHT(actual, conv, _current_fn, ss, _helpers, _here, ctx, module, options);

    };
    if (is_zeroes_9CJmuVSD(actual.type.vtype) && !is_zeroes_9CJmuVSD(expect.vtype))
        definitWrap_gDsnGKHT(actual, expect, ss, _helpers, _here, ctx, module, options);

    return true;
}

static void convertIfNeeded_gDsnGKHT(s_SolvedNode& actual, const s_Type& expect, fu::view<char> err, const bool asArgument, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (!tryConvertIfNeeded_gDsnGKHT(actual, expect, asArgument, _current_fn, ss, _helpers, _here, ctx, module, options))
    {
        fail_gDsnGKHT((err + explainNotAssignable_gDsnGKHT(expect, actual.type, _current_fn, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    };
}

static s_SolvedNode createLetLike_dontTouchScope_gDsnGKHT(const fu::str& id, s_Flags flags, /*MOV*/ s_SolvedNode&& init, const bool asArgument, const s_Type& annot, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (annot || init.type)
    {
        s_Type BL_2_v {};
        /*MOV*/ s_Type t_init = (init ? (__extension__ (
        {
            const bool init_isNever = is_never_9CJmuVSD(init.type.vtype);
            fu::never BL_3_v {};
            s_Type BL_7_v {};
            BL_2_v = (((init_isNever && !(asArgument || (flags & s_Flags_F_INLINE))) ? (__extension__ (
            {

                {
                    const s_SolverNotes note = s_SolverNotes_N_DeadLet;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        ss._notes |= note;

                };
                return static_cast<s_SolvedNode&&>(init);
            (void)0;}), static_cast<fu::never&&>(BL_3_v)) : (__extension__ (
            {
                if (annot && init.type && !init_isNever)
                    convertIfNeeded_gDsnGKHT(init, annot, "Type annotation does not match initializer: "_fu, asArgument, _current_fn, ss, _helpers, _here, ctx, module, options);

                if (flags & s_Flags_F_REF)
                {
                    if (is_ref_9CJmuVSD(init.type))
                    {
                        if (flags & s_Flags_F_MUT)
                        {
                            if (!(is_mutref_9CJmuVSD(init.type, _here, ctx)))
                            {
                                fail_gDsnGKHT(((("Init expression is not a "_fu + qBAD_e44UlzzA("mut"_fu)) + " ref: "_fu) + explainType_gDsnGKHT(init.type, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            };
                        };
                    }
                    else
                    {
                        fail_gDsnGKHT(((("Init expression is not a "_fu + qBAD_e44UlzzA("ref"_fu)) + ": "_fu) + explainType_gDsnGKHT(init.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    };
                };
                /*MOV*/ s_Type t_init_1 = clear_Typename_9CJmuVSD(s_Type(init.type), false);
                if (asArgument)
                {
                    t_init_1.vtype.vfacts = s_VFacts{};
                }
                else if (flags & s_Flags_F_MUT)
                    t_init_1.vtype.vfacts &= s_VFacts((s_VFacts_LeftAligned | s_VFacts_RightAligned));

                BL_7_v = ((hasTemporary_7Yz9ezW2(t_init_1.lifetime) ? clear_refs_9CJmuVSD(static_cast<s_Type&&>(t_init_1)) : static_cast<s_Type&&>(t_init_1)));
            (void)0;}), static_cast<s_Type&&>(BL_7_v))));
        (void)0;}), static_cast<s_Type&&>(BL_2_v)) : s_Type{});
        if (is_mutref_9CJmuVSD(annot, _here, ctx))
            flags |= s_Flags_F_REF;

        s_Type t_let = ((annot && (asArgument || !t_init)) ? s_Type(annot) : ((is_mutref_9CJmuVSD(t_init, _here, ctx) && ((flags & (s_Flags_F_REF | s_Flags_F_CONST)) != s_Flags_F_REF)) ? clear_mutref_9CJmuVSD(static_cast<s_Type&&>(t_init)) : static_cast<s_Type&&>(t_init)));
        if (asArgument)
        {
            t_let.lifetime = Lifetime_temporary;
        }
        else if (!init && is_sliceable_hxWWgdZ1(t_let.vtype))
            t_let.vtype.vfacts |= s_VFacts((s_VFacts_LeftAligned | s_VFacts_RightAligned));

        unsigned BL_20_v {};
        if (is_Typename_9CJmuVSD(t_let))
            BUG_gDsnGKHT("solveLetLike_dontTouchScope: Ended up with a Typename"_fu, ss, _helpers, _here, ctx, module, options);
        else if ((asArgument || (flags & s_Flags_F_MUT)) && s_VFacts((t_let.vtype.vfacts & s_VFacts((s_VFacts_AlwaysTrue | s_VFacts_AlwaysFalse)))) && (__extension__ (
        {
            const s_ValueType& type = t_let.vtype;
            BL_20_v = ((type.quals & q_USAGE));
        (void)0;}), BL_20_v))
            BUG_gDsnGKHT("solveLetLike_dontTouchScope: Ended up with an AlwaysTrue/False"_fu, ss, _helpers, _here, ctx, module, options);

        return SolvedNode_gDsnGKHT(s_Kind_let, t_let, flags, id, fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode{}, static_cast<s_SolvedNode&&>(init) } }, s_Target{}, s_Helpers{}, _here);
    }
    else
    {
        fail_gDsnGKHT((("Variable declarations without type annotations must be initialized: "_fu + qBAD_e44UlzzA(id)) + "."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF___qStw82LcgTb
                                #define DEF___qStw82LcgTb
inline static void _qStw82Lc(const s_Target& target, const fu::str& id, const bool shadows, s_SolverState& ss)
{
    Scope_set_FjkYY9fz(ss._scope.items, id, target, shadows);
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_EWrzafGHR51
                                #define DEF_unpackAddrOfFn_EWrzafGHR51
inline void unpackAddrOfFn_EWrzafGH(fu::view<char> canon, const fu::str& id, const bool shadows, s_SolverState& ss)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const s_Target mi = parseLocalOrGlobal_xQNS19Zn(canon, offset);
            int BL_4_v {};
            _qStw82Lc(Target_xQNS19Zn(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (__extension__ (
            {
                const unsigned v = unsigned((mi._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v)), id, shadows, ss);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_fu + canon) + "`."_fu));

}
                                #endif

static void Scope_set_gDsnGKHT(const s_Target& target, const s_SolvedNode& out, const bool setScope, const bool shadows, const fu::str& id, s_SolverState& ss)
{
    if (!(!setScope))
    {
        Scope_set_z0QqoZ5t(ss._scope, id, target, shadows);
        if (out.flags & s_Flags_F_IMPLICIT)
            Scope_set_FjkYY9fz(ss._scope.implicits, id, target, shadows);

        if (out.flags & s_Flags_F_USING)
        {
            ss._scope.usings.push(s_Target(target));
            remove_qacjtO9I(ss._conv_cache, s_ValueType{});
        };
    };
}

static s_SolvedNode solveLet_createBindingAndGetLetdef_gDsnGKHT(/*MOV*/ s_SolvedNode&& out, const fu::str& id, const bool setScope, const bool isArg, const s_DeclAsserts asserts, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (out.kind != s_Kind_let)
    {
        if (is_never_9CJmuVSD(out.type.vtype))
            return static_cast<s_SolvedNode&&>(out);
        else
            BUG_gDsnGKHT((((x7E_3lDd4lqo("solveLet: results in a `"_fu, str_WkqQ7QhO(out.kind)) + ": "_fu) + id) + "`."_fu), ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        bool shadows = !!(out.flags & s_Flags_F_SHADOW);
        fu::str id_1 = ((out.flags & s_Flags_F_COMPOUND_ID) ? cleanID_V5IuMsej(id) : fu::str(id));
        if (isAddrOfFn_9CJmuVSD(out.type))
        {
            const bool shadows_1 = true;
            if (setScope)
                unpackAddrOfFn_EWrzafGH(out.type.vtype.canon, id_1, shadows_1, ss);

        }
        else
        {
            if (!isArg && !(out.flags & (s_Flags_F_PUB | s_Flags_F_VAL)))
            {
                const s_SolvedNode& init = out.items[LET_INIT];
                if ((init.kind == s_Kind_call) && !init.items)
                {
                    const s_Target& target = init.target;
                    const s_Overload& other = GET_gDsnGKHT(target, ss, _here, ctx, module);
                    if ((other.kind == s_Kind_var) && !(other.flags & s_Flags_F_INLINE) && (s_DeclAsserts((other.asserts & asserts)) == asserts))
                    {
                        if (isAssignable_9CJmuVSD(other.type, out.type, false, false, _here, ctx))
                        {
                            Scope_set_gDsnGKHT(target, out, setScope, shadows, id_1, ss);
                            out = createEmpty_gDsnGKHT(t_void, target, ss, _helpers, _here, ctx, module, options);
                            return static_cast<s_SolvedNode&&>(out);
                        };
                    };
                };
            };
            const s_DeclAsserts refArgAsserts = ((isArg && !(out.flags & s_Flags_F_VAL)) ? _current_fn.asserts : s_DeclAsserts{});
            const s_Target& target = (out.target = Binding_gDsnGKHT(id_1, s_Type(out.type), out.flags, s_DeclAsserts((asserts | refArgAsserts)), shadows, isArg, _current_fn, ss, _helpers, _here, ctx, module, options));
            if (!hasTemporary_7Yz9ezW2(out.type.lifetime) || isArg)
            {
                if (is_Typename_9CJmuVSD(out.type))
                    BUG_gDsnGKHT("solveLet_createBindingAndGetLetdef: Ended up with a Typename"_fu, ss, _helpers, _here, ctx, module, options);

            }
            else
            {
                BUG_gDsnGKHT("solveLet_createBindingAndGetLetdef: Non-argument lifetime.hasTemporary"_fu, ss, _helpers, _here, ctx, module, options);
            };
            solved_set_FDl5ha9X(target, out, ss, module);
            Scope_set_gDsnGKHT(target, out, setScope, shadows, id_1, ss);
            return createLetDef_gDsnGKHT(target, ss, _here, ctx, module);
        };
        if (isArg)
        {
            if (isAddrOfFn_9CJmuVSD(out.type))
                out.type = clear_refs_9CJmuVSD(s_Type(out.type));

            return static_cast<s_SolvedNode&&>(out);
        }
        else
        {
            return createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static s_SolvedNode createLet_gDsnGKHT(const fu::str& id, const s_Flags flags, const s_DeclAsserts asserts, const s_SolvedNode& init, const bool setScope, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode out = createLetLike_dontTouchScope_gDsnGKHT(id, flags, s_SolvedNode(init), false, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
    return solveLet_createBindingAndGetLetdef_gDsnGKHT(static_cast<s_SolvedNode&&>(out), id, setScope, false, asserts, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static s_Target injectForeignLocal_gDsnGKHT(const s_Target& target, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (GET_gDsnGKHT(target, ss, _here, ctx, module).kind == s_Kind_var)
    {
        const s_ClosureID noClID = tryParseClosureID_UvH3gYAB(GET_gDsnGKHT(target, ss, _here, ctx, module).name, _here, ctx);
        if (noClID)
            BUG_gDsnGKHT(x7E_3lDd4lqo("injectForeignLocal: Unexpected closure-id: "_fu, str_FDl5ha9X(noClID.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("injectForeignLocal: trying to inject a non-var: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    if (GET_gDsnGKHT(target, ss, _here, ctx, module).flags & s_Flags_F_IMPLICIT)
        return injectImplicitArg_gDsnGKHT(fu::str(GET_gDsnGKHT(target, ss, _here, ctx, module).name), s_Type(GET_gDsnGKHT(target, ss, _here, ctx, module).type), target, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
    {
        unsigned _0 {};
        const s_ClosureID clID = s_ClosureID { s_Target(target), ((_0 = EPH_gDsnGKHT(parent_gDsnGKHT(target, _here, ctx), ss, module).revision) ? _0 : BUG_gDsnGKHT(x7E_3lDd4lqo("injectForeignLocal: About to serialize at rev 0: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options)) };
        return injectImplicitArg_gDsnGKHT(serialize_UvH3gYAB(clID, _here, ctx), s_Type(GET_gDsnGKHT(target, ss, _here, ctx, module).type), target, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}

static s_Target matchReplicaOrInjectForeignLocal_gDsnGKHT(const s_Target& target, const s_Type& slot, const s_Target& from, fu::view_mut<s_SolvedNode> callsite_args, const s_Map_uccvP8a6Yhg& letdefReplicas, const int minLocalIdx, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Target& replica = get_K8LYAgh4(letdefReplicas, target);
    if (replica)
        return replica;
    else
    {
        const s_Target parent = parent_gDsnGKHT(target, _here, ctx);
        if (parent == _current_fn.out.target)
        {
            int BL_4_v {};
            if ((__extension__ (
            {
                const unsigned v = unsigned((target._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v) < minLocalIdx)
                return target;
            else
                BUG_gDsnGKHT(x7E_3lDd4lqo("Missing a local replica for: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        }
        else
        {
            const s_Overload& o = GET_gDsnGKHT(target, ss, _here, ctx, module);
            if (o.flags & s_Flags_F_IMPLICIT)
                return bindImplicitArg_gDsnGKHT(fu::str(o.name), s_Type((slot ? slot : o.type)), target, _current_fn, ss, _helpers, _here, ctx, module, options).target;
            else if (int(unsigned(((from._packed >> 40ull) & 0xfffffull))) != module.modid)
                BUG_gDsnGKHT(x7E_3lDd4lqo("inlineExpression: about to use injectForeignLocal with an off-module target: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            else
            {
                if ((parent == from) && callsite_args)
                { {
                    int BL_12_v {};
                    if ((__extension__ (
                    {
                        const unsigned v = unsigned((target._packed & 0xfffffull));
                        BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                    (void)0;}), BL_12_v) < 0)
                    {
                        fu::view<s_Argument> a = EXT_gDsnGKHT(parent, ss, ctx, module).args;
                        for (int i = 0; i < a.size(); i++)
                        {
                            const s_Argument& host_arg = a[i];
                            const int i_1 = i;
                            if (host_arg.target == target)
                            {
                                if (callsite_args.size() < i_1)
                                    goto BL_11;
                                else
                                {
                                    s_SolvedNode& arg = callsite_args.mutref(i_1);
                                    const s_Target& replacement = ((((arg.kind == s_Kind_call) && (GET_gDsnGKHT(arg.target, ss, _here, ctx, module).kind == s_Kind_var)) || (arg.kind == s_Kind_letdef)) ? arg.target : (arg = createLet_gDsnGKHT("__def_arg_ref"_fu, s_Flags{}, s_DeclAsserts{}, arg, false, _current_fn, ss, _helpers, _here, ctx, module, options)).target);
                                    return replacement;
                                };
                            };
                        };
                    }
                    else
                        BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("inlineExpression callsite_args("_fu, fu::i64dec(callsite_args.size())) + ") observing a non-F_ARG local("_fu), str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + ") from("_fu), str_FDl5ha9X(from, false, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                  } BL_11:;
                };
                return injectForeignLocal_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    };
}

static s_Flags isInlineLocal_gDsnGKHT(const s_Target& t, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    int BL_1_v {};
    if (!((__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) < 0))
        return GET_gDsnGKHT(t, ss, _here, ctx, module).flags & s_Flags_F_INLINE;
    else
    {
        return s_Flags{};
    };
}

static const s_Type& Lifetime_climbType_gDsnGKHT(const s_Target& t, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) < 0)
        return (*(const s_Type*)fu::NIL);
    else
    {
        const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
        if (o.kind == s_Kind_var)
        {
            const s_SolvedNode& node = o.solved;
            if (is_ref_9CJmuVSD(node.type))
                return node.items[LET_INIT].type;
            else
                return (*(const s_Type*)fu::NIL);

        }
        else
        {
            BUG_gDsnGKHT("Lifetime_climbType: not a var"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static bool Lifetime_allowsMutrefReturn_gDsnGKHT(const s_Lifetime& lifetime, const int locals_start, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    { {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            if (!(!locid))
            {
                if (locid < locals_start)
                    goto BL_1;
                else
                {
                    const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
                    const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
                    if ((o.kind == s_Kind_var) && is_mutref_9CJmuVSD(o.type, _here, ctx))
                    {
                        if (!(o.flags & s_Flags_F_REF))
                            return false;
                        else
                        {
                            const s_Type& init = Lifetime_climbType_gDsnGKHT(t, ss, _helpers, _here, ctx, module, options);
                            if (!Lifetime_allowsMutrefReturn_gDsnGKHT(init.lifetime, locals_start, ss, _helpers, _here, ctx, module, options))
                                return false;

                        };
                    }
                    else
                    {
                        BUG_gDsnGKHT(x7E_3lDd4lqo("Lifetime_allowsMutrefReturn: found non-mutref: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                    };
                };
            };
        };
      } BL_1:;
    };
    return true;
}

static s_Type superType_neverOK_gDsnGKHT(fu::view<char> reason, const s_Type& a, const s_Type& b, const s_Target& target, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (is_never_9CJmuVSD(a.vtype))
        return s_Type(b);
    else if (is_never_9CJmuVSD(b.vtype))
        return s_Type(a);
    else
        return superType_gDsnGKHT(reason, a, b, target, ss, _helpers, _here, ctx, module, options);

}

static void reportReturnType_gDsnGKHT(const s_Helpers& h, const s_Type& type, const bool NICEERR_missingReturn, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Type type_1 = ((is_mutref_9CJmuVSD(type, _here, ctx) && !Lifetime_allowsMutrefReturn_gDsnGKHT(type.lifetime, (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).locals_start, ss, _helpers, _here, ctx, module, options)) ? clear_mutref_9CJmuVSD(s_Type(type)) : s_Type(type));
    /*MOV*/ s_Type type_2 = (hasTemporary_7Yz9ezW2(type_1.lifetime) ? clear_refs_9CJmuVSD(static_cast<s_Type&&>(type_1)) : static_cast<s_Type&&>(type_1));
    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect)
    {
        const s_Type& host = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect;
        const bool asArgument = false;
        if (!(isAssignable_9CJmuVSD(host, type_2, false, asArgument, _here, ctx)))
        {
            fail_gDsnGKHT((((fu::str{} + (NICEERR_missingReturn ? x7E_3lDd4lqo(str_FDl5ha9X((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, false, ss, _here, ctx, module, options), " is missing a final return statement"_fu) : (s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Function)) ? x7E_3lDd4lqo(str_FDl5ha9X((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, false, ss, _here, ctx, module, options), ": return type does not match annotation"_fu) : "Bad jump expression"_fu))) + ": "_fu) + explainNotAssignable_gDsnGKHT(host, type_2, _current_fn, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    };
    (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual = ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual ? superType_neverOK_gDsnGKHT((NICEERR_missingReturn ? " is missing a final return statement: "_fu : "Subsequent return: "_fu), (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual, type_2, (NICEERR_missingReturn ? (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target : (*(const s_Target*)fu::NIL)), ss, _helpers, _here, ctx, module, options) : static_cast<s_Type&&>(type_2));
    if (!((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual))
        BUG_gDsnGKHT("reportReturnType: no ret_actual."_fu, ss, _helpers, _here, ctx, module, options);

}

static s_SolvedNode createJump_gDsnGKHT(const s_Helpers& h, const s_SolvedNode& expr, const s_TokenIdx& _here)
{
    return SolvedNode_gDsnGKHT(s_Kind_jump, t_never, s_Flags{}, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(expr) } }, s_Target{}, h, _here);
}

static s_SolvedNode solveJump_finish_gDsnGKHT(const s_Flags flags, const s_SolvedNode& expr, const s_Helpers& h, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask |= s_HelpersMask_HM_LabelUsed;
    reportReturnType_gDsnGKHT(h, expr.type, !!(flags & s_Flags_F_IMPLICIT), _current_fn, ss, _helpers, _here, ctx, module, options);
    return createJump_gDsnGKHT(h, expr, _here);
}

                                #ifndef DEF_add_8Ex4HrqlBhg
                                #define DEF_add_8Ex4HrqlBhg
inline bool add_8Ex4Hrql(s_Set_95BJOojOc45& _, const int key)
{
    fu::view<int> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_XrkW2YUZ(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, key);
    return true;
}
                                #endif

static void visit_wyx7msfr(const s_Lifetime& lifetime, s_Lifetime& result, bool& maybeOutOfOrder, const s_Target& from, fu::view_mut<s_SolvedNode> callsite_args, const s_Map_uccvP8a6Yhg& letdefReplicas, const int minLocalIdx, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit(chars, offset);
            int BL_4_v {};
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
            (void)0;}), BL_4_v);
            int BL_12_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_12_v));
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!(!locid))
            {
                const s_Target foreign = nested_gDsnGKHT(locid, from, _here, ctx);
                const s_Target local = matchReplicaOrInjectForeignLocal_gDsnGKHT(foreign, (*(const s_Type*)fu::NIL), from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
                s_Lifetime replacement = (GET_gDsnGKHT(local, ss, _here, ctx, module).type.lifetime ? Lifetime_op_join_7Yz9ezW2(GET_gDsnGKHT(local, ss, _here, ctx, module).type.lifetime, paths, _here, ctx) : BUG_gDsnGKHT("visitType: !local.type.lifetime"_fu, ss, _helpers, _here, ctx, module, options));
                maybeOutOfOrder = true;
                Lifetime_add_7Yz9ezW2(result, replacement, false, _here, ctx);
                continue;
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_2PuIGhxS2si
                                #define DEF_Lifetime_process_2PuIGhxS2si
inline s_Lifetime Lifetime_process_2PuIGhxS(const s_Lifetime& lifetime, const s_Target& from, fu::view_mut<s_SolvedNode> callsite_args, const s_Map_uccvP8a6Yhg& letdefReplicas, const int minLocalIdx, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Lifetime result {};
    bool maybeOutOfOrder = false;
    visit_wyx7msfr(lifetime, result, maybeOutOfOrder, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ result;
}
                                #endif

static void visitType_gDsnGKHT(s_Type& type, const s_Target& from, fu::view_mut<s_SolvedNode> callsite_args, const s_Map_uccvP8a6Yhg& letdefReplicas, const int minLocalIdx, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    type.lifetime = Lifetime_process_2PuIGhxS(type.lifetime, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static void visitNode_gDsnGKHT(s_SolvedNode& node, const int locals_start, const s_Target& from, fu::view_mut<s_SolvedNode> callsite_args, s_Map_uccvP8a6Yhg& letdefReplicas, const s_Target& now_inlining, const int minLocalIdx, fu::vec<s_Helpers>& helpersReplicas, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if ((node.kind == s_Kind_block) || (node.kind == s_Kind_loop))
    {
        const s_Helpers& foreign = node.helpers;
        if (foreign)
        {
            const int locals_start_1 = (locals_start ? locals_start : GET_next_local_index_gDsnGKHT(_current_fn, ss, _here, ctx));
            int BL_3_v {};
            const s_Helpers local = push_gDsnGKHT(HelpersReplica_gDsnGKHT((__extension__ (
            {
                const s_Target& t = _current_fn.out.target;
                BL_3_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_3_v), locals_start_1, node.type), ss, _helpers);
            ensure_DRUGaYT7(helpersReplicas, foreign.index) = s_Helpers((local ? local : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)));
            node.helpers = local;
        };
    };

    {
        int rest = 0;
        if ((node.kind == s_Kind_if) || (node.kind == s_Kind_and) || (node.kind == s_Kind_or))
        {
            rest = ((node.kind == s_Kind_if) ? 1 : (node.items.size() - 1));
            for (int i = 0; i < rest; i++)
            {
                s_SolvedNode& item = node.items.mutref(i);
                visitNode_gDsnGKHT(item, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, _helpers, _here, ctx, module, options);
                const s_StaticEval ae = tryAbstractEvalAsBool_gDsnGKHT(item, false, _current_fn, ss, _helpers, _here, ctx, module, options);
                if (ae)
                {
                    if (((ae == s_StaticEval_SE_True) && (node.kind != s_Kind_and)) || ((ae == s_StaticEval_SE_False) && (node.kind != s_Kind_or)))
                    {
                        if (node.kind == s_Kind_if)
                        {
                            node.kind = s_Kind_block;
                            remove_CU2cEQmH(node.items, ((ae == s_StaticEval_SE_True) ? 2 : 1), 1);
                        }
                        else if (!i)
                        {
                            node = steal_46agKNQY(item);
                            return;
                        }
                        else
                            node.items.shrink((rest = (i + 1)));

                        break;
                    };
                };
            };
        };
        bool children_someNever = false;
        for (int i = rest; i < node.items.size(); i++)
        {
            s_SolvedNode& item = node.items.mutref(i);
            visitNode_gDsnGKHT(item, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (is_never_9CJmuVSD(item.type.vtype))
            {
                children_someNever = true;
                if ((node.kind == s_Kind_and) || (node.kind == s_Kind_or) || (node.kind == s_Kind_block))
                {
                    node.items.shrink((i + 1));
                    break;
                }
                else if ((node.kind == s_Kind_not) || ((node.kind == s_Kind_if) && (i == 0)))
                {
                    node = item;
                    break;
                };
            };
        };
        if (children_someNever && (node.kind == s_Kind_call))
        {
            const bool RTL = isRTL_xQNS19Zn(GET_gDsnGKHT(node.target, ss, _here, ctx, module));
            fu::view<s_Argument> host_args = EXT_gDsnGKHT(node.target, ss, ctx, module).args;
            fu::vec<s_SolvedNode> block {};

            { {

                {
                    const int seqIdx_start = 0;
                    int seqIdx = 0;
                    int lastPass = 1;
                    for (int pass = 0; pass < lastPass; pass++)
                    {
                        for (int i_1 = 0; i_1 < host_args.size(); i_1++)
                        {
                            const s_Argument& host_arg = host_args[i_1];
                            if (!!pass != (RTL ? !i_1 : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                                lastPass = 2;
                            else
                            {
                                if ((seqIdx_start <= seqIdx))
                                {
                                    const int i_2 = i_1;
                                    const s_SolvedNode& item = node.items[i_2];
                                    const bool discard_rest = is_never_9CJmuVSD(item.type.vtype);
                                    block += s_SolvedNode(item);
                                    if (discard_rest)
                                        goto BL_19;

                                };
                                seqIdx++;
                            };
                        };
                    };
                };
                BUG_gDsnGKHT("visitNode(call): !FOUND_NEVER"_fu, ss, _helpers, _here, ctx, module, options);
              } BL_19:;
            };
            node = createBlock_gDsnGKHT(t_never, block, s_Helpers{}, _here);
        };
    };
    if (node.kind == s_Kind_letdef)
    {
        s_Overload BL_30_v {};
        /*MOV*/ s_Overload foreign = (__extension__ (
        {
            const s_Overload& __partcopy_ref = GET_gDsnGKHT(node.target, ss, _here, ctx, module);
            BL_30_v = (s_Overload { __partcopy_ref.kind, __partcopy_ref.flags, __partcopy_ref.status, {}, fu::str(__partcopy_ref.name), s_Type(__partcopy_ref.type), s_SolvedNode(__partcopy_ref.solved) });
        (void)0;}), static_cast<s_Overload&&>(BL_30_v));
        int BL_31_v {};
        const s_Target local = Scope_create_z0QqoZ5t(ss._scope, s_Kind___no_kind_yet, (*(const fu::str*)fu::NIL), (*(const s_Type*)fu::NIL), s_Flags{}, s_DeclAsserts{}, s_SolverStatus{}, (__extension__ (
        {
            const s_Target& t = _current_fn.out.target;
            BL_31_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
        (void)0;}), BL_31_v), false, module);
        set_PvI5nIDT(letdefReplicas, node.target, (local ? local : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)));
        /*MOV*/ s_Type type { foreign.type };
        if (isStaticOrZeroes_7Yz9ezW2(type.lifetime))
        {
            if (!(is_zst_1qjplDUo(type.vtype, _here, ctx, module)))
            {
                BUG_gDsnGKHT(x7E_3lDd4lqo("Unexpected static lifetime on "_fu, str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            const int flatCount = getFlatCount_1qjplDUo(type.vtype, _here, ctx, module);
            TEST_LifetimeEqual_gDsnGKHT(type.lifetime, "foreign.type.lifetime"_fu, Lifetime_fromBinding_gDsnGKHT(node.target, flatCount, ss, _helpers, _here, ctx, module, options), "Lifetime_fromBinding"_fu, ss, _helpers, _here, ctx, module, options);
            type.lifetime = Lifetime_fromBinding_gDsnGKHT(local, flatCount, ss, _helpers, _here, ctx, module, options);
        };
        /*MOV*/ s_SolvedNode solved { foreign.solved };
        if ((solved.kind == s_Kind_let) && (solved.target == node.target))
        {
            solved.target = local;
            visitNode_gDsnGKHT(solved, 0, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, _helpers, _here, ctx, module, options);
            GET_mut_gDsnGKHT(local, ss, module) = s_Overload { foreign.kind, foreign.flags, s_SolverStatus((foreign.status & s_SolverStatus_SS_MATCHED)), s_DeclAsserts{}, static_cast<fu::str&&>(foreign.name), static_cast<s_Type&&>(type), static_cast<s_SolvedNode&&>(solved) };
            node.target = local;
        }
        else
        {
            BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else if (node.kind == s_Kind_call)
    {
        if (isLocal_gDsnGKHT(node.target))
        {
            const s_Target local = matchReplicaOrInjectForeignLocal_gDsnGKHT(node.target, node.type, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);

            {
                const s_Target& foreign = node.target;
                if (!(isAssignable_9CJmuVSD(GET_gDsnGKHT(foreign, ss, _here, ctx, module).type, GET_gDsnGKHT(local, ss, _here, ctx, module).type, false, false, _here, ctx) || (is_never_9CJmuVSD(GET_gDsnGKHT(local, ss, _here, ctx, module).type.vtype) && isInlineLocal_gDsnGKHT(local, ss, _here, ctx, module))))
                    BUG_gDsnGKHT((((((x7E_3lDd4lqo("matchReplicaOrInjectForeignLocal botching the type of "_fu, str_FDl5ha9X(foreign, false, ss, _here, ctx, module, options)) + ":\n"_fu) + "\n\t\tExpect: "_fu) + explainType_gDsnGKHT(GET_gDsnGKHT(foreign, ss, _here, ctx, module).type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + "\n\t\tActual: "_fu) + explainType_gDsnGKHT(GET_gDsnGKHT(local, ss, _here, ctx, module).type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            };
            node.target = local;
            if (isLocal_gDsnGKHT(local))
                GET_mut_gDsnGKHT(local, ss, module).status |= s_SolverStatus_SS_MATCHED;

            node.type.vtype.vfacts = GET_gDsnGKHT(local, ss, _here, ctx, module).type.vtype.vfacts;
            if (isInlineLocal_gDsnGKHT(local, ss, _here, ctx, module))
            {
                if (GET_gDsnGKHT(local, ss, _here, ctx, module).status & s_SolverStatus_SS_NAME_UNUSED)
                {
                    fail_gDsnGKHT("Inline arguments can only be inlined once."_fu, fu::view<char>{}, s_TokenIdx(node.token), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    s_Overload& o = GET_mut_gDsnGKHT(local, ss, module);
                    o.status |= s_SolverStatus_SS_NAME_UNUSED;
                    const s_SolvedNode& init = o.solved.items[LET_INIT];
                    if (is_never_9CJmuVSD(init.type.vtype))
                    {
                        node = init;
                        return;
                    }
                    else
                    {
                        node = createLetDef_gDsnGKHT(local, ss, _here, ctx, module);
                        return;
                    };
                };
            };
        }
        else if ((node.target == now_inlining) || has_AOZqRgIb(_current_fn.already_inlined, node.target))
        {
            fail_gDsnGKHT(x7E_3lDd4lqo("Cannot inline self-recursive fns: "_fu, str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else if ((node.kind == s_Kind_jump) || (node.kind == s_Kind___far_jump))
    { {
        if (node.kind == s_Kind_jump)
        {
            const s_Helpers& foreign = node.helpers;
            const s_Helpers& local = iF_5Rs0gQD7(helpersReplicas, foreign.index);
            if (local)
            {
                node.helpers = local;
                (((local.index >= 0) && (local.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(local.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask |= s_HelpersMask_HM_LabelUsed;
                goto BL_48;
            }
            else
                node.kind = s_Kind___far_jump;

        };
        const s_HelpersData* BL_52_v;
        int BL_53_v {};
        if ((__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_52_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_52_v).local_of == (__extension__ (
        {
            const s_Target& t = _current_fn.out.target;
            BL_53_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
        (void)0;}), BL_53_v))
        {
            const s_TokenIdx here0 { _here };
            _here = node.token;
            node = solveJump_finish_gDsnGKHT(node.flags, only_LqU08rcL(node.items), node.helpers, _current_fn, ss, _helpers, _here, ctx, module, options);
            _here = here0;
        }
        else
        {
            const s_HelpersData* BL_56_v;
            add_8Ex4Hrql(_current_fn.far_jumps, (__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_56_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_56_v).local_of);
        };
      } BL_48:;
    }
    else if (node.kind == s_Kind_unwrap)
    {
        if (!node.target)
        {
            node.target = from;
            node.token = _here;
        };
    };
    visitType_gDsnGKHT(node.type, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (node.helpers)
    {
        if ((node.kind == s_Kind_block) || (node.kind == s_Kind_loop))
        {
            const s_HelpersData* BL_61_v;
            if ((__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_61_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_61_v).ret_actual)
            {
                s_Type ret_actual {};
                s_HelpersData* BL_63_v;
                std::swap(ret_actual, (__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_63_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_63_v).ret_actual);
                visitType_gDsnGKHT(ret_actual, from, callsite_args, letdefReplicas, minLocalIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
                s_HelpersData* BL_64_v;
                std::swap(ret_actual, (__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_64_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_64_v).ret_actual);
            };
        }
        else if ((node.kind != s_Kind_jump) && (node.kind != s_Kind___far_jump))
            BUG_gDsnGKHT(x7E_3lDd4lqo("inlineExpression: TODO handle .helpers on a "_fu, str_WkqQ7QhO(node.kind)), ss, _helpers, _here, ctx, module, options);

    };
}

static s_SolvedNode inlineExpression_gDsnGKHT(const s_Target& from, /*MOV*/ s_SolvedNode&& node, fu::view_mut<s_SolvedNode> callsite_args, s_Map_uccvP8a6Yhg&& letdefReplicas, const int locals_start, const s_Target& now_inlining, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (from)
    {
        const int helpers0 = _helpers.size();
        fu_DEFER(_helpers.shrink(helpers0));
        const int minLocalIdx = GET_next_local_index_gDsnGKHT(_current_fn, ss, _here, ctx);
        fu::vec<s_Helpers> helpersReplicas {};
        visitNode_gDsnGKHT(node, locals_start, from, callsite_args, letdefReplicas, now_inlining, minLocalIdx, helpersReplicas, _current_fn, ss, _helpers, _here, ctx, module, options);
        return static_cast<s_SolvedNode&&>(node);
    }
    else
        BUG_gDsnGKHT("TODO inlining from global scope, never happened before, might work, remove assert as needed."_fu, ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_argsForward_Zv3pwS64PJ1
                                #define DEF_argsForward_Zv3pwS64PJ1
inline void argsForward_Zv3pwS64(const bool RTL, fu::view<s_Argument> host_args, const int seqIdx_start, const int i, fu::vec<s_SolvedNode>& ooe, fu::view<s_SolvedNode> args, const s_TokenIdx& _here, const s_Context& ctx)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass = 0; pass < lastPass; pass++)
    {
        for (int i_1 = 0; i_1 < host_args.size(); i_1++)
        {
            const s_Argument& host_arg = host_args[i_1];
            if (!!pass != (RTL ? !i_1 : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                {
                    const int i_2 = i_1;
                    ooe += s_SolvedNode(args[i_2]);
                    if (i == i_2)
                        return;

                };
                seqIdx++;
            };
        };
    };
}
                                #endif

                                #ifndef DEF_only_n3dv4p6exT5
                                #define DEF_only_n3dv4p6exT5
inline s_SolvedNode& only_n3dv4p6e(fu::view_mut<s_SolvedNode> s)
{
    fu_ASSERT((s.size() == 1));
    return s.mutref(0);
}
                                #endif

                                #ifndef DEF___CAvalO0Jmk6
                                #define DEF___CAvalO0Jmk6
inline static bool _CAvalO0J(const int locid, const bool isStatic, const bool staticOK, const int expect)
{
    return (locid ? (!expect || (locid == expect)) : false) || (!isStatic ? isStatic : staticOK);
}
                                #endif

                                #ifndef DEF_Lifetime_if_only_iEajNDRw0ef
                                #define DEF_Lifetime_if_only_iEajNDRw0ef
inline bool Lifetime_if_only_iEajNDRw(const s_Lifetime& lifetime, const bool staticOK, const int expect)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const int offset0 = offset;
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            const bool isOnly = (!offset0 ? (offset == chars.size()) : false);
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            const bool isStatic = ((r & 11u) == 1u);
            if (isOnly)
                return _CAvalO0J(locid, isStatic, staticOK, expect);
            else
                return false;

        };
    };
    return false;
}
                                #endif

static void TEST_varLifetime_gDsnGKHT(const s_Lifetime& lifetime, const bool staticOK, const int expect, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!Lifetime_if_only_iEajNDRw(lifetime, staticOK, expect))
    {
        BUG_gDsnGKHT(x7E_3lDd4lqo("Bad local lifetime: "_fu, str_gDsnGKHT(lifetime, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
    };
}

static int localOf_gDsnGKHT(const s_Target& target, const s_SolverState& ss, const s_Module& module)
{
    if (isLocal_gDsnGKHT(target))
        return int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    else
        return EPH_gDsnGKHT(target, ss, module).local_of;

}

                                #ifndef DEF_bfind_0xcQAIqFEj4
                                #define DEF_bfind_0xcQAIqFEj4
inline static int bfind_0xcQAIqF(fu::view<int> keys_asc, const int key, s_Set_95BJOojOc45& _, const int key_1, fu::vec<int>& values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_XrkW2YUZ(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, int{});
    _.keys_asc.insert(i, key_1);
    return i;
}
                                #endif

                                #ifndef DEF_ref_dpAGlAFBIDg
                                #define DEF_ref_dpAGlAFBIDg
inline int& ref_dpAGlAFB(s_Set_95BJOojOc45& _, const int key, fu::vec<int>& values)
{
    const int idx = bfind_0xcQAIqF(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_6QbK8pO0vsa
                                #define DEF_ref_6QbK8pO0vsa
inline int& ref_6QbK8pO0(s_Map_2goAfCfe5Ta& _, const int key)
{
    return ref_dpAGlAFB(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_incr_2wqwrhpYfLc
                                #define DEF_incr_2wqwrhpYfLc
inline bool incr_2wqwrhpY(s_CountedSet_95BJOojOc45& _, const int key)
{
    if (ref_6QbK8pO0(_.counts, key)++)
        return false;
    else
        return true;

}
                                #endif

static void detectRecursion_gDsnGKHT(const s_Target& target, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Overload& overload = GET_gDsnGKHT(target, ss, _here, ctx, module);
    if (!(s_SolverStatus((overload.status & s_SolverStatus((s_SolverStatus_SS_FINALIZED | s_SolverStatus_SS_LAZY)))) != s_SolverStatus_SS_LAZY))
    {
        const s_SolverNotes note = ((overload.kind == s_Kind_type) ? s_SolverNotes_N_TypeRecursion : s_SolverNotes_N_FnRecursion);
        const s_SolverStatus status = ((overload.kind == s_Kind_type) ? s_SolverStatus_SS_TYPE_RECUR : s_SolverStatus_SS_FN_RECUR);
        for (int i = _helpers.size(); i-- > 0; )
        {
            const s_Helpers& h = _helpers[i];
            if (!(!isFnOrType_gDsnGKHT(h, ss, _here, ctx)))
            {
                GET_mut_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target, ss, module).status |= status;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                    ss._notes |= note;

                if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target == target)
                    return;

            };
        };
        BUG_gDsnGKHT((x7E_3lDd4lqo((("detectRecursion: no _helpers entry for `"_fu + overload.name) + " ("_fu), str_tqiEnBQ6(overload.status)) + ")`."_fu), ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF___REjuyZKKjj1
                                #define DEF___REjuyZKKjj1
inline static void _REjuyZKK(const int i, fu::view<s_SolvedNode> args, fu::vec<s_SolvedNode>& argdefs, s_Map_uccvP8a6Yhg& letdefReplicas, const unsigned revision, fu::view<s_Argument> host_args, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Argument& host_arg = host_args[i];
    if (!(!host_arg.target))
    {
        s_SolvedNode argdef = createLet_gDsnGKHT(serialize_UvH3gYAB(s_ClosureID { s_Target(host_arg.target), revision }, _here, ctx), ((host_arg.flags & ~s_Flags_F_COMPOUND_ID) | s_Flags_F_LAX), GET_gDsnGKHT(host_arg.target, ss, _here, ctx, module).asserts, args[i], false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if ((argdef.kind == s_Kind_empty) || (argdef.kind == s_Kind_letdef))
        {
            if (!(argdef.target))
                BUG_gDsnGKHT(x7E_3lDd4lqo("Inliner: no argdef.target: "_fu, str_iUdwqyBn(argdef, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        }
        else
            BUG_gDsnGKHT(x7E_3lDd4lqo("Inliner: argdef neither letdef nor empty: "_fu, str_iUdwqyBn(argdef, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        if ((argdef.kind != s_Kind_empty) && !(GET_gDsnGKHT(argdef.target, ss, _here, ctx, module).flags & s_Flags_F_INLINE))
            argdefs += s_SolvedNode(argdef);

        const s_Target& foreign = host_arg.target;
        set_PvI5nIDT(letdefReplicas, foreign, (argdef.target ? argdef.target : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)));
        if (!(isAssignable_9CJmuVSD(GET_gDsnGKHT(foreign, ss, _here, ctx, module).type, GET_gDsnGKHT(argdef.target, ss, _here, ctx, module).type, false, false, _here, ctx) || (is_never_9CJmuVSD(GET_gDsnGKHT(argdef.target, ss, _here, ctx, module).type.vtype) && (GET_gDsnGKHT(argdef.target, ss, _here, ctx, module).flags & s_Flags_F_INLINE))))
            BUG_gDsnGKHT((((((x7E_3lDd4lqo("Inliner botching the argdef type of "_fu, str_FDl5ha9X(foreign, false, ss, _here, ctx, module, options)) + ":\n"_fu) + "\n\t\tExpect: "_fu) + explainType_gDsnGKHT(GET_gDsnGKHT(foreign, ss, _here, ctx, module).type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + "\n\t\tActual: "_fu) + explainType_gDsnGKHT(GET_gDsnGKHT(argdef.target, ss, _here, ctx, module).type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
}
                                #endif

                                #ifndef DEF_argsForward_OD4MoVJsMQe
                                #define DEF_argsForward_OD4MoVJsMQe
inline void argsForward_OD4MoVJs(const bool RTL, fu::view<s_Argument> host_args, const int seqIdx_start, fu::view<s_SolvedNode> args, fu::vec<s_SolvedNode>& argdefs, s_Map_uccvP8a6Yhg& letdefReplicas, const unsigned revision, fu::view<s_Argument> host_args_1, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass = 0; pass < lastPass; pass++)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const s_Argument& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                    _REjuyZKK(i, args, argdefs, letdefReplicas, revision, host_args_1, _current_fn, ss, _helpers, _here, ctx, module, options);

                seqIdx++;
            };
        };
    };
}
                                #endif

static s_SolvedNode CallerNode_inline_gDsnGKHT(const s_Target& target, fu::view<s_SolvedNode> args, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if ((int(unsigned(((target._packed >> 40ull) & 0xfffffull))) != module.modid) || (EPH_gDsnGKHT(target, ss, module).revision > 0u))
    {
        if (!(ss.TODO_FIX_inline_safety++ < 24))
            BUG_gDsnGKHT(x7E_3lDd4lqo("Inliner recursion, something is off: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo("Inlining "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + " at revision 0."_fu), ss, _helpers, _here, ctx, module, options);

    fu_DEFER(ss.TODO_FIX_inline_safety--);
    fu::vec<s_SolvedNode> argdefs {};
    /*MOV*/ s_Map_uccvP8a6Yhg letdefReplicas {};
    const int locals_start = GET_next_local_index_gDsnGKHT(_current_fn, ss, _here, ctx);
    const unsigned revision = EPH_gDsnGKHT(target, ss, module).revision;
    fu::vec<s_Argument> host_args { EXT_gDsnGKHT(target, ss, ctx, module).args };
    if (host_args.size() == args.size())
    {
        const bool RTL = isRTL_xQNS19Zn(GET_gDsnGKHT(target, ss, _here, ctx, module));
        argsForward_OD4MoVJs(RTL, host_args, 0, args, argdefs, letdefReplicas, revision, host_args, _current_fn, ss, _helpers, _here, ctx, module, options);
        const s_SolvedNode& n_body = last_31malqbt(GET_gDsnGKHT(target, ss, _here, ctx, module).solved.items);
        fu::vec<s_SolvedNode> callsite_args {};
        /*MOV*/ s_SolvedNode s_body = inlineExpression_gDsnGKHT(target, s_SolvedNode(n_body), callsite_args, static_cast<s_Map_uccvP8a6Yhg&&>(letdefReplicas), locals_start, target, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (argdefs)
        {
            if (s_body.kind)
            {
                if (s_body.kind != s_Kind_block)
                {
                    s_body = createBlock_gDsnGKHT(s_body.type, (argdefs + s_body), s_Helpers{}, _here);
                }
                else
                    s_body.items.splice(0, 0, argdefs);

            }
            else
                BUG_gDsnGKHT("inline: no s_body.kind"_fu, ss, _helpers, _here, ctx, module, options);

        };
        return /*NRVO*/ s_body;
    }
    else
        BUG_gDsnGKHT("inline: arglen mismatch"_fu, ss, _helpers, _here, ctx, module, options);

}

static void visit_gDsnGKHT(const s_Lifetime& lifetime, s_Lifetime& result, bool& maybeOutOfOrder, fu::view<s_SolvedNode> argNodes, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit(chars, offset);
            int BL_4_v {};
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
            (void)0;}), BL_4_v);
            const bool isStatic = ((r & 11u) == 1u);
            const bool isTemp = (r == 0b1001u);
            int BL_12_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_12_v));
            const int argidx = int(((r & 1u) ? (r >> 2u) : 0u));
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!(isStatic))
            {
                if (isTemp || locid)
                {
                    BUG_gDsnGKHT("Lifetime_replaceArgsAtCallsite: Found a temp or locid."_fu, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    const s_SolvedNode& argNode = argNodes[argidx];
                    const s_Lifetime& argLt = (is_ref_9CJmuVSD(argNode.type) ? argNode.type.lifetime : Lifetime_temporary);
                    s_Lifetime replacement = Lifetime_op_join_7Yz9ezW2(argLt, paths, _here, ctx);
                    maybeOutOfOrder = true;
                    Lifetime_add_7Yz9ezW2(result, replacement, false, _here, ctx);
                    continue;
                };
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_LhU4BMLr4uj
                                #define DEF_Lifetime_process_LhU4BMLr4uj
inline s_Lifetime Lifetime_process_LhU4BMLr(const s_Lifetime& lifetime, fu::view<s_SolvedNode> argNodes, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Lifetime result {};
    bool maybeOutOfOrder = false;
    visit_gDsnGKHT(lifetime, result, maybeOutOfOrder, argNodes, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ result;
}
                                #endif

static s_Lifetime Lifetime_replaceArgsAtCallsite_gDsnGKHT(const s_Target& target, fu::view<s_SolvedNode> argNodes, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return Lifetime_process_LhU4BMLr(GET_gDsnGKHT(target, ss, _here, ctx, module).type.lifetime, argNodes, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF___lP45dHqfzGk
                                #define DEF___lP45dHqfzGk
inline static void _lP45dHqf(const int locid, const bool isStatic, const bool isAlwaysMoveable, const bool isTemp, const bool isArgIdx, const int argidx, fu::view<char> paths, const s_Type& type, const bool tempsOK, const bool argPositionsOK, bool& first, int& lastStatic, int& lastLocid, int& lastArgIdx, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (isTemp)
    {
        if (tempsOK)
        {
            if (!(first))
            {
                BUG_gDsnGKHT("TEST_Lifetime: temporary is not first"_fu, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            BUG_gDsnGKHT("TEST_Lifetime: unexpected temporary"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    first = false;
    if (isStatic)
    {
        const int r = (isAlwaysMoveable ? 1 : 0);
        if (lastStatic > r)
            lastStatic = r;
        else
        {
            BUG_gDsnGKHT("TEST_Lifetime: static out of order"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    if (locid)
    {
        if (!argPositionsOK)
        {
            if (lastArgIdx == 1000000)
            {
                if (lastStatic == 1000000)
                {
                    if (lastLocid > locid)
                        lastLocid = locid;
                    else
                    {
                        BUG_gDsnGKHT("TEST_Lifetime: locid out of order"_fu, ss, _helpers, _here, ctx, module, options);
                    };
                }
                else
                {
                    BUG_gDsnGKHT("TEST_Lifetime: local after static"_fu, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
            {
                BUG_gDsnGKHT("TEST_Lifetime: local after argpos"_fu, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            BUG_gDsnGKHT("TEST_Lifetime: unexpected locid"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    if (isArgIdx)
    {
        if (argPositionsOK)
        {
            if (lastLocid == 1000000)
            {
                if (lastStatic == 1000000)
                {
                    if (lastArgIdx > argidx)
                        lastArgIdx = argidx;
                    else
                    {
                        BUG_gDsnGKHT("TEST_Lifetime: argidx out of order"_fu, ss, _helpers, _here, ctx, module, options);
                    };
                }
                else
                {
                    BUG_gDsnGKHT("TEST_Lifetime: argidx after static"_fu, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
            {
                BUG_gDsnGKHT("TEST_Lifetime: argidx after local"_fu, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            BUG_gDsnGKHT("TEST_Lifetime: unexpected argidx"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    if (isStatic || isTemp)
    {
        if (!(paths == "\x00\x00"_fu))
        {
            BUG_gDsnGKHT("TEST_Lifetime: static/temp paths != x00x00"_fu, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
        assertPathsValid_7Yz9ezW2(paths, getFlatCount_1qjplDUo(type.vtype, _here, ctx, module), (locid ? getFlatCount_1qjplDUo(GET_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _here, ctx, module).type.vtype, _here, ctx, module) : -1), false, 1, _here, ctx);

}
                                #endif

                                #ifndef DEF_Lifetime_each_qzbdxgK58lc
                                #define DEF_Lifetime_each_qzbdxgK58lc
inline void Lifetime_each_qzbdxgK5(const s_Lifetime& lifetime, const s_Type& type, const bool tempsOK, const bool argPositionsOK, bool& first, int& lastStatic, int& lastLocid, int& lastArgIdx, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0;

    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        _lP45dHqf(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v)), ((r & 11u) == 1u), ((r == 0b0101u) || (r == 0b1001u)), (r == 0b1001u), ((r & 3u) == 3u), int(((r & 1u) ? (r >> 2u) : 0u)), fu::get_view(chars, sr, offset), type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static const s_Lifetime& TEST_Lifetime_gDsnGKHT(const s_Lifetime& lifetime, const s_Type& type, const bool tempsOK, const bool argPositionsOK, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!lifetime)
    {
        BUG_gDsnGKHT("TEST_Lifetime: empty lifetime"_fu, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        bool first = true;
        int lastStatic = 1000000;
        int lastLocid = 1000000;
        int lastArgIdx = 1000000;
        Lifetime_each_qzbdxgK5(lifetime, type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, _helpers, _here, ctx, module, options);
    };
    return lifetime;
}

static s_SolvedNode CallerNode_gDsnGKHT(const fu::str& debug, s_Target&& target, fu::vec<s_SolvedNode>&& args, const s_Reorder& reorder, fu::view<fu::vec<s_Target>> conversions, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (reorder)
    {
        /*MOV*/ fu::vec<s_SolvedNode> args_out {};
        args_out.resize(reorder.map.size());
        for (int i = 0; i < reorder.map.size(); i++)
        {
            const int idx = reorder.map[i];
            if ((idx >= 0))
                args_out.mutref(i) = steal_46agKNQY(args.mutref(idx));

        };
        args = static_cast<fu::vec<s_SolvedNode>&&>(args_out);
    };
    for (int argIdx = 0; argIdx < conversions.size(); argIdx++)
    {
        fu::view<s_Target> conversion = conversions[argIdx];
        if (applyConversion_gDsnGKHT(args.mutref(argIdx), conversion, _current_fn, ss, _helpers, _here, ctx, module, options))
        {
            args.shrink((argIdx + 1));

            {
                const s_SolverNotes note = s_SolverNotes_N_DeadConv;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                    ss._notes |= note;

            };
            return createBlock_gDsnGKHT(t_never, args, s_Helpers{}, _here);
        };
    };
    const int REST_START = findRestStart_gDsnGKHT(EXT_gDsnGKHT(target, ss, ctx, module));
    if (REST_START < args.size())
    {
        fu::vec<s_SolvedNode> rest {};
        rest.resize((args.size() - REST_START));
        for (int i = args.size(); i-- > REST_START; )
        {
            std::swap(rest.mutref((i - REST_START)), args.mutref(i));
            if (i > REST_START)
                args.splice(i, 1);
            else
                args.mutref(i) = createArrlit_gDsnGKHT(rest, (*(const s_Type*)fu::NIL), ss, _helpers, _here, ctx, module, options);

        };
    };
    const s_Kind kind = GET_gDsnGKHT(target, ss, _here, ctx, module).kind;
    const bool isZeroInit = ((kind == s_Kind_type) ? !args.size() : false);
    if (!isZeroInit)
    {
        fu::vec<s_Argument> host_args { EXT_gDsnGKHT(target, ss, ctx, module).args };
        const s_Target spec_of { EXT_gDsnGKHT(target, ss, ctx, module).spec_of };
        fu::vec<s_Argument> spec_of_args { (spec_of ? EXT_gDsnGKHT(spec_of, ss, ctx, module).args : (*(const fu::vec<s_Argument>*)fu::NIL)) };
        args.resize(host_args.size());
        const bool RTL = isRTL_xQNS19Zn(GET_gDsnGKHT(target, ss, _here, ctx, module));
        const int seqIdx_start = 0;
        int seqIdx = 0;
        int lastPass = 1;
        for (int pass = 0; pass < lastPass; pass++)
        {
            for (int i = 0; i < host_args.size(); i++)
            {
                s_Argument host_arg { host_args[i] };
                if (!!pass != (RTL ? !i : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                    lastPass = 2;
                else
                {
                    if ((seqIdx_start <= seqIdx))
                    {
                        const int i_1 = i;
                        s_SolvedNode& arg = args.mutref(i_1);
                        if (!arg)
                        {
                            s_Target defaultFrom { target };
                            const s_SolvedNode& dEfault = (host_arg.dEfault ? host_arg.dEfault : ((defaultFrom = spec_of), ((spec_of_args.size() > i_1) ? spec_of_args[i_1].dEfault : (*(const s_SolvedNode*)fu::NIL))));
                            if (dEfault)
                            {
                                args.mutref(i_1) = inlineExpression_gDsnGKHT(defaultFrom, s_SolvedNode(dEfault), args, s_Map_uccvP8a6Yhg{}, 0, s_Target{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                            }
                            else if (host_arg.flags & s_Flags_F_IMPLICIT)
                                arg = bindImplicitArg_gDsnGKHT(host_arg.name, host_arg.type, host_arg.target, _current_fn, ss, _helpers, _here, ctx, module, options);
                            else
                                BUG_gDsnGKHT(x7E_3lDd4lqo("tryMatch: about to implicit-bind a non-implicit argument: "_fu, str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                        };
                        s_SolvedNode& arg_1 = args.mutref(i_1);
                        if ((kind != s_Kind_field) && (kind != s_Kind_template))
                        {
                            if (arg_1.kind == s_Kind_argid)
                                arg_1 = only_LqU08rcL(arg_1.items);

                            const s_Type& expect = host_arg.type;
                            s_Type retype = tryRetyping_gDsnGKHT(arg_1, expect, ss, _helpers, _here, ctx, module, options);
                            if (retype && isAssignableAsArgument_9CJmuVSD(expect.vtype, retype.vtype, false, _here, ctx))
                                applyRetype_gDsnGKHT(arg_1, retype, ss, _helpers, _here, ctx, module, options);

                        };
                        if (is_never_9CJmuVSD(arg_1.type.vtype) && !(host_arg.flags & s_Flags_F_INLINE))
                        {
                            fu::vec<s_SolvedNode> ooe {};
                            argsForward_Zv3pwS64(RTL, host_args, 0, i_1, ooe, args, _here, ctx);

                            {
                                const s_SolverNotes note = s_SolverNotes_N_DeadCall;
                                if (note & options.break_notes)
                                {
                                    fu::view<char> reason = fu::view<char>{};
                                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                }
                                else
                                    ss._notes |= note;

                            };
                            return createBlock_gDsnGKHT(t_never, ooe, s_Helpers{}, _here);
                        };
                    };
                    seqIdx++;
                };
            };
        };
    };
    s_Type type { GET_gDsnGKHT(target, ss, _here, ctx, module).type };
    if (kind == s_Kind_field)
    {
        s_SolvedNode* _0;
        s_SolvedNode& arg = (*(_0 = &(only_n3dv4p6e(args))) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        type = make_field_reference_gDsnGKHT(arg.type, GET_gDsnGKHT(target, ss, _here, ctx, module), false, _here, ctx);
        if (is_zeroes_9CJmuVSD(arg.type.vtype))
        {
            definitWrap_gDsnGKHT(arg, type, ss, _helpers, _here, ctx, module, options);
            return s_SolvedNode(arg);
        };
    }
    else if (kind == s_Kind_var)
    {
        TEST_varLifetime_gDsnGKHT(type.lifetime, true, 0, ss, _helpers, _here, ctx, module, options);
        int BL_38_v {};
        int BL_39_v {};
        if ((__extension__ (
        {
            const s_Target& t = target;
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_38_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_38_v) || (((__extension__ (
        {
            const s_Target& t = target;
            BL_39_v = (int(unsigned(((t._packed >> 40ull) & 0xfffffull))));
        (void)0;}), BL_39_v) == module.modid) && !(GET_gDsnGKHT(target, ss, _here, ctx, module).flags & s_Flags_F_PUB)))
            GET_mut_gDsnGKHT(target, ss, module).status |= s_SolverStatus_SS_MATCHED;

        int BL_41_v {};
        if (isLocal_gDsnGKHT(target) && (localOf_gDsnGKHT(target, ss, module) != (__extension__ (
        {
            const s_Target& t = _current_fn.out.target;
            BL_41_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
        (void)0;}), BL_41_v)))
        {
            target = injectForeignLocal_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options);
            const s_Type* _1;
            type = (*(_1 = &(GET_gDsnGKHT(target, ss, _here, ctx, module).type)) ? *_1 : BUG_gDsnGKHT(("CallerNode: !type on var "_fu + GET_gDsnGKHT(target, ss, _here, ctx, module).name), ss, _helpers, _here, ctx, module, options));
        };
        bool BL_43_v {};
        if (isIrrelevant_9CJmuVSD(type) && !((__extension__ (
        {
            const s_Target& target_1 = target;
            int BL_44_v {};
            BL_43_v = (((__extension__ (
            {
                const unsigned v = unsigned((target_1._packed & 0xfffffull));
                BL_44_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_44_v) < 0));
        (void)0;}), BL_43_v) && (GET_gDsnGKHT(target, ss, _here, ctx, module).flags & s_Flags_F_INLINE)))
        {
            return createEmpty_gDsnGKHT(type, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
    {
        int BL_47_v {};
        if ((__extension__ (
        {
            const s_Target& t = target;
            BL_47_v = (int(unsigned(((t._packed >> 40ull) & 0xfffffull))));
        (void)0;}), BL_47_v) == module.modid)
        {
            if ((kind == s_Kind_fn) || (kind == s_Kind_type) || (kind == s_Kind_inline))
            {
                if (ss._solvingFnort)
                {
                    int BL_51_v {};
                    int _2 {};
                    (_2 = (__extension__ (
                    {
                        const s_Target& t = ss._solvingFnort;
                        BL_51_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                    (void)0;}), BL_51_v), incr_2wqwrhpY(EPH_mut_FDl5ha9X(target, ss, module).callers, _2));
                    int BL_52_v {};
                    incr_2wqwrhpY(EPH_mut_FDl5ha9X(ss._solvingFnort, ss, module).calls, (__extension__ (
                    {
                        const s_Target& t = target;
                        BL_52_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                    (void)0;}), BL_52_v));
                    detectRecursion_gDsnGKHT(target, ss, _helpers, _here, ctx, module, options);
                };
            };
        };
        if (args)
        {
            if (kind == s_Kind_type)
                type = clear_Typename_9CJmuVSD(s_Type(type), false);

        };
        if ((kind == s_Kind_inline) && s_SolverStatus((GET_gDsnGKHT(target, ss, _here, ctx, module).status & s_SolverStatus_SS_FINALIZED)))
            return CallerNode_inline_gDsnGKHT(target, args, _current_fn, ss, _helpers, _here, ctx, module, options);
        else if (args && is_ref_9CJmuVSD(type))
        {
            type.lifetime = static_cast<s_Lifetime&&>(const_cast<s_Lifetime&>(TEST_Lifetime_gDsnGKHT(Lifetime_replaceArgsAtCallsite_gDsnGKHT(target, args, ss, _helpers, _here, ctx, module, options), type, true, false, ss, _helpers, _here, ctx, module, options)));
        };
    };
    if (isZeroInit)
    {
        return createEmpty_gDsnGKHT(type, s_Target{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        return SolvedNode_gDsnGKHT(s_Kind_call, type, s_Flags{}, debug, args, target, s_Helpers{}, _here);
    };
}

static bool applyConversion_gDsnGKHT(s_SolvedNode& arg, fu::view<s_Target> conversion, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    for (int i = 0; i < conversion.size(); i++)
    {
        const s_Target& t = conversion[i];
        if (EXT_gDsnGKHT(t, ss, ctx, module).min || (EXT_gDsnGKHT(t, ss, ctx, module).max && arg))
        {
            arg = CallerNode_gDsnGKHT("__using.a"_fu, s_Target(t), fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(arg) } }, (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        }
        else if (i)
            BUG_gDsnGKHT(x7E_3lDd4lqo("Bad conversion chain, non-leading nullary: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else if (arg)
            BUG_gDsnGKHT("Bad conversion chain, about to throw away an argnode."_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            arg = CallerNode_gDsnGKHT("__using.b"_fu, s_Target(t), fu::vec<s_SolvedNode>{}, (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        if (is_never_9CJmuVSD(arg.type.vtype))
            return true;

    };
    return false;
}

static s_Type convertToSuperType_gDsnGKHT(fu::view<char> topic, s_SolvedNode& a, s_SolvedNode& b, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{

    {
        /*MOV*/ s_Type super = type_trySuper_9CJmuVSD(a.type, b.type, false, _here, ctx);
        if (super)
            return /*NRVO*/ super;

    };
    /*MOV*/ s_Type b_T = clear_vfacts_9CJmuVSD(s_Type(b.type));
    /*MOV*/ s_Type a_T = clear_vfacts_9CJmuVSD(s_Type(a.type));

    {
        s_Type aRetype = tryRetyping_gDsnGKHT(a, b_T, ss, _helpers, _here, ctx, module, options);
        s_Type bRetype = tryRetyping_gDsnGKHT(b, a_T, ss, _helpers, _here, ctx, module, options);
        if (aRetype)
        {
            if (bRetype)
            {
                fail_gDsnGKHT(((((topic + ": Type ambiguity, literals can be retyped both ways: "_fu) + explainType_gDsnGKHT(a.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " <-> "_fu) + explainType_gDsnGKHT(b.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
            {
                /*MOV*/ s_Type super = type_trySuper_9CJmuVSD(aRetype, b.type, false, _here, ctx);
                if (super)
                {
                    applyRetype_gDsnGKHT(a, aRetype, ss, _helpers, _here, ctx, module, options);
                    return /*NRVO*/ super;
                };
            };
        };
        if (bRetype)
        {
            /*MOV*/ s_Type super = type_trySuper_9CJmuVSD(bRetype, a.type, false, _here, ctx);
            if (super)
            {
                applyRetype_gDsnGKHT(b, bRetype, ss, _helpers, _here, ctx, module, options);
                return /*NRVO*/ super;
            };
        };
    };

    {
        fu::vec<s_Target> aConv = tryConvert_2QnVRhSK(clear_all_9CJmuVSD(static_cast<s_Type&&>(b_T)), a.type, _current_fn, ss, _helpers, _here, ctx, module, options);
        fu::vec<s_Target> bConv = tryConvert_2QnVRhSK(clear_all_9CJmuVSD(static_cast<s_Type&&>(a_T)), b.type, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (aConv)
        {
            if (bConv)
            {
                fu::str error = (topic + ": Type ambiguity, conversions exist both ways:\n"_fu);
                explain_wyx7msfr(a.type, b.type, aConv, error, _current_fn, ss, _here, ctx, module, options);
                explain_wyx7msfr(b.type, a.type, bConv, error, _current_fn, ss, _here, ctx, module, options);
                fail_gDsnGKHT(error, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
            {
                applyConversion_gDsnGKHT(a, aConv, _current_fn, ss, _helpers, _here, ctx, module, options);
                s_Type _0 {};
                return (_0 = type_trySuper_9CJmuVSD(a.type, b.type, false, _here, ctx)) ? static_cast<s_Type&&>(_0) : BUG_gDsnGKHT("convertToSuper: aConv super"_fu, ss, _helpers, _here, ctx, module, options);
            };
        }
        else if (bConv)
        {
            applyConversion_gDsnGKHT(b, bConv, _current_fn, ss, _helpers, _here, ctx, module, options);
            s_Type _1 {};
            return (_1 = type_trySuper_9CJmuVSD(a.type, b.type, false, _here, ctx)) ? static_cast<s_Type&&>(_1) : BUG_gDsnGKHT("convertToSuper: bConv super"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    fail_gDsnGKHT(((((topic + ": No common supertype: "_fu) + explainType_gDsnGKHT(a.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " <-> "_fu) + explainType_gDsnGKHT(b.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode createIf_gDsnGKHT(const s_SolvedNode& cond, /*MOV*/ s_SolvedNode&& cons, /*MOV*/ s_SolvedNode&& alt, s_Type&& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (is_never_9CJmuVSD(cond.type.vtype))
        BUG_gDsnGKHT("createIf: cond.is_never"_fu, ss, _helpers, _here, ctx, module, options);
    else if (const s_StaticEval ae_cond = tryAbstractEvalAsBool_gDsnGKHT(cond, false, _current_fn, ss, _helpers, _here, ctx, module, options))
        return createBlock_FDl5ha9X(s_SolvedNode(cond), ((ae_cond == s_StaticEval_SE_True) ? litfix_bound_gDsnGKHT(cons, alt, _here) : ((ae_cond == s_StaticEval_SE_False) ? litfix_bound_gDsnGKHT(alt, cons, _here) : BUG_gDsnGKHT("createIf: ae_cond, neither True nor False."_fu, ss, _helpers, _here, ctx, module, options))), ss, _here, ctx, module);
    else
    {
        const bool cons_isNever = is_never_9CJmuVSD(cons.type.vtype);
        const bool alt_isNever = is_never_9CJmuVSD(alt.type.vtype);
        if (cons_isNever && alt_isNever)
            type = t_never;
        else if (propositionOK_9CJmuVSD(type, false, _here, ctx))
            type = t_bool;
        else if (!is_void_9CJmuVSD(type.vtype))
        {
            type = (cons_isNever ? s_Type(alt.type) : (alt_isNever ? s_Type(cons.type) : convertToSuperType_gDsnGKHT("if/else"_fu, cons, alt, _current_fn, ss, _helpers, _here, ctx, module, options)));
        };
        return SolvedNode_gDsnGKHT(s_Kind_if, (type ? type : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)), s_Flags{}, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<3, s_SolvedNode> { s_SolvedNode(cond), static_cast<s_SolvedNode&&>(cons), static_cast<s_SolvedNode&&>(alt) } }, s_Target{}, s_Helpers{}, _here);
    };
}

static s_SolvedNode createAnd_gDsnGKHT(fu::vec<s_SolvedNode>&& items, s_Type&& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const int trim = createAndOr_staticEvalFold_gDsnGKHT(items, s_StaticEval_SE_True, _current_fn, ss, _helpers, _here, ctx, module, options);
    if ((items.size() > 1) && !is_void_or_propositionOK_9CJmuVSD(type, false, _here, ctx))
    {
        /*MOV*/ s_Type sumType {};
        for (int i = items.size(); i-- > 0; )
        {
            const s_SolvedNode& item = items[i];
            if (!(is_never_9CJmuVSD(item.type.vtype)))
            {
                if (sumType)
                {
                    sumType = type_trySuper_9CJmuVSD(sumType, item.type, false, _here, ctx);
                    if (andNodeType_canCleanlyDefinit_gDsnGKHT(sumType, _here, ctx))
                        break;

                }
                else
                {
                    type = item.type;
                    sumType = item.type;
                    if (is_zeroes_9CJmuVSD(type.vtype))
                        break;

                };
            };
        };
        if (andNodeType_canCleanlyDefinit_gDsnGKHT(sumType, _here, ctx))
        {
            /*MOV*/ fu::vec<s_SolvedNode> cond = fu::slice(items, 0, (items.size() - 1));
            const s_SolvedNode& cons = last_31malqbt(items);
            s_SolvedNode _0 {};
            return (_0 = createAnd_gDsnGKHT(static_cast<fu::vec<s_SolvedNode>&&>(cond), s_Type(t_bool), _current_fn, ss, _helpers, _here, ctx, module, options), createIf_gDsnGKHT(static_cast<s_SolvedNode&&>(_0), s_SolvedNode(cons), solveDefinit_gDsnGKHT(type, _here, ctx), s_Type{}, _current_fn, ss, _helpers, _here, ctx, module, options));
        }
        else
            type = static_cast<s_Type&&>(sumType);

    }
    else
        type = t_bool;


    {
        const s_VFacts vfacts = s_VFacts_AlwaysFalse;
        if (trim)
        {
            items.shrink(trim);
            type.vtype.vfacts |= vfacts;
        };
        if (items.size() < 2)
        {
            const s_SolvedNode& only = only_LqU08rcL(items);
            return s_SolvedNode(only);
        };
    };
    const s_SolvedNode& last_type = last_31malqbt(items);
    if (is_never_9CJmuVSD(last_type.type.vtype) || s_VFacts((last_type.type.vtype.vfacts & s_VFacts_AlwaysFalse)))
        type.vtype.vfacts = s_VFacts_AlwaysFalse;

    return SolvedNode_gDsnGKHT(s_Kind_and, type, s_Flags{}, (*(const fu::str*)fu::NIL), items, s_Target{}, s_Helpers{}, _here);
}

                                #ifndef DEF_TRY_CATCH
                                #define DEF_TRY_CATCH
inline constexpr int TRY_CATCH = 2;
                                #endif

static s_SolvedNode& recover_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(TRY_CATCH);
}

static s_SolvedNode& error_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(TRY_ERR);
}

                                #ifndef DEF_TRY_TRY
                                #define DEF_TRY_TRY
inline constexpr int TRY_TRY = 0;
                                #endif

static s_SolvedNode& attempt_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(TRY_TRY);
}

static const s_SolvedNode& attempt_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[TRY_TRY];
}

static void Breakable_begin_gDsnGKHT(const bool loop_PREVITER, const s_SolvedNode& node, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (node.helpers)
    {
        s_HelpersData* BL_2_v;
        (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_2_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_2_v).postdom = s_Postdom(_current_fn.postdom);
    };
    if (loop_PREVITER && (relax_mask == RELAX_all))
    {
        const s_HelpersData* BL_4_v;
        branch_gDsnGKHT(_current_fn.postdom, (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_4_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_4_v).loop_PREVITER, _here, ctx);
    };
}

                                #ifndef DEF_LOOP_POST_COND
                                #define DEF_LOOP_POST_COND
inline constexpr int LOOP_POST_COND = 5;
                                #endif

static const s_SolvedNode& post_cond_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_POST_COND];
}

static s_SolvedNode& post_cond_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_POST_COND);
}

                                #ifndef DEF_LOOP_POST
                                #define DEF_LOOP_POST
inline constexpr int LOOP_POST = 4;
                                #endif

static const s_SolvedNode& post_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_POST];
}

static s_SolvedNode& post_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_POST);
}

                                #ifndef DEF_LOOP_BODY
                                #define DEF_LOOP_BODY
inline constexpr int LOOP_BODY = 3;
                                #endif

static const s_SolvedNode& body_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_BODY];
}

static s_SolvedNode& body_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_BODY);
}

                                #ifndef DEF_LOOP_PRE
                                #define DEF_LOOP_PRE
inline constexpr int LOOP_PRE = 2;
                                #endif

static const s_SolvedNode& pre_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_PRE];
}

static s_SolvedNode& pre_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_PRE);
}

                                #ifndef DEF_LOOP_PRE_COND
                                #define DEF_LOOP_PRE_COND
inline constexpr int LOOP_PRE_COND = 1;
                                #endif

static const s_SolvedNode& pre_cond_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_PRE_COND];
}

static s_SolvedNode& pre_cond_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_PRE_COND);
}

static void clear_FDl5ha9X(s_LocidSet& set, const int start, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    clear_Na55O4zv(set._bitset, (args_neg + ((start == NO_LOOP) ? -args_neg : start)));
}

                                #ifndef DEF_clear_GQxqmk0C5h5
                                #define DEF_clear_GQxqmk0C5h5
inline static void clear_GQxqmk0C(s_LocidMap_DC5gktNgm89& map, const int start, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    const int i = (start + args_neg);
    if (map._values.size() > i)
        map._values.shrink(i);

}
                                #endif

static void Breakable_end_gDsnGKHT(const bool loop_PREVITER, const s_SolvedNode& node, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (loop_PREVITER && !(relax_mask == RELAX_all))
    {
        s_HelpersData* BL_2_v;
        s_Postdom& previter = (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_2_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_2_v).loop_PREVITER;
        previter = _current_fn.postdom;
        const s_HelpersData* BL_3_v;
        const int loop_start = (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_3_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_3_v).locals_start;
        clear_FDl5ha9X(previter.snap.used_again, loop_start, _current_fn);
        clear_GQxqmk0C(previter.snap.ever_written, loop_start, _current_fn);
    };
    if (node.helpers)
    {
        const s_HelpersData* BL_5_v;
        branch_gDsnGKHT(_current_fn.postdom, (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_5_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_5_v).postdom, _here, ctx);
    };
}

                                #ifndef DEF_LOOP_INIT
                                #define DEF_LOOP_INIT
inline constexpr int LOOP_INIT = 0;
                                #endif

static const s_SolvedNode& init_FDl5ha9X(const s_SolvedNode& node)
{
    return node.items[LOOP_INIT];
}

static s_SolvedNode& init_gDsnGKHT(s_SolvedNode& node)
{
    return node.items.mutref(LOOP_INIT);
}

static bool has_gDsnGKHT(const s_LocidSet& set, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return has_ZwXYCruz(set._bitset, (args_neg + locid));
}

static s_UsedAgain descend_wyx7msfr(const s_Target& t, s_LocidSet& bitset, s_LocidSet& just_added, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    if (!add_gDsnGKHT(bitset, locid, _current_fn))
    {
        const s_UsedAgainReason reason = s_UsedAgainReason_UsedAgain;
        return s_UsedAgain(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
    }
    else
    {
        add_gDsnGKHT(just_added, locid, _current_fn);
        const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
        int BL_4_v {};
        const bool isArg = ((__extension__ (
        {
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_4_v) < 0);
        const s_SolvedNode& letNode = o.solved;
        if (is_ref_9CJmuVSD(letNode.type))
        {
            if (isArg)
            {
                if (!isMutVal_gDsnGKHT(o))
                {
                    const s_UsedAgainReason reason = s_UsedAgainReason_ArgReference;
                    return s_UsedAgain(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
                }
                else
                    return 0u;

            }
            else
            {
                const s_UsedAgain usedAgain = descend_FDl5ha9X(Lifetime_climbType_gDsnGKHT(t, ss, _helpers, _here, ctx, module, options).lifetime, bitset, just_added, _current_fn, ss, _helpers, _here, ctx, module, options);
                if (usedAgain)
                    return usedAgain;

            };
        }
        else if (isArg)
            BUG_gDsnGKHT("trackUsedAgain/descend: o.isArg but !o.solved.is_ref"_fu, ss, _helpers, _here, ctx, module, options);

        if (locid < _current_fn.postdom.write_loop_start)
        {
            const s_UsedAgainReason reason = s_UsedAgainReason_UsedInALoop;
            return s_UsedAgain(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
        }
        else
            return 0u;

    };
}

                                #ifndef DEF___7Xd9DtDuCJ3
                                #define DEF___7Xd9DtDuCJ3
inline static void _7Xd9DtDu(const int locid, const bool isAlwaysMoveable, const bool isStatic, s_LocidSet& bitset, s_UsedAgain& some, s_LocidSet& just_added, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(isAlwaysMoveable))
    {
        if (!locid)
        {
            if (isStatic)
            {
                s_UsedAgain BL_4_v {};
                some = (__extension__ (
                {
                    const s_UsedAgainReason reason = s_UsedAgainReason_StaticReference;
                    BL_4_v = (s_UsedAgain(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason))));
                (void)0;}), BL_4_v);
            }
            else
                BUG_gDsnGKHT("trackUsedAgain/descend: non-static non-local"_fu, ss, _helpers, _here, ctx, module, options);

        }
        else if (!has_gDsnGKHT(just_added, locid, _current_fn))
        {
            const s_UsedAgain usedAgain = descend_wyx7msfr(nested_FDl5ha9X(locid, ss, _here, ctx), bitset, just_added, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (usedAgain && !some)
                some = usedAgain;

        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_K0AVdmxJ0l7
                                #define DEF_Lifetime_each_K0AVdmxJ0l7
inline void Lifetime_each_K0AVdmxJ(const s_Lifetime& lifetime, s_LocidSet& bitset, s_UsedAgain& some, s_LocidSet& just_added, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _7Xd9DtDu(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), ((r == 0b0101u) || (r == 0b1001u)), ((r & 11u) == 1u), bitset, some, just_added, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static s_UsedAgain descend_FDl5ha9X(const s_Lifetime& lt, s_LocidSet& bitset, s_LocidSet& just_added, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_UsedAgain some {};
    Lifetime_each_K0AVdmxJ(lt, bitset, some, just_added, _current_fn, ss, _helpers, _here, ctx, module, options);
    return some;
}

static s_UsedAgain trackUsedAgain_gDsnGKHT(const s_Lifetime& lt, const unsigned relax_mask, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_LocidSet just_added {};
    if (relax_mask == RELAX_all)
        return descend_FDl5ha9X(lt, _current_fn.postdom.snap.used_again, just_added, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
    {
        const int locid = 0;
        const s_UsedAgainReason reason = s_UsedAgainReason_WrongPass;
        return s_UsedAgain(((((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) << 8u) | unsigned(reason)));
    };
}

static s_Target tryReverseSpecialize_gDsnGKHT(s_Target&& original, unsigned relaxed_quals, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    while (const s_Target& up = EPH_gDsnGKHT(original, ss, module).rev_spec.instance.original)
    {
        unsigned _0 {};
        relaxed_quals |= ((_0 = EPH_gDsnGKHT(original, ss, module).rev_spec.instance.relaxed_quals) ? _0 : BUG_gDsnGKHT((x7E_3lDd4lqo("tryReverseSpecialize: .original set on "_fu, str_FDl5ha9X(original, false, ss, _here, ctx, module, options)) + " but !relaxed_quals"_fu), ss, _helpers, _here, ctx, module, options));
        original = up;
    };
    if (!s_SolverStatus((GET_gDsnGKHT(original, ss, _here, ctx, module).status & s_SolverStatus_SS_FINALIZED)))
    {
        return s_Target{};
    }
    else
    {
        const unsigned expect_revision = EPH_gDsnGKHT(original, ss, module).revision;
        fu::view<s_RevSpecOutput> outputs = EPH_gDsnGKHT(original, ss, module).rev_spec.outputs;
        for (int i = 0; i < outputs.size(); i++)
        {
            if (outputs[i].relaxed_quals == relaxed_quals)
                return outputs[i].instance_targ;

        };
        const s_Target target = Scope_create_z0QqoZ5t(ss._scope, s_Kind_fn, (*(const fu::str*)fu::NIL), (*(const s_Type*)fu::NIL), s_Flags{}, s_DeclAsserts{}, s_SolverStatus{}, 0, false, module);
        GET_mut_gDsnGKHT(target, ss, module) = s_Overload(GET_gDsnGKHT(original, ss, _here, ctx, module));
        EXT_mut_gDsnGKHT(target, ss, module) = s_Extended(EXT_gDsnGKHT(original, ss, ctx, module));
        EPH_mut_FDl5ha9X(target, ss, module).rev_spec = s_ReverseSpecialization { s_RevSpecPrototype{}, s_RevSpecInstance { s_Target(original), relaxed_quals }, fu::vec<s_RevSpecOutput>{} };
        s_Ephemeral& eph_orig = EPH_mut_FDl5ha9X(original, ss, module);
        if (expect_revision && (eph_orig.revision == expect_revision))
        {
            eph_orig.rev_spec.outputs += s_RevSpecOutput { relaxed_quals, s_Target(target) };
            GET_mut_gDsnGKHT(target, ss, module).status &= s_SolverStatus((s_SolverStatus_SS_LAZY | s_SolverStatus_SS_FN_RECUR));
            EPH_mut_FDl5ha9X(target, ss, module).local_of = EPH_gDsnGKHT(original, ss, module).local_of;
            return target;
        }
        else
            BUG_gDsnGKHT("tryReverseSpecialize: original.revision bumped while reverse specializing."_fu, ss, _helpers, _here, ctx, module, options);

    };
}

                                #ifndef DEF___R1kLJDfxUJ5
                                #define DEF___R1kLJDfxUJ5
inline static fu::str _R1kLJDfx(const s_Argument& _, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return str_wyx7msfr(_, false, _current_fn, ss, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_map_MX6az0A3yg1
                                #define DEF_map_MX6az0A3yg1
inline fu::vec<fu::str> map_MX6az0A3(fu::view<s_Argument> a, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _R1kLJDfx(a[i], _current_fn, ss, _here, ctx, module, options);

    return /*NRVO*/ res;
}
                                #endif

                                #ifndef DEF_join_roEBocCSa32
                                #define DEF_join_roEBocCSa32
inline fu::str join_roEBocCS(fu::view<fu::str> a, fu::view<char> sep)
{
    if (a.size() < 2)
    {
        if (a.size())
            return fu::str(a[0]);
        else
        {
            return fu::str{};
        };
    }
    else
    {
        const int N = sep.size();
        int size = a[0].size();
        for (int i = 1; i < a.size(); i++)
            size += (N + a[i].size());

        /*MOV*/ fu::str res {};
        res.grow<false>(size);
        fu::view<char> head = a[0];
        size = head.size();
        fu::view_assign(fu::get_view_start0_mut(res, head.size()), head);
        for (int i_1 = 1; i_1 < a.size(); i_1++)
        {
            fu::view<char> range = a[i_1];
            fu::view_assign(fu::get_view_mut(res, size, (size + N)), sep);
            size += N;
            fu::view_assign(fu::get_view_mut(res, size, (size + range.size())), range);
            size += range.size();
        };
        return /*NRVO*/ res;
    };
}
                                #endif

static void redirectCallTarget_gDsnGKHT(const s_Target& spec, s_SolvedNode& node, const s_Target& t, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Target& orig = node.target;
    if (!(orig == spec))
    {
        ensureLazySolved_gDsnGKHT(spec, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (EXT_gDsnGKHT(spec, ss, ctx, module).args.size() == EXT_gDsnGKHT(t, ss, ctx, module).args.size())
        {

            {
                s_Type host { node.type };
                const s_Type& guest = GET_gDsnGKHT(spec, ss, _here, ctx, module).type;
                const bool asArgument = false;
                if (!(isAssignable_9CJmuVSD(host, guest, false, asArgument, _here, ctx)))
                    BUG_gDsnGKHT((("Relaxed specialization does not return a subtype"_fu + ": "_fu) + explainNotAssignable_gDsnGKHT(host, guest, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            };
            if (is_ref_9CJmuVSD(node.type))
            {
                node.type.lifetime = static_cast<s_Lifetime&&>(const_cast<s_Lifetime&>(TEST_Lifetime_gDsnGKHT(Lifetime_replaceArgsAtCallsite_gDsnGKHT(spec, node.items, ss, _helpers, _here, ctx, module, options), node.type, true, false, ss, _helpers, _here, ctx, module, options)));
            };
            node.target = spec;
            const s_SolverNotes note = s_SolverNotes_N_RelaxRespec;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
                ss._notes |= note;

        }
        else
            BUG_gDsnGKHT((((((x7E_3lDd4lqo((x7E_3lDd4lqo("Relaxed spec.args.len("_fu, fu::i64dec(EXT_gDsnGKHT(spec, ss, ctx, module).args.size())) + ") != original.args.len("_fu), fu::i64dec(EXT_gDsnGKHT(t, ss, ctx, module).args.size())) + "):"_fu) + "\n\n\t\t"_fu) + join_roEBocCS(map_MX6az0A3(EXT_gDsnGKHT(spec, ss, ctx, module).args, _current_fn, ss, _here, ctx, module, options), ", "_fu)) + "\n\n\t\t"_fu) + join_roEBocCS(map_MX6az0A3(EXT_gDsnGKHT(t, ss, ctx, module).args, _current_fn, ss, _here, ctx, module, options), ", "_fu)), ss, _helpers, _here, ctx, module, options);

    };
}

static s_Type conversionTailType_gDsnGKHT(const s_Type& from, fu::view<s_Target> conversions, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    for (int i = conversions.size(); i-- > 0; )
    {
        const s_Target& lastConv = conversions[i];
        if (GET_gDsnGKHT(lastConv, ss, _here, ctx, module).kind == s_Kind_field)
            return make_field_reference_gDsnGKHT(conversionTailType_gDsnGKHT(from, fu::get_view_start0(conversions, i), ss, _here, ctx, module), GET_gDsnGKHT(lastConv, ss, _here, ctx, module), true, _here, ctx);
        else
            return s_Type(GET_gDsnGKHT(lastConv, ss, _here, ctx, module).type);

    };
    return s_Type(from);
}

static fu::str mangleArgTypes_gDsnGKHT(fu::view<s_SolvedNode> args, const s_Reorder& reorder, fu::view<fu::vec<s_Target>> conversions, const int REST_START, const s_Type& REST_TYPE, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    /*MOV*/ fu::str mangle = ""_fu;
    const int REST_END = (reorder ? reorder.map.size() : args.size());
    const int N = min_O25D0jcU(REST_END, REST_START);
    for (int i = 0; i < N; i++)
    {
        if (i)
            mangle += ',';

        const int callsiteIndex = (reorder ? reorder.map[i] : i);
        const s_SolvedNode& arg = ((callsiteIndex >= 0) ? args[callsiteIndex] : (*(const s_SolvedNode*)fu::NIL));
        s_Type type = ((conversions.size() > i) ? conversionTailType_gDsnGKHT(arg.type, conversions[i], ss, _here, ctx, module) : s_Type(arg.type));
        if (type)
            mangle += serializeType_1qjplDUo(type.vtype, "mangle.conv"_fu);

    };
    if (REST_START < REST_END)
    {
        if (REST_START)
            mangle += ',';

        mangle += serializeType_1qjplDUo(REST_TYPE.vtype, "mangle[Nodes].rest"_fu);
    };
    return /*NRVO*/ mangle;
}

                                #ifndef DEF___IafLmajDKbc
                                #define DEF___IafLmajDKbc
inline static void _IafLmajD(const s_Target& target, int& parent_idx, const s_SolverState& ss, const s_Module& module)
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) || (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        const int local_of = localOf_gDsnGKHT(target, ss, module);
        if (parent_idx < local_of)
            parent_idx = local_of;

    };
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_MuJD2L7ysQ9
                                #define DEF_unpackAddrOfFn_MuJD2L7ysQ9
inline void unpackAddrOfFn_MuJD2L7y(fu::view<char> canon, int& parent_idx, const s_SolverState& ss, const s_Module& module)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const s_Target mi = parseLocalOrGlobal_xQNS19Zn(canon, offset);
            int BL_4_v {};
            _IafLmajD(Target_xQNS19Zn(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (__extension__ (
            {
                const unsigned v = unsigned((mi._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v)), parent_idx, ss, module);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_fu + canon) + "`."_fu));

}
                                #endif

                                #ifndef DEF_ensure_FYfwRiMglXb
                                #define DEF_ensure_FYfwRiMglXb
inline const s_Ephemeral& ensure_FYfwRiMg(fu::vec<s_Ephemeral>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a[i];
}
                                #endif

static const s_Ephemeral& EPH_mut_iUdwqyBn(const int index, s_SolverState& ss)
{
    return ensure_FYfwRiMg(ss._ephemeral, index);
}

static const s_Map_CIvvfLLMMzl& getSpecs_FDl5ha9X(const int parent_idx, s_SolverState& ss)
{
    return EPH_mut_iUdwqyBn(parent_idx, ss).specs;
}

                                #ifndef DEF_get_ctfBQWbsrd2
                                #define DEF_get_ctfBQWbsrd2
inline const s_Target& get_ctfBQWbs(const s_Set_6ARmtH0K78f& _, fu::view<char> key, fu::view<s_Target> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(const s_Target*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_DC6o5biXZwe
                                #define DEF_get_DC6o5biXZwe
inline const s_Target& get_DC6o5biX(const s_Map_CIvvfLLMMzl& _, fu::view<char> key)
{
    return get_ctfBQWbs(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_steal_HPql5iRShgb
                                #define DEF_steal_HPql5iRShgb
inline s_Map_lhf7SV3Fyjf steal_HPql5iRS(s_Map_lhf7SV3Fyjf& v)
{
    /*MOV*/ s_Map_lhf7SV3Fyjf ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF_x3Cx3E_RPJNYyHEAT3
                                #define DEF_x3Cx3E_RPJNYyHEAT3
inline int x3Cx3E_RPJNYyHE(const s_RetypeOrder& a, const s_RetypeOrder& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_XrkW2YUZ(a.retype_score, b.retype_score)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.index, b.index)))
        return cmp;

    return 0;
}
                                #endif

                                #ifndef DEF___43vR8bgFKu6
                                #define DEF___43vR8bgFKu6
inline static bool _43vR8bgF(const s_RetypeOrder& a, const s_RetypeOrder& b)
{
    return x3Cx3E_RPJNYyHE(a, b) < 0;
}
                                #endif

static void sort_FDl5ha9X(fu::vec<s_RetypeOrder>& a)
{
    s_RetypeOrder l {};
    s_RetypeOrder r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = _43vR8bgF(l, r);
    return lt;
            });

}

                                #ifndef DEF_sort_qDmV1ybCJ11
                                #define DEF_sort_qDmV1ybCJ11
inline void sort_qDmV1ybC(fu::vec<s_RetypeOrder>& a)
{
    sort_FDl5ha9X(a);
}
                                #endif

                                #ifndef DEF_LET_TYPE
                                #define DEF_LET_TYPE
inline constexpr int LET_TYPE = 0;
                                #endif

                                #ifndef DEF_bfind_T4oEoFI5ZWa
                                #define DEF_bfind_T4oEoFI5ZWa
inline static int bfind_T4oEoFI5(fu::view<fu::str> keys_asc, fu::view<char> key, s_Set_6ARmtH0K78f& _, const fu::str& key_1, fu::vec<s_TypeParam>& values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, s_TypeParam{});
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_MTrsOoFck1b
                                #define DEF_ref_MTrsOoFck1b
inline const s_TypeParam& ref_MTrsOoFc(s_Set_6ARmtH0K78f& _, const fu::str& key, fu::vec<s_TypeParam>& values)
{
    const int idx = bfind_T4oEoFI5(_.keys_asc, key, _, key, values);
    return values[idx];
}
                                #endif

                                #ifndef DEF_ref_k3fJtwyOLO4
                                #define DEF_ref_k3fJtwyOLO4
inline const s_TypeParam& ref_k3fJtwyO(s_Map_lhf7SV3Fyjf& _, const fu::str& key)
{
    return ref_MTrsOoFc(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_x21x3D_ExVC00HnUgl
                                #define DEF_x21x3D_ExVC00HnUgl
inline bool operator!=(fu::view<char> a, fu::view<char> b)
{
    return !!x3Cx3E_bv5nK4Kl(a, b);
}
                                #endif

static bool isMutRef_gDsnGKHT(const s_Flags flags)
{
    return !(~flags & (s_Flags_F_MUT | s_Flags_F_REF));
}

                                #ifndef DEF_DONT_match_zeroes
                                #define DEF_DONT_match_zeroes
inline constexpr bool DONT_match_zeroes = true;
                                #endif

                                #ifndef DEF_ref_pkMkFw6DFjh
                                #define DEF_ref_pkMkFw6DFjh
inline s_TypeParam& ref_pkMkFw6D(s_Set_6ARmtH0K78f& _, const fu::str& key, fu::vec<s_TypeParam>& values)
{
    const int idx = bfind_T4oEoFI5(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_zuiRS11g626
                                #define DEF_ref_zuiRS11g626
inline s_TypeParam& ref_zuiRS11g(s_Map_lhf7SV3Fyjf& _, const fu::str& key)
{
    return ref_pkMkFw6D(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF___oszmUOPvhUi
                                #define DEF___oszmUOPvhUi
inline static fu::view<s_Target> _oszmUOPv(const s_Target& target, fu::vec<s_Target>& targets)
{
    return (targets += s_Target(target));
}
                                #endif

                                #ifndef DEF_unpackAddrOfFn_WRkTvJWxYSg
                                #define DEF_unpackAddrOfFn_WRkTvJWxYSg
inline void unpackAddrOfFn_WRkTvJWx(fu::view<char> canon, fu::vec<s_Target>& targets)
{
    if (canon[0] == '@')
    {
        int offset = 1;
        while (offset < canon.size())
        {
            const s_Target mi = parseLocalOrGlobal_xQNS19Zn(canon, offset);
            int BL_4_v {};
            _oszmUOPv(Target_xQNS19Zn(int(unsigned(((mi._packed >> 40ull) & 0xfffffull))), int(unsigned(((mi._packed >> 20ull) & 0xfffffull))), (__extension__ (
            {
                const unsigned v = unsigned((mi._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v)), targets);
        };
    }
    else
        fu::fail((("unpackAddrOfFn: No leading @ in `"_fu + canon) + "`."_fu));

}
                                #endif

                                #ifndef DEF_add_eAAgIA81n52
                                #define DEF_add_eAAgIA81n52
inline bool add_eAAgIA81(s_Set_aQNJhbMknMf& _, const s_Target& key)
{
    fu::view<s_Target> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_B3HLYN6f(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, s_Target(key));
    return true;
}
                                #endif

static void visitScope_gDsnGKHT(const bool local_scope, fu::view<s_ScopeItem> items, fu::view<s_ScopeItem> globals, fu::view<char> id, const bool shadow, fu::vec<s_Target>& result, s_Set_aQNJhbMknMf& unique, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    int scope_iterator {};
    s_Target target {};
    bool shadows {};
    while (!shadow && (target = (local_scope ? search_z0QqoZ5t(ss._scope.items, id, scope_iterator, ss._ss.items, shadows, fu::view<s_Target>{}, ss._scope.globals, _here, ctx) : search_KHWeNbCZ(items, id, scope_iterator, globals))))
    {
        if (add_eAAgIA81(unique, target))
            result += s_Target(target);

    };
}

                                #ifndef DEF_reverse_SP9778va6S4
                                #define DEF_reverse_SP9778va6S4
inline void reverse_SP9778va(fu::view_mut<s_Target> a)
{
    const int n1 = (a.size() - 1);
    const int n2 = (a.size() >> 1);
    for (int i = 0; i < n2; i++)
        fu::view_swap(a, i, (n1 - i));

}
                                #endif

static fu::str isNotDefinedHere_gDsnGKHT(const fu::str& id)
{
    return qID_e44UlzzA(id) + " is not defined here."_fu;
}

static fu::vec<s_Target> solveAddrOfFn_FDl5ha9X(fu::str&& id, const s_TokenIdx& token, const s_Flags flags, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const bool shadow = false;
    /*MOV*/ fu::vec<s_Target> result {};
    s_Set_aQNJhbMknMf unique {};
    const s_Flags qualified = (flags & s_Flags_F_COMPOUND_ID);
    const s_Scope& s = (qualified ? dequalify_andGetScope_gDsnGKHT(id, ss, _helpers, _here, ctx, module, options) : (*(const s_Scope*)fu::NIL));
    visitScope_gDsnGKHT(!qualified, fu::get_view_start0(s.items, s.pub_items), fu::get_view_start0(s.globals, s.pub_globals), id, shadow, result, unique, ss, _here, ctx);
    reverse_SP9778va(result);
    return static_cast<fu::vec<s_Target>&&>((result ? result : fail_gDsnGKHT(isNotDefinedHere_gDsnGKHT(id), fu::view<char>{}, s_TokenIdx(token), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)));
}

                                #ifndef DEF_collectNamedArgs_qsmzHp12Z9c
                                #define DEF_collectNamedArgs_qsmzHp12Z9c
inline static s_NamedArgs_uE7WdS56SGd collectNamedArgs_qsmzHp12(fu::view<s_Node> args, int& minArity, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_NamedArgs_uE7WdS56SGd ret {};
    bool some = false;
    for (int i = 0; i < args.size(); i++)
    {
        const s_Node& arg = args[i];
        const fu::str* _0;
        ret.names.push(((arg.kind == s_Kind_argid) ? fu::str((*(_0 = &(((some = true), arg.value))) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options))) : ""_fu));
        if (arg.flags & s_Flags_F_ARGID_IS_OPTIONAL)
        {
            minArity--;
            add_ZwXYCruz(ret.optional, i);
        };
    };
    if (some)
        return /*NRVO*/ ret;
    else
        BUG_gDsnGKHT("collectNamedArgs: no named arguments here"_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_find_l600OhfD9ua
                                #define DEF_find_l600OhfD9ua
inline int find_l600OhfD(fu::view<fu::str> haystack, fu::view<char> needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

static bool reorderByArgIDs_gDsnGKHT(s_Reorder& reorder, fu::view<fu::str> names, s_BitSet&& optional, fu::view<s_Argument> host_args, const int num_usings, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    reorder.applicable = true;
    reorder.map.clear();
    int used = 0;
    int offset = 0;
    int usings_left = num_usings;
    int ha_required = 0;
    int ha_bound_optional = 0;
    for (int i = 0; i < host_args.size(); i++)
    {
        const s_Argument& host_arg = host_args[i];
        if (!(host_arg.flags & s_Flags_F_INJECTED))
        {
            int idx = find_l600OhfD(names, host_arg.name);
            if (idx < 0)
            {
                if (usings_left > 0)
                    usings_left--;
                else
                {
                    for (int i_1 = offset; i_1 < names.size(); i_1++)
                    {
                        offset++;
                        if (!names[i_1])
                        {
                            idx = i_1;
                            break;
                        };
                    };
                };
            }
            else
            {
                used++;
                remove_Na55O4zv(optional, idx);
            };
            reorder.map.push(idx);
            if (!(host_arg.dEfault || (host_arg.flags & s_Flags_F_IMPLICIT)))
                ha_required++;
            else if ((idx >= 0))
                ha_bound_optional++;

        };
    };
    if ((ha_bound_optional + ha_required) > (names.size() + num_usings))
        return false;
    else if (usings_left)
        BUG_gDsnGKHT("reorderByArgIDs: usings_left != 0"_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        if (used != names.size())
        {
            for (int i_1 = 0; i_1 < names.size(); i_1++)
            {
                if (!names[i_1])
                    used++;

            };
            if ((used + popcount_ZwXYCruz(optional)) != names.size())
                return false;

        };

        {
            int trailing_misses = 0;
            int non_trailing_misses = 0;
            for (int i_1 = reorder.map.size(); i_1-- > 0; )
            {
                if ((reorder.map[i_1] >= 0))
                {
                    while (i_1-- > 0)
                    {
                        if (reorder.map[i_1] < 0)
                            non_trailing_misses++;

                    };
                    break;
                }
                else
                    trailing_misses++;

            };
            const int trailing_usings = max_yeUdQhUA((num_usings - non_trailing_misses), 0);
            if (trailing_misses > trailing_usings)
                reorder.map.shrink((reorder.map.size() - (trailing_misses - trailing_usings)));

        };
        if (reorder.map.size() != names.size())
            return true;
        else
        {
            for (int i_1 = 0; i_1 < reorder.map.size(); i_1++)
            {
                if (reorder.map[i_1] != i_1)
                    return true;

            };
            clear_iUdwqyBn(reorder);
            return true;
        };
    };
}

                                #ifndef DEF___ekv6ZxcMC0h
                                #define DEF___ekv6ZxcMC0h
inline static void _ekv6ZxcM(fu::view<char> n, const int i, fu::view<char> name, int& count, int& first)
{
    if ((n == name) && !count++)
        first = i;

}
                                #endif

                                #ifndef DEF_each_ABrmyT5bKU2
                                #define DEF_each_ABrmyT5bKU2
inline void each_ABrmyT5b(fu::view<fu::str> a, fu::view<char> name, int& count, int& first)
{
    for (int i = 0; i < a.size(); i++)
        _ekv6ZxcM(a[i], i, name, count, first);

}
                                #endif

static fu::str ERRMSG_findUnmatchedArgName_gDsnGKHT(const s_Reorder& reorder, fu::view<fu::str> names, fu::view<s_Argument> host_args, const s_Target& target, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_BitSet used {};
    s_BitSet matched {};
    for (int i = 0; i < reorder.map.size(); i++)
    {
        const int pos = reorder.map[i];
        if ((pos >= 0))
        {
            add_ZwXYCruz(used, pos);
            add_ZwXYCruz(matched, i);
        };
    };
    fu::str fOr = (target ? (" for "_fu + str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) : fu::str{});
    for (int i_1 = 0; i_1 < names.size(); i_1++)
    {
        fu::view<char> name = names[i_1];
        const int i_2 = i_1;
        if (!(has_ZwXYCruz(used, i_2)))
        {
            int count = 0;
            int first = names.size();
            each_ABrmyT5b(names, name, count, first);
            if (first < i_2)
                return x7E_3lDd4lqo((((((("Duplicate :named arguments"_fu + fOr) + ": "_fu) + qBAD_KW_e44UlzzA("arg"_fu)) + " "_fu) + qBAD_e44UlzzA(names[i_2])) + " explicitly provided "_fu), fu::i64dec(count)) + " times."_fu;
            else
                return ((((("Named :argument mismatch"_fu + fOr) + ": no "_fu) + qBAD_KW_e44UlzzA("arg"_fu)) + " "_fu) + qBAD_e44UlzzA(names[i_2])) + "."_fu;

        };
    };
    for (int i_2 = 0; i_2 < host_args.size(); i_2++)
    {
        const s_Argument& host_arg = host_args[i_2];
        const int i_3 = i_2;
        if (!host_arg.dEfault && !has_ZwXYCruz(matched, i_3))
            return x7E_3lDd4lqo(((((host_arg.flags & s_Flags_F_TYPENAME) ? "Missing type argument"_fu : "Missing required argument"_fu) + fOr) + ": "_fu), str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options));

    };
    return ("Named :argument mismatch"_fu + fOr) + ": BUG failing to explain what's wrong."_fu;
}

static bool trySolveTypeParams_gDsnGKHT(const s_Node& node, /*MOV*/ s_Type&& type, fu::str& error, bool invariant, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.kind == s_Kind_call)
    { {
        fu::view<s_Node> items = node.items;
        if (items.size() == 1)
        {
            s_Type _0 {};
            fu::never BL_3_v {};
            s_Type _1 {};
            fu::never BL_5_v {};
            s_Type _2 {};
            fu::never BL_7_v {};
            s_Type _3 {};
            fu::never BL_9_v {};
            fu::never BL_11_v {};
            /*MOV*/ s_Type t = ((node.value == "&"_fu) ? ((_0 = tryClear_ref_9CJmuVSD(type, _here, ctx)) ? static_cast<s_Type&&>(_0) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_fu + ("Not a reference: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));

                return false;
            (void)0;}), static_cast<fu::never&&>(BL_3_v))) : ((node.value == "&mut"_fu) ? ((_1 = tryClear_mutref_9CJmuVSD(type, _here, ctx)) ? static_cast<s_Type&&>(_1) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_fu + ("Not a mutref: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));

                return false;
            (void)0;}), static_cast<fu::never&&>(BL_5_v))) : ((node.value == "[]"_fu) ? ((_2 = (is_zeroes_9CJmuVSD(type.vtype) ? s_Type(t_zeroes) : ((invariant = true), tryClear_array_9CJmuVSD(type, _here, ctx, module)))) ? static_cast<s_Type&&>(_2) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_fu + ("Not an array: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));

                return false;
            (void)0;}), static_cast<fu::never&&>(BL_7_v))) : ((node.value == "[..]"_fu) ? ((_3 = (is_zeroes_9CJmuVSD(type.vtype) ? s_Type(t_zeroes) : ((invariant = true), tryClear_sliceable_1qjplDUo(type.vtype, _here, ctx, module)))) ? static_cast<s_Type&&>(_3) : (__extension__ (
            {
                if (error)
                    error += ("\n\t    "_fu + ("Not sliceable: "_fu + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));

                return false;
            (void)0;}), static_cast<fu::never&&>(BL_9_v))) : (__extension__ (
            {
                goto BL_1;
            (void)0;}), static_cast<fu::never&&>(BL_11_v))))));
            const s_Node* _4;
            return trySolveTypeParams_gDsnGKHT((*(_4 = &(node.items[0])) ? *_4 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)), static_cast<s_Type&&>(t), error, invariant, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
      } BL_1:;
    }
    else if (node.kind == s_Kind_typeparam)
    { {
        const fu::str& id = (node.value ? node.value : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        type = relax_typeParam_9CJmuVSD(s_Type(type));
        s_TypeParam& param = ref_zuiRS11g(ss._typeParams, id);
        if (param)
        {
            if (param.flags & s_TypeParamFlags_TP_isArgSpec)
                goto BL_12;
            else
            {
                if (invariant)
                {
                    if (!isAssignable_9CJmuVSD(type, param.matched, DONT_match_zeroes, false, _here, ctx))
                    {
                        if (error)
                        {
                            error += ("\n\t    "_fu + ((("Incompatible types for "_fu + qBAD_e44UlzzA(id)) + ": "_fu) + explainTypeDiff_gDsnGKHT(param.matched, type, " -> "_fu, ss, _here, ctx, module, options)));
                        };
                        return false;
                    };
                }
                else
                {
                    /*MOV*/ s_Type uNion = type_trySuper_9CJmuVSD(param.matched, type, false, _here, ctx);
                    if (!uNion)
                    {
                        if (error)
                        {
                            error += ("\n\t    "_fu + ((("Incompatible types for "_fu + qBAD_e44UlzzA(id)) + ": "_fu) + explainTypeDiff_gDsnGKHT(param.matched, type, " <-> "_fu, ss, _here, ctx, module, options)));
                        };
                        return false;
                    }
                    else
                        type = static_cast<s_Type&&>(uNion);

                };
                if (param.invariant && !isAssignable_9CJmuVSD(param.invariant, type, DONT_match_zeroes, false, _here, ctx))
                {
                    if (error)
                        error += ("\n\t    "_fu + ((("Incompatible types for "_fu + qBAD_e44UlzzA(id)) + ": "_fu) + explainNotAssignable_gDsnGKHT(param.invariant, type, _current_fn, ss, _here, ctx, module, options)));

                    return false;
                };
            };
        };
        param.matched = type;
        if (invariant)
            param.invariant = static_cast<s_Type&&>(type);

        return true;
      } BL_12:;
    }
    else if (node.kind == s_Kind_typeunion)
    {
        const int error0 = error.size();
        s_Map_lhf7SV3Fyjf typeParams0 { ss._typeParams };
        for (int i = 0; i < node.items.size(); i++)
        {
            if (trySolveTypeParams_gDsnGKHT(node.items[i], static_cast<s_Type&&>(type), error, invariant, _current_fn, ss, _helpers, _here, ctx, module, options))
            {
                error.shrink(error0);
                return true;
            }
            else
                ss._typeParams = typeParams0;

        };
        return false;
    };
    if (((node.kind == s_Kind_call) && (node.flags & s_Flags_F_TEMPLATE) && (node.value != "typeof"_fu)) || (node.kind == s_Kind___serialized_addrof_type_fn))
    {
        fu::vec<s_Target> targets {};
        if (node.kind == s_Kind___serialized_addrof_type_fn)
            unpackAddrOfFn_WRkTvJWx(node.value, targets);
        else
            targets = solveAddrOfFn_FDl5ha9X(fu::str(node.value), node.token, (node.flags & s_Flags_F_COMPOUND_ID), ss, _helpers, _here, ctx, module, options);

        fu::view<char> pattern = tryGetPattern_Ot6wT82z(type.vtype.canon);
        if (pattern)
        {
            s_Reorder reorder {};
            int TODO_FIX_what_about_opt_args = 0;
            s_NamedArgs_uE7WdS56SGd namedArgs = ((node.flags & s_Flags_F_CALL_HAS_NAMED_ARGS) ? collectNamedArgs_qsmzHp12(node.items, TODO_FIX_what_about_opt_args, ss, _helpers, _here, ctx, module, options) : s_NamedArgs_uE7WdS56SGd{});
            int offset = 0;
            for (; ; )
            {
                const s_Target spec_of = parseGlobal_xQNS19Zn(pattern, offset);
                const int start = offset;
                bool isLastSubPattern {};
                scan(pattern, '|', offset, isLastSubPattern);

                { {
                    fu::view<char> pattern_1 = fu::get_view(pattern, start, offset);
                    const int targetsIdx = find_H5f3kK8G(targets, spec_of);
                    if (!(targetsIdx < 0))
                    {
                        targets.splice(targetsIdx, 1);
                        clear_iUdwqyBn(reorder);
                        if (namedArgs.names)
                        {
                            fu::view<s_Argument> host_args = EXT_gDsnGKHT(spec_of, ss, ctx, module).args;
                            if (!reorderByArgIDs_gDsnGKHT(reorder, namedArgs.names, s_BitSet(namedArgs.optional), host_args, 0, ss, _helpers, _here, ctx, module, options))
                            {
                                if (error)
                                    error += ("\n\t    "_fu + ERRMSG_findUnmatchedArgName_gDsnGKHT(reorder, namedArgs.names, host_args, spec_of, _current_fn, ss, _here, ctx, module, options));

                                goto BL_37;
                            };
                        };
                        int numArgs = 0;

                        {
                            int offset_1 = 0;
                            for (; ; )
                            {
                                const int start_1 = offset_1;
                                bool isLastArgSpecType {};
                                scan(pattern_1, ':', offset_1, isLastArgSpecType);

                                { {
                                    fu::view<char> argSpecType = fu::get_view(pattern_1, start_1, offset_1);
                                    const int i = numArgs++;
                                    if (!((i >= node.items.size())))
                                    {
                                        const int callsiteIndex = (reorder ? reorder.map[i] : i);
                                        if (!(callsiteIndex < 0))
                                        {
                                            const s_Node& node_1 = node.items[callsiteIndex];
                                            /*MOV*/ s_Type type_1 = s_Type { parseType_1qjplDUo(argSpecType, _here, ctx, module), s_Lifetime{} };
                                            const s_Node& node_2 = ((node_1.kind == s_Kind_argid) ? only_CiCfNZS0(node_1.items) : node_1);
                                            if (!trySolveTypeParams_gDsnGKHT(node_2, static_cast<s_Type&&>(type_1), error, true, _current_fn, ss, _helpers, _here, ctx, module, options))
                                                goto BL_37;
                                            else
                                                goto BL_45;

                                        };
                                    };
                                    if (error)
                                        error += ("\n\t    "_fu + x7E_3lDd4lqo((x7E_3lDd4lqo("Missing type argument for "_fu, str_FDl5ha9X(spec_of, false, ss, _here, ctx, module, options)) + ": "_fu), str_wyx7msfr(EXT_gDsnGKHT(spec_of, ss, ctx, module).args[i], false, _current_fn, ss, _here, ctx, module, options)));

                                    goto BL_37;
                                  } BL_45:;
                                };
                                if (isLastArgSpecType)
                                    break;
                                else
                                    offset_1++;

                            };
                        };
                        if (numArgs != node.items.size())
                        {
                            if (error)
                                error += ("\n\t    "_fu + (x7E_3lDd4lqo("Too many type arguments for "_fu, str_FDl5ha9X(spec_of, false, ss, _here, ctx, module, options)) + "."_fu));

                        }
                        else
                            return true;

                    };
                  } BL_37:;
                };
                if (isLastSubPattern)
                    break;
                else
                    offset++;

            };
        };
        if (error && targets)
        {
            for (int i = 0; i < targets.size(); i++)
            {
                if (error)
                    error += ("\n\t    "_fu + ((x7E_3lDd4lqo("Not produced by "_fu, str_FDl5ha9X(targets[i], false, ss, _here, ctx, module, options)) + ": "_fu) + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));

            };
        };
        return false;
    }
    else
    {
        s_Type expect = evalTypeAnnot_gDsnGKHT(node, false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (!isAssignable_9CJmuVSD(expect, type, DONT_match_zeroes, false, _here, ctx))
        {
            if (error)
                error += ("\n\t    "_fu + ("Incompatible types: "_fu + explainNotAssignable_gDsnGKHT(expect, type, _current_fn, ss, _here, ctx, module, options)));

            return false;
        }
        else
            return true;

    };
}

                                #ifndef DEF_mangleArgTypes_AJPeBvoSWk1
                                #define DEF_mangleArgTypes_AJPeBvoSWk1
inline static fu::str mangleArgTypes_AJPeBvoS(fu::view<s_Type> args)
{
    /*MOV*/ fu::str mangle = ""_fu;
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const s_Type& arg = args[i];
        if (numNonInjected++)
            mangle += ',';

        if (arg)
            mangle += serializeType_1qjplDUo(arg.vtype, "mangle[$T]"_fu);

    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF_add_eHVOG4piV4k
                                #define DEF_add_eHVOG4piV4k
inline bool add_eHVOG4pi(s_Set_6ARmtH0K78f& _, const fu::str& key)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, fu::str(key));
    return true;
}
                                #endif

                                #ifndef DEF_remove_WUsyyR27sui
                                #define DEF_remove_WUsyyR27sui
inline bool remove_WUsyyR27(s_Set_6ARmtH0K78f& _, fu::view<char> key)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
        {
            _.keys_asc.splice(i, 1);
            return true;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return false;
}
                                #endif

                                #ifndef DEF___HN6npIaNAEc
                                #define DEF___HN6npIaNAEc
inline static void _HN6npIaN(const s_Target& spec, s_SolverState& ss, const s_Module& module)
{
    intoTombstone_gDsnGKHT(spec, ss, module);
}
                                #endif

                                #ifndef DEF_each_3S6DiPHvITf
                                #define DEF_each_3S6DiPHvITf
inline void each_3S6DiPHv(const s_Map_CIvvfLLMMzl& _, s_SolverState& ss, const s_Module& module)
{
    for (int i = 0; i < _.vals.size(); i++)
        _HN6npIaN(_.vals[i], ss, module);

}
                                #endif

static void intoTombstone_gDsnGKHT(const s_Target& t, s_SolverState& ss, const s_Module& module)
{
    s_Extended& ext = EXT_mut_gDsnGKHT(t, ss, module);
    ext = s_Extended{};
    s_Overload& o = GET_mut_gDsnGKHT(t, ss, module);
    o = s_Overload{};
    o.kind = s_Kind___tombstone;
    fu::vec<s_ChildTarget> children { EPH_gDsnGKHT(t, ss, module).children };
    for (int i = 0; i < children.size(); i++)
        intoTombstone_gDsnGKHT(s_Target(children[i].target), ss, module);

    s_Map_CIvvfLLMMzl specs = s_Map_CIvvfLLMMzl { {}, fu::vec<s_Target>(EPH_gDsnGKHT(t, ss, module).specs.vals) };
    each_3S6DiPHv(specs, ss, module);
}

static void destroyOverload_gDsnGKHT(const s_Target& t, s_SolverState& ss, const s_Module& module)
{
    intoTombstone_gDsnGKHT(t, ss, module);
}

static s_Map_CIvvfLLMMzl& getSpecs_gDsnGKHT(const int parent_idx, s_SolverState& ss)
{
    return EPH_mut_gDsnGKHT(parent_idx, ss).specs;
}

                                #ifndef DEF_bfind_i5SCsmCtWgi
                                #define DEF_bfind_i5SCsmCtWgi
inline static int bfind_i5SCsmCt(fu::view<fu::str> keys_asc, fu::view<char> key, s_Set_6ARmtH0K78f& _, const fu::str& key_1, fu::vec<s_Target>& values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, s_Target{});
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_Pj5EznQtl84
                                #define DEF_ref_Pj5EznQtl84
inline s_Target& ref_Pj5EznQt(s_Set_6ARmtH0K78f& _, const fu::str& key, fu::vec<s_Target>& values)
{
    const int idx = bfind_i5SCsmCt(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_ZEhRUdG2Qoj
                                #define DEF_ref_ZEhRUdG2Qoj
inline s_Target& ref_ZEhRUdG2(s_Map_CIvvfLLMMzl& _, const fu::str& key)
{
    return ref_Pj5EznQt(_.keys, key, _.vals);
}
                                #endif

                                #ifndef DEF_id_sUlSUW5PT2a
                                #define DEF_id_sUlSUW5PT2a
inline static fu::str id_sUlSUW5P(const s_Target& target, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (is_SPECFAIL_gDsnGKHT(target))
        return qBAD_e44UlzzA("SPEC_FAIL"_fu);
    else
        return str_FDl5ha9X(target, false, ss, _here, ctx, module, options);

}
                                #endif

static void setSpec_gDsnGKHT(const fu::str& mangle, const s_Target& target, const bool nx, const bool allowReplaceNonSpecfails, const int parent_idx, fu::view<char> error, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (error)
        BUG_gDsnGKHT("doTrySpec: setSpec on error path"_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        s_Target& t = ref_ZEhRUdG2(getSpecs_gDsnGKHT(parent_idx, ss), mangle);
        if ((!t == nx) && (!t || is_SPECFAIL_gDsnGKHT(t) || allowReplaceNonSpecfails))
            t = target;
        else
        {
            int BL_5_v {};
            BUG_gDsnGKHT(((((((x7E_3lDd4lqo((x7E_3lDd4lqo("About to screw up royally, replacing spec: "_fu, fu::i64dec((__extension__ (
            {
                const s_Target& t_1 = t;
                BL_5_v = (int(unsigned(((t_1._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_5_v))) + " with "_fu), fu::i64dec(int(unsigned(((target._packed >> 20ull) & 0xfffffull))))) + ", mangle: "_fu) + mangle) + ", that's: "_fu) + id_sUlSUW5P(t, ss, _here, ctx, module, options)) + " becoming "_fu) + id_sUlSUW5P(target, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        };
    };
}

static void resetSpec_gDsnGKHT(const s_Target& spec, const bool allowReplaceNonSpecfails, const int parent_idx, fu::view<char> error, const s_Set_6ARmtH0K78f& mangles, s_Target& currentSpec, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (spec != currentSpec)
    {
        currentSpec = spec;
        int BL_2_v {};
        for (int i = 0; i < (__extension__ (
        {
            const s_Set_6ARmtH0K78f& _ = mangles;
            BL_2_v = (_.keys_asc.size());
        (void)0;}), BL_2_v); i++)
        {
            const fu::str* BL_5_v;
            setSpec_gDsnGKHT((__extension__ (
            {
                const s_Set_6ARmtH0K78f& _ = mangles;
                const int i_1 = i;
                BL_5_v = &(_.keys_asc[i_1]);
            (void)0;}), *BL_5_v), spec, false, allowReplaceNonSpecfails, parent_idx, error, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static const s_Target& SPECFAIL_gDsnGKHT(fu::view<char> reason, const int parent_idx, fu::str& error, const s_Target& SPECFAIL_RentrySafety, const int err0, const s_Set_6ARmtH0K78f& mangles, s_Target& currentSpec, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (error)
    {
        error += reason;
        if (!(error.size() > err0))
            BUG_gDsnGKHT("SPECFAIL: no error output"_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
        resetSpec_gDsnGKHT(SPECFAIL_RentrySafety, false, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);

    return SPECFAIL_RentrySafety;
}

                                #ifndef DEF_FN_BODY_BACK
                                #define DEF_FN_BODY_BACK
inline constexpr int FN_BODY_BACK = -1;
                                #endif

static bool isNativeBody_gDsnGKHT(const s_Node& n_body)
{
    if (n_body.kind == s_Kind_call)
        return n_body.value == "__native"_fu;
    else
        return false;

}

                                #ifndef DEF_useConsumedType_ifNative_MP6Qxu1Mje4
                                #define DEF_useConsumedType_ifNative_MP6Qxu1Mje4
inline static bool useConsumedType_ifNative_MP6Qxu1M(const s_TypeParam& tp)
{
    return s_TypeParamFlags((tp.flags & s_TypeParamFlags((s_TypeParamFlags_TP_isArgSpec | s_TypeParamFlags_TP_isTypenameArgSpec)))) == s_TypeParamFlags_TP_isArgSpec;
}
                                #endif

                                #ifndef DEF___Ze5YQ6p3T6g
                                #define DEF___Ze5YQ6p3T6g
inline static void _Ze5YQ6p3(s_TypeParam& tp)
{
    if (useConsumedType_ifNative_MP6Qxu1M(tp))
        tp.flags |= s_TypeParamFlags_TP_needsConsumedTypes;

}
                                #endif

                                #ifndef DEF_each_HVikC3FonLg
                                #define DEF_each_HVikC3FonLg
inline void each_HVikC3Fo(s_Map_lhf7SV3Fyjf& _)
{
    for (int i = 0; i < _.vals.size(); i++)
        _Ze5YQ6p3(_.vals.mutref(i));

}
                                #endif

static bool type_has_gDsnGKHT(const s_Type& type, fu::view<char> tag, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (tag == "trivial"_fu)
        return is_trivial_1qjplDUo(type.vtype, _here, ctx, module);
    else if (tag == "copy"_fu)
        return is_rx_copy_9CJmuVSD(type.vtype);
    else if (tag == "arithmetic"_fu)
        return is_arithmetic_hxWWgdZ1(type.vtype);
    else if (tag == "primitive"_fu)
        return is_primitive_hxWWgdZ1(type.vtype);
    else if (tag == "bitfield"_fu)
        return is_bitfield_hxWWgdZ1(type.vtype);
    else if (tag == "integral"_fu)
        return is_integral_hxWWgdZ1(type.vtype);
    else if (tag == "unsigned"_fu)
        return is_unsigned_hxWWgdZ1(type.vtype);
    else if (tag == "floating_point"_fu)
        return is_floating_pt_hxWWgdZ1(type.vtype);
    else if (tag == "mutref"_fu)
        return is_mutref_9CJmuVSD(type, _here, ctx);
    else if (tag == "enum"_fu)
        return is_enum_hxWWgdZ1(type.vtype);
    else if (tag == "flags"_fu)
        return is_flags_hxWWgdZ1(type.vtype);
    else if (tag == "reinterpretable"_fu)
        return is_reinterpretable_1qjplDUo(type.vtype, _here, ctx, module);
    else if (tag == "zero_size"_fu)
        return is_zst_1qjplDUo(type.vtype, _here, ctx, module);
    else
        BUG_gDsnGKHT((("Unknown type tag: `"_fu + tag) + "`."_fu), ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_if_only_iY1ARePCP71
                                #define DEF_if_only_iY1ARePCP71
inline const s_Node& if_only_iY1ARePC(fu::view<s_Node> s)
{
    if (s.size() == 1)
        return s[0];
    else
        return (*(const s_Node*)fu::NIL);

}
                                #endif

static s_SolvedNode solveCall_gDsnGKHT(const s_Node& node, fu::view<s_Target> targets, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<s_SolvedNode> args = solveNodes_gDsnGKHT(node.items, s_DeadBreak_DeadBreak_Only_WhileSolvingRecursion, (*(const s_Type*)fu::NIL), (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (is_AssumeNever_WhileSolvingRecursion_9CJmuVSD(if_last_iOPO4E2X(args).type.vtype))
        return s_SolvedNode(last_31malqbt(args));
    else
        return solveCall_FDl5ha9X(fu::str(node.value), static_cast<fu::vec<s_SolvedNode>&&>(args), node.flags, targets, _current_fn, ss, _helpers, _here, ctx, module, options);

}

static bool evalTypePattern_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.kind == s_Kind_and)
    {
        for (int i = 0; i < node.items.size(); i++)
        {
            if (!evalTypePattern_gDsnGKHT(node.items[i], _current_fn, ss, _helpers, _here, ctx, module, options))
                return false;

        };
        return true;
    }
    else if (node.kind == s_Kind_or)
    {
        s_Map_lhf7SV3Fyjf undo { ss._typeParams };
        for (int i = 0; i < node.items.size(); i++)
        {
            if (evalTypePattern_gDsnGKHT(node.items[i], _current_fn, ss, _helpers, _here, ctx, module, options))
                return true;
            else
                ss._typeParams = undo;

        };
        return false;
    }
    else if (node.kind == s_Kind_typeassert)
    {
        const s_Node* _0;
        const s_Node& left = (*(_0 = &(node.items[0])) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        const s_Node* _1;
        const s_Node& right = (*(_1 = &(node.items[1])) ? *_1 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        /*MOV*/ s_Type actual = evalTypeAnnot_gDsnGKHT(left, true, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (right.kind == s_Kind_typetag)
        {
            return type_has_gDsnGKHT(actual, (right.value ? right.value : fail_gDsnGKHT("Falsy type tag."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            fu::str error {};
            const bool ok = trySolveTypeParams_gDsnGKHT(right, static_cast<s_Type&&>(actual), error, false, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (error)
                BUG_gDsnGKHT("Inefficient: trySolveTypeParams pushing errors when told not to (falsy errout)."_fu, ss, _helpers, _here, ctx, module, options);
            else
            {
                if (ok)
                {
                    const s_Node* _2;
                    const s_Node& left_1 = (*(_2 = &((((left.kind == s_Kind_call) && (left.value == "typeof"_fu)) ? if_only_iY1ARePC(left.items) : (*(const s_Node*)fu::NIL)))) ? *_2 : left);
                    if (left_1.kind == s_Kind_typeparam)
                    {
                        const fu::str& id = left_1.value;
                        if (get_usbzfpQ2(ss._typeParams, id).flags & s_TypeParamFlags_TP_needsConsumedTypes)
                        {
                            /*MOV*/ s_Type expect = evalTypeAnnot_gDsnGKHT(right, false, _current_fn, ss, _helpers, _here, ctx, module, options);
                            s_TypeParam& tp = ref_zuiRS11g(ss._typeParams, id);
                            s_Type _3 {};
                            tp.consumed = (tp.consumed ? ((_3 = type_tryIntersect_9CJmuVSD(tp.consumed, expect, _here, ctx)) ? static_cast<s_Type&&>(_3) : fail_gDsnGKHT("typeassert intersect fail."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)) : static_cast<s_Type&&>(expect));
                        };
                    };
                };
                return ok;
            };
        };
    }
    else if (node.kind == s_Kind_not)
        return !evalTypePattern_gDsnGKHT(only_CiCfNZS0(node.items), _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (node.kind == s_Kind_call)
    {
        s_SolvedNode _4 {};
        const s_StaticEval res = (_4 = solveCall_gDsnGKHT(node, fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options), tryAbstractEvalAsBool_gDsnGKHT(static_cast<s_SolvedNode&&>(_4), false, _current_fn, ss, _helpers, _here, ctx, module, options));
        if (res == s_StaticEval_SE_True)
            return true;
        else if (res == s_StaticEval_SE_False)
            return false;

    };
    fail_gDsnGKHT("Invalid type pattern."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static const s_Node& n_fn_wyx7msfr(const s_Template& tEmplate)
{
    return tEmplate.node;
}

static fu::view<s_Node> sig_iUdwqyBn(const s_Template& tEmplate)
{
    return n_fn_wyx7msfr(tEmplate).items;
}

static s_Node& n_fn_iUdwqyBn(s_Template& tEmplate)
{
    return tEmplate.node;
}

static fu::view_mut<s_Node> sig_wyx7msfr(s_Template& tEmplate)
{
    return n_fn_iUdwqyBn(tEmplate).items;
}

                                #ifndef DEF___G59nKKe7r4e
                                #define DEF___G59nKKe7r4e
inline static void _G59nKKe7(s_TypeParam& tp)
{
    if (useConsumedType_ifNative_MP6Qxu1M(tp))
        tp.matched = tp.consumed;

}
                                #endif

                                #ifndef DEF_each_rZH8cGMFUMb
                                #define DEF_each_rZH8cGMFUMb
inline void each_rZH8cGMF(s_Map_lhf7SV3Fyjf& _)
{
    for (int i = 0; i < _.vals.size(); i++)
        _G59nKKe7(_.vals.mutref(i));

}
                                #endif

                                #ifndef DEF_starts_V9JEq7nYbSk
                                #define DEF_starts_V9JEq7nYbSk
inline bool starts_V9JEq7nY(fu::view<s_Target> a, const s_Target& with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF___oi2QwZoXtah
                                #define DEF___oi2QwZoXtah
inline static void _oi2QwZoX(s_ConvCache_ColsAndBakes& cc, const s_Target& t)
{
    for (int i = cc.columns.paths.size(); i-- > 0; )
    {
        if (starts_V9JEq7nY(cc.columns.paths[i], t))
        {
            cc.columns.types.splice(i, 1);
            cc.columns.paths.splice(i, 1);
            cc.columns.must_see.splice(i, 1);
        };
    };
}
                                #endif

                                #ifndef DEF_iF_IrsqpmktaTi
                                #define DEF_iF_IrsqpmktaTi
inline bool iF_Irsqpmkt(const s_Set_7aI0knTMWY7& _, const s_ValueType& key, fu::view_mut<s_ConvCache_ColsAndBakes> values, const s_Target& t)
{
    fu::view<s_ValueType> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_VHap4TnO(keys_asc[i], key);
        if (cmp == 0)
        {
            _oi2QwZoX(values.mutref(i), t);
            return true;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return false;
}
                                #endif

                                #ifndef DEF_iF_De3oNmgAzSb
                                #define DEF_iF_De3oNmgAzSb
inline bool iF_De3oNmgA(s_Map_j5rW2s1zJ22& _, const s_ValueType& key, const s_Target& t)
{
    return iF_Irsqpmkt(_.keys, key, _.vals, t);
}
                                #endif

                                #ifndef DEF___IRuvE01pXL3
                                #define DEF___IRuvE01pXL3
inline static void _IRuvE01p(s_ConvCache_ColsAndBakes& cc, const s_Target& t)
{
    for (int i = cc.columns.paths.size(); i-- > 0; )
    {
        if (has_AOZqRgIb(cc.columns.paths[i], t))
        {
            cc.columns.types.splice(i, 1);
            cc.columns.paths.splice(i, 1);
            cc.columns.must_see.splice(i, 1);
        };
    };
}
                                #endif

                                #ifndef DEF_each_dfrzWqzbeK2
                                #define DEF_each_dfrzWqzbeK2
inline void each_dfrzWqzb(s_Map_j5rW2s1zJ22& _, const s_Target& t)
{
    for (int i = 0; i < _.vals.size(); i++)
        _IRuvE01p(_.vals.mutref(i), t);

}
                                #endif

static void Scope_pop_gDsnGKHT(const s_ScopeMemo& memo, s_SolverState& ss, fu::vec<s_Helpers>& _helpers)
{
    for (int i = memo.usings_len; i < ss._scope.usings.size(); i++)
    {
        const s_Target& t = ss._scope.usings[i];
        iF_De3oNmgA(ss._conv_cache, s_ValueType{}, t);
    };
    for (int i_1 = memo.converts_len; i_1 < ss._scope.converts.size(); i_1++)
    {
        const s_Target& t = ss._scope.converts[i_1];
        each_dfrzWqzb(ss._conv_cache, t);
    };
    ss._scope.items.shrink(memo.items_len);
    ss._scope.implicits.shrink(memo.implicits_len);
    ss._scope.imports.shrink(memo.imports_len);
    ss._scope.privates.shrink(memo.privates_len);
    ss._scope.usings.shrink(memo.usings_len);
    ss._scope.converts.shrink(memo.converts_len);
    _helpers.shrink(memo.helpers_len);
}

                                #ifndef DEF_if_last_az3nwhxi7fj
                                #define DEF_if_last_az3nwhxi7fj
inline const s_ScopeSkip& if_last_az3nwhxi(fu::view<s_ScopeSkip> s)
{
    if (s.size())
        return s[(s.size() - 1)];
    else
        return (*(const s_ScopeSkip*)fu::NIL);

}
                                #endif

                                #ifndef DEF_last_H9myks7TaW4
                                #define DEF_last_H9myks7TaW4
inline s_ScopeSkip& last_H9myks7T(fu::view_mut<s_ScopeSkip> s)
{
    return s.mutref((s.size() - 1));
}
                                #endif

static void ScopeSkip_push_gDsnGKHT(fu::vec<s_ScopeSkip>& scope_skip, const int start, const int end, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if ((start <= end))
    {
        if (!(end == start))
        {
            const s_ScopeSkip& last = if_last_az3nwhxi(scope_skip);
            if ((last.end <= start))
            {
                if (scope_skip && (last.end == start))
                    last_H9myks7T(scope_skip).end = end;
                else
                {
                    scope_skip += s_ScopeSkip { start, end };
                };
            }
            else
                BUG_gDsnGKHT("ScopeSkip_push: last.end > start."_fu, ss, _helpers, _here, ctx, module, options);

        };
    }
    else
        BUG_gDsnGKHT("ScopeSkip_push: bad args."_fu, ss, _helpers, _here, ctx, module, options);

}

static bool Scope_import_gDsnGKHT(const int modid, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{

    {
        fu::view<int> items = ss._scope.imports;
        fu::view<s_ScopeSkip> scope_skip = ss._ss.imports;
        const int start = 0;
        const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const s_ScopeSkip& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const int m = items[i_1];
                    if (m == modid)
                        return false;

                };
                i0 = ss_1.end;
            };
        };
    };
    if (modid)
    {
        ss._scope.imports += modid;
        _Scope_import__forceCopy_gDsnGKHT(modid, false, ss, ctx);
        return true;
    }
    else
        BUG_u9Gbkniv("Attempting to import modid-0."_fu, _here, ctx);

}

static void Scope_import_privates_gDsnGKHT(const int modid, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{

    {
        fu::view<int> items = ss._scope.privates;
        fu::view<s_ScopeSkip> scope_skip = ss._ss.privates;
        const int start = 0;
        const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
        int i0 = start;
        for (int i = 0; i < (scope_skip.size() + 1); i++)
        {
            const s_ScopeSkip& ss_1 = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
            if (!((ss_1.end <= i0)))
            {
                const int i1 = ss_1.start;
                for (int i_1 = i0; i_1 < i1; i_1++)
                {
                    const int m = items[i_1];
                    if (m == modid)
                        return;

                };
                i0 = ss_1.end;
            };
        };
    };
    if (modid)
    {
        ss._scope.privates += modid;
        _Scope_import__forceCopy_gDsnGKHT(modid, true, ss, ctx);
    }
    else
        BUG_u9Gbkniv("Attempting to import_privates modid-0."_fu, _here, ctx);

}

                                #ifndef DEF_update_uRJCOLyeOx3
                                #define DEF_update_uRJCOLyeOx3
inline bool update_uRJCOLye(s_Set_6ARmtH0K78f& _, const fu::str& key, fu::vec<s_Type>& values, const s_Type& value)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
        {
            values.mutref(i) = s_Type(value);
            return false;
        }
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, fu::str(key));
    values.insert(i, s_Type(value));
    return true;
}
                                #endif

                                #ifndef DEF_set_ivGaGsmAcDe
                                #define DEF_set_ivGaGsmAcDe
inline bool set_ivGaGsmA(s_Map_pdTv4gjINIj& _, const fu::str& key, const s_Type& value)
{
    return update_uRJCOLye(_.keys, key, _.vals, value);
}
                                #endif

static void createTypedef_gDsnGKHT(const fu::str& id, const s_Type& annot, const s_Flags flags, const s_TokenIdx& token, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_UserType& s = tryLookupUserType_1qjplDUo(annot.vtype, _here, ctx, module);
    const s_Target target = createRawTypedef_gDsnGKHT(id, s_Type(annot), flags, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
    if (s.target)
    {
        const s_Flags TODO_FIX_flags0 = GET_gDsnGKHT(target, ss, _here, ctx, module).flags;
        EXT_mut_gDsnGKHT(target, ss, module) = s_Extended(EXT_gDsnGKHT(s.target, ss, ctx, module));
        GET_mut_gDsnGKHT(target, ss, module) = s_Overload(GET_gDsnGKHT(s.target, ss, _here, ctx, module));
        s_Overload& o = GET_mut_gDsnGKHT(target, ss, module);
        o.flags |= (TODO_FIX_flags0 & s_Flags_F_PUB);
    };
    if (token)
        GET_mut_gDsnGKHT(target, ss, module).solved.token = s_TokenIdx(token);

}

                                #ifndef DEF___R3r5rzw3AY9
                                #define DEF___R3r5rzw3AY9
inline static void _R3r5rzw3(const fu::str& id, const s_TypeParam& tp, s_SpecExtras& res, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Type& type = tp.matched;
    if (!(!type))
    {
        if (tp.flags & s_TypeParamFlags_TP_isArgSpec)
            set_ivGaGsmA(res.arg_spec_types, id, type);
        else
        {
            createTypedef_gDsnGKHT(id, type, s_Flags{}, s_TokenIdx{}, ss, _here, ctx, module);
        };
    };
}
                                #endif

                                #ifndef DEF_each_dYD0mmD2x0f
                                #define DEF_each_dYD0mmD2x0f
inline void each_dYD0mmD2(const s_Map_lhf7SV3Fyjf& _, s_SpecExtras& res, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const fu::str& key = _.keys.keys_asc[i];
        _R3r5rzw3(key, _.vals[i], res, ss, _here, ctx, module);
    };
}
                                #endif

                                #ifndef DEF_steal_N9AQdXVe3Qd
                                #define DEF_steal_N9AQdXVe3Qd
inline fu::vec<s_ScopeItem> steal_N9AQdXVe(fu::vec<s_ScopeItem>& a, const int start)
{
    /*MOV*/ fu::vec<s_ScopeItem> ret {};
    ret.resize((a.size() - start));
    for (int i = 0; i < ret.size(); i++)
        std::swap(ret.mutref(i), a.mutref((i + start)));

    a.shrink(start);
    return /*NRVO*/ ret;
}
                                #endif

static s_SpecExtras intoSpecExtras_gDsnGKHT(const s_Map_lhf7SV3Fyjf& typeParams, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    /*MOV*/ s_SpecExtras res {};
    const int scopeItems0 = ss._scope.items.size();
    each_dYD0mmD2(typeParams, res, ss, _here, ctx, module);
    res.scope_items = steal_N9AQdXVe(ss._scope.items, scopeItems0);
    return /*NRVO*/ res;
}

static const s_Node& n_fn_FDl5ha9X(const s_Template& tEmplate)
{
    return tEmplate.node;
}

static s_SolvedNode solved_gDsnGKHT(const s_Node& node, const s_Type& type, const fu::vec<s_SolvedNode>& items, const s_Target& target, const s_TokenIdx& _here)
{
    return SolvedNode_gDsnGKHT(node.kind, type, node.flags, node.value, items, target, s_Helpers{}, _here);
}

static fu::vec<s_SolvedNode>& outItems_gDsnGKHT(s_CurrentFn& _current_fn)
{
    return _current_fn.out.items;
}

static void TODO_FIX_partialEvalTypeAnnot_gDsnGKHT(s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.kind == s_Kind_call)
    {
        if (node.flags & s_Flags_F_TEMPLATE)
        {
            fu::vec<s_Target> targets = solveAddrOfFn_FDl5ha9X(fu::str(node.value), node.token, (node.flags & s_Flags_F_COMPOUND_ID), ss, _helpers, _here, ctx, module, options);
            node.kind = s_Kind___serialized_addrof_type_fn;
            node.value = packAddrOfFn_9CJmuVSD(targets);
        }
        else if ((node.items.size() != 1) || ((node.value != "[]"_fu) && (node.value != "[..]"_fu) && (node.value != "&"_fu) && (node.value != "&mut"_fu)))
        {
            s_Type type = evalTypeAnnot_gDsnGKHT(node, false, _current_fn, ss, _helpers, _here, ctx, module, options);
            node.kind = s_Kind___serialized_type;
            node.value = serializeType_1qjplDUo(type.vtype, "__serialized_type"_fu);
            node.items.clear();
        };
    };
    if ((node.kind == s_Kind_call) || (node.kind == s_Kind_typeunion) || (node.kind == s_Kind___serialized_addrof_type_fn))
        for (int i = 0; i < node.items.size(); i++)
            TODO_FIX_partialEvalTypeAnnot_gDsnGKHT(node.items.mutref(i), _current_fn, ss, _helpers, _here, ctx, module, options);
;
}

static fu::view_mut<s_SolvedNode> outItems_wyx7msfr(s_CurrentFn& _current_fn)
{
    return _current_fn.out.items;
}

                                #ifndef DEF_get_R8LBDpOe8lk
                                #define DEF_get_R8LBDpOe8lk
inline const s_Type& get_R8LBDpOe(const s_Set_6ARmtH0K78f& _, fu::view<char> key, fu::view<s_Type> values)
{
    fu::view<fu::str> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return values[i];
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    return (*(const s_Type*)fu::NIL);
}
                                #endif

                                #ifndef DEF_get_aWNBBsyMKV1
                                #define DEF_get_aWNBBsyMKV1
inline const s_Type& get_aWNBBsyM(const s_Map_pdTv4gjINIj& _, fu::view<char> key)
{
    return get_R8LBDpOe(_.keys, key, _.vals);
}
                                #endif

static s_SolvedNode solveTypedef_gDsnGKHT(const s_Node& node, const bool asArgument, const s_Type& specType, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.items[LET_TYPE])
    {
        _here = node.items[LET_TYPE].token;
        fail_gDsnGKHT("Type annotations on type aliases are not supported."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else if (specType && !is_Typename_9CJmuVSD(specType))
        BUG_gDsnGKHT("solveTypedef: specType is not a Typename"_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        const s_Node* _0;
        /*MOV*/ s_Type annot = (specType ? s_Type(specType) : evalTypeAnnot_gDsnGKHT((*(_0 = &(node.items[LET_INIT])) ? *_0 : fail_gDsnGKHT("Type aliases must be initialized."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)), false, _current_fn, ss, _helpers, _here, ctx, module, options));
        fu::str id = ((node.flags & s_Flags_F_COMPOUND_ID) ? cleanID_V5IuMsej(node.value) : fu::str(node.value));
        createTypedef_gDsnGKHT(id, annot, node.flags, node.token, ss, _here, ctx, module);
        if (asArgument)
        {
            s_Type relaxed = static_cast<s_Type&&>(annot);
            relaxed.vtype.quals &= ~q_USAGE;
            return createEmpty_gDsnGKHT(relaxed, s_Target{}, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            return createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}

                                #ifndef DEF_at_most_one_set_q6X7rguHh66
                                #define DEF_at_most_one_set_q6X7rguHh66
inline static bool at_most_one_set_q6X7rguH(const uint64_t v)
{
    return !(v & (v - 1ull));
}
                                #endif

static s_SolvedNode solveLetLike_dontTouchScope_gDsnGKHT(const s_Node& node, const bool asArgument, const s_Type& specType, const s_Type& primType, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    // Hoisted:
    s_Type specType_1 {};

    s_Flags flags = node.flags;
    if (at_most_one_set_q6X7rguH(uint64_t((flags & (s_Flags_F_VAL | s_Flags_F_REF)))))
    {
        if (at_most_one_set_q6X7rguH(uint64_t((flags & (s_Flags_F_CONST | s_Flags_F_MUT)))))
        {
            const s_Node& n_annot = node.items[LET_TYPE];
            s_Type BL_3_v {};
            s_Type annot = ((specType && (!n_annot || (n_annot.kind == s_Kind_typeunion) || !is_zeroes_9CJmuVSD(specType.vtype))) ? static_cast<s_Type&&>((specType_1 = ((!(flags & s_Flags_F_REF) || (flags & s_Flags_F_CONST)) ? clear_mutref_9CJmuVSD(s_Type(specType)) : s_Type(specType)), specType_1)) : (primType ? s_Type(primType) : (__extension__ (
            {
                /*MOV*/ s_Type annot_1 = (n_annot ? evalTypeAnnot_gDsnGKHT(n_annot, false, _current_fn, ss, _helpers, _here, ctx, module, options) : s_Type{});
                BL_3_v = (((annot_1 && ((node.flags & (s_Flags_F_REF | s_Flags_F_CONST)) == s_Flags_F_REF)) ? add_mutref_9CJmuVSD(static_cast<s_Type&&>(annot_1), Lifetime_temporary, _here, ctx) : static_cast<s_Type&&>(annot_1)));
            (void)0;}), static_cast<s_Type&&>(BL_3_v))));
            const s_Node& n_init = (!specType ? node.items[LET_INIT] : (*(const s_Node*)fu::NIL));
            /*MOV*/ s_SolvedNode init = (n_init ? solveNode_gDsnGKHT(n_init, annot, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
            if (s_ParseSyntax((node.syntax & s_ParseSyntax_PS_USING_EXPRESSION)) && !annot && is_ref_9CJmuVSD(init.type))
                flags |= s_Flags_F_REF;

            _here = node.token;
            return createLetLike_dontTouchScope_gDsnGKHT(node.value, flags, static_cast<s_SolvedNode&&>(init), asArgument, annot, _current_fn, ss, _helpers, _here, ctx, module, options);
        }
        else
            BUG_gDsnGKHT("F_CONST & F_MUT both set"_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT("F_VAL & F_REF both set"_fu, ss, _helpers, _here, ctx, module, options);

}

static s_SolvedNode solveLet_gDsnGKHT(const s_Node& node, const bool asArgument, const s_Type& specType, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.flags & s_Flags_F_TYPENAME)
        return solveTypedef_gDsnGKHT(node, asArgument, specType, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
    {
        s_SolvedNode out = solveLetLike_dontTouchScope_gDsnGKHT(node, asArgument, specType, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
        const fu::str& id = out.value;
        return solveLet_createBindingAndGetLetdef_gDsnGKHT(s_SolvedNode(out), id, true, asArgument, node.asserts, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF_t_AssumeNever_WhileSolvingRecursion
                                #define DEF_t_AssumeNever_WhileSolvingRecursion
extern const s_Type t_AssumeNever_WhileSolvingRecursion;
                                #endif

                                #ifndef DEF___CZ9panjcqS5
                                #define DEF___CZ9panjcqS5
inline static bool _CZ9panjc(const int locid)
{
    return !!locid;
}
                                #endif

                                #ifndef DEF_Lifetime_if_only_27d0w5NZ6wg
                                #define DEF_Lifetime_if_only_27d0w5NZ6wg
inline bool Lifetime_if_only_27d0w5NZ(const s_Lifetime& lifetime)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const int offset0 = offset;
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            const bool isOnly = (!offset0 ? (offset == chars.size()) : false);
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            if (isOnly)
                return _CZ9panjc(locid);
            else
                return false;

        };
    };
    return false;
}
                                #endif

static s_Lifetime Lifetime_fromNative_gDsnGKHT(fu::view<s_Node> sig, fu::view<s_SolvedNode> args, const s_Type& actual, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Type res {};
    if ((sig.size() + FN_ARGS_BACK) == args.size())
    {
        for (int i = 0; i < args.size(); i++)
        {
            if (sig[i].flags & s_Flags_F_REF)
            {
                if (res)
                {
                    fail_gDsnGKHT("Multiple ref arguments, cannot infer what the returned reference points to."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    res = GET_gDsnGKHT(args[i].target, ss, _here, ctx, module).type;
                    if (!(res.lifetime))
                    {
                        fail_gDsnGKHT("Missing ref argument lifetime."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    };
                };
            };
        };
        if (res.lifetime)
        {
            if (Lifetime_if_only_27d0w5NZ(res.lifetime) || is_zst_1qjplDUo(res.vtype, _here, ctx, module))
            {
                if (!isAssignable_9CJmuVSD(actual, res, false, false, _here, ctx))
                {
                    const int flatCount = getFlatCount_1qjplDUo(actual.vtype, _here, ctx, module);
                    if (!flatCount)
                    {
                        return s_Lifetime(Lifetime_static_moveable);
                    }
                    else
                    {
                        return Lifetime_makeShared_7Yz9ezW2(res.lifetime, flatCount, _here, ctx);
                    };
                }
                else
                {
                    return static_cast<s_Lifetime&&>(res.lifetime);
                };
            }
            else
            {
                fail_gDsnGKHT(x7E_3lDd4lqo("Infered a non-single-local __native lifetime: "_fu, str_gDsnGKHT(res.lifetime, false, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            fail_gDsnGKHT("No ref arguments, cannot infer what the returned reference points to."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
        BUG_gDsnGKHT("sig.len != args.len"_fu, ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_starts_8EDTwZj1Fm2
                                #define DEF_starts_8EDTwZj1Fm2
inline bool starts_8EDTwZj1(fu::view<char> a, const char with)
{
    return a.size() && (a[0] == with);
}
                                #endif

                                #ifndef DEF_EFFECTS_output
                                #define DEF_EFFECTS_output
extern const s_FxMask EFFECTS_output;
                                #endif

                                #ifndef DEF_parse_j8jAosYDPxh
                                #define DEF_parse_j8jAosYDPxh
inline s_FxMask parse_j8jAosYD(fu::view<char> v)
{
    if (v == "Fx_NotDeadCode"_fu)
        return s_FxMask_Fx_NotDeadCode;
    else if (v == "Fx_NonDeterministic"_fu)
        return s_FxMask_Fx_NonDeterministic;
    else if (v == "Fx_DontMoveUp"_fu)
        return s_FxMask_Fx_DontMoveUp;
    else if (v == "Fx_DontMoveDown"_fu)
        return s_FxMask_Fx_DontMoveDown;
    else if (v == "Fx_Input"_fu)
        return s_FxMask_Fx_Input;
    else if (v == "Fx_Output"_fu)
        return s_FxMask_Fx_Output;
    else if (v == "Fx_Throws"_fu)
        return s_FxMask_Fx_Throws;
    else if (v == "Fx_Crashes"_fu)
        return s_FxMask_Fx_Crashes;
    else if (v == "Fx_Crashes_Div0"_fu)
        return s_FxMask_Fx_Crashes_Div0;
    else if (v == "Fx_Crashes_OOB"_fu)
        return s_FxMask_Fx_Crashes_OOB;
    else if (v == "Fx_Crashes_Assert"_fu)
        return s_FxMask_Fx_Crashes_Assert;
    else if (v == "Fx_Crashes_Exit"_fu)
        return s_FxMask_Fx_Crashes_Exit;
    else if (v == "Fx_Syscall"_fu)
        return s_FxMask_Fx_Syscall;
    else if (v == "Fx_Blocks"_fu)
        return s_FxMask_Fx_Blocks;
    else if (v == "Fx_Blocks_Alloc"_fu)
        return s_FxMask_Fx_Blocks_Alloc;
    else if (v == "Fx_Blocks_Await"_fu)
        return s_FxMask_Fx_Blocks_Await;

    return s_FxMask{};
}
                                #endif

                                #ifndef DEF_ensure_qSTqnenA2R1
                                #define DEF_ensure_qSTqnenA2R1
inline int& ensure_qSTqnenA(fu::vec<int>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF___DvGtHApNuu8
                                #define DEF___DvGtHApNuu8
inline static const s_ValueType& _DvGtHApN(const s_ValueType& itemType)
{
    if (is_rx_copy_9CJmuVSD(itemType))
        return itemType;
    else
        return (*(const s_ValueType*)fu::NIL);

}
                                #endif

                                #ifndef DEF_if_sliceable_iSZ1k2rpThl
                                #define DEF_if_sliceable_iSZ1k2rpThl
inline s_ValueType if_sliceable_iSZ1k2rp(const s_ValueType& type, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (is_sliceable_hxWWgdZ1(type))
        return s_ValueType(_DvGtHApN(parseType_1qjplDUo(fu::slice(type.canon, 1, (type.canon.size() - 1)), _here, ctx, module)));
    else
    {
        return s_ValueType{};
    };
}
                                #endif

static fu::str CompoundArgID_outerSplice_gDsnGKHT(fu::str& name, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    bool exclam = false;
    for (int i = 0; i < name.size(); i++)
    {
        const char c = name[i];
        if (c == '!')
        {
            if (exclam)
                BUG_gDsnGKHT((("CompoundArgID: double bang in `"_fu + name) + "`."_fu), ss, _helpers, _here, ctx, module, options);
            else
            {
                exclam = true;
                const int i0 = i++;
                for (; i < name.size(); i++)
                {
                    if (name[i] == '.')
                        break;

                };
                name.splice(i0, (i - i0));
                i = (i0 - 1);
            };
        }
        else if (c == '.')
        {
            /*MOV*/ fu::str ret = fu::slice(name, (i + 1));
            name.shrink(i);
            return /*NRVO*/ ret;
        };
    };
    if (!exclam)
        BUG_gDsnGKHT((("CompoundArgID: no `.` nor `!` in id `"_fu + name) + "`."_fu), ss, _helpers, _here, ctx, module, options);
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF_iF_iLSTz9HPOn0
                                #define DEF_iF_iLSTz9HPOn0
inline unsigned iF_iLSTz9HP(fu::view<unsigned> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
    {
        return unsigned{};
    };
}
                                #endif

                                #ifndef DEF_iF_51ChLTxy130
                                #define DEF_iF_51ChLTxy130
inline static unsigned iF_51ChLTxy(const s_LocidMap_DC5gktNgm89& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_iLSTz9HP(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_iF_3r92HVHiVD8
                                #define DEF_iF_3r92HVHiVD8
inline const s_LocidSet& iF_3r92HVHi(fu::view<s_LocidSet> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_LocidSet*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_1RIDDoXNUGj
                                #define DEF_iF_1RIDDoXNUGj
inline static const s_LocidSet& iF_1RIDDoXN(const s_LocidMap_I7YkM5C62o7& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_3r92HVHi(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_iF_zuMlNyDQpMh
                                #define DEF_iF_zuMlNyDQpMh
inline int iF_zuMlNyDQ(fu::view<int> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
    {
        return int{};
    };
}
                                #endif

                                #ifndef DEF___j1BJZIMAxgg
                                #define DEF___j1BJZIMAxgg
inline static void _j1BJZIMA(const int other, s_BitSet& output, fu::view<int> argPos_1b)
{
    const int otherPos_1b = iF_zuMlNyDQ(argPos_1b, (-1 - other));
    if (otherPos_1b)
        add_ZwXYCruz(output, (otherPos_1b - 1));

}
                                #endif

                                #ifndef DEF___mSYCfsQRRCl
                                #define DEF___mSYCfsQRRCl
inline static void _mSYCfsQR(const int locid, const int args_neg, s_BitSet& output, fu::view<int> argPos_1b)
{
    _j1BJZIMA((locid - args_neg), output, argPos_1b);
}
                                #endif

                                #ifndef DEF_each_oGXSe2EtNsl
                                #define DEF_each_oGXSe2EtNsl
inline void each_oGXSe2Et(const s_BitSet& _, const int args_neg, s_BitSet& output, fu::view<int> argPos_1b)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _mSYCfsQR(((i << 3) | int(b)), args_neg, output, argPos_1b);

            };
        };
    };
}
                                #endif

                                #ifndef DEF_each_nRZZjOjEl25
                                #define DEF_each_nRZZjOjEl25
inline static void each_nRZZjOjE(const s_LocidSet& set, s_BitSet& output, fu::view<int> argPos_1b, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    each_oGXSe2Et(set._bitset, args_neg, output, argPos_1b);
}
                                #endif

static void ArgsAtRisk_list_gDsnGKHT(s_BitSet& output, const s_LocidMap_I7YkM5C62o7& at_risk, fu::view<int> argPos_1b, const s_Target& argTarget, const s_CurrentFn& _current_fn)
{
    int BL_1_v {};
    each_nRZZjOjE(iF_1RIDDoXN(at_risk, (__extension__ (
    {
        const unsigned v = unsigned((argTarget._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v), _current_fn), output, argPos_1b, _current_fn);
}

                                #ifndef DEF___Yy7RZxObtU3
                                #define DEF___Yy7RZxObtU3
inline static void _Yy7RZxOb(const int index, fu::view<s_SolvedNode> items, s_Set_95BJOojOc45& TODO_FIX_mayAlias_ensureStable, s_BitSet& hard_risk, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Overload& other = GET_gDsnGKHT(items[index].target, ss, _here, ctx, module);
    if (is_sliceable_hxWWgdZ1(other.solved.type.vtype) && !TODO_FIX_isArray_9CJmuVSD(other.solved.type))
    {
        if (other.status & s_SolverStatus_SS_TODO_FIX_was_rx_resize)
            add_8Ex4Hrql(TODO_FIX_mayAlias_ensureStable, index);
        else
            add_ZwXYCruz(hard_risk, index);

    };
}
                                #endif

                                #ifndef DEF_each_7xEkFjwlaY0
                                #define DEF_each_7xEkFjwlaY0
inline void each_7xEkFjwl(const s_BitSet& _, fu::view<s_SolvedNode> items, s_Set_95BJOojOc45& TODO_FIX_mayAlias_ensureStable, s_BitSet& hard_risk, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _Yy7RZxOb(((i << 3) | int(b)), items, TODO_FIX_mayAlias_ensureStable, hard_risk, ss, _here, ctx, module);

            };
        };
    };
}
                                #endif

static bool isNoVec_gDsnGKHT(const s_Type& t, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    return is_trivial_1qjplDUo(t.vtype, _here, ctx, module) || !(is_rx_copy_9CJmuVSD(t.vtype) || is_rx_resize_9CJmuVSD(t.vtype));
}

static void visit_FDl5ha9X(const s_Lifetime& lifetime, bool& maybeOutOfOrder, const int needle, bool& found, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0;

    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        const int locid = ((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v));
        fu::view<char> paths = fu::get_view(chars, sr, offset);
        if (!(!locid || found))
        {
            if (locid == needle)
                found = true;
            else
            {
                const s_Type& init = Lifetime_climbType_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _helpers, _here, ctx, module, options);
                if (is_ref_9CJmuVSD(init))
                {
                    s_Lifetime parent = Lifetime_op_join_7Yz9ezW2(init.lifetime, paths, _here, ctx);
                    maybeOutOfOrder = true;
                    visit_FDl5ha9X(parent, maybeOutOfOrder, needle, found, ss, _helpers, _here, ctx, module, options);
                };
            };
        };
    };
}

                                #ifndef DEF_Lifetime_process_JKwPNnNM1Wb
                                #define DEF_Lifetime_process_JKwPNnNM1Wb
inline s_Lifetime Lifetime_process_JKwPNnNM(const s_Lifetime& lifetime, const int needle, bool& found, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Lifetime result {};
    bool maybeOutOfOrder = false;
    visit_FDl5ha9X(lifetime, maybeOutOfOrder, needle, found, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ result;
}
                                #endif

static bool Lifetime_unwinds_through_gDsnGKHT(const s_Lifetime& lifetime, const int needle, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    bool found = false;
    Lifetime_process_JKwPNnNM(lifetime, needle, found, ss, _helpers, _here, ctx, module, options);
    return found;
}

static fu::str qSTACK_local_gDsnGKHT(const s_Target& target, const int locid, fu::view<s_Target> seen, const s_ArgQuery query, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return qSTACK_local_FDl5ha9X(target, s_SolvedNode(GET_gDsnGKHT(target, ss, _here, ctx, module).solved), locid, seen, query, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static fu::str qSTACK_arg_gDsnGKHT(const s_Target& target, const int position, fu::view<s_Target> seen, const s_ArgQuery query, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    return qSTACK_local_gDsnGKHT(target, (__extension__ (
    {
        const s_Target& t = EXT_gDsnGKHT(target, ss, ctx, module).args[position].target;
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v), seen, query, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static fu::str qSTACK_local_FDl5ha9X(const s_Target& target, const s_SolvedNode& node, const int locid, fu::view<s_Target> seen, const s_ArgQuery query, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    if (!seen)
        ss._qstack_safety = 0;
    else if (ss._qstack_safety++ > 1024)
        return "[QSTACK > 1024]"_fu;

    fu::vec<s_Target> seen_1 = (seen + target);

    {
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            s_SolvedNode BL_6_v {};
            s_SolvedNode node_3 = (__extension__ (
            {
                const s_SolvedNode& __partcopy_ref = ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
                BL_6_v = (s_SolvedNode { __partcopy_ref.kind, {}, {}, {}, {}, fu::vec<s_SolvedNode>(__partcopy_ref.items), s_TokenIdx(__partcopy_ref.token), {}, s_Target(__partcopy_ref.target) });
            (void)0;}), static_cast<s_SolvedNode&&>(BL_6_v));
            if (node_3.kind != s_Kind_call)
            {
                if ((query == s_ArgQuery_AQ_WhyNotNovec) && ((node_3.kind == s_Kind_copy) || (node_3.kind == s_Kind_move)))
                {
                    const s_SolvedNode& arg = only_LqU08rcL(node_3.items);
                    if (Lifetime_unwinds_through_gDsnGKHT(arg.type.lifetime, locid, ss, _helpers, _here, ctx, module, options))
                    {
                        return (x7E_3lDd4lqo(("\n            "_fu + "via "_fu), str_WkqQ7QhO(node_3.kind)) + " at "_fu) + addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module);
                    };
                };
            }
            else
            {
                if (!(has_AOZqRgIb(seen_1, node_3.target)))
                {
                    fu::vec<s_SolvedNode> args { node_3.items };
                    fu::vec<s_Argument> host_args { EXT_gDsnGKHT(node_3.target, ss, ctx, module).args };
                    if (args.size() == host_args.size())
                    {
                        for (int i = 0; i < host_args.size(); i++)
                        {
                            const s_Argument& host_arg = host_args[i];
                            if (query == s_ArgQuery_AQ_WhyNotNovec)
                            {
                                if (isNoVec_gDsnGKHT(host_arg.type, _here, ctx, module))
                                    continue;

                            }
                            else if (!host_arg.written_to)
                                continue;

                            const s_SolvedNode& arg = args[i];
                            if (!(!Lifetime_unwinds_through_gDsnGKHT(arg.type.lifetime, locid, ss, _helpers, _here, ctx, module, options)))
                            {
                                fu::str peek = qSTACK_arg_gDsnGKHT(s_Target(node_3.target), i, seen_1, query, _current_fn, ss, _helpers, _here, ctx, module, options);
                                if (!(!peek && (GET_gDsnGKHT(node_3.target, ss, _here, ctx, module).kind == s_Kind_fn)))
                                {
                                    return ((x7E_3lDd4lqo(("\n            "_fu + "via "_fu), str_FDl5ha9X(node_3.target, false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + peek;
                                };
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += s_SolvedNode(node_3.items[i]);

        };
    };
    return ""_fu;
}

                                #ifndef DEF___oxXTizSCztj
                                #define DEF___oxXTizSCztj
inline static bool _oxXTizSC(const s_COWInside& cow, const s_Target& argTarget)
{
    int BL_1_v {};
    return cow.argTarget == (__extension__ (
    {
        const unsigned v = unsigned((argTarget._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
}
                                #endif

                                #ifndef DEF_some_JQmdj86SVK5
                                #define DEF_some_JQmdj86SVK5
inline bool some_JQmdj86S(fu::view<s_COWInside> a, const s_Target& argTarget)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_COWInside& item = a[i];
        if (_oxXTizSC(item, argTarget))
            return true;

    };
    return false;
}
                                #endif

static const s_Lifetime& TEST_Lifetime_FDl5ha9X(const s_Lifetime& lifetime, const s_Type& type, const bool tempsOK, const bool argPositionsOK, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!lifetime)
    {
        BUG_gDsnGKHT("TEST_Lifetime: empty lifetime"_fu, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        bool first = true;
        int lastStatic = 1000000;
        int lastLocid = 1000000;
        int lastArgIdx = 1000000;
        Lifetime_each_qzbdxgK5(lifetime, type, tempsOK, argPositionsOK, first, lastStatic, lastLocid, lastArgIdx, ss, _helpers, _here, ctx, module, options);
    };
    return lifetime;
}

static void visit_iUdwqyBn(const s_Lifetime& lifetime, s_Lifetime& result, bool& maybeOutOfOrder, fu::view<int> argPos_1b, fu::view_mut<s_Argument> args, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        {
            const unsigned r = parse7bit(chars, offset);
            int BL_4_v {};
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
            (void)0;}), BL_4_v);
            int BL_12_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_12_v));
            const bool isStatic = ((r & 11u) == 1u);
            fu::view<char> paths = fu::get_view(chars, sr, offset);
            if (!locid)
            {
                if (!(isStatic))
                {
                    BUG_gDsnGKHT("Non-local/non-static in retval.lifetime."_fu, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
            {
                int _0 {};
                const int argPos_1b_1 = ((_0 = iF_zuMlNyDQ(argPos_1b, (-1 - locid))) ? _0 : BUG_gDsnGKHT(x7E_3lDd4lqo("Non-argument local in retval.lifetime: "_fu, str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options));
                const int i = (argPos_1b_1 - 1);
                s_Argument& arg = args.mutref(i);
                if (is_ref_9CJmuVSD(arg.type))
                {
                    arg.flags |= s_Flags_F_LT_RETURNED;
                    s_Lifetime replacement = Lifetime_from_UkiI9X8L(i, paths, _here, ctx);
                    maybeOutOfOrder = true;
                    Lifetime_add_7Yz9ezW2(result, replacement, false, _here, ctx);
                    continue;
                }
                else
                {
                    BUG_gDsnGKHT(x7E_3lDd4lqo("Non-ref argument in retval.lifetime: "_fu, str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                };
            };
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_aPoUrGef2zi
                                #define DEF_Lifetime_process_aPoUrGef2zi
inline s_Lifetime Lifetime_process_aPoUrGef(const s_Lifetime& lifetime, fu::view<int> argPos_1b, fu::view_mut<s_Argument> args, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Lifetime result {};
    bool maybeOutOfOrder = false;
    visit_iUdwqyBn(lifetime, result, maybeOutOfOrder, argPos_1b, args, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ result;
}
                                #endif

static s_ArgRationale rejectsTempCopies_gDsnGKHT(const s_Argument& arg, const s_ArgRationale requireVal, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (arg.flags & s_Flags_F_IMPLICIT)
        return s_ArgRationale_CantTempCopy_HostArg_Implicit;
    else if (arg.flags & s_Flags_F_REF)
        return s_ArgRationale_CantTempCopy_HostArg_Ref;
    else if (is_mutref_9CJmuVSD(arg.type, _here, ctx))
        return s_ArgRationale_CantTempCopy_HostArg_MutRef;
    else if (!(arg.flags & s_Flags_F_VAL))
        return requireVal;
    else
    {
        return s_ArgRationale{};
    };
}

static bool acceptsTempCopies_gDsnGKHT(const s_Argument& arg, const s_ArgRationale requireVal, const s_TokenIdx& _here, const s_Context& ctx)
{
    return !rejectsTempCopies_gDsnGKHT(arg, requireVal, _here, ctx);
}

static bool willPassByValue_gDsnGKHT(const s_Argument& arg, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (acceptsTempCopies_gDsnGKHT(arg, s_ArgRationale{}, _here, ctx))
        return isPassByValue_hxWWgdZ1(arg.type.vtype);
    else
        return false;

}

                                #ifndef DEF___csG9PeQpXD1
                                #define DEF___csG9PeQpXD1
inline static bool _csG9PeQp(const bool isArgIdx, const bool isStatic, const s_Type& retval, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return isArgIdx ? isArgIdx : isStatic ? isStatic : BUG_gDsnGKHT(x7E_3lDd4lqo("updateScope: Non-static/non-arg leaked:\n\t"_fu, str_gDsnGKHT(retval.lifetime, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_Lifetime_each_hZI4uDKgf5h
                                #define DEF_Lifetime_each_hZI4uDKgf5h
inline void Lifetime_each_hZI4uDKg(const s_Lifetime& lifetime, const s_Type& retval, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        _csG9PeQp(((r & 3u) == 3u), ((r & 11u) == 1u), retval, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static const s_Type& ignoreLocalLts_gDsnGKHT(const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (is_ref_9CJmuVSD(type))
    {
        if (!(type.lifetime == Lifetime_temporary))
        {
            BUG_gDsnGKHT("type.lifetime != Lifetime_temporary"_fu, ss, _helpers, _here, ctx, module, options);
        };
    };
    return type;
}

static fu::str qSTACK_effect_gDsnGKHT(const s_Target& target, const s_SolvedNode& node, const s_FxMask fx_mask, fu::view<s_Target> seen, const s_CurrentFn& _current_fn, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    fu::vec<s_Target> seen_1 = (seen + target);

    {
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            s_SolvedNode BL_4_v {};
            s_SolvedNode node_3 = (__extension__ (
            {
                const s_SolvedNode& __partcopy_ref = ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
                BL_4_v = (s_SolvedNode { __partcopy_ref.kind, {}, {}, {}, {}, fu::vec<s_SolvedNode>(__partcopy_ref.items), s_TokenIdx(__partcopy_ref.token), {}, s_Target(__partcopy_ref.target) });
            (void)0;}), static_cast<s_SolvedNode&&>(BL_4_v));
            if (!((node_3.kind != s_Kind_call) || isLocal_gDsnGKHT(node_3.target)))
            {
                if (!(has_AOZqRgIb(seen_1, node_3.target)))
                {
                    if (!(!s_FxMask((EXT_gDsnGKHT(node_3.target, ss, ctx, module).fx_mask & fx_mask))))
                    {
                        fu::str peek = qSTACK_effect_gDsnGKHT(s_Target(node_3.target), s_SolvedNode(GET_gDsnGKHT(node_3.target, ss, _here, ctx, module).solved), fx_mask, seen_1, _current_fn, ss, _here, ctx, module, options);
                        if (!(!peek && (GET_gDsnGKHT(node_3.target, ss, _here, ctx, module).kind == s_Kind_fn)))
                        {
                            return ((x7E_3lDd4lqo(("\n            "_fu + "via "_fu), str_FDl5ha9X(node_3.target, false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + peek;
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += s_SolvedNode(node_3.items[i]);

        };
    };
    return ""_fu;
}

                                #ifndef DEF_first_DX9UgGp0Cs2
                                #define DEF_first_DX9UgGp0Cs2
inline int first_DX9UgGp0(fu::view<int> s)
{
    return s[0];
}
                                #endif

                                #ifndef DEF___6OFzo0AUHEi
                                #define DEF___6OFzo0AUHEi
inline static bool _6OFzo0AU(const s_Argument& _)
{
    return isAddrOfFn_9CJmuVSD(_.type);
}
                                #endif

                                #ifndef DEF_some_63Tr7AIxYSa
                                #define DEF_some_63Tr7AIxYSa
inline bool some_63Tr7AIx(fu::view<s_Argument> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_Argument& item = a[i];
        if (_6OFzo0AU(item))
            return true;

    };
    return false;
}
                                #endif

static bool astChange_gDsnGKHT(const s_SolvedNode& a, const s_SolvedNode& b)
{
    if ((a.kind != b.kind) || (a.items.size() != b.items.size()))
        return true;
    else
    {
        for (int i = a.items.size(); i-- > 0; )
        {
            if (astChange_gDsnGKHT(a.items[i], b.items[i]))
                return true;

        };
        return false;
    };
}

                                #ifndef DEF_steal_fgQ7FGOBTug
                                #define DEF_steal_fgQ7FGOBTug
inline s_RevSpecPrototype steal_fgQ7FGOB(s_RevSpecPrototype& v)
{
    /*MOV*/ s_RevSpecPrototype ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static void doUpdateScope_gDsnGKHT(s_Type&& retval, const s_Target& target, const bool maybeLast, const bool isNative, const bool isUnspec, const s_DeclAsserts asserts, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (target == _current_fn.out.target)
    {
        const int args_neg0 = _current_fn.args_neg;
        _current_fn.args_neg = EXT_gDsnGKHT(target, ss, ctx, module).args_neg;
        fu_DEFER(if (_current_fn.args_neg == EXT_gDsnGKHT(target, ss, ctx, module).args_neg)
            _current_fn.args_neg = args_neg0;
        else
        {
            BUG_gDsnGKHT("doUpdateScope: args_neg drift"_fu, ss, _helpers, _here, ctx, module, options);
        });
        fu::view<s_SolvedNode> items = _current_fn.out.items;
        fu::str mustBecomeInline = currentFn_mustBecomeInline_gDsnGKHT(_current_fn);
        const int N = (items.size() + FN_ARGS_BACK);
        int min = 0;
        int max = 0;
        const s_NativeQualities NativeQualities = (isNative ? NativeQualities_UvH3gYAB(GET_gDsnGKHT(target, ss, _here, ctx, module).name) : s_NativeQualities{});
        int numArgsWritten = 0;
        const bool relaxMutValArgs = (maybeLast ? !mustBecomeInline : false);
        s_MayEscapeVia TODO_FIX_nativeCOWsInside_mayEscapeVia {};
        fu::vec<int> argPos_1b {};
        for (int i = 0; i < N; i++)
        {
            const s_SolvedNode& argNode = items[i];
            const s_Target& argTarget = argNode.target;
            if (!(!argTarget))
            {
                int BL_7_v {};
                ensure_qSTqnenA(argPos_1b, (-1 - (__extension__ (
                {
                    const unsigned v = unsigned((argTarget._packed & 0xfffffull));
                    BL_7_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_7_v))) = (i + 1);
                if (relaxMutValArgs)
                {
                    s_Overload& o = GET_mut_gDsnGKHT(argTarget, ss, module);
                    if (isMutVal_gDsnGKHT(o))
                        keepOrClearMutVal_gDsnGKHT(o, (is_mutref_9CJmuVSD(o.type, _here, ctx) || s_SolverStatus((o.status & s_SolverStatus_SS_MOVED_FROM))), ss, _helpers, _here, ctx, module, options);

                };
                if (isNative && is_mutref_9CJmuVSD(argNode.type, _here, ctx) && !is_trivial_1qjplDUo(argNode.type.vtype, _here, ctx, module))
                {
                    int BL_11_v {};
                    int _0 {};
                    add_xQNS19Zn(TODO_FIX_nativeCOWsInside_mayEscapeVia, ((_0 = (__extension__ (
                    {
                        const s_Target& t = argNode.target;
                        const unsigned v = unsigned((t._packed & 0xfffffull));
                        BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                    (void)0;}), BL_11_v)) ? _0 : BUG_gDsnGKHT("TODO_FIX_nativeCOWsInside_mayEscapeVia: no locid"_fu, ss, _helpers, _here, ctx, module, options)));
                };
            };
        };
        const bool TODO_FIX_nativeCOWsInside = (!!TODO_FIX_nativeCOWsInside_mayEscapeVia || ((isNative && !is_ref_9CJmuVSD(retval)) ? !is_trivial_1qjplDUo(retval.vtype, _here, ctx, module) : false));
        if (TODO_FIX_nativeCOWsInside)
        {
            if (_current_fn.events.cows_inside)
                BUG_gDsnGKHT("TODO_FIX_nativeCOWsInside: _current_fn.cows_inside already set"_fu, ss, _helpers, _here, ctx, module, options);
            else
            {
                for (int i_1 = 0; i_1 < N; i_1++)
                {
                    const s_SolvedNode& argNode = items[i_1];
                    fu::never BL_17_v {};
                    s_SolvedNode& argNode_1 = ((argNode.kind == s_Kind_letdef) ? GET_mut_gDsnGKHT(argNode.target, ss, module).solved : (__extension__ (
                    {
                        continue;
                    (void)0;}), static_cast<fu::never&&>(BL_17_v)));
                    if (is_ref_9CJmuVSD(argNode_1.type) && !is_mutref_9CJmuVSD(argNode_1.type, _here, ctx) && !is_trivial_1qjplDUo(argNode_1.type.vtype, _here, ctx, module))
                    {
                        int BL_19_v {};
                        int _1 {};
                        const int locid = ((_1 = (__extension__ (
                        {
                            const s_Target& t = argNode_1.target;
                            const unsigned v = unsigned((t._packed & 0xfffffull));
                            BL_19_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                        (void)0;}), BL_19_v)) ? _1 : BUG_gDsnGKHT("TODO_FIX_nativeCOWsInside: ref arg target not set"_fu, ss, _helpers, _here, ctx, module, options));
                        /*MOV*/ s_ValueType vtype = (is_rx_copy_9CJmuVSD(argNode_1.type.vtype) ? s_ValueType(argNode_1.type.vtype) : if_sliceable_iSZ1k2rp(argNode_1.type.vtype, _here, ctx, module));
                        if (!is_rx_copy_9CJmuVSD(vtype))
                        {
                            if (!is_ref_9CJmuVSD(retval) || is_mutref_9CJmuVSD(retval, _here, ctx))
                                argNode_1.type = clear_refs_9CJmuVSD(s_Type(argNode_1.type));
                            else
                            {
                                fail_gDsnGKHT(((x7E_3lDd4lqo((x7E_3lDd4lqo("Heuristically, "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + " likely performs COW inside, but "_fu), str_FDl5ha9X(argNode_1.target, false, ss, _here, ctx, module, options)) + " is neither copiable nor value-convertible "_fu) + " (appears to be ref-returned)."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            };
                        }
                        else
                        {
                            _current_fn.events.cows_inside += s_COWInside { static_cast<s_ValueType&&>(vtype), s_TokenIdx(argNode_1.token), locid, TODO_FIX_nativeCOWsInside_mayEscapeVia, s_ExitPaths((s_ExitPaths_XP_NonEmptyReturn | (TODO_FIX_nativeCOWsInside_mayEscapeVia ? s_ExitPaths_XP_EmptyReturn : s_ExitPaths{}))) };
                        };
                    };
                };
            };
        };
        s_Set_95BJOojOc45 TODO_FIX_mayAlias_ensureStable {};
        fu::vec<s_Argument> args {};
        for (int i_1 = 0; i_1 < N; i_1++)
        {
            const s_SolvedNode& argNode = items[i_1];
            if (!(argNode.kind == s_Kind_letdef))
            {
                if (argNode.target)
                    BUG_gDsnGKHT(x7E_3lDd4lqo("Argnode is not letdef, but has a target: "_fu, str_FDl5ha9X(argNode.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            };
            const s_SolvedNode& argNode_1 = ((argNode.kind == s_Kind_letdef) ? GET_gDsnGKHT(argNode.target, ss, _here, ctx, module).solved : argNode);
            if ((argNode_1.kind == s_Kind_let) || (argNode_1.kind == s_Kind_empty))
            {
                /*MOV*/ fu::str name { argNode_1.value };
                /*MOV*/ fu::str autocall = ((argNode_1.flags & s_Flags_F_COMPOUND_ID) ? CompoundArgID_outerSplice_gDsnGKHT(name, ss, _helpers, _here, ctx, module, options) : fu::str{});
                const bool isImplicit = !!(argNode_1.flags & s_Flags_F_IMPLICIT);
                const bool isInjected = !!(argNode_1.flags & s_Flags_F_INJECTED);
                const s_Target& argTarget = argNode_1.target;
                unsigned BL_29_v {};
                int BL_30_v {};
                const unsigned written_to = ((!isUnspec && is_mutref_9CJmuVSD(argNode_1.type, _here, ctx)) ? (isNative ? (__extension__ (
                {
                    const s_ValueType& type = argNode_1.type.vtype;
                    BL_29_v = ((type.quals & q_USAGE));
                (void)0;}), BL_29_v) : iF_51ChLTxy(_current_fn.postdom.snap.ever_written, (__extension__ (
                {
                    const unsigned v = unsigned((argTarget._packed & 0xfffffull));
                    BL_30_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_30_v), _current_fn)) : 0u);
                s_BitSet soft_risk {};
                s_BitSet hard_risk {};
                if (written_to)
                {
                    unsigned BL_32_v {};
                    if ((written_to & (__extension__ (
                    {
                        const s_ValueType& type = argNode_1.type.vtype;
                        BL_32_v = ((type.quals & q_USAGE));
                    (void)0;}), BL_32_v)) == written_to)
                    {
                        numArgsWritten++;
                        if (isNative)
                        {
                            add_range_ZwXYCruz(soft_risk, N);
                            remove_Na55O4zv(soft_risk, i_1);
                            if (!NativeQualities.MayAlias)
                                hard_risk = soft_risk;

                        }
                        else
                        {
                            ArgsAtRisk_list_gDsnGKHT(soft_risk, _current_fn.flow.at_soft_risk, argPos_1b, argTarget, _current_fn);
                            ArgsAtRisk_list_gDsnGKHT(hard_risk, _current_fn.flow.at_hard_risk, argPos_1b, argTarget, _current_fn);
                            if (TODO_FIX_isArray_9CJmuVSD(argNode_1.type))
                            {
                                s_BitSet soft { soft_risk };
                                remove_ZwXYCruz(soft, hard_risk);
                                each_7xEkFjwl(soft, items, TODO_FIX_mayAlias_ensureStable, hard_risk, ss, _here, ctx, module);
                            };
                        };
                    }
                    else
                    {
                        unsigned BL_39_v {};
                        BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("doUpdateScope written_to("_fu, fu::u64dec(written_to)) + ") argNode.usage("_fu), fu::u64dec((__extension__ (
                        {
                            const s_ValueType& type = argNode_1.type.vtype;
                            BL_39_v = ((type.quals & q_USAGE));
                        (void)0;}), BL_39_v))) + "): "_fu), str_FDl5ha9X(argNode_1.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                    };
                };
                if (maybeLast && s_DeclAsserts((asserts & s_DeclAsserts_A_NOVEC)) && !isNoVec_gDsnGKHT(argNode_1.type, _here, ctx, module) && !mustBecomeInline)
                {
                    fu::str _2 {};
                    int BL_41_v {};
                    fu::str _3 {};
                    (_3 = (_2 = (((x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not novec, "_fu), str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)) + " is "_fu) + explainType_gDsnGKHT(argNode_1.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + ":\n"_fu), (static_cast<fu::str&&>(_2) + qSTACK_local_FDl5ha9X(target, _current_fn.out, (__extension__ (
                    {
                        const unsigned v = unsigned((argTarget._packed & 0xfffffull));
                        BL_41_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                    (void)0;}), BL_41_v), fu::view<s_Target>{}, s_ArgQuery_AQ_WhyNotNovec, _current_fn, ss, _helpers, _here, ctx, module, options))), fail_gDsnGKHT(static_cast<fu::str&&>(_3), "novec"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
                }
                else
                {
                    const bool cow_inside = some_JQmdj86S(_current_fn.events.cows_inside, argTarget);
                    if (has_ZwXYCruz(soft_risk, i_1))
                        BUG_gDsnGKHT((x7E_3lDd4lqo("updateScope: "_fu, str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)) + " soft_risk lists self"_fu), ss, _helpers, _here, ctx, module, options);
                    else if (has_ZwXYCruz(hard_risk, i_1))
                        BUG_gDsnGKHT((x7E_3lDd4lqo("updateScope: "_fu, str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)) + " hard_risk lists self"_fu), ss, _helpers, _here, ctx, module, options);

                    /*MOV*/ s_BitSet may_alias = negated_ZwXYCruz(hard_risk, N);
                    /*MOV*/ s_BitSet may_invalidate = negated_ZwXYCruz(soft_risk, N);
                    if (popcount_ZwXYCruz(may_alias) > N)
                        BUG_gDsnGKHT((x7E_3lDd4lqo("updateScope: "_fu, str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)) + " may_alias.popcount > N"_fu), ss, _helpers, _here, ctx, module, options);
                    else if (popcount_ZwXYCruz(may_invalidate) > N)
                        BUG_gDsnGKHT((x7E_3lDd4lqo("updateScope: "_fu, str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)) + " may_invalidate.popcount > N"_fu), ss, _helpers, _here, ctx, module, options);

                    /*MOV*/ s_Argument arg = s_Argument { static_cast<fu::str&&>(name), static_cast<fu::str&&>(autocall), s_Type(argNode_1.type), s_SolvedNode(((!isImplicit && argNode_1.items) ? argNode_1.items[LET_INIT] : (*(const s_SolvedNode*)fu::NIL))), s_Target(argTarget), (argNode_1.flags | (cow_inside ? s_Flags_F_COW_INSIDE : s_Flags{})), written_to, static_cast<s_BitSet&&>(may_invalidate), static_cast<s_BitSet&&>(may_alias) };
                    if (arg.type.lifetime && !(arg.flags & s_Flags_F_INJECTED))
                    {
                        if (!(arg.type.lifetime == Lifetime_temporary))
                            BUG_gDsnGKHT(x7E_3lDd4lqo("Non-temporary lt on ref arg: "_fu, str_FDl5ha9X(argTarget, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                    }
                    else
                        ref_anonymize_9CJmuVSD(arg.type);

                    if (arg.type || isUnspec)
                    {
                        unsigned BL_51_v {};
                        if (s_VFacts((arg.type.vtype.vfacts & s_VFacts((s_VFacts_AlwaysTrue | s_VFacts_AlwaysFalse)))) && (__extension__ (
                        {
                            const s_ValueType& type = arg.type.vtype;
                            BL_51_v = ((type.quals & q_USAGE));
                        (void)0;}), BL_51_v) && !tryParseClosureID_UvH3gYAB(arg.name, _here, ctx))
                            BUG_gDsnGKHT("updateScope: arg.type is AlwaysTrue/False."_fu, ss, _helpers, _here, ctx, module, options);

                    }
                    else
                        BUG_gDsnGKHT("updateScope: Unexpected untyped argument."_fu, ss, _helpers, _here, ctx, module, options);

                    if (!isInjected)
                    {
                        if (max != int(0x7fffffffu))
                            max++;

                        if (!arg.dEfault && !isImplicit)
                            min++;

                    };
                    if (arg.flags & s_Flags_F_REST_ARG)
                        max = int(0x7fffffffu);

                    if ((arg.flags & s_Flags_F_VAL) && is_mutref_9CJmuVSD(arg.type, _here, ctx))
                        BUG_gDsnGKHT("F_VAL but arg.type.is_mutref"_fu, ss, _helpers, _here, ctx, module, options);
                    else if (isMutRef_gDsnGKHT(arg.flags) && arg.type && !is_mutref_9CJmuVSD(arg.type, _here, ctx))
                        BUG_gDsnGKHT("F_MUT|F_REF but !arg.type.is_mutref"_fu, ss, _helpers, _here, ctx, module, options);
                    else
                    {
                        if (!(args.size() == i_1))
                            BUG_gDsnGKHT("TODO_FIX_mayAlias_ensureStable: the stuff below relies on argument indices being 1:1"_fu, ss, _helpers, _here, ctx, module, options);

                    };
                    args.push(static_cast<s_Argument&&>(arg));
                };
            }
            else
            {
                BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
            };
        };
        int BL_63_v {};
        for (int i_2 = 0; i_2 < (__extension__ (
        {
            const s_Set_95BJOojOc45& _ = TODO_FIX_mayAlias_ensureStable;
            BL_63_v = (_.keys_asc.size());
        (void)0;}), BL_63_v); i_2++)
        {
            int BL_66_v {};
            const int i_3 = (__extension__ (
            {
                const s_Set_95BJOojOc45& _ = TODO_FIX_mayAlias_ensureStable;
                const int i_4 = i_2;
                BL_66_v = (_.keys_asc[i_4]);
            (void)0;}), BL_66_v);
            s_Argument& arg = args.mutref(i_3);
            if (is_sliceable_hxWWgdZ1(arg.type.vtype) && !TODO_FIX_isArray_9CJmuVSD(arg.type))
            {
                arg.type.vtype.quals |= q_rx_resize;
                s_SolvedNode& argNode = GET_mut_gDsnGKHT(items[i_3].target, ss, module).solved;
                if (is_sliceable_hxWWgdZ1(argNode.type.vtype) && !TODO_FIX_isArray_9CJmuVSD(argNode.type))
                    argNode.type.vtype.quals |= q_rx_resize;
                else
                    BUG_gDsnGKHT(((((("TODO_FIX_mayAlias_ensureStable[2] ("_fu + arg.name) + "): "_fu) + argNode.value) + " : "_fu) + explainType_gDsnGKHT(argNode.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            }
            else
                BUG_gDsnGKHT("TODO_FIX_mayAlias_ensureStable[1]"_fu, ss, _helpers, _here, ctx, module, options);

        };

        {
            if (is_ref_9CJmuVSD(retval))
            {
                TEST_Lifetime_FDl5ha9X(retval.lifetime, retval, false, false, ss, _helpers, _here, ctx, module, options);
            };
            retval.lifetime = Lifetime_process_aPoUrGef(retval.lifetime, argPos_1b, args, ss, _helpers, _here, ctx, module, options);
            for (int i_3 = 0; i_3 < args.size(); i_3++)
            {
                s_Argument& arg = args.mutref(i_3);
                if (!(arg.flags & s_Flags_F_LT_RETURNED))
                {
                    if (is_ref_9CJmuVSD(arg.type) && willPassByValue_gDsnGKHT(arg, _here, ctx))
                        arg.type = clear_refs_9CJmuVSD(s_Type(arg.type));

                };
            };
        };
        if (retval)
        {
            if (is_ref_9CJmuVSD(retval))
            {
                if (isIrrelevant_9CJmuVSD(retval))
                {
                    retval.lifetime = Lifetime_static_moveable;
                };
                TEST_Lifetime_FDl5ha9X(retval.lifetime, retval, false, true, ss, _helpers, _here, ctx, module, options);
            };
            const s_Type& retval_1 = retval;

            {
                Lifetime_each_hZI4uDKg(retval_1.lifetime, retval_1, ss, _helpers, _here, ctx, module, options);
                if (isNative && is_Typename_9CJmuVSD(retval_1))
                    BUG_gDsnGKHT(("updateScope: native retval.is_Typename: "_fu + explainType_gDsnGKHT(retval_1, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

            };
            s_Overload BL_82_v {};
            s_Overload overload = (__extension__ (
            {
                const s_Overload& __partcopy_ref = GET_gDsnGKHT(target, ss, _here, ctx, module);
                BL_82_v = (s_Overload { {}, __partcopy_ref.flags, {}, {}, {}, s_Type(__partcopy_ref.type), {} });
            (void)0;}), static_cast<s_Overload&&>(BL_82_v));
            s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
            bool change = false;
            const bool hasCallers = !!EPH_gDsnGKHT(target, ss, module).callers;
            if (hasCallers)
            {
                if (!(change))
                    change = ((args.size() != ext.args.size()) || !(overload.type == retval_1));

                if (!change)
                {
                    for (int i_3 = 0; i_3 < args.size(); i_3++)
                    {
                        const s_Argument& a = args[i_3];
                        const s_Argument& b = ext.args[i_3];
                        if (!((a.name == b.name) && (ignoreLocalLts_gDsnGKHT(a.type, ss, _helpers, _here, ctx, module, options) == ignoreLocalLts_gDsnGKHT(b.type, ss, _helpers, _here, ctx, module, options))))
                        {
                            change = true;
                            break;
                        };
                    };
                };
            };
            ext.min = min;
            ext.max = max;
            ext.args = args;
            if (!isNative)
                ext.fx_mask = _current_fn.effects.fx_mask;

            ext.cows_inside = _current_fn.events.cows_inside;
            if (const s_Target& retval_targ = tryLookupUserType_1qjplDUo(retval_1.vtype, _here, ctx, module).target)
                ext.tEmplate.node.asserts |= EXT_gDsnGKHT(retval_targ, ss, ctx, module).tEmplate.node.asserts;

            if (s_DeclAsserts((asserts & s_DeclAsserts_A_NOTHROW)) && s_FxMask((ext.fx_mask & s_FxMask_Fx_Throws)))
            {
                fu::str _4 {};
                fu::view<char> _5 {};
                fu::str _6 {};
                (_6 = (_4 = x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not nothrow, throws here:\n"_fu), (static_cast<fu::str&&>(_4) + ((_5 = qSTACK_effect_gDsnGKHT(target, _current_fn.out, s_FxMask_Fx_Throws, fu::view<s_Target>{}, _current_fn, ss, _here, ctx, module, options)) ? static_cast<fu::view<char>&&>(_5) : BUG_u9Gbkniv("Empty nothrow qSTACK"_fu, _here, ctx)))), fail_gDsnGKHT(static_cast<fu::str&&>(_6), "nothrow"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
            }
            else if (s_DeclAsserts((asserts & s_DeclAsserts_A_NOCRASH)) && s_FxMask((ext.fx_mask & s_FxMask_Fx_Crashes)))
            {
                fu::str _7 {};
                fu::view<char> _8 {};
                fu::str _9 {};
                (_9 = (_7 = x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not nocrash, can crash here:\n"_fu), (static_cast<fu::str&&>(_7) + ((_8 = qSTACK_effect_gDsnGKHT(target, _current_fn.out, s_FxMask_Fx_Crashes, fu::view<s_Target>{}, _current_fn, ss, _here, ctx, module, options)) ? static_cast<fu::view<char>&&>(_8) : BUG_u9Gbkniv("Empty nocrash qSTACK"_fu, _here, ctx)))), fail_gDsnGKHT(static_cast<fu::str&&>(_9), "nocrash"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
            }
            else if (s_DeclAsserts((asserts & s_DeclAsserts_A_NOIO)) && s_FxMask((ext.fx_mask & s_FxMask((s_FxMask_Fx_Input | s_FxMask_Fx_Output)))))
            {
                fu::str _10 {};
                fu::view<char> _11 {};
                fu::str _12 {};
                (_12 = (_10 = x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not noio, performs I/O here:\n"_fu), (static_cast<fu::str&&>(_10) + ((_11 = qSTACK_effect_gDsnGKHT(target, _current_fn.out, s_FxMask((s_FxMask_Fx_Input | s_FxMask_Fx_Output)), fu::view<s_Target>{}, _current_fn, ss, _here, ctx, module, options)) ? static_cast<fu::view<char>&&>(_11) : BUG_u9Gbkniv("Empty noio qSTACK"_fu, _here, ctx)))), fail_gDsnGKHT(static_cast<fu::str&&>(_12), "noio"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
            }
            else if (s_DeclAsserts((asserts & s_DeclAsserts_A_PURE_FX)) && s_FxMask((ext.fx_mask & s_FxMask_Fx_Output)))
            {
                fu::str _13 {};
                fu::view<char> _14 {};
                fu::str _15 {};
                (_15 = (_13 = x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not purefx, outputs here:\n"_fu), (static_cast<fu::str&&>(_13) + ((_14 = qSTACK_effect_gDsnGKHT(target, _current_fn.out, s_FxMask_Fx_Output, fu::view<s_Target>{}, _current_fn, ss, _here, ctx, module, options)) ? static_cast<fu::view<char>&&>(_14) : BUG_u9Gbkniv("Empty purefx qSTACK"_fu, _here, ctx)))), fail_gDsnGKHT(static_cast<fu::str&&>(_15), "purefx"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
            }
            else if (s_DeclAsserts((asserts & s_DeclAsserts_A_NOFLOW)) && _current_fn.far_jumps)
            {
                fail_gDsnGKHT((x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not noflow: contains non-local control flow, jumping out to "_fu), str_FDl5ha9X(localfn_gDsnGKHT(first_DX9UgGp0(_current_fn.far_jumps.keys_asc), module), false, ss, _here, ctx, module, options)) + "."_fu), "noflow"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
            {
                if (maybeLast && !mustBecomeInline)
                {
                    if (!(numArgsWritten || ext.fx_mask || !is_void_9CJmuVSD(retval_1.vtype) || (overload.flags & s_Flags_F_LAX) || some_63Tr7AIx(args)))
                    {
                        push_FDl5ha9X(s_Warning { 0x11110000 }, _current_fn, ss);
                    };
                };
                s_Overload& overload_1 = GET_mut_gDsnGKHT(target, ss, module);
                overload_1.type = retval_1;
                overload_1.flags = _current_fn.out.flags;
                const s_Kind kind = (isUnspec ? s_Kind_template : (isNative ? s_Kind___native : (mustBecomeInline ? s_Kind_inline : s_Kind_fn)));
                if (kind != overload_1.kind)
                {
                    overload_1.kind = kind;
                    change = true;
                };

                {
                    const bool rtl = (((args.size() == 2) && (overload_1.flags & s_Flags_F_OPERATOR)) ? hasAssignment_vRqJr3WR(overload_1.name) : false);
                    isRTL_set_xQNS19Zn(overload_1, rtl);
                };
                const s_SolvedNode& solved = (!isUnspec ? _current_fn.out : (*(const s_SolvedNode*)fu::NIL));
                if (hasCallers)
                {
                    if (!change && (kind == s_Kind_inline))
                        change = astChange_gDsnGKHT(overload_1.solved, solved);

                    if (change)
                        overload_1.status |= s_SolverStatus_SS_UPDATED;

                };
                overload_1.solved = solved;
                if (overload_1.flags & s_Flags_F_CONVERSION)
                {
                    if (is_zeroes_9CJmuVSD(retval_1.vtype))
                    {
                        fail_gDsnGKHT((((x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " returns type "_fu) + explainTypeName_gDsnGKHT(retval_1, false, _here, ctx, module, options)) + "."_fu) + "\n\n\tThis would make the conversion function ambiguous because it assigns to anything."_fu), "using"_fu, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    };
                };
                if (overload_1.status & s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE)
                {
                    overload_1.status &= s_SolverStatus(~s_SolverStatus_SS_OBSERVED_BY_CONV_CACHE);
                    if (overload_1.flags & s_Flags_F_CONVERSION)
                        clear_LqmWP5WQ(ss._conv_cache);
                    else if (overload_1.flags & s_Flags_F_USING)
                    {
                        remove_qacjtO9I(ss._conv_cache, s_ValueType{});
                    }
                    else
                        BUG_gDsnGKHT("SS_OBSERVED_BY_CONV_CACHE but !F_CONVERSION && !F_USING"_fu, ss, _helpers, _here, ctx, module, options);

                };
                s_Ephemeral& eph = EPH_mut_FDl5ha9X(target, ss, module);
                eph.far_jumps = _current_fn.far_jumps;
                eph.rev_spec.prototype = steal_fgQ7FGOB(_current_fn.rev_spec_proto);
            };
        }
        else
            BUG_gDsnGKHT("updateScope: no return type."_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT("doUpdateScope: target mismatch"_fu, ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_mangleArgTypes_jyKPa9MxB3k
                                #define DEF_mangleArgTypes_jyKPa9MxB3k
inline static fu::str mangleArgTypes_jyKPa9Mx(fu::view<s_Argument> args)
{
    /*MOV*/ fu::str mangle = ""_fu;
    int numNonInjected = 0;
    for (int i = 0; i < args.size(); i++)
    {
        const s_Argument& arg = args[i];
        if (!(arg.flags & s_Flags_F_INJECTED))
        {
            if (numNonInjected++)
                mangle += ',';

            const s_Type& argType = arg.type;
            if (argType)
                mangle += serializeType_1qjplDUo(argType.vtype, "mangle[$T]"_fu);

        };
    };
    return /*NRVO*/ mangle;
}
                                #endif

                                #ifndef DEF___MQOySOf9ICe
                                #define DEF___MQOySOf9ICe
inline static bool _MQOySOf9(const int callee, const s_Target& target, const int self, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int _0 {};
    return (_0 = self, remove_L2yJ8xEl(EPH_mut_FDl5ha9X(localfn_gDsnGKHT(callee, module), ss, module).callers, _0)) || BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo("doTrySpec: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + " not listed as a caller of "_fu), str_FDl5ha9X(localfn_gDsnGKHT(callee, module), false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF___nQytMiqZql8
                                #define DEF___nQytMiqZql8
inline static bool _nQytMiqZ(const int key, const s_Target& target, const int self, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return _MQOySOf9(key, target, self, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_fpg3WuEsKb9
                                #define DEF_each_fpg3WuEsKb9
inline void each_fpg3WuEs(const s_Map_2goAfCfe5Ta& _, const s_Target& target, const int self, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _nQytMiqZ(key, target, self, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_each_hmr1Wh0W3bd
                                #define DEF_each_hmr1Wh0W3bd
inline void each_hmr1Wh0W(const s_CountedSet_95BJOojOc45& _, const s_Target& target, const int self, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_fpg3WuEs(_.counts, target, self, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_last_LbltPilu7l1
                                #define DEF_last_LbltPilu7l1
inline s_Node& last_LbltPilu(fu::view_mut<s_Node> s)
{
    return s.mutref((s.size() - 1));
}
                                #endif

                                #ifndef DEF_F_TODO_FIX_TRAILING_RETURN
                                #define DEF_F_TODO_FIX_TRAILING_RETURN
extern const s_Flags F_TODO_FIX_TRAILING_RETURN;
                                #endif

static bool TODO_FIX_optionalSemis_blockWantsVoid_gDsnGKHT(const s_HelpersData& h)
{
    return is_void_9CJmuVSD((h.ret_expect ? h.ret_expect : h.ret_actual).vtype);
}

                                #ifndef DEF_x3C_RR8cQKhYHxc
                                #define DEF_x3C_RR8cQKhYHxc
inline bool operator<(fu::view<char> a, fu::view<char> b)
{
    return x3Cx3E_bv5nK4Kl(a, b) < 0;
}
                                #endif

static bool compare_gDsnGKHT(const s_SolvedNode& a, const s_SolvedNode& b, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Overload& a_1 = GET_gDsnGKHT(a.target, ss, _here, ctx, module);
    const s_Overload& b_1 = GET_gDsnGKHT(b.target, ss, _here, ctx, module);
    fu::view<char> an = a_1.name;
    fu::view<char> bn = b_1.name;
    const s_ClosureID acid = tryParseClosureID_UvH3gYAB(an, _here, ctx);
    const s_ClosureID bcid = tryParseClosureID_UvH3gYAB(bn, _here, ctx);
    if (acid)
    {
        if (bcid)
        {
            int BL_3_v {};
            int BL_4_v {};
            int _0 {};
            int BL_5_v {};
            const int cmp = ((_0 = ((__extension__ (
            {
                const s_Target& t = bcid.target;
                BL_3_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_3_v) - (__extension__ (
            {
                const s_Target& t = acid.target;
                BL_4_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_4_v))) ? _0 : (__extension__ (
            {
                int BL_6_v {};
                const int a_2 = (__extension__ (
                {
                    const s_Target& t = acid.target;
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_6_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_6_v);
                int BL_7_v {};
                const int b_2 = (__extension__ (
                {
                    const s_Target& t = bcid.target;
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_7_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_7_v);
                BL_5_v = (((a_2 < 0) ? ((b_2 < 0) ? (b_2 - a_2) : -1) : ((b_2 < 0) ? +1 : (a_2 - b_2))));
            (void)0;}), BL_5_v));
            return cmp < 0;
        }
        else
            return true;

    }
    else if (bcid)
        return false;

    return an < bn;
}

static void sort_gDsnGKHT(fu::view_mut<s_SolvedNode> a, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    s_SolvedNode l {};
    s_SolvedNode r {};
    (void) l;
    (void) r;
    auto* data = a.data_mut();
    std::sort(data, data + a.size(), [&](auto& l, auto& r)
    {;
    bool lt = compare_gDsnGKHT(l, r, ss, _here, ctx, module);
    return lt;
            });

}

                                #ifndef DEF_sort_3dsmXIfCIBj
                                #define DEF_sort_3dsmXIfCIBj
inline void sort_3dsmXIfC(fu::view_mut<s_SolvedNode> a, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    sort_gDsnGKHT(a, ss, _here, ctx, module);
}
                                #endif

static void sortInjectedArguments_gDsnGKHT(s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    fu::view_mut<s_SolvedNode> args = fu::get_view_start0_mut(_current_fn.out.items, (_current_fn.out.items.size() + FN_ARGS_BACK));
    for (int i = 0; i < args.size(); i++)
    {
        const s_SolvedNode& arg = args[i];
        if (arg.target && (GET_gDsnGKHT(arg.target, ss, _here, ctx, module).flags & s_Flags_F_INJECTED))
        {
            sort_3dsmXIfC(fu::get_view_mut(args, i), ss, _here, ctx, module);
            return;
        };
    };
}

static void visit_q5Q6zgXB(const s_Lifetime& lifetime, s_Lifetime& result, bool& maybeOutOfOrder, const bool locals_only, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit(chars, offset);
            int BL_4_v {};
            const int sr = (__extension__ (
            {
                offset0_1 = (offset + 0);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                BL_4_v = (offset0_1);
            (void)0;}), BL_4_v);

            { {
                int BL_13_v {};
                const int locid = ((r & 1u) ? 0 : (__extension__ (
                {
                    const unsigned v = (r >> 1u);
                    BL_13_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_13_v));
                fu::view<char> paths = fu::get_view(chars, sr, offset);
                if (!locid)
                {
                    if (locals_only)
                        goto BL_12;

                }
                else
                {
                    const s_Type& init = Lifetime_climbType_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _helpers, _here, ctx, module, options);
                    if (is_ref_9CJmuVSD(init))
                    {
                        s_Lifetime parent = Lifetime_op_join_7Yz9ezW2(init.lifetime, paths, _here, ctx);
                        maybeOutOfOrder = true;
                        visit_q5Q6zgXB(parent, result, maybeOutOfOrder, locals_only, ss, _helpers, _here, ctx, module, options);
                        continue;
                    };
                };
                goto BL_3;
              } BL_12:;
            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_mwube4ZmsA8
                                #define DEF_Lifetime_process_mwube4ZmsA8
inline s_Lifetime Lifetime_process_mwube4Zm(const s_Lifetime& lifetime, const bool locals_only, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_Lifetime result {};
    bool maybeOutOfOrder = false;
    visit_q5Q6zgXB(lifetime, result, maybeOutOfOrder, locals_only, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ result;
}
                                #endif

static s_Lifetime Lifetime_unwind_gDsnGKHT(const s_Lifetime& lifetime, const bool locals_only, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return Lifetime_process_mwube4Zm(lifetime, locals_only, ss, _helpers, _here, ctx, module, options);
}

static void mcom_FnReturn_CopyOrMoveDecision_gDsnGKHT(const s_Helpers& h, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Type& retval = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual;
    if (!(!is_ref_9CJmuVSD(retval)))
    {
        /*MOV*/ s_Lifetime unwound = Lifetime_unwind_gDsnGKHT(retval.lifetime, false, ss, _helpers, _here, ctx, module, options);

        {
            fu::view<char> chars = unwound.uni0n;
            int offset = 0;
            while (offset < chars.size())
            {
                const unsigned r = parse7bit(chars, offset);
                for (; ; )
                {
                    bool isLastPath = false;
                    bool isFirstSubRegion = true;
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(chars, offset);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                        isLastPath = !(raw_flatCount & 1u);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion = false;

                    };
                    if (isLastPath)
                        break;

                };
                int BL_12_v {};
                const int locid = ((r & 1u) ? 0 : (__extension__ (
                {
                    const unsigned v = (r >> 1u);
                    BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_12_v));
                const bool isStatic = ((r & 11u) == 1u);
                const bool isTemp = (r == 0b1001u);
                const s_Target t = (locid ? nested_FDl5ha9X(locid, ss, _here, ctx) : s_Target{});
                int BL_13_v {};
                const bool isRefArg = (((__extension__ (
                {
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_13_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_13_v) < 0) ? !isMutVal_gDsnGKHT(GET_gDsnGKHT(t, ss, _here, ctx, module)) : false);
                if (!isRefArg && !isStatic)
                {
                    if (locid || isTemp)
                    {
                        reportReturnType_gDsnGKHT(h, clear_refs_9CJmuVSD(s_Type((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)), false, _current_fn, ss, _helpers, _here, ctx, module, options);
                        return;
                    }
                    else
                        BUG_gDsnGKHT("mcom_FnReturn_CopyOrMoveDecision: !locid && !isStatic && !isTemp."_fu, ss, _helpers, _here, ctx, module, options);

                };
            };
        };
        (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual.lifetime = static_cast<s_Lifetime&&>(unwound);
    };
}

static s_SolvedNode solveBlock_gDsnGKHT(const s_Node& node, const s_Type& type, const int fnbody_of, const s_HelpersMask mask, const fu::str& id, const int locals_start, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    fu::vec<s_Node> nodes = ((node.kind == s_Kind_block) ? fu::vec<s_Node>(node.items) : fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node(node) } });
    const fu::str& id_1 = (id ? id : ((node.kind == s_Kind_block) ? node.value : (*(const fu::str*)fu::NIL)));
    const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
    fu_DEFER(if (!s_HelpersMask((mask & s_HelpersMask_HM_LoopPreheader)))
        Scope_pop_gDsnGKHT(scope0, ss, _helpers););
    const int helpers_idx = _helpers.size();
    int BL_2_v {};
    push_gDsnGKHT(s_HelpersData { (fnbody_of ? localfn_gDsnGKHT(fnbody_of, module) : s_Target{}), s_SolverPass{}, mask, fu::str(id_1), (fnbody_of ? fnbody_of : (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_2_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_2_v)), (fnbody_of ? +1 : (locals_start ? locals_start : GET_next_local_index_gDsnGKHT(_current_fn, ss, _here, ctx))), s_Type(type), s_Type{}, s_Postdom{}, s_Postdom{}, s_EventsSnap{}, s_Helpers{} }, ss, _helpers);
    const s_Helpers h { _helpers[helpers_idx] };
    if (fnbody_of && nodes)
    {
        s_Node& last = last_LbltPilu(nodes);
        if (last.kind == s_Kind_unwrap)
            _current_fn.TODO_FIX_isInline = true;
        else
        {
            const bool NICEERR_missingReturn = ((node.kind == s_Kind_block) ? ((last.kind == s_Kind_empty) || s_ParseSyntax((last.syntax & s_ParseSyntax_PS_ALWAYS_DISCARD))) : false);
            last = s_Node { s_Kind_return, s_DeclAsserts{}, s_ParseSyntax{}, (((NICEERR_missingReturn ? s_Flags_F_IMPLICIT : s_Flags{}) | s_Flags_F_LAMBDA) | F_TODO_FIX_TRAILING_RETURN), fu::str{}, ((last.kind != s_Kind_empty) ? fu::vec<s_Node> { fu::slate<1, s_Node> { s_Node(last) } } : fu::vec<s_Node>{}), s_TokenIdx(last.token) };
        };
    };
    fu::vec<s_SolvedNode> items = solveNodes_gDsnGKHT(nodes, s_DeadBreak_DeadBreak_Always, t_void, type, !is_void_9CJmuVSD(type.vtype), s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (TODO_FIX_optionalSemis_blockWantsVoid_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx))))
    {
        if (items && !isIrrelevantOrNever_9CJmuVSD(last_31malqbt(items).type))
        {
            items += createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
    };
    if (!fnbody_of)
    {
        (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect = s_Type{};
    };

    {
        const s_Type& tail = (items ? last_31malqbt(items).type : t_void);
        if (!is_never_9CJmuVSD(tail.vtype))
            reportReturnType_gDsnGKHT(h, tail, false, _current_fn, ss, _helpers, _here, ctx, module, options);
        else if (!(((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual = s_Type(t_never);

    };
    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)
    {
        const s_Type* _0;
        /*MOV*/ s_SolvedNode block = createBlock_gDsnGKHT((*(_0 = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)), items, h, _here);
        if (fnbody_of)
        { {
            const s_SolverStatus status = GET_gDsnGKHT(localfn_gDsnGKHT(fnbody_of, module), ss, _here, ctx, module).status;
            if (!s_SolverStatus((status & s_SolverStatus_SS_DIRTY)))
            {
                sortInjectedArguments_gDsnGKHT(_current_fn, ss, _here, ctx, module);
                if (currentFn_mustBecomeInline_gDsnGKHT(_current_fn))
                {
                    mcom_FnReturn_CopyOrMoveDecision_gDsnGKHT(h, _current_fn, ss, _helpers, _here, ctx, module, options);
                    goto BL_13;
                }
                else
                {

                    {
                        /*MOV*/ s_SolvedNode solved { _current_fn.out };
                        last_fjKdEPCD(solved.items) = s_SolvedNode(block);
                        const s_Target target = localfn_gDsnGKHT(fnbody_of, module);
                        _current_fn.rev_spec_proto = s_RevSpecPrototype { static_cast<s_SolvedNode&&>(solved), fu::vec<s_Overload>(EXT_gDsnGKHT(target, ss, ctx, module).args_n_locals), EXT_gDsnGKHT(target, ss, ctx, module).args_neg };
                    };
                    runAllPasses_gDsnGKHT(block, _current_fn, ss, _helpers, _here, ctx, module, options);
                };
            };
          } BL_13:;
        };
        return /*NRVO*/ block;
    }
    else
        BUG_gDsnGKHT("No ret_actual"_fu, ss, _helpers, _here, ctx, module, options);

}

static fu::view<s_SolvedNode> outItems_iUdwqyBn(const s_CurrentFn& _current_fn)
{
    return _current_fn.out.items;
}

static const s_Ephemeral& EPH_mut_wyx7msfr(const s_Target& target, s_SolverState& ss, const s_Module& module)
{
    if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
        return EPH_mut_iUdwqyBn(int(unsigned(((target._packed >> 20ull) & 0xfffffull))), ss);
    else
        fu::fail("EPH_mut: modid is off."_fu);

}

                                #ifndef DEF___X72V2SCFEN8
                                #define DEF___X72V2SCFEN8
inline static void _X72V2SCF(int index, fu::vec<int>& reopen, const int parent, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (; ; )
    {
        const s_Target t = localfn_gDsnGKHT(index, module);
        s_Overload& o = GET_mut_gDsnGKHT(t, ss, module);
        if (s_SolverStatus((o.status & s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_DIRTY)))) != s_SolverStatus_SS_DID_START)
            return;
        else if (!s_SolverStatus((o.status & s_SolverStatus_SS_FINALIZED)))
        {
            o.status |= s_SolverStatus_SS_DIRTY;
            return;
        }
        else
        {
            const int up = EPH_gDsnGKHT(t, ss, module).local_of;
            if (up != parent)
            {
                if (up > parent)
                    index = up;
                else
                    BUG_gDsnGKHT("lazySolveEnd: about to climb up the wrong tree."_fu, ss, _helpers, _here, ctx, module, options);

            }
            else
            {

                {
                    const s_SolverNotes note = ((o.kind == s_Kind_type) ? s_SolverNotes_N_TypeReopen : s_SolverNotes_N_FnReopen);
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        ss._notes |= note;

                };
                o.status &= s_SolverStatus(~s_SolverStatus((s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_DIRTY)) | s_SolverStatus_SS_FINALIZED)));
                reopen += index;
                return;
            };
        };
    };
}
                                #endif

                                #ifndef DEF___yI34n1lLDCb
                                #define DEF___yI34n1lLDCb
inline static void _yI34n1lL(const int key, fu::vec<int>& reopen, const int parent, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    _X72V2SCF(key, reopen, parent, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_Y6GP5YLl0E4
                                #define DEF_each_Y6GP5YLl0E4
inline void each_Y6GP5YLl(const s_Map_2goAfCfe5Ta& _, fu::vec<int>& reopen, const int parent, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < _.vals.size(); i++)
    {
        const int key = _.keys.keys_asc[i];
        _yI34n1lL(key, reopen, parent, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_each_urivHUtYKg8
                                #define DEF_each_urivHUtYKg8
inline void each_urivHUtY(const s_CountedSet_95BJOojOc45& _, fu::vec<int>& reopen, const int parent, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_Y6GP5YLl(_.counts, reopen, parent, ss, _helpers, _here, ctx, module, options);
}
                                #endif

static void lazySolveEnd_gDsnGKHT(const s_Target& t, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Overload& o = GET_mut_gDsnGKHT(t, ss, module);
    fu::vec<int> reopen {};
    const int parent = EPH_gDsnGKHT(t, ss, module).local_of;
    if (o.status & s_SolverStatus_SS_UPDATED)
    {
        o.status &= s_SolverStatus(~s_SolverStatus_SS_UPDATED);
        s_CountedSet_95BJOojOc45 callers { EPH_mut_wyx7msfr(t, ss, module).callers };
        each_urivHUtY(callers, reopen, parent, ss, _helpers, _here, ctx, module, options);
    };
    s_Overload& o_1 = GET_mut_gDsnGKHT(t, ss, module);
    if (!s_SolverStatus((o_1.status & s_SolverStatus_SS_DIRTY)))
    {
        o_1.status |= s_SolverStatus_SS_FINALIZED;
        fu::vec<s_RevSpecOutput> rev_specs { ((o_1.kind == s_Kind_fn) ? EPH_gDsnGKHT(t, ss, module).rev_spec.outputs : (*(const fu::vec<s_RevSpecOutput>*)fu::NIL)) };
        if (rev_specs)
        {
            const unsigned actual = o_1.type.vtype.quals;
            for (int i = 0; i < rev_specs.size(); i++)
            {
                const s_RevSpecOutput rev_spec { rev_specs[i] };
                const s_Target t_1 { rev_spec.instance_targ };
                s_Overload& o_2 = GET_mut_gDsnGKHT(t_1, ss, module);
                if ((actual & rev_spec.relaxed_quals) == rev_spec.relaxed_quals)
                {
                    o_2.status &= s_SolverStatus(~s_SolverStatus((s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_DIRTY)) | s_SolverStatus_SS_FINALIZED)));
                    lazySolveStart_gDsnGKHT(t_1, _current_fn, ss, _helpers, _here, ctx, module, options);
                }
                else if (o_2.kind != s_Kind___tombstone)
                    destroyOverload_gDsnGKHT(t_1, ss, module);

            };
        };
    }
    else if (o_1.status & s_SolverStatus_SS_FINALIZED)
        BUG_gDsnGKHT("Stray SS_FINALIZED."_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        o_1.status &= s_SolverStatus(~s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_DIRTY)));
        const s_SolverNotes note = ((o_1.kind == s_Kind_type) ? s_SolverNotes_N_TypeResolve : s_SolverNotes_N_FnResolve);
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            ss._notes |= note;

    };
    for (int i = 0; i < reopen.size(); i++)
    {
        const s_Target t_1 = localfn_gDsnGKHT(reopen[i], module);
        lazySolveStart_gDsnGKHT(t_1, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}

static s_Target doTrySpecialize_gDsnGKHT(const int parent_idx, fu::str& error, const s_Target& into, const s_Target& overloadIdx, fu::view<s_SolvedNode> args_in, const fu::str& mangle, const s_Reorder& reorder, fu::view<fu::vec<s_Target>> conversions, const int REST_START, const s_Type& REST_TYPE, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Target SPECFAIL_RentrySafety = s_Target { 0x8000000000000000ull };
    const int err0 = error.size();
    const s_Target& original = (overloadIdx ? overloadIdx : into ? into : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
    s_Template tEmplate { EXT_gDsnGKHT(original, ss, ctx, module).tEmplate };
    const s_TokenIdx here0 { _here };
    _here = EXT_gDsnGKHT(original, ss, ctx, module).tEmplate.node.token;
    const int solver_safety0 = ss._solver_safety++;
    if ((solver_safety0 >= 128))
    {
        fail_gDsnGKHT(("Solver stack got too deep, was about to start working on "_fu + qID_e44UlzzA(tEmplate.node.value)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        fu_DEFER(
        {
            _here = here0;
            ss._solver_safety = solver_safety0;
        });
        s_Set_6ARmtH0K78f mangles {};
        s_Target currentSpec { SPECFAIL_RentrySafety };
        fu::view<s_Node> items = tEmplate.node.items;
        const int numArgs = ((tEmplate.node.kind == s_Kind_fn) ? (items.size() + FN_ARGS_BACK) : BUG_gDsnGKHT("template.node.kind != `fn`"_fu, ss, _helpers, _here, ctx, module, options));
        s_Map_lhf7SV3Fyjf typeParams0 = steal_HPql5iRS(ss._typeParams);
        fu_DEFER(std::swap(ss._typeParams, typeParams0));
        if (!into)
        {
            bool fail = false;
            fu::vec<s_Type> args {};
            if (reorder)
            {
                for (int i = 0; i < reorder.map.size(); i++)
                {
                    const int callsiteIndex = reorder.map[i];
                    args.push(s_Type((((callsiteIndex >= 0) && (callsiteIndex < args_in.size())) ? args_in[callsiteIndex].type : (*(const s_Type*)fu::NIL))));
                };
            }
            else
                for (int i = 0; i < args_in.size(); i++)
                    args.push(s_Type(args_in[i].type));
;
            for (int i = 0; i < conversions.size(); i++)
            {
                s_Type& arg = args.mutref(i);
                arg = conversionTailType_gDsnGKHT(arg, conversions[i], ss, _here, ctx, module);
            };
            if (REST_TYPE)
                args.mutref(REST_START) = s_Type(REST_TYPE);

            fu::vec<s_RetypeOrder> retypeIndices {};
            for (int pass_retype = 0; (pass_retype == 0) || ((pass_retype == 1) && retypeIndices); pass_retype++)
            {
                const int N = (pass_retype ? (sort_qDmV1ybC(retypeIndices), retypeIndices.size()) : numArgs);
                for (int i_1 = 0; i_1 < N; i_1++)
                {
                    const int i_2 = (pass_retype ? retypeIndices[i_1].index : i_1);
                    /*MOV*/ s_Type inType { ((args.size() > i_2) ? args[i_2] : (*(const s_Type*)fu::NIL)) };
                    const s_SolvedNode& inValue = (reorder ? (((reorder.map.size() > i_2) && (reorder.map[i_2] >= 0)) ? args_in[reorder.map[i_2]] : (*(const s_SolvedNode*)fu::NIL)) : ((args_in.size() > i_2) ? args_in[i_2] : (*(const s_SolvedNode*)fu::NIL)));
                    const s_Node* _0;
                    const s_Node& argNode = (*(_0 = &(items[i_2])) ? *_0 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                    const s_Node& annot = argNode.items[LET_TYPE];
                    /*MOV*/ s_Argument host_arg { EXT_gDsnGKHT(original, ss, ctx, module).args[i_2] };
                    const s_SolvedNode& inValue_1 = ((!host_arg.dEfault || !is_zeroes_9CJmuVSD(inValue.type.vtype)) ? inValue : (*(const s_SolvedNode*)fu::NIL));
                    s_SolvedNode inValue_2 { (inValue_1 ? inValue_1 : ((inType = host_arg.dEfault.type), host_arg.dEfault)) };
                    const int retype_score = couldRetype_gDsnGKHT(inValue_2);
                    if (retype_score)
                    {
                        if (!pass_retype)
                        {
                            retypeIndices.push(s_RetypeOrder { retype_score, i_2 });
                            continue;
                        }
                        else
                        {
                            s_Type paramType = ((annot.kind == s_Kind_typeparam) ? s_Type(ref_k3fJtwyO(ss._typeParams, annot.value).matched) : (((annot.kind == s_Kind_call) && !annot.items) ? Scope_lookupType_gDsnGKHT(annot.value, annot.flags, _current_fn, ss, _helpers, _here, ctx, module, options) : s_Type{}));
                            if (paramType)
                            {
                                /*MOV*/ s_Type retype = tryRetyping_gDsnGKHT(inValue_2, paramType, ss, _helpers, _here, ctx, module, options);
                                if (retype && (retype.vtype.canon != inType.vtype.canon))
                                {
                                    inType = static_cast<s_Type&&>(retype);
                                    if (args.size() > i_2)
                                        args.mutref(i_2) = s_Type(inType);

                                };
                            };
                        };
                    };
                    if (!pass_retype && (annot.kind == s_Kind_typeunion))
                    {
                        retypeIndices.push(s_RetypeOrder { MAX_u3ymTS2i(), i_2 });
                    }
                    else if (isMutRef_gDsnGKHT(host_arg.flags) && !is_mutref_9CJmuVSD(inType, _here, ctx))
                    {
                        if (error)
                        {
                            fu::view<char> _1 {};
                            error += ((_1 = (x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " "_fu) + explainNotMutref_gDsnGKHT(inType, _current_fn, ss, _here, ctx, module, options))) ? static_cast<fu::view<char>&&>(_1) : BUG_gDsnGKHT("matchFail: No reason."_fu, ss, _helpers, _here, ctx, module, options));
                        };
                        fail = true;
                        goto LL_14;
                    }
                    else if (argNode.kind == s_Kind_let)
                    {
                        if (inType)
                        {
                            ref_anonymize_9CJmuVSD(inType);
                            /*MOV*/ s_Type& exactType = host_arg.type;
                            if (exactType && !isAssignableAsArgument_9CJmuVSD(exactType.vtype, inType.vtype, DONT_match_zeroes, _here, ctx))
                            {
                                if (args.size() > i_2)
                                    args.mutref(i_2) = static_cast<s_Type&&>(exactType);

                                continue;
                            }
                            else
                            {
                                fu::str argName = ((argNode.flags & s_Flags_F_COMPOUND_ID) ? cleanID_V5IuMsej(argNode.value) : fu::str(argNode.value));
                                if (argName)
                                {
                                    s_TypeParam& argName_typeParam = ref_zuiRS11g(ss._typeParams, argName);
                                    const bool isTypedef = !!(argNode.flags & s_Flags_F_TYPENAME);
                                    if (isTypedef)
                                    {
                                        if (!(is_Typename_9CJmuVSD(inType)))
                                            BUG_gDsnGKHT(((argName + " not a typename: "_fu) + explainType_gDsnGKHT(inType, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                                    }
                                    else
                                        inType = clear_Typename_9CJmuVSD(s_Type(inType), false);

                                    inType.vtype.vfacts = (isTypedef ? s_VFacts_Typename : s_VFacts{});
                                    (!argName_typeParam ? argName_typeParam : fail_gDsnGKHT((x7E_3lDd4lqo("Type param name collision with "_fu, str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options)) + "."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)).matched = s_Type(inType);
                                    argName_typeParam.flags |= s_TypeParamFlags_TP_isArgSpec;
                                    if (isTypedef)
                                        argName_typeParam.flags |= s_TypeParamFlags_TP_isTypenameArgSpec;

                                    if (annot && !exactType)
                                    {
                                        fu::str error_1 = (error ? ((((qKW_e44UlzzA("arg"_fu) + " "_fu) + str_IDns_gDsnGKHT(original, ss, _here, ctx, module, options)) + qID_e44UlzzA(argName)) + ":"_fu) : fu::str{});
                                        if (!trySolveTypeParams_gDsnGKHT(annot, static_cast<s_Type&&>(inType), error_1, false, _current_fn, ss, _helpers, _here, ctx, module, options))
                                        {
                                            if (error)
                                                error += (error_1 ? error_1 : BUG_gDsnGKHT("matchFail: No reason."_fu, ss, _helpers, _here, ctx, module, options));

                                            fail = true;
                                            goto LL_14;
                                        };
                                    };
                                }
                                else
                                    BUG_gDsnGKHT("No argName"_fu, ss, _helpers, _here, ctx, module, options);

                            };
                        };
                    }
                    else
                    {
                        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
                    };
                };
            } LL_14:;

            if (!error)
            {
                fu::view<s_Type> args_1 = args;
                const bool allowReplaceNonSpecfails = false;
                int _2 {};
                const int start = ((_2 = (find_yP7FbxFZ(mangle, ' ') + 1)) ? _2 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                fu::str mangle_1 = (fu::slice(mangle, 0, start) + mangleArgTypes_AJPeBvoS(args_1));
                if (add_eHVOG4pi(mangles, mangle_1))
                {
                    const s_Target preexisting { get_DC6o5biX(getSpecs_FDl5ha9X(parent_idx, ss), mangle_1) };
                    if (preexisting)
                    {
                        if (error)
                            BUG_gDsnGKHT("doTrySpec: resetMangle/preexisting on error path"_fu, ss, _helpers, _here, ctx, module, options);
                        else
                        {
                            remove_WUsyyR27(mangles, mangle_1);
                            if (!is_SPECFAIL_gDsnGKHT(currentSpec))
                                destroyOverload_gDsnGKHT(currentSpec, ss, module);

                            resetSpec_gDsnGKHT(preexisting, allowReplaceNonSpecfails, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
                            return preexisting;
                        };
                    }
                    else
                        setSpec_gDsnGKHT(mangle_1, currentSpec, true, false, parent_idx, error, ss, _helpers, _here, ctx, module, options);

                };
            };
            if (fail)
            {
                return SPECFAIL_gDsnGKHT(fu::view<char>{}, parent_idx, error, SPECFAIL_RentrySafety, err0, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
            };
        };
        if (!into)
        {
            const s_Node* _3;
            const s_Node& body = (*(_3 = &(items[(items.size() + FN_BODY_BACK)])) ? *_3 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
            if (body.kind == s_Kind_pattern)
            {
                s_Map_lhf7SV3Fyjf undo { ss._typeParams };
                fu::view<s_Node> branches = body.items;
                bool did_match = false;
                for (int i = 0; i < branches.size(); i++)
                {
                    fu::view<s_Node> branch = branches[i].items;
                    /*MOV*/ s_Node n_body { branch[(branch.size() + FN_BODY_BACK)] };
                    if (isNativeBody_gDsnGKHT(n_body))
                        each_HVikC3Fo(ss._typeParams);

                    const s_Node& cond = branches[i].items[0];
                    if (cond && !evalTypePattern_gDsnGKHT(cond, _current_fn, ss, _helpers, _here, ctx, module, options))
                        ss._typeParams = undo;
                    else
                    {

                        {
                            const s_Node& n_ret = branch[(branch.size() + FN_RET_BACK)];
                            if (n_ret)
                                sig_wyx7msfr(tEmplate).mutref((sig_iUdwqyBn(tEmplate).size() + FN_RET_BACK)) = s_Node(n_ret);

                            sig_wyx7msfr(tEmplate).mutref((sig_iUdwqyBn(tEmplate).size() + FN_BODY_BACK)) = static_cast<s_Node&&>((n_body ? n_body : BUG_gDsnGKHT("doTrySpec: no case/body."_fu, ss, _helpers, _here, ctx, module, options)));
                        };
                        did_match = true;
                        break;
                    };
                };
                if (!did_match)
                    return SPECFAIL_gDsnGKHT("No body pattern matched."_fu, parent_idx, error, SPECFAIL_RentrySafety, err0, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);

            };
            const s_Node& n_body = n_fn_wyx7msfr(tEmplate).items[(n_fn_wyx7msfr(tEmplate).items.size() + FN_BODY_BACK)];
            if (isNativeBody_gDsnGKHT(n_body))
            {
                fu::view_mut<s_Node> argNodes = fu::get_view_start0_mut(n_fn_iUdwqyBn(tEmplate).items, (n_fn_wyx7msfr(tEmplate).items.size() + FN_ARGS_BACK));
                for (int i = 0; i < argNodes.size(); i++)
                {
                    s_Node& argNode = argNodes.mutref(i);
                    if (!((argNode.flags & ((s_Flags_F_REF | s_Flags_F_CONST) | s_Flags_F_MUT)) != s_Flags_F_REF))
                    {
                        fu::str argName = ((argNode.flags & s_Flags_F_COMPOUND_ID) ? cleanID_V5IuMsej(argNode.value) : fu::str(argNode.value));
                        const s_Type* _4;
                        const s_Type& matched = (*(_4 = &(get_usbzfpQ2(ss._typeParams, (argName ? argName : BUG_gDsnGKHT("No argName"_fu, ss, _helpers, _here, ctx, module, options))).matched)) ? *_4 : BUG_gDsnGKHT("native F_REF arg without a matched type"_fu, ss, _helpers, _here, ctx, module, options));
                        if (!is_mutref_9CJmuVSD(matched, _here, ctx))
                            argNode.flags |= s_Flags_F_CONST;

                    };
                };
                each_rZH8cGMF(ss._typeParams);
            };
        };
        s_Target target {};
        if (error)
            BUG_gDsnGKHT("doTrySpecialize: error path about to start solving"_fu, ss, _helpers, _here, ctx, module, options);
        else
        {

            {
                const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
                /*MOV*/ s_ScopeSkipMemos ss0 { ss._ss };
                const int helpers_data0 = ss._helpers_data.size();
                fu_DEFER(
                {
                    Scope_pop_gDsnGKHT(scope0, ss, _helpers);
                    ss._ss = static_cast<s_ScopeSkipMemos&&>(ss0);
                    ss._helpers_data.shrink(helpers_data0);
                });

                {
                    if (ss._root_scope)
                    {
                        const s_Target* _5;
                        const s_Ephemeral& eph = EPH_gDsnGKHT((*(_5 = &(EXT_gDsnGKHT(original, ss, ctx, module).spec_of)) ? *_5 : original), ss, module);
                        const s_ScopeMemo& start = (eph.scope_memo ? eph.scope_memo : ss._root_scope);
                        ss._ss = eph.scope_skip;
                        ScopeSkip_push_gDsnGKHT(ss._ss.items, start.items_len, scope0.items_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.implicits, start.implicits_len, scope0.implicits_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.imports, start.imports_len, scope0.imports_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.privates, start.privates_len, scope0.privates_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.usings, start.usings_len, scope0.usings_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.converts, start.converts_len, scope0.converts_len, ss, _helpers, _here, ctx, module, options);
                        ScopeSkip_push_gDsnGKHT(ss._ss.helpers, start.helpers_len, scope0.helpers_len, ss, _helpers, _here, ctx, module, options);
                    };
                    fu::view<int> imports = tEmplate.imports;
                    for (int i = 0; i < imports.size(); i++)
                    {
                        Scope_import_gDsnGKHT(imports[i], ss, _here, ctx);
                        if (i == 0)
                            Scope_import_privates_gDsnGKHT(imports[i], ss, _here, ctx);

                    };
                };
                target = (into ? s_Target(into) : Scope_create_z0QqoZ5t(ss._scope, s_Kind___no_kind_yet, (*(const fu::str*)fu::NIL), (*(const s_Type*)fu::NIL), s_Flags{}, s_DeclAsserts{}, s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_LAZY)), 0, false, module));
                s_Ephemeral& eph = EPH_mut_FDl5ha9X(target, ss, module);
                eph.local_of = parent_idx;
                s_SpecExtras spec_extras { (into ? EPH_gDsnGKHT(into, ss, module).spec_extras : (EPH_mut_FDl5ha9X(target, ss, module).spec_extras = intoSpecExtras_gDsnGKHT(s_Map_lhf7SV3Fyjf(ss._typeParams), ss, _here, ctx, module))) };
                const s_Target solvingFnort0 = exchange_EqG2aXiz(ss._solvingFnort, s_Target(target));
                const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
                fu_DEFER(
                {
                    ss._solvingFnort = solvingFnort0;
                    ss._nestingFnort = nestingFnort0;
                });

                {
                    s_Ephemeral& eph_1 = EPH_mut_FDl5ha9X(target, ss, module);
                    const unsigned rev0 = eph_1.revision++;
                    if (rev0)
                    {
                        if ((rev0 >= 1024u))
                            BUG_gDsnGKHT((x7E_3lDd4lqo("Looping forever: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + ".revision >= 1024"_fu), ss, _helpers, _here, ctx, module, options);
                        else
                        {
                            s_Extended& o = EXT_mut_gDsnGKHT(target, ss, module);
                            o.args_n_locals.clear();
                            o.args_neg = 0;
                            int BL_79_v {};
                            if (ss._warnings.size() > (__extension__ (
                            {
                                const s_Target& t = target;
                                BL_79_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                            (void)0;}), BL_79_v))
                            {
                                int BL_81_v {};
                                ss._warnings.mutref((__extension__ (
                                {
                                    const s_Target& t = target;
                                    BL_81_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                                (void)0;}), BL_81_v)) = s_Warning{};
                            };
                            fu::vec<s_Target> specs { EPH_gDsnGKHT(target, ss, module).specs.vals };
                            for (int i = 0; i < specs.size(); i++)
                                resetChild_gDsnGKHT(s_Target(specs[i]), ss, _helpers, _here, ctx, module, options);

                        };
                    };
                };
                const s_DeclAsserts asserts = tEmplate.node.asserts;
                s_CurrentFn out = s_CurrentFn { solved_gDsnGKHT(n_fn_FDl5ha9X(tEmplate), X_addrofTarget_FDl5ha9X(target), (*(const fu::vec<s_SolvedNode>*)fu::NIL), target, _here), s_ScopeMemo(scope0), asserts, s_Flow{}, s_Set_95BJOojOc45{}, s_Effects{}, s_Events{}, ((n_fn_FDl5ha9X(tEmplate).flags & s_Flags_F_TEMPLATE) ? 1 : 0), s_VarUsage{}, false, 0, fu::vec<s_Target>{}, 0, 0, s_Postdom{}, s_LocidMap_OjaSaYAvjq2{}, s_RevSpecPrototype{}, 0, 0 };
                const s_ScopeMemo root_scope0 { ss._root_scope };
                if (!root_scope0)
                    ss._root_scope = scope0;

                std::swap(_current_fn, out);
                fu_DEFER(
                {
                    std::swap(_current_fn, out);
                    ss._root_scope = root_scope0;
                });
                fu::view_mut<s_Node> inItems = n_fn_iUdwqyBn(tEmplate).items;
                outItems_gDsnGKHT(_current_fn).resize(inItems.size());
                ss._scope.items += spec_extras.scope_items;
                const bool isFirst = (!into || !GET_gDsnGKHT(into, ss, _here, ctx, module).solved);
                const s_Flags isTemplate = (tEmplate.node.flags & s_Flags_F_TEMPLATE);
                const bool isSpec = (isTemplate ? (!into || !isFirst) : false);
                const bool isUnspec = (isTemplate ? !isSpec : false);
                for (int i = 0; i < (inItems.size() + FN_ARGS_BACK); i++)
                {
                    s_Node& n_arg = inItems.mutref(i);
                    _here = n_arg.token;
                    if (isUnspec)
                    {
                        s_Node& type_annot = n_arg.items.mutref(LET_TYPE);
                        if ((n_arg.flags & s_Flags_F_TEMPLATE) || !type_annot)
                        {
                            if (type_annot)
                                TODO_FIX_partialEvalTypeAnnot_gDsnGKHT(type_annot, _current_fn, ss, _helpers, _here, ctx, module, options);

                            s_SolvedNode init = (n_arg.items[LET_INIT] ? solveNode_gDsnGKHT(n_arg.items[LET_INIT], (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
                            outItems_wyx7msfr(_current_fn).mutref(i) = SolvedNode_gDsnGKHT(s_Kind_let, s_Type{}, n_arg.flags, n_arg.value, fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode{}, s_SolvedNode(init) } }, s_Target{}, s_Helpers{}, _here);
                            continue;
                        };
                    };
                    const s_Type& specType = (isSpec ? get_aWNBBsyM(spec_extras.arg_spec_types, ((n_arg.flags & s_Flags_F_COMPOUND_ID) ? cleanID_V5IuMsej(n_arg.value) : fu::str(n_arg.value))) : (*(const s_Type*)fu::NIL));
                    /*MOV*/ s_SolvedNode arg = solveLet_gDsnGKHT(n_arg, true, specType, _current_fn, ss, _helpers, _here, ctx, module, options);
                    outItems_wyx7msfr(_current_fn).mutref(i) = static_cast<s_SolvedNode&&>(arg);
                };
                const s_Node& n_ret = (!isUnspec ? inItems[(inItems.size() + FN_RET_BACK)] : (*(const s_Node*)fu::NIL));
                const s_Node& n_body = inItems[(inItems.size() + FN_BODY_BACK)];
                if (n_body)
                {
                    const bool isNative = isNativeBody_gDsnGKHT(n_body);
                    s_Type ret_expect = (n_ret ? evalTypeAnnot_gDsnGKHT(n_ret, false, _current_fn, ss, _helpers, _here, ctx, module, options) : s_Type{});
                    /*MOV*/ s_Type ret_seed { (n_ret ? (ret_expect ? ret_expect : BUG_gDsnGKHT(("falsy ret_expect: "_fu + n_fn_wyx7msfr(tEmplate).value), ss, _helpers, _here, ctx, module, options)) : t_AssumeNever_WhileSolvingRecursion) };
                    if (ret_seed.lifetime)
                    {
                        ret_seed.lifetime = (isNative ? Lifetime_fromNative_gDsnGKHT(inItems, fu::get_view_start0(_current_fn.out.items, (_current_fn.out.items.size() + FN_ARGS_BACK)), ret_seed, ss, _helpers, _here, ctx, module, options) : s_Lifetime(Lifetime_static_moveable));
                    }
                    else if (isNative)
                    {
                        for (int i_1 = 0; i_1 < (inItems.size() + FN_ARGS_BACK); i_1++)
                        {
                            const s_Node& arg = inItems[i_1];
                            if ((arg.flags & s_Flags_F_REF) && !(arg.flags & (s_Flags_F_MUT | s_Flags_F_CONST)))
                            {
                                fail_gDsnGKHT(((((((((qKW_e44UlzzA("ref"_fu) + " arguments to "_fu) + qKW_e44UlzzA("__native"_fu)) + " fns must either be ref-returned"_fu) + " or explicitly specified "_fu) + qKW_e44UlzzA("mut"_fu)) + " or "_fu) + qKW_e44UlzzA("const"_fu)) + "."_fu), fu::view<char>{}, s_TokenIdx(arg.token), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            };
                        };
                    };
                    if (isFirst)
                    {
                        /*MOV*/ fu::str name = ""_fu;
                        s_FxMask fx_mask {};
                        if (isNative)
                        {
                            for (int i_1 = 0; i_1 < n_body.items.size(); i_1++)
                            {
                                const fu::str& item = n_body.items[i_1].value;
                                if (starts_8EDTwZj1(item, '|'))
                                {
                                    s_FxMask _6 {};
                                    fx_mask |= ((item == "|output"_fu) ? EFFECTS_output : ((_6 = parse_j8jAosYD(fu::get_view(item, 1))) ? _6 : BUG_gDsnGKHT(("Invalid |Fx mask: "_fu + qBAD_e44UlzzA(item)), ss, _helpers, _here, ctx, module, options)));
                                }
                                else
                                    name += ("\n"_fu + item);

                            };
                        };
                        if (!(name))
                        {
                            const fu::str* _7;
                            name = (*(_7 = &(n_fn_FDl5ha9X(tEmplate).value)) ? *_7 : BUG_gDsnGKHT("TODO anonymous fns"_fu, ss, _helpers, _here, ctx, module, options));
                        };
                        s_Overload& overload = GET_mut_gDsnGKHT(target, ss, module);
                        overload.name = static_cast<fu::str&&>(name);
                        s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
                        ext.tEmplate = tEmplate;
                        ext.spec_of = overloadIdx;
                        ext.fx_mask = fx_mask;
                        /*MOV*/ s_Type& retval = ret_seed;
                        const bool maybeLast = (isNative ? !isUnspec : false);
                        const s_TokenIdx* _8;
                        _here = (*(_8 = &(n_fn_FDl5ha9X(tEmplate).token)) ? *_8 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                        if (GET_gDsnGKHT(target, ss, _here, ctx, module).status & s_SolverStatus_SS_DIRTY)
                            GET_mut_gDsnGKHT(target, ss, module).status |= s_SolverStatus_SS_UPDATED;
                        else
                        {
                            doUpdateScope_gDsnGKHT(static_cast<s_Type&&>(retval), target, maybeLast, isNative, isUnspec, asserts, _current_fn, ss, _helpers, _here, ctx, module, options);
                            if (!into)
                            {

                                {
                                    fu::view<s_Argument> args = EXT_gDsnGKHT(target, ss, ctx, module).args;
                                    int _9 {};
                                    const int start = ((_9 = (find_yP7FbxFZ(mangle, ' ') + 1)) ? _9 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                                    fu::str mangle_1 = (fu::slice(mangle, 0, start) + mangleArgTypes_jyKPa9Mx(args));
                                    if (add_eHVOG4pi(mangles, mangle_1))
                                    {
                                        const s_Target preexisting { get_DC6o5biX(getSpecs_FDl5ha9X(parent_idx, ss), mangle_1) };
                                        if (preexisting)
                                        {
                                            if (error)
                                                BUG_gDsnGKHT("doTrySpec: resetMangle/preexisting on error path"_fu, ss, _helpers, _here, ctx, module, options);
                                            else
                                            {
                                                remove_WUsyyR27(mangles, mangle_1);
                                                if (!is_SPECFAIL_gDsnGKHT(currentSpec))
                                                    destroyOverload_gDsnGKHT(currentSpec, ss, module);

                                                resetSpec_gDsnGKHT(preexisting, maybeLast, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
                                                return preexisting;
                                            };
                                        }
                                        else
                                            setSpec_gDsnGKHT(mangle_1, currentSpec, true, false, parent_idx, error, ss, _helpers, _here, ctx, module, options);

                                    };
                                };
                                resetSpec_gDsnGKHT(target, false, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
                            };
                        };
                    };
                    bool didSetBody = false;
                    if (!isUnspec && !isNative)
                    {
                        if (isFirst)
                        {
                            s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
                            for (int i_1 = 0; i_1 < ext.args.size(); i_1++)
                                force_relax_9CJmuVSD(ext.args.mutref(i_1).type, (RELAX_all & ~q_USAGE));

                        };

                        {
                            int BL_119_v {};
                            const int self = (__extension__ (
                            {
                                const s_Target& t = target;
                                BL_119_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                            (void)0;}), BL_119_v);
                            s_CountedSet_95BJOojOc45 calls = steal_W9jpf1Xa(EPH_mut_FDl5ha9X(target, ss, module).calls);
                            each_hmr1Wh0W(calls, target, self, ss, _helpers, _here, ctx, module, options);
                        };
                        const s_SolverStatus status = (GET_mut_gDsnGKHT(target, ss, module).status &= s_SolverStatus(~s_SolverStatus_SS_Debug_AllPassesComplete));
                        if (s_SolverStatus((status & s_SolverStatus((s_SolverStatus((s_SolverStatus_SS_DIRTY | s_SolverStatus_SS_FINALIZED)) | s_SolverStatus_SS_DID_START)))) != s_SolverStatus_SS_DID_START)
                            BUG_gDsnGKHT(x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " is not SS_DID_START just before solve: "_fu), str_tqiEnBQ6(status)), ss, _helpers, _here, ctx, module, options);
                        else
                        {
                            _current_fn.TODO_FIX_isInline = !!(tEmplate.node.flags & s_Flags_F_INLINE);
                            /*MOV*/ s_SolvedNode s_body {};
                            int BL_122_v {};
                            s_body = solveBlock_gDsnGKHT(n_body, ret_expect, (__extension__ (
                            {
                                const s_Target& t = target;
                                BL_122_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                            (void)0;}), BL_122_v), s_HelpersMask((s_HelpersMask((s_HelpersMask((s_HelpersMask_HM_Function | s_HelpersMask_HM_CanReturn)) | s_HelpersMask_HM_LabelUsed)) | ((n_fn_FDl5ha9X(tEmplate).flags & s_Flags_F_LAMBDA) ? s_HelpersMask_HM_Lambda : s_HelpersMask{}))), n_fn_FDl5ha9X(tEmplate).value, 0, _current_fn, ss, _helpers, _here, ctx, module, options);
                            const s_HelpersData* BL_123_v;
                            const s_Type* _10;
                            const s_Type& retval = (*(_10 = &((__extension__ (
                            {
                                const s_Helpers& h = s_body.helpers;
                                BL_123_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                            (void)0;}), *BL_123_v).ret_actual)) ? *_10 : BUG_gDsnGKHT("doTrySpec: no body.ret_actual"_fu, ss, _helpers, _here, ctx, module, options));
                            const int idx_body = (outItems_iUdwqyBn(_current_fn).size() + FN_BODY_BACK);
                            outItems_wyx7msfr(_current_fn).mutref(idx_body) = static_cast<s_SolvedNode&&>((s_body ? s_body : BUG_gDsnGKHT("falsy body"_fu, ss, _helpers, _here, ctx, module, options)));
                            didSetBody = true;
                            const s_Type& retval_1 = retval;
                            const bool maybeLast = true;
                            const s_TokenIdx* _11;
                            _here = (*(_11 = &(n_fn_FDl5ha9X(tEmplate).token)) ? *_11 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                            if (GET_gDsnGKHT(target, ss, _here, ctx, module).status & s_SolverStatus_SS_DIRTY)
                                GET_mut_gDsnGKHT(target, ss, module).status |= s_SolverStatus_SS_UPDATED;
                            else
                            {
                                doUpdateScope_gDsnGKHT(s_Type(retval_1), target, maybeLast, isNative, isUnspec, asserts, _current_fn, ss, _helpers, _here, ctx, module, options);
                                if (!into)
                                {

                                    {
                                        fu::view<s_Argument> args = EXT_gDsnGKHT(target, ss, ctx, module).args;
                                        int _12 {};
                                        const int start = ((_12 = (find_yP7FbxFZ(mangle, ' ') + 1)) ? _12 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
                                        fu::str mangle_1 = (fu::slice(mangle, 0, start) + mangleArgTypes_jyKPa9Mx(args));
                                        if (add_eHVOG4pi(mangles, mangle_1))
                                        {
                                            const s_Target preexisting { get_DC6o5biX(getSpecs_FDl5ha9X(parent_idx, ss), mangle_1) };
                                            if (preexisting)
                                            {
                                                if (error)
                                                    BUG_gDsnGKHT("doTrySpec: resetMangle/preexisting on error path"_fu, ss, _helpers, _here, ctx, module, options);
                                                else
                                                {
                                                    remove_WUsyyR27(mangles, mangle_1);
                                                    if (!is_SPECFAIL_gDsnGKHT(currentSpec))
                                                        destroyOverload_gDsnGKHT(currentSpec, ss, module);

                                                    resetSpec_gDsnGKHT(preexisting, maybeLast, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
                                                    return preexisting;
                                                };
                                            }
                                            else
                                                setSpec_gDsnGKHT(mangle_1, currentSpec, true, false, parent_idx, error, ss, _helpers, _here, ctx, module, options);

                                        };
                                    };
                                    resetSpec_gDsnGKHT(target, false, parent_idx, error, mangles, currentSpec, ss, _helpers, _here, ctx, module, options);
                                };
                            };
                        };
                    };
                    if (!didSetBody)
                    {
                        if (!(GET_gDsnGKHT(target, ss, _here, ctx, module).kind != s_Kind_fn))
                            BUG_gDsnGKHT(x7E_3lDd4lqo("Did not set body on "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                    };
                }
                else
                    BUG_gDsnGKHT("solveFn: no body."_fu, ss, _helpers, _here, ctx, module, options);

            };
            lazySolveEnd_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options);
            return target;
        };
    };
}

static s_Target trySpecialize_gDsnGKHT(const s_Target& overloadIdx, fu::view<s_SolvedNode> args, fu::str& args_mangled, fu::str& error, const int REST_START, const s_Type& REST_TYPE, const s_Reorder& reorder, fu::view<fu::vec<s_Target>> conversions, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (!(args_mangled))
        args_mangled = mangleArgTypes_gDsnGKHT(args, reorder, conversions, REST_START, REST_TYPE, ss, _here, ctx, module);

    int parent_idx = EPH_gDsnGKHT(overloadIdx, ss, module).local_of;
    for (int i = 0; i < args.size(); i++)
    {
        const s_SolvedNode& arg_t = args[i];
        if (isAddrOfFn_9CJmuVSD(arg_t.type))
            unpackAddrOfFn_MuJD2L7y(arg_t.type.vtype.canon, parent_idx, ss, module);

    };
    fu::str mangle = ((x7E_3lDd4lqo(x7E_3lDd4lqo(fu::i64dec(int(unsigned(((overloadIdx._packed >> 40ull) & 0xfffffull)))), "#"_fu), fu::i64dec(int(unsigned(((overloadIdx._packed >> 20ull) & 0xfffffull))))) + " "_fu) + args_mangled);
    const s_Target& preexisting = get_DC6o5biX(getSpecs_FDl5ha9X(parent_idx, ss), mangle);
    if (preexisting && (!is_SPECFAIL_gDsnGKHT(preexisting) || !error))
        return preexisting;
    else
    {
        s_Target _0 {};
        return (_0 = doTrySpecialize_gDsnGKHT(parent_idx, error, s_Target{}, overloadIdx, args, mangle, reorder, conversions, REST_START, REST_TYPE, _current_fn, ss, _helpers, _here, ctx, module, options)) ? _0 : BUG_gDsnGKHT("doTrySpecialize returns empty target."_fu, ss, _helpers, _here, ctx, module, options);
    };
}

static bool isDiscardable_gDsnGKHT(const s_Target& t, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Extended& ext = EXT_gDsnGKHT(t, ss, ctx, module);
    if (ext.tEmplate.node.asserts & s_DeclAsserts_A_NODISCARD)
    {
        fail_gDsnGKHT((((((x7E_3lDd4lqo("Return value of "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ": "_fu) + qBAD_e44UlzzA("nodiscard"_fu)) + " "_fu) + explainType_gDsnGKHT(GET_gDsnGKHT(t, ss, _here, ctx, module).type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " is getting discarded here."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else if (EXT_gDsnGKHT(t, ss, ctx, module).fx_mask & s_FxMask_Fx_NotDeadCode)
        return false;
    else
    {
        fu::view<s_Argument> host_args = ext.args;
        for (int i = 0; i < host_args.size(); i++)
        {
            if (host_args[i].written_to)
                return false;

        };
        return true;
    };
}

static void discardIntoBlock_gDsnGKHT(s_SolvedNode& node, const s_Type& slot, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    node = createBlock_gDsnGKHT(slot, node.items, s_Helpers{}, _here);
    propagateType_gDsnGKHT(node, slot, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_iF_Z0ePP798OV8
                                #define DEF_iF_Z0ePP798OV8
inline const s_Set_95BJOojOc45& iF_Z0ePP798(fu::view<s_Set_95BJOojOc45> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Set_95BJOojOc45*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_MjtiwtwzUR1
                                #define DEF_iF_MjtiwtwzUR1
inline static const s_Set_95BJOojOc45& iF_Mjtiwtwz(const s_LocidMap_OjaSaYAvjq2& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_Z0ePP798(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_find_DRuCVJPp7zc
                                #define DEF_find_DRuCVJPp7zc
inline int find_DRuCVJPp(fu::view<int> haystack, const int needle)
{
    for (int i = 0; i < haystack.size(); i++)
    {
        if (haystack[i] == needle)
            return i;

    };
    return -1;
}
                                #endif

                                #ifndef DEF_has_4AEOmDQrEG3
                                #define DEF_has_4AEOmDQrEG3
inline bool has_4AEOmDQr(fu::view<int> a, const int b)
{
    return (find_DRuCVJPp(a, b) >= 0);
}
                                #endif

                                #ifndef DEF_iF_8PRPJGTW3K9
                                #define DEF_iF_8PRPJGTW3K9
inline const s_Lifetime& iF_8PRPJGTW(fu::view<s_Lifetime> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
    {
        return (*(const s_Lifetime*)fu::NIL);
    };
}
                                #endif

                                #ifndef DEF_iF_jKub7rekop9
                                #define DEF_iF_jKub7rekop9
inline static const s_Lifetime& iF_jKub7rek(const s_LocidMap_93S9qlGbUSi& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_8PRPJGTW(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___0OxGYvZghue
                                #define DEF___0OxGYvZghue
inline static bool _0OxGYvZg(const s_ValueType& _, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    return is_reinterpretable_1qjplDUo(_, _here, ctx, module);
}
                                #endif

                                #ifndef DEF_if_sliceable_PKg6inpyyCe
                                #define DEF_if_sliceable_PKg6inpyyCe
inline bool if_sliceable_PKg6inpy(const s_ValueType& type, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (is_sliceable_hxWWgdZ1(type))
        return _0OxGYvZg(parseType_1qjplDUo(fu::slice(type.canon, 1, (type.canon.size() - 1)), _here, ctx, module), _here, ctx, module);
    else
        return false;

}
                                #endif

                                #ifndef DEF_type_maybeInside_0pJee81rDe9
                                #define DEF_type_maybeInside_0pJee81rDe9
inline static bool type_maybeInside_0pJee81r(const s_ValueType& host, const s_ValueType& guest, const uint64_t guest_non_triv_mask, s_Set_ukcriy4HHQd& seen, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (isCanonAssignable_Ot6wT82z(host.canon, guest.canon, _here, ctx))
        return true;
    else if (is_sliceable_hxWWgdZ1(host))
    {
        s_ValueType host_sliceT = parseType_1qjplDUo(fu::slice(host.canon, 1, (host.canon.size() - 1)), _here, ctx, module);
        return type_maybeInside_0pJee81r(host_sliceT, guest, guest_non_triv_mask, seen, ss, _here, ctx, module);
    }
    else
    {
        if (isUserType_27MV22ZA(host))
        {
            const s_UserTypeCanon scp = parseUserTypeCanon_27MV22ZA(host.canon);
            const s_UserType& s = lookupUserType_1qjplDUo(scp, module, ctx, _here);
            if ((s.shape.non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else if (add_RcxQmqfh(seen, scp))
            {
                for (int i = 0; i < s.items.size(); i++)
                {
                    const s_Overload& f = GET_gDsnGKHT(target_z0QqoZ5t(s.items[i]), ss, _here, ctx, module);
                    const s_Type& fieldType = f.type;
                    if (type_maybeInside_0pJee81r(fieldType.vtype, guest, guest_non_triv_mask, seen, ss, _here, ctx, module))
                        return true;

                };
            };
        };
        return false;
    };
}
                                #endif

                                #ifndef DEF_type_maybeInside_x0HhL7VyEx0
                                #define DEF_type_maybeInside_x0HhL7VyEx0
inline static bool type_maybeInside_x0HhL7Vy(const s_ValueType& host, const unsigned usage, const s_ValueType& guest, const uint64_t guest_non_triv_mask, s_Set_ukcriy4HHQd& seen, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (!usage)
        return false;
    else if (isCanonAssignable_Ot6wT82z(host.canon, guest.canon, _here, ctx))
        return true;
    else if (is_sliceable_hxWWgdZ1(host))
    {
        s_ValueType host_sliceT = parseType_1qjplDUo(fu::slice(host.canon, 1, (host.canon.size() - 1)), _here, ctx, module);
        return type_maybeInside_0pJee81r(host_sliceT, guest, guest_non_triv_mask, seen, ss, _here, ctx, module);
    }
    else
    {
        if (isUserType_27MV22ZA(host))
        {
            const s_UserTypeCanon scp = parseUserTypeCanon_27MV22ZA(host.canon);
            const s_UserType& s = lookupUserType_1qjplDUo(scp, module, ctx, _here);
            if ((s.shape.non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else
            {
                for (int i = 0; i < s.items.size(); i++)
                {
                    const s_Overload& f = GET_gDsnGKHT(target_z0QqoZ5t(s.items[i]), ss, _here, ctx, module);
                    const s_Type& fieldType = f.type;
                    const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(f, _here, ctx);
                    unsigned BL_10_v {};
                    const unsigned usage_1 = USAGE_fieldUsageFromStructUsage_CaGDtmWo((__extension__ (
                    {
                        const s_ValueType& type = f.type.vtype;
                        BL_10_v = ((type.quals & q_USAGE));
                    (void)0;}), BL_10_v), usage, _.memberFlatOffset, _.memberFlatCount);
                    if (usage_1 == getMaxUsage_CaGDtmWo(_.memberFlatCount))
                    {
                        if (type_maybeInside_0pJee81r(fieldType.vtype, guest, guest_non_triv_mask, seen, ss, _here, ctx, module))
                            return true;

                    }
                    else if (type_maybeInside_x0HhL7Vy(fieldType.vtype, usage_1, guest, guest_non_triv_mask, seen, ss, _here, ctx, module))
                        return true;

                };
            };
        };
        return false;
    };
}
                                #endif

static bool SLOW_type_maybeInside_gDsnGKHT(const s_ValueType& host, const s_ValueType& guest, const uint64_t guest_non_triv_mask, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    s_Set_ukcriy4HHQd seen {};
    const unsigned usage = (host.quals & q_USAGE);
    if (usage == getMaxUsage_CaGDtmWo(getFlatCount_1qjplDUo(host, _here, ctx, module)))
        return type_maybeInside_0pJee81r(host, guest, guest_non_triv_mask, seen, ss, _here, ctx, module);
    else
        return type_maybeInside_x0HhL7Vy(host, usage, guest, guest_non_triv_mask, seen, ss, _here, ctx, module);

}

static bool type_mayPointInto_gDsnGKHT(const s_ValueType& host, const s_ValueType& guest, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (is_reinterpretable_1qjplDUo(guest, _here, ctx, module) || if_sliceable_PKg6inpy(guest, _here, ctx, module))
        return !!(host.quals & q_USAGE);
    else
    {
        const uint64_t guest_non_triv_mask = getShape_1qjplDUo(guest, _here, ctx, module).non_triv_mask;
        if (!guest_non_triv_mask)
            return false;
        else
        {
            const uint64_t host_non_triv_mask = getShape_1qjplDUo(host, _here, ctx, module).non_triv_mask;
            if ((host_non_triv_mask & guest_non_triv_mask) != guest_non_triv_mask)
                return false;
            else
                return SLOW_type_maybeInside_gDsnGKHT(host, guest, guest_non_triv_mask, ss, _here, ctx, module);

        };
    };
}

                                #ifndef DEF_x3Dx3D_ocPOQCagTj1
                                #define DEF_x3Dx3D_ocPOQCagTj1
inline bool operator==(const s_TokenIdx& a, const s_TokenIdx& b)
{
    return !x3Cx3E_f3YaHn9V(a, b);
}
                                #endif

                                #ifndef DEF___LcgzDnbmFa4
                                #define DEF___LcgzDnbmFa4
inline static bool _LcgzDnbm(const s_COWInside& cow, const s_Argument& host_arg, const s_TokenIdx& cow_inside)
{
    int BL_1_v {};
    if (cow.argTarget == (__extension__ (
    {
        const s_Target& t = host_arg.target;
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v))
        return cow.token == cow_inside;
    else
        return false;

}
                                #endif

                                #ifndef DEF_some_IOl1oEp6dD1
                                #define DEF_some_IOl1oEp6dD1
inline bool some_IOl1oEp6(fu::view<s_COWInside> a, const s_Argument& host_arg, const s_TokenIdx& cow_inside)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_COWInside& item = a[i];
        if (_LcgzDnbm(item, host_arg, cow_inside))
            return true;

    };
    return false;
}
                                #endif

static fu::str qSTACK_cow_inside_gDsnGKHT(const s_Target& target, const s_SolvedNode& node, const s_Argument& host_arg, const s_TokenIdx& cow_inside, fu::view<s_Target> seen, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
    fu_DEFER(ss._nestingFnort = nestingFnort0);
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const s_Target& t = host_arg.target;
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    fu::str candidates = ""_fu;
    fu::vec<s_Target> seen_1 = (seen + target);

    {
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            s_SolvedNode node_3 { ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2) };
            if ((node_3.kind == s_Kind_copy) && (only_LqU08rcL(node_3.items).token == cow_inside))
            {
                return (x7E_3lDd4lqo(("\n            "_fu + "in "_fu), str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(cow_inside, s_CodeFmt{}, fu::view<char>{}, ctx, module);
            }
            else
            {
                if (!((node_3.kind != s_Kind_call) || !node_3.items))
                {
                    if (!(has_AOZqRgIb(seen_1, node_3.target)))
                    {
                        fu::view<s_Argument> host_args = EXT_gDsnGKHT(node_3.target, ss, ctx, module).args;
                        for (int i = 0; i < host_args.size(); i++)
                        {
                            s_Argument BL_11_v {};
                            s_Argument host_arg_1 = (__extension__ (
                            {
                                const s_Argument& __partcopy_ref = host_args[i];
                                BL_11_v = (s_Argument { {}, {}, {}, {}, s_Target(__partcopy_ref.target), __partcopy_ref.flags, {}, {}, {} });
                            (void)0;}), static_cast<s_Argument&&>(BL_11_v));
                            if ((host_arg_1.flags & s_Flags_F_COW_INSIDE) && some_IOl1oEp6(EXT_gDsnGKHT(node_3.target, ss, ctx, module).cows_inside, host_arg_1, cow_inside) && Lifetime_has_7Yz9ezW2(Lifetime_unwind_gDsnGKHT(node_3.items[i].type.lifetime, false, ss, _helpers, _here, ctx, module, options), locid))
                            {
                                fu::str peek = qSTACK_cow_inside_gDsnGKHT(s_Target(node_3.target), s_SolvedNode(GET_gDsnGKHT(node_3.target, ss, _here, ctx, module).solved), host_arg_1, cow_inside, seen_1, _current_fn, ss, _helpers, _here, ctx, module, options);
                                return (((x7E_3lDd4lqo((x7E_3lDd4lqo(("\n            "_fu + "in "_fu), str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + " via "_fu), str_FDl5ha9X(node_3.target, false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + peek) + candidates;
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += s_SolvedNode(node_3.items[i]);

        };
    };
    return ""_fu;
}

                                #ifndef DEF___qdLRbEaiZX0
                                #define DEF___qdLRbEaiZX0
inline static void _qdLRbEai(const s_ValueType& vtype, const s_TokenIdx& token, const s_Target& t, const s_Overload& o, const int parent_locid, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (type_mayPointInto_gDsnGKHT(vtype, o.type.vtype, ss, _here, ctx, module))
    {
        fu::str _0 {};
        fu::str err = (!callee ? "A copy is needed, but "_fu : ((_0 = (x7E_3lDd4lqo(x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " to "_fu), str_FDl5ha9X(callee, false, ss, _here, ctx, module, options)) + " is indirectly copied from:\n"_fu), (static_cast<fu::str&&>(_0) + qSTACK_cow_inside_gDsnGKHT(callee, s_SolvedNode(GET_gDsnGKHT(callee, ss, _here, ctx, module).solved), host_arg, token, fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options))) + "\n\t... but "_fu));
        err += ("COW will break due to pre-existing mutref: "_fu + explainWhichFn_gDsnGKHT(s_Target(t), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options));
        err += ("\n\tBoth refer to: "_fu + explainWhichFn_gDsnGKHT(nested_FDl5ha9X(parent_locid, ss, _here, ctx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options));
        _here = here;
        fail_gDsnGKHT(err, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_eachCOWInside_8sHjZ3QGjt7
                                #define DEF_eachCOWInside_8sHjZ3QGjt7
inline static void eachCOWInside_8sHjZ3QG(const s_Target& t, const s_Overload& o, const int parent_locid, const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (callee)
    {
        fu::vec<s_COWInside> callee_cows { EXT_gDsnGKHT(callee, ss, ctx, module).cows_inside };
        for (int i = 0; i < callee_cows.size(); i++)
        {
            const s_COWInside& callee_cow = callee_cows[i];
            if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
            {
                int BL_5_v {};
                if (callee_cow.argTarget == (__extension__ (
                {
                    const s_Target& t_1 = host_arg.target;
                    const unsigned v = unsigned((t_1._packed & 0xfffffull));
                    BL_5_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_5_v))
                    _qdLRbEai(callee_cow.vtype, s_TokenIdx(callee_cow.token), t, o, parent_locid, here, callee, host_arg, _current_fn, ss, _helpers, _here, ctx, module, options);

            };
        };
    }
    else
        _qdLRbEai(item.type.vtype, _here, t, o, parent_locid, here, callee, host_arg, _current_fn, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF___vaUodalu3H3
                                #define DEF___vaUodalu3H3
inline static void _vaUodalu(const int child, const s_Target& t, const s_Overload& o, const int parent_locid, const s_Lifetime& parent_region, fu::view<int> expected_refs, const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(has_4AEOmDQr(expected_refs, child)))
    {
        s_Lifetime inter = Lifetime_inter_7Yz9ezW2(iF_jKub7rek(_current_fn.flow.rg_parents, child, _current_fn), parent_region, _here, ctx);
        if (!(!inter))
        {
            bool BL_3_v {};
            if ((__extension__ (
            {
                const s_LocidMap_DC5gktNgm89& map = _current_fn.postdom.snap.ever_written;
                BL_3_v = (!!iF_51ChLTxy(map, child, _current_fn));
            (void)0;}), BL_3_v))
                eachCOWInside_8sHjZ3QG(t, o, parent_locid, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);

            cannotCOW_descendChildren_gDsnGKHT(child, inter, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
}
                                #endif

                                #ifndef DEF_eachLiveChildMutref_NxGOM4qq4h9
                                #define DEF_eachLiveChildMutref_NxGOM4qq4h9
inline static void eachLiveChildMutref_NxGOM4qq(const int index, const int parent_locid, const s_Lifetime& parent_region, fu::view<int> expected_refs, const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Set_95BJOojOc45& children = iF_Mjtiwtwz(_current_fn.TODO_FIX_children, index, _current_fn);
    for (int i = 0; i < children.keys_asc.size(); i++)
    {
        int BL_3_v {};
        const int child = (__extension__ (
        {
            const int i_1 = i;
            BL_3_v = (children.keys_asc[i_1]);
        (void)0;}), BL_3_v);
        const s_Target t = nested_FDl5ha9X(child, ss, _here, ctx);
        const s_Overload& o = GET_gDsnGKHT(t, ss, _here, ctx, module);
        if (!(!is_mutref_9CJmuVSD(o.solved.type, _here, ctx)))
        {
            if (!(has_gDsnGKHT(_current_fn.relaxed.done_relaxing, child, _current_fn)))
                _vaUodalu(child, t, o, parent_locid, parent_region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);

        };
    };
}
                                #endif

static void cannotCOW_descendChildren_gDsnGKHT(const int parent_locid, const s_Lifetime& parent_region, fu::view<int> expected_refs, const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    eachLiveChildMutref_NxGOM4qq(parent_locid, parent_locid, parent_region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static int needsHardRisk_gDsnGKHT(const int index, const s_Overload& o, const s_SolvedNode& item, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{

    {
        const s_Set_95BJOojOc45& children = iF_Mjtiwtwz(_current_fn.TODO_FIX_children, index, _current_fn);
        for (int i = 0; i < children.keys_asc.size(); i++)
        {
            int BL_4_v {};
            const int child = (__extension__ (
            {
                const int i_1 = i;
                BL_4_v = (children.keys_asc[i_1]);
            (void)0;}), BL_4_v);
            const s_Target t = nested_FDl5ha9X(child, ss, _here, ctx);
            const s_Overload& o_1 = GET_gDsnGKHT(t, ss, _here, ctx, module);
            if (!(!is_mutref_9CJmuVSD(o_1.solved.type, _here, ctx)))
            {
                if (!(has_gDsnGKHT(_current_fn.relaxed.done_relaxing, child, _current_fn)))
                {
                    const int reason = needsHardRisk_gDsnGKHT(child, o, item, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _here, ctx, module);
                    if (reason)
                        return reason;

                };
            };
        };
    };
    bool BL_8_v {};
    if ((__extension__ (
    {
        const s_LocidMap_DC5gktNgm89& map = _current_fn.postdom.snap.ever_written;
        BL_8_v = (!!iF_51ChLTxy(map, index, _current_fn));
    (void)0;}), BL_8_v))
    {
        if (callee)
        {
            fu::view<s_COWInside> callee_cows = EXT_gDsnGKHT(callee, ss, ctx, module).cows_inside;
            for (int i = 0; i < callee_cows.size(); i++)
            {
                const s_COWInside& callee_cow = callee_cows[i];
                if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
                {
                    int BL_14_v {};
                    if (callee_cow.argTarget == (__extension__ (
                    {
                        const s_Target& t = host_arg.target;
                        const unsigned v = unsigned((t._packed & 0xfffffull));
                        BL_14_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                    (void)0;}), BL_14_v))
                    {
                        const s_ValueType& vtype = callee_cow.vtype;
                        const bool uncaughtThrowOnly = ((callee_cow.exitPaths == s_ExitPaths_XP_NoReturn) ? !_current_fn.TODO_FIX_catches : false);
                        if (!(uncaughtThrowOnly))
                        {
                            if (type_mayPointInto_gDsnGKHT(vtype, o.type.vtype, ss, _here, ctx, module))
                                return index;

                        };
                    };
                };
            };
        }
        else
        {
            const s_ValueType& vtype = item.type.vtype;
            if (type_mayPointInto_gDsnGKHT(vtype, o.type.vtype, ss, _here, ctx, module))
                return index;

        };
    };
    return 0;
}

                                #ifndef DEF_ensure_2vd5RyHmztl
                                #define DEF_ensure_2vd5RyHmztl
inline s_LocidSet& ensure_2vd5RyHm(fu::vec<s_LocidSet>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_solxXoYYR5i
                                #define DEF_ensure_solxXoYYR5i
inline static s_LocidSet& ensure_solxXoYY(s_LocidMap_I7YkM5C62o7& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_2vd5RyHm(map._values, (args_neg + locid));
}
                                #endif

static bool TODO_FIX_slicesAgain_gDsnGKHT(const int t, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    return is_sliceable_hxWWgdZ1(GET_gDsnGKHT(nested_FDl5ha9X(t, ss, _here, ctx), ss, _here, ctx, module).type.vtype);
}

static void cannotCOW_climbParents_gDsnGKHT(const s_Lifetime& lifetime, fu::view<int> expected_refs, const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0_1 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0_1);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        const int locid = ((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v));
        s_Lifetime region = s_Lifetime { fu::slice(chars, offset0, offset) };
        fu::view<char> paths = fu::get_view(chars, sr, offset);
        if (!(!locid))
        {
            const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
            if (GET_gDsnGKHT(t, ss, _here, ctx, module).kind == s_Kind_var)
            {
                cannotCOW_climbParents_gDsnGKHT(Lifetime_op_join_7Yz9ezW2(Lifetime_climbType_gDsnGKHT(t, ss, _helpers, _here, ctx, module, options).lifetime, paths, _here, ctx), (expected_refs + locid), item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);
                cannotCOW_descendChildren_gDsnGKHT(locid, region, expected_refs, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);
                s_Flow& flow = _current_fn.flow;
                int BL_14_v {};
                if ((__extension__ (
                {
                    const unsigned v_1 = unsigned((t._packed & 0xfffffull));
                    BL_14_v = (int(((v_1 >> 1u) ^ ((v_1 & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_14_v) < 0)
                {
                    fu::view<int> arg_targets = flow.arg_targets;
                    for (int i = 0; i < arg_targets.size(); i++)
                    {
                        const int t_1 = arg_targets[i];
                        if (!(!t_1 || (t_1 == locid)))
                        {
                            const s_Overload& o = GET_gDsnGKHT(nested_FDl5ha9X(t_1, ss, _here, ctx), ss, _here, ctx, module);
                            if (!(!is_mutref_9CJmuVSD(o.solved.type, _here, ctx)))
                            {
                                if (!(has_gDsnGKHT(iF_1RIDDoXN(flow.at_hard_risk, t_1, _current_fn), locid, _current_fn)))
                                {
                                    const int reason = needsHardRisk_gDsnGKHT(t_1, o, item, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _here, ctx, module);
                                    if (reason)
                                    {

                                        {
                                            const s_SolverNotes note = s_SolverNotes_N_COWRestrict;
                                            if (note & options.break_notes)
                                            {
                                                fu::str reason_1 = x7E_3lDd4lqo((x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options), " at risk from "_fu), str_FDl5ha9X(nested_FDl5ha9X(t_1, ss, _here, ctx), false, ss, _here, ctx, module, options)) + " via "_fu), str_FDl5ha9X(nested_FDl5ha9X(reason, ss, _here, ctx), false, ss, _here, ctx, module, options));
                                                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason_1 ? ("\n\t\t"_fu + reason_1) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                            }
                                            else
                                                ss._notes |= note;

                                        };
                                        add_gDsnGKHT(ensure_solxXoYY(flow.at_soft_risk, t_1, _current_fn), locid, _current_fn);
                                        if ((reason != t_1) || TODO_FIX_slicesAgain_gDsnGKHT(t_1, ss, _here, ctx, module))
                                            add_gDsnGKHT(ensure_solxXoYY(flow.at_hard_risk, t_1, _current_fn), locid, _current_fn);

                                    };
                                };
                            };
                        };
                    };
                    if (callee)
                    {
                        fu::view<s_COWInside> callee_cows = EXT_gDsnGKHT(callee, ss, ctx, module).cows_inside;
                        for (int i_1 = 0; i_1 < callee_cows.size(); i_1++)
                        {
                            const s_COWInside& callee_cow = callee_cows[i_1];
                            if (!(calleeReturnDiscarded && !callee_cow.mayEscapeVia))
                            {
                                int BL_30_v {};
                                if (callee_cow.argTarget == (__extension__ (
                                {
                                    const s_Target& t_2 = host_arg.target;
                                    const unsigned v_2 = unsigned((t_2._packed & 0xfffffull));
                                    BL_30_v = (int(((v_2 >> 1u) ^ ((v_2 & 1u) ? 0xffffffffu : 0x0u))));
                                (void)0;}), BL_30_v))
                                {
                                    const s_ValueType& vtype = callee_cow.vtype;
                                    const s_TokenIdx& token = callee_cow.token;
                                    const bool uncaughtThrowOnly = ((callee_cow.exitPaths == s_ExitPaths_XP_NoReturn) ? !_current_fn.TODO_FIX_catches : false);
                                    const s_MayEscapeVia mayEscapeVia = _current_fn.postdom.snap.mayEscapeVia;
                                    const s_ExitPaths exitPaths = (uncaughtThrowOnly ? s_ExitPaths_XP_NoReturn : (_current_fn.postdom.snap.exitPaths ? _current_fn.postdom.snap.exitPaths : BUG_gDsnGKHT("No current_fn.exitPaths"_fu, ss, _helpers, _here, ctx, module, options)));
                                    fu::vec<s_COWInside>& my_cows = _current_fn.events.cows_inside;
                                    for (int i_2 = 0; i_2 < my_cows.size(); i_2++)
                                    {
                                        s_COWInside& my_cow = my_cows.mutref(i_2);
                                        if ((my_cow.argTarget == locid) && (my_cow.vtype.canon == vtype.canon))
                                        {
                                            my_cow.vtype.quals |= vtype.quals;
                                            my_cow.mayEscapeVia |= mayEscapeVia;
                                            my_cow.exitPaths |= exitPaths;
                                            return;
                                        };
                                    };
                                    my_cows += s_COWInside { s_ValueType(vtype), s_TokenIdx(token), locid, mayEscapeVia, exitPaths };
                                };
                            };
                        };
                    }
                    else
                    {
                        const s_ValueType& vtype_1 = item.type.vtype;
                        const s_TokenIdx& token_1 = _here;
                        const s_MayEscapeVia mayEscapeVia_1 = _current_fn.postdom.snap.mayEscapeVia;
                        const s_ExitPaths exitPaths_1 = (_current_fn.postdom.snap.exitPaths ? _current_fn.postdom.snap.exitPaths : BUG_gDsnGKHT("No current_fn.exitPaths"_fu, ss, _helpers, _here, ctx, module, options));
                        fu::vec<s_COWInside>& my_cows_1 = _current_fn.events.cows_inside;
                        for (int i_3 = 0; i_3 < my_cows_1.size(); i_3++)
                        {
                            s_COWInside& my_cow_1 = my_cows_1.mutref(i_3);
                            if ((my_cow_1.argTarget == locid) && (my_cow_1.vtype.canon == vtype_1.canon))
                            {
                                my_cow_1.vtype.quals |= vtype_1.quals;
                                my_cow_1.mayEscapeVia |= mayEscapeVia_1;
                                my_cow_1.exitPaths |= exitPaths_1;
                                return;
                            };
                        };
                        my_cows_1 += s_COWInside { s_ValueType(vtype_1), s_TokenIdx(token_1), locid, mayEscapeVia_1, exitPaths_1 };
                    };
                };
            }
            else
                BUG_gDsnGKHT(x7E_3lDd4lqo("cannotCOW_climbParents found a non-var: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        };
    };
}

static void validateCOW_gDsnGKHT(const s_SolvedNode& item, const s_TokenIdx& here, const s_Target& callee, const s_Argument& host_arg, const bool calleeReturnDiscarded, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    cannotCOW_climbParents_gDsnGKHT(item.type.lifetime, fu::view<int>{}, item, here, callee, host_arg, calleeReturnDiscarded, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_ensure_4mG4NFfsnij
                                #define DEF_ensure_4mG4NFfsnij
inline static unsigned& ensure_4mG4NFfs(s_LocidMap_DC5gktNgm89& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_NX8DJxmg(map._values, (args_neg + locid));
}
                                #endif

static bool add_FDl5ha9X(s_LocidMap_DC5gktNgm89& map, const int locid, const unsigned quals, const s_CurrentFn& _current_fn)
{
    unsigned& v = ensure_4mG4NFfs(map, locid, _current_fn);
    const unsigned v0 = v;
    v |= quals;
    return v != v0;
}

                                #ifndef DEF___YqLfZiqfkg4
                                #define DEF___YqLfZiqfkg4
inline static void _YqLfZiqf(const int locid, fu::view<char> paths, const unsigned usage, const s_SolvedNode& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!locid))
    {
        const unsigned usage_1 = Lifetime_shiftUsage_7Yz9ezW2(paths, usage, _here, ctx);
        if (add_FDl5ha9X(_current_fn.postdom.snap.ever_written, locid, usage_1, _current_fn))
        {
            const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
            s_Overload BL_3_v {};
            s_Overload o = (__extension__ (
            {
                const s_Overload& __partcopy_ref = GET_gDsnGKHT(t, ss, _here, ctx, module);
                BL_3_v = (s_Overload { {}, __partcopy_ref.flags, {}, __partcopy_ref.asserts, fu::str(__partcopy_ref.name), {}, {} });
            (void)0;}), static_cast<s_Overload&&>(BL_3_v));
            const s_DeclAsserts asserts = o.asserts;

            {
                const s_Target& target = _current_fn.out.target;
                s_Target fail_fn { target };
                s_TokenIdx fail_arg_token { GET_gDsnGKHT(t, ss, _here, ctx, module).solved.token };
                s_TokenIdx backtrack_token { _current_fn.out.token };
                const s_ClosureID cid = tryParseClosureID_UvH3gYAB(o.name, _here, ctx);
                if (isLocal_gDsnGKHT(cid.target))
                {
                    fail_fn = parent_gDsnGKHT(cid.target, _here, ctx);
                    fail_arg_token = GET_gDsnGKHT(cid.target, ss, _here, ctx, module).solved.token;
                    backtrack_token = GET_gDsnGKHT(fail_fn, ss, _here, ctx, module).solved.token;
                };
                if (asserts & s_DeclAsserts_A_PURE)
                {
                    fu::str _0 {};
                    fu::str _1 {};
                    (_1 = (_0 = (x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(fail_fn, false, ss, _here, ctx, module, options), " is not pure, writes to "_fu), str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ":\n"_fu), (static_cast<fu::str&&>(_0) + qSTACK_local_FDl5ha9X(target, node, locid, fu::view<s_Target>{}, s_ArgQuery{}, _current_fn, ss, _helpers, _here, ctx, module, options))), fail_gDsnGKHT(static_cast<fu::str&&>(_1), "pure"_fu, s_TokenIdx(backtrack_token), (fu::slate<1, s_TokenIdx> { s_TokenIdx(fail_arg_token) }), ss, _helpers, _here, ctx, module, options));
                }
                else if (s_DeclAsserts((asserts & s_DeclAsserts_A_PURE_CTX)) && (o.flags & s_Flags_F_INJECTED))
                {
                    fu::str _2 {};
                    fu::str _3 {};
                    (_3 = (_2 = (x7E_3lDd4lqo(x7E_3lDd4lqo(str_FDl5ha9X(fail_fn, false, ss, _here, ctx, module, options), " is not purectx, writes to "_fu), str_FDl5ha9X(t, false, ss, _here, ctx, module, options)) + ":\n"_fu), (static_cast<fu::str&&>(_2) + qSTACK_local_FDl5ha9X(target, node, locid, fu::view<s_Target>{}, s_ArgQuery{}, _current_fn, ss, _helpers, _here, ctx, module, options))), fail_gDsnGKHT(static_cast<fu::str&&>(_3), "purectx"_fu, s_TokenIdx(backtrack_token), (fu::slate<1, s_TokenIdx> { s_TokenIdx(fail_arg_token) }), ss, _helpers, _here, ctx, module, options));
                };
            };
            unsigned BL_8_v {};
            if (((__extension__ (
            {
                const s_ValueType& type = GET_gDsnGKHT(t, ss, _here, ctx, module).type.vtype;
                BL_8_v = ((type.quals & q_USAGE));
            (void)0;}), BL_8_v) & usage_1) == usage_1)
            {
                if (!(o.flags & s_Flags_F_VAL))
                {
                    callarg_trackWrites_gDsnGKHT(s_Lifetime(Lifetime_climbType_gDsnGKHT(t, ss, _helpers, _here, ctx, module, options).lifetime), usage_1, node, _current_fn, ss, _helpers, _here, ctx, module, options);
                };
                int BL_11_v {};
                if ((__extension__ (
                {
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_11_v) < 0)
                    add_xQNS19Zn(_current_fn.postdom.snap.mayEscapeVia, locid);

            }
            else
            {
                unsigned BL_14_v {};
                BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("callarg_trackWrites: written_to("_fu, fu::u64dec(usage_1)) + ") quals("_fu), fu::u64dec((__extension__ (
                {
                    const s_ValueType& type = GET_gDsnGKHT(t, ss, _here, ctx, module).type.vtype;
                    BL_14_v = ((type.quals & q_USAGE));
                (void)0;}), BL_14_v))) + ") "_fu), str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            };
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_s7MUbnGAJb7
                                #define DEF_Lifetime_each_s7MUbnGAJb7
inline void Lifetime_each_s7MUbnGA(const s_Lifetime& lifetime, const unsigned usage, const s_SolvedNode& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0;

    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        _YqLfZiqf(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v)), fu::get_view(chars, sr, offset), usage, node, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void callarg_trackWrites_gDsnGKHT(const s_Lifetime& lt, const unsigned usage, const s_SolvedNode& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    Lifetime_each_s7MUbnGA(lt, usage, node, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF___H2o1VPVX3O1
                                #define DEF___H2o1VPVX3O1
inline static void _H2o1VPVX(const int i, const s_Argument& host_arg, s_SolvedNode& node, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_SolvedNode& arg = node.items.mutref(i);
    if (relax_mask == RELAX_all)
        maybeCopyOrMove_gDsnGKHT(arg, host_arg.type, true, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);

    propagateType_gDsnGKHT(arg, host_arg.type, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (host_arg.written_to)
    {
        unsigned BL_3_v {};
        if ((host_arg.written_to & (__extension__ (
        {
            const s_ValueType& type = arg.type.vtype;
            BL_3_v = ((type.quals & q_USAGE));
        (void)0;}), BL_3_v)) == host_arg.written_to)
        {
            callarg_trackWrites_gDsnGKHT(arg.type.lifetime, host_arg.written_to, node, _current_fn, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            unsigned BL_6_v {};
            BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("propagateType(call) host_arg.written_to("_fu, fu::u64dec(host_arg.written_to)) + ") arg.usage("_fu), fu::u64dec((__extension__ (
            {
                const s_ValueType& type = arg.type.vtype;
                BL_6_v = ((type.quals & q_USAGE));
            (void)0;}), BL_6_v))) + ")"_fu), ss, _helpers, _here, ctx, module, options);
        };
    };
    if (!(host_arg.flags & s_Flags_F_LT_RETURNED))
    {
        if ((arg.kind == s_Kind_letdef) && s_SolverStatus((GET_gDsnGKHT(arg.target, ss, _here, ctx, module).status & s_SolverStatus_SS_NAME_UNUSED)))
            unwrapLetdef_gDsnGKHT(arg, relax_mask, ss, _helpers, _here, ctx, module, options);

    };
}
                                #endif

                                #ifndef DEF_argsReverse_JsXGXPqUbP0
                                #define DEF_argsReverse_JsXGXPqUbP0
inline void argsReverse_JsXGXPqU(const bool RTL, fu::view<s_Argument> host_args, s_SolvedNode& node, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    int revSeqIdx = 0;
    int lastPass = 1;
    bool ooe_isLast = true;
    for (int pass = 2; pass-- > lastPass; )
    {
        for (int i = host_args.size(); i-- > 0; )
        {
            const s_Argument& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                lastPass = 0;
            else
            {
                _H2o1VPVX(i, host_arg, node, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
                ooe_isLast = false;
                revSeqIdx++;
            };
        };
    };
}
                                #endif

static bool isFieldChain_gDsnGKHT(const s_SolvedNode& arg, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (arg.kind != s_Kind_call)
        return false;
    else
    {
        const s_Kind t = GET_gDsnGKHT(arg.target, ss, _here, ctx, module).kind;
        return (t == s_Kind_var) || ((t == s_Kind_field) && isFieldChain_gDsnGKHT(only_LqU08rcL(arg.items), ss, _here, ctx, module));
    };
}

static fu::str explainUsedAgain_gDsnGKHT(const s_UsedAgain usedAgain, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const unsigned v = unsigned((usedAgain >> 8u));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    const s_UsedAgainReason reason = s_UsedAgainReason(fu::u8(usedAgain));
    if (locid)
        return x7E_3lDd4lqo(str_FDl5ha9X(nested_FDl5ha9X(locid, ss, _here, ctx), false, ss, _here, ctx, module, options), ((reason == s_UsedAgainReason_UsedInALoop) ? " is used on next loop iteration."_fu : ((reason == s_UsedAgainReason_ArgReference) ? " is a reference argument."_fu : ((reason == s_UsedAgainReason_UsedAgain) ? " is used again."_fu : ""_fu))));
    else if (reason == s_UsedAgainReason_StaticReference)
        return "references a static."_fu;
    else
    {
        return fu::str{};
    };
}

                                #ifndef DEF___wU9qLAgfN06
                                #define DEF___wU9qLAgfN06
inline static void _wU9qLAgf(const int locid, const bool isAlwaysMoveable, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!locid)
    {
        if (!(isAlwaysMoveable))
            BUG_gDsnGKHT("Attempting to move from a non-local, non-temporary region."_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
        s_Overload& o = GET_mut_gDsnGKHT(t, ss, module);
        if (!(o.status & s_SolverStatus_SS_MOVED_FROM))
        {
            o.status |= s_SolverStatus_SS_MOVED_FROM;
            const s_Type& init = Lifetime_climbType_gDsnGKHT(t, ss, _helpers, _here, ctx, module, options);
            if (is_ref_9CJmuVSD(init))
            {
                Lifetime_F_MOVED_FROM_gDsnGKHT(s_Lifetime(init.lifetime), ss, _helpers, _here, ctx, module, options);
            };
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_KTfaCbajZNd
                                #define DEF_Lifetime_each_KTfaCbajZNd
inline void Lifetime_each_KTfaCbaj(const s_Lifetime& lifetime, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _wU9qLAgf(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), ((r == 0b0101u) || (r == 0b1001u)), ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void Lifetime_F_MOVED_FROM_gDsnGKHT(const s_Lifetime& lifetime, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    Lifetime_each_KTfaCbaj(lifetime, ss, _helpers, _here, ctx, module, options);
}

static void injectJumps_gDsnGKHT(s_SolvedNode& expr, const s_Helpers& h, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!tryInjectJumps_gDsnGKHT(expr, h, ss, _helpers, _here, ctx, module, options))
        expr = createJump_gDsnGKHT(h, expr, _here);

}

static bool tryInjectJumps_gDsnGKHT(s_SolvedNode& expr, const s_Helpers& h, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_HelpersData* BL_2_v;
    if (is_never_9CJmuVSD(expr.type.vtype))
        return true;
    else if ((__extension__ (
    {
        const s_Helpers& h_1 = h;
        BL_2_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_2_v).ret_actual)
    {
        const s_HelpersData* BL_4_v;
        if (is_void_9CJmuVSD((__extension__ (
        {
            const s_Helpers& h_1 = h;
            BL_4_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_4_v).ret_actual.vtype) && !is_void_9CJmuVSD(expr.type.vtype))
        {
            if (expr.kind != s_Kind_block)
            {
                expr = createBlock_gDsnGKHT(t_void, fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(expr) } }, s_Helpers{}, _here);
            };
            if (is_void_9CJmuVSD(if_last_iOPO4E2X(expr.items).type.vtype))
                BUG_gDsnGKHT(("tryInjectJumps: Block tail is void, but block.type isn't: "_fu + explainType_gDsnGKHT(expr.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            else
            {
                expr.items += createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
            };
        };
        const s_HelpersData* BL_9_v;
        if ((expr.kind == s_Kind_block) && expr.items && !s_HelpersMask(((__extension__ (
        {
            const s_Helpers& h_1 = expr.helpers;
            BL_9_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_9_v).mask & s_HelpersMask_HM_LabelUsed)))
        {
            s_SolvedNode* _0;
            (_0 = &(last_fjKdEPCD(expr.items)), injectJumps_gDsnGKHT(*_0, h, ss, _helpers, _here, ctx, module, options));
            expr.type = t_never;
            return true;
        }
        else if (expr.kind == s_Kind_if)
        {
            for (int i = 1; i < expr.items.size(); i++)
            {
                s_SolvedNode* _1;
                (_1 = &(expr.items.mutref(i)), injectJumps_gDsnGKHT(*_1, h, ss, _helpers, _here, ctx, module, options));
            };
            expr.type = t_never;
            return true;
        };
        return false;
    }
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("tryInjectJumps: no h.ret_actual on #"_fu, fu::i64dec(h.index)), ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_steal_aoGMoHr91hd
                                #define DEF_steal_aoGMoHr91hd
inline fu::vec<s_SolvedNode> steal_aoGMoHr9(fu::vec<s_SolvedNode>& a, const int start, const int end)
{
    const int size = (end - start);
    /*MOV*/ fu::vec<s_SolvedNode> ret {};
    ret.resize(size);
    for (int i = 0; i < size; i++)
        std::swap(ret.mutref(i), a.mutref((i + start)));

    a.splice(start, size);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF___Yc7WAWDPzK5
                                #define DEF___Yc7WAWDPzK5
inline static void _Yc7WAWDP(const s_Target& t, const int position, const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    relaxBlockVar_gDsnGKHT(t, relax_mask, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (s_SolverStatus((GET_gDsnGKHT(t, ss, _here, ctx, module).status & s_SolverStatus_SS_UNUSED)) && (GET_gDsnGKHT(t, ss, _here, ctx, module).flags & s_Flags_F_IMPLICIT))
    {

        {
            const s_SolverNotes note = s_SolverNotes_N_UnusedImplicit;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
                ss._notes |= note;

        };
        if (_current_fn.out.items[position].target == t)
            _current_fn.out.items.splice(position, 1);
        else
        {
            BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}
                                #endif

                                #ifndef DEF__current_fn_eachArg_BACK_kvgUfP1hGIj
                                #define DEF__current_fn_eachArg_BACK_kvgUfP1hGIj
inline static void _current_fn_eachArg_BACK_kvgUfP1h(const unsigned relax_mask, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    for (int i = (_current_fn.out.items.size() + FN_ARGS_BACK); i-- > 0; )
    {
        const s_Target t { _current_fn.out.items[i].target };
        if (t)
        {
            int BL_4_v {};
            if ((__extension__ (
            {
                const unsigned v = unsigned((t._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v) < 0)
                _Yc7WAWDP(t, i, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
            else
            {
                BUG_u9Gbkniv(fu::str{}, _here, ctx);
            };
        };
    };
}
                                #endif

                                #ifndef DEF_EFFECTS_clock
                                #define DEF_EFFECTS_clock
extern const s_FxMask EFFECTS_clock;
                                #endif

                                #ifndef DEF_EFFECTS_input
                                #define DEF_EFFECTS_input
extern const s_FxMask EFFECTS_input;
                                #endif

static void propagateType_gDsnGKHT(s_SolvedNode& node, const s_Type& slot, const unsigned relax_mask, const s_Helpers& kills, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Kind k = node.kind;
    const s_TokenIdx here0 { _here };
    _here = node.token;
    fu_DEFER(_here = here0);
    const bool canDiscard = isIrrelevant_9CJmuVSD(slot);
    const unsigned relaxed_quals = try_relax_9CJmuVSD(node.type, slot, relax_mask);
    TEST_paintNode_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);
    if ((k == s_Kind_let) || (k == s_Kind_letdef))
    {
        if (!(!node.target))
        {
            if (relax_mask == RELAX_all)
            {
                s_SolvedNode& node_1 = GET_mut_gDsnGKHT(node.target, ss, module).solved;
                s_SolvedNode& init = node_1.items.mutref(LET_INIT);
                if (init)
                    maybeCopyOrMove_gDsnGKHT(init, node_1.type, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);

            };
            if (!canDiscard)
            {
                int BL_6_v {};
                const bool firstUse = trackVarUsage_gDsnGKHT((__extension__ (
                {
                    const s_Target& t = node.target;
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_6_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_6_v), node.type, _current_fn, ss, _helpers, _here, ctx, module, options);
                if (firstUse)
                {
                    s_Overload& o = GET_mut_gDsnGKHT(node.target, ss, module);
                    o.status |= s_SolverStatus_SS_NAME_UNUSED;
                    warnUnused_gDsnGKHT(node.target, o, _current_fn, ss, _here, ctx, module);
                    if (!is_ref_9CJmuVSD(slot))
                    {
                        unwrapLetdef_gDsnGKHT(node, relax_mask, ss, _helpers, _here, ctx, module, options);
                        propagateType_gDsnGKHT(node, slot, relax_mask, kills, _current_fn, ss, _helpers, _here, ctx, module, options);
                        return;
                    };
                };
            };
            relaxBlockVar_gDsnGKHT(node.target, relax_mask, canDiscard, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (k == s_Kind_letdef)
            {
                if (GET_gDsnGKHT(node.target, ss, _here, ctx, module).status & s_SolverStatus_SS_UNUSED)
                {

                    {
                        const s_SolverNotes note = s_SolverNotes_N_UnusedLet;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else
                            ss._notes |= note;

                    };
                    s_SolvedNode _0 {};
                    node = ((_0 = s_SolvedNode(GET_gDsnGKHT(node.target, ss, _here, ctx, module).solved.items[LET_INIT])) ? static_cast<s_SolvedNode&&>(_0) : createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options));
                };
            }
            else
                BUG_gDsnGKHT("Unexpected let node."_fu, ss, _helpers, _here, ctx, module, options);

        };
    }
    else if ((k == s_Kind_and) || (k == s_Kind_or))
    {
        const s_Type& rest = ((!canDiscard && ((k == s_Kind_or) || !andNodeType_canCleanlyDefinit_gDsnGKHT(node.type, _here, ctx))) ? slot : t_proposition);
        s_Postdom postdom0 { _current_fn.postdom };
        const bool mcomOrItems = (((k == s_Kind_or) && (relax_mask == RELAX_all) && !canDiscard) ? !is_boolean_hxWWgdZ1(node.type.vtype) : false);
        fu::vec<s_SolvedNode>& items = node.items;
        for (int i = items.size(); i-- > 0; )
        {
            s_SolvedNode& item = items.mutref(i);
            if (mcomOrItems)
                maybeCopyOrMove_gDsnGKHT(item, node.type, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);

            propagateType_gDsnGKHT(item, ((i == (items.size() - 1)) ? slot : rest), relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (canDiscard && (i == (items.size() - 1)) && isDiscardable_FDl5ha9X(item, ss, _helpers, _here, ctx, module, options))
            {

                {
                    const s_SolverNotes note = s_SolverNotes_N_UnusedAndOr;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        ss._notes |= note;

                };
                items.pop();
                if (!(_current_fn.postdom == postdom0))
                {
                    BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
                };
            };
            if (i)
                branch_gDsnGKHT(_current_fn.postdom, postdom0, _here, ctx);

        };
        if (items.size() < 2)
        {
            s_SolvedNode _1 {};
            node = ((_1 = s_SolvedNode(if_only_2GSkLHW1(items))) ? static_cast<s_SolvedNode&&>(_1) : createEmpty_gDsnGKHT(slot, s_Target{}, ss, _helpers, _here, ctx, module, options));
        }
        else if (canDiscard)
            node.type = t_bool;

    }
    else if (k == s_Kind_if)
    {
        fu::vec<s_SolvedNode>& items = node.items;
        if ((relax_mask == RELAX_all) && !canDiscard && !propositionOK_9CJmuVSD(node.type, true, _here, ctx))
        {
            for (int i = items.size(); i-- > 1; )
            {
                s_SolvedNode* _2;
                (_2 = &(items.mutref(i)), maybeCopyOrMove_gDsnGKHT(*_2, node.type, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options));
            };
        };
        s_Postdom postdom0 { _current_fn.postdom };
        bool canDiscard_cond = canDiscard;
        for (int i = items.size(); i-- > 0; )
        {
            if (i == 1)
                std::swap(postdom0, _current_fn.postdom);
            else if (i == 0)
                branch_gDsnGKHT(_current_fn.postdom, postdom0, _here, ctx);

            propagateType_gDsnGKHT(items.mutref(i), (((i != 0) || canDiscard_cond) ? slot : t_proposition), relax_mask, ((i != 0) ? kills : (*(const s_Helpers*)fu::NIL)), _current_fn, ss, _helpers, _here, ctx, module, options);
            if (canDiscard_cond && i && !isDiscardable_FDl5ha9X(items[i], ss, _helpers, _here, ctx, module, options))
                canDiscard_cond = false;

        };
        if (canDiscard)
        {
            if (canDiscard_cond)
            {

                {
                    const s_SolverNotes note = s_SolverNotes_N_UnusedIfElse;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        ss._notes |= note;

                };
                node = items[0];
            }
            else if (isDiscardable_FDl5ha9X(items[1], ss, _helpers, _here, ctx, module, options))
            {
                node = createOr_gDsnGKHT(fu::vec<s_SolvedNode> { fu::slate<2, s_SolvedNode> { s_SolvedNode(items[0]), s_SolvedNode(items[2]) } }, s_Type(t_void), _current_fn, ss, _helpers, _here, ctx, module, options);
            }
            else if (isDiscardable_FDl5ha9X(items[2], ss, _helpers, _here, ctx, module, options))
                node = createAnd_gDsnGKHT(fu::slice(items, 0, 2), s_Type(t_void), _current_fn, ss, _helpers, _here, ctx, module, options);
            else
                node.type = t_void;

        }
        else if (kills)
        {
            node.type = superType_neverOK_gDsnGKHT("if/else after control flow simplification: "_fu, items[1].type, items[2].type, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
        node._loop_start = _current_fn.postdom.write_loop_start;
    }
    else if (k == s_Kind_try)
    {
        s_Postdom postdom0 { _current_fn.postdom };
        propagateType_gDsnGKHT(recover_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        branch_gDsnGKHT(_current_fn.postdom, postdom0, _here, ctx);
        propagateType_gDsnGKHT(error_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        const s_FxMask throws0 = s_FxMask((_current_fn.effects.fx_mask & s_FxMask_Fx_Throws));
        _current_fn.effects.fx_mask &= s_FxMask(~s_FxMask_Fx_Throws);
        _current_fn.TODO_FIX_catches++;
        propagateType_gDsnGKHT(attempt_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        _current_fn.TODO_FIX_catches--;
        if (!s_FxMask((_current_fn.effects.fx_mask & s_FxMask_Fx_Throws)))
        {

            {
                const s_SolverNotes note = s_SolverNotes_N_UnusedTry;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                    ss._notes |= note;

            };
            node = attempt_FDl5ha9X(node);
        };
        _current_fn.effects.fx_mask &= s_FxMask(~s_FxMask_Fx_Throws);
        _current_fn.effects.fx_mask |= throws0;
    }
    else if (k == s_Kind_loop)
    {
        Breakable_begin_gDsnGKHT(true, node, relax_mask, _current_fn, ss, _here, ctx);
        const int read_loop0 = (_current_fn.postdom.read_loop_start ? _current_fn.postdom.read_loop_start : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        const int write_loop0 = (_current_fn.postdom.write_loop_start ? _current_fn.postdom.write_loop_start : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options));
        const s_HelpersData* BL_51_v;
        int _3 {};
        _current_fn.postdom.read_loop_start = (_current_fn.postdom.write_loop_start = ((_3 = (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_51_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_51_v).locals_start) ? _3 : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)));
        if (post_cond_FDl5ha9X(node))
        {
            propagateType_gDsnGKHT(post_cond_gDsnGKHT(node), t_proposition, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        if (post_FDl5ha9X(node))
        {
            if (isDiscardable_FDl5ha9X(post_FDl5ha9X(node), ss, _helpers, _here, ctx, module, options))
            {
                post_gDsnGKHT(node) = s_SolvedNode{};
            }
            else
            {
                propagateType_gDsnGKHT(post_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        if (body_FDl5ha9X(node))
        {
            if (isDiscardable_FDl5ha9X(body_FDl5ha9X(node), ss, _helpers, _here, ctx, module, options))
            {
                body_gDsnGKHT(node) = s_SolvedNode{};
            }
            else
            {
                propagateType_gDsnGKHT(body_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        if (pre_FDl5ha9X(node))
        {
            s_Postdom postdom0 { _current_fn.postdom };
            if (isDiscardable_FDl5ha9X(pre_FDl5ha9X(node), ss, _helpers, _here, ctx, module, options))
            {
                pre_gDsnGKHT(node) = s_SolvedNode{};
            }
            else
            {
                propagateType_gDsnGKHT(pre_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
            branch_gDsnGKHT(_current_fn.postdom, postdom0, _here, ctx);
        };
        if (pre_cond_FDl5ha9X(node))
        {
            propagateType_gDsnGKHT(pre_cond_gDsnGKHT(node), t_proposition, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        _current_fn.postdom.read_loop_start = read_loop0;
        _current_fn.postdom.write_loop_start = write_loop0;
        Breakable_end_gDsnGKHT(true, node, relax_mask, _current_fn, ss, _here, ctx);
        if (_current_fn.postdom.read_loop_start == read_loop0)
        {
            if (!(_current_fn.postdom.write_loop_start == write_loop0))
            {
                BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
        };
        if (init_FDl5ha9X(node))
        {
            propagateType_gDsnGKHT(init_gDsnGKHT(node), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        if (!node._loop_start || (node._loop_start == _current_fn.postdom.write_loop_start))
        {
            node._loop_start = _current_fn.postdom.write_loop_start;
            if (_current_fn.postdom.read_loop_start == read_loop0)
            {
                if (!(_current_fn.postdom.write_loop_start == write_loop0))
                {
                    BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
            {
                BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
            BUG_gDsnGKHT("The new loop._loop_start thing would mess something else up"_fu, ss, _helpers, _here, ctx, module, options);

    }
    else if (k == s_Kind_not)
    {
        if (canDiscard)
        {
            node = only_LqU08rcL(node.items);
            propagateType_gDsnGKHT(node, t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            propagateType_gDsnGKHT(only_n3dv4p6e(node.items), t_proposition, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    }
    else if (k == s_Kind_call)
    {
        node._loop_start = _current_fn.postdom.write_loop_start;
        const s_Target t { node.target };
        if (GET_gDsnGKHT(t, ss, _here, ctx, module).kind == s_Kind_field)
        {
            const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(GET_gDsnGKHT(t, ss, _here, ctx, module), _here, ctx);
            s_Type slot_1 = USAGE_structUsageFromFieldUsage_GgXYS4ZV(s_Type(slot), _.memberFlatOffset);
            if (canDiscard)
            {
                node = only_LqU08rcL(node.items);
                propagateType_gDsnGKHT(node, slot_1, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            }
            else
            {
                propagateType_gDsnGKHT(only_n3dv4p6e(node.items), slot_1, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        }
        else if (GET_gDsnGKHT(t, ss, _here, ctx, module).kind == s_Kind_var)
        {
            node._loop_start = _current_fn.postdom.read_loop_start;
            if (canDiscard)
            {
                node = createEmpty_gDsnGKHT(slot, s_Target{}, ss, _helpers, _here, ctx, module, options);
            }
            else if (isLocal_gDsnGKHT(t))
            {
                int BL_82_v {};
                trackVarUsage_gDsnGKHT((__extension__ (
                {
                    const unsigned v = unsigned((t._packed & 0xfffffull));
                    BL_82_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_82_v), node.type, _current_fn, ss, _helpers, _here, ctx, module, options);
                trackUsedAgain_gDsnGKHT(node.type.lifetime, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            const unsigned mask_retval_relaxable = mask_retval_relaxable_9CJmuVSD(GET_gDsnGKHT(t, ss, _here, ctx, module).type, relaxed_quals, _here, ctx);
            if (mask_retval_relaxable && (int(unsigned(((t._packed >> 40ull) & 0xfffffull))) == module.modid))
            {
                if (GET_gDsnGKHT(t, ss, _here, ctx, module).kind == s_Kind_fn)
                {
                    const s_Target spec = tryReverseSpecialize_gDsnGKHT(s_Target(t), mask_retval_relaxable, ss, _helpers, _here, ctx, module, options);
                    if (spec)
                        redirectCallTarget_gDsnGKHT(spec, node, t, _current_fn, ss, _helpers, _here, ctx, module, options);

                }
                else if (EXT_gDsnGKHT(t, ss, ctx, module).spec_of)
                {
                    fu::vec<s_SolvedNode> relaxed {};
                    for (int i = 0; i < node.items.size(); i++)
                    {
                        const s_SolvedNode& orig = node.items[i];
                        if (EXT_gDsnGKHT(t, ss, ctx, module).args[i].flags & s_Flags_F_LT_RETURNED)
                        {
                            const unsigned relax_mask_1 = (relax_mask & ~q_USAGE);
                            s_Type type { orig.type };
                            if (try_relax_9CJmuVSD(type, slot, relax_mask_1))
                            {
                                if (!relaxed)
                                    relaxed = fu::slice(node.items, 0, i);

                                relaxed += SolvedNode_gDsnGKHT(s_Kind___relaxed, type, s_Flags{}, (*(const fu::str*)fu::NIL), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, s_Helpers{}, _here);
                                continue;
                            };
                        };
                        if (relaxed)
                            relaxed += s_SolvedNode(orig);

                    };
                    if (relaxed)
                    {
                        fu::str error {};
                        fu::str args_mangled {};
                        const s_Target spec = trySpecialize_gDsnGKHT(s_Target(EXT_gDsnGKHT(t, ss, ctx, module).spec_of), relaxed, args_mangled, error, relaxed.size(), (*(const s_Type*)fu::NIL), (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                        if (!is_SPECFAIL_gDsnGKHT(spec))
                            redirectCallTarget_gDsnGKHT(spec, node, t, _current_fn, ss, _helpers, _here, ctx, module, options);

                    };
                };
            };
            if (canDiscard && isDiscardable_gDsnGKHT(node.target, ss, _helpers, _here, ctx, module, options))
            {

                {
                    const s_SolverNotes note = s_SolverNotes_N_UnusedCall;
                    if (note & options.break_notes)
                    {
                        fu::view<char> reason = fu::view<char>{};
                        fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                        ss._notes |= note;

                };
                discardIntoBlock_gDsnGKHT(node, slot, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
            }
            else
            {
                if (is_never_9CJmuVSD(GET_gDsnGKHT(node.target, ss, _here, ctx, module).type.vtype) && !_current_fn.TODO_FIX_catches)
                {
                    _current_fn.postdom.snap = s_PostdomSnap{};
                    _current_fn.postdom.snap.exitPaths = s_ExitPaths_XP_NoReturn;
                };
                _current_fn.effects.fx_mask |= EXT_gDsnGKHT(node.target, ss, ctx, module).fx_mask;
                if ((relax_mask == RELAX_all) && node.items)
                {
                    fu::vec<s_Argument> host_args { EXT_gDsnGKHT(t, ss, ctx, module).args };
                    for (int i = 0; i < host_args.size(); i++)
                    {
                        const s_SolvedNode& arg = node.items[i];
                        s_Argument host_arg { host_args[i] };
                        if (is_ref_9CJmuVSD(host_arg.type))
                        {
                            trackUsedAgain_gDsnGKHT(arg.type.lifetime, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
                        };
                        if (host_arg.flags & s_Flags_F_COW_INSIDE)
                            validateCOW_gDsnGKHT(arg, arg.token, node.target, host_arg, canDiscard, _current_fn, ss, _helpers, _here, ctx, module, options);

                    };
                };
                if (node.items)
                { {
                    if (GET_gDsnGKHT(t, ss, _here, ctx, module).kind == s_Kind_type)
                    {
                        s_UserType BL_109_v {};
                        s_UserType s = (__extension__ (
                        {
                            const s_UserType& __partcopy_ref = tryLookupUserType_1qjplDUo(GET_gDsnGKHT(t, ss, _here, ctx, module).type.vtype, _here, ctx, module);
                            BL_109_v = (s_UserType { __partcopy_ref.kind, {}, {}, fu::vec<s_ScopeItem>(__partcopy_ref.items), {}, {}, {}, {} });
                        (void)0;}), static_cast<s_UserType&&>(BL_109_v));
                        if (!(s.kind != s_Kind_struct))
                        {
                            if (s.items.size() == node.items.size())
                            {
                                for (int i = node.items.size(); i-- > 0; )
                                {
                                    const s_Overload& field = GET_gDsnGKHT(target_z0QqoZ5t(s.items[i]), ss, _here, ctx, module);
                                    s_SolvedNode& arg = node.items.mutref(i);
                                    const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(field, _here, ctx);
                                    unsigned BL_114_v {};
                                    s_Type slot_1 = USAGE_fieldUsageFromStructUsage_GgXYS4ZV(s_Type(field.type), (__extension__ (
                                    {
                                        const s_ValueType& type = slot.vtype;
                                        BL_114_v = ((type.quals & q_USAGE));
                                    (void)0;}), BL_114_v), _.memberFlatOffset, _.memberFlatCount);
                                    if (relax_mask == RELAX_all)
                                        maybeCopyOrMove_gDsnGKHT(arg, slot_1, true, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);

                                    propagateType_gDsnGKHT(arg, slot_1, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                                };
                                goto BL_107;
                            }
                            else
                                BUG_gDsnGKHT("Call(type): struct.items.len != call.items.len"_fu, ss, _helpers, _here, ctx, module, options);

                        };
                    };
                    fu::vec<s_Argument> host_args { EXT_gDsnGKHT(node.target, ss, ctx, module).args };
                    const bool RTL = isRTL_xQNS19Zn(GET_gDsnGKHT(node.target, ss, _here, ctx, module));
                    if (host_args.size() == node.items.size())
                        argsReverse_JsXGXPqU(RTL, host_args, node, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
                    else
                        BUG_gDsnGKHT(x7E_3lDd4lqo("propagateType(call) args.len != host_args.len at call to "_fu, str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                  } BL_107:;
                };
            };
        };
    }
    else if (isImmediatelyDiscardable_UVY6Qzz1(k))
    {
        if (canDiscard || (k == s_Kind_definit))
        {
            if (node.items)
                BUG_gDsnGKHT((x7E_3lDd4lqo("propagateType canDiscard("_fu, str_WkqQ7QhO(k)) + ") has items."_fu), ss, _helpers, _here, ctx, module, options);
            else
                intoEmpty_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);

        };
    }
    else if (k == s_Kind_copy)
    {
        if (canDiscard)
            BUG_gDsnGKHT(x7E_3lDd4lqo("Trying to discard a copy: "_fu, str_iUdwqyBn(node, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else if (relax_mask != RELAX_all)
            BUG_gDsnGKHT(x7E_3lDd4lqo("Found a copy node during first relax: "_fu, str_iUdwqyBn(node, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else
        {
            const s_SolvedNode& item = only_LqU08rcL(node.items);
            bool isCopy = true;
            s_UsedAgain usedAgain {};
            if (!is_trivial_1qjplDUo(item.type.vtype, _here, ctx, module))
            {
                if (!(usedAgain = trackUsedAgain_gDsnGKHT(item.type.lifetime, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options)))
                    isCopy = false;
                else
                {
                    if (!is_trivial_1qjplDUo(item.type.vtype, _here, ctx, module))
                    {
                        validateCOW_gDsnGKHT(item, s_TokenIdx(_here), s_Target{}, (*(const s_Argument*)fu::NIL), false, _current_fn, ss, _helpers, _here, ctx, module, options);
                    };
                    unsigned BL_131_v {};
                    const unsigned usage = (__extension__ (
                    {
                        const s_ValueType& type = node.type.vtype;
                        BL_131_v = ((type.quals & q_USAGE));
                    (void)0;}), BL_131_v);
                    const int flatCount = getFlatCount_1qjplDUo(node.type.vtype, _here, ctx, module);
                    const unsigned maxUsage = getMaxUsage_CaGDtmWo(flatCount);
                    if ((usage != maxUsage) && is_rx_copy_9CJmuVSD(node.type.vtype))
                    {
                        s_UserType BL_133_v {};
                        s_UserType s = (__extension__ (
                        {
                            const s_UserType& __partcopy_ref = tryLookupUserType_1qjplDUo(node.type.vtype, _here, ctx, module);
                            BL_133_v = (s_UserType { __partcopy_ref.kind, {}, s_Target(__partcopy_ref.target), fu::vec<s_ScopeItem>(__partcopy_ref.items), {}, {}, {}, {} });
                        (void)0;}), static_cast<s_UserType&&>(BL_133_v));
                        if (!(s.kind != s_Kind_struct))
                        {
                            if (!USAGE_justOneThing_9CJmuVSD(usage, flatCount) && !isFieldChain_gDsnGKHT(item, ss, _here, ctx, module))
                            {
                                /*MOV*/ s_SolvedNode letdef = createLet_gDsnGKHT("__partcopy_ref"_fu, s_Flags{}, s_DeclAsserts{}, item, false, _current_fn, ss, _helpers, _here, ctx, module, options);
                                only_n3dv4p6e(node.items) = CallerNode_gDsnGKHT("__partcopy_ref"_fu, s_Target((letdef.target ? letdef.target : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options))), fu::vec<s_SolvedNode>{}, (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                                node = createBlock_FDl5ha9X(static_cast<s_SolvedNode&&>(letdef), s_SolvedNode(node), ss, _here, ctx, module);
                            }
                            else
                            {
                                /*MOV*/ fu::vec<s_SolvedNode> args {};
                                for (int i = 0; i < s.items.size(); i++)
                                {
                                    const s_Target fieldTarget = target_z0QqoZ5t(s.items[i]);
                                    const s_Overload& field = GET_gDsnGKHT(fieldTarget, ss, _here, ctx, module);
                                    const s_UnpackedOffset _ = field_unpackOffset_gDsnGKHT(field, _here, ctx);
                                    /*MOV*/ s_Type usedFieldType = USAGE_fieldUsageFromStructUsage_GgXYS4ZV(s_Type(field.type), usage, _.memberFlatOffset, _.memberFlatCount);
                                    if (isIrrelevant_9CJmuVSD(usedFieldType))
                                    {
                                        args += createEmpty_gDsnGKHT(usedFieldType, s_Target{}, ss, _helpers, _here, ctx, module, options);
                                    }
                                    else
                                    {
                                        /*MOV*/ s_SolvedNode copy { node };
                                        copy.type = static_cast<s_Type&&>(usedFieldType);
                                        copy.items = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { CallerNode_gDsnGKHT("__partcopy_f"_fu, s_Target(fieldTarget), fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(item) } }, (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options) } };
                                        args += static_cast<s_SolvedNode&&>(copy);
                                    };
                                };
                                /*MOV*/ s_Type type0 { node.type };
                                node = CallerNode_gDsnGKHT("__partcopy_s"_fu, s_Target(s.target), static_cast<fu::vec<s_SolvedNode>&&>(args), (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                                node.type = static_cast<s_Type&&>(type0);
                            };
                            propagateType_gDsnGKHT(node, slot, relax_mask, kills, _current_fn, ss, _helpers, _here, ctx, module, options);
                            return;
                        };
                    };
                };
            };
            s_SolvedNode& item_1 = only_n3dv4p6e(node.items);
            if (is_ref_9CJmuVSD(item_1.type))
            {
                if (!(isCopy ? is_rx_copy_9CJmuVSD(item_1.type.vtype) : is_rx_move_9CJmuVSD(item_1.type)))
                {
                    fu::str extra = explainUsedAgain_gDsnGKHT(usedAgain, ss, _here, ctx, module, options);
                    fail_gDsnGKHT(((((!isCopy && is_sliceable_hxWWgdZ1(item_1.type.vtype)) ? "An array value is needed, but cannot be copied or moved from a slice: "_fu : "A value is needed, but cannot be copied or moved from: "_fu) + explainType_gDsnGKHT(item_1.type, false, true, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + (extra ? ("\n\n\tCannot move: "_fu + extra) : fu::str{})), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    if (isCopy && !is_trivial_1qjplDUo(node.type.vtype, _here, ctx, module))
                    {
                        const s_SolverNotes note = s_SolverNotes_N_NonTrivAutoCopy;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else
                            ss._notes |= note;

                    };
                    s_Type itemSlot = (isCopy ? make_copyable_9CJmuVSD(s_Type(slot)) : make_moveable_9CJmuVSD(s_Type(slot)));
                    propagateType_gDsnGKHT(item_1, itemSlot, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                    if (!is_ref_9CJmuVSD(item_1.type))
                        node = item_1;
                    else if (!isCopy)
                    {
                        Lifetime_F_MOVED_FROM_gDsnGKHT(item_1.type.lifetime, ss, _helpers, _here, ctx, module, options);
                        node.kind = s_Kind_move;
                    };
                };
            }
            else
                BUG_gDsnGKHT(x7E_3lDd4lqo("Nothing to copy, item is not a ref: "_fu, str_iUdwqyBn(item_1, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        };
    }
    else if (k == s_Kind_arrlit)
    {
        if (!node.items.size())
            intoEmpty_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);
        else if (canDiscard)
        {

            {
                const s_SolverNotes note = s_SolverNotes_N_UnusedArrlit;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                    ss._notes |= note;

            };
            discardIntoBlock_gDsnGKHT(node, slot, relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            fu::view_mut<s_SolvedNode> items = node.items;
            s_Type itemSlot = clear_sliceable_1qjplDUo(node.type.vtype, _here, ctx, module);
            if (relax_mask == RELAX_all)
            {
                for (int i = 0; i < items.size(); i++)
                {
                    s_SolvedNode* _4;
                    (_4 = &(items.mutref(i)), maybeCopyOrMove_gDsnGKHT(*_4, itemSlot, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options));
                };
            };
            for (int i = 0; i < items.size(); i++)
            {
                propagateType_gDsnGKHT(items.mutref(i), itemSlot, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    }
    else if ((k == s_Kind_argid) || (k == s_Kind___litfix_bound))
    {
        node = first_5wdN9pnX(node.items);
        propagateType_gDsnGKHT(node, slot, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else if (k == s_Kind_jump)
    {
        s_Helpers h { node.helpers };
        const s_HelpersData* BL_164_v;
        while ((__extension__ (
        {
            const s_Helpers& h_1 = h;
            BL_164_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_164_v).kills)
        {
            const s_HelpersData* BL_167_v;
            h = (node.helpers = (__extension__ (
            {
                const s_Helpers& h_1 = h;
                BL_167_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_167_v).kills);
        };
        const s_HelpersData* BL_168_v;
        if ((__extension__ (
        {
            const s_Helpers& h_1 = h;
            BL_168_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_168_v).ret_actual)
        {
            s_SolvedNode& expr = only_n3dv4p6e(node.items);

            {
                const int read_loop0 = _current_fn.postdom.read_loop_start;
                const s_HelpersData* BL_171_v;
                const s_Postdom* _5;
                _current_fn.postdom = (*(_5 = &((__extension__ (
                {
                    const s_Helpers& h_1 = h;
                    BL_171_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_171_v).postdom)) ? *_5 : BUG_gDsnGKHT(x7E_3lDd4lqo("propagateType(jump): h.loop_start not available: #"_fu, fu::i64dec(h.index)), ss, _helpers, _here, ctx, module, options));
                _current_fn.postdom.read_loop_start = read_loop0;
                const s_HelpersData* BL_172_v;
                if ((__extension__ (
                {
                    const s_Helpers& h_1 = h;
                    BL_172_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_172_v).mask & s_HelpersMask_HM_Function)
                {
                    const s_Kind kind = expr.kind;
                    _current_fn.postdom.snap.exitPaths = (((kind == s_Kind_empty) || (kind == s_Kind_definit)) ? s_ExitPaths_XP_EmptyReturn : s_ExitPaths_XP_NonEmptyReturn);
                };
            };
            const bool redundant = (kills ? (kills.index <= h.index) : false);
            const s_Helpers& kills_1 = (redundant ? kills : h);
            if (relax_mask == RELAX_all)
            {
                const s_HelpersData* BL_175_v;
                maybeCopyOrMove_gDsnGKHT(expr, (__extension__ (
                {
                    const s_Helpers& h_1 = h;
                    BL_175_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_175_v).ret_actual, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
            };
            const s_HelpersData* BL_176_v;
            propagateType_gDsnGKHT(expr, s_Type((__extension__ (
            {
                const s_Helpers& h_1 = h;
                BL_176_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_176_v).ret_actual), relax_mask, kills_1, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (redundant)
                node = expr;
            else
            {
                s_HelpersData* BL_179_v;
                (__extension__ (
                {
                    const s_Helpers& h_1 = h;
                    BL_179_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h_1.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_179_v).mask |= s_HelpersMask_HM_LabelUsed;
                const s_HelpersData* BL_180_v;
                if (isIrrelevant_9CJmuVSD((__extension__ (
                {
                    const s_Helpers& h_1 = h;
                    BL_180_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_180_v).ret_actual))
                {
                    if (expr.kind == s_Kind_empty)
                    {
                        const s_HelpersData* BL_183_v;
                        expr.type = (__extension__ (
                        {
                            const s_Helpers& h_1 = h;
                            BL_183_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                        (void)0;}), *BL_183_v).ret_actual;
                        intoEmpty_gDsnGKHT(expr, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                    {
                        const s_HelpersData* BL_185_v;
                        /*MOV*/ s_SolvedNode not_empty = createEmpty_gDsnGKHT((__extension__ (
                        {
                            const s_Helpers& h_1 = h;
                            BL_185_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                        (void)0;}), *BL_185_v).ret_actual, s_Target{}, ss, _helpers, _here, ctx, module, options);
                        std::swap(expr, not_empty);
                        node = createBlock_FDl5ha9X(static_cast<s_SolvedNode&&>(not_empty), s_SolvedNode(node), ss, _here, ctx, module);
                    };
                }
                else if (tryInjectJumps_gDsnGKHT(expr, h, ss, _helpers, _here, ctx, module, options))
                    node = expr;

            };
        }
        else
            BUG_gDsnGKHT(x7E_3lDd4lqo("propagateType(jump): h.ret_actual not available: #"_fu, fu::i64dec(h.index)), ss, _helpers, _here, ctx, module, options);

    }
    else if (k == s_Kind_block)
    {
        const s_Helpers& h = node.helpers;
        if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)
        {
            if ((relax_mask == RELAX_all) && s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Function)))
                mcom_FnReturn_CopyOrMoveDecision_gDsnGKHT(h, _current_fn, ss, _helpers, _here, ctx, module, options);

            try_relax_9CJmuVSD((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual, slot, relax_mask);
            if ((relax_mask == RELAX_all) && !canDiscard && !is_never_9CJmuVSD((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual.vtype))
            {
                const s_Type* _6;
                s_SolvedNode* _7;
                (_6 = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual), _7 = &(last_fjKdEPCD(node.items)), maybeCopyOrMove_gDsnGKHT(*_7, *_6, false, (*(const fu::str*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options));
            };
        };
        if (h)
        {
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask &= s_HelpersMask(~s_HelpersMask_HM_LabelUsed);
            (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).kills = s_Helpers(kills);
        };
        fu::vec<s_SolvedNode>& items = node.items;

        {
            for (int i = 0; i < (items.size() - 1); i++)
            {
                s_SolvedNode& node_1 = items.mutref(i);
                const s_Kind k_1 = node_1.kind;
                if (k_1 == s_Kind_defer)
                {
                    TEST_paintNode_gDsnGKHT(node_1, ss, _helpers, _here, ctx, module, options);
                    s_SolvedNode& expr = only_n3dv4p6e(node_1.items);
                    propagateType_gDsnGKHT(expr, t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                    if (isDiscardable_FDl5ha9X(expr, ss, _helpers, _here, ctx, module, options))
                    {

                        {
                            const s_SolverNotes note = s_SolverNotes_N_UnusedDefer;
                            if (note & options.break_notes)
                            {
                                fu::view<char> reason = fu::view<char>{};
                                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            }
                            else
                                ss._notes |= note;

                        };
                        items.splice(i--, 1);
                    };
                }
                else if ((k_1 == s_Kind_and) || (k_1 == s_Kind_or))
                {
                    if (is_never_9CJmuVSD(last_31malqbt(node_1.items).type.vtype))
                    {
                        /*MOV*/ fu::vec<s_SolvedNode> cond = fu::slice(node_1.items, 0, (node_1.items.size() - 1));
                        /*MOV*/ s_SolvedNode cons { node_1.items[(node_1.items.size() - 1)] };
                        fu::vec<s_SolvedNode> alt = fu::slice(items, (i + 1), items.size());
                        items.splice((i + 1), alt.size());
                        s_SolvedNode cond_1 = ((k_1 == s_Kind_and) ? createAnd_gDsnGKHT(static_cast<fu::vec<s_SolvedNode>&&>(cond), s_Type(t_proposition), _current_fn, ss, _helpers, _here, ctx, module, options) : createOr_gDsnGKHT(static_cast<fu::vec<s_SolvedNode>&&>(cond), s_Type(t_proposition), _current_fn, ss, _helpers, _here, ctx, module, options));
                        /*MOV*/ s_SolvedNode alt_1 = createBlock_gDsnGKHT(last_31malqbt(alt).type, alt, s_Helpers{}, _here);
                        /*MOV*/ s_SolvedNode replacement = createIf_gDsnGKHT(cond_1, s_SolvedNode(((k_1 == s_Kind_and) ? cons : alt_1)), static_cast<s_SolvedNode&&>(((k_1 == s_Kind_and) ? alt_1 : cons)), s_Type{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                        items.mutref(i) = static_cast<s_SolvedNode&&>(replacement);
                    };
                }
                else if (k_1 == s_Kind_block)
                {
                    if (if_last_iOPO4E2X(node_1.items).kind == s_Kind_unwrap)
                    {
                        if (relax_mask == RELAX_before_bck)
                        {
                            const s_HelpersData* BL_206_v;
                            if ((node_1.kind == s_Kind_block) && !s_HelpersMask(((__extension__ (
                            {
                                const s_Helpers& h_1 = node_1.helpers;
                                BL_206_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                            (void)0;}), *BL_206_v).mask & s_HelpersMask_HM_LabelUsed)))
                            {
                                items.splice(i, 1, steal_aoGMoHr9(node_1.items, 0, (node_1.items.size() - 1)));
                                i--;
                                continue;
                            }
                            else
                            {
                                fail_gDsnGKHT("`unwrap` doesn't currently support early returns."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            };
                        }
                        else
                            BUG_gDsnGKHT("Unwrapping a `defer` after BCK, changes control flow."_fu, ss, _helpers, _here, ctx, module, options);

                    };
                };
            };
            Breakable_begin_gDsnGKHT(false, node, relax_mask, _current_fn, ss, _here, ctx);
            fu_DEFER(Breakable_end_gDsnGKHT(false, node, relax_mask, _current_fn, ss, _here, ctx));
            while (items)
            {
                s_SolvedNode& tail = last_fjKdEPCD(items);
                if (tail.kind == s_Kind_defer)
                {
                    tail = ((tail.value == "err"_fu) ? createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options) : s_SolvedNode(only_LqU08rcL(tail.items)));
                    break;
                }
                else
                {
                    const s_Helpers& kills_1 = (!(s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Function)) && !is_void_9CJmuVSD((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual.vtype)) ? (kills ? kills : h) : (*(const s_Helpers*)fu::NIL));
                    propagateType_gDsnGKHT(tail, slot, relax_mask, kills_1, _current_fn, ss, _helpers, _here, ctx, module, options);
                    if (!canDiscard || !isDiscardable_FDl5ha9X(tail, ss, _helpers, _here, ctx, module, options))
                        break;
                    else
                        items.pop();

                };
            };
            for (int i_1 = (items.size() - 1); i_1-- > 0; )
            {
                s_SolvedNode& expr = items.mutref(i_1);
                if (expr.kind != s_Kind_defer)
                {
                    propagateType_gDsnGKHT(expr, t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                    if (isDiscardable_FDl5ha9X(expr, ss, _helpers, _here, ctx, module, options))
                        items.splice(i_1, 1);

                };
            };
        };
        if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target == _current_fn.out.target)
            _current_fn_eachArg_BACK_kvgUfP1h(relax_mask, _current_fn, ss, _helpers, _here, ctx, module, options);

        if (!items && !s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Function)))
        {
            if (!canDiscard)
                BUG_gDsnGKHT(("Empty block type is relevant: "_fu + explainType_gDsnGKHT(node.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
            else
                intoEmpty_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);

        }
        else if ((items.size() == 1) && !s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask((s_HelpersMask_HM_LabelUsed | s_HelpersMask_HM_Function)))))
            node = only_LqU08rcL(items);
        else
        {
            if (canDiscard)
                node.type = slot;
            else if (kills)
            {
                if (items)
                {
                    const s_SolvedNode& tail = last_31malqbt(items);
                    if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)
                    {
                        reportReturnType_gDsnGKHT(h, tail.type, false, _current_fn, ss, _helpers, _here, ctx, module, options);
                        node.type = (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual;
                    }
                    else
                        node.type = tail.type;

                };
            };
            const s_SolvedNode& tail = if_last_iOPO4E2X(node.items);
            const s_HelpersData* BL_231_v;
            if ((tail.kind == s_Kind_block) && !s_HelpersMask(((__extension__ (
            {
                const s_Helpers& h_1 = tail.helpers;
                BL_231_v = &((((h_1.index >= 0) && (h_1.index < ss._helpers_data.size())) ? ss._helpers_data[h_1.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_231_v).mask & s_HelpersMask_HM_LabelUsed)))
                node.items.splice((node.items.size() - 1), 1, fu::vec<s_SolvedNode>(tail.items));

        };
    }
    else if (k == s_Kind_root)
    {
        for (int i = node.items.size(); i-- > 0; )
        {
            propagateType_gDsnGKHT(node.items.mutref(i), t_void, relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    }
    else if (k == s_Kind_pragma)
    {
        node._loop_start = _current_fn.postdom.write_loop_start;
        for (int i = 0; i < node.items.size(); i++)
        {
            s_SolvedNode& item = node.items.mutref(i);
            propagateType_gDsnGKHT(item, s_Type(node.items[i].type), relax_mask, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (is_mutref_9CJmuVSD(item.type, _here, ctx))
            {
                unsigned BL_240_v {};
                callarg_trackWrites_gDsnGKHT(item.type.lifetime, (__extension__ (
                {
                    const s_ValueType& type = item.type.vtype;
                    BL_240_v = ((type.quals & q_USAGE));
                (void)0;}), BL_240_v), node, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        if (node.value == "clock"_fu)
            _current_fn.effects.fx_mask |= EFFECTS_clock;
        else if (node.value == "input"_fu)
            _current_fn.effects.fx_mask |= EFFECTS_input;
        else if (node.value == "output"_fu)
            _current_fn.effects.fx_mask |= EFFECTS_output;

    }
    else if (k == s_Kind_unwrap)
    {
        fu::str what = (node.target ? str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options) : "block"_fu);
        fail_gDsnGKHT((((((("Attempting to use an "_fu + qKW_e44UlzzA("unwrap"_fu)) + " "_fu) + what) + " as a value."_fu) + "\n\n\tUnwrapping here would complete any defers inside immediately."_fu) + "\n\n\tIf this is intended, wrap it in a block to disambiguate."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
        BUG_gDsnGKHT(("relax: Unexpected "_fu + str_WkqQ7QhO(k)), ss, _helpers, _here, ctx, module, options);

}

static fu::view<s_SolvedNode> args_iUdwqyBn(const s_SolvedNode& callsite)
{
    return callsite.items;
}

static const s_Target& target_FDl5ha9X(const s_SolvedNode& callsite)
{
    return callsite.target;
}

                                #ifndef DEF_TODO_FIX_static_ZSTs
                                #define DEF_TODO_FIX_static_ZSTs
inline constexpr bool TODO_FIX_static_ZSTs = true;
                                #endif

static const s_Events& events_iUdwqyBn(const s_CurrentFn& _current_fn)
{
    return _current_fn.events;
}

                                #ifndef DEF_iF_aDgveplH4E4
                                #define DEF_iF_aDgveplH4E4
inline const s_Set_2i2v33LNlqd& iF_aDgveplH(fu::view<s_Set_2i2v33LNlqd> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Set_2i2v33LNlqd*)fu::NIL);

}
                                #endif

                                #ifndef DEF_iF_hRiqvWW2lBd
                                #define DEF_iF_hRiqvWW2lBd
inline static const s_Set_2i2v33LNlqd& iF_hRiqvWW2(const s_LocidMap_OrMuSNs7d4i& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return iF_aDgveplH(map._values, (args_neg + locid));
}
                                #endif

static int locid_gDsnGKHT(const s_WriteID& w)
{
    const unsigned v = (w._locid_and_hash & 0xfffffu);
    return int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u)));
}

static bool acceptsTempCopies_FDl5ha9X(const s_Overload& o, const s_TokenIdx& _here, const s_Context& ctx)
{
    if ((o.kind == s_Kind_var) && !(o.flags & (s_Flags_F_IMPLICIT | s_Flags_F_REF)))
        return !is_mutref_9CJmuVSD(o.type, _here, ctx);
    else
        return false;

}

static bool acceptsSoftRisk_FDl5ha9X(const s_Target& t, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    int BL_1_v {};
    if ((__extension__ (
    {
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) < 0)
        return !acceptsTempCopies_FDl5ha9X(GET_gDsnGKHT(t, ss, _here, ctx, module), _here, ctx);
    else
        return false;

}

static bool RESOLVE_byAAR_gDsnGKHT(const int read, const int write, const bool trySoft, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (pass == s_BorrowCheckPass_BCK_aar)
    {
        if (read != write)
        {
            if ((!trySoft || !acceptsSoftRisk_FDl5ha9X(nested_FDl5ha9X(read, ss, _here, ctx), ss, _here, ctx, module)) && !add_gDsnGKHT(ensure_solxXoYY(_current_fn.flow.at_hard_risk, write, _current_fn), read, _current_fn))
                return true;
            else if (!add_gDsnGKHT(ensure_solxXoYY(_current_fn.flow.at_soft_risk, write, _current_fn), read, _current_fn))
                return true;
            else
            {
                const bool firstTry_to_ascendWrites = (write > read);
                for (int i = 0; i < 2; i++)
                {
                    if (!i == firstTry_to_ascendWrites)
                    {
                        s_Set_95BJOojOc45 parents { iF_Mjtiwtwz(_current_fn.flow.arg_parents, write, _current_fn) };
                        if (parents)
                        {
                            for (int i_1 = 0; i_1 < parents.keys_asc.size(); i_1++)
                            {
                                int BL_12_v {};
                                const int parent = (__extension__ (
                                {
                                    const int i_2 = i_1;
                                    BL_12_v = (parents.keys_asc[i_2]);
                                (void)0;}), BL_12_v);
                                if (parent != read)
                                    RESOLVE_byAAR_gDsnGKHT(read, parent, trySoft, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

                            };
                            return true;
                        };
                    }
                    else
                    {
                        s_Set_95BJOojOc45 parents { iF_Mjtiwtwz(_current_fn.flow.arg_parents, read, _current_fn) };
                        if (parents)
                        {
                            for (int i_1 = 0; i_1 < parents.keys_asc.size(); i_1++)
                            {
                                int BL_18_v {};
                                const int parent = (__extension__ (
                                {
                                    const int i_2 = i_1;
                                    BL_18_v = (parents.keys_asc[i_2]);
                                (void)0;}), BL_18_v);
                                if (parent != write)
                                    RESOLVE_byAAR_gDsnGKHT(parent, write, false, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

                            };
                            return true;
                        };
                    };
                };
                return true;
            };
        }
        else
            BUG_gDsnGKHT("RESOLVE_byAAR: read == write"_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}

static bool RESOLVE_byAAR_wyx7msfr(fu::view<s_WriteID> writes, const int read, const bool trySoft, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < writes.size(); i++)
        RESOLVE_byAAR_gDsnGKHT(read, locid_gDsnGKHT(writes[i]), trySoft, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

    return true;
}

static const s_Overload& GET_mut_FDl5ha9X(const s_Target& target, const s_SolverState& ss, const s_Module& module)
{
    const int globid = int(unsigned(((target._packed >> 20ull) & 0xfffffull)));
    int BL_1_v {};
    const int locid = (__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    if ((globid > 0) && (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid))
    {
        if (locid)
        {
            const s_Extended& ext = ss._scope.extended[globid];
            int BL_4_v {};
            return ext.args_n_locals[(__extension__ (
            {
                const s_Extended& ext_1 = ext;
                BL_4_v = (((ext_1.args_neg - ((locid > 0) ? 1 : 0)) + locid));
            (void)0;}), BL_4_v)];
        }
        else
            return ss._scope.overloads[(globid - 1)];

    }
    else
        fu::fail("GET_mut: bad modid/globid"_fu);

}

static s_Flow& flow_gDsnGKHT(s_CurrentFn& _current_fn)
{
    return _current_fn.flow;
}

static bool RESOLVE_byMutvar_FDl5ha9X(const int locid, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (pass == s_BorrowCheckPass_BCK_bck)
    {
        const s_Target t = nested_FDl5ha9X(locid, ss, _here, ctx);
        const s_Overload& o = GET_mut_FDl5ha9X(t, ss, module);
        if (!acceptsTempCopies_FDl5ha9X(o, _here, ctx))
            return false;
        else if (is_mutref_9CJmuVSD(o.type, _here, ctx))
            BUG_gDsnGKHT((x7E_3lDd4lqo(str_FDl5ha9X(t, false, ss, _here, ctx, module, options), ": Not F_REF but type.is_mutref"_fu) + " in RESOLVE_byMutvar: is this a problem?"_fu), ss, _helpers, _here, ctx, module, options);
        else if (o.kind == s_Kind_var)
        {
            TEST_varLifetime_gDsnGKHT(o.type.lifetime, false, 0, ss, _helpers, _here, ctx, module, options);
            if (!is_rx_copy_9CJmuVSD(o.type.vtype))
                return false;
            else
            {
                add_gDsnGKHT(flow_gDsnGKHT(_current_fn).bck_consider_copy, locid, _current_fn);
                return true;
            };
        }
        else
            BUG_gDsnGKHT(x7E_3lDd4lqo("RESOLVE_byMutvar: Not a variable: "_fu, str_FDl5ha9X(t, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}

                                #ifndef DEF_first_28gjKDbX0X8
                                #define DEF_first_28gjKDbX0X8
inline const s_WriteID& first_28gjKDbX(fu::view<s_WriteID> s)
{
    return s[0];
}
                                #endif

static unsigned tokenHash_gDsnGKHT(const s_TokenIdx& token)
{
    return ((unsigned(token.modid) * 9973u) ^ unsigned(token.tokidx)) << 20u;
}

static unsigned tokenHash_FDl5ha9X(const s_WriteID& w)
{
    return w._locid_and_hash & 0xfff00000u;
}

static fu::str RWEvent_stack_gDsnGKHT(const s_WriteID& write, const s_SolvedNode& root, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int locid = locid_gDsnGKHT(write);

    {
        const s_SolvedNode& node = root;
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            const s_SolvedNode& node_3 = ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
            if (!(tokenHash_gDsnGKHT(node_3.token) != tokenHash_FDl5ha9X(write)))
            {
                if (!((node_3.kind != s_Kind_call) && (node_3.kind != s_Kind_pragma)))
                {
                    if (node_3.kind == s_Kind_call)
                    {
                        for (int i = 0; i < node_3.items.size(); i++)
                        {
                            const s_SolvedNode& arg = node_3.items[i];
                            if (Lifetime_has_7Yz9ezW2(arg.type.lifetime, locid))
                            {
                                const s_Argument& host_arg = EXT_gDsnGKHT(node_3.target, ss, ctx, module).args[i];
                                if (host_arg.written_to)
                                {
                                    fu::str _0 {};
                                    return (_0 = x7E_3lDd4lqo((addr_and_snippet_gDsnGKHT(node_3.token, s_CodeFmt{}, fu::view<char>{}, ctx, module) + "\n\tAt call to "_fu), str_FDl5ha9X(node_3.target, false, ss, _here, ctx, module, options)), (static_cast<fu::str&&>(_0) + qSTACK_arg_gDsnGKHT(s_Target(node_3.target), i, fu::view<s_Target>{}, s_ArgQuery{}, _current_fn, ss, _helpers, _here, ctx, module, options)));
                                };
                            };
                        };
                    }
                    else if (node_3.kind == s_Kind_pragma)
                    {
                        for (int i = 0; i < node_3.items.size(); i++)
                        {
                            const s_SolvedNode& arg = node_3.items[i];
                            if (is_mutref_9CJmuVSD(arg.type, _here, ctx) && Lifetime_has_7Yz9ezW2(arg.type.lifetime, locid))
                            {
                                return (addr_and_snippet_gDsnGKHT(arg.token, s_CodeFmt{}, fu::view<char>{}, ctx, module) + "\n\tvia pragma "_fu) + qID_e44UlzzA(node_3.value);
                            };
                        };
                    };
                };
            };
            for (int i = node_3.items.size(); i-- > 0; )
                stack += s_SolvedNode(node_3.items[i]);

        };
    };
    return x7E_3lDd4lqo("\n\n\tCOMPILER BUG: RWEvent_stack could not find write to "_fu, str_FDl5ha9X(nested_FDl5ha9X(locid_gDsnGKHT(write), ss, _here, ctx), false, ss, _here, ctx, module, options));
}

                                #ifndef DEF_str_Qjfao9aJpjc
                                #define DEF_str_Qjfao9aJpjc
inline fu::str str_Qjfao9aJ(const s_BorrowCheckPass n)
{
    if (n == s_BorrowCheckPass_BCK_bck)
        return "BCK_bck"_fu;
    else if (n == s_BorrowCheckPass_BCK_aar)
        return "BCK_aar"_fu;
    else if (n == s_BorrowCheckPass_BCK_ooe)
        return "BCK_ooe"_fu;

    return fu::i64dec(int64_t(n));
}
                                #endif

[[noreturn]] static fu::never cannotFailAfterBCK_gDsnGKHT(const fu::str& reason, const s_BorrowCheckPass pass, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (pass == s_BorrowCheckPass_BCK_bck)
    {
        fail_gDsnGKHT(reason, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo(str_Qjfao9aJ(pass), " is trying to emit an error:\n\n\t"_fu) + reason), ss, _helpers, _here, ctx, module, options);

}

static s_Events& events_wyx7msfr(s_CurrentFn& _current_fn)
{
    return _current_fn.events;
}

                                #ifndef DEF_x5Bx5D_RPYpiyw9hV0
                                #define DEF_x5Bx5D_RPYpiyw9hV0
inline static s_Set_2i2v33LNlqd& x5Bx5D_RPYpiyw9(s_LocidMap_OrMuSNs7d4i& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return map._values.mutref((args_neg + locid));
}
                                #endif

static s_Events& events_gDsnGKHT(s_CurrentFn& _current_fn)
{
    return _current_fn.events;
}

static void bck_trackRead_gDsnGKHT(const s_SolvedNode& callsite, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!isLocal_gDsnGKHT(callsite.target)))
    {
        _here = callsite.token;
        int BL_2_v {};
        const int target = (__extension__ (
        {
            const s_Target& t = callsite.target;
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v);
        const int loop_start = (callsite._loop_start ? callsite._loop_start : BUG_gDsnGKHT("bck_trackRead: loop_start not set on callsite."_fu, ss, _helpers, _here, ctx, module, options));
        TEST_varLifetime_gDsnGKHT(callsite.type.lifetime, TODO_FIX_static_ZSTs, target, ss, _helpers, _here, ctx, module, options);
        s_Set_2i2v33LNlqd u { iF_hRiqvWW2(events_iUdwqyBn(_current_fn).snap.invalidated_by, target, _current_fn) };
        if (u)
        {
            if (((pass == s_BorrowCheckPass_BCK_aar) ? !RESOLVE_byAAR_wyx7msfr(fu::vec<s_WriteID>(u.keys_asc), target, true, pass, _current_fn, ss, _helpers, _here, ctx, module, options) : !RESOLVE_byMutvar_FDl5ha9X(target, pass, _current_fn, ss, _helpers, _here, ctx, module, options)))
            {
                const s_WriteID& first = first_28gjKDbX(u.keys_asc);
                fu::str _0 {};
                fu::str _1 {};
                (_1 = (_0 = (x7E_3lDd4lqo(((x7E_3lDd4lqo(("Cannot access"_fu + " "_fu), str_FDl5ha9X(nested_FDl5ha9X(target, ss, _here, ctx), false, ss, _here, ctx, module, options)) + ", reference invalidated by write to"_fu) + " "_fu), str_FDl5ha9X(nested_FDl5ha9X(locid_gDsnGKHT(first), ss, _here, ctx), false, ss, _here, ctx, module, options)) + " at "_fu), (static_cast<fu::str&&>(_0) + RWEvent_stack_gDsnGKHT(first, root, _current_fn, ss, _helpers, _here, ctx, module, options))), cannotFailAfterBCK_gDsnGKHT(static_cast<fu::str&&>(_1), pass, ss, _helpers, _here, ctx, module, options));
            }
            else
            {
                x5Bx5D_RPYpiyw9(events_wyx7msfr(_current_fn).snap.invalidated_by, target, _current_fn) = s_Set_2i2v33LNlqd{};
            };
        };
        if (target < loop_start)
            add_gDsnGKHT(events_gDsnGKHT(_current_fn).used_in_a_loop, target, _current_fn);

    };
}

static fu::view_mut<s_SolvedNode> args_FDl5ha9X(s_SolvedNode& callsite)
{
    return callsite.items;
}

                                #ifndef DEF___4idQYixSz0f
                                #define DEF___4idQYixSz0f
inline static void _4idQYixS(const int i, const s_Argument& host_arg, const bool ooe_isLast, s_SolvedNode& callsite, s_Lifetime& bck_writes, int& num_ref_args, int& pra_first, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if ((pra_first >= 0))
        _current_fn.events.preceding_ref_args.mutref(pra_first).w = i;

    s_SolvedNode& arg = args_FDl5ha9X(callsite).mutref(i);
    bck_node_gDsnGKHT(arg, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (!(!(is_ref_9CJmuVSD(host_arg.type) && is_ref_9CJmuVSD(arg.type))))
    {
        num_ref_args++;
        if (host_arg.written_to)
        {
            if (is_mutref_9CJmuVSD(host_arg.type, _here, ctx))
            {
                if (!(is_mutref_9CJmuVSD(arg.type, _here, ctx)))
                    BUG_gDsnGKHT((qID_e44UlzzA(human_gDsnGKHT(host_arg.name, ss, _here, ctx, module, options)) + ": host_arg.written but !arg.is_mutref"_fu), ss, _helpers, _here, ctx, module, options);

            }
            else
                BUG_gDsnGKHT((qID_e44UlzzA(human_gDsnGKHT(host_arg.name, ss, _here, ctx, module, options)) + ": host_arg.written but !host_arg.is_mutref"_fu), ss, _helpers, _here, ctx, module, options);

            Lifetime_add_7Yz9ezW2(bck_writes, arg.type.lifetime, true, _here, ctx);
        };
        if (!ooe_isLast)
        {
            /*MOV*/ s_SolvedNode pra {};
            pra.kind = s_Kind___preceding_ref_arg;
            const int pra_index = _current_fn.events.preceding_ref_args.size();
            pra.helpers.index = pra_index;
            if (pra_first < 0)
                pra_first = pra_index;

            std::swap(pra, arg);
            _current_fn.events.preceding_ref_args += s_PrecedingRefArg { s_TokenIdx(callsite.token), s_Target(target_FDl5ha9X(callsite)), i, -1, static_cast<s_SolvedNode&&>(pra) };
        };
    };
}
                                #endif

                                #ifndef DEF_argsForward_CvRqzLk2Tl1
                                #define DEF_argsForward_CvRqzLk2Tl1
inline void argsForward_CvRqzLk2(const bool RTL, fu::view<s_Argument> host_args, const int seqIdx_start, s_SolvedNode& callsite, s_Lifetime& bck_writes, int& num_ref_args, int& pra_first, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int seqIdx = 0;
    int lastPass = 1;
    for (int pass_1 = 0; pass_1 < lastPass; pass_1++)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const s_Argument& host_arg = host_args[i];
            if (!!pass_1 != (RTL ? !i : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                lastPass = 2;
            else
            {
                if ((seqIdx_start <= seqIdx))
                    _4idQYixS(i, host_arg, (seqIdx == (host_args.size() - 1)), callsite, bck_writes, num_ref_args, pra_first, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

                seqIdx++;
            };
        };
    };
}
                                #endif

                                #ifndef DEF___duqbsAqwQu1
                                #define DEF___duqbsAqwQu1
inline static void _duqbsAqw(const int locid, int& arg_first, int& arg_last, const int i0)
{
    if (locid)
    {
        arg_first = ((arg_first < 0) ? i0 : arg_first);
        arg_last = i0;
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_faE69Fb7GL4
                                #define DEF_Lifetime_each_faE69Fb7GL4
inline void Lifetime_each_faE69Fb7(const s_Lifetime& lifetime, int& arg_first, int& arg_last, const int i0)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _duqbsAqw(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), arg_first, arg_last, i0);
    };
}
                                #endif

static bool softRiskSafe_gDsnGKHT(const s_SolvedNode& arg, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    return isFieldChain_gDsnGKHT(arg, ss, _here, ctx, module);
}

                                #ifndef DEF___EYPQNVKInk7
                                #define DEF___EYPQNVKInk7
inline static void _EYPQNVKI(const int region1, const int region0, const int i1, const s_Argument& host_arg1, const s_SolvedNode& arg1, const int i0, const s_Argument& host_arg0, const s_SolvedNode& arg0, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!(region1 && (region0 != region1))))
    {
        if (host_arg0.written_to)
            RESOLVE_byAAR_gDsnGKHT(region1, region0, (has_ZwXYCruz(host_arg0.may_alias, i1) ? softRiskSafe_gDsnGKHT(arg1, ss, _here, ctx, module) : false), pass, _current_fn, ss, _helpers, _here, ctx, module, options);

        if (host_arg1.written_to)
            RESOLVE_byAAR_gDsnGKHT(region0, region1, (has_ZwXYCruz(host_arg1.may_alias, i0) ? softRiskSafe_gDsnGKHT(arg0, ss, _here, ctx, module) : false), pass, _current_fn, ss, _helpers, _here, ctx, module, options);

    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_Rb18OvBW1ud
                                #define DEF_Lifetime_each_Rb18OvBW1ud
inline void Lifetime_each_Rb18OvBW(const s_Lifetime& lifetime, const int region0, const int i1, const s_Argument& host_arg1, const s_SolvedNode& arg1, const int i0, const s_Argument& host_arg0, const s_SolvedNode& arg0, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _EYPQNVKI(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), region0, i1, host_arg1, arg1, i0, host_arg0, arg0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF___tmoTa3UAHb5
                                #define DEF___tmoTa3UAHb5
inline static void _tmoTa3UA(const int region0, const int i1, const s_Argument& host_arg1, const s_SolvedNode& arg1, const s_Lifetime& shallow1, const int i0, const s_Argument& host_arg0, const s_SolvedNode& arg0, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!region0))
    {
        Lifetime_each_Rb18OvBW(shallow1, region0, i1, host_arg1, arg1, i0, host_arg0, arg0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_eYp556B2PH3
                                #define DEF_Lifetime_each_eYp556B2PH3
inline void Lifetime_each_eYp556B2(const s_Lifetime& lifetime, const int i1, const s_Argument& host_arg1, const s_SolvedNode& arg1, const s_Lifetime& shallow1, const int i0, const s_Argument& host_arg0, const s_SolvedNode& arg0, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _tmoTa3UA(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), i1, host_arg1, arg1, shallow1, i0, host_arg0, arg0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_SR_empty
                                #define DEF_SR_empty
extern const fu::str SR_empty;
                                #endif

                                #ifndef DEF___tTLW15MuyTe
                                #define DEF___tTLW15MuyTe
inline static void _tTLW15Mu(fu::vec<s_SubRegion>& path)
{
    path.clear();
}
                                #endif

                                #ifndef DEF___RJQTFKH3d5k
                                #define DEF___RJQTFKH3d5k
inline static void _RJQTFKH3(const int flatCount, const int flatOffset, fu::vec<s_SubRegion>& path)
{
    path += s_SubRegion { flatCount, flatOffset };
}
                                #endif

static void TEST_verifyUsageBitRanges_FDl5ha9X(const s_SubRegion& a, const s_RWQuals& rw, const s_TokenIdx& _here, const s_Context& ctx)
{
    const unsigned range = getRegionUsage_CaGDtmWo(a.flatOffset, a.flatCount);
    if (!(((range & rw.usage) == rw.usage) && (range & rw.usage) && ((rw.written_to & rw.usage) == rw.written_to)))
        BUG_u9Gbkniv((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("range("_fu, fu::u64dec(range)) + ") rw.usage("_fu), fu::u64dec(rw.usage)) + ") rw.written_to("_fu), fu::u64dec(rw.written_to)) + ")"_fu), _here, ctx);

}

                                #ifndef DEF_Paths_hasInter_hFfDhxjbbSg
                                #define DEF_Paths_hasInter_hFfDhxjbbSg
inline static bool Paths_hasInter_hFfDhxjb(fu::view<char> a, fu::view<char> b, const s_RWQuals& rw_left, const s_RWQuals& rw_right, const s_TokenIdx& _here, const s_Context& ctx)
{

    {
        fu::vec<s_SubRegion> path {};
        int _o = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            _tTLW15Mu(path);
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(a, _o);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(a, _o) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                _RJQTFKH3(flatCount, flatOffset, path);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };

            {
                fu::view<s_SubRegion> a_path = path;
                fu::vec<s_SubRegion> path_1 {};
                int _o_1 = 0;
                for (; ; )
                {
                    bool isLastPath_1 = false;
                    bool isFirstSubRegion_1 = true;
                    _tTLW15Mu(path_1);
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(b, _o_1);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(b, _o_1) : 3u);
                        isLastPath_1 = !(raw_flatCount & 1u);
                        const int flatCount = int((raw_flatCount >> 1u));
                        const int flatOffset = int((raw_flatOffset >> 1u));
                        _RJQTFKH3(flatCount, flatOffset, path_1);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion_1 = false;

                    };

                    { {
                        fu::view<s_SubRegion> b_path = path_1;
                        const int N = min_O25D0jcU(a_path.size(), b_path.size());
                        s_SubRegion a_1 {};
                        s_SubRegion b_1 {};
                        for (int i = 0; i < N; i++)
                        {
                            a_1 = a_path[i];
                            b_1 = b_path[i];
                            const int overlap = min_O25D0jcU(((b_1.flatOffset + b_1.flatCount) - a_1.flatOffset), ((a_1.flatOffset + a_1.flatCount) - b_1.flatOffset));
                            if ((overlap <= 0))
                                goto BL_15;

                        };
                        s_RWQuals abs_left {};
                        if ((a_path.size() <= b_path.size()))
                        {
                            abs_left = USAGE_structUsageFromFieldUsage_z5tFO59K(rw_left, a_1.flatOffset);
                            TEST_verifyUsageBitRanges_FDl5ha9X(a_1, abs_left, _here, ctx);
                            const s_SubRegion& a_2 = b_1;
                            const unsigned rw = (rw_right.written_to ? abs_left.usage : abs_left.written_to);
                            const unsigned range = getRegionUsage_CaGDtmWo(a_2.flatOffset, a_2.flatCount);
                            if (!(range & rw))
                                goto BL_15;

                        };
                        if ((b_path.size() <= a_path.size()))
                        {
                            const s_RWQuals abs_right = USAGE_structUsageFromFieldUsage_z5tFO59K(rw_right, b_1.flatOffset);
                            TEST_verifyUsageBitRanges_FDl5ha9X(b_1, abs_right, _here, ctx);

                            {
                                const s_SubRegion& a_2 = a_1;
                                const unsigned rw = (rw_left.written_to ? abs_right.usage : abs_right.written_to);
                                const unsigned range = getRegionUsage_CaGDtmWo(a_2.flatOffset, a_2.flatCount);
                                if (!(range & rw))
                                    goto BL_15;

                            };
                            if (b_path.size() == a_path.size())
                            {
                                if (!((abs_right.written_to & abs_left.usage) || (abs_left.written_to & abs_right.usage)))
                                    goto BL_15;

                            };
                        };
                        return true;
                      } BL_15:;
                    };
                    if (isLastPath_1)
                        break;

                };
                if (!(_o_1 == b.size()))
                    BUG_u9Gbkniv("walkPaths(!tailOK): excess bytes"_fu, _here, ctx);

            };
            if (isLastPath)
                break;

        };
        if (!(_o == a.size()))
            BUG_u9Gbkniv("walkPaths(!tailOK): excess bytes"_fu, _here, ctx);

    };
    return false;
}
                                #endif

                                #ifndef DEF_Lifetime_hasInter_SNOY04NKaq6
                                #define DEF_Lifetime_hasInter_SNOY04NKaq6
inline bool Lifetime_hasInter_SNOY04NK(const s_Lifetime& a, const s_Lifetime& b, const s_RWQuals& rw_left, const s_RWQuals& rw_right, const s_TokenIdx& _here, const s_Context& ctx)
{
    // Hoisted:
    int offset0;
    int offset0_1;

    if (!(rw_left.written_to || rw_right.written_to))
        return false;
    else
    {

        { {
            fu::view<char> l_chars = a.uni0n;
            fu::view<char> r_chars = b.uni0n;
            int l_start {};
            int r_start {};
            int l_paths0 {};
            int r_paths0 {};
            int l_offset {};
            int r_offset {};
            unsigned l {};
            unsigned r {};
            bool l_dirty = true;
            bool r_dirty = true;
            const bool l_done = false;
            const bool r_done = false;
            for (; ; )
            {
                if (l_dirty)
                {
                    l_dirty = false;
                    l_start = l_offset;
                    if (l_offset < l_chars.size())
                    {
                        l = parse7bit(l_chars, l_offset);
                        int BL_8_v {};
                        l_paths0 = (__extension__ (
                        {
                            offset0 = (l_offset + 0);
                            for (; ; )
                            {
                                bool isLastPath = false;
                                bool isFirstSubRegion = true;
                                for (; ; )
                                {
                                    const unsigned raw_flatOffset = parse7bit(l_chars, l_offset);
                                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(l_chars, l_offset) : 3u);
                                    isLastPath = !(raw_flatCount & 1u);
                                    if (isLastSubRegion)
                                        break;
                                    else
                                        isFirstSubRegion = false;

                                };
                                if (isLastPath)
                                    break;

                            };
                            BL_8_v = (offset0);
                        (void)0;}), BL_8_v);
                    }
                    else
                        goto BL_3;

                };
                if (r_dirty)
                {
                    r_dirty = false;
                    r_start = r_offset;
                    if (r_offset < r_chars.size())
                    {
                        r = parse7bit(r_chars, r_offset);
                        int BL_19_v {};
                        r_paths0 = (__extension__ (
                        {
                            offset0_1 = (r_offset + 0);
                            for (; ; )
                            {
                                bool isLastPath_1 = false;
                                bool isFirstSubRegion_1 = true;
                                for (; ; )
                                {
                                    const unsigned raw_flatOffset_1 = parse7bit(r_chars, r_offset);
                                    const bool isLastSubRegion_1 = !(raw_flatOffset_1 & 1u);
                                    const unsigned raw_flatCount_1 = (isLastSubRegion_1 ? parse7bit(r_chars, r_offset) : 3u);
                                    isLastPath_1 = !(raw_flatCount_1 & 1u);
                                    if (isLastSubRegion_1)
                                        break;
                                    else
                                        isFirstSubRegion_1 = false;

                                };
                                if (isLastPath_1)
                                    break;

                            };
                            BL_19_v = (offset0_1);
                        (void)0;}), BL_19_v);
                    }
                    else
                        goto BL_3;

                };
                fu::never BL_28_v {};
                bool BL_29_v {};
                bool BL_30_v {};
                bool BL_31_v {};
                bool BL_32_v {};
                bool BL_33_v {};
                bool BL_34_v {};
                const int cmp = (l_done ? (r_done ? (__extension__ (
                {
                    goto BL_3;
                (void)0;}), static_cast<fu::never&&>(BL_28_v)) : +1) : (r_done ? -1 : (((__extension__ (
                {
                    const unsigned r_1 = l;
                    BL_29_v = (((r_1 & 11u) == 1u));
                (void)0;}), BL_29_v) != (__extension__ (
                {
                    const unsigned r_2 = r;
                    BL_30_v = (((r_2 & 11u) == 1u));
                (void)0;}), BL_30_v)) ? ((__extension__ (
                {
                    const unsigned r_3 = r;
                    BL_31_v = (((r_3 & 11u) == 1u));
                (void)0;}), BL_31_v) ? -1 : +1) : (((__extension__ (
                {
                    const unsigned r_4 = l;
                    BL_32_v = ((r_4 == 0b1001u));
                (void)0;}), BL_32_v) != (__extension__ (
                {
                    const unsigned r_5 = r;
                    BL_33_v = ((r_5 == 0b1001u));
                (void)0;}), BL_33_v)) ? ((__extension__ (
                {
                    const unsigned r_6 = r;
                    BL_34_v = ((r_6 == 0b1001u));
                (void)0;}), BL_34_v) ? +1 : -1) : (((l & 3u) == 2u) ? (((r & 3u) == 2u) ? x3Cx3E_F82w14kI(l, r) : +1) : (((r & 3u) == 2u) ? -1 : x3Cx3E_F82w14kI(r, l)))))));
                if (cmp == 0)
                {
                    l_dirty = true;
                    r_dirty = true;
                    fu::view<char> sr_left = fu::get_view(l_chars, l_paths0, l_offset);
                    fu::view<char> sr_right = fu::get_view(r_chars, r_paths0, r_offset);
                    if (((sr_left == sr_right) ? !!((rw_left.written_to & rw_right.usage) || (rw_right.written_to & rw_left.usage)) : ((sr_left == SR_empty) || (sr_right == SR_empty) || Paths_hasInter_hFfDhxjb(sr_left, sr_right, rw_left, rw_right, _here, ctx))))
                        return true;

                }
                else if (cmp < 0)
                    l_dirty = true;
                else
                    r_dirty = true;

            };
          } BL_3:;
        };
        return false;
    };
}
                                #endif

static const s_Flow& flow_wyx7msfr(const s_CurrentFn& _current_fn)
{
    return _current_fn.flow;
}

                                #ifndef DEF_Paths_hasInter_1Eirzmpyg61
                                #define DEF_Paths_hasInter_1Eirzmpyg61
inline static bool Paths_hasInter_1Eirzmpy(fu::view<char> a, fu::view<char> b, const s_TokenIdx& _here, const s_Context& ctx)
{

    {
        fu::vec<s_SubRegion> path {};
        int _o = 0;
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            _tTLW15Mu(path);
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(a, _o);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(a, _o) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                const int flatCount = int((raw_flatCount >> 1u));
                const int flatOffset = int((raw_flatOffset >> 1u));
                _RJQTFKH3(flatCount, flatOffset, path);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };

            {
                fu::view<s_SubRegion> a_path = path;
                fu::vec<s_SubRegion> path_1 {};
                int _o_1 = 0;
                for (; ; )
                {
                    bool isLastPath_1 = false;
                    bool isFirstSubRegion_1 = true;
                    _tTLW15Mu(path_1);
                    for (; ; )
                    {
                        const unsigned raw_flatOffset = parse7bit(b, _o_1);
                        const bool isLastSubRegion = !(raw_flatOffset & 1u);
                        const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(b, _o_1) : 3u);
                        isLastPath_1 = !(raw_flatCount & 1u);
                        const int flatCount = int((raw_flatCount >> 1u));
                        const int flatOffset = int((raw_flatOffset >> 1u));
                        _RJQTFKH3(flatCount, flatOffset, path_1);
                        if (isLastSubRegion)
                            break;
                        else
                            isFirstSubRegion_1 = false;

                    };

                    { {
                        fu::view<s_SubRegion> b_path = path_1;
                        const int N = min_O25D0jcU(a_path.size(), b_path.size());
                        s_SubRegion a_1 {};
                        s_SubRegion b_1 {};
                        for (int i = 0; i < N; i++)
                        {
                            a_1 = a_path[i];
                            b_1 = b_path[i];
                            const int overlap = min_O25D0jcU(((b_1.flatOffset + b_1.flatCount) - a_1.flatOffset), ((a_1.flatOffset + a_1.flatCount) - b_1.flatOffset));
                            if ((overlap <= 0))
                                goto BL_15;

                        };
                        return true;
                      } BL_15:;
                    };
                    if (isLastPath_1)
                        break;

                };
                if (!(_o_1 == b.size()))
                    BUG_u9Gbkniv("walkPaths(!tailOK): excess bytes"_fu, _here, ctx);

            };
            if (isLastPath)
                break;

        };
        if (!(_o == a.size()))
            BUG_u9Gbkniv("walkPaths(!tailOK): excess bytes"_fu, _here, ctx);

    };
    return false;
}
                                #endif

                                #ifndef DEF_Lifetime_hasInter_bMCR56A24Fe
                                #define DEF_Lifetime_hasInter_bMCR56A24Fe
inline bool Lifetime_hasInter_bMCR56A2(const s_Lifetime& a, const s_Lifetime& b, const s_TokenIdx& _here, const s_Context& ctx)
{
    // Hoisted:
    int offset0;
    int offset0_1;


    { {
        fu::view<char> l_chars = a.uni0n;
        fu::view<char> r_chars = b.uni0n;
        int l_start {};
        int r_start {};
        int l_paths0 {};
        int r_paths0 {};
        int l_offset {};
        int r_offset {};
        unsigned l {};
        unsigned r {};
        bool l_dirty = true;
        bool r_dirty = true;
        const bool l_done = false;
        const bool r_done = false;
        for (; ; )
        {
            if (l_dirty)
            {
                l_dirty = false;
                l_start = l_offset;
                if (l_offset < l_chars.size())
                {
                    l = parse7bit(l_chars, l_offset);
                    int BL_6_v {};
                    l_paths0 = (__extension__ (
                    {
                        offset0 = (l_offset + 0);
                        for (; ; )
                        {
                            bool isLastPath = false;
                            bool isFirstSubRegion = true;
                            for (; ; )
                            {
                                const unsigned raw_flatOffset = parse7bit(l_chars, l_offset);
                                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(l_chars, l_offset) : 3u);
                                isLastPath = !(raw_flatCount & 1u);
                                if (isLastSubRegion)
                                    break;
                                else
                                    isFirstSubRegion = false;

                            };
                            if (isLastPath)
                                break;

                        };
                        BL_6_v = (offset0);
                    (void)0;}), BL_6_v);
                }
                else
                    goto BL_1;

            };
            if (r_dirty)
            {
                r_dirty = false;
                r_start = r_offset;
                if (r_offset < r_chars.size())
                {
                    r = parse7bit(r_chars, r_offset);
                    int BL_17_v {};
                    r_paths0 = (__extension__ (
                    {
                        offset0_1 = (r_offset + 0);
                        for (; ; )
                        {
                            bool isLastPath_1 = false;
                            bool isFirstSubRegion_1 = true;
                            for (; ; )
                            {
                                const unsigned raw_flatOffset_1 = parse7bit(r_chars, r_offset);
                                const bool isLastSubRegion_1 = !(raw_flatOffset_1 & 1u);
                                const unsigned raw_flatCount_1 = (isLastSubRegion_1 ? parse7bit(r_chars, r_offset) : 3u);
                                isLastPath_1 = !(raw_flatCount_1 & 1u);
                                if (isLastSubRegion_1)
                                    break;
                                else
                                    isFirstSubRegion_1 = false;

                            };
                            if (isLastPath_1)
                                break;

                        };
                        BL_17_v = (offset0_1);
                    (void)0;}), BL_17_v);
                }
                else
                    goto BL_1;

            };
            fu::never BL_26_v {};
            bool BL_27_v {};
            bool BL_28_v {};
            bool BL_29_v {};
            bool BL_30_v {};
            bool BL_31_v {};
            bool BL_32_v {};
            const int cmp = (l_done ? (r_done ? (__extension__ (
            {
                goto BL_1;
            (void)0;}), static_cast<fu::never&&>(BL_26_v)) : +1) : (r_done ? -1 : (((__extension__ (
            {
                const unsigned r_1 = l;
                BL_27_v = (((r_1 & 11u) == 1u));
            (void)0;}), BL_27_v) != (__extension__ (
            {
                const unsigned r_2 = r;
                BL_28_v = (((r_2 & 11u) == 1u));
            (void)0;}), BL_28_v)) ? ((__extension__ (
            {
                const unsigned r_3 = r;
                BL_29_v = (((r_3 & 11u) == 1u));
            (void)0;}), BL_29_v) ? -1 : +1) : (((__extension__ (
            {
                const unsigned r_4 = l;
                BL_30_v = ((r_4 == 0b1001u));
            (void)0;}), BL_30_v) != (__extension__ (
            {
                const unsigned r_5 = r;
                BL_31_v = ((r_5 == 0b1001u));
            (void)0;}), BL_31_v)) ? ((__extension__ (
            {
                const unsigned r_6 = r;
                BL_32_v = ((r_6 == 0b1001u));
            (void)0;}), BL_32_v) ? +1 : -1) : (((l & 3u) == 2u) ? (((r & 3u) == 2u) ? x3Cx3E_F82w14kI(l, r) : +1) : (((r & 3u) == 2u) ? -1 : x3Cx3E_F82w14kI(r, l)))))));
            if (cmp == 0)
            {
                l_dirty = true;
                r_dirty = true;
                fu::view<char> sr_left = fu::get_view(l_chars, l_paths0, l_offset);
                fu::view<char> sr_right = fu::get_view(r_chars, r_paths0, r_offset);
                if (((sr_left == sr_right) ? true : ((sr_left == SR_empty) || (sr_right == SR_empty) || Paths_hasInter_1Eirzmpy(sr_left, sr_right, _here, ctx))))
                    return true;

            }
            else if (cmp < 0)
                l_dirty = true;
            else
                r_dirty = true;

        };
      } BL_1:;
    };
    return false;
}
                                #endif

static bool isInvalidatedBy_gDsnGKHT(const s_Lifetime& read, const s_Lifetime& write, const s_CurrentFn& _current_fn, const s_TokenIdx& _here, const s_Context& ctx)
{

    {
        fu::view<char> chars = write.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            if (locid && Lifetime_hasInter_bMCR56A2(read, iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_invalidates, locid, _current_fn), _here, ctx))
                return true;

        };
    };
    return false;
}

                                #ifndef DEF___jEi7lUFXzra
                                #define DEF___jEi7lUFXzra
inline static bool _jEi7lUFX(const int locid, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (locid)
        return !(GET_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _here, ctx, module).flags & s_Flags_F_INJECTED);
    else
        return false;

}
                                #endif

                                #ifndef DEF_Lifetime_some_qICM3mkpWH9
                                #define DEF_Lifetime_some_qICM3mkpWH9
inline bool Lifetime_some_qICM3mkp(const s_Lifetime& lifetime, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{

    {
        fu::view<char> chars = lifetime.uni0n;
        int offset = 0;
        while (offset < chars.size())
        {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            int BL_11_v {};
            const int locid = ((r & 1u) ? 0 : (__extension__ (
            {
                const unsigned v = (r >> 1u);
                BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_11_v));
            if (_jEi7lUFX(locid, ss, _here, ctx, module))
                return true;

        };
    };
    return false;
}
                                #endif

static s_ArgRationale requireVal_gDsnGKHT(const s_Argument& other, const s_SolvedNode& other_arg, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (!(other.flags & s_Flags_F_INJECTED) || !Lifetime_some_qICM3mkp(other_arg.type.lifetime, ss, _here, ctx, module))
    {
        return s_ArgRationale{};
    }
    else
        return s_ArgRationale_RequireVal_AliasesMutatedInjectedArgument;

}

static bool RESOLVE_byMutvar_gDsnGKHT(const s_Target& target, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v))
    {
        int BL_3_v {};
        return RESOLVE_byMutvar_FDl5ha9X((__extension__ (
        {
            const unsigned v = unsigned((target._packed & 0xfffffull));
            BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_3_v), pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else
        return false;

}

static s_ArgRationale RESOLVE_byTempCopy_FDl5ha9X(s_SolvedNode& arg, const s_Target& target, const int position, const fu::str& debug, const s_ArgRationale requireVal, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (pass == s_BorrowCheckPass_BCK_bck)
    {
        if (_current_fn.asserts & s_DeclAsserts_A_FAST)
            return s_ArgRationale_CantTempCopy_FastFn;
        else
        {
            fu::view<s_Argument> host_args = EXT_gDsnGKHT(target, ss, ctx, module).args;
            const s_Argument& host_arg = host_args[position];
            if (!is_rx_copy_9CJmuVSD(arg.type.vtype))
                return s_ArgRationale_CantTempCopy_NonCopiable;
            else if ((arg.kind == s_Kind_call) && RESOLVE_byMutvar_gDsnGKHT(arg.target, pass, _current_fn, ss, _helpers, _here, ctx, module, options))
            {
                return s_ArgRationale{};
            }
            else
            {
                const s_ArgRationale r = rejectsTempCopies_gDsnGKHT(host_arg, requireVal, _here, ctx);
                if (r)
                    return r;
                else if (host_arg.flags & s_Flags_F_LT_RETURNED)
                    return s_ArgRationale_CantTempCopy_ReturnedFromFn;
                else
                {
                    const s_Type& slot = host_args[position].type;
                    s_Type slot_1 = make_copyable_9CJmuVSD(clear_refs_9CJmuVSD(s_Type(slot)));
                    maybeCopyOrMove_gDsnGKHT(arg, slot_1, false, debug, _current_fn, ss, _helpers, _here, ctx, module, options);
                    return s_ArgRationale{};
                };
            };
        };
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}

static s_ArgRationale RESOLVE_byTempCopy_gDsnGKHT(s_SolvedNode& callsite, const int position, const fu::str& debug, const s_ArgRationale requireVal, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Target& target = callsite.target;
    s_SolvedNode& arg = callsite.items.mutref(position);
    return RESOLVE_byTempCopy_FDl5ha9X(arg, target, position, debug, requireVal, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF___UgEkaRQH4m1
                                #define DEF___UgEkaRQH4m1
inline static fu::view<char> _UgEkaRQH(const int locid, fu::str& err, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return (err += ("\n\t    "_fu + explainWhichFn_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options)));
}
                                #endif

                                #ifndef DEF_each_Uffb4q6qL93
                                #define DEF_each_Uffb4q6qL93
inline void each_Uffb4q6q(fu::view<int> a, fu::str& err, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
        _UgEkaRQH(a[i], err, _current_fn, ss, _here, ctx, module, options);

}
                                #endif

static fu::str ArgRationale_explain_gDsnGKHT(const s_ArgRationale r, const s_Target& callee, const s_SolvedNode& arg, const s_Argument& host_arg, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (r == s_ArgRationale_CantTempCopy_FastFn)
        return "Temporary copies not allowed in fast fns."_fu;
    else if (r == s_ArgRationale_CantTempCopy_NonCopiable)
        return x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " is non-copyable: "_fu) + explainType_gDsnGKHT(arg.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options);
    else if (r == s_ArgRationale_CantTempCopy_HostArg_Ref)
        return x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " is "_fu) + qBAD_e44UlzzA("ref"_fu);
    else if (r == s_ArgRationale_CantTempCopy_HostArg_Implicit)
        return x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " is "_fu) + qBAD_e44UlzzA("implicit"_fu);
    else if (r == s_ArgRationale_CantTempCopy_HostArg_MutRef)
        return x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " is a mutref: "_fu) + explainType_gDsnGKHT(arg.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options);
    else if (r == s_ArgRationale_CantTempCopy_ReturnedFromFn)
        return x7E_3lDd4lqo(x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " is ref-returned from "_fu), str_FDl5ha9X(callee, false, ss, _here, ctx, module, options));
    else if (r == s_ArgRationale_RequireVal_AliasesMutatedInjectedArgument)
    {
        return x7E_3lDd4lqo(((((((((((((((x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " needs an explicit "_fu) + qKW_e44UlzzA("ref"_fu)) + " or "_fu) + qKW_e44UlzzA("val"_fu)) + " for disambiguation:"_fu) + "\n\n\t\t- Use "_fu) + qKW_e44UlzzA("ref"_fu)) + " if you want "_fu) + str_wyx7msfr(host_arg, true, _current_fn, ss, _here, ctx, module, options)) + " to reflect changes made to the aliased injected arg."_fu) + "\n\n\t\t- Use "_fu) + qKW_e44UlzzA("val"_fu)) + " if you want "_fu) + str_wyx7msfr(host_arg, true, _current_fn, ss, _here, ctx, module, options)) + " to remain constant throughout "_fu), str_FDl5ha9X(callee, false, ss, _here, ctx, module, options));
    }
    else
        BUG_gDsnGKHT("Unknown reason."_fu, ss, _helpers, _here, ctx, module, options);

}

static void validate_gDsnGKHT(const int i1, s_SolvedNode& callsite, fu::view<s_Argument> host_args, fu::view<s_Lifetime> bck_unwound, const int arg_first, const int arg_last, const int i0, const s_Argument& host_arg0, const s_SolvedNode& arg0, const s_Lifetime& shallow0, const s_Lifetime& unwound0, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Argument& host_arg1 = host_args[i1];
    if (!(has_ZwXYCruz(host_arg0.may_invalidate, i1) && has_ZwXYCruz(host_arg1.may_invalidate, i0)))
    {
        s_SolvedNode BL_2_v {};
        s_SolvedNode arg1 = (__extension__ (
        {
            const s_SolvedNode& __partcopy_ref = args_iUdwqyBn(callsite)[i1];
            BL_2_v = (s_SolvedNode { __partcopy_ref.kind, {}, {}, {}, {}, fu::vec<s_SolvedNode>(__partcopy_ref.items), {}, s_Type(__partcopy_ref.type), s_Target(__partcopy_ref.target) });
        (void)0;}), static_cast<s_SolvedNode&&>(BL_2_v));
        const s_Lifetime& shallow1 = arg1.type.lifetime;
        if (pass == s_BorrowCheckPass_BCK_aar)
        {
            if ((i0 >= arg_first) && (i0 <= arg_last) && (i1 >= arg_first) && (i1 <= arg_last))
            {
                Lifetime_each_eYp556B2(shallow0, i1, host_arg1, arg1, shallow1, i0, host_arg0, arg0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            const s_Lifetime& unwound1 = bck_unwound[i1];
            unsigned BL_6_v {};
            unsigned BL_7_v {};
            unsigned BL_8_v {};
            unsigned BL_9_v {};
            if (((__extension__ (
            {
                const s_ValueType& type = host_arg0.type.vtype;
                BL_6_v = ((type.quals & q_USAGE));
            (void)0;}), BL_6_v) == (__extension__ (
            {
                const s_ValueType& type = arg0.type.vtype;
                BL_7_v = ((type.quals & q_USAGE));
            (void)0;}), BL_7_v)) && ((__extension__ (
            {
                const s_ValueType& type = host_arg1.type.vtype;
                BL_8_v = ((type.quals & q_USAGE));
            (void)0;}), BL_8_v) == (__extension__ (
            {
                const s_ValueType& type = arg1.type.vtype;
                BL_9_v = ((type.quals & q_USAGE));
            (void)0;}), BL_9_v)))
            {
                unsigned BL_11_v {};
                unsigned BL_12_v {};
                if (!(!Lifetime_hasInter_SNOY04NK(unwound0, unwound1, s_RWQuals { (__extension__ (
                {
                    const s_ValueType& type = host_arg0.type.vtype;
                    BL_11_v = ((type.quals & q_USAGE));
                (void)0;}), BL_11_v), host_arg0.written_to }, s_RWQuals { (__extension__ (
                {
                    const s_ValueType& type = host_arg1.type.vtype;
                    BL_12_v = ((type.quals & q_USAGE));
                (void)0;}), BL_12_v), host_arg1.written_to }, _here, ctx)))
                {
                    if (has_ZwXYCruz(host_arg0.may_alias, i1) && has_ZwXYCruz(host_arg1.may_alias, i0))
                    {
                        if ((has_ZwXYCruz(host_arg0.may_invalidate, i1) || (softRiskSafe_gDsnGKHT(arg1, ss, _here, ctx, module) && !isInvalidatedBy_gDsnGKHT(shallow1, shallow0, _current_fn, _here, ctx))) && (has_ZwXYCruz(host_arg1.may_invalidate, i0) || (softRiskSafe_gDsnGKHT(arg0, ss, _here, ctx, module) && !isInvalidatedBy_gDsnGKHT(shallow0, shallow1, _current_fn, _here, ctx))))
                        {

                            {
                                const s_SolverNotes note = s_SolverNotes_N_AARSoftRisk;
                                if (note & options.break_notes)
                                {
                                    fu::view<char> reason = fu::view<char>{};
                                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                }
                                else
                                    ss._notes |= note;

                            };
                            return;
                        };
                    };
                    s_ArgRationale noTempCopy0 {};
                    s_ArgRationale noTempCopy1 {};
                    if ((noTempCopy0 = RESOLVE_byTempCopy_gDsnGKHT(callsite, i0, x7E_3lDd4lqo("bck:vi "_fu, fu::i64dec(i1)), requireVal_gDsnGKHT(host_arg1, arg1, ss, _here, ctx, module), pass, _current_fn, ss, _helpers, _here, ctx, module, options)) && (noTempCopy1 = RESOLVE_byTempCopy_gDsnGKHT(callsite, i1, x7E_3lDd4lqo("bck:vi "_fu, fu::i64dec(i0)), requireVal_gDsnGKHT(host_arg0, arg0, ss, _here, ctx, module), pass, _current_fn, ss, _helpers, _here, ctx, module, options)))
                    {
                        fu::str err = ("At call to "_fu + str_FDl5ha9X(target_FDl5ha9X(callsite), false, ss, _here, ctx, module, options));
                        err += (((host_args.size() == 2) && (GET_gDsnGKHT(target_FDl5ha9X(callsite), ss, _here, ctx, module).flags & s_Flags_F_OPERATOR)) ? ", both operands alias:\n"_fu : (x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo(", arguments:\n\n\t    "_fu, fu::i64dec((i0 + 1))) + ":\t"_fu), str_wyx7msfr(host_arg0, false, _current_fn, ss, _here, ctx, module, options)) + " and\n\t    "_fu), fu::i64dec((i1 + 1))) + ":\t"_fu), str_wyx7msfr(host_arg1, false, _current_fn, ss, _here, ctx, module, options)) + "\n\n\t    both alias:\n"_fu));
                        each_Uffb4q6q(Lifetime_interLocids_7Yz9ezW2(unwound0, unwound1, _here, ctx), err, _current_fn, ss, _here, ctx, module, options);
                        fu::str noTempCopy0_1 = ArgRationale_explain_gDsnGKHT(noTempCopy0, target_FDl5ha9X(callsite), arg0, host_arg0, _current_fn, ss, _helpers, _here, ctx, module, options);
                        fu::str noTempCopy1_1 = ArgRationale_explain_gDsnGKHT(noTempCopy1, target_FDl5ha9X(callsite), arg1, host_arg1, _current_fn, ss, _helpers, _here, ctx, module, options);
                        err += "\n\tCannot resolve aliasing by a temporary copy:"_fu;
                        err += ("\n\n\t    "_fu + noTempCopy0_1);
                        if (noTempCopy0_1 != noTempCopy1_1)
                            err += ("\n\n\t    "_fu + noTempCopy1_1);

                        _here = args_iUdwqyBn(callsite)[i0].token;
                        cannotFailAfterBCK_gDsnGKHT(err, pass, ss, _helpers, _here, ctx, module, options);
                    };
                };
            }
            else
                BUG_gDsnGKHT("host_arg/arg.usage mismatch"_fu, ss, _helpers, _here, ctx, module, options);

        };
    };
}

static void visit_zxrjol4Z(const s_Lifetime& lifetime, s_Lifetime& result, const bool maybeOutOfOrder, const s_Lifetime& all_written, const s_CurrentFn& _current_fn, const s_TokenIdx& _here, const s_Context& ctx)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                int BL_12_v {};
                const int locid = ((r & 1u) ? 0 : (__extension__ (
                {
                    const unsigned v = (r >> 1u);
                    BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_12_v));
                const s_Lifetime& parents = iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_parents, locid, _current_fn);
                if (Lifetime_hasInter_bMCR56A2(parents, all_written, _here, ctx))
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_cCyqKtXddag
                                #define DEF_Lifetime_process_cCyqKtXddag
inline s_Lifetime Lifetime_process_cCyqKtXd(const s_Lifetime& lifetime, const s_Lifetime& all_written, const s_CurrentFn& _current_fn, const s_TokenIdx& _here, const s_Context& ctx)
{
    /*MOV*/ s_Lifetime result {};
    const bool maybeOutOfOrder = false;
    visit_zxrjol4Z(lifetime, result, maybeOutOfOrder, all_written, _current_fn, _here, ctx);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF___lDYQfNSiCgg
                                #define DEF___lDYQfNSiCgg
inline static int _lDYQfNSi(const s_Postdom& _)
{
    return _.write_loop_start;
}
                                #endif

                                #ifndef DEF___PPmVSDaKfNa
                                #define DEF___PPmVSDaKfNa
inline static fu::view<int> _PPmVSDaK(const int loop_id, fu::vec<int>& loop_ids)
{
    return (loop_ids += loop_id);
}
                                #endif

                                #ifndef DEF_eachLoopStart_nJvHNWHJ0o3
                                #define DEF_eachLoopStart_nJvHNWHJ0o3
inline static void eachLoopStart_nJvHNWHJ(int search, fu::vec<int>& loop_ids, const s_SolverState& ss)
{
    for (int i = ss._helpers_data.size(); i-- > 0; )
    {
        const s_HelpersData& h = ss._helpers_data[i];
        if (h.locals_start == search)
        {
            const int parent = _lDYQfNSi(h.postdom);
            _PPmVSDaK(search, loop_ids);
            search = parent;
        };
    };
}
                                #endif

                                #ifndef DEF___JXvzsPjXFck
                                #define DEF___JXvzsPjXFck
inline static int _JXvzsPjX(const s_Postdom& _)
{
    return _.read_loop_start;
}
                                #endif

static bool checkReadLoopStart_gDsnGKHT(const int read_loop_start, fu::view<int> loop_ids, const s_SolverState& ss)
{

    {
        int search = read_loop_start;
        for (int i = ss._helpers_data.size(); i-- > 0; )
        {
            const s_HelpersData& h = ss._helpers_data[i];
            if (h.locals_start == search)
            {
                const int parent = _JXvzsPjX(h.postdom);

                {
                    const int loop_id = search;
                    if (has_4AEOmDQr(loop_ids, loop_id))
                        return true;

                };
                search = parent;
            };
        };
    };
    return false;
}

                                #ifndef DEF___1AXfSSx3eQ1
                                #define DEF___1AXfSSx3eQ1
inline static bool _1AXfSSx3(const s_SolvedNode& node, const int read, fu::view<int> loop_ids, const s_SolverState& ss)
{
    int BL_1_v {};
    if ((node.kind == s_Kind_call) && isLocal_gDsnGKHT(node.target) && ((__extension__ (
    {
        const s_Target& t = node.target;
        const unsigned v = unsigned((t._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v) == read))
        return checkReadLoopStart_gDsnGKHT(node._loop_start, loop_ids, ss);
    else
        return false;

}
                                #endif

                                #ifndef DEF_SLOW_find_QHBo9ZEhHsf
                                #define DEF_SLOW_find_QHBo9ZEhHsf
inline static s_SolvedNode SLOW_find_QHBo9ZEh(const int read, fu::view<int> loop_ids, const s_SolvedNode& root, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{

    {
        const s_SolvedNode& node = root;
        fu::vec<s_SolvedNode> stack = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(node) } };
        while (stack)
        {
            s_SolvedNode node_1 = TODO_FIX_pop_08mGYIdw(stack);
            const s_SolvedNode& node_2 = ((node_1.kind == s_Kind_letdef) ? GET_gDsnGKHT(node_1.target, ss, _here, ctx, module).solved : node_1);
            const s_SolvedNode& node_3 = ((node_2.kind == s_Kind___preceding_ref_arg) ? _current_fn.events.preceding_ref_args[node_2.helpers.index].arg : node_2);
            if (_1AXfSSx3(node_3, read, loop_ids, ss))
                return s_SolvedNode(node_3);
            else
                for (int i = node_3.items.size(); i-- > 0; )
                    stack += s_SolvedNode(node_3.items[i]);
;
        };
    };
    return s_SolvedNode{};
}
                                #endif

static s_SolvedNode SLOW_findByReadID_gDsnGKHT(const int read, const int write_loop_start, const s_SolvedNode& root, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::vec<int> loop_ids {};
    eachLoopStart_nJvHNWHJ(write_loop_start, loop_ids, ss);
    s_SolvedNode _0 {};
    return (_0 = SLOW_find_QHBo9ZEh(read, loop_ids, root, _current_fn, ss, _here, ctx, module)) ? static_cast<s_SolvedNode&&>(_0) : BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("Cannot find read("_fu, str_FDl5ha9X(nested_FDl5ha9X(read, ss, _here, ctx), false, ss, _here, ctx, module, options)) + ") in loop("_fu), fu::i64dec(write_loop_start)) + ")."_fu), ss, _helpers, _here, ctx, module, options);
}

static fu::str qSTACK_rwevent_gDsnGKHT(const s_SolvedNode& callsite, const int write, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<s_SolvedNode> args = callsite.items;
    fu::view<s_Argument> host_args = ((callsite.kind == s_Kind_call) ? EXT_gDsnGKHT(callsite.target, ss, ctx, module).args : fu::view<s_Argument>{});
    if (args.size() == host_args.size())
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const s_Argument& host_arg = host_args[i];
            if (!(!host_arg.written_to))
            {
                const s_SolvedNode& arg = args[i];
                if (!(!Lifetime_has_7Yz9ezW2(arg.type.lifetime, write)))
                {
                    return qSTACK_arg_gDsnGKHT(callsite.target, i, fu::view<s_Target>{}, s_ArgQuery{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                };
            };
        };
    };
    return ""_fu;
}

                                #ifndef DEF___WcMLkLpCdVl
                                #define DEF___WcMLkLpCdVl
inline static void _WcMLkLpC(const int read, const int write, const s_SolvedNode& callOrPragma, const int loop_start, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (read)
    {
        if (read < loop_start)
        {
            if (has_gDsnGKHT(events_iUdwqyBn(_current_fn).used_in_a_loop, read, _current_fn))
            {
                if (pass == s_BorrowCheckPass_BCK_aar)
                    RESOLVE_byAAR_gDsnGKHT(read, write, true, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
                else
                {
                    if (!(RESOLVE_byMutvar_FDl5ha9X(read, pass, _current_fn, ss, _helpers, _here, ctx, module, options)))
                    {
                        fu::str _0 {};
                        fu::str _1 {};
                        (_1 = (_0 = (((x7E_3lDd4lqo(((x7E_3lDd4lqo("Write to "_fu, str_FDl5ha9X(nested_FDl5ha9X(write, ss, _here, ctx), false, ss, _here, ctx, module, options)) + ((callOrPragma.kind == s_Kind_call) ? x7E_3lDd4lqo(" at call to "_fu, str_FDl5ha9X(callOrPragma.target, false, ss, _here, ctx, module, options)) : fu::str{})) + " invalidates the use of "_fu), str_FDl5ha9X(nested_FDl5ha9X(read, ss, _here, ctx), false, ss, _here, ctx, module, options)) + " at "_fu) + addr_and_snippet_gDsnGKHT(SLOW_findByReadID_gDsnGKHT(read, loop_start, root, _current_fn, ss, _helpers, _here, ctx, module, options).token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + "\n\t... on next loop iteration.\n\n\tWritten"_fu), (static_cast<fu::str&&>(_0) + qSTACK_rwevent_gDsnGKHT(callOrPragma, write, _current_fn, ss, _helpers, _here, ctx, module, options))), cannotFailAfterBCK_gDsnGKHT(static_cast<fu::str&&>(_1), pass, ss, _helpers, _here, ctx, module, options));
                    };
                };
            };
        };
    }
    else
        BUG_gDsnGKHT("bck_trackWrites: invalidates contains non-locals."_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_Lifetime_each_Lcaque3i9V4
                                #define DEF_Lifetime_each_Lcaque3i9V4
inline void Lifetime_each_Lcaque3i(const s_Lifetime& lifetime, const int write, const s_SolvedNode& callOrPragma, const int loop_start, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _WcMLkLpC(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), write, callOrPragma, loop_start, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static s_WriteID WriteID_gDsnGKHT(const int locid, const s_TokenIdx& token, const s_BorrowCheckPass pass)
{
    return s_WriteID { (((unsigned(locid) << 1u) ^ ((locid < 0) ? 0xffffffffu : 0x0u)) | ((pass == s_BorrowCheckPass_BCK_bck) ? tokenHash_gDsnGKHT(token) : 0u)) };
}

                                #ifndef DEF_steal_1Lw83ZXe1pa
                                #define DEF_steal_1Lw83ZXe1pa
inline s_PrecedingRefArg steal_1Lw83ZXe(s_PrecedingRefArg& v)
{
    /*MOV*/ s_PrecedingRefArg ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

                                #ifndef DEF___OmZARlINQ1d
                                #define DEF___OmZARlINQ1d
inline static void _OmZARlIN(const int read, const int write, const bool trySoft, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (read && (read != write))
        RESOLVE_byAAR_gDsnGKHT(read, write, trySoft, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_each_hXVTewSvJt7
                                #define DEF_each_hXVTewSvJt7
inline void each_hXVTewSv(fu::view<int> a, const int write, const bool trySoft, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
        _OmZARlIN(a[i], write, trySoft, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

}
                                #endif

static bool RESOLVE_byAAR_FDl5ha9X(const int write, fu::view<int> reads, const bool trySoft, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_hXVTewSv(reads, write, trySoft, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    return true;
}

                                #ifndef DEF_ensure_EecW8ZOjrnb
                                #define DEF_ensure_EecW8ZOjrnb
inline s_Set_2i2v33LNlqd& ensure_EecW8ZOj(fu::vec<s_Set_2i2v33LNlqd>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_ODQbeVDPhLb
                                #define DEF_ensure_ODQbeVDPhLb
inline static s_Set_2i2v33LNlqd& ensure_ODQbeVDP(s_LocidMap_OrMuSNs7d4i& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_EecW8ZOj(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF_x3Cx3E_PrbTM1d3B89
                                #define DEF_x3Cx3E_PrbTM1d3B89
inline int x3Cx3E_PrbTM1d3(const s_WriteID& a, const s_WriteID& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_F82w14kI(a._locid_and_hash, b._locid_and_hash)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_add_ALAAtcqSyZf
                                #define DEF_add_ALAAtcqSyZf
inline bool add_ALAAtcqS(s_Set_2i2v33LNlqd& _, const s_WriteID& key)
{
    fu::view<s_WriteID> keys_asc = _.keys_asc;
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_PrbTM1d3(keys_asc[i], key);
        if (cmp == 0)
            return false;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    _.keys_asc.insert(i, s_WriteID(key));
    return true;
}
                                #endif

                                #ifndef DEF___0O8wHvmgJE2
                                #define DEF___0O8wHvmgJE2
inline static void _0O8wHvmg(const int invalidatee, const int write, const s_WriteID& writeID, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Set_2i2v33LNlqd& set = ensure_ODQbeVDP(events_gDsnGKHT(_current_fn).snap.invalidated_by, invalidatee, _current_fn);
    int BL_3_v {};
    if (pass == s_BorrowCheckPass_BCK_bck)
    {
        fu::vec<s_WriteID>& a = set.keys_asc;
        if (!(a))
        {
            a = fu::vec<s_WriteID> { fu::slate<1, s_WriteID> { s_WriteID(writeID) } };
        };
    }
    else if ((__extension__ (
    {
        const unsigned v = writeID._locid_and_hash;
        BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_3_v) == write)
        add_ALAAtcqS(set, writeID);
    else
        BUG_gDsnGKHT("AAR: writeID._locid != write locid, set::add wont be able to dedupe"_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_Lifetime_each_1ctVYsThd74
                                #define DEF_Lifetime_each_1ctVYsThd74
inline void Lifetime_each_1ctVYsTh(const s_Lifetime& lifetime, const int write, const s_WriteID& writeID, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _0O8wHvmg(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), write, writeID, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF___DST93ErxKD1
                                #define DEF___DST93ErxKD1
inline static void _DST93Erx(const int write, const s_Lifetime& write_region, fu::view<char> write_paths, const s_SolvedNode& callOrPragma, const int loop_start, const bool OPTI_isLoop, const bool OPTI_hasPRA, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!write))
    {
        /*MOV*/ s_Lifetime all_written { write_region };
        Lifetime_add_7Yz9ezW2(all_written, Lifetime_op_join_7Yz9ezW2(iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_parents, write, _current_fn), write_paths, _here, ctx), false, _here, ctx);
        const s_Lifetime& invalidates = iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_invalidates, write, _current_fn);
        if (Lifetime_has_7Yz9ezW2(invalidates, write))
            BUG_gDsnGKHT(x7E_3lDd4lqo("flow.invalidates[write].has(write): "_fu, str_FDl5ha9X(nested_FDl5ha9X(write, ss, _here, ctx), false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else
        {
            s_Lifetime invalidates_1 = Lifetime_process_cCyqKtXd(invalidates, all_written, _current_fn, _here, ctx);
            if (OPTI_isLoop)
            {
                Lifetime_each_Lcaque3i(invalidates_1, write, callOrPragma, loop_start, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
            const s_WriteID writeID = WriteID_gDsnGKHT(write, callOrPragma.token, pass);
            if (OPTI_hasPRA)
            {
                s_Lifetime all_written_and_invalidated = static_cast<s_Lifetime&&>(all_written);
                Lifetime_add_7Yz9ezW2(all_written_and_invalidated, invalidates_1, true, _here, ctx);
                int w = -1;
                for (int i = 0; i < _current_fn.events.preceding_ref_args.size(); i++)
                {
                    s_PrecedingRefArg pra = steal_1Lw83ZXe(_current_fn.events.preceding_ref_args.mutref(i));
                    fu_DEFER(std::swap(_current_fn.events.preceding_ref_args.mutref(i), pra));
                    if (pra.w < 0)
                    {
                        if (!((w >= 0)))
                            BUG_gDsnGKHT("preceding_ref_args: No leading .w position."_fu, ss, _helpers, _here, ctx, module, options);

                    }
                    else
                        w = pra.w;

                    const int r = pra.r;
                    const s_Lifetime& bound = pra.arg.type.lifetime;
                    fu::vec<int> inter = Lifetime_interLocids_7Yz9ezW2(bound, all_written_and_invalidated, _here, ctx);
                    if (!(!inter))
                    {
                        if (((pass == s_BorrowCheckPass_BCK_aar) ? !RESOLVE_byAAR_FDl5ha9X(write, inter, softRiskSafe_gDsnGKHT(pra.arg, ss, _here, ctx, module), pass, _current_fn, ss, _helpers, _here, ctx, module, options) : !!RESOLVE_byTempCopy_FDl5ha9X(pra.arg, pra.target, r, x7E_3lDd4lqo("bck:pra "_fu, fu::i64dec(write)), s_ArgRationale{}, pass, _current_fn, ss, _helpers, _here, ctx, module, options)))
                        {
                            _here = pra.callsite_token;
                            fu::str _0 {};
                            fu::str _1 {};
                            (_1 = (_0 = (x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("At call to "_fu, str_FDl5ha9X(pra.target, false, ss, _here, ctx, module, options)) + ", binding for "_fu), str_wyx7msfr(EXT_gDsnGKHT(pra.target, ss, ctx, module).args[r], false, _current_fn, ss, _here, ctx, module, options)) + " (arg #"_fu), fu::i64dec(r)) + ") at "_fu) + addr_and_snippet_gDsnGKHT(pra.arg.token, s_CodeFmt{}, fu::view<char>{}, ctx, module)) + "\n\t... invalidated by subsequent write to "_fu), str_FDl5ha9X(nested_FDl5ha9X(write, ss, _here, ctx), false, ss, _here, ctx, module, options)) + " upon evaluation of "_fu), str_wyx7msfr(EXT_gDsnGKHT(pra.target, ss, ctx, module).args[w], false, _current_fn, ss, _here, ctx, module, options)) + " (arg #"_fu), fu::i64dec(w)) + ") at "_fu), (static_cast<fu::str&&>(_0) + RWEvent_stack_gDsnGKHT(writeID, root, _current_fn, ss, _helpers, _here, ctx, module, options))), cannotFailAfterBCK_gDsnGKHT(static_cast<fu::str&&>(_1), pass, ss, _helpers, _here, ctx, module, options));
                        };
                    };
                };
            };
            Lifetime_each_1ctVYsTh(invalidates_1, write, writeID, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_pDBFbNx3k36
                                #define DEF_Lifetime_each_pDBFbNx3k36
inline void Lifetime_each_pDBFbNx3(const s_Lifetime& lifetime, const s_SolvedNode& callOrPragma, const int loop_start, const bool OPTI_isLoop, const bool OPTI_hasPRA, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0_1;

    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0_1 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0_1);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        _DST93Erx(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v)), s_Lifetime { fu::slice(chars, offset0, offset) }, fu::get_view(chars, sr, offset), callOrPragma, loop_start, OPTI_isLoop, OPTI_hasPRA, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void bck_trackWrites_gDsnGKHT(const s_SolvedNode& callOrPragma, const s_Lifetime& lifetime, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int loop_start = (callOrPragma._loop_start ? callOrPragma._loop_start : BUG_gDsnGKHT("bck_trackWrites: _loop_start not set on callsite."_fu, ss, _helpers, _here, ctx, module, options));
    const bool OPTI_isLoop = ((loop_start != NO_LOOP) ? !!events_iUdwqyBn(_current_fn).used_in_a_loop : false);
    const bool OPTI_hasPRA = !!events_iUdwqyBn(_current_fn).preceding_ref_args;
    Lifetime_each_pDBFbNx3(lifetime, callOrPragma, loop_start, OPTI_isLoop, OPTI_hasPRA, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static void bck_call_gDsnGKHT(s_SolvedNode& callsite, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!args_iUdwqyBn(callsite))
    {
        if (GET_gDsnGKHT(target_FDl5ha9X(callsite), ss, _here, ctx, module).kind == s_Kind_var)
            bck_trackRead_gDsnGKHT(callsite, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        const bool RTL = isRTL_xQNS19Zn(GET_gDsnGKHT(target_FDl5ha9X(callsite), ss, _here, ctx, module));
        fu::vec<s_Argument> host_args { EXT_gDsnGKHT(target_FDl5ha9X(callsite), ss, ctx, module).args };
        s_Lifetime bck_writes {};
        int num_ref_args {};

        {
            const int pra_len0 = _current_fn.events.preceding_ref_args.size();
            int pra_first = -1;
            argsForward_CvRqzLk2(RTL, host_args, 0, callsite, bck_writes, num_ref_args, pra_first, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            for (int i = 0; i < args_iUdwqyBn(callsite).size(); i++)
            {
                s_SolvedNode& arg = args_FDl5ha9X(callsite).mutref(i);
                if (arg.kind == s_Kind___preceding_ref_arg)
                {
                    s_PrecedingRefArg& pra = _current_fn.events.preceding_ref_args.mutref(arg.helpers.index);
                    if ((pra.target == target_FDl5ha9X(callsite)) && (pra.r == i))
                        std::swap(arg, pra.arg);
                    else
                        BUG_gDsnGKHT("preceding_ref_args got messed up"_fu, ss, _helpers, _here, ctx, module, options);

                };
            };
            _current_fn.events.preceding_ref_args.shrink(pra_len0);
        };
        if (!(!bck_writes))
        {
            if (num_ref_args > 1)
            {
                int mutref_first = -1;
                int mutref_last = -1;
                int ref_first = -1;
                int ref_last = -1;
                fu::vec<s_Lifetime> bck_unwound {};
                bck_unwound.resize(args_iUdwqyBn(callsite).size());
                int arg_first = -1;
                int arg_last = -1;
                for (int i0 = 0; i0 < args_iUdwqyBn(callsite).size(); i0++)
                {
                    s_Argument host_arg0 { host_args[i0] };
                    s_Type expect { host_arg0.type };
                    if (!(!is_ref_9CJmuVSD(expect)))
                    {
                        s_SolvedNode BL_15_v {};
                        s_SolvedNode arg0 = (__extension__ (
                        {
                            const s_SolvedNode& __partcopy_ref = args_iUdwqyBn(callsite)[i0];
                            BL_15_v = (s_SolvedNode { __partcopy_ref.kind, {}, {}, {}, {}, fu::vec<s_SolvedNode>(__partcopy_ref.items), {}, s_Type(__partcopy_ref.type), s_Target(__partcopy_ref.target) });
                        (void)0;}), static_cast<s_SolvedNode&&>(BL_15_v));
                        s_Lifetime shallow0 { arg0.type.lifetime };
                        const s_Lifetime& unwound0 = (bck_unwound.mutref(i0) = Lifetime_unwind_gDsnGKHT(shallow0, true, ss, _helpers, _here, ctx, module, options));
                        Lifetime_each_faE69Fb7(unwound0, arg_first, arg_last, i0);
                        if ((ref_first >= 0))
                        {
                            if (is_mutref_9CJmuVSD(expect, _here, ctx))
                            {
                                for (int i = ref_first; (i <= ref_last); i++)
                                {
                                    if (is_ref_9CJmuVSD(host_args[i].type))
                                        validate_gDsnGKHT(i, callsite, host_args, bck_unwound, arg_first, arg_last, i0, host_arg0, arg0, shallow0, unwound0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

                                };
                            }
                            else if ((mutref_first >= 0))
                            {
                                for (int i = mutref_first; (i <= mutref_last); i++)
                                {
                                    if (is_mutref_9CJmuVSD(host_args[i].type, _here, ctx))
                                        validate_gDsnGKHT(i, callsite, host_args, bck_unwound, arg_first, arg_last, i0, host_arg0, arg0, shallow0, unwound0, pass, _current_fn, ss, _helpers, _here, ctx, module, options);

                                };
                            };
                        };

                        {
                            if (ref_first < 0)
                                ref_first = i0;

                            ref_last = i0;
                        };
                        if (is_mutref_9CJmuVSD(expect, _here, ctx))
                        {
                            if (mutref_first < 0)
                                mutref_first = i0;

                            mutref_last = i0;
                        };
                    };
                };
            };
            _here = callsite.token;
            bck_trackWrites_gDsnGKHT(callsite, bck_writes, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static void bck_loop_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_LocidSet used_in_a_loop0 { _current_fn.events.used_in_a_loop };
    clear_FDl5ha9X(_current_fn.events.used_in_a_loop, node._loop_start, _current_fn);
    fu::view_mut<s_SolvedNode> items = node.items;
    s_SolvedNode* _0;
    (_0 = &(items.mutref(0)), bck_node_gDsnGKHT(*_0, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
    for (int i = 1; i < items.size(); i++)
    {
        s_SolvedNode* _1;
        (_1 = &(items.mutref(i)), bck_node_gDsnGKHT(*_1, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
    };
    const s_HelpersData* BL_3_v;
    int _2 {};
    const int read_loop_start = ((_2 = (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_3_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_3_v).postdom.read_loop_start) ? _2 : BUG_gDsnGKHT("bck_loop: read_loop_start not set."_fu, ss, _helpers, _here, ctx, module, options));
    clear_FDl5ha9X(_current_fn.events.used_in_a_loop, read_loop_start, _current_fn);
    s_LocidSet& set = _current_fn.events.used_in_a_loop;
    add_Na55O4zv(set._bitset, used_in_a_loop0._bitset);
}

static bool willPassByValue_FDl5ha9X(const s_Overload& o, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (acceptsTempCopies_FDl5ha9X(o, _here, ctx))
        return isPassByValue_hxWWgdZ1(o.type.vtype);
    else
        return false;

}

                                #ifndef DEF___eQpqtS0QjJe
                                #define DEF___eQpqtS0QjJe
inline static void _eQpqtS0Q(const int locid, const bool isStatic, int& left, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(isStatic))
    {
        (!left ? left : BUG_gDsnGKHT("Lifetime_getRefLocid_unlessStatic: multiple locids in left_lt"_fu, ss, _helpers, _here, ctx, module, options)) = (locid ? locid : BUG_gDsnGKHT("Lifetime_getRefLocid_unlessStatic: non-locid/non-static in left_lt"_fu, ss, _helpers, _here, ctx, module, options));
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_st4FUhdXMcj
                                #define DEF_Lifetime_each_st4FUhdXMcj
inline void Lifetime_each_st4FUhdX(const s_Lifetime& lifetime, int& left, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _eQpqtS0Q(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), ((r & 11u) == 1u), left, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static int Lifetime_getRefLocid_unlessStatic_gDsnGKHT(const s_Lifetime& lifetime, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int left {};
    Lifetime_each_st4FUhdX(lifetime, left, ss, _helpers, _here, ctx, module, options);
    return left;
}

static void visit_835qRIOU(const s_Lifetime& lifetime, s_Lifetime& result, const bool maybeOutOfOrder, const s_TokenIdx& _here, const s_Context& ctx)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                int BL_12_v {};
                const int locid = ((r & 1u) ? 0 : (__extension__ (
                {
                    const unsigned v = (r >> 1u);
                    BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_12_v));
                if (locid)
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_5Qtq8kSDq58
                                #define DEF_Lifetime_process_5Qtq8kSDq58
inline s_Lifetime Lifetime_process_5Qtq8kSD(const s_Lifetime& lifetime, const s_TokenIdx& _here, const s_Context& ctx)
{
    /*MOV*/ s_Lifetime result {};
    const bool maybeOutOfOrder = false;
    visit_835qRIOU(lifetime, result, maybeOutOfOrder, _here, ctx);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_ensure_3gHz8Thhhc9
                                #define DEF_ensure_3gHz8Thhhc9
inline s_Set_95BJOojOc45& ensure_3gHz8Thh(fu::vec<s_Set_95BJOojOc45>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_tGuqVNcL6h0
                                #define DEF_ensure_tGuqVNcL6h0
inline static s_Set_95BJOojOc45& ensure_tGuqVNcL(s_LocidMap_OjaSaYAvjq2& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_3gHz8Thh(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___eIbFZcoGVZ8
                                #define DEF___eIbFZcoGVZ8
inline static void _eIbFZcoG(const int right, fu::view<char> paths, const s_Type& t_left, const int left, s_Lifetime& parents, s_Lifetime& siblings, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!right))
    {
        if (!right)
            BUG_gDsnGKHT("Reference_trackLocalRef: right has non-locals."_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            const s_Type& t_right = GET_gDsnGKHT(nested_FDl5ha9X(right, ss, _here, ctx), ss, _here, ctx, module).type;
            if (!(type_mayPointInto_gDsnGKHT(t_right.vtype, t_left.vtype, ss, _here, ctx, module)))
                BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo("type_mayPointInto fails for "_fu, str_FDl5ha9X(nested_FDl5ha9X(left, ss, _here, ctx), false, ss, _here, ctx, module, options)) + " := "_fu), str_FDl5ha9X(nested_FDl5ha9X(right, ss, _here, ctx), false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

        };
        int _0 {};
        (_0 = left, add_8Ex4Hrql(ensure_tGuqVNcL(flow_gDsnGKHT(_current_fn).rg_children, right, _current_fn), _0));
        Lifetime_add_7Yz9ezW2(parents, Lifetime_op_join_7Yz9ezW2(iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_parents, right, _current_fn), paths, _here, ctx), false, _here, ctx);
        Lifetime_add_7Yz9ezW2(siblings, iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_invalidates, right, _current_fn), false, _here, ctx);
        if (has_gDsnGKHT(flow_wyx7msfr(_current_fn).is_arg, right, _current_fn))
        {
            add_gDsnGKHT(flow_gDsnGKHT(_current_fn).is_arg, left, _current_fn);
            add_8Ex4Hrql(ensure_tGuqVNcL(flow_gDsnGKHT(_current_fn).arg_parents, left, _current_fn), right);
        };
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_FUN1cbtIua4
                                #define DEF_Lifetime_each_FUN1cbtIua4
inline void Lifetime_each_FUN1cbtI(const s_Lifetime& lifetime, const s_Type& t_left, const int left, s_Lifetime& parents, s_Lifetime& siblings, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    // Hoisted:
    int offset0;

    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        int BL_3_v {};
        const int sr = (__extension__ (
        {
            offset0 = (offset + 0);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };
            BL_3_v = (offset0);
        (void)0;}), BL_3_v);
        int BL_11_v {};
        _eIbFZcoG(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_11_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_11_v)), fu::get_view(chars, sr, offset), t_left, left, parents, siblings, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void visit_TU44lxHR(const s_Lifetime& lifetime, s_Lifetime& result, const bool maybeOutOfOrder, const s_Type& t_left, const unsigned left_ever_written, const s_Lifetime& parents, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const fu::str& chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;

        { {
            const unsigned r = parse7bit(chars, offset);
            for (; ; )
            {
                bool isLastPath = false;
                bool isFirstSubRegion = true;
                for (; ; )
                {
                    const unsigned raw_flatOffset = parse7bit(chars, offset);
                    const bool isLastSubRegion = !(raw_flatOffset & 1u);
                    const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                    isLastPath = !(raw_flatCount & 1u);
                    if (isLastSubRegion)
                        break;
                    else
                        isFirstSubRegion = false;

                };
                if (isLastPath)
                    break;

            };

            {
                int BL_12_v {};
                const int locid = ((r & 1u) ? 0 : (__extension__ (
                {
                    const unsigned v = (r >> 1u);
                    BL_12_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_12_v));
                const s_Type& t_sibling = GET_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _here, ctx, module).type;
                const unsigned sibling_written = iF_51ChLTxy(_current_fn.postdom.snap.ever_written, locid, _current_fn);
                const s_Lifetime& sibling_parents = iF_jKub7rek(flow_wyx7msfr(_current_fn).rg_parents, locid, _current_fn);
                unsigned BL_13_v {};
                unsigned BL_14_v {};
                if (Lifetime_hasInter_SNOY04NK(parents, sibling_parents, s_RWQuals { (__extension__ (
                {
                    const s_ValueType& type = t_left.vtype;
                    BL_13_v = ((type.quals & q_USAGE));
                (void)0;}), BL_13_v), left_ever_written }, s_RWQuals { (__extension__ (
                {
                    const s_ValueType& type = t_sibling.vtype;
                    BL_14_v = ((type.quals & q_USAGE));
                (void)0;}), BL_14_v), sibling_written }, _here, ctx))
                    goto BL_3;

            };
            continue;
          } BL_3:;
        };
        if (maybeOutOfOrder)
        {
            result = Lifetime_union_7Yz9ezW2(result, s_Lifetime { fu::slice(chars, offset0, offset) }, false, _here, ctx);
        }
        else
            result.uni0n += fu::get_view(chars, offset0, offset);

    };
}

                                #ifndef DEF_Lifetime_process_EAwFKeGBHWk
                                #define DEF_Lifetime_process_EAwFKeGBHWk
inline s_Lifetime Lifetime_process_EAwFKeGB(const s_Lifetime& lifetime, const s_Type& t_left, const unsigned left_ever_written, const s_Lifetime& parents, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    /*MOV*/ s_Lifetime result {};
    const bool maybeOutOfOrder = false;
    visit_TU44lxHR(lifetime, result, maybeOutOfOrder, t_left, left_ever_written, parents, _current_fn, ss, _here, ctx, module);
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF_ensure_FVuksKV7i0f
                                #define DEF_ensure_FVuksKV7i0f
inline s_Lifetime& ensure_FVuksKV7(fu::vec<s_Lifetime>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF_ensure_xVGIzXENE8e
                                #define DEF_ensure_xVGIzXENE8e
inline static s_Lifetime& ensure_xVGIzXEN(s_LocidMap_93S9qlGbUSi& map, const int locid, const s_CurrentFn& _current_fn)
{
    const int args_neg = _current_fn.args_neg;
    return ensure_FVuksKV7(map._values, (args_neg + locid));
}
                                #endif

                                #ifndef DEF___46yRnj8QQSl
                                #define DEF___46yRnj8QQSl
inline static void _46yRnj8Q(const int sibling, const s_Type& t_left, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!sibling)
        BUG_gDsnGKHT("Reference_trackLocalRef: siblings has non-locals."_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        Lifetime_add_7Yz9ezW2(ensure_xVGIzXEN(flow_gDsnGKHT(_current_fn).rg_invalidates, sibling, _current_fn), t_left.lifetime, false, _here, ctx);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_easVQw8HSg6
                                #define DEF_Lifetime_each_easVQw8HSg6
inline void Lifetime_each_easVQw8H(const s_Lifetime& lifetime, const s_Type& t_left, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _46yRnj8Q(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), t_left, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF___k9lRco1ye02
                                #define DEF___k9lRco1ye02
inline static void _k9lRco1y(const int parent, const s_Type& t_left, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!parent)
        BUG_gDsnGKHT("Reference_trackLocalRef: parents has non-locals."_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        Lifetime_add_7Yz9ezW2(ensure_xVGIzXEN(flow_gDsnGKHT(_current_fn).rg_invalidates, parent, _current_fn), t_left.lifetime, false, _here, ctx);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_FzqMhvDIVQ9
                                #define DEF_Lifetime_each_FzqMhvDIVQ9
inline void Lifetime_each_FzqMhvDI(const s_Lifetime& lifetime, const s_Type& t_left, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _k9lRco1y(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), t_left, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void Reference_trackLocalRef_gDsnGKHT(const s_Type& t_left, const s_Lifetime& right, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int left = Lifetime_getRefLocid_unlessStatic_gDsnGKHT(t_left.lifetime, ss, _helpers, _here, ctx, module, options);
    if (!(!left))
    {
        const unsigned left_ever_written = iF_51ChLTxy(_current_fn.postdom.snap.ever_written, left, _current_fn);
        s_Lifetime right_1 = Lifetime_process_5Qtq8kSD(right, _here, ctx);
        s_Lifetime parents {};
        s_Lifetime siblings {};
        Lifetime_add_7Yz9ezW2(parents, right_1, false, _here, ctx);
        Lifetime_each_FUN1cbtI(right_1, t_left, left, parents, siblings, _current_fn, ss, _helpers, _here, ctx, module, options);
        siblings = Lifetime_process_EAwFKeGB(siblings, t_left, left_ever_written, parents, _current_fn, ss, _here, ctx, module);
        if (siblings)
        {
            if (Lifetime_has_7Yz9ezW2(siblings, left))
                BUG_gDsnGKHT("siblings.has(left)"_fu, ss, _helpers, _here, ctx, module, options);
            else
            {
                s_Lifetime* _0;
                (!*(_0 = &(ensure_xVGIzXEN(flow_gDsnGKHT(_current_fn).rg_invalidates, left, _current_fn))) ? *_0 : BUG_gDsnGKHT("rg_invalidates already set"_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime(siblings);
                Lifetime_each_easVQw8H(siblings, t_left, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        if (parents)
        {
            s_Lifetime* _1;
            (!*(_1 = &(ensure_xVGIzXEN(flow_gDsnGKHT(_current_fn).rg_parents, left, _current_fn))) ? *_1 : BUG_gDsnGKHT("rg_parents already set"_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime(parents);
            Lifetime_each_FzqMhvDI(parents, t_left, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static void bck_trackInit_gDsnGKHT(const s_Target& target, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    const int index = (__extension__ (
    {
        const unsigned v = unsigned((target._packed & 0xfffffull));
        BL_1_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
    (void)0;}), BL_1_v);
    if (!(!index))
    {
        if (iF_hRiqvWW2(events_iUdwqyBn(_current_fn).snap.invalidated_by, index, _current_fn))
        {
            BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static void bck_let_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_SolvedNode* _0;
    (_0 = &(node.items.mutref(LET_INIT)), bck_node_gDsnGKHT(*_0, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
    if (is_ref_9CJmuVSD(node.type) && !willPassByValue_FDl5ha9X(GET_gDsnGKHT(node.target, ss, _here, ctx, module), _here, ctx))
    {
        bool BL_2_v {};
        if ((__extension__ (
        {
            const s_Target& target = node.target;
            int BL_3_v {};
            BL_2_v = (((__extension__ (
            {
                const unsigned v = unsigned((target._packed & 0xfffffull));
                BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_3_v) < 0));
        (void)0;}), BL_2_v))
            BUG_gDsnGKHT("bck_let: Found an argument!"_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            const s_SolvedNode& init = node.items[LET_INIT];
            if (is_ref_9CJmuVSD(init.type))
            {
                Reference_trackLocalRef_gDsnGKHT(GET_gDsnGKHT(node.target, ss, _here, ctx, module).type, init.type.lifetime, _current_fn, ss, _helpers, _here, ctx, module, options);
            }
            else
                BUG_gDsnGKHT("What!"_fu, ss, _helpers, _here, ctx, module, options);

        };
    };
    bck_trackInit_gDsnGKHT(node.target, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_Events_restore_19AfMpwQx05
                                #define DEF_Events_restore_19AfMpwQx05
inline static void Events_restore_19AfMpwQ(fu::vec<s_Set_2i2v33LNlqd>& dest, fu::view<s_Set_2i2v33LNlqd> src, const int write_loop_start)
{
    if (dest.size() > write_loop_start)
        dest.shrink(write_loop_start);

    if (src.size() > write_loop_start)
    {
        dest.grow(write_loop_start);
        dest += fu::get_view(src, write_loop_start);
    };
}
                                #endif

static void Events_restore_gDsnGKHT(s_Events& events, const s_EventsSnap& restore, const int write_loop_start, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (!write_loop_start)
        BUG_u9Gbkniv("Events_restore: no write_loop_start, cant decide which events need to survive"_fu, _here, ctx);
    else if (write_loop_start == NO_LOOP)
        events.snap = restore;
    else
        Events_restore_19AfMpwQ(events.snap.invalidated_by._values, restore.invalidated_by._values, write_loop_start);

}

                                #ifndef DEF_add_9vyxIcYUXb1
                                #define DEF_add_9vyxIcYUXb1
inline void add_9vyxIcYU(fu::vec<s_WriteID>& a, fu::view<s_WriteID> b)
{
    int x = 0;
    int y = 0;
    while ((x < a.size()) && (y < b.size()))
    {
        const s_WriteID& X = a[x];
        const s_WriteID& Y = b[y];
        const int cmp = x3Cx3E_PrbTM1d3(X, Y);
        if ((cmp >= 0))
        {
            if (cmp != 0)
            {
                a.insert(x, s_WriteID(Y));
                y++;
            }
            else
                y++;

        };
        x++;
    };
    if (y < b.size())
        a += fu::get_view(b, y);

}
                                #endif

                                #ifndef DEF_Events_merge_9RDpO5vumDh
                                #define DEF_Events_merge_9RDpO5vumDh
inline static void Events_merge_9RDpO5vu(fu::vec<s_Set_2i2v33LNlqd>& dest, fu::view<s_Set_2i2v33LNlqd> src)
{
    if (dest.size() < src.size())
        dest.grow(src.size());

    for (int i = 0; i < src.size(); i++)
    {
        const s_Set_2i2v33LNlqd& src_1 = src[i];
        if (src_1)
            add_9vyxIcYU(dest.mutref(i).keys_asc, src_1.keys_asc);

    };
}
                                #endif

static void Events_merge_gDsnGKHT(s_EventsSnap& events, const s_EventsSnap& snap)
{
    Events_merge_9RDpO5vu(events.invalidated_by._values, snap.invalidated_by._values);
}

static void bck_if_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view_mut<s_SolvedNode> items = node.items;
    s_SolvedNode& cond = items.mutref(0);
    bck_node_gDsnGKHT(cond, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    const s_StaticEval ae_cond = tryAbstractEvalAsBool_gDsnGKHT(cond, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (ae_cond)
    {
        s_SolvedNode& cons = items.mutref(((ae_cond == s_StaticEval_SE_True) ? 1 : 2));
        bck_node_gDsnGKHT(cons, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
        node = createBlock_FDl5ha9X(s_SolvedNode(items[0]), s_SolvedNode(cons), ss, _here, ctx, module);
    }
    else
    {
        s_EventsSnap e_Restore_AfterCond { _current_fn.events.snap };
        s_SolvedNode* _0;
        (_0 = &(items.mutref(1)), bck_node_gDsnGKHT(*_0, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
        s_EventsSnap e_Merge_AfterCons { _current_fn.events.snap };
        Events_restore_gDsnGKHT(_current_fn.events, e_Restore_AfterCond, node._loop_start, _here, ctx);
        s_SolvedNode* _1;
        (_1 = &(items.mutref(2)), bck_node_gDsnGKHT(*_1, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
        Events_merge_gDsnGKHT(_current_fn.events.snap, e_Merge_AfterCons);
    };
}

static void bck_and_or_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::vec<s_SolvedNode>& items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        s_SolvedNode& expr = items.mutref(i);
        bck_node_gDsnGKHT(expr, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
        const s_StaticEval ae_expr = tryAbstractEvalAsBool_gDsnGKHT(expr, (i == (items.size() - 1)), _current_fn, ss, _helpers, _here, ctx, module, options);
        if (ae_expr)
        {
            const bool isAnd = (node.kind == s_Kind_and);
            if (isAnd == (ae_expr == s_StaticEval_SE_False))
            {
                items.shrink((i + 1));
                node.type.vtype.vfacts |= (isAnd ? s_VFacts_AlwaysFalse : s_VFacts_AlwaysTrue);
                break;
            }
            else if (i < (items.size() - 1))
            {
                /*MOV*/ s_SolvedNode cond = steal_46agKNQY(expr);
                items.splice(i, 1);
                s_SolvedNode& cons = items.mutref(i--);
                cons = createBlock_FDl5ha9X(static_cast<s_SolvedNode&&>(cond), s_SolvedNode(cons), ss, _here, ctx, module);
            };
        };
    };
    if (node.items.size() < 2)
        node = only_LqU08rcL(node.items);

}

static void bck_not_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_SolvedNode& expr = only_n3dv4p6e(node.items);
    bck_node_gDsnGKHT(expr, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    const s_StaticEval ae_expr = tryAbstractEvalAsBool_gDsnGKHT(expr, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (ae_expr)
        node.type.vtype.vfacts |= ((ae_expr == s_StaticEval_SE_True) ? s_VFacts_AlwaysFalse : s_VFacts_AlwaysTrue);

}

static void bck_block_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::vec<int> defers {};
    const int TODO_FIX_nesteDefers0 = _current_fn.TODO_FIX_bckCantDealWithNestedDefers;
    fu::vec<s_SolvedNode>& items = node.items;
    for (int i = 0; i < items.size(); i++)
    {
        s_SolvedNode& stmt = items.mutref(i);
        if (stmt.kind == s_Kind_defer)
        {
            const s_HelpersData* BL_4_v;
            if (!defers && ((__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_4_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_4_v).target != _current_fn.out.target))
                _current_fn.TODO_FIX_bckCantDealWithNestedDefers++;

            defers += i;
            if (is_never_9CJmuVSD(stmt.type.vtype))
                BUG_gDsnGKHT("bck, block: defer.is_never"_fu, ss, _helpers, _here, ctx, module, options);

        }
        else
        {
            bck_node_gDsnGKHT(stmt, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (is_never_9CJmuVSD(stmt.type.vtype))
            {
                items.shrink((i + 1));
                const s_HelpersData* BL_9_v;
                if (!s_HelpersMask(((__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_9_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_9_v).mask & s_HelpersMask_HM_LabelUsed)))
                    node.type = t_never;

                break;
            };
        };
    };
    const s_HelpersData* BL_11_v;
    Events_merge_gDsnGKHT(_current_fn.events.snap, (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_11_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_11_v).postevt);
    for (int i_1 = defers.size(); i_1-- > 0; )
    {
        s_SolvedNode* _0;
        (_0 = &(only_n3dv4p6e(node.items.mutref(defers[i_1]).items)), bck_node_gDsnGKHT(*_0, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
    };
    _current_fn.TODO_FIX_bckCantDealWithNestedDefers = TODO_FIX_nesteDefers0;
}

static void bck_node_gDsnGKHT(s_SolvedNode& node, const s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const s_Kind k = node.kind;
    if (k == s_Kind_call)
        bck_call_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_loop)
        bck_loop_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_letdef)
    {
        std::swap(GET_mut_gDsnGKHT(node.target, ss, module).solved, node);
        bck_node_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
        std::swap(GET_mut_gDsnGKHT(node.target, ss, module).solved, node);
    }
    else if (k == s_Kind_let)
        bck_let_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_if)
    {
        bck_if_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else if ((k == s_Kind_and) || (k == s_Kind_or))
        bck_and_or_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_not)
        bck_not_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_block)
        bck_block_gDsnGKHT(node, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if ((k == s_Kind_root) || (k == s_Kind_jump) || (k == s_Kind_try) || (k == s_Kind_copy) || (k == s_Kind_move) || (k == s_Kind_arrlit))
    {
        fu::view_mut<s_SolvedNode> items = node.items;
        for (int i = 0; i < items.size(); i++)
        {
            s_SolvedNode* _0;
            (_0 = &(items.mutref(i)), bck_node_gDsnGKHT(*_0, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options));
        };
        if (k == s_Kind_jump)
        {
            const s_HelpersData* BL_13_v;
            if ((__extension__ (
            {
                const s_Helpers& h = node.helpers;
                BL_13_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
            (void)0;}), *BL_13_v).postevt)
            {
                s_HelpersData* BL_15_v;
                Events_merge_gDsnGKHT((__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_15_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_15_v).postevt, _current_fn.events.snap);
            }
            else
            {
                s_HelpersData* BL_17_v;
                (__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_17_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_17_v).postevt = s_EventsSnap(_current_fn.events.snap);
            };
            if (!_current_fn.TODO_FIX_bckCantDealWithNestedDefers)
            {
                const s_HelpersData* BL_19_v;
                int _1 {};
                Events_restore_gDsnGKHT(_current_fn.events, (*(const s_EventsSnap*)fu::NIL), ((_1 = (__extension__ (
                {
                    const s_Helpers& h = node.helpers;
                    BL_19_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
                (void)0;}), *BL_19_v).postdom.write_loop_start) ? _1 : BUG_gDsnGKHT("bck_node(jump): helpers.postdom.write_loop_start not set."_fu, ss, _helpers, _here, ctx, module, options)), _here, ctx);
            };
        };
    }
    else if (k == s_Kind_pragma)
    {
        for (int i = 0; i < node.items.size(); i++)
        {
            s_SolvedNode& item = node.items.mutref(i);
            bck_node_gDsnGKHT(item, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (is_mutref_9CJmuVSD(item.type, _here, ctx))
            {
                _here = item.token;
                bck_trackWrites_gDsnGKHT(node, item.type.lifetime, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    }
    else if (node.items)
        BUG_gDsnGKHT(x7E_3lDd4lqo("bck: Unexpected "_fu, str_WkqQ7QhO(k)), ss, _helpers, _here, ctx, module, options);

}

static void PASS_borrowCheck_gDsnGKHT(s_SolvedNode& root, const s_BorrowCheckPass pass, s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    bck_node_gDsnGKHT(root, root, pass, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_Lifetime_each_Cg3tOweX8J6
                                #define DEF_Lifetime_each_Cg3tOweX8J6
inline void Lifetime_each_Cg3tOweX(const s_Lifetime& lifetime, bool& notPointless, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        const int locid = ((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v));
        if (!(!locid))
        {
            bool BL_12_v {};
            if ((__extension__ (
            {
                const s_LocidMap_DC5gktNgm89& map = _current_fn.postdom.snap.ever_written;
                BL_12_v = (!!iF_51ChLTxy(map, locid, _current_fn));
            (void)0;}), BL_12_v))
                notPointless = true;
            else if (!(locid < 0))
            {
                verifyCopyNotRedundant_gDsnGKHT(GET_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _here, ctx, module).solved.type.lifetime, notPointless, _current_fn, ss, _here, ctx, module);
            };
            if (notPointless)
                return;

        };
    };
}
                                #endif

static void verifyCopyNotRedundant_gDsnGKHT(const s_Lifetime& lt, bool& notPointless, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    Lifetime_each_Cg3tOweX(lt, notPointless, _current_fn, ss, _here, ctx, module);
}

                                #ifndef DEF___XiqmAHqjsX0
                                #define DEF___XiqmAHqjsX0
inline static void _XiqmAHqj(const int locid, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Overload& o = GET_mut_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, module);
    if (is_ref_9CJmuVSD(o.solved.type))
    {
        bool notPointless = false;
        verifyCopyNotRedundant_gDsnGKHT(o.solved.type.lifetime, notPointless, _current_fn, ss, _here, ctx, module);
        if (notPointless)
            o.solved.type = clear_refs_9CJmuVSD(s_Type(o.type));

    }
    else
        BUG_gDsnGKHT("PASS_BCK_applyCopies: not a ref"_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF___RvVenQeTBBk
                                #define DEF___RvVenQeTBBk
inline static void _RvVenQeT(const int locid, const int args_neg, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    _XiqmAHqj((locid - args_neg), _current_fn, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_2TkPnCZ3kuj
                                #define DEF_each_2TkPnCZ3kuj
inline void each_2TkPnCZ3(const s_BitSet& _, const int args_neg, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < _._data.size(); i++)
    {
        const fu::u8 item = _._data[i];
        if (item)
        {
            for (int b = 0; b < 8; b++)
            {
                const fu::u8 mask = fu::u8((fu::u8(1u) << fu::u8(unsigned(b))));
                if (item & mask)
                    _RvVenQeT(((i << 3) | int(b)), args_neg, _current_fn, ss, _helpers, _here, ctx, module, options);

            };
        };
    };
}
                                #endif

                                #ifndef DEF_each_5vSHFmAu6X4
                                #define DEF_each_5vSHFmAu6X4
inline static void each_5vSHFmAu(const s_LocidSet& set, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int args_neg = _current_fn.args_neg;
    each_2TkPnCZ3(set._bitset, args_neg, _current_fn, ss, _helpers, _here, ctx, module, options);
}
                                #endif

static void PASS_BCK_applyCopies_gDsnGKHT(const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    each_5vSHFmAu(_current_fn.flow.bck_consider_copy, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF___o7PvBAfwqY5
                                #define DEF___o7PvBAfwqY5
inline static void _o7PvBAfw(const s_Target& target, s_Lifetime& consts, s_Lifetime& refs, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v))
    {
        const s_Type& type = GET_gDsnGKHT(target, ss, _here, ctx, module).solved.type;
        int BL_3_v {};
        s_Lifetime region = Lifetime_AAR_7Yz9ezW2((__extension__ (
        {
            const unsigned v = unsigned((target._packed & 0xfffffull));
            BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_3_v), _here, ctx);
        if (!(!Lifetime_getRefLocid_unlessStatic_gDsnGKHT(region, ss, _helpers, _here, ctx, module, options)))
        {
            bool BL_5_v {};
            if (is_mutref_9CJmuVSD(type, _here, ctx) && (__extension__ (
            {
                int BL_6_v {};
                const int locid = (__extension__ (
                {
                    const unsigned v = unsigned((target._packed & 0xfffffull));
                    BL_6_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
                (void)0;}), BL_6_v);
                const s_LocidMap_DC5gktNgm89& map = _current_fn.postdom.snap.ever_written;
                BL_5_v = (!!iF_51ChLTxy(map, locid, _current_fn));
            (void)0;}), BL_5_v))
            {
                Lifetime_add_7Yz9ezW2(refs, region, false, _here, ctx);
            }
            else if (is_ref_9CJmuVSD(type) && !willPassByValue_FDl5ha9X(GET_gDsnGKHT(target, ss, _here, ctx, module), _here, ctx))
            {
                Lifetime_add_7Yz9ezW2(consts, region, false, _here, ctx);
            };
        };
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF__current_fn_eachArg_FWD_VKdYF3VGiWb
                                #define DEF__current_fn_eachArg_FWD_VKdYF3VGiWb
inline static void _current_fn_eachArg_FWD_VKdYF3VG(s_Lifetime& consts, s_Lifetime& refs, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
    {
        const s_Target& t = _current_fn.out.items[i].target;
        if (t)
        {
            int BL_4_v {};
            if ((__extension__ (
            {
                const unsigned v = unsigned((t._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v) < 0)
                _o7PvBAfw(t, consts, refs, _current_fn, ss, _helpers, _here, ctx, module, options);
            else
            {
                BUG_u9Gbkniv(fu::str{}, _here, ctx);
            };
        };
    };
}
                                #endif

                                #ifndef DEF___xYm4D8VcVPk
                                #define DEF___xYm4D8VcVPk
inline static void _xYm4D8Vc(const int locid, int& refs_len, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (locid)
        refs_len++;
    else
        BUG_gDsnGKHT("AAR: refs contains non-locals"_fu, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_Lifetime_each_MYNJCxp1ad4
                                #define DEF_Lifetime_each_MYNJCxp1ad4
inline void Lifetime_each_MYNJCxp1(const s_Lifetime& lifetime, int& refs_len, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _xYm4D8Vc(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), refs_len, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void clear_wyx7msfr(s_Flow& flow)
{
    if (flow.at_hard_risk || flow.at_soft_risk)
        fu::fail("Flow.clear(): Non-empty at-risk tables."_fu);
    else
    {

        {
            s_LocidMap_93S9qlGbUSi& map = flow.rg_parents;
            map._values.clear();
        };

        {
            s_LocidMap_93S9qlGbUSi& map = flow.rg_invalidates;
            map._values.clear();
        };

        {
            s_LocidMap_OjaSaYAvjq2& map = flow.rg_children;
            map._values.clear();
        };

        {
            s_LocidMap_I7YkM5C62o7& map = flow.at_soft_risk;
            map._values.clear();
        };

        {
            s_LocidMap_I7YkM5C62o7& map = flow.at_hard_risk;
            map._values.clear();
        };

        {
            s_LocidSet& set = flow.bck_consider_copy;
            clear_ZwXYCruz(set._bitset);
        };

        {
            s_LocidSet& set = flow.is_arg;
            clear_ZwXYCruz(set._bitset);
        };

        {
            s_LocidMap_OjaSaYAvjq2& map = flow.arg_parents;
            map._values.clear();
        };
        flow.arg_targets.clear();
    };
}

static void clear_gDsnGKHT(s_Events& events)
{
    events = s_Events{};
}

                                #ifndef DEF___OSQ50rU59Hb
                                #define DEF___OSQ50rU59Hb
inline static void _OSQ50rU5(const s_Target& target, const int position, s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int BL_1_v {};
    if (int(unsigned(((target._packed >> 20ull) & 0xfffffull))) == (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v))
    {
        int BL_3_v {};
        const int target_1 = (__extension__ (
        {
            const unsigned v = unsigned((target._packed & 0xfffffull));
            BL_3_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_3_v);
        if ((_current_fn.flow.arg_targets.size() <= position))
        {
            _current_fn.flow.arg_targets.grow((position + 1));
            _current_fn.flow.arg_targets.mutref(position) = target_1;
            add_gDsnGKHT(_current_fn.flow.is_arg, target_1, _current_fn);
        }
        else
            BUG_gDsnGKHT("Reference_trackArgument: positions out of order."_fu, ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("Arg target not local to current-fn: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF__current_fn_eachArg_FWD_h9Mc8yP1rh1
                                #define DEF__current_fn_eachArg_FWD_h9Mc8yP1rh1
inline static void _current_fn_eachArg_FWD_h9Mc8yP1(s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
    {
        const s_Target& t = _current_fn.out.items[i].target;
        if (t)
        {
            int BL_4_v {};
            if ((__extension__ (
            {
                const unsigned v = unsigned((t._packed & 0xfffffull));
                BL_4_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_4_v) < 0)
                _OSQ50rU5(t, i, _current_fn, ss, _helpers, _here, ctx, module, options);
            else
            {
                BUG_u9Gbkniv(fu::str{}, _here, ctx);
            };
        };
    };
}
                                #endif

                                #ifndef DEF___NPD2mHMGWna
                                #define DEF___NPD2mHMGWna
inline static void _NPD2mHMG(const int target, const s_Lifetime& other_refs, const s_Lifetime& consts, s_Flow& flow, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (target)
    {
        if (consts)
        {
            s_Lifetime* _0;
            (!*(_0 = &(ensure_xVGIzXEN(flow.rg_invalidates, target, _current_fn))) ? *_0 : BUG_gDsnGKHT("AAR: ref arg already has invalidates."_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime(consts);
        };
        if (other_refs)
        {
            Lifetime_add_7Yz9ezW2(ensure_xVGIzXEN(flow.rg_invalidates, target, _current_fn), other_refs, false, _here, ctx);
        };
        if (consts || other_refs)
        {
            const s_Lifetime* _1;
            s_Lifetime* _2;
            (!*(_2 = &(ensure_xVGIzXEN(flow.rg_parents, target, _current_fn))) ? *_2 : BUG_gDsnGKHT("AAR: ref arg already has parents."_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime((*(_1 = &(iF_jKub7rek(flow.rg_invalidates, target, _current_fn))) ? *_1 : BUG_gDsnGKHT("AAR: (refs.len > 1 || consts), but no invalidates."_fu, ss, _helpers, _here, ctx, module, options)));
        };
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_RVm4RQl9J45
                                #define DEF_Lifetime_each_RVm4RQl9J45
inline void Lifetime_each_RVm4RQl9(const s_Lifetime& lifetime, const s_Lifetime& consts, s_Flow& flow, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const int offset0 = offset;
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _NPD2mHMG(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), s_Lifetime { (fu::get_view_start0(chars, offset0) + fu::get_view(chars, offset)) }, consts, flow, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF___IxoknSz4Cca
                                #define DEF___IxoknSz4Cca
inline static void _IxoknSz4(const int target, const s_Lifetime& refs, s_Flow& flow, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (target)
    {
        s_Lifetime* _0;
        (!*(_0 = &(ensure_xVGIzXEN(flow.rg_invalidates, target, _current_fn))) ? *_0 : BUG_gDsnGKHT("AAR: const arg already has invalidates."_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime(refs);
        s_Lifetime* _1;
        (!*(_1 = &(ensure_xVGIzXEN(flow.rg_parents, target, _current_fn))) ? *_1 : BUG_gDsnGKHT("AAR: const arg already has parents."_fu, ss, _helpers, _here, ctx, module, options)) = s_Lifetime(refs);
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_5e8lAbACdv1
                                #define DEF_Lifetime_each_5e8lAbACdv1
inline void Lifetime_each_5e8lAbAC(const s_Lifetime& lifetime, const s_Lifetime& refs, s_Flow& flow, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _IxoknSz4(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), refs, flow, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static bool PASS_AAR_prepare_gDsnGKHT(s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Lifetime consts {};
    s_Lifetime refs {};
    _current_fn_eachArg_FWD_VKdYF3VG(consts, refs, _current_fn, ss, _helpers, _here, ctx, module, options);
    int refs_len = 0;
    Lifetime_each_MYNJCxp1(refs, refs_len, ss, _helpers, _here, ctx, module, options);
    if (!refs_len || ((refs_len == 1) && !consts))
        return false;
    else
    {
        clear_wyx7msfr(_current_fn.flow);
        clear_gDsnGKHT(_current_fn.events);
        _current_fn_eachArg_FWD_h9Mc8yP1(_current_fn, ss, _helpers, _here, ctx, module, options);
        s_Flow& flow = _current_fn.flow;
        Lifetime_each_RVm4RQl9(refs, consts, flow, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (refs)
        {
            Lifetime_each_5e8lAbAC(consts, refs, flow, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        if (refs)
        {
            _current_fn.events = s_Events{};
            return true;
        }
        else
            BUG_gDsnGKHT("Wasting time on AAR without ref args."_fu, ss, _helpers, _here, ctx, module, options);

    };
}

static void runAllPasses_gDsnGKHT(s_SolvedNode& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (_current_fn)
    {
        if (currentFn_mustBecomeInline_gDsnGKHT(_current_fn))
            return;
        else if (GET_gDsnGKHT(_current_fn.out.target, ss, _here, ctx, module).status & s_SolverStatus_SS_Debug_AllPassesComplete)
            BUG_gDsnGKHT("runAllPasses: All passes already complete."_fu, ss, _helpers, _here, ctx, module, options);
        else
            _current_fn.args_neg = EXT_gDsnGKHT(_current_fn.out.target, ss, ctx, module).args_neg;

    };
    fu_DEFER(if (_current_fn)
    {
        if (_current_fn.args_neg == EXT_gDsnGKHT(_current_fn.out.target, ss, ctx, module).args_neg)
            _current_fn.args_neg = 0;
        else
        {
            BUG_gDsnGKHT("runAllPasses: args_neg drifted"_fu, ss, _helpers, _here, ctx, module, options);
        };
    });
    const s_HelpersData* BL_8_v;
    TEST_pass_gDsnGKHT(node, (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_8_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_8_v).pass, false, _current_fn, ss, _helpers, _here, ctx, module, options);

    {
        s_HelpersData* BL_10_v;
        (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_10_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_10_v).pass = s_SolverPass_RelaxMut;
        if (_current_fn.relaxed.var_usage)
            BUG_gDsnGKHT("_current_fn.var_usage not empty before propagateType."_fu, ss, _helpers, _here, ctx, module, options);
        else if (_current_fn.postdom)
            BUG_gDsnGKHT("_current_fn.postdom not empty before propagateType."_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            Postdom_resetAtFnEnd_gDsnGKHT(_current_fn.postdom);
            propagateType_gDsnGKHT(node, s_Type(node.type), RELAX_before_bck, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (_current_fn.postdom.read_loop_start == NO_LOOP)
            {
                if (!(_current_fn.postdom.write_loop_start == NO_LOOP))
                    BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxMut.end: write_loop_start("_fu, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

            }
            else
                BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxMut.end: read_loop_start("_fu, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

        };
    };
    const s_HelpersData* BL_17_v;
    TEST_pass_gDsnGKHT(node, (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_17_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_17_v).pass, true, _current_fn, ss, _helpers, _here, ctx, module, options);

    {
        s_HelpersData* BL_19_v;
        (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_19_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_19_v).pass = s_SolverPass_BorrowCheck;
        PASS_borrowCheck_gDsnGKHT(node, s_BorrowCheckPass_BCK_bck, _current_fn, ss, _helpers, _here, ctx, module, options);
        PASS_BCK_applyCopies_gDsnGKHT(_current_fn, ss, _helpers, _here, ctx, module, options);
    };

    {
        s_HelpersData* BL_21_v;
        (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_21_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_21_v).pass = s_SolverPass_ArgumentsAtRisk;
        _current_fn.TODO_FIX_children = _current_fn.flow.rg_children;
        if (PASS_AAR_prepare_gDsnGKHT(_current_fn, ss, _helpers, _here, ctx, module, options))
            PASS_borrowCheck_gDsnGKHT(node, s_BorrowCheckPass_BCK_aar, _current_fn, ss, _helpers, _here, ctx, module, options);

    };
    const s_HelpersData* BL_23_v;
    TEST_pass_gDsnGKHT(node, (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_23_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_23_v).pass, false, _current_fn, ss, _helpers, _here, ctx, module, options);

    {
        s_HelpersData* BL_25_v;
        (__extension__ (
        {
            const s_Helpers& h = node.helpers;
            BL_25_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_25_v).pass = s_SolverPass_RelaxCopyResize;
        _current_fn.effects.fx_mask = s_FxMask{};
        _current_fn.relaxed = s_VarUsage{};
        if (_current_fn.postdom.read_loop_start == NO_LOOP)
        {
            if (_current_fn.postdom.write_loop_start == NO_LOOP)
            {
                Postdom_resetAtFnEnd_gDsnGKHT(_current_fn.postdom);
                propagateType_gDsnGKHT(node, s_Type(node.type), RELAX_all, s_Helpers{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                if (_current_fn.postdom.read_loop_start == NO_LOOP)
                {
                    if (!(_current_fn.postdom.write_loop_start == NO_LOOP))
                        BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxCopyResize.end: write_loop_start("_fu, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                }
                else
                    BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxCopyResize.end: read_loop_start("_fu, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

            }
            else
                BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxCopyResize: write_loop_start("_fu, fu::i64dec(_current_fn.postdom.write_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

        }
        else
            BUG_gDsnGKHT((x7E_3lDd4lqo("RelaxCopyResize: read_loop_start("_fu, fu::i64dec(_current_fn.postdom.read_loop_start)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

    };
    const s_HelpersData* BL_33_v;
    TEST_pass_gDsnGKHT(node, (__extension__ (
    {
        const s_Helpers& h = node.helpers;
        BL_33_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
    (void)0;}), *BL_33_v).pass, true, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (_current_fn)
    {
        if (currentFn_mustBecomeInline_gDsnGKHT(_current_fn))
            BUG_gDsnGKHT("runAllPasses: currentFn_mustBecomeInline after all."_fu, ss, _helpers, _here, ctx, module, options);
        else
            GET_mut_gDsnGKHT(_current_fn.out.target, ss, module).status |= s_SolverStatus_SS_Debug_AllPassesComplete;

    };
}

                                #ifndef DEF_str_DY6GhqTZ7Hc
                                #define DEF_str_DY6GhqTZ7Hc
inline fu::str str_DY6GhqTZ(const s_FxMask n)
{
    /*MOV*/ fu::str res {};

    {
        if (n & s_FxMask_Fx_NotDeadCode)
            res += ("Fx_NotDeadCode"_fu + ", "_fu);

        if (n & s_FxMask_Fx_NonDeterministic)
            res += ("Fx_NonDeterministic"_fu + ", "_fu);

        if (n & s_FxMask_Fx_DontMoveUp)
            res += ("Fx_DontMoveUp"_fu + ", "_fu);

        if (n & s_FxMask_Fx_DontMoveDown)
            res += ("Fx_DontMoveDown"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Input)
            res += ("Fx_Input"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Output)
            res += ("Fx_Output"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Throws)
            res += ("Fx_Throws"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Crashes)
            res += ("Fx_Crashes"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Crashes_Div0)
            res += ("Fx_Crashes_Div0"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Crashes_OOB)
            res += ("Fx_Crashes_OOB"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Crashes_Assert)
            res += ("Fx_Crashes_Assert"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Crashes_Exit)
            res += ("Fx_Crashes_Exit"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Syscall)
            res += ("Fx_Syscall"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Blocks)
            res += ("Fx_Blocks"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Blocks_Alloc)
            res += ("Fx_Blocks_Alloc"_fu + ", "_fu);

        if (n & s_FxMask_Fx_Blocks_Await)
            res += ("Fx_Blocks_Await"_fu + ", "_fu);

    };
    if (res)
        res.shrink((res.size() - 2));

    return /*NRVO*/ res;
}
                                #endif

static void TEST_FunctionNarrowing_gDsnGKHT(const s_Target& wider, const s_Target& narrower, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<s_Argument> w_args = EXT_gDsnGKHT(wider, ss, ctx, module).args;
    fu::view<s_Argument> n_args = EXT_gDsnGKHT(narrower, ss, ctx, module).args;
    if (w_args.size() == n_args.size())
    {
        for (int i = 0; i < w_args.size(); i++)
        {
            const s_Argument& w = w_args[i];
            const s_Argument& n = n_args[i];
            if (w.name == n.name)
            {

                {
                    s_Type host { n.type };
                    const s_Type& guest = w.type;
                    const bool asArgument = false;
                    if (!(isAssignable_9CJmuVSD(host, guest, false, asArgument, _here, ctx)))
                        BUG_gDsnGKHT((((x7E_3lDd4lqo("n.type !<- w.type ("_fu, str_wyx7msfr(n, false, _current_fn, ss, _here, ctx, module, options)) + ")"_fu) + ": "_fu) + explainNotAssignable_gDsnGKHT(host, guest, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

                };
                const unsigned uNion = (n.written_to | w.written_to);
                if (uNion == w.written_to)
                {
                    if (has_missing_ZwXYCruz(n.may_invalidate, w.may_invalidate))
                        BUG_gDsnGKHT((x7E_3lDd4lqo("n.may_invalidate less ("_fu, str_wyx7msfr(n, false, _current_fn, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);
                    else if (has_missing_ZwXYCruz(n.may_alias, w.may_alias))
                        BUG_gDsnGKHT((x7E_3lDd4lqo("n.may_alias less ("_fu, str_wyx7msfr(n, false, _current_fn, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                }
                else
                    BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("n.written_to("_fu, fu::u64dec(n.written_to)) + ") w.written_to("_fu), fu::u64dec(w.written_to)) + ") union("_fu), fu::u64dec(uNion)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

            }
            else
                BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("w.name("_fu, str_wyx7msfr(w, false, _current_fn, ss, _here, ctx, module, options)) + ") == n.name("_fu), str_wyx7msfr(n, false, _current_fn, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

        };
        const s_FxMask w_fx = EXT_gDsnGKHT(wider, ss, ctx, module).fx_mask;
        const s_FxMask n_fx = EXT_gDsnGKHT(narrower, ss, ctx, module).fx_mask;
        if (!(s_FxMask((n_fx & w_fx)) == n_fx))
            BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("n_fx("_fu, str_DY6GhqTZ(n_fx)) + ") !<= w_fx("_fu), str_DY6GhqTZ(w_fx)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

    }
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("w_args("_fu, fu::i64dec(w_args.size())) + ") != n_args("_fu), fu::i64dec(n_args.size())) + ")"_fu), ss, _helpers, _here, ctx, module, options);

}

static void doReverseSpecialize_gDsnGKHT(const s_Target& target, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_RevSpecInstance& instance = EPH_gDsnGKHT(target, ss, module).rev_spec.instance;
    const s_Target original { instance.original };
    const unsigned relaxed_quals = instance.relaxed_quals;
    const s_RevSpecPrototype& prototype = EPH_gDsnGKHT(original, ss, module).rev_spec.prototype;
    s_SolvedNode solved { (prototype.solved ? prototype.solved : BUG_gDsnGKHT("doReverseSpecialize: no rev_spec.prototype.solved"_fu, ss, _helpers, _here, ctx, module, options)) };
    /*MOV*/ fu::vec<s_Overload> args_n_locals { prototype.args_n_locals };
    const int args_neg = prototype.args_neg;
    const int helpers0 = _helpers.size();
    const int helpers_data0 = ss._helpers_data.size();
    s_CurrentFn current_fn0 = steal_07W3lQmY(_current_fn);
    const s_Target solvingFnort0 = exchange_EqG2aXiz(ss._solvingFnort, s_Target(target));
    const s_Target nestingFnort0 = exchange_EqG2aXiz(ss._nestingFnort, s_Target(target));
    fu_DEFER(
    {
        _helpers.shrink(helpers0);
        ss._helpers_data.shrink(helpers_data0);
        std::swap(current_fn0, _current_fn);
        ss._solvingFnort = solvingFnort0;
        ss._nestingFnort = nestingFnort0;
    });

    {
        fu::vec<s_Helpers> helpersReplicas {};
        int lastKnownLocal {};
        relinkNode_gDsnGKHT(solved, target, original, args_n_locals, args_neg, helpersReplicas, lastKnownLocal, _current_fn, ss, _helpers, _here, ctx);
    };

    {
        s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
        ext.args_n_locals = static_cast<fu::vec<s_Overload>&&>(args_n_locals);
        ext.args_neg = args_neg;
    };
    GET_mut_gDsnGKHT(target, ss, module).status &= s_SolverStatus(~s_SolverStatus_SS_Debug_AllPassesComplete);

    {
        solved.target = target;
        s_SolvedNode& n_body = last_fjKdEPCD(solved.items);
        s_HelpersData* BL_5_v;
        (__extension__ (
        {
            const s_Helpers& h = n_body.helpers;
            BL_5_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_5_v).target = s_Target(target);
        s_HelpersData* BL_6_v;
        (__extension__ (
        {
            const s_Helpers& h = n_body.helpers;
            BL_6_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data.mutref(h.index) : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_6_v).mask = s_HelpersMask_HM_Function;
        s_Type slot = s_Type { s_ValueType { n_body.type.vtype.quals, {}, {} }, {} };
        force_relax_9CJmuVSD(slot, relaxed_quals);
        const unsigned did_relax = try_relax_9CJmuVSD(n_body.type, slot, relaxed_quals);
        if (!(did_relax == relaxed_quals))
            BUG_gDsnGKHT((x7E_3lDd4lqo(((x7E_3lDd4lqo("doReverseSpecialize: did_relax("_fu, fu::u64dec(did_relax)) + ")"_fu) + " != relaxed_quals("_fu), fu::u64dec(relaxed_quals)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

    };
    /*MOV*/ s_Type retval {};

    {
        s_SolvedNode n_body = steal_46agKNQY(last_fjKdEPCD(solved.items));
        std::swap(_current_fn.out, solved);
        runAllPasses_gDsnGKHT(n_body, _current_fn, ss, _helpers, _here, ctx, module, options);
        const s_HelpersData* BL_9_v;
        retval = (__extension__ (
        {
            const s_Helpers& h = n_body.helpers;
            BL_9_v = &((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)));
        (void)0;}), *BL_9_v).ret_actual;
        if (retval.vtype.quals & relaxed_quals)
            BUG_gDsnGKHT("reported retval intersects relaxed_quals"_fu, ss, _helpers, _here, ctx, module, options);
        else
            std::swap(last_fjKdEPCD(_current_fn.out.items), n_body);

    };
    doUpdateScope_gDsnGKHT(static_cast<s_Type&&>(retval), target, true, false, false, s_DeclAsserts{}, _current_fn, ss, _helpers, _here, ctx, module, options);
    TEST_FunctionNarrowing_gDsnGKHT(original, target, _current_fn, ss, _helpers, _here, ctx, module, options);
    lazySolveEnd_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static bool lazySolveStart_gDsnGKHT(const s_Target& target, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (s_SolverStatus((GET_gDsnGKHT(target, ss, _here, ctx, module).status & s_SolverStatus((s_SolverStatus_SS_DID_START | s_SolverStatus_SS_LAZY)))) != s_SolverStatus_SS_LAZY)
        return false;
    else
    {
        s_Overload& o = GET_mut_gDsnGKHT(target, ss, module);
        if (o.status & s_SolverStatus((s_SolverStatus((s_SolverStatus_SS_FINALIZED | s_SolverStatus_SS_DID_START)) | s_SolverStatus_SS_DIRTY)))
            BUG_gDsnGKHT(x7E_3lDd4lqo("SS_DID_START: non-zero solver status: "_fu, str_tqiEnBQ6(o.status)), ss, _helpers, _here, ctx, module, options);
        else
        {
            o.status |= s_SolverStatus_SS_DID_START;
            if ((o.kind == s_Kind_fn) || (o.kind == s_Kind_inline) || (o.kind == s_Kind_template))
            {
                fu::str error = ""_fu;
                if (EPH_gDsnGKHT(target, ss, module).rev_spec.instance.original)
                    doReverseSpecialize_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options);
                else
                {
                    doTrySpecialize_gDsnGKHT(EPH_gDsnGKHT(target, ss, module).local_of, error, target, s_Target{}, fu::view<s_SolvedNode>{}, (*(const fu::str*)fu::NIL), (*(const s_Reorder*)fu::NIL), fu::view<fu::vec<s_Target>>{}, 0, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
                };
            }
            else if (o.kind == s_Kind_type)
                __solveStruct_gDsnGKHT(true, s_Node(EXT_gDsnGKHT(target, ss, ctx, module).tEmplate.node), target, false, _current_fn, ss, _helpers, _here, ctx, module, options);
            else
                BUG_gDsnGKHT((x7E_3lDd4lqo("lazySolveStart: kind is `"_fu, str_WkqQ7QhO(o.kind)) + "`."_fu), ss, _helpers, _here, ctx, module, options);

            return true;
        };
    };
}

static void ensureLazySolved_gDsnGKHT(const s_Target& target, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    int repeats = 0;
    while (lazySolveStart_gDsnGKHT(target, _current_fn, ss, _helpers, _here, ctx, module, options))
    {
        if (repeats++ > 1000)
            BUG_gDsnGKHT(x7E_3lDd4lqo("Repeat-solved too many times: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

    };
}

static fu::str str_q5Q6zgXB(const int min, const int max)
{
    if (min != max)
        return x7E_3lDd4lqo((x7E_3lDd4lqo("["_fu, fu::i64dec(min)) + " upto "_fu), fu::i64dec(max)) + "]"_fu;
    else
        return fu::i64dec(min);

}

static void reorderByNumUsings_gDsnGKHT(s_Reorder& reorder, fu::view<s_Argument> host_args, const int num_args, const int num_usings)
{
    reorder.map.clear();
    if (num_usings)
    {
        for (int i = 0; i < host_args.size(); i++)
        {
            const int x = (i - num_usings);
            reorder.map.push((((x >= 0) && (x < num_args)) ? x : -1));
        };
    };
    reorder.applicable = !!reorder.map;
}

                                #ifndef DEF_iF_AFpkFfBBzLd
                                #define DEF_iF_AFpkFfBBzLd
inline int iF_AFpkFfBB(fu::view<int> a, const int i, const int eLse)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return eLse;

}
                                #endif

                                #ifndef DEF_each_qM0HDSpF9G6
                                #define DEF_each_qM0HDSpF9G6
inline void each_qM0HDSpF(fu::view<s_Argument> a, const s_Reorder& reorder, fu::str& error, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_Argument& host_arg = a[i];
        const int i_1 = i;
        const int callsiteIndex = iF_AFpkFfBB(reorder.map, i_1, -1);
        if (callsiteIndex < 0)
        {
            error += (x7E_3lDd4lqo(("\n\n\t\tExpected "_fu + (host_arg.dEfault ? "optional "_fu : fu::str{})), str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options)) + " not provided."_fu);
            return;
        };
    };
}
                                #endif

                                #ifndef DEF___4dhajlcevgj
                                #define DEF___4dhajlcevgj
inline static bool _4dhajlce(const s_Argument& a, fu::view<char> name)
{
    return a.name == name;
}
                                #endif

                                #ifndef DEF_some_cDz6NZQ5Y62
                                #define DEF_some_cDz6NZQ5Y62
inline bool some_cDz6NZQ5(fu::view<s_Argument> a, fu::view<char> name)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_Argument& item = a[i];
        if (_4dhajlce(item, name))
            return true;

    };
    return false;
}
                                #endif

                                #ifndef DEF_each_e5mqBZ6OTFi
                                #define DEF_each_e5mqBZ6OTFi
inline void each_e5mqBZ6O(fu::view<fu::str> a, fu::view<s_Argument> host_args, fu::str& error)
{
    for (int i = 0; i < a.size(); i++)
    {
        const fu::str& name = a[i];
        if (name && !some_cDz6NZQ5(host_args, name))
        {
            error += (((("\n\n\t\tOptional :named argument mismatch: no "_fu + qBAD_KW_e44UlzzA("arg"_fu)) + " "_fu) + qBAD_e44UlzzA(name)) + "."_fu);
            return;
        };
    };
}
                                #endif

static fu::str ERRMSG_optionalArgumentAmbiguity_gDsnGKHT(fu::view<s_Argument> host_args, const s_Reorder& reorder, fu::view<fu::str> names, const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::str error = "Optional argument ambiguity:"_fu;
    each_qM0HDSpF(host_args, reorder, error, _current_fn, ss, _here, ctx, module, options);
    each_e5mqBZ6O(names, host_args, error);
    return static_cast<fu::str&&>((error += "\n\n\t\tCannot distinguish from a typo."_fu));
}

                                #ifndef DEF_ensure_wODKBuHQZh0
                                #define DEF_ensure_wODKBuHQZh0
inline fu::vec<s_Target>& ensure_wODKBuHQ(fu::vec<fu::vec<s_Target>>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

static const s_Node& annot_gDsnGKHT(const s_Target& overloadIdx, const int host_argIdx, const s_SolverState& ss, const s_Context& ctx, const s_Module& module)
{
    return EXT_gDsnGKHT(overloadIdx, ss, ctx, module).tEmplate.node.items[host_argIdx].items[LET_TYPE];
}

                                #ifndef DEF_tryConvert_k6rrQ6kn9Wc
                                #define DEF_tryConvert_k6rrQ6kn9Wc
inline static fu::vec<s_Target> tryConvert_k6rrQ6kn(const s_Node& expect, const s_Type& actual, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<s_Target> match {};
    s_ConvCache_ColsAndBakes BL_1_v {};
    s_ConvCache_ColsAndBakes cc = (__extension__ (
    {
        const s_ConvCache_ColsAndBakes& __partcopy_ref = exploreConversions_FDl5ha9X(actual.vtype, _current_fn, ss, _helpers, _here, ctx, module, options);
        BL_1_v = (s_ConvCache_ColsAndBakes { s_ConvCacheColumns(__partcopy_ref.columns), {}, {} });
    (void)0;}), static_cast<s_ConvCache_ColsAndBakes&&>(BL_1_v));
    for (int i = 0; i < cc.columns.types.size(); i++)
    { {
        const s_ValueType& convertType = cc.columns.types[i];
        bool BL_4_v {};
        if ((__extension__ (
        {
            fu::str error = ""_fu;
            s_Map_lhf7SV3Fyjf tp = steal_HPql5iRS(ss._typeParams);
            fu_DEFER(std::swap(ss._typeParams, tp));
            BL_4_v = (trySolveTypeParams_gDsnGKHT(expect, s_Type { s_ValueType(convertType), s_Lifetime(Lifetime_temporary) }, error, false, _current_fn, ss, _helpers, _here, ctx, module, options));
        (void)0;}), BL_4_v))
        {
            const fu::vec<s_Target>& path = cc.columns.paths[i];
            fu::view<int> ms = cc.columns.must_see[i];
            for (int i_1 = 0; i_1 < ms.size(); i_1++)
            {
                const int ms_1 = ms[i_1];
                const bool isUsing = (ms_1 < 0);
                const int index = ((isUsing ? -ms_1 : +ms_1) - 1);
                fu::view<s_ScopeSkip> skips = (isUsing ? ss._ss.usings : ss._ss.converts);
                fu::view<s_Target> which = (isUsing ? ss._scope.usings : ss._scope.converts);
                if ((index >= 0) && (index < which.size()))
                {
                    for (int i_2 = 0; i_2 < skips.size(); i_2++)
                    {
                        const s_ScopeSkip& skip = skips[i_2];
                        if ((skip.start <= index) && (skip.end > index))
                            goto BL_3;

                    };
                }
                else
                    BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("ConvCache.must_see ms("_fu, fu::i64dec(ms_1)) + ") isUsing("_fu), fu::booldec(isUsing)) + ") index("_fu), fu::i64dec(index)) + ") is out of bounds("_fu), fu::i64dec(which.size())) + ")"_fu), ss, _helpers, _here, ctx, module, options);

            };
            if (match)
            {
                fu::str suffix = ((("\n"_fu + explainConversion_gDsnGKHT(match, fu::view<char>{}, _current_fn, ss, _here, ctx, module, options)) + "\n\tand:\n"_fu) + explainConversion_gDsnGKHT(path, fu::view<char>{}, _current_fn, ss, _here, ctx, module, options));
                if (actual)
                {
                    fail_gDsnGKHT(((((("Conversion ambiguity, multiple ways to convert "_fu + explainType_gDsnGKHT(actual, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " into "_fu) + "[TODO pattern str]"_fu) + ":"_fu) + suffix), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    fail_gDsnGKHT(((((qBAD_e44UlzzA("using"_fu) + " ambiguity, multiple ways to obtain a "_fu) + "[TODO pattern str]"_fu) + " in this scope:"_fu) + suffix), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                };
            }
            else
                match = (path ? path : BUG_gDsnGKHT("Empty conversion path in cache."_fu, ss, _helpers, _here, ctx, module, options));

        };
      } BL_3:;
    };
    return /*NRVO*/ match;
}
                                #endif

                                #ifndef DEF_find_5WUbOXwWxRb
                                #define DEF_find_5WUbOXwWxRb
inline int find_5WUbOXwW(fu::view<char> haystack, fu::view<char> needle)
{
    if ((haystack.size() < needle.size()) || (needle.size() <= 0))
    {
        if (needle.size())
            return -1;
        else
            return 0;

    }
    else if (needle.size() == 1)
        return find_yP7FbxFZ(haystack, needle[0]);
    else
    {
        const int needle_len_m1 = (needle.size() - 1);
        const char needle_last_char = needle[needle_len_m1];
        int skip = 0;
        for (int i = needle_len_m1; i < haystack.size(); )
        {
            while (haystack[i] != needle_last_char)
            {
                if (++i == haystack.size())
                    return -1;

            };
            for (int j = 0; ; )
            {
                if (haystack[((i - needle_len_m1) + j)] != needle[j])
                {
                    if (!skip)
                    {
                        skip = needle.size();
                        for (int j_1 = needle_len_m1; j_1-- > 0; )
                        {
                            if (needle[j_1] == needle_last_char)
                            {
                                skip = (needle_len_m1 - j_1);
                                break;
                            };
                        };
                    };
                    i += skip;
                    break;
                }
                else if (++j == needle_len_m1)
                    return i - needle_len_m1;

            };
        };
        return -1;
    };
}
                                #endif

                                #ifndef DEF_find_2C20a41o6u3
                                #define DEF_find_2C20a41o6u3
inline int find_2C20a41o(fu::view<char> haystack, fu::view<char> needle, const int start)
{
    fu::view<char> slice = fu::get_view(haystack, start);
    const int res = find_5WUbOXwW(slice, needle);
    return res + ((res < 0) ? 0 : start);
}
                                #endif

                                #ifndef DEF_replace_EgBUdXNI93i
                                #define DEF_replace_EgBUdXNI93i
inline fu::str replace_EgBUdXNI(const fu::str& str, fu::view<char> all, fu::view<char> with)
{
    /*MOV*/ fu::str result {};

    {
        int last = 0;
        int next = 0;
        const int N = all.size();
        if (N)
        {
            while (((next = find_2C20a41o(str, all, last)) >= 0))
            {

                {
                    fu::str substr = fu::slice(str, last, next);
                    const bool first = !last;
                    if (!first)
                        result += with;

                    result += substr;
                };
                last = (next + N);
            };
        };
        if (last)
        {
            fu::str substr = fu::slice(str, last);
            result += with;
            result += substr;
        }
        else
            return fu::str(str);

    };
    return /*NRVO*/ result;
}
                                #endif

                                #ifndef DEF___muXZzWmOFHd
                                #define DEF___muXZzWmOFHd
inline static fu::str _muXZzWmO(const s_SolvedNode& _, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return explainType_gDsnGKHT(_.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_map_LaBD6FuDiu6
                                #define DEF_map_LaBD6FuDiu6
inline fu::vec<fu::str> map_LaBD6FuD(fu::view<s_SolvedNode> a, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<fu::str> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = _muXZzWmO(a[i], ss, _here, ctx, module, options);

    return /*NRVO*/ res;
}
                                #endif

static fu::str explainBadCallArguments_gDsnGKHT(const fu::str& id, fu::view<s_Target> targets, fu::view<s_SolvedNode> args, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return ((targets.size() == 1) ? str_FDl5ha9X(targets[0], false, ss, _here, ctx, module, options) : qID_e44UlzzA(id)) + (args ? ((" with args ("_fu + join_roEBocCS(map_LaBD6FuD(args, ss, _here, ctx, module, options), ", "_fu)) + ")"_fu) : fu::str{});
}

                                #ifndef DEF_last_StdcW3mSfW7
                                #define DEF_last_StdcW3mSfW7
inline const fu::str& last_StdcW3mS(fu::view<fu::str> s)
{
    return s[(s.size() - 1)];
}
                                #endif

static s_Target tryMatchCall_gDsnGKHT(fu::str&& id, s_Reorder& reorder_out, fu::vec<fu::vec<s_Target>>& conversions_out, fu::str& error, const bool local_scope, const s_Scope& misc_scope, fu::view<s_SolvedNode> args, const s_Flags flags, fu::view<s_Target> targets, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const int error_len0 = error.size();
    for (int i = 0; i < args.size(); i++)
    {
        if (!args[i].kind)
            BUG_gDsnGKHT("Falsy arg.kind!"_fu, ss, _helpers, _here, ctx, module, options);

    };
    s_Target matchIdx {};
    s_Target ambigOkIdx {};
    int minArity = args.size();
    const int numUsings = count_oMVVE0Wp(ss._scope.usings, ss._ss.usings);
    const int explicitArity = minArity;
    const int maxArity = (explicitArity + numUsings);
    s_NamedArgs_AWe2QSUTLw0 namedArgs = ((flags & s_Flags_F_CALL_HAS_NAMED_ARGS) ? collectNamedArgs_qT83fNIj(args, minArity, ss, _helpers, _here, ctx, module, options) : s_NamedArgs_AWe2QSUTLw0{});
    fu::str reusable_mangle {};
    const int considerFieldItems = ((!targets && ((flags & s_Flags_F_CALL_HAS_DOT) || !minArity) && (minArity <= 1)) ? maxArity : 0);
    fu::vec<fu::str> alternate_ids {};
    fu::vec<fu::vec<s_Target>> conversions {};
    s_Reorder reorder {};
    for (bool isExplicitConversion = false; ; (isExplicitConversion = true))
    {
        const s_SolvedNode& explore = ((flags & s_Flags_F_CALL_HAS_DOT) ? first_5wdN9pnX(args) : (*(const s_SolvedNode*)fu::NIL));
        fu::vec<s_ScopeItem> field_items { (considerFieldItems ? ((is_zeroes_9CJmuVSD(explore.type.vtype) || error) ? (local_scope ? ss._scope.globals : misc_scope.globals) : convCache_considerFieldItems_gDsnGKHT(explore.type, flags, _current_fn, ss, _helpers, _here, ctx, module, options)) : (*(const fu::vec<s_ScopeItem>*)fu::NIL)) };
        fu::vec<s_Target> extra_items {};
        if (local_scope && !targets)
        {
            s_BitSet seen {};
            if (flags & (s_Flags_F_CALL_HAS_DOT | s_Flags_F_OPERATOR))
            {
                const int N = ((flags & s_Flags_F_CALL_HAS_DOT) ? 1 : args.size());
                for (int i_1 = 0; i_1 < N; i_1++)
                    visitTypeImports_gDsnGKHT(args[i_1].type, id, local_scope, extra_items, seen, ss, _here, ctx, module);

            }
            else if (numUsings)
                each_V5AlXe60(ss._scope.usings, ss._ss.usings, 0, id, local_scope, extra_items, seen, ss, _here, ctx, module);

        };
        int scope_iterator {};
        s_Target overloadIdx {};
        if (!local_scope && extra_items)
            BUG_gDsnGKHT("!local_scope but extra_items"_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            bool shadows {};
            while ((overloadIdx = (targets ? s_Target(search_FjkYY9fz(targets, scope_iterator)) : (local_scope ? search_z0QqoZ5t(((flags & s_Flags_F_IMPLICIT) ? ss._scope.implicits : ss._scope.items), id, scope_iterator, ((flags & s_Flags_F_IMPLICIT) ? ss._ss.implicits : ss._ss.items), shadows, extra_items, field_items, _here, ctx) : search_KHWeNbCZ(fu::get_view_start0(misc_scope.items, misc_scope.pub_items), id, scope_iterator, field_items)))))
            { {
                if (!local_scope && shadows)
                    BUG_gDsnGKHT("!local_scope but shadows"_fu, ss, _helpers, _here, ctx, module, options);
                else
                {
                    bool TODO_FIX_dontBotherSpecializing = false;
                    conversions.clear();
                    clear_iUdwqyBn(reorder);
                    ensureLazySolved_gDsnGKHT(overloadIdx, _current_fn, ss, _helpers, _here, ctx, module, options);
                    const s_Overload& overload = GET_gDsnGKHT(overloadIdx, ss, _here, ctx, module);
                    const s_Kind kind = overload.kind;
                    const bool isType = (kind == s_Kind_type);
                    if (minArity && isType && !targets)
                    { {
                        const s_UserType& s = tryLookupUserType_1qjplDUo(overload.type.vtype, _here, ctx, module);
                        fu::never BL_18_v {};
                        const fu::str& alt = (s ? (s.name ? s.name : BUG_gDsnGKHT("No usertype.name"_fu, ss, _helpers, _here, ctx, module, options)) : (is_primitive_hxWWgdZ1(overload.type.vtype) ? overload.type.vtype.canon : (__extension__ (
                        {
                            goto BL_17;
                        (void)0;}), static_cast<fu::never&&>(BL_18_v))));
                        if (alt != id)
                            alternate_ids.push(fu::str(alt));

                      } BL_17:;
                    };
                    const s_Extended& arity = EXT_gDsnGKHT(overloadIdx, ss, ctx, module);
                    const bool isZeroInit = (isType ? !explicitArity : false);
                    if (!isZeroInit && ((arity.max < minArity) || (arity.min > maxArity)))
                    {
                        if (arity.min > arity.max)
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + (((x7E_3lDd4lqo(((("Declaration cycle, signature not yet available."_fu + "\n\n\t    To fix this, you might need to shuffle functions around"_fu) + "\n\t\tuntil every dependency (type annot or arg default expr)"_fu) + "\n\t\tof "_fu), str_FDl5ha9X(overloadIdx, false, ss, _here, ctx, module, options)) + " is declared above it."_fu) + "\n\n\t    This borders on a compiler bug, sorry about it,"_fu) + "\n\t\twe gotta come up with a better solve order algorithm."_fu));
                            };
                        }
                        else if (error)
                        {
                            error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + (((("Wrong number of arguments: expects "_fu + str_q5Q6zgXB(arity.min, arity.max)) + ", got "_fu) + str_q5Q6zgXB(minArity, maxArity)) + "."_fu));
                        };
                    }
                    else
                    {
                        if (isExplicitConversion)
                        {
                            if (overload.kind == s_Kind_fn)
                            {
                                if (is_Typename_9CJmuVSD(overload.type))
                                {
                                    if (error)
                                    {
                                        error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + "Not a conversion function: returns a type."_fu);
                                    };
                                    continue;
                                };
                            }
                            else if (overload.kind != s_Kind_template)
                            {
                                if (error)
                                {
                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + "Not a conversion function."_fu);
                                };
                                continue;
                            };
                        };
                        fu::vec<s_Argument> host_args { arity.args };
                        const int num_usings = ((!isZeroInit && (arity.min > explicitArity)) ? (arity.min - explicitArity) : 0);
                        if (!namedArgs.names)
                            reorderByNumUsings_gDsnGKHT(reorder, host_args, args.size(), num_usings);
                        else if (!reorderByArgIDs_gDsnGKHT(reorder, namedArgs.names, s_BitSet(namedArgs.optional), host_args, num_usings, ss, _helpers, _here, ctx, module, options))
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + ERRMSG_findUnmatchedArgName_gDsnGKHT(reorder, namedArgs.names, host_args, s_Target{}, _current_fn, ss, _here, ctx, module, options));
                            };
                            continue;
                        };
                        if (namedArgs.optional && reorder && (reorder.map.size() < args.size()) && (reorder.map.size() < arity.max))
                        {
                            if (error)
                            {
                                error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + ERRMSG_optionalArgumentAmbiguity_gDsnGKHT(host_args, reorder, namedArgs.names, _current_fn, ss, _here, ctx, module, options));
                            };
                        }
                        else
                        {
                            s_Type REST_TYPE {};
                            const int REST_START = findRestStart_gDsnGKHT(arity);
                            if ((REST_START < host_args.size()) && reorder && (reorder.map.size() < args.size()))
                            {
                                for (int i_1 = 0; i_1 < args.size(); i_1++)
                                {
                                    if (!has_ZwXYCruz(namedArgs.optional, i_1) && !has_4AEOmDQr(reorder.map, i_1))
                                        reorder.map += i_1;

                                };
                            };
                            const int N = max_yeUdQhUA((reorder ? reorder.map.size() : args.size()), (!isZeroInit ? arity.min : 0));
                            if (N)
                            {
                                if (REST_START < N)
                                {
                                    const s_Type& expect = host_args[REST_START].type;
                                    if (expect)
                                    {
                                        s_Type _0 {};
                                        REST_TYPE = ((_0 = tryClear_sliceable_1qjplDUo(expect.vtype, _here, ctx, module)) ? static_cast<s_Type&&>(_0) : fail_gDsnGKHT(((GET_gDsnGKHT(overloadIdx, ss, _here, ctx, module).name + ": Rest argument annotation is not an array: "_fu) + explainType_gDsnGKHT(expect, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options));
                                    };
                                };
                                if ((reorder.map.size() >= args.size()) || !reorder || namedArgs.optional)
                                {
                                    for (int i_1 = 0; i_1 < N; i_1++)
                                    {
                                        const bool rest = (i_1 >= REST_START);
                                        const int host_argIdx = (rest ? REST_START : i_1);
                                        s_Argument host_arg { host_args[host_argIdx] };
                                        s_Type expect { (rest ? REST_TYPE : host_arg.type) };
                                        const int callsiteIndex = (reorder ? reorder.map[i_1] : ((i_1 < args.size()) ? i_1 : -1));
                                        if (callsiteIndex < 0)
                                        {
                                            if (host_arg.dEfault || (host_arg.flags & s_Flags_F_IMPLICIT))
                                                continue;
                                            else
                                            {
                                                if (!((host_arg.flags & s_Flags_F_MUSTNAME) || (flags & s_Flags_F_CONVERSION)))
                                                {
                                                    if (expect)
                                                    {
                                                        /*MOV*/ fu::vec<s_Target> conversion = tryConvert_2QnVRhSK(expect, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
                                                        if (conversion)
                                                        {
                                                            ensure_wODKBuHQ(conversions, i_1) = static_cast<fu::vec<s_Target>&&>(conversion);
                                                            continue;
                                                        };
                                                    };
                                                };
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + x7E_3lDd4lqo("Cannot infer missing "_fu, str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        }
                                        else if (!expect)
                                        {
                                            const s_Node& a = annot_gDsnGKHT(overloadIdx, host_argIdx, ss, ctx, module);
                                            if (a.items || (a.kind == s_Kind___serialized_type))
                                            {
                                                fu::str error_1 = ""_fu;
                                                const s_Type& actual = args[callsiteIndex].type;
                                                s_Map_lhf7SV3Fyjf tp = steal_HPql5iRS(ss._typeParams);
                                                fu_DEFER(std::swap(ss._typeParams, tp));
                                                const bool ok = trySolveTypeParams_gDsnGKHT(s_Node(a), s_Type(actual), error_1, false, _current_fn, ss, _helpers, _here, ctx, module, options);
                                                if (!ok)
                                                {
                                                    fu::vec<s_Target> conversion = tryConvert_k6rrQ6kn(s_Node(annot_gDsnGKHT(overloadIdx, host_argIdx, ss, ctx, module)), actual, _current_fn, ss, _helpers, _here, ctx, module, options);
                                                    if (conversion)
                                                        ensure_wODKBuHQ(conversions, i_1) += conversion;

                                                };
                                            };
                                        };
                                        if (host_arg.flags & s_Flags_F_MUSTNAME)
                                        {
                                            if ((namedArgs.names.size() <= callsiteIndex) || !namedArgs.names[callsiteIndex])
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " must be :named explicitly."_fu));
                                                };
                                                goto BL_14;
                                            };
                                        };
                                        if (host_arg.autocall)
                                        {
                                            fu::vec<s_SolvedNode> autocall_args {};
                                            s_Reorder autocall_reorder {};
                                            fu::vec<fu::vec<s_Target>> autocall_conversions {};
                                            autocall_args.resize(1);
                                            autocall_args.mutref(0) = s_SolvedNode(args[callsiteIndex]);
                                            fu::str autocall_error = (error ? (((x7E_3lDd4lqo("Cannot match "_fu, str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options)) + " autocall "_fu) + qID_e44UlzzA(host_arg.autocall)) + ": "_fu) : fu::str{});
                                            const s_Target t = tryMatchCall_gDsnGKHT(fu::str(host_arg.autocall), autocall_reorder, autocall_conversions, autocall_error, true, (*(const s_Scope*)fu::NIL), autocall_args, (s_Flags_F_CALL_HAS_DOT | (flags & s_Flags_F_CONVERSION)), fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
                                            if (!t)
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + replace_EgBUdXNI(autocall_error, "\t"_fu, "\t\t"_fu));
                                                };
                                                goto BL_14;
                                            }
                                            else
                                            {
                                                if (autocall_conversions)
                                                    ensure_wODKBuHQ(conversions, i_1) += only_m9oK8BbA(autocall_conversions);

                                                ensure_wODKBuHQ(conversions, i_1) += s_Target(t);
                                                if (!(autocall_reorder.map.size() < 2))
                                                    BUG_gDsnGKHT("autocall: reorder"_fu, ss, _helpers, _here, ctx, module, options);

                                            };
                                        };
                                        fu::view<s_Target> argConv = ((conversions.size() > i_1) ? conversions[i_1] : fu::view<s_Target>{});
                                        s_Type actual = conversionTailType_gDsnGKHT(args[callsiteIndex].type, argConv, ss, _here, ctx, module);
                                        if (is_never_9CJmuVSD(actual.vtype))
                                        {
                                            if (!(host_arg.flags & s_Flags_F_INLINE))
                                                TODO_FIX_dontBotherSpecializing = true;

                                        }
                                        else if (!expect)
                                        {
                                            if ((host_arg.flags & s_Flags_F_TYPENAME) && !is_Typename_9CJmuVSD(actual))
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + (x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " expects a type, got a value: "_fu) + explainType_gDsnGKHT(actual, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        }
                                        else
                                        {
                                            if (!(isAssignableAsArgument_9CJmuVSD(expect.vtype, (actual ? actual : BUG_gDsnGKHT("tryMatch: !actual"_fu, ss, _helpers, _here, ctx, module, options)).vtype, false, _here, ctx)))
                                            {
                                                if (!argConv)
                                                {
                                                    const s_SolvedNode& arg = args[callsiteIndex];
                                                    const s_SolvedNode& arg_1 = ((arg.kind == s_Kind_argid) ? only_LqU08rcL(arg.items) : arg);
                                                    s_Type retype = tryRetyping_gDsnGKHT(arg_1, expect, ss, _helpers, _here, ctx, module, options);
                                                    if (retype && isAssignableAsArgument_9CJmuVSD(expect.vtype, retype.vtype, false, _here, ctx))
                                                        continue;

                                                };
                                                if (!(flags & s_Flags_F_CONVERSION))
                                                {
                                                    fu::vec<s_Target> conversion = tryConvert_2QnVRhSK(expect, actual, _current_fn, ss, _helpers, _here, ctx, module, options);
                                                    if (conversion)
                                                    {
                                                        ensure_wODKBuHQ(conversions, i_1) += conversion;
                                                        continue;
                                                    };
                                                };
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + (x7E_3lDd4lqo(str_wyx7msfr(host_arg, false, _current_fn, ss, _here, ctx, module, options), " "_fu) + explainNotAssignable_gDsnGKHT(expect, actual, _current_fn, ss, _here, ctx, module, options)));
                                                };
                                                goto BL_14;
                                            };
                                        };
                                    };
                                    if (REST_START < N)
                                    {
                                        for (int i_2 = REST_START; i_2 < N; i_2++)
                                        {
                                            const int callsiteIndex = (reorder ? reorder.map[i_2] : i_2);
                                            s_Type actual = conversionTailType_gDsnGKHT(args[callsiteIndex].type, ((conversions.size() > i_2) ? conversions[i_2] : fu::view<s_Target>{}), ss, _here, ctx, module);
                                            s_Type _1 {};
                                            fu::never BL_82_v {};
                                            REST_TYPE = ((i_2 == REST_START) ? solveArrlit_itemType_init_gDsnGKHT(actual, ss, _helpers, _here, ctx, module, options) : ((_1 = type_trySuper_9CJmuVSD(REST_TYPE, actual, false, _here, ctx)) ? static_cast<s_Type&&>(_1) : (__extension__ (
                                            {
                                                if (error)
                                                {
                                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + ((("Rest arguments have no common supertype: "_fu + explainType_gDsnGKHT(REST_TYPE, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)) + " <- "_fu) + explainType_gDsnGKHT(actual, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)));
                                                };
                                                goto BL_14;
                                            (void)0;}), static_cast<fu::never&&>(BL_82_v))));
                                        };
                                        REST_TYPE = solveArrlit_done_gDsnGKHT(REST_TYPE, -1, options);
                                    };
                                }
                                else
                                    BUG_gDsnGKHT(x7E_3lDd4lqo((x7E_3lDd4lqo("reorder < args:\n\t\treorder="_fu, fu::i64dec(reorder.map.size())) + "\n\t\t#args="_fu), fu::i64dec(args.size())), ss, _helpers, _here, ctx, module, options);

                            };
                            if ((kind == s_Kind_template) && !TODO_FIX_dontBotherSpecializing)
                            {
                                fu::str cant_reuse {};
                                fu::str& args_mangled = ((reorder || conversions) ? cant_reuse : reusable_mangle);
                                const int err0 = error.size();
                                if (error)
                                {
                                    error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + ""_fu);
                                };
                                const s_Target specIdx = trySpecialize_gDsnGKHT(overloadIdx, args, args_mangled, error, REST_START, REST_TYPE, reorder, conversions, _current_fn, ss, _helpers, _here, ctx, module, options);
                                if (is_SPECFAIL_gDsnGKHT(specIdx))
                                {
                                    if (!err0 || (err0 < error.size()))
                                        continue;
                                    else
                                        BUG_gDsnGKHT("tryMatch: is_SPECFAIL but trySpec provides no error message."_fu, ss, _helpers, _here, ctx, module, options);

                                }
                                else
                                {
                                    ensureLazySolved_gDsnGKHT((overloadIdx = specIdx), _current_fn, ss, _helpers, _here, ctx, module, options);
                                    if (isExplicitConversion && is_Typename_9CJmuVSD(GET_gDsnGKHT(overloadIdx, ss, _here, ctx, module).type))
                                    {
                                        if (error)
                                        {
                                            error += ((("\n\n\t"_fu + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t    "_fu) + "Not a conversion function: returns a type."_fu);
                                        };
                                        continue;
                                    };
                                };
                            };
                            if (ambigOkIdx && !TODO_FIX_dontBotherSpecializing)
                                matchIdx = ambigOkIdx;

                            if (matchIdx)
                            {
                                if (matchIdx == overloadIdx)
                                {
                                    if (!(GET_gDsnGKHT(matchIdx, ss, _here, ctx, module).kind == s_Kind_enumv))
                                    {
                                        BUG_gDsnGKHT(("tryMatchCall: Tested the same overload twice: "_fu + explainWhichFn_gDsnGKHT(s_Target(matchIdx), conversions_out, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                                    };
                                }
                                else
                                {
                                    fail_gDsnGKHT((((((("Ambiguous call to "_fu + explainBadCallArguments_gDsnGKHT(id, targets, args, ss, _here, ctx, module, options)) + ", matches multiple items in scope:\n"_fu) + "\n\t"_fu) + explainWhichFn_gDsnGKHT(s_Target(matchIdx), conversions_out, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)) + "\n\t"_fu) + explainWhichFn_gDsnGKHT(s_Target(overloadIdx), conversions, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                };
                            }
                            else
                            {
                                if (TODO_FIX_dontBotherSpecializing)
                                    ambigOkIdx = overloadIdx;
                                else
                                    matchIdx = overloadIdx;

                                std::swap(reorder, reorder_out);
                                std::swap(conversions, conversions_out);
                                if (shadows)
                                    break;

                            };
                        };
                    };
                };
              } BL_14:;
            };
            if (!alternate_ids)
                break;
            else
            {
                id = last_StdcW3mS(alternate_ids);
                alternate_ids.pop();
            };
        };
    };
    if (error && (error.size() == error_len0) && !matchIdx)
        error += isNotDefinedHere_gDsnGKHT(id);

    return (matchIdx ? matchIdx : ambigOkIdx);
}

static s_Target matchCall_gDsnGKHT(const s_Scope& misc_scope, const bool local_scope, const fu::str& id, fu::view<s_SolvedNode> args, s_Reorder& reorder, fu::vec<fu::vec<s_Target>>& conversions, const s_Flags flags, fu::view<s_Target> targets, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    fu::str error {};
    const s_Target ret = tryMatchCall_gDsnGKHT(fu::str(id), reorder, conversions, error, local_scope, misc_scope, args, flags, targets, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (ret)
        return ret;
    else
    {
        error = (("Bad call to "_fu + explainBadCallArguments_gDsnGKHT(id, targets, args, ss, _here, ctx, module, options)) + ": "_fu);
        const s_Target debug = tryMatchCall_gDsnGKHT(fu::str(id), reorder, conversions, error, local_scope, misc_scope, args, flags, targets, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (debug)
            BUG_gDsnGKHT(x7E_3lDd4lqo("Did match on second pass: "_fu, str_FDl5ha9X(debug, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
        else
        {
            fail_gDsnGKHT(error, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static s_SolvedNode solveCall_FDl5ha9X(fu::str&& id, /*MOV*/ fu::vec<s_SolvedNode>&& args, const s_Flags flags, fu::view<s_Target> targets, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (id || targets)
    {
        const s_Flags qualified = (flags & s_Flags_F_COMPOUND_ID);
        const s_Scope& misc_scope = (qualified ? dequalify_andGetScope_gDsnGKHT(id, ss, _helpers, _here, ctx, module, options) : (*(const s_Scope*)fu::NIL));
        s_Reorder reorder {};
        fu::vec<fu::vec<s_Target>> conversions {};
        const s_Target callTargIdx = matchCall_gDsnGKHT(misc_scope, !qualified, id, args, reorder, conversions, flags, targets, _current_fn, ss, _helpers, _here, ctx, module, options);
        return CallerNode_gDsnGKHT(id, s_Target(callTargIdx), static_cast<fu::vec<s_SolvedNode>&&>(args), reorder, conversions, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else
        BUG_gDsnGKHT("solveCall: No id, no target."_fu, ss, _helpers, _here, ctx, module, options);

}

static s_Type Scope_lookupType_gDsnGKHT(const fu::str& id, const s_Flags flags, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode callsite = solveCall_FDl5ha9X(fu::str(id), fu::vec<s_SolvedNode>{}, flags, fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (callsite.kind != s_Kind_empty)
    {
        fail_gDsnGKHT((("No type "_fu + qBAD_e44UlzzA(id)) + " in scope."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else if (callsite.type.vtype.vfacts & s_VFacts_Typename)
        return static_cast<s_Type&&>(callsite.type);
    else
        BUG_gDsnGKHT("Scope_lookupType: empty, but no vfacts.Typename"_fu, ss, _helpers, _here, ctx, module, options);

}

static s_Type evalTypeParam_gDsnGKHT(const fu::str& id, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Type _0 {};
    return (_0 = s_Type(get_usbzfpQ2(ss._typeParams, id).matched)) ? static_cast<s_Type&&>(_0) : (_0 = Scope_lookupType_gDsnGKHT((id ? id : fail_gDsnGKHT("Falsy type param id."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options)), s_Flags{}, _current_fn, ss, _helpers, _here, ctx, module, options)) ? static_cast<s_Type&&>(_0) : fail_gDsnGKHT((("No type param "_fu + qID_e44UlzzA(id)) + " in scope."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

static s_Type evalTypeAnnot_gDsnGKHT(const s_Node& node, const bool TODO_FIX_typeof_dontStripRefs, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_TokenIdx here0 { _here };
    fu_DEFER(_here = here0);
    _here = node.token;
    if (node.kind == s_Kind_call)
    {
        fu::view<s_Node> items = node.items;
        if (items.size() == 1)
        {
            if (node.value == "&"_fu)
            {
                return add_ref_9CJmuVSD(T_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options), Lifetime_temporary, _here, ctx);
            }
            else if (node.value == "&mut"_fu)
            {
                return add_mutref_9CJmuVSD(T_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options), Lifetime_temporary, _here, ctx);
            }
            else if (node.value == "[]"_fu)
                return createArray_9CJmuVSD(T_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options));
            else if (node.value == "[..]"_fu)
            {
                return createSlice_9CJmuVSD(T_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options), Lifetime_temporary, _here, ctx);
            }
            else if (node.value == "typeof"_fu)
            {
                /*MOV*/ s_Type type = solveNode_gDsnGKHT(only_CiCfNZS0(node.items), (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options).type;
                if (is_Typename_9CJmuVSD(type))
                {
                    _here = only_CiCfNZS0(node.items).token;
                    fail_gDsnGKHT(((("Redundant "_fu + qBAD_e44UlzzA("typeof"_fu)) + ", this is a type, not a value: "_fu) + explainType_gDsnGKHT(type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                {
                    if (!TODO_FIX_typeof_dontStripRefs)
                        type = clear_Typename_9CJmuVSD(relax_typeParam_9CJmuVSD(s_Type(type)), false);

                    return /*NRVO*/ type;
                };
            };
        };
    }
    else if (node.kind == s_Kind_definit)
        return s_Type(t_zeroes);
    else if (node.kind == s_Kind___serialized_type)
    {
        return s_Type { parseType_1qjplDUo(node.value, _here, ctx, module), s_Lifetime{} };
    };
    /*MOV*/ s_Type exprType = ((node.kind == s_Kind_typeparam) ? evalTypeParam_gDsnGKHT(node.value, _current_fn, ss, _helpers, _here, ctx, module, options) : solveNode_gDsnGKHT(node, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options).type);
    if (!is_Typename_9CJmuVSD(exprType))
    {
        fail_gDsnGKHT(("Invalid type annotation: evaluates to a value, not a type."_fu + " Consider wrapping it in typeof()."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
        return clear_Typename_9CJmuVSD(static_cast<s_Type&&>(exprType), true);

}

static const fu::str& getBasePrim_gDsnGKHT(const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const int offset = basePrimPrefixLen_hxWWgdZ1(type.vtype.canon);
    if (offset < type.vtype.canon.size())
        return lookupUserType_gDsnGKHT(type, ss, _helpers, _here, ctx, module, options).shape.basePrim;
    else
        return type.vtype.canon;

}

static fu::str TODO_FIX_getSpecPat_gDsnGKHT(const s_CurrentFn& _current_fn, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    const s_Target& spec_of = (!_current_fn.out.target ? _current_fn.out.target : EXT_gDsnGKHT(_current_fn.out.target, ss, ctx, module).spec_of);
    if (!spec_of)
        return ""_fu;
    else
    {
        /*MOV*/ fu::str specPat = ""_fu;
        for (int i = 0; i < (_current_fn.out.items.size() + FN_ARGS_BACK); i++)
        {
            const s_SolvedNode& arg = _current_fn.out.items[i];
            const s_SolvedNode& arg_1 = ((arg.kind == s_Kind_letdef) ? GET_gDsnGKHT(arg.target, ss, _here, ctx, module).solved : arg);
            if (!specPat)
            {
                specPat = "("_fu;
                appendGlobal_xQNS19Zn(specPat, spec_of);
            }
            else
                specPat += ":"_fu;

            specPat += serializeType_1qjplDUo(arg_1.type.vtype, "TODO_FIX_getSpecPat"_fu);
        };
        if (specPat)
            specPat += ")"_fu;

        return /*NRVO*/ specPat;
    };
}

static s_Type initUserType_gDsnGKHT(const s_Kind kind, const s_Shape& shape, const fu::str& name, const s_DeclAsserts asserts, fu::view<char> specPat, const uint64_t initialHash, s_Module& module)
{
    if (fu::u8((fu::u8(fu::u8(name[0])) - fu::u8(fu::u8('0')))) > fu::u8(unsigned(9)))
    {
        const int index = module.out.types.size();
        module.out.types += s_UserType { kind, fu::str(name), s_Target{}, fu::vec<s_ScopeItem>{}, fu::vec<s_ScopeItem>{}, s_Set_95BJOojOc45{}, fu::vec<s_Target>{}, s_Shape(shape) };
        /*MOV*/ fu::str canon = createUserTypeCanon_27MV22ZA(kind, shape.basePrim, module.modid, index, specPat, initialHash);
        return s_Type { s_ValueType { speculateStruct_9CJmuVSD(asserts, shape.flatCount), s_VFacts{}, static_cast<fu::str&&>(canon) }, s_Lifetime{} };
    }
    else
        fu::fail((("Bad struct name, leading digit: `"_fu + name) + "`."_fu));

}

static s_SolvedNode solveMember_gDsnGKHT(const s_Node& node, const bool isPrimDecl, const s_Type& primType, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.kind == s_Kind_let)
    {
        if (!isPrimDecl && node.items[LET_INIT] && (node.items[LET_INIT].kind != s_Kind_definit))
        {
            fail_gDsnGKHT(((("All structs must be zerofilled by default."_fu + " Please remove the initializer of struct member "_fu) + qBAD_e44UlzzA(node.value)) + "."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            /*MOV*/ s_SolvedNode ret = solveLetLike_dontTouchScope_gDsnGKHT(node, false, (*(const s_Type*)fu::NIL), primType, _current_fn, ss, _helpers, _here, ctx, module, options);
            ret.type.vtype.vfacts = s_VFacts{};
            return /*NRVO*/ ret;
        };
    }
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("solveStructMembers_1: "_fu, str_WkqQ7QhO(node.kind)), ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF_map_35PDWprrk5l
                                #define DEF_map_35PDWprrk5l
inline fu::vec<s_SolvedNode> map_35PDWprr(fu::view<s_Node> a, const bool isPrimDecl, const s_Type& primType, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<s_SolvedNode> res {};
    res.grow<false>(a.size());
    for (int i = 0; i < a.size(); i++)
        res.mutref(i) = solveMember_gDsnGKHT(a[i], isPrimDecl, primType, _current_fn, ss, _helpers, _here, ctx, module, options);

    return /*NRVO*/ res;
}
                                #endif

static void field_setParentStruct_gDsnGKHT(s_Overload& o, const s_Target& structTarget, const s_TokenIdx& _here, const s_Context& ctx)
{
    (!o.solved.target ? o.solved.target : BUG_u9Gbkniv("field_setParentStruct: solved.target already set."_fu, _here, ctx)) = s_Target(structTarget);
}

                                #ifndef DEF___94g1rdLQSN4
                                #define DEF___94g1rdLQSN4
inline static void _94g1rdLQ(const s_ScopeItem& item, s_UserType& s, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    if (GET_gDsnGKHT(target_z0QqoZ5t(item), ss, _here, ctx, module).flags & s_Flags_F_IMPLICIT)
        s.implicits.push(s_ScopeItem(item));

}
                                #endif

                                #ifndef DEF_each_78geoo68BMa
                                #define DEF_each_78geoo68BMa
inline void each_78geoo68(fu::view<s_ScopeItem> a, s_UserType& s, const s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    for (int i = 0; i < a.size(); i++)
        _94g1rdLQ(a[i], s, ss, _here, ctx, module);

}
                                #endif

                                #ifndef DEF_q_USAGE_bitsize
                                #define DEF_q_USAGE_bitsize
extern const int q_USAGE_bitsize;
                                #endif

static fu::str TODO_FIX_getRecursionError_gDsnGKHT(const s_UserType& other, const s_Type& instType, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < other.items.size(); i++)
    {
        const s_Target item = target_z0QqoZ5t(other.items[i]);
        const s_Type& itemType = GET_gDsnGKHT(item, ss, _here, ctx, module).type;
        if (isUserType_27MV22ZA(itemType.vtype))
        {
            fu::str rec = ""_fu;
            if ((itemType.vtype.canon == instType.vtype.canon) || (rec = TODO_FIX_getRecursionError_gDsnGKHT(lookupUserType_gDsnGKHT(itemType, ss, _helpers, _here, ctx, module, options), instType, _current_fn, ss, _helpers, _here, ctx, module, options)))
            {
                return ("\n\t\tvia "_fu + explainWhichFn_gDsnGKHT(s_Target(item), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_FullContext, _current_fn, ss, _here, ctx, module, options)) + rec;
            };
        };
    };
    return ""_fu;
}

                                #ifndef DEF_add_mO6a01zPMe8
                                #define DEF_add_mO6a01zPMe8
inline void add_mO6a01zP(fu::vec<int>& a, fu::view<int> b)
{
    int x = 0;
    int y = 0;
    while ((x < a.size()) && (y < b.size()))
    {
        const int X = a[x];
        const int Y = b[y];
        const int cmp = x3Cx3E_XrkW2YUZ(X, Y);
        if ((cmp >= 0))
        {
            if (cmp != 0)
            {
                a.insert(x, Y);
                y++;
            }
            else
                y++;

        };
        x++;
    };
    if (y < b.size())
        a += fu::get_view(b, y);

}
                                #endif

static void field_packOffset_gDsnGKHT(s_Overload& o, const int memberFlatOffset, const int memberFlatCount, const s_TokenIdx& _here, const s_Context& ctx)
{
    const int packed = (memberFlatOffset | (memberFlatCount << 16));
    if (o.kind == s_Kind_field)
    {
        o.solved.helpers = s_Helpers { packed };
    }
    else
        BUG_u9Gbkniv("field_packOffset: Not a field."_fu, _here, ctx);

}

                                #ifndef DEF_iF_2dYjj0V8kab
                                #define DEF_iF_2dYjj0V8kab
inline const s_Node& iF_2dYjj0V8(fu::view<s_Node> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_Node*)fu::NIL);

}
                                #endif

                                #ifndef DEF___eeI30O7xXE5
                                #define DEF___eeI30O7xXE5
inline static bool _eeI30O7x(const int import, s_Set_95BJOojOc45& structImports)
{
    return add_8Ex4Hrql(structImports, import);
}
                                #endif

                                #ifndef DEF_each_xyYTUZ41RAb
                                #define DEF_each_xyYTUZ41RAb
inline void each_xyYTUZ41(fu::view<int> items, fu::view<s_ScopeSkip> scope_skip, const int start, s_Set_95BJOojOc45& structImports)
{
    const s_ScopeSkip END_DUMMY = s_ScopeSkip { items.size(), items.size() };
    int i0 = start;
    for (int i = 0; i < (scope_skip.size() + 1); i++)
    {
        const s_ScopeSkip& ss = ((i < scope_skip.size()) ? scope_skip[i] : END_DUMMY);
        if (!((ss.end <= i0)))
        {
            const int i1 = ss.start;
            for (int i_1 = i0; i_1 < i1; i_1++)
                _eeI30O7x(items[i_1], structImports);

            i0 = ss.end;
        };
    };
}
                                #endif

                                #ifndef DEF___6fRfhMJVIp9
                                #define DEF___6fRfhMJVIp9
inline static bool _6fRfhMJV(const s_SolvedNode& member)
{
    return !is_rx_copy_9CJmuVSD(member.type.vtype);
}
                                #endif

                                #ifndef DEF_some_Ux3GUCvAVd6
                                #define DEF_some_Ux3GUCvAVd6
inline bool some_Ux3GUCvA(fu::view<s_SolvedNode> a)
{
    for (int i = 0; i < a.size(); i++)
    {
        const s_SolvedNode& item = a[i];
        if (_6fRfhMJV(item))
            return true;

    };
    return false;
}
                                #endif

                                #ifndef DEF_x3Cx3E_z4pVuOXd5Yb
                                #define DEF_x3Cx3E_z4pVuOXd5Yb
inline int x3Cx3E_z4pVuOXd(const s_Shape& a, const s_Shape& b)
{
    int cmp = 0;
    if ((cmp = x3Cx3E_ZAz3Jw6L(a.non_triv_mask, b.non_triv_mask)))
        return cmp;
    else if ((cmp = x3Cx3E_ZAz3Jw6L(a.hash, b.hash)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.flatCount, b.flatCount)))
        return cmp;
    else if ((cmp = x3Cx3E_XrkW2YUZ(a.declDepth, b.declDepth)))
        return cmp;

    if ((cmp = x3Cx3E_bv5nK4Kl(a.basePrim, b.basePrim)))
        return cmp;
    else
        return 0;

}
                                #endif

                                #ifndef DEF_x21x3D_AB8oa2Kdek0
                                #define DEF_x21x3D_AB8oa2Kdek0
inline bool operator!=(const s_Shape& a, const s_Shape& b)
{
    return !!x3Cx3E_z4pVuOXd(a, b);
}
                                #endif

static s_SolvedNode __solveStruct_gDsnGKHT(const bool solve, const s_Node& node, const s_Target& into, const bool TODO_FIX_useSpecPath, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    // Hoisted:
    s_Target out_target_1;

    const fu::str& origId = node.value;
    fu::str _0 {};
    fu::str name = (origId ? fu::str(origId) : (_0 = fu::str((_current_fn.out.target ? GET_gDsnGKHT(_current_fn.out.target, ss, _here, ctx, module).name : (*(const fu::str*)fu::NIL)))) ? static_cast<fu::str&&>(_0) : "Anon"_fu);
    const s_Kind kind = node.kind;
    const bool isStruct = (kind == s_Kind_struct);
    const bool isUnion = (kind == s_Kind_union);
    const bool isPrimDecl = (!isStruct ? !isUnion : false);
    fu::view<s_Node> memberNodes = (!node.items ? node.items : node.items[STRUCT_MEMBERS].items);
    /*MOV*/ s_Type basePrimType {};
    fu::str basePrim {};
    if (isPrimDecl)
    {
        const s_Node& baseannot = node.items[STRUCT_BASE];
        basePrimType = (baseannot ? evalTypeAnnot_gDsnGKHT(baseannot, false, _current_fn, ss, _helpers, _here, ctx, module, options) : s_Type(t_u8));
        basePrim = getBasePrim_gDsnGKHT(basePrimType, ss, _helpers, _here, ctx, module, options);
    };
    s_TEA shape_hasher = hash_s9RCxn8L(name);
    if (isPrimDecl)
        hash_l6RUR9Sz(shape_hasher, ss.shortModuleName);
    else
    {
        for (int i = 0; i < memberNodes.size(); i++)
        {
            fu::view<char> _1 {};
            hash_l6RUR9Sz(shape_hasher, ((_1 = memberNodes[i].value) ? static_cast<fu::view<char>&&>(_1) : BUG_u9Gbkniv(fu::str{}, _here, ctx)));
        };
    };
    uint64_t BL_6_v {};
    s_Shape shape = s_Shape { fu::str(basePrim), 0ull, (__extension__ (
    {
        const s_TEA& tea = shape_hasher;
        BL_6_v = ((uint64_t(tea.v0) | (uint64_t(tea.v1) << 32ull)));
    (void)0;}), BL_6_v), (isPrimDecl ? 1 : 0), 0 };
    if (isPrimDecl)
        hash_l6RUR9Sz(shape_hasher, basePrim);

    const s_DeclAsserts asserts = node.asserts;
    const s_Target* BL_8_v;
    const s_Target& out_target = (into ? into : (__extension__ (
    {
        fu::str specPat = ((!origId && TODO_FIX_useSpecPath) ? TODO_FIX_getSpecPat_gDsnGKHT(_current_fn, ss, _here, ctx, module) : fu::str{});
        s_Type _2 {};
        out_target_1 = (_2 = initUserType_gDsnGKHT(kind, shape, name, asserts, specPat, shape.hash, module), createRawTypedef_gDsnGKHT(origId, static_cast<s_Type&&>(_2), node.flags, name, s_SolverStatus_SS_LAZY, ss, module));
        EXT_mut_gDsnGKHT(out_target_1, ss, module).tEmplate = createTemplate_gDsnGKHT(node, _current_fn, ss);
        BL_8_v = &(out_target_1);
    (void)0;}), *BL_8_v));
    s_Type out_Typename { GET_gDsnGKHT(out_target, ss, _here, ctx, module).type };
    /*MOV*/ s_Type instType = clear_Typename_9CJmuVSD(s_Type(out_Typename), false);
    if (!solve)
        return createEmpty_gDsnGKHT(t_void, out_target, ss, _helpers, _here, ctx, module, options);
    else
    {
        const s_Target solvingFnort0 = exchange_EqG2aXiz(ss._solvingFnort, s_Target(out_target));
        fu_DEFER(ss._solvingFnort = solvingFnort0);
        GET_mut_gDsnGKHT(out_target, ss, module).status |= s_SolverStatus_SS_DID_START;
        const int helpers0 = _helpers.size();
        const int helpers_data0 = ss._helpers_data.size();
        fu_DEFER(
        {
            _helpers.shrink(helpers0);
            ss._helpers_data.shrink(helpers_data0);
        });
        push_gDsnGKHT(s_HelpersData { s_Target((out_target ? out_target : BUG_gDsnGKHT((("solveStruct: no out_target: `"_fu + origId) + "`."_fu), ss, _helpers, _here, ctx, module, options))), s_SolverPass{}, s_HelpersMask_HM_UserType, fu::str{}, 0, 0, s_Type{}, s_Type{}, s_Postdom{}, s_Postdom{}, s_EventsSnap{}, s_Helpers{} }, ss, _helpers);
        /*MOV*/ fu::vec<s_Target> structConverts {};
        /*MOV*/ s_Set_95BJOojOc45 structImports {};
        int non_triv_reason = (!is_rx_copy_9CJmuVSD(instType.vtype) ? -1 : 0);
        const s_Type& primType = (isPrimDecl ? (instType ? instType : BUG_gDsnGKHT("Falsy isPrimDecl.instType"_fu, ss, _helpers, _here, ctx, module, options)) : (*(const s_Type*)fu::NIL));
        fu::vec<s_SolvedNode> members = map_35PDWprr(memberNodes, isPrimDecl, primType, _current_fn, ss, _helpers, _here, ctx, module, options);

        {
            s_UserType& s = lookupUserType_mut_1qjplDUo(instType.vtype.canon, module, _here, ctx);
            if (!s.items && memberNodes)
            {
                const bool isUnscoped = !!(node.flags & s_Flags_F_USING);
                fu::vec<s_Argument> args = (!isPrimDecl ? fu::vec<s_Argument> { fu::slate<1, s_Argument> { s_Argument { "this"_fu, fu::str{}, despeculateStruct_9CJmuVSD(s_Type(instType)), s_SolvedNode{}, s_Target{}, s_Flags{}, 0u, s_BitSet{}, s_BitSet{} } } } : fu::vec<s_Argument> { fu::slate<1, s_Argument> { s_Argument { "This"_fu, fu::str{}, s_Type(out_Typename), (isUnscoped ? createEmpty_gDsnGKHT(out_Typename, s_Target{}, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{}), s_Target{}, s_Flags{}, 0u, s_BitSet{}, s_BitSet{} } } });
                for (int i = 0; i < memberNodes.size(); i++)
                {
                    const s_Node& node_1 = memberNodes[i];
                    const fu::str& id = node_1.value;
                    const s_Flags flags = (node_1.flags & (s_Flags_F_PREDICATE | s_Flags_F_IMPLICIT));
                    if (flags && isPrimDecl)
                    {
                        fail_gDsnGKHT((((("Unexpected "_fu + qKW_e44UlzzA("true"_fu)) + " or "_fu) + qKW_e44UlzzA("implicit"_fu)) + " qualifier."_fu), fu::view<char>{}, s_TokenIdx(node_1.token), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                    }
                    else
                    {
                        const s_Target target = Scope_create_z0QqoZ5t(ss._scope, (!isPrimDecl ? s_Kind_field : s_Kind_enumv), (id ? id : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)), (*(const s_Type*)fu::NIL), (s_Flags_F_PUB | flags), s_DeclAsserts{}, s_SolverStatus{}, 0, false, module);
                        s_Extended& ext = EXT_mut_gDsnGKHT(target, ss, module);
                        ext.args = args;
                        ext.min = ((isUnscoped && isPrimDecl) ? 0 : args.size());
                        ext.max = args.size();
                        ext.tEmplate.node.token = memberNodes[i].token;
                        Scope_set_FjkYY9fz(s.items, id, target, false);
                        field_setParentStruct_gDsnGKHT(GET_mut_gDsnGKHT(target, ss, module), out_target, _here, ctx);
                    };
                };
                if (isPrimDecl)
                    ss._scope.items += s.items;
                else
                {
                    each_78geoo68(s.items, s, ss, _here, ctx, module);
                    if (!_current_fn)
                        ss._scope.globals += s.items;

                };
            };
            if (s.items.size() == members.size())
            {
                for (int i_1 = 0; i_1 < s.items.size(); i_1++)
                {
                    const s_ScopeItem& item = s.items[i_1];
                    const s_SolvedNode& member = members[i_1];
                    if (item.id == member.value)
                    {
                        const s_Target field_target = target_z0QqoZ5t(item);
                        s_Overload& field = GET_mut_gDsnGKHT(field_target, ss, module);
                        field.type = member.type;
                        s_Shape member_shape = getShape_1qjplDUo(member.type.vtype, _here, ctx, module);
                        int memberFlatOffset = 0;
                        if (!isPrimDecl)
                        {
                            hash_qRo1x0wq(shape_hasher, member_shape.hash);
                            shape.declDepth = max_yeUdQhUA(shape.declDepth, (member_shape.declDepth + 1));
                            memberFlatOffset = shape.flatCount;
                            shape.flatCount += member_shape.flatCount;
                            if (member_shape.non_triv_mask)
                            {
                                if (!(non_triv_reason))
                                    non_triv_reason = (non_triv_reason = (i_1 + 1));

                                shape.non_triv_mask |= member_shape.non_triv_mask;
                            };
                        };

                        {
                            const int expect = min_O25D0jcU(member_shape.flatCount, q_USAGE_bitsize);
                            unsigned BL_29_v {};
                            const int actual = __builtin_popcount((__extension__ (
                            {
                                const s_ValueType& type = member.type.vtype;
                                BL_29_v = ((type.quals & q_USAGE));
                            (void)0;}), BL_29_v));
                            if ((actual == expect) || isUserType_27MV22ZA(member.type.vtype))
                            {
                                if ((!is_trivial_1qjplDUo(member.type.vtype, _here, ctx, module) != !!member_shape.non_triv_mask) && member_shape.flatCount)
                                    BUG_gDsnGKHT((x7E_3lDd4lqo(((x7E_3lDd4lqo("member.is_trivial("_fu, fu::booldec(is_trivial_1qjplDUo(member.type.vtype, _here, ctx, module))) + "),"_fu) + " but non_triv_mask("_fu), fu::u64dec(member_shape.non_triv_mask)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                            }
                            else
                                BUG_gDsnGKHT((x7E_3lDd4lqo(((x7E_3lDd4lqo("member.type.usage popcount("_fu, fu::i64dec(actual)) + ")"_fu) + " != member_shape.flatCount("_fu), fu::i64dec(member_shape.flatCount)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                        };
                        fu::str recursionError = (isUserType_27MV22ZA(member.type.vtype) ? TODO_FIX_getRecursionError_gDsnGKHT(tryLookupUserType_1qjplDUo(member.type.vtype, _here, ctx, module), instType, _current_fn, ss, _helpers, _here, ctx, module, options) : fu::str{});
                        if (recursionError)
                        {
                            fail_gDsnGKHT(((("Type "_fu + qBAD_e44UlzzA(name)) + " is self-recursive:\n"_fu) + recursionError), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else
                        {
                            if (member.flags & s_Flags_F_USING)
                            {
                                structConverts.push(target_z0QqoZ5t(item));
                                const int m = modidOfOrigin_27MV22ZA(field.type);
                                if (m && (m != module.modid))
                                    add_8Ex4Hrql(structImports, m);

                                add_mO6a01zP(structImports.keys_asc, lookupTypeImports_1qjplDUo(field.type.vtype, _here, ctx, module).keys_asc);
                            };
                            if (!isPrimDecl)
                                field_packOffset_gDsnGKHT(field, memberFlatOffset, member_shape.flatCount, _here, ctx);

                        };
                    }
                    else
                        BUG_gDsnGKHT("solveStructMembers_4: field id mismatch."_fu, ss, _helpers, _here, ctx, module, options);

                };
                if (isPrimDecl)
                {
                    const bool sIgned = (basePrim[0] == 'i');
                    const bool uNsigned = (basePrim[0] == 'u');
                    fu::view<char> size_str = fu::get_view(basePrim, 1);
                    const fu::u8 size = ((size_str == "8"_fu) ? fu::u8(8u) : ((size_str == "16"_fu) ? fu::u8(16u) : ((size_str == "32"_fu) ? fu::u8(32u) : ((size_str == "64"_fu) ? fu::u8(64u) : ((size_str == "128"_fu) ? fu::u8(128u) : BUG_gDsnGKHT(("Enum auto-incrementer: unknown prim size: "_fu + size_str), ss, _helpers, _here, ctx, module, options))))));
                    s_Intlit last {};
                    for (int i_2 = 0; i_2 < s.items.size(); i_2++)
                    {
                        s_SolvedNode& init = GET_mut_gDsnGKHT(target_z0QqoZ5t(s.items[i_2]), ss, module).solved;
                        const s_SolvedNode& member_1 = members[i_2];
                        init = member_1.items[LET_INIT];
                        _here = member_1.token;
                        if (init)
                        {
                            _here = init.token;
                            if (init.kind == s_Kind_int)
                            {
                                last = Intlit_u8re8TwO(init.value);
                                if (last.error)
                                {
                                    fail_gDsnGKHT(last.error, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                }
                                else
                                    continue;

                            }
                            else
                                last.error = "Cannot auto-increment, please provide an explicit value."_fu;

                        };
                        if (last.error)
                        {
                            fail_gDsnGKHT(last.error, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else if (last.negative)
                        {
                            fail_gDsnGKHT("Previous constant is negative, not sure how to increment, please specify an explicit value."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else
                        {
                            /*MOV*/ s_Intlit next = Intlit_MpuZ8TbN(((kind == s_Kind_flags) ? (i_2 ? (last.absval << 1ull) : 1ull) : (last.absval + 1ull)), false, fu::str{}, uNsigned, sIgned, 10ull);
                            if (next.error || (next.absval > last.absval))
                            {
                                const fu::u8 minsize = (sIgned ? next.minsize_i : next.minsize_u);
                                if (minsize > size)
                                {
                                    fail_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("Primitive range exhausted: requires "_fu, fu::u64dec(minsize)) + " bits, got "_fu), fu::u64dec(size)) + "."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                }
                                else
                                {
                                    last = next;
                                    if (sIgned || uNsigned)
                                    {
                                        init = SolvedNode_gDsnGKHT(s_Kind_int, primType, s_Flags{}, x7E_3lDd4lqo((next.negative ? "-"_fu : fu::str{}), fu::u64dec(next.absval)), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, s_Helpers{}, _here);
                                    }
                                    else
                                    {
                                        fail_gDsnGKHT(("Cannot auto-increment this type: "_fu + basePrim), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                                    };
                                };
                            }
                            else
                            {
                                fail_gDsnGKHT((next.error ? static_cast<fu::str&&>(next.error) : "Failed to auto-increment, range exhausted."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                            };
                        };
                    };
                };
            }
            else
                BUG_gDsnGKHT((((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("solveStructMembers_3: field lens mismatch: "_fu, fu::i64dec(s.items.size())) + " vs "_fu), fu::i64dec(members.size())) + "/"_fu), fu::i64dec(memberNodes.size())) + ": `struct "_fu) + name) + "`."_fu), ss, _helpers, _here, ctx, module, options);

        };
        uint64_t BL_57_v {};
        shape.hash = (__extension__ (
        {
            const s_TEA& tea = shape_hasher;
            BL_57_v = ((uint64_t(tea.v0) | (uint64_t(tea.v1) << 32ull)));
        (void)0;}), BL_57_v);
        if (EPH_gDsnGKHT(out_target, ss, module).callers)
            shape.hash = lookupUserType_gDsnGKHT(instType, ss, _helpers, _here, ctx, module, options).shape.hash;

        if (non_triv_reason)
        {
            if (asserts & s_DeclAsserts_A_TRIVIAL)
            {
                fail_gDsnGKHT((("Struct is not "_fu + qKW_e44UlzzA("trivial"_fu)) + ((non_triv_reason < 1) ? ((" because it is "_fu + qKW_e44UlzzA("nocopy"_fu)) + "."_fu) : (" because of non-trivial member "_fu + qID_e44UlzzA(iF_2dYjj0V8(memberNodes, (non_triv_reason - 1)).value)))), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else if (shape.non_triv_mask || (non_triv_reason < 0))
                shape.non_triv_mask |= (1ull << (shape.hash & 63ull));
            else
                BUG_gDsnGKHT("solveStruct: Empty non_triv_mask, but some member is non-trivial."_fu, ss, _helpers, _here, ctx, module, options);

        };
        each_xyYTUZ41(ss._scope.imports, ss._ss.imports, 0, structImports);
        /*MOV*/ s_Type instType_1 = static_cast<s_Type&&>(instType);

        {
            bool CHANGE = false;
            if (is_rx_copy_9CJmuVSD(instType_1.vtype) && some_Ux3GUCvA(members))
            {
                CHANGE = true;
                instType_1 = make_non_copyable_9CJmuVSD(s_Type(instType_1));
            };
            if (!isStruct && !isUnion)
            {
                if (!(shape.flatCount == 1))
                    BUG_gDsnGKHT(((x7E_3lDd4lqo((x7E_3lDd4lqo("solveStruct: Bad flatCount("_fu, fu::i64dec(shape.flatCount)) + "): "_fu), str_WkqQ7QhO(kind)) + " "_fu) + name), ss, _helpers, _here, ctx, module, options);

            };

            {
                s_UserType& s_1 = lookupUserType_mut_1qjplDUo(instType_1.vtype.canon, module, _here, ctx);
                s_1.target = (out_target ? out_target : BUG_gDsnGKHT("solveStruct: No struct/out_target."_fu, ss, _helpers, _here, ctx, module, options));
                s_1.converts = static_cast<fu::vec<s_Target>&&>(structConverts);
                s_1.imports = static_cast<s_Set_95BJOojOc45&&>(structImports);

                {
                    s_Shape shape0 { s_1.shape };
                    s_1.shape = shape;
                    if (!(CHANGE))
                        CHANGE = (shape0 != shape);

                };
                if (GET_gDsnGKHT(s_1.target, ss, _here, ctx, module).status & s_SolverStatus_SS_DID_START)
                {

                    {
                        const int actual_1 = getFlatCount_1qjplDUo(instType_1.vtype, _here, ctx, module);
                        if (actual_1 != shape.flatCount)
                            BUG_gDsnGKHT((x7E_3lDd4lqo((x7E_3lDd4lqo("solveStruct: getFlatCount("_fu, fu::i64dec(actual_1)) + ") !== shape.flatCount("_fu), fu::i64dec(shape.flatCount)) + ")"_fu), ss, _helpers, _here, ctx, module, options);

                    };
                    USAGE_setMaxUsage_CaGDtmWo(instType_1, shape.flatCount);
                }
                else
                    BUG_gDsnGKHT("solveStruct: Setting stuff but missing SS_DID_START."_fu, ss, _helpers, _here, ctx, module, options);

            };
            /*MOV*/ s_Type& instType_2 = instType_1;
            /*MOV*/ s_Type out_Typename_1 = into_Typename_9CJmuVSD(static_cast<s_Type&&>(instType_2));
            int min = 0;
            /*MOV*/ fu::vec<s_Argument> args_1 {};
            if (isPrimDecl)
            {
                args_1.push(s_Argument { "value"_fu, fu::str{}, static_cast<s_Type&&>(basePrimType), s_SolvedNode{}, s_Target{}, s_Flags{}, 0u, s_BitSet{}, s_BitSet{} });
            }
            else
            {
                int N = members.size();
                if (N && isUnion)
                    N = 1;

                for (int i_3 = 0; i_3 < N; i_3++)
                {
                    const s_SolvedNode& member_2 = members[i_3];
                    s_SolvedNode _3 {};
                    /*MOV*/ s_Argument arg = s_Argument { fu::str((member_2.value ? member_2.value : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options))), fu::str{}, s_Type((member_2.type ? member_2.type : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options))), ((_3 = s_SolvedNode(member_2.items[LET_INIT])) ? static_cast<s_SolvedNode&&>(_3) : (isUnion ? createEmpty_gDsnGKHT(member_2.type, s_Target{}, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{})), s_Target{}, (member_2.flags & s_Flags_F_MUSTNAME), 0u, s_BitSet{}, s_BitSet{} };
                    if (!arg.dEfault)
                        min++;

                    args_1.push(static_cast<s_Argument&&>(arg));
                };
            };
            const int max = args_1.size();
            if (max && !min)
                min++;

            s_Extended& ext_1 = EXT_mut_gDsnGKHT(out_target, ss, module);
            ext_1.min = min;
            ext_1.max = max;
            ext_1.args = static_cast<fu::vec<s_Argument>&&>(args_1);
            int BL_81_v {};
            const int mustUpdate = (CHANGE ? (__extension__ (
            {
                const s_CountedSet_95BJOojOc45& _ = EPH_gDsnGKHT(out_target, ss, module).callers;
                const s_Set_95BJOojOc45& __1 = _.counts.keys;
                BL_81_v = (__1.keys_asc.size());
            (void)0;}), BL_81_v) : 0);
            s_Overload& overload = GET_mut_gDsnGKHT(out_target, ss, module);
            overload.type = static_cast<s_Type&&>(out_Typename_1);
            if (mustUpdate)
                overload.status |= s_SolverStatus_SS_UPDATED;

        };
        lazySolveEnd_gDsnGKHT(out_target, _current_fn, ss, _helpers, _here, ctx, module, options);
        return s_SolvedNode{};
    };
}

static s_SolvedNode uPrepStruct_gDsnGKHT(const s_Node& node, const bool TODO_FIX_useSpecPath, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    return __solveStruct_gDsnGKHT(false, node, s_Target{}, TODO_FIX_useSpecPath, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode unorderedPrep_A_gDsnGKHT(const s_Node& node, const bool TODO_FIX_useSpecPath, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Kind kind = node.kind;
    if (kind == s_Kind_fn)
        return uPrepFn_A_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (isTypeDecl_gDsnGKHT(kind))
        return uPrepStruct_gDsnGKHT(node, TODO_FIX_useSpecPath, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo("TODO: unorderedPrep_A("_fu, str_WkqQ7QhO(node.kind)) + ")."_fu), ss, _helpers, _here, ctx, module, options);

}

static void unorderedPrep_B_gDsnGKHT(fu::view<s_Node> nodes, fu::view<s_SolvedNode> results, const int unorderedClass, s_SolverState& ss, const s_Module& module)
{
    if (!(unorderedClass != 1))
    {
        bool hasSnap = false;
        s_ScopeMemo lastSnap {};
        for (int i = nodes.size(); i-- > 0; )
        {
            const s_Target& target = results[i].target;
            s_Ephemeral& eph = EPH_mut_FDl5ha9X(target, ss, module);
            if (eph.scope_memo)
            {
                if (!hasSnap)
                {
                    hasSnap = true;
                    lastSnap = eph.scope_memo;
                }
                else
                    eph.scope_memo = lastSnap;

            };
        };
    };
}

static fu::vec<s_SolvedNode> solveNodes_gDsnGKHT(fu::view<s_Node> nodes, const s_DeadBreak dead_brk, const s_Type& type_all, const s_Type& type_last, const bool use_type_last, const s_StaticEval static_eval_brk, const bool TODO_FIX_useSpecPath, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ fu::vec<s_SolvedNode> result {};
    const s_TokenIdx here0 { _here };
    fu_DEFER(_here = here0);
    for (int i = 0; i < nodes.size(); i++)
    {
        const s_Node& node = nodes[i];
        if (!(!node))
        {
            const int unorderedClass = unorderedClassify_gDsnGKHT(node.kind);
            if (!unorderedClass)
            {

                {
                    const s_TokenIdx& node_1 = node.token;
                    if (node_1)
                        _here = node_1;

                };
                const bool last = (i == (nodes.size() - 1));
                const s_Type& type = ((last && use_type_last) ? type_last : type_all);
                s_SolvedNode solved = solveNode_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
                result += s_SolvedNode(solved);
                if (is_never_9CJmuVSD(solved.type.vtype) && dead_brk && ((dead_brk != s_DeadBreak_DeadBreak_Only_WhileSolvingRecursion) || is_AssumeNever_WhileSolvingRecursion_9CJmuVSD(solved.type.vtype)))
                {
                    if (i < (nodes.size() - 1))
                    {
                        const s_SolverNotes note = s_SolverNotes_N_DeadCode;
                        if (note & options.break_notes)
                        {
                            fu::view<char> reason = fu::view<char>{};
                            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        }
                        else
                            ss._notes |= note;

                    };
                    break;
                }
                else if (static_eval_brk)
                {
                    const s_StaticEval ae_item = tryAbstractEvalAsBool_gDsnGKHT(solved, (i == (nodes.size() - 1)), _current_fn, ss, _helpers, _here, ctx, module, options);
                    if (ae_item == static_eval_brk)
                        break;

                };
            }
            else
            {
                const int i0 = i;
                int i1 = nodes.size();
                const int offset = (result.size() - i0);
                for (int i_1 = i0; i_1 < nodes.size(); i_1++)
                {
                    const s_Node* _0;
                    const s_Node& node_1 = (*(_0 = &(nodes[i_1])) ? *_0 : BUG_gDsnGKHT("solveNodes, prep-a: falsy node"_fu, ss, _helpers, _here, ctx, module, options));
                    if ((unorderedClassify_gDsnGKHT(node_1.kind) != unorderedClass) || ((node_1.flags & s_Flags_F_SHADOW) && (i_1 > i0)))
                    {
                        i1 = i_1;
                        break;
                    }
                    else
                    {

                        {
                            const s_TokenIdx& node_2 = node_1.token;
                            if (node_2)
                                _here = node_2;

                        };
                        result += unorderedPrep_A_gDsnGKHT(node_1, TODO_FIX_useSpecPath, _current_fn, ss, _helpers, _here, ctx, module, options);
                        if (node_1.flags & (s_Flags_F_CONVERSION | s_Flags_F_USING))
                        {
                            i1 = (i_1 + 1);
                            break;
                        };
                    };
                };
                if (i1 > i0)
                {
                    i = (i1 - 1);
                    unorderedPrep_B_gDsnGKHT(fu::get_view(nodes, i0, i1), fu::get_view(result, (i0 + offset), (i1 + offset)), unorderedClass, ss, module);
                    bool repeat = true;
                    while (repeat)
                    {
                        repeat = false;
                        for (int i_2 = i0; i_2 < i1; i_2++)
                        {
                            const s_Node* _1;
                            const s_Node& node_1 = (*(_1 = &(nodes[i_2])) ? *_1 : BUG_gDsnGKHT("solveNodes, solve: falsy node"_fu, ss, _helpers, _here, ctx, module, options));

                            {
                                const s_TokenIdx& node_2 = node_1.token;
                                if (node_2)
                                    _here = node_2;

                            };
                            const s_Target& into = result[(i_2 + offset)].target;
                            if (lazySolveStart_gDsnGKHT(into, _current_fn, ss, _helpers, _here, ctx, module, options))
                                repeat = true;

                        };
                    };
                }
                else
                {
                    BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
                };
            };
        };
    };
    return /*NRVO*/ result;
}

static s_SolvedNode solveRoot_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Helpers helpers = s_Helpers { _helpers.size() };
    push_gDsnGKHT(s_HelpersData{}, ss, _helpers);
    fu::vec<s_SolvedNode> items = solveNodes_gDsnGKHT(node.items, s_DeadBreak_DeadBreak_Always, t_void, (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (is_never_9CJmuVSD(if_last_iOPO4E2X(items).type.vtype))
    {
        _here = last_31malqbt(items).token;
        fail_gDsnGKHT("Noreturn during static init: this program will never finish booting."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        /*MOV*/ s_SolvedNode root = SolvedNode_gDsnGKHT(s_Kind_root, t_void, s_Flags{}, (*(const fu::str*)fu::NIL), items, s_Target{}, helpers, _here);
        runAllPasses_gDsnGKHT(root, _current_fn, ss, _helpers, _here, ctx, module, options);
        return /*NRVO*/ root;
    };
}

static s_SolvedNode solveArgID_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_SolvedNode expr = solveNode_gDsnGKHT(only_CiCfNZS0(node.items), type, _current_fn, ss, _helpers, _here, ctx, module, options);
    return solved_gDsnGKHT(node, expr.type, fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(expr) } }, s_Target{}, _here);
}

static s_SolvedNode solveArrlit_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Type itemType = (type ? tryClear_sliceable_1qjplDUo(type.vtype, _here, ctx, module) : s_Type{});
    if (!itemType && type && isUserType_27MV22ZA(type.vtype))
    {
        return solveCall_gDsnGKHT(node, (fu::slate<1, s_Target> { s_Target(lookupUserType_gDsnGKHT(type, ss, _helpers, _here, ctx, module, options).target) }), _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        fu::vec<s_SolvedNode> args = solveNodes_gDsnGKHT(node.items, s_DeadBreak_DeadBreak_Always, itemType, (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (is_never_9CJmuVSD(if_last_iOPO4E2X(args).type.vtype))
        {

            {
                const s_SolverNotes note = s_SolverNotes_N_DeadArrlit;
                if (note & options.break_notes)
                {
                    fu::view<char> reason = fu::view<char>{};
                    fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                }
                else
                    ss._notes |= note;

            };
            return createBlock_gDsnGKHT(t_never, args, s_Helpers{}, _here);
        }
        else if (!(node.flags & s_Flags_F_CALL_HAS_NAMED_ARGS))
            return createArrlit_gDsnGKHT(args, itemType, ss, _helpers, _here, ctx, module, options);
        else
        {
            fail_gDsnGKHT("TODO: solveArrlit: tryMatch by [ argnames: ... ] without function name."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static s_SolvedNode createBool_wyx7msfr(const fu::str& value, s_Type&& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    type.vtype.vfacts = ((value == "true"_fu) ? s_VFacts_AlwaysTrue : ((value == "false"_fu) ? s_VFacts_AlwaysFalse : BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options)));
    return SolvedNode_gDsnGKHT(s_Kind_bool, type, s_Flags{}, value, (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, s_Helpers{}, _here);
}

static s_SolvedNode createBool_FDl5ha9X(const bool value, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return createBool_wyx7msfr((value ? "true"_fu : "false"_fu), s_Type(t_bool), ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode createNot_gDsnGKHT(const s_SolvedNode& item, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (item.kind == s_Kind_bool)
    {
        if (item.value == "true"_fu)
            return createBool_FDl5ha9X(false, ss, _helpers, _here, ctx, module, options);
        else if (item.value == "false"_fu)
            return createBool_FDl5ha9X(true, ss, _helpers, _here, ctx, module, options);
        else
            BUG_gDsnGKHT(("Invalid bool literal: "_fu + qBAD_e44UlzzA(item.value)), ss, _helpers, _here, ctx, module, options);

    }
    else
    {
        s_Type type { t_bool };
        const s_StaticEval ae = tryAbstractEvalAsBool_gDsnGKHT(item, false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (ae)
            type.vtype.vfacts = ((ae == s_StaticEval_SE_True) ? s_VFacts_AlwaysFalse : s_VFacts_AlwaysTrue);

        return SolvedNode_gDsnGKHT(s_Kind_not, type, s_Flags{}, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode(item) } }, s_Target{}, s_Helpers{}, _here);
    };
}

static s_SolvedNode solveNot_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_SolvedNode item = solveNode_gDsnGKHT(only_CiCfNZS0(node.items), t_proposition, _current_fn, ss, _helpers, _here, ctx, module, options);
    _here = node.token;
    return createNot_gDsnGKHT(item, _current_fn, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode solveIf_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
    fu_DEFER(Scope_pop_gDsnGKHT(scope0, ss, _helpers));
    /*MOV*/ s_SolvedNode cond = solveNode_gDsnGKHT(node.items[0], t_proposition, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (is_never_9CJmuVSD(cond.type.vtype))
        return /*NRVO*/ cond;
    else
    {
        const s_StaticEval ae_cond = tryAbstractEvalAsBool_gDsnGKHT(cond, false, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (ae_cond)
            return createBlock_FDl5ha9X(static_cast<s_SolvedNode&&>(cond), solveNode_gDsnGKHT(node.items[((ae_cond == s_StaticEval_SE_True) ? 1 : 2)], type, _current_fn, ss, _helpers, _here, ctx, module, options), ss, _here, ctx, module);
        else
        {
            /*MOV*/ s_SolvedNode cons = solveNode_gDsnGKHT(node.items[1], type, _current_fn, ss, _helpers, _here, ctx, module, options);
            fu_DEFER(Scope_pop_gDsnGKHT(scope0, ss, _helpers));
            /*MOV*/ s_SolvedNode alt = solveNode_gDsnGKHT(node.items[2], type, _current_fn, ss, _helpers, _here, ctx, module, options);
            _here = node.token;
            return createIf_gDsnGKHT(cond, static_cast<s_SolvedNode&&>(cons), static_cast<s_SolvedNode&&>(alt), s_Type(type), _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
}

static s_SolvedNode solveOr_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
    fu_DEFER(Scope_pop_gDsnGKHT(scope0, ss, _helpers));
    /*MOV*/ fu::vec<s_SolvedNode> items = solveNodes_gDsnGKHT(node.items, s_DeadBreak_DeadBreak_Always, (is_void_9CJmuVSD(type.vtype) ? t_proposition : type), type, true, s_StaticEval_SE_True, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    return createOr_gDsnGKHT(static_cast<fu::vec<s_SolvedNode>&&>(items), s_Type(type), _current_fn, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode solveAnd_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
    fu_DEFER(Scope_pop_gDsnGKHT(scope0, ss, _helpers));
    const bool staticEvalBrk = is_void_or_propositionOK_9CJmuVSD(type, false, _here, ctx);
    /*MOV*/ fu::vec<s_SolvedNode> items = solveNodes_gDsnGKHT(node.items, (staticEvalBrk ? s_DeadBreak_DeadBreak_Always : s_DeadBreak{}), t_proposition, type, true, (staticEvalBrk ? s_StaticEval_SE_False : s_StaticEval{}), false, _current_fn, ss, _helpers, _here, ctx, module, options);
    return createAnd_gDsnGKHT(static_cast<fu::vec<s_SolvedNode>&&>(items), s_Type(type), _current_fn, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode solveLetStatement_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.kind == s_Kind_let)
        return solveNode_gDsnGKHT(node, t_void, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
        BUG_gDsnGKHT((x7E_3lDd4lqo("Expected a `let` statement, got: `"_fu, str_WkqQ7QhO(node.kind)) + "`."_fu), ss, _helpers, _here, ctx, module, options);

}

static s_SolvedNode solveLoop_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
    fu_DEFER(Scope_pop_gDsnGKHT(scope0, ss, _helpers));
    const int brk_idx = _helpers.size();
    int BL_1_v {};
    push_gDsnGKHT(s_HelpersData { s_Target{}, s_SolverPass{}, s_HelpersMask((s_HelpersMask_HM_Anon | s_HelpersMask_HM_CanBreak)), fu::str(node.value), (__extension__ (
    {
        const s_Target& t = _current_fn.out.target;
        BL_1_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
    (void)0;}), BL_1_v), GET_next_local_index_gDsnGKHT(_current_fn, ss, _here, ctx), s_Type{}, s_Type(t_void), s_Postdom{}, s_Postdom{}, s_EventsSnap{}, s_Helpers{} }, ss, _helpers);
    const s_Node& n_init = node.items[LOOP_INIT];
    const s_Node& n_pre_cond = node.items[LOOP_PRE_COND];
    const s_Node& n_pre = node.items[LOOP_PRE];
    const s_Node& n_body = node.items[LOOP_BODY];
    const s_Node& n_post = node.items[LOOP_POST];
    const s_Node& n_post_cond = node.items[LOOP_POST_COND];
    /*MOV*/ s_SolvedNode init = (n_init ? solveLetStatement_gDsnGKHT(n_init, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
    if (is_never_9CJmuVSD(init.type.vtype))
    {

        {
            const s_SolverNotes note = s_SolverNotes_N_DeadLoopInit;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
                ss._notes |= note;

        };
        return /*NRVO*/ init;
    }
    else
    {
        /*MOV*/ s_SolvedNode pre_cond = (n_pre_cond ? solveNode_gDsnGKHT(n_pre_cond, t_proposition, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
        /*MOV*/ s_SolvedNode pre = (n_pre ? solveBlock_gDsnGKHT(n_pre, t_void, 0, s_HelpersMask_HM_LoopPreheader, (*(const fu::str*)fu::NIL), 0, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
        /*MOV*/ s_SolvedNode body = (n_body ? solveBlock_gDsnGKHT(n_body, t_void, 0, s_HelpersMask_HM_LoopBody, (*(const fu::str*)fu::NIL), 0, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
        /*MOV*/ s_SolvedNode post = (n_post ? solveBlock_gDsnGKHT(n_post, t_void, 0, s_HelpersMask_HM_CanBreak, (*(const fu::str*)fu::NIL), 0, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
        /*MOV*/ s_SolvedNode post_cond = (n_post_cond ? solveNode_gDsnGKHT(n_post_cond, t_proposition, _current_fn, ss, _helpers, _here, ctx, module, options) : s_SolvedNode{});
        const s_Helpers& h = _helpers[brk_idx];
        const s_Type& type = ((!pre_cond && !post_cond && !s_HelpersMask(((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_LabelUsed))) ? t_never : t_void);

        {
            const s_TokenIdx& node_1 = node.token;
            if (node_1)
                _here = node_1;

        };
        return SolvedNode_gDsnGKHT(s_Kind_loop, type, s_Flags{}, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<6, s_SolvedNode> { static_cast<s_SolvedNode&&>(init), static_cast<s_SolvedNode&&>(pre_cond), static_cast<s_SolvedNode&&>(pre), static_cast<s_SolvedNode&&>(body), static_cast<s_SolvedNode&&>(post), static_cast<s_SolvedNode&&>(post_cond) } }, s_Target{}, h, _here);
    };
}

static const s_Helpers& Scope_lookupReturn_gDsnGKHT(const fu::str& id, const bool lambdaOK, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    {
        fu::view<s_Helpers> items = _helpers;
        fu::view<s_ScopeSkip> ss_1 = ss._ss.helpers;
        int ssi = (ss_1.size() - 1);
        int ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
        for (int i = items.size(); i-- > 0; )
        {
            if ((ssi >= 0) && (i == ssN))
            {
                i = ss_1[ssi--].start;
                ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
            }
            else
            {
                const s_Helpers& item = items[i];
                if (!(!s_HelpersMask(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_CanReturn))))
                {
                    if (!(s_HelpersMask(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Lambda)) && !lambdaOK))
                    {
                        if (!(id && ((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).id != id)))
                            return item;

                    };
                };
            };
        };
    };
    fail_gDsnGKHT((("No return "_fu + qBAD_e44UlzzA(id)) + " in scope."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_each_J0z7WhnfxVk
                                #define DEF_each_J0z7WhnfxVk
inline void each_J0z7Whnf(fu::view<s_ScopeSkip> a, int& i)
{
    for (int i_1 = 0; i_1 < a.size(); i_1++)
    {
        const s_ScopeSkip& skip = a[i_1];
        if (i == skip.start)
            i = skip.end;
        else if (i < skip.start)
            return;

    };
}
                                #endif

static const s_Helpers& Scope_lookupLabel_FDl5ha9X(const fu::str& id, const bool cont, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int CONTINUE_BELOW {};

    {
        fu::view<s_Helpers> items = _helpers;
        fu::view<s_ScopeSkip> ss_1 = ss._ss.helpers;
        int ssi = (ss_1.size() - 1);
        int ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
        for (int i = items.size(); i-- > 0; )
        {
            if ((ssi >= 0) && (i == ssN))
            {
                i = ss_1[ssi--].start;
                ssN = ((ssi >= 0) ? (ss_1[ssi].end - 1) : 0);
            }
            else
            {
                const s_Helpers& item = items[i];
                if (i < (CONTINUE_BELOW - 1))
                    i++;

                if (!s_HelpersMask(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_CanBreak)))
                {
                    if (!CONTINUE_BELOW)
                    {
                        if (id || !s_HelpersMask(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Lambda)))
                            continue;
                        else if (!cont)
                        {
                            CONTINUE_BELOW = i;
                            continue;
                        };
                    };
                }
                else if (!CONTINUE_BELOW)
                {
                    if (!(id ? ((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).id == id) : !!s_HelpersMask(((((item.index >= 0) && (item.index < ss._helpers_data.size())) ? ss._helpers_data[item.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).mask & s_HelpersMask_HM_Anon))))
                        continue;
                    else if (cont)
                    {
                        i++;
                        each_J0z7Whnf(ss._ss.helpers, i);
                        if (!(i < _helpers.size()))
                        {
                            fail_gDsnGKHT((((("Cannot "_fu + qBAD_e44UlzzA(("continue :"_fu + id))) + " from here, did you mean to "_fu) + qKW_e44UlzzA("break"_fu)) + "?"_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                        };
                    };
                };
                return _helpers[i];
            };
        };
    };
    if (id)
    {
        fail_gDsnGKHT((("No label "_fu + qBAD_e44UlzzA(id)) + " in scope."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        fail_gDsnGKHT((("Nothing to "_fu + qBAD_e44UlzzA((cont ? "continue"_fu : "break"_fu))) + " from here."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
    };
}

static s_SolvedNode solveDeclExpr_gDsnGKHT(const s_Node& node, const bool TODO_FIX_useSpecPath, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode res { only_LqU08rcL(solveNodes_gDsnGKHT((fu::slate<1, s_Node> { s_Node(node) }), s_DeadBreak_DeadBreak_Dont, (*(const s_Type*)fu::NIL), (*(const s_Type*)fu::NIL), false, s_StaticEval{}, TODO_FIX_useSpecPath, _current_fn, ss, _helpers, _here, ctx, module, options)) };
    if (res.target && (GET_gDsnGKHT(res.target, ss, _here, ctx, module).kind == s_Kind_type))
        res.type = GET_gDsnGKHT(res.target, ss, _here, ctx, module).type;

    return /*NRVO*/ res;
}

static s_SolvedNode solveJump_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Helpers h { ((node.kind == s_Kind_return) ? Scope_lookupReturn_gDsnGKHT(node.value, !!(node.flags & F_TODO_FIX_TRAILING_RETURN), ss, _helpers, _here, ctx, module, options) : Scope_lookupLabel_FDl5ha9X(node.value, (node.kind == s_Kind_continue), ss, _helpers, _here, ctx, module, options)) };
    if (h)
    {
        const s_Node& n_expr = if_only_iY1ARePC(node.items);
        /*MOV*/ s_SolvedNode expr = (!n_expr ? createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options) : (unorderedClassify_gDsnGKHT(n_expr.kind) ? solveDeclExpr_gDsnGKHT(n_expr, ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).target == _current_fn.out.target), _current_fn, ss, _helpers, _here, ctx, module, options) : solveNode_gDsnGKHT(n_expr, ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual ? clear_vfacts_9CJmuVSD(s_Type((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_actual)) : s_Type((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect)), _current_fn, ss, _helpers, _here, ctx, module, options)));
        if (is_never_9CJmuVSD(expr.type.vtype))
            return /*NRVO*/ expr;
        else
        {
            if ((node.flags & F_TODO_FIX_TRAILING_RETURN) && TODO_FIX_optionalSemis_blockWantsVoid_gDsnGKHT((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx))))
            {
                expr = createBlock_FDl5ha9X(s_SolvedNode(expr), createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options), ss, _here, ctx, module);
            };
            if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect)
                tryConvertIfNeeded_gDsnGKHT(expr, s_Type((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).ret_expect), false, _current_fn, ss, _helpers, _here, ctx, module, options);

            int BL_6_v {};
            if ((((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).local_of != (__extension__ (
            {
                const s_Target& t = _current_fn.out.target;
                BL_6_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
            (void)0;}), BL_6_v))
            {
                add_8Ex4Hrql(_current_fn.far_jumps, (((h.index >= 0) && (h.index < ss._helpers_data.size())) ? ss._helpers_data[h.index] : BUG_u9Gbkniv("Helpers.GET: h.index is oob"_fu, _here, ctx)).local_of);
                return SolvedNode_gDsnGKHT(s_Kind___far_jump, t_never, node.flags, (*(const fu::str*)fu::NIL), fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { static_cast<s_SolvedNode&&>(expr) } }, s_Target{}, h, _here);
            }
            else
            {
                _here = node.token;
                return solveJump_finish_gDsnGKHT(node.flags, expr, h, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    }
    else
        BUG_gDsnGKHT("solveJump: empty jump target"_fu, ss, _helpers, _here, ctx, module, options);

}

static s_SolvedNode solveInt_FDl5ha9X(const s_Node& node, const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    return solved_gDsnGKHT(node, solveInt_gDsnGKHT(node.value, type, ss, _helpers, _here, ctx, module, options), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, _here);
}

static s_SolvedNode solveReal_FDl5ha9X(const s_Node& node, const s_Type& type, const s_TokenIdx& _here)
{
    return solved_gDsnGKHT(node, solveReal_gDsnGKHT(type), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, _here);
}

static s_SolvedNode solveString_FDl5ha9X(const s_Node& node, const s_Type& type, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_Type type_1 = solveString_gDsnGKHT(node.value, type, ss, _here, ctx, module, options);
    if (type_1.vtype.vfacts & s_VFacts_AlwaysFalse)
    {
        if (node.value)
            BUG_gDsnGKHT((("solveString: AlwaysFalse but non-empty: `"_fu + node.value) + "`."_fu), ss, _helpers, _here, ctx, module, options);
        else
        {
            return createEmpty_gDsnGKHT(type_1, s_Target{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
    {
        return solved_gDsnGKHT(node, type_1, (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, _here);
    };
}

                                #ifndef DEF_only_2Om2RuuETKl
                                #define DEF_only_2Om2RuuETKl
inline char only_2Om2RuuE(fu::view<char> s)
{
    fu_ASSERT((s.size() == 1));
    return s[0];
}
                                #endif

static s_SolvedNode solveChar_gDsnGKHT(const s_Node& node, const s_TokenIdx& _here, const s_Options& options)
{
    s_Type type { t_byte };
    if (!s_DevOptions((options.dev & s_DevOptions_DEV_DontFoldLiterals)))
        type.vtype.vfacts = (only_2Om2RuuE(node.value) ? s_VFacts_AlwaysTrue : s_VFacts_AlwaysFalse);

    return solved_gDsnGKHT(node, type, (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, _here);
}

static s_SolvedNode solveBool_gDsnGKHT(const fu::str& value, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode ret = createBool_wyx7msfr(value, s_Type(t_bool), ss, _helpers, _here, ctx, module, options);
    if (options.dev & s_DevOptions_DEV_DontFoldLiterals)
    {
        ret.type.vtype.vfacts = s_VFacts{};
    };
    return /*NRVO*/ ret;
}

static void visit_p7GM6uKi(const int modid, s_SolverState& ss, const s_TokenIdx& _here, const s_Context& ctx)
{
    if (!(!Scope_import_gDsnGKHT(modid, ss, _here, ctx)))
    {
        const s_Scope& s = ctx.modules[modid].out.solve.scope;
        for (int i = 0; i < s.imports.size(); i++)
            visit_p7GM6uKi(s.imports[i], ss, _here, ctx);

    };
}

static s_SolvedNode solveImport_gDsnGKHT(const s_Node& node, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int offset = 0;
    const s_Module& m = findModule_gDsnGKHT(node.value, offset, ss, _helpers, _here, ctx, module, options);
    visit_p7GM6uKi(m.modid, ss, _here, ctx);
    if (node.flags & s_Flags_F_PUB)
    {
        if (_current_fn.scope0)
        {
            fail_gDsnGKHT("Cannot pub import from here."_fu, fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            add_8Ex4Hrql(ss._pub_imports, m.modid);

    };
    return createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
}

static s_SolvedNode solveDefer_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    /*MOV*/ s_SolvedNode item = solveNode_gDsnGKHT(only_CiCfNZS0(node.items), t_void, _current_fn, ss, _helpers, _here, ctx, module, options);
    return solved_gDsnGKHT(node, t_void, fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { static_cast<s_SolvedNode&&>(item) } }, s_Target{}, _here);
}

                                #ifndef DEF_t_string
                                #define DEF_t_string
extern const s_Type t_string;
                                #endif

static s_SolvedNode solveTryCatch_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.items.size() == 3)
    {
        const s_ScopeMemo scope0 = Scope_snap_gDsnGKHT(ss, _helpers);
        /*MOV*/ s_SolvedNode tRy = solveNode_gDsnGKHT(node.items[0], t_void, _current_fn, ss, _helpers, _here, ctx, module, options);
        Scope_pop_gDsnGKHT(scope0, ss, _helpers);
        const s_ScopeMemo scope0_1 = Scope_snap_gDsnGKHT(ss, _helpers);
        /*MOV*/ s_SolvedNode err = solveLetStatement_gDsnGKHT(node.items[1], _current_fn, ss, _helpers, _here, ctx, module, options);
        /*MOV*/ s_SolvedNode cAtch = solveNode_gDsnGKHT(node.items[2], t_void, _current_fn, ss, _helpers, _here, ctx, module, options);
        Scope_pop_gDsnGKHT(scope0_1, ss, _helpers);
        if ((err.kind == s_Kind_letdef) && isAssignableAsArgument_9CJmuVSD(GET_gDsnGKHT(err.target, ss, _here, ctx, module).solved.type.vtype, definitType_9CJmuVSD(s_Type(t_string), false, _here, ctx).vtype, false, _here, ctx))
        {
            const s_Type& type = ((is_never_9CJmuVSD(tRy.type.vtype) && is_never_9CJmuVSD(cAtch.type.vtype)) ? t_never : t_void);
            return solved_gDsnGKHT(node, type, fu::vec<s_SolvedNode> { fu::slate<3, s_SolvedNode> { static_cast<s_SolvedNode&&>(tRy), static_cast<s_SolvedNode&&>(err), static_cast<s_SolvedNode&&>(cAtch) } }, s_Target{}, _here);
        }
        else
        {
            fail_gDsnGKHT(("catch: exceptions are strings,"_fu + " consider dropping the annotation."_fu), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
    {
        BUG_gDsnGKHT(fu::str{}, ss, _helpers, _here, ctx, module, options);
    };
}

static s_SolvedNode solveTypeCast_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    const s_Node& left = node.items[0];
    const s_Node& right = node.items[1];
    s_Type expect = evalTypeAnnot_gDsnGKHT(right, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    /*MOV*/ s_SolvedNode actual = solveNode_gDsnGKHT(left, expect, _current_fn, ss, _helpers, _here, ctx, module, options);
    convertIfNeeded_gDsnGKHT(actual, expect, "Cannot convert: "_fu, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    return /*NRVO*/ actual;
}

static s_SolvedNode solveTypeAssert_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Map_lhf7SV3Fyjf typeParams0 = steal_HPql5iRS(ss._typeParams);
    fu_DEFER(std::swap(ss._typeParams, typeParams0));
    bool _0 {};
    return (_0 = evalTypePattern_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options), createBool_FDl5ha9X(_0, ss, _helpers, _here, ctx, module, options));
}

static s_SolvedNode solveTypeParam_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_Type _0 {};
    return (_0 = evalTypeParam_gDsnGKHT(node.value, _current_fn, ss, _helpers, _here, ctx, module, options), solved_gDsnGKHT(node, static_cast<s_Type&&>(_0), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, _here));
}

static s_SolvedNode solveAddrOfFn_gDsnGKHT(const s_Node& node, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const fu::str& id = node.value;
    s_Type type = X_addrofTarget_gDsnGKHT(solveAddrOfFn_FDl5ha9X(fu::str(id), node.token, node.flags, ss, _helpers, _here, ctx, module, options));
    return createEmpty_gDsnGKHT(type, s_Target{}, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_starts_hRi5tkxndc1
                                #define DEF_starts_hRi5tkxndc1
inline bool starts_hRi5tkxn(fu::view<char> a, fu::view<char> with)
{
    return (a.size() >= with.size()) && (fu::get_view_start0(a, with.size()) == with);
}
                                #endif

                                #ifndef DEF___Uc6i50ukn21
                                #define DEF___Uc6i50ukn21
inline static void _Uc6i50uk(s_Node& item, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const s_ScopeItem& field)
{
    const int idx = ((item.value == placeholder) ? 0 : (starts_hRi5tkxn(item.value, prefix) ? 0 : (ends_JkFJYOhR(item.value, suffix) ? (item.value.size() - placeholder.size()) : find_5WUbOXwW(item.value, inside))));
    if ((idx >= 0))
    {
        if (item.kind == s_Kind_call)
            item.value.splice(idx, placeholder.size(), field.id);
        else if (item.kind == s_Kind_str)
            item.value.splice(idx, placeholder.size(), field.id);

    };
}
                                #endif

static void walk_gDsnGKHT(s_Node& node, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const s_ScopeItem& field)
{
    for (int i = 0; i < node.items.size(); i++)
    {
        s_Node* _0;
        (_0 = &(node.items.mutref(i)), walk_gDsnGKHT(*_0, placeholder, prefix, suffix, inside, field));
    };
    _Uc6i50uk(node, placeholder, prefix, suffix, inside, field);
}

                                #ifndef DEF_astReplace_ewRvu3bYk3l
                                #define DEF_astReplace_ewRvu3bYk3l
inline static s_Node astReplace_ewRvu3bY(const s_Node& node, fu::view<char> placeholder, fu::view<char> prefix, fu::view<char> suffix, fu::view<char> inside, const s_ScopeItem& field)
{
    /*MOV*/ s_Node node_1 { node };
    walk_gDsnGKHT(node_1, placeholder, prefix, suffix, inside, field);
    return /*NRVO*/ node_1;
}
                                #endif

static s_SolvedNode solveForFieldsOf_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    fu::view<char> placeholder = node.value;
    const s_Node& body_template = node.items[1];
    fu::str prefix = (placeholder + "_"_fu);
    fu::str suffix = ("_"_fu + placeholder);
    fu::str inside = (("_"_fu + placeholder) + "_"_fu);
    s_Type _0 {};
    fu::view<s_ScopeItem> fields = (_0 = evalTypeAnnot_gDsnGKHT(node.items[0], false, _current_fn, ss, _helpers, _here, ctx, module, options), lookupUserType_gDsnGKHT(static_cast<s_Type&&>(_0), ss, _helpers, _here, ctx, module, options)).items;
    fu::vec<s_Node> items_ast {};
    for (int i = 0; i < fields.size(); i++)
    {
        const s_ScopeItem& field = fields[i];
        items_ast += astReplace_ewRvu3bY(body_template, placeholder, prefix, suffix, inside, field);
    };
    fu::vec<s_SolvedNode> items = solveNodes_gDsnGKHT(items_ast, s_DeadBreak_DeadBreak_Always, t_void, (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    const s_Type& type = (is_never_9CJmuVSD(if_last_iOPO4E2X(items).type.vtype) ? t_never : t_void);
    return createBlock_gDsnGKHT(type, items, s_Helpers{}, _here);
}

static void compilerBreak_gDsnGKHT()
{
    // Hoisted:
    fu::str x {};

    fu::println((fu::slate<1, fu::str> { static_cast<fu::str&&>((x = "[[[ BREAKPOINT HERE ]]]"_fu, x)) }));
}

static s_SolvedNode executeCompilerPragma_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.value != "break"_fu)
    {
        fu::vec<s_SolvedNode> _0 {};
        return (_0 = solveNodes_gDsnGKHT(node.items, s_DeadBreak_DeadBreak_Dont, (*(const s_Type*)fu::NIL), (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options), SolvedNode_gDsnGKHT(s_Kind_pragma, t_void, s_Flags{}, node.value, static_cast<fu::vec<s_SolvedNode>&&>(_0), s_Target{}, s_Helpers{}, _here));
    }
    else
    {
        compilerBreak_gDsnGKHT();
        return createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
    };
}

static s_SolvedNode createUnwrap_gDsnGKHT(const s_TokenIdx& _here)
{
    return SolvedNode_gDsnGKHT(s_Kind_unwrap, t_void, s_Flags{}, (*(const fu::str*)fu::NIL), (*(const fu::vec<s_SolvedNode>*)fu::NIL), s_Target{}, s_Helpers{}, _here);
}

                                #ifndef DEF_first_7s1dKaE2ptk
                                #define DEF_first_7s1dKaE2ptk
inline const s_Node& first_7s1dKaE2(fu::view<s_Node> s)
{
    return s[0];
}
                                #endif

static s_SolvedNode solveCallIndirect_gDsnGKHT(const s_Node& node, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{
    if (node.items.size())
    {
        fu::vec<s_Target> targets {};
        s_SolvedNode head = solveCall_gDsnGKHT(first_7s1dKaE2(node.items), fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
        if (isAddrOfFn_9CJmuVSD(head.type))
            unpackAddrOfFn_WRkTvJWx(head.type.vtype.canon, targets);
        else if (is_Typename_9CJmuVSD(head.type))
        {
            const s_UserType& s = tryLookupUserType_1qjplDUo(head.type.vtype, _here, ctx, module);
            if (s.target)
                targets += s_Target(s.target);

        };
        if (!targets)
        {
            fail_gDsnGKHT(("Indirect call: expression does not evaluate to an overload set: "_fu + explainType_gDsnGKHT(head.type, false, false, false, false, false, (*(const s_Type*)fu::NIL), ss, _here, ctx, module, options)), fu::view<char>{}, s_TokenIdx(first_7s1dKaE2(node.items).token), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
        {
            /*MOV*/ fu::vec<s_SolvedNode> args = solveNodes_gDsnGKHT(fu::get_view(node.items, 1), s_DeadBreak_DeadBreak_Only_WhileSolvingRecursion, (*(const s_Type*)fu::NIL), (*(const s_Type*)fu::NIL), false, s_StaticEval{}, false, _current_fn, ss, _helpers, _here, ctx, module, options);
            if (is_AssumeNever_WhileSolvingRecursion_9CJmuVSD(if_last_iOPO4E2X(args).type.vtype))
                return s_SolvedNode(last_31malqbt(args));
            else
            {
                return solveCall_FDl5ha9X("__indirect"_fu, static_cast<fu::vec<s_SolvedNode>&&>(args), s_Flags{}, targets, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    }
    else
        BUG_gDsnGKHT("solveCallIndirect: No head node, nothing to call."_fu, ss, _helpers, _here, ctx, module, options);

}

static s_SolvedNode solveNode_gDsnGKHT(const s_Node& node, const s_Type& type, s_CurrentFn& _current_fn, s_SolverState& ss, fu::vec<s_Helpers>& _helpers, s_TokenIdx& _here, const s_Context& ctx, s_Module& module, const s_Options& options)
{

    {
        const s_TokenIdx& node_1 = node.token;
        if (node_1)
            _here = node_1;

    };
    const s_Kind k = node.kind;
    if (k == s_Kind_root)
        return solveRoot_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_block)
        return solveBlock_gDsnGKHT(node, type, 0, s_HelpersMask_HM_CanBreak, (*(const fu::str*)fu::NIL), 0, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_argid)
        return solveArgID_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_let)
        return solveLet_gDsnGKHT(node, false, (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_call)
    {
        return solveCall_gDsnGKHT(node, fu::view<s_Target>{}, _current_fn, ss, _helpers, _here, ctx, module, options);
    }
    else if (k == s_Kind_arrlit)
        return solveArrlit_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_not)
        return solveNot_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_if)
        return solveIf_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_or)
        return solveOr_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_and)
        return solveAnd_gDsnGKHT(node, type, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_loop)
        return solveLoop_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_break)
        return solveJump_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_return)
        return solveJump_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_continue)
        return solveJump_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_int)
        return solveInt_FDl5ha9X(node, type, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_real)
        return solveReal_FDl5ha9X(node, type, _here);
    else if (k == s_Kind_str)
        return solveString_FDl5ha9X(node, type, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_char)
        return solveChar_gDsnGKHT(node, _here, options);
    else if (k == s_Kind_bool)
        return solveBool_gDsnGKHT(node.value, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_definit)
        return solveDefinit_gDsnGKHT(type, _here, ctx);
    else if (k == s_Kind_import)
        return solveImport_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_defer)
        return solveDefer_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_try)
        return solveTryCatch_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_typecast)
        return solveTypeCast_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_typeassert)
        return solveTypeAssert_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_typeparam)
        return solveTypeParam_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_addroffn)
        return solveAddrOfFn_gDsnGKHT(node, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_forfieldsof)
        return solveForFieldsOf_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_pragma)
        return executeCompilerPragma_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (k == s_Kind_empty)
    {
        return createEmpty_gDsnGKHT(t_void, s_Target{}, ss, _helpers, _here, ctx, module, options);
    }
    else if (k == s_Kind_unwrap)
        return createUnwrap_gDsnGKHT(_here);
    else if (k == s_Kind_call_indir)
        return solveCallIndirect_gDsnGKHT(node, _current_fn, ss, _helpers, _here, ctx, module, options);
    else if (unorderedClassify_gDsnGKHT(k))
        return solveDeclExpr_gDsnGKHT(node, false, _current_fn, ss, _helpers, _here, ctx, module, options);
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("solve: Unexpected "_fu, str_WkqQ7QhO(k)), ss, _helpers, _here, ctx, module, options);

}

static void hash_gDsnGKHT(s_TEA& hash, const s_Type& type, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module)
{
    hash_lweHUmk8(hash, s_TEA { unsigned((type.vtype.quals & q_TAGS)), (type.lifetime.uni0n.size() ? unsigned(1) : 0u) });
    hash_qRo1x0wq(hash, getShape_1qjplDUo(type.vtype, _here, ctx, module).hash);
}

                                #ifndef DEF_typeof_fCctcC5U0w4
                                #define DEF_typeof_fCctcC5U0w4
inline fu::vec<s_SolvedNode> typeof_fCctcC5U()
{
    return fu::vec<s_SolvedNode>{};
}
                                #endif

                                #ifndef DEF_x5Bx5D_vJ8BEFlJAea
                                #define DEF_x5Bx5D_vJ8BEFlJAea
inline fu::vec<s_SolvedNode> x5Bx5D_vJ8BEFlJ()
{
    return typeof_fCctcC5U();
}
                                #endif

static void sighashNode_gDsnGKHT(const s_SolvedNode& n, const s_Target& fn_target, s_TEA& hash, s_Map_4FUR4uzUhqd& name_counts, fu::vec<s_Target>& already_hashing, s_Set_aQNJhbMknMf& cycle_participants, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (isImmediatelyDiscardable_UVY6Qzz1(n.kind))
    {
        if (n.value)
            hash_l6RUR9Sz(hash, n.value);

    }
    else
    {
        hash_lweHUmk8(hash, s_TEA { unsigned(n.kind), unsigned(n.items.size()) });
        for (int i = 0; i < n.items.size(); i++)
            sighashNode_gDsnGKHT(n.items[i], fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);

        if (n.kind == s_Kind_letdef)
            sighashNode_gDsnGKHT(GET_gDsnGKHT(n.target, ss, _here, ctx, module).solved, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);
        else if (n.kind == s_Kind_let)
        {
            int BL_8_v {};
            hash_qRo1x0wq(hash, uint64_t(unsigned((__extension__ (
            {
                const s_Target& t = n.target;
                const unsigned v = unsigned((t._packed & 0xfffffull));
                BL_8_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_8_v))));
            hash_gDsnGKHT(hash, n.type, _here, ctx, module);
        }
        else if (n.kind == s_Kind_call)
        {
            const s_Target& target = n.target;
            int BL_10_v {};
            const int locid = (__extension__ (
            {
                const unsigned v = unsigned((target._packed & 0xfffffull));
                BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
            (void)0;}), BL_10_v);
            if (locid)
                hash_qRo1x0wq(hash, uint64_t(unsigned(locid)));
            else
            {
                const s_Overload& o = GET_gDsnGKHT(target, ss, _here, ctx, module);
                const s_Kind k = o.kind;
                if (k == s_Kind_fn)
                {
                    s_TEA sighash { EXT_gDsnGKHT(target, ss, ctx, module).sighash };
                    if (!sighash)
                    {
                        const int idx = find_H5f3kK8G(already_hashing, target);
                        if ((idx >= 0))
                        {
                            add_eAAgIA81(cycle_participants, fn_target);
                            sighash = s_TEA { 0xffffffffu, unsigned(idx) };
                        }
                        else if (int(unsigned(((target._packed >> 40ull) & 0xfffffull))) == module.modid)
                            sighash = computeFnSighash_gDsnGKHT(target, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);
                        else
                        {
                            BUG_gDsnGKHT(("Off-module fn with no sighash: "_fu + explainWhichFn_gDsnGKHT(s_Target(target), fu::view<fu::vec<s_Target>>{}, fu::view<char>{}, s_CodeFmt_NoContext, _current_fn, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);
                        };
                    };
                    hash_lweHUmk8(hash, sighash);
                }
                else if ((k == s_Kind___native) || (k == s_Kind_enumv))
                    hash_l6RUR9Sz(hash, o.name);
                else if (k == s_Kind_field)
                {
                    const int offset = field_unpackOffset_gDsnGKHT(o, _here, ctx).memberFlatOffset;
                    hash_qRo1x0wq(hash, uint64_t(unsigned(offset)));
                }
                else if (k == s_Kind_var)
                    sighashNode_gDsnGKHT(o.solved, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);
                else if ((k != s_Kind_type) && (k != s_Kind_definit))
                    BUG_gDsnGKHT(x7E_3lDd4lqo("computeFnSighash: no support for kind="_fu, str_WkqQ7QhO(k)), ss, _helpers, _here, ctx, module, options);

            };
        };
    };
}

                                #ifndef DEF___Hel7V27imM0
                                #define DEF___Hel7V27imM0
inline static void _Hel7V27i(const s_SolvedNode& _, const s_Target& fn_target, s_TEA& hash, s_Map_4FUR4uzUhqd& name_counts, fu::vec<s_Target>& already_hashing, s_Set_aQNJhbMknMf& cycle_participants, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    sighashNode_gDsnGKHT(_, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);
}
                                #endif

                                #ifndef DEF_each_DlYbKXRSlJi
                                #define DEF_each_DlYbKXRSlJi
inline void each_DlYbKXRS(fu::view<s_SolvedNode> a, const s_Target& fn_target, s_TEA& hash, s_Map_4FUR4uzUhqd& name_counts, fu::vec<s_Target>& already_hashing, s_Set_aQNJhbMknMf& cycle_participants, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
        _Hel7V27i(a[i], fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_bfind_XrSQwdKPzu1
                                #define DEF_bfind_XrSQwdKPzu1
inline static int bfind_XrSQwdKP(fu::view<fu::str> keys_asc, fu::view<char> key, s_Set_6ARmtH0K78f& _, const fu::str& key_1, fu::vec<unsigned>& values)
{
    int lo = 0;
    int hi = keys_asc.size();
    while (lo < hi)
    {
        const int i = ((hi + lo) >> 1);
        const int cmp = x3Cx3E_bv5nK4Kl(keys_asc[i], key);
        if (cmp == 0)
            return i;
        else if (cmp < 0)
            lo = (i + 1);
        else
            hi = i;

    };
    const int i = lo;
    values.insert(i, unsigned{});
    _.keys_asc.insert(i, fu::str(key_1));
    return i;
}
                                #endif

                                #ifndef DEF_ref_Q26BRlxfdDj
                                #define DEF_ref_Q26BRlxfdDj
inline unsigned& ref_Q26BRlxf(s_Set_6ARmtH0K78f& _, const fu::str& key, fu::vec<unsigned>& values)
{
    const int idx = bfind_XrSQwdKP(_.keys_asc, key, _, key, values);
    return values.mutref(idx);
}
                                #endif

                                #ifndef DEF_ref_gwayvOknZik
                                #define DEF_ref_gwayvOknZik
inline unsigned& ref_gwayvOkn(s_Map_4FUR4uzUhqd& _, const fu::str& key)
{
    return ref_Q26BRlxf(_.keys, key, _.vals);
}
                                #endif

static const s_TEA& computeFnSighash_gDsnGKHT(const s_Target& fn_target, s_Map_4FUR4uzUhqd& name_counts, fu::vec<s_Target>& already_hashing, s_Set_aQNJhbMknMf& cycle_participants, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    s_TEA hash {};
    const s_Overload& o = GET_gDsnGKHT(fn_target, ss, _here, ctx, module);
    if (o.kind == s_Kind_fn)
    {
        if (o.flags & s_Flags_F_TEMPLATE)
        {
            hash_gDsnGKHT(hash, o.type, _here, ctx, module);
            fu::vec<s_SolvedNode> TODO_FIX = (o.solved.items + x5Bx5D_vJ8BEFlJ());
            already_hashing += s_Target(fn_target);
            each_DlYbKXRS(TODO_FIX, fn_target, hash, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options);
            already_hashing.pop();
        }
        else
        {
            hash_l6RUR9Sz(hash, ss.shortModuleName);
            hash_qw8SyzVJ(hash, ref_gwayvOkn(name_counts, GET_gDsnGKHT(fn_target, ss, _here, ctx, module).name)++);
        };
        s_TEA* _0;
        const s_TEA& sighash = ((!*(_0 = &(EXT_mut_gDsnGKHT(fn_target, ss, module).sighash)) ? *_0 : BUG_gDsnGKHT("sighash already set"_fu, ss, _helpers, _here, ctx, module, options)) = s_TEA(non_zero_lweHUmk8(hash)));
        return sighash;
    }
    else
        BUG_gDsnGKHT(x7E_3lDd4lqo("computeFnSighash: Not a fn: "_fu, str_FDl5ha9X(fn_target, false, ss, _here, ctx, module, options)), ss, _helpers, _here, ctx, module, options);

}

                                #ifndef DEF___iYYyqrNqiSh
                                #define DEF___iYYyqrNqiSh
inline static void _iYYyqrNq(const s_Target& target, const s_TEA& cycle_root_hash, s_SolverState& ss, const s_Module& module)
{
    hash_lweHUmk8(EXT_mut_gDsnGKHT(target, ss, module).sighash, cycle_root_hash);
}
                                #endif

                                #ifndef DEF_each_e09919597a9
                                #define DEF_each_e09919597a9
inline void each_e0991959(fu::view<s_Target> a, const s_TEA& cycle_root_hash, s_SolverState& ss, const s_Module& module)
{
    for (int i = 0; i < a.size(); i++)
        _iYYyqrNq(a[i], cycle_root_hash, ss, module);

}
                                #endif

static void computeFnSighash_asIfCycleRoot_gDsnGKHT(const s_Target& fn_target, s_Map_4FUR4uzUhqd& name_counts, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::vec<s_Target> already_hashing {};
    s_Set_aQNJhbMknMf cycle_participants {};
    const s_TEA cycle_root_hash { computeFnSighash_gDsnGKHT(fn_target, name_counts, already_hashing, cycle_participants, _current_fn, ss, _helpers, _here, ctx, module, options) };
    const s_Set_aQNJhbMknMf& _ = cycle_participants;
    each_e0991959(_.keys_asc, cycle_root_hash, ss, module);
}

                                #ifndef DEF_ensure_nXAz6yiaY50
                                #define DEF_ensure_nXAz6yiaY50
inline s_BitSet& ensure_nXAz6yia(fu::vec<s_BitSet>& a, const int i)
{
    if ((a.size() <= i))
        a.grow((i + 1));

    return a.mutref(i);
}
                                #endif

                                #ifndef DEF___MtWLCOPSdi2
                                #define DEF___MtWLCOPSdi2
inline static void _MtWLCOPS(const s_Argument& host_arg, const int i, fu::vec<s_BitSet>& _may_alias, fu::vec<int>& _argPos_1b, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (!(!is_ref_9CJmuVSD(host_arg.type)))
    {
        int BL_2_v {};
        ensure_qSTqnenA(_argPos_1b, (-1 - (__extension__ (
        {
            const s_Target& t = host_arg.target;
            const unsigned v = unsigned((t._packed & 0xfffffull));
            BL_2_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_2_v))) = (i + 1);
        const s_BitSet& may_alias = (host_arg.written_to ? host_arg.may_alias : (*(const s_BitSet*)fu::NIL));
        if (may_alias)
        {
            if (!is_mutref_9CJmuVSD(host_arg.type, _here, ctx))
                BUG_gDsnGKHT("ensureArgSequencing: F_WRITTEN_TO but !is_mutref"_fu, ss, _helpers, _here, ctx, module, options);
            else if (!has_ZwXYCruz(may_alias, i))
                BUG_gDsnGKHT("ensureArgSequencing: may_alias does not list self [1]"_fu, ss, _helpers, _here, ctx, module, options);

            ensure_nXAz6yia(_may_alias, i) = s_BitSet(may_alias);
        };
    };
}
                                #endif

                                #ifndef DEF_each_N1IZx7eezd7
                                #define DEF_each_N1IZx7eezd7
inline void each_N1IZx7ee(fu::view<s_Argument> a, fu::vec<s_BitSet>& _may_alias, fu::vec<int>& _argPos_1b, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    for (int i = 0; i < a.size(); i++)
        _MtWLCOPS(a[i], i, _may_alias, _argPos_1b, ss, _helpers, _here, ctx, module, options);

}
                                #endif

                                #ifndef DEF_iF_R0TDZOMOWPd
                                #define DEF_iF_R0TDZOMOWPd
inline const s_BitSet& iF_R0TDZOMO(fu::view<s_BitSet> a, const int i)
{
    if (uNsigned_fAw9WufW(i) < uNsigned_fAw9WufW(a.size()))
        return a[i];
    else
        return (*(const s_BitSet*)fu::NIL);

}
                                #endif

                                #ifndef DEF___J2PqUOXpeA1
                                #define DEF___J2PqUOXpeA1
inline static void _J2PqUOXp(const int locid, s_Regions& regions, const bool dontUse_may_alias, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (locid && add_gDsnGKHT(regions.locids, locid, _current_fn))
    {
        const int argPos_1b = iF_zuMlNyDQ(_argPos_1b, (-1 - locid));
        if (argPos_1b)
        {
            const int i = (argPos_1b - 1);
            const s_BitSet& may_alias = (!dontUse_may_alias ? iF_R0TDZOMO(_may_alias, i) : (*(const s_BitSet*)fu::NIL));
            if (may_alias)
            {
                if (!has_ZwXYCruz(may_alias, i))
                    BUG_gDsnGKHT("ensureArgSequencing: may_alias does not list self [2]"_fu, ss, _helpers, _here, ctx, module, options);
                else
                    regions.arguments |= may_alias;

            }
            else
                add_ZwXYCruz(regions.arguments, i);

        };
        flag_gDsnGKHT(regions, Lifetime_climbType_gDsnGKHT(nested_FDl5ha9X(locid, ss, _here, ctx), ss, _helpers, _here, ctx, module, options).lifetime, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

                                #ifndef DEF_Lifetime_each_70YipEZd7zg
                                #define DEF_Lifetime_each_70YipEZd7zg
inline void Lifetime_each_70YipEZd(const s_Lifetime& lifetime, s_Regions& regions, const bool dontUse_may_alias, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::view<char> chars = lifetime.uni0n;
    int offset = 0;
    while (offset < chars.size())
    {
        const unsigned r = parse7bit(chars, offset);
        for (; ; )
        {
            bool isLastPath = false;
            bool isFirstSubRegion = true;
            for (; ; )
            {
                const unsigned raw_flatOffset = parse7bit(chars, offset);
                const bool isLastSubRegion = !(raw_flatOffset & 1u);
                const unsigned raw_flatCount = (isLastSubRegion ? parse7bit(chars, offset) : 3u);
                isLastPath = !(raw_flatCount & 1u);
                if (isLastSubRegion)
                    break;
                else
                    isFirstSubRegion = false;

            };
            if (isLastPath)
                break;

        };
        int BL_10_v {};
        _J2PqUOXp(((r & 1u) ? 0 : (__extension__ (
        {
            const unsigned v = (r >> 1u);
            BL_10_v = (int(((v >> 1u) ^ ((v & 1u) ? 0xffffffffu : 0x0u))));
        (void)0;}), BL_10_v)), regions, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
    };
}
                                #endif

static void flag_gDsnGKHT(s_Regions& regions, const s_Lifetime& lifetime, const bool dontUse_may_alias, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, const s_CurrentFn& _current_fn, const s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    Lifetime_each_70YipEZd(lifetime, regions, dontUse_may_alias, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
}

                                #ifndef DEF_steal_I3wXv9MXEci
                                #define DEF_steal_I3wXv9MXEci
inline s_Unsequenced steal_I3wXv9MX(s_Unsequenced& v)
{
    /*MOV*/ s_Unsequenced ret {};
    std::swap(v, ret);
    return /*NRVO*/ ret;
}
                                #endif

static void operator|=(s_Regions& a, const s_Regions& b)
{

    {
        const s_LocidSet& other = b.locids;
        s_LocidSet& set = a.locids;
        set._bitset |= other._bitset;
    };
    a.arguments |= b.arguments;
}

static void operator|=(s_Unsequenced& events, const s_Unsequenced& other)
{
    events.writes |= other.writes;
    events.moves |= other.moves;
    events.reads |= other.reads;
}

static void clear_q5Q6zgXB(s_Regions& regions)
{

    {
        s_LocidSet& set = regions.locids;
        clear_ZwXYCruz(set._bitset);
    };
    clear_ZwXYCruz(regions.arguments);
}

static void clear_835qRIOU(s_Unsequenced& events)
{
    clear_q5Q6zgXB(events.writes);
    clear_q5Q6zgXB(events.moves);
    clear_q5Q6zgXB(events.reads);
}

static bool has_inter_gDsnGKHT(const s_Regions& a, const s_Regions& b)
{
    bool BL_1_v {};
    return (__extension__ (
    {
        const s_LocidSet& a_1 = a.locids;
        const s_LocidSet& b_1 = b.locids;
        BL_1_v = (has_inter_ZwXYCruz(a_1._bitset, b_1._bitset));
    (void)0;}), BL_1_v) || has_inter_ZwXYCruz(a.arguments, b.arguments);
}

                                #ifndef DEF___BNrmxXFU496
                                #define DEF___BNrmxXFU496
inline static void _BNrmxXFU(const int i, const s_Argument& host_arg, const int revSeqIdx, const bool unsequencedOutside, const bool unsequencedHere, s_Unsequenced& outer, s_Unsequenced& parallel, int& MUSTSEQ_mask, fu::view_mut<s_SolvedNode> args, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, s_Unsequenced& _inner, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    if (unsequencedHere)
    {
        if (revSeqIdx == 1)
            parallel = steal_I3wXv9MX(_inner);
        else if (revSeqIdx > 1)
        {
            parallel |= _inner;
            clear_835qRIOU(_inner);
        };
    };
    s_SolvedNode& arg = args.mutref(i);
    s_SolvedNode* BL_4_v;
    s_SolvedNode& arg_1 = ((arg.kind != s_Kind_move) ? arg : (__extension__ (
    {
        s_SolvedNode& expr = only_n3dv4p6e(arg.items);
        if (unsequencedOutside)
        {
            flag_gDsnGKHT(outer.moves, expr.type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
        BL_4_v = &(expr);
    (void)0;}), *BL_4_v));
    visit_CLRxF4GH(arg_1, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options);
    if (unsequencedOutside)
    {
        if (host_arg.written_to)
        {
            flag_gDsnGKHT(outer.writes, arg_1.type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    };
    if (unsequencedHere)
    {
        bool BL_9_v {};
        bool BL_10_v {};
        fu::never BL_11_v {};
        const s_SolverNotes note = ((has_inter_gDsnGKHT(_inner.moves, parallel.reads) || has_inter_gDsnGKHT(parallel.moves, _inner.reads)) ? s_SolverNotes_N_MoveMustSeq : (((__extension__ (
        {
            const s_LocidSet& a = _inner.writes.locids;
            const s_LocidSet& b = parallel.reads.locids;
            BL_9_v = (has_inter_ZwXYCruz(a._bitset, b._bitset));
        (void)0;}), BL_9_v) || (__extension__ (
        {
            const s_LocidSet& a = parallel.writes.locids;
            const s_LocidSet& b = _inner.reads.locids;
            BL_10_v = (has_inter_ZwXYCruz(a._bitset, b._bitset));
        (void)0;}), BL_10_v)) ? s_SolverNotes_N_BckMustSeq : ((has_inter_ZwXYCruz(_inner.writes.arguments, parallel.reads.arguments) || has_inter_ZwXYCruz(parallel.writes.arguments, _inner.reads.arguments)) ? s_SolverNotes_N_AARMustSeq : (__extension__ (
        {
            return;
        (void)0;}), static_cast<fu::never&&>(BL_11_v)))));
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            ss._notes |= note;

        MUSTSEQ_mask |= (1 << (i & 31));
    };
}
                                #endif

                                #ifndef DEF_argsReverse_aDxaQusDqtk
                                #define DEF_argsReverse_aDxaQusDqtk
inline void argsReverse_aDxaQusD(const bool RTL, fu::view<s_Argument> host_args, const bool unsequencedOutside, const bool unsequencedHere, s_Unsequenced& outer, s_Unsequenced& parallel, int& MUSTSEQ_mask, fu::view_mut<s_SolvedNode> args, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, s_Unsequenced& _inner, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    int revSeqIdx = 0;
    int lastPass = 1;
    bool ooe_isLast = true;
    for (int pass = 2; pass-- > lastPass; )
    {
        for (int i = host_args.size(); i-- > 0; )
        {
            const s_Argument& host_arg = host_args[i];
            if (!!pass != (RTL ? !i : !!((host_arg.flags & s_Flags_F_IMPLICIT) || is_mutref_9CJmuVSD(host_arg.type, _here, ctx))))
                lastPass = 0;
            else
            {
                _BNrmxXFU(i, host_arg, revSeqIdx, unsequencedOutside, unsequencedHere, outer, parallel, MUSTSEQ_mask, args, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options);
                ooe_isLast = false;
                revSeqIdx++;
            };
        };
    };
}
                                #endif

[[noreturn]] static fu::never BUG_FDl5ha9X(const s_TokenIdx& token, const fu::str& reason, const s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    _here = token;
    BUG_gDsnGKHT(fu::str(reason), ss, _helpers, _here, ctx, module, options);
}

static void visit_CLRxF4GH(s_SolvedNode& node, fu::view<s_BitSet> _may_alias, fu::view<int> _argPos_1b, int& _unseqDepth, s_Unsequenced& _inner, const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    const bool unsequencedOutside = !!_unseqDepth;
    if (node.kind == s_Kind_call)
    {
        const s_Overload& o = GET_gDsnGKHT(node.target, ss, _here, ctx, module);
        if (!node.items)
        {
            if ((o.kind == s_Kind_var) && _unseqDepth)
            {
                flag_gDsnGKHT(_inner.reads, o.type.lifetime, true, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        }
        else
        {
            const bool RTL = isRTL_xQNS19Zn(o);
            const bool unsequencedHere = (!RTL ? (node.items.size() > 1) : false);
            if (unsequencedHere)
                _unseqDepth++;

            s_Unsequenced outer = steal_I3wXv9MX(_inner);
            s_Unsequenced parallel {};
            int MUSTSEQ_mask = 0;
            fu::vec<s_Argument> host_args { EXT_gDsnGKHT(node.target, ss, ctx, module).args };
            fu::view_mut<s_SolvedNode> args = node.items;
            if (host_args.size() == args.size())
            {
                argsReverse_aDxaQusD(RTL, host_args, unsequencedOutside, unsequencedHere, outer, parallel, MUSTSEQ_mask, args, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options);
                if (unsequencedHere)
                    _unseqDepth--;

                node.helpers.index |= MUSTSEQ_mask;
                if (unsequencedOutside)
                {
                    outer |= _inner;
                    outer |= parallel;
                    std::swap(_inner, outer);
                }
                else if (outer)
                    BUG_gDsnGKHT("!unsequencedOutside but outer events non-empty."_fu, ss, _helpers, _here, ctx, module, options);
                else
                    clear_835qRIOU(_inner);

            }
            else
            {
                int BL_12_v {};
                int BL_13_v {};
                BUG_FDl5ha9X(node.token, (x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo((x7E_3lDd4lqo("ensureArgSequencing: target("_fu, fu::i64dec((__extension__ (
                {
                    const s_Target& t = node.target;
                    BL_12_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                (void)0;}), BL_12_v))) + " "_fu), str_FDl5ha9X(node.target, false, ss, _here, ctx, module, options)) + ") host_args.len("_fu), fu::i64dec(host_args.size())) + ") != args.len("_fu), fu::i64dec(args.size())) + "), nestingFnort("_fu), fu::i64dec((__extension__ (
                {
                    const s_Target& t = ss._nestingFnort;
                    BL_13_v = (int(unsigned(((t._packed >> 20ull) & 0xfffffull))));
                (void)0;}), BL_13_v))) + " "_fu), str_FDl5ha9X(ss._nestingFnort, false, ss, _here, ctx, module, options)) + ")"_fu), ss, _helpers, _here, ctx, module, options);
            };
        };
    }
    else if (node.kind == s_Kind_letdef)
    {
        s_SolvedNode root = steal_46agKNQY(GET_mut_gDsnGKHT(node.target, ss, module).solved);
        visit_CLRxF4GH(root, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options);
        std::swap(root, GET_mut_gDsnGKHT(node.target, ss, module).solved);
        if (!isIrrelevant_9CJmuVSD(node.type) && unsequencedOutside)
        {
            flag_gDsnGKHT(_inner.writes, node.type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
        };
    }
    else
    {
        if (node.kind == s_Kind_move)
        {
            if (_unseqDepth && (node.kind == s_Kind_move))
            {
                flag_gDsnGKHT(_inner.moves, only_LqU08rcL(node.items).type.lifetime, false, _may_alias, _argPos_1b, _current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
        for (int i = 0; i < node.items.size(); i++)
        {
            s_SolvedNode* _0;
            (_0 = &(node.items.mutref(i)), visit_CLRxF4GH(*_0, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options));
        };
    };
}

static void nestingFnort_ensureArgSequencing_gDsnGKHT(const s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    fu::vec<s_BitSet> _may_alias {};
    fu::vec<int> _argPos_1b {};
    each_N1IZx7ee(EXT_gDsnGKHT(ss._nestingFnort, ss, ctx, module).args, _may_alias, _argPos_1b, ss, _helpers, _here, ctx, module, options);
    int _unseqDepth = 0;
    s_Unsequenced _inner {};
    s_SolvedNode root = steal_46agKNQY(last_fjKdEPCD(GET_mut_gDsnGKHT(ss._nestingFnort, ss, module).solved.items));
    visit_CLRxF4GH(root, _may_alias, _argPos_1b, _unseqDepth, _inner, _current_fn, ss, _helpers, _here, ctx, module, options);
    std::swap(root, last_fjKdEPCD(GET_mut_gDsnGKHT(ss._nestingFnort, ss, module).solved.items));
}

static void PASS_runAllVerifiers_gDsnGKHT(s_CurrentFn& _current_fn, s_SolverState& ss, fu::view<s_Helpers> _helpers, s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{

    {
        s_Map_4FUR4uzUhqd name_counts {};
        for (int i = 0; i < ss._scope.overloads.size(); i++)
        {
            const s_Overload& o = ss._scope.overloads[i];
            if (o.kind == s_Kind_fn)
            {
                const s_Target target = Target_xQNS19Zn(module.modid, (i + 1), 0);
                const s_SolverStatus status = o.status;
                if (s_SolverStatus(~status) & s_SolverStatus_SS_FINALIZED)
                {
                    destroyOverload_gDsnGKHT(target, ss, module);
                    continue;
                }
                else if (!EXT_gDsnGKHT(target, ss, ctx, module).sighash)
                    computeFnSighash_asIfCycleRoot_gDsnGKHT(target, name_counts, _current_fn, ss, _helpers, _here, ctx, module, options);

            };
        };
    };
    if (ss._nestingFnort)
    {
        BUG_gDsnGKHT("PASS_runAllVerifiers: non-empty _nestingFnort"_fu, ss, _helpers, _here, ctx, module, options);
    }
    else if (_current_fn.args_neg)
    {
        BUG_gDsnGKHT("PASS_runAllVerifiers: non-empty _current_fn.args_neg"_fu, ss, _helpers, _here, ctx, module, options);
    }
    else
    {
        for (int i = 0; i < ss._scope.overloads.size(); i++)
        {
            const s_Overload& o = ss._scope.overloads[i];
            if (o.kind == s_Kind_fn)
            {
                ss._nestingFnort = Target_xQNS19Zn(module.modid, (i + 1), 0);
                _current_fn.args_neg = EXT_gDsnGKHT(ss._nestingFnort, ss, ctx, module).args_neg;
                nestingFnort_ensureArgSequencing_gDsnGKHT(_current_fn, ss, _helpers, _here, ctx, module, options);
            };
        };
    };
    ss._nestingFnort = s_Target{};
    _current_fn.args_neg = int{};
}

static void Scope_observeDefects_gDsnGKHT(s_SolverState& ss, fu::view<s_Helpers> _helpers, const s_TokenIdx& _here, const s_Context& ctx, const s_Module& module, const s_Options& options)
{
    bool hasLets = false;
    bool hasPubTemplates = false;
    fu::vec<s_Target> privates {};
    for (int i = 0; i < ss._scope.items.size(); i++)
    {
        const s_Target t = target_z0QqoZ5t(ss._scope.items[i]);
        if (!(int(unsigned(((t._packed >> 40ull) & 0xfffffull))) != module.modid))
        {
            s_Overload& o = GET_mut_gDsnGKHT(t, ss, module);
            if ((o.kind == s_Kind_var) || (o.kind == s_Kind_fn))
            {
                if (o.kind == s_Kind_var)
                    hasLets = true;

                if (!(o.flags & s_Flags_F_PUB))
                    privates += s_Target(t);
                else
                    o.status |= s_SolverStatus_SS_EXTERNAL_LINKAGE;

            }
            else if (o.kind == s_Kind_template)
            {
                if (o.flags & s_Flags_F_PUB)
                    hasPubTemplates = true;

            };
        };
    };
    if (hasLets)
    {
        const s_SolverNotes note = s_SolverNotes_N_SD_HasStaticInit;
        if (note & options.break_notes)
        {
            fu::view<char> reason = fu::view<char>{};
            fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
        }
        else
            ss._notes |= note;

    };
    if (privates && hasPubTemplates)
    {

        {
            const s_SolverNotes note = s_SolverNotes_N_SD_ExternPrivates;
            if (note & options.break_notes)
            {
                fu::view<char> reason = fu::view<char>{};
                fail_gDsnGKHT((("`break_notes`: Unwanted event: "_fu + qBAD_e44UlzzA(str_cVIkXcxd(note))) + (reason ? ("\n\t\t"_fu + reason) : "."_fu)), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
            }
            else
                ss._notes |= note;

        };
        for (int i_1 = 0; i_1 < privates.size(); i_1++)
        {
            s_Overload& o = GET_mut_gDsnGKHT(privates[i_1], ss, module);
            o.status |= s_SolverStatus_SS_EXTERNAL_LINKAGE;
        };
    };
}

s_SolverOutput solve_gDsnGKHT(const s_Context& ctx, s_Module& module, const s_Options& options)
{
    s_TokenIdx _here {};
    s_CurrentFn _current_fn {};
    s_SolverState ss {};
    fu::vec<s_Helpers> _helpers {};
    ss.shortModuleName = (module.modid ? getShortModuleName_1qjplDUo(module.fname, _here, ctx) : fu::str{});
    ss.TODO_FIX_convert_args = fu::vec<s_SolvedNode> { fu::slate<1, s_SolvedNode> { s_SolvedNode{} } };
    ss.TODO_FIX_convert_args.mutref(0).kind = s_Kind___convert;
    ss._scope.extended += s_Extended{};
    push_gDsnGKHT(s_HelpersData{}, ss, _helpers);
    if (module.modid)
    {
        ss._scope.imports += module.modid;
        _Scope_import__forceCopy_gDsnGKHT(0, false, ss, ctx);
    }
    else
    {
        createRawTypedef_gDsnGKHT("i8"_fu, s_Type(t_i8), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("i16"_fu, s_Type(t_i16), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("i32"_fu, s_Type(t_i32), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("i64"_fu, s_Type(t_i64), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("i128"_fu, s_Type(t_i128), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("u8"_fu, s_Type(t_u8), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("u16"_fu, s_Type(t_u16), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("u32"_fu, s_Type(t_u32), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("u64"_fu, s_Type(t_u64), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("u128"_fu, s_Type(t_u128), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("f32"_fu, s_Type(t_f32), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("f64"_fu, s_Type(t_f64), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("bool"_fu, s_Type(t_bool), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("byte"_fu, s_Type(t_byte), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("void"_fu, s_Type(t_void), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
        createRawTypedef_gDsnGKHT("never"_fu, s_Type(t_never), s_Flags_F_PUB, (*(const fu::str*)fu::NIL), s_SolverStatus{}, ss, module);
    };
    s_Node _0 {};
    /*MOV*/ s_SolvedNode root = (_0 = steal_3blx9gas(module.in.parse.root), solveNode_gDsnGKHT(static_cast<s_Node&&>(_0), (*(const s_Type*)fu::NIL), _current_fn, ss, _helpers, _here, ctx, module, options));
    if (_current_fn)
        BUG_gDsnGKHT("non-empty _current_fn."_fu, ss, _helpers, _here, ctx, module, options);
    else
    {
        PASS_runAllVerifiers_gDsnGKHT(_current_fn, ss, _helpers, _here, ctx, module, options);
        if (ss._helpers_data[0])
            BUG_gDsnGKHT("non-empty _helpers_data[0]."_fu, ss, _helpers, _here, ctx, module, options);
        else
        {
            Scope_observeDefects_gDsnGKHT(ss, _helpers, _here, ctx, module, options);
            for (int i = 0; i < ss._warnings.size(); i++)
            {
                const s_Warning& w = ss._warnings[i];
                if (w.locid)
                {
                    const s_Target target = Target_xQNS19Zn(module.modid, i, ((w.locid < 0x11110000) ? w.locid : 0));
                    _here = GET_gDsnGKHT(target, ss, _here, ctx, module).solved.token;
                    fail_gDsnGKHT(((w.locid == 0x11110000) ? (x7E_3lDd4lqo(str_FDl5ha9X(target, false, ss, _here, ctx, module, options), " does nothing: returns void and has no effects."_fu) + makeItLaxIfIntentional_gDsnGKHT()) : ((x7E_3lDd4lqo("Unused variable: "_fu, str_FDl5ha9X(target, false, ss, _here, ctx, module, options)) + "."_fu) + makeItLaxIfIntentional_gDsnGKHT())), fu::view<char>{}, s_TokenIdx(_here), fu::view<s_TokenIdx>{}, ss, _helpers, _here, ctx, module, options);
                };
            };
            return s_SolverOutput { static_cast<s_SolvedNode&&>(root), Scope_exports_z0QqoZ5t(ss._scope, module.modid, ss._pub_imports.keys_asc), ss._notes };
        };
    };
}

#endif
