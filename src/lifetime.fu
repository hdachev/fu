import module;
import fail;


//

let SR_empty        = "\x00\x00";

let Region_TEMP     = "\x01" ~ SR_empty;
let Region_STATIC   = "\x00" ~ SR_empty;

fn parse7bit(str: byte[..], ref offset: int)
{
    mut shift:  u32;
    mut result: u32;

    mut c: byte;
    while (offset < str.len
            && (c = str[offset++]).u32 >= 128)
    {
        result |= (c.u32 & 0x7f) << shift;
        shift  += 7;
    }

    return result | c.u32 << shift;
}

fn append7bit(ref str: byte[], mut v: u32)
{
    while (v >= 128)
    {
        str ~= byte(v | 0x80);
        v  >>= 7;
    }

    str ~= byte(v);
}


/*
    a               ;       .A;     .A*;    .A*;    .A*B,.C;
    b               .A;     .B;     .A;     ;       .C*;

    UNION(a, b)     ;       .AB;    .A;     ;       .A*B,.C;
    INTER(a, b)     .A;     \       .A*;    .A*;    .C;

    We're going with full path serialize-parse for starters to keep things a little simpler,
     i think once we got this figured out it should be relatively easy
      to optimize each op to directly process the raw bytes.
*/

pub inline fn walkPaths(str: byte[..], ref offset, lax tailOK!?: bool,
    onPathStart!?,

    onSubRegion!?,
    onLastSubRegion!?,

    onPathDone!?,
    onDone!?)
{
    lax let offset0 = offset + 0 /* i'm having a bad time, otherwise this returns a ref, which relaxes ... */;

    // A non-empty list of "paths" ...
    for (;;)
    {
        mut isLastPath          = false;
        mut isFirstSubRegion    = true;

        let path0               = offset;

        onPathStart();

        // ... which are non-empty lists of subregions ...
        for (;;)
        {
            // Subregion flatCount.
            let subregion0      = offset;
            let raw_flatOffset  = str.parse7bit(:offset);
            let isLastSubRegion = !(raw_flatOffset & 1);

            let raw_flatCount   = isLastSubRegion
                ? str.parse7bit(:offset)
                : 3;

            isLastPath          = !(raw_flatCount & 1);

            let flatCount       = i32(raw_flatCount  >> 1);
            let flatOffset      = i32(raw_flatOffset >> 1);

            onSubRegion(
                ?:isFirstSubRegion,
                ?:isLastSubRegion,
                ?:isLastPath,
                ?:flatCount,
                ?:flatOffset,

                raw_prefix?:    str[path0 .. subregion0]);

            if (isLastSubRegion)
            {
                onLastSubRegion(
                    ?:isFirstSubRegion,
                    ?:isLastSubRegion,
                    ?:isLastPath,
                    ?:flatCount,
                    ?:flatOffset,

                    raw_prefix?:    str[path0 .. subregion0]);

                break;
            }

            isFirstSubRegion    = false;
        }

        onPathDone(
            isLastPath?:        isLastPath,
            raw_path?:          str[path0 .. offset]);

        if (isLastPath)
            break;
    }

    if (SELF_TEST && !tailOK)
        offset == str.len || BUG("walkPaths(!tailOK): excess bytes");

    onDone();

    return offset0;
}


//

pub lax fn assertPathsValid(
    lax str: byte[..],
    lax mut expect_flatCount = -1,
    lax mut region_flatCount = -1,
    lax flatCountMismatchOK! = false,
    lax selfIntersectOK! = false,
    lax minPathDepth! = 1)
{
    if (!SELF_TEST)
        return;

    mut pathDepth       = -1001;
    mut numPaths        = 0;

    mut offset = 0;
    str.walkPaths(:offset,

        onPathStart: ||
        {
            pathDepth = 0;

            numPaths++;
            if (numPaths > 64)
                BUG("assertPathsValid: numPaths > 64, we're likely stuck in an infinite loop.");
        },

        onPathDone: ||
        {
            pathDepth >= minPathDepth || BUG(
                "assertPathsValid: pathDepth(" ~ pathDepth ~ ")"
                    ~ " !>= minPathDepth(" ~ minPathDepth ~ ")");
        },

        onSubRegion: |flatOffset, flatCount, isLastSubRegion, isFirstSubRegion|
        {
            pathDepth++;
            if (pathDepth > 64)
                BUG("assertPathsValid: pathDepth > 64, we're likely stuck in an infinite loop.");

            if (isFirstSubRegion && region_flatCount >= 0)
            {
                flatOffset + flatCount <= region_flatCount || BUG(
                    "assertPathsValid: flatOffset(" ~ flatOffset ~ ")"
                        ~ " + flatCount(" ~ flatCount ~ ")"
                        ~ " !<= region_flatCount(" ~ region_flatCount ~ ")");
            }

            if (isLastSubRegion && !flatCountMismatchOK)
            {
                if (expect_flatCount < 0)
                    expect_flatCount = flatCount;
                else
                    expect_flatCount == flatCount || BUG(
                        "assertPathsValid: expect_flatCount(" ~ expect_flatCount ~ ")"
                            ~ " != flatCount(" ~ flatCount ~ ")");
            }
        });
}


//

struct SubRegion
{
    flatCount:      i32;
    flatOffset:     i32;
};

type Paths = SubRegion[][];

fn parsePaths_each(str: byte[..], each)
{
    mut path: SubRegion[];

    mut _o = 0;
    str.walkPaths(offset: _o,

        onPathStart: || {
            path.clear();
        },

        onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
        },

        onPathDone: || {
            each(path);
        });
}

fn parsePaths(str: byte[..]): Paths
{
    mut paths:      SubRegion[][];
    mut path:       SubRegion[];

    mut _o = 0;
    str.walkPaths(offset: _o,

        onSubRegion: |flatCount, flatOffset| {
            path ~= SubRegion(:flatCount, :flatOffset);
        },

        onPathDone: || {
            paths ~= helpers::steal(path);
        },

        onDone: || {
            return paths;
        });
}

fn printPaths(str: byte[..]): string
{
    mut result = "";

    mut _o = 0;
    str.walkPaths(offset: _o,

        onPathStart: || {
            result ~= "\n\tPath:\n";
        },

        onPathDone: |isLastPath| {
            result ~= "\t/Path\tisLastPath=" ~ isLastPath;
        },

        onSubRegion: |flatCount, flatOffset, isFirstSubRegion, isLastSubRegion| {
            result ~= "\t\tSubReg\t flatCount="         ~ flatCount
                                ~ " isFirstSubRegion="  ~ isFirstSubRegion
                                ~ " isLastSubRegion="   ~ isLastSubRegion
                                ~ "\n";

            result ~= "\t\t\tflatOffset=" ~ flatOffset ~ "\n";
        },

        onDone: || {
            return result;
        });
}


//

inline fn appendSubRegion(ref uni0n: byte[],
    flatCount: i32, flatOffset: i32,
    isLastSubRegion!: bool, isLastPath!: bool)
{
    if (SELF_TEST)
        flatOffset >= 0 && flatCount > 0 && (isLastSubRegion || flatCount == 1) || BUG(
            "appendSubRegion: flatCount(" ~ flatCount ~ ")"
                          ~ " flatOffset(" ~ flatOffset ~ ")"
                          ~ " isLastSubRegion(" ~ isLastSubRegion ~ ")");

    uni0n.append7bit(
        flatOffset.u32 << 1
            | (isLastSubRegion ? 0 : 1));

    if (isLastSubRegion)
        uni0n.append7bit(
            flatCount.u32 << 1
                | (isLastPath ? 0 : 1));
}

fn appendPaths(ref str: byte[], paths: Paths,
    lax emptyOK! = false,
    lax flatCountMismatchOK! = false,
    lax selfIntersectOK! = false)
{
    lax let str0 = str.len;

    if (SELF_TEST)
        emptyOK || paths || BUG("appendPaths: zero paths");

    // A non-empty list of "paths" ...
    for (mut i = 0; i < paths.len; i++)
    {
        let path            = paths[i];
        let isLastPath      = i == paths.len - 1;

        if (SELF_TEST)
            path || BUG("appendPaths: zero subregions");

        // ... which are non-empty lists of subregions ...
        for (shadow mut i = 0; i < path.len; i++)
        {
            let subregion       = path[i];
            if (SELF_TEST)
            {
                subregion || BUG("appendPaths: empty subregion");

                subregion.flatCount

                    // TODO FIX statics and temporaries are special right now.
                    || path.len == 1
                    || subregion.flatOffset == 0
                    || BUG("appendPaths: empty flatCount");
            }

            let isLastSubRegion = i == path.len - 1;

            // Subregion flatCount.
            str.appendSubRegion(
                :subregion.flatCount, :subregion.flatOffset,
                :isLastSubRegion, :isLastPath);
        }
    }

    if (SELF_TEST)
        str ? assertPathsValid(str[str0 ..], :flatCountMismatchOK, :selfIntersectOK)
            : emptyOK || BUG("appendPaths: empty output");
}


//

fn Paths_union(ref result: SubRegion[][], path: SubRegion[])
{
    // Starting off really simple here,
    //  just ensure we don't get two identical paths,
    //   and also ignore attempts to add `a.b` to `a`.
    //
    for (mut i = 0; i < result.len; i++)
    {
        let host = result[i];

        let minL = min(path.len, host.len);
        if (SELF_TEST)
            minL || BUG("Paths_union: found an empty path.");

        if (path[.. minL - 1] == host[.. minL - 1])
        {
            let a_sr = host[minL - 1];
            let b_sr = path[minL - 1];

            // Does one completely wrap the other?
            let a0 = a_sr.flatOffset;
            let a1 = a0 + a_sr.flatCount;

            let b0 = b_sr.flatOffset;
            let b1 = b0 + b_sr.flatCount;

            let host_within_path = a0 >= b0 && a1 <= b1;
            let path_within_host = a0 <= b0 && a1 >= b1;

            if (path_within_host && path.len >= host.len)
            {
                // Nothing to add.
                return false;
            }

            if (host_within_path && host.len >= path.len)
            {
                // Get rid of the host path entry,
                //  we'll add it below after we've had the chance
                //   to get rid of more host paths.
                result.splice(i, 1);
                i--;
            }
        }
    }

    // UNION(a, b) -> a|b
    result ~= path;
    return true;
}


//

fn Paths_union(ref str: byte[], a: byte[..], b: byte[..],
    flatCountMismatchOK! = false)
{
    mut result = parsePaths(a);

    b.parsePaths_each: |b_path|
        result.Paths_union(b_path);

    str.appendPaths(result, :flatCountMismatchOK);
}

fn Paths_inter(ref str: byte[], a: byte[..], b: byte[..])
{
    if (a.len < b.len)
        return Paths_inter(str, b, a);

    mut result: SubRegion[][] = [];
    mut inter: SubRegion[];

    a.parsePaths_each: |a_path|
    {
        :EACH_B_PATH
        b.parsePaths_each: |b_path|
        {
            let N = min(a_path.len, b_path.len);
            for (mut i = 0; i < N; i++)
            {
                shadow let a = a_path[i];
                shadow let b = b_path[i];

                let overlap = min(
                    b.flatOffset + b.flatCount - a.flatOffset,
                    a.flatOffset + a.flatCount - b.flatOffset);

                if (overlap <= 0)
                {
                    inter.clear();
                    continue :EACH_B_PATH;
                }

                let flatCount   = min(a.flatCount,  b.flatCount);
                let flatOffset  = max(a.flatOffset, b.flatOffset);

                if (SELF_TEST)
                    overlap >= flatCount || BUG("Paths_inter: self-intersection:"
                        ~ "\n\t\ta.flatOffset(" ~ a.flatOffset ~ ") a.flatCount(" ~ a.flatCount ~ ")"
                        ~ "\n\t\tb.flatOffset(" ~ b.flatOffset ~ ") b.flatCount(" ~ b.flatCount ~ ")"
                        ~ "\n\t\toverlap(" ~ overlap ~ ")");

                inter ~= SubRegion(:flatCount, :flatOffset);
            }

            if (SELF_TEST)
                inter || BUG("Paths_inter: empty inter, about to append suffix");

            if (a_path.len > b_path.len) inter ~= a_path[b_path.len ..];
            if (b_path.len > a_path.len) inter ~= b_path[a_path.len ..];

            result.Paths_union(inter);
        }
    }

    str.appendPaths(result,
        emptyOK: true,
        selfIntersectOK: true,
        flatCountMismatchOK: true);
}


//

fn Paths_hasInter(a: byte[..], b: byte[..])
{
    if (a.len < b.len)
        return Paths_hasInter(b, a);

    a.parsePaths_each: |a_path|
    {
        :EACH_B_PATH
        b.parsePaths_each: |b_path|
        {
            let N = min(a_path.len, b_path.len);
            for (mut i = 0; i < N; i++)
            {
                shadow let a = a_path[i];
                shadow let b = b_path[i];

                let overlap = min(
                    b.flatOffset + b.flatCount - a.flatOffset,
                    a.flatOffset + a.flatCount - b.flatOffset);

                if (overlap <= 0)
                    continue :EACH_B_PATH;
            }

            return true;
        }
    }

    return false;
}


//

pub fn Lifetime_from(locid!: i32, flatCount: i32): Lifetime =
{
    if (SELF_TEST)
        locid > 0 || BUG("Lifetime_from: Bad locid");

    mut uni0n: byte[];
    uni0n.append7bit(locid.u32 << 1);
    uni0n.appendSubRegion(
        :flatCount, flatOffset: 0,
        isLastPath: true, isLastSubRegion: true);

    return Lifetime(:uni0n);
}

pub fn Lifetime_from(argidx!: i32, paths: byte[..]): Lifetime =
{
    if (SELF_TEST)
        argidx >= 0 || BUG("Lifetime_from: Bad argidx");

    mut uni0n: byte[];
    uni0n.append7bit((argidx.u32 << 2) | 3);
    uni0n ~= paths;

    return Lifetime(:uni0n);
}

pub let Lifetime_AAR_hasFalsePositives = true;

pub fn Lifetime_AAR(locid!: i32): Lifetime =
{
    if (SELF_TEST)
        locid > 0 || BUG("Lifetime_from: Bad locid");

    mut uni0n: byte[];
    uni0n.append7bit(locid.u32 << 1);
    uni0n ~= SR_empty;

    return Lifetime(:uni0n);
}


//

inline fn merge !<B, L, R, Either, Rest>(

    l_chars.uni0n,
    r_chars.uni0n,

    both!?: B, left!?: L, right!?: R,

    either!?: Either,

    left_done!?,
    right_done!?,

    rest!?: Rest)
{
    mut l_start: i32;
    mut r_start: i32;

    mut l_paths0: i32;
    mut r_paths0: i32;

    mut l_offset: i32;
    mut r_offset: i32;

    mut l: u32;
    mut r: u32;

    mut l_dirty = true;
    mut r_dirty = true;

    mut l_done = false;
    mut r_done = false;

    lax let rest_chars =
    {
        :REST
        {
            for (;;)
            {
                if (l_dirty) {
                    l_dirty = false;
                    l_start = l_offset;

                    if (l_offset < l_chars.len) {
                        l = l_chars.parse7bit(l_offset);
                        l_paths0 = l_chars.walkPaths(offset: l_offset, tailOK: true);
                    }
                    else {
                        left_done();
                        if !(Rest -> [])
                            break :REST r_chars[r_dirty ? r_offset : r_start ..];
                        else
                            l_done = true;
                    }
                }

                if (r_dirty) {
                    r_dirty = false;
                    r_start = r_offset;

                    if (r_offset < r_chars.len) {
                        r = r_chars.parse7bit(r_offset);
                        r_paths0 = r_chars.walkPaths(offset: r_offset, tailOK: true);
                    }
                    else {
                        right_done();
                        if !(Rest -> [])
                            break :REST l_chars[l_dirty ? l_offset : l_start ..];
                        else
                            r_done = true;
                    }
                }

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1

                        // Because we historically like to iterate lifetimes
                        //  from innermost to outermost, we compare backwards here,
                        //   so that we end up with the same reverse iteration order,
                        //    we basically store them innermost to outermost.
                        //
                        : (l == 0) != (r == 0)      ? r == 0    ? -1 : +1
                        : (l == 1) != (r == 1)      ? r == 1    ? +1 : -1
                                                    : r <> l;

                let either_chars =
                {
                    :EITHER
                    {
                        if (cmp == 0)
                        {
                            l_dirty = true;
                            r_dirty = true;
                            if !(B -> [])
                            {
                                both(l_chars[l_start .. l_paths0],  l_chars[l_paths0 .. l_offset],
                                                                    r_chars[r_paths0 .. r_offset],

                                     locid?: i32(r & 1 ? 0 : r >> 1));

                                continue;
                            }
                        }
                        else if (cmp < 0)
                        {
                            l_dirty = true;
                            if !(Either -> [])
                                break :EITHER l_chars[l_start .. l_offset];

                            if !(L -> [])
                            {
                                left(l_chars[l_start .. l_offset]);
                                continue;
                            }
                        }
                        else
                        {
                            r_dirty = true;
                            if !(Either -> [])
                                break :EITHER r_chars[r_start .. r_offset];

                            if !(R -> [])
                            {
                                right(r_chars[r_start .. r_offset]);
                                continue;
                            }
                        }

                        continue;
                    }
                };

                //
                either(either_chars);
            }

            return;
        }
    };

    //
    rest(rest_chars);
}


//

pub fn Lifetime_union(a: Lifetime, b: Lifetime,
    flatCountMismatchOK! = false): Lifetime =
{
    mut result: Lifetime;

    merge(a, b,

        either: |raw| result.uni0n ~= raw,

        both: |r_both, sr_left, sr_right| {
            result.uni0n ~= r_both;

            if (sr_left == sr_right || sr_left == SR_empty)
                result.uni0n ~= sr_left;
            else if (sr_right == SR_empty)
                result.uni0n ~= sr_right;
            else
                Paths_union(
                    result.uni0n, sr_left, sr_right,
                    :flatCountMismatchOK);
        },

        // Early exits.
        left_done: || {
            if (!result)
                return b;
        },
        right_done: || {
            if (!result)
                return a;
        },
        rest: |either| {
            result.uni0n ~= either;
            break;
        });

    return result;
}

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
{
    mut result: Lifetime;

    mut inter: byte[];

    merge(a, b,

        both: |r_both, sr_left, sr_right|
        {
            let sr_chars =
            {
                :INTER
                {
                    if (sr_left == sr_right || sr_right == SR_empty)
                        break :INTER sr_left;
                    if (sr_left == SR_empty)
                        break :INTER sr_right;

                    inter.clear();
                    Paths_inter(inter, sr_left, sr_right);
                    if (inter)
                        break :INTER inter;

                    continue;
                }
            };

            result.uni0n ~= r_both;
            result.uni0n ~= sr_chars;
        },

        // Early exits.
        rest: |_| { break; });

    return result;
}

pub fn Lifetime_hasInter(a: Lifetime, b: Lifetime): bool =
{
    merge(a, b,

        both: |_, sr_left, sr_right|
        {
            if (sr_left == sr_right
                || sr_left == SR_empty || sr_right == SR_empty
                || Paths_hasInter(sr_left, sr_right))
            {
                return true;
            }
        },

        // Early exits.
        rest: |_| { break; });

    return false;
}

pub fn Lifetime_interLocids(a: Lifetime, b: Lifetime): i32[] =
{
    mut result: i32[];

    merge(a, b,

        both: |_, locid, sr_left, sr_right|
        {
            if (!locid)
                continue;

            if (sr_left == sr_right
                || sr_left == SR_empty || sr_right == SR_empty
                || Paths_hasInter(sr_left, sr_right))
            {
                result ~= locid;
            }
        },

        // Early exits.
        rest: |_| { break; });

    //
    return result;
}


//

pub fn Lifetime_add(ref l: Lifetime, r: Lifetime,
    flatCountMismatchOK! = false)
{
    if (r)
        l = Lifetime_union(l, r, :flatCountMismatchOK);
}


//

pub fn Lifetime_each(lifetime: Lifetime, each)
{
    let chars = lifetime.uni0n;
    mut offset = 0;

    while (offset < chars.len)
    {
        lax let offset0 = offset;

        let r       = chars.parse7bit(:offset);
        lax mut sr  = chars.walkPaths(:offset, tailOK: true);

        each(
            locid?:     i32(r & 1 ? 0 : r >> 1),
            argidx?:    i32(r & 1 ? r >> 2 : 0),
            isStatic?:  r == 0,
            isTemp?:    r == 1,
            isArgIdx?:  r & 3 == 3,

            region?:    Lifetime(uni0n: chars.slice(offset0, offset)),
            others?:    Lifetime(uni0n: chars[.. offset0] ~ chars[offset ..]),

            r_raw?:     chars[offset0 .. sr],
            paths?:     chars[sr .. offset]);
    }
}

pub fn Lifetime_process(lifetime: Lifetime, each)
{
    mut result: Lifetime;
    mut maybeOutOfOrder = false;

    fn visit(shadow lifetime: Lifetime)
    {
        let chars = lifetime.uni0n;
        mut offset = 0;

        while (offset < chars.len)
        {
            let offset0 = offset;

            :TEST
            {
                fn continue_climb(mut parent: Lifetime)
                {
                    maybeOutOfOrder = true;
                    visit(parent);
                    continue;
                }

                fn continue_replace(replacement: Lifetime)
                {
                    maybeOutOfOrder = true;
                    result.Lifetime_add(replacement);
                    continue;
                }

                fn continue_keep()
                {
                    // Doing this in a convoluted way so that
                    //  you can inline this multiple times at no cost.
                    break :TEST;
                }

                //
                let r       = chars.parse7bit(:offset);
                lax let sr  = chars.walkPaths(:offset, tailOK: true);

                each(continue_keep?: fn continue_keep,
                    continue_climb?: fn continue_climb,
                  continue_replace?: fn continue_replace,

                    // Same as above.
                    locid?:     i32(r & 1 ? 0 : r >> 1),
                    argidx?:    i32(r & 1 ? r >> 2 : 0),
                    isStatic?:  r == 0,
                    isTemp?:    r == 1,
                    isArgIdx?:  r & 3 == 3,

                    paths?:     chars[sr .. offset]);

                continue;
            }

            if (maybeOutOfOrder)
                result = Lifetime_union(result,
                    Lifetime(uni0n: chars.slice(offset0, offset)));
            else
                result.uni0n ~= chars[offset0 .. offset];
        }
    }

    visit(lifetime);

    return result;
}


//

pub let Lifetime_static =
    Lifetime(uni0n: Region_STATIC);

pub let Lifetime_temporary =
    Lifetime(uni0n: Region_TEMP);

pub fn hasTemporary(lifetime: Lifetime): bool
    lifetime.uni0n.starts(with: Region_TEMP);

pub fn hasStatic(lifetime: Lifetime): bool
    lifetime.uni0n.ends(with: Region_STATIC);


//

pub fn Lifetime_some(lifetime: Lifetime, some)
{
    Lifetime_each(:lifetime):
        |lax locid, lax argidx, lax isStatic, lax isTemp, lax isArgIdx|
    {
        if (some(locid?:    locid,    argidx?: argidx,
                 isStatic?: isStatic, isTemp?: isTemp,
                 isArgIdx?: isArgIdx))
        {
            return true;
        }
    }

    return false;
}

pub fn Lifetime_if_only(lifetime: Lifetime, if_only)
{
    mut first = true;

    Lifetime_each(:lifetime):
        |lax locid, lax argidx, lax isStatic, lax isTemp, lax isArgIdx|
    {
        if (!first)
            break;

        first = false;

        //
        if (if_only(locid?:    locid,    argidx?: argidx,
                    isStatic?: isStatic, isTemp?: isTemp,
                    isArgIdx?: isArgIdx))
        {
            return true;
        }
    }

    return false;
}

pub fn Lifetime_has(lifetime: Lifetime, locid!search: i32)
    lifetime.Lifetime_some(
        |locid| locid == search);

pub fn Lifetime_has(lifetime: Lifetime, argidx!search: i32)
    lifetime.Lifetime_some(
        |isArgIdx, argidx| isArgIdx && argidx == search);

pub fn Lifetime_makeShared(lifetime: Lifetime, flatCount!: i32): Lifetime =
    Lifetime_union(
        Lifetime_op_deref(lifetime, :flatCount),
        Lifetime_static);


/*
    We have three operations on lifetimes:

    .field:     Innermost subregion flatCount -= (>= 0), offset += (>= 0),
                    we're selecting a single field from a structure.

    *deref:     We append a new region, flatCount = dereferencedType.flatCount, offset = 0,
                    we're selecting an array item.

    join:       We're replacing a reference with whatever it is refering to,
                    and we join parent lifetime ~ child paths,
                        glueing the innermost parent subregion
                            with the outermost child subregion.

                Feels like the last one is an N*M situation unfortunately.
*/

inline fn Lifetime_op(lt: Lifetime, each, minPathDepth! = 1)
{
    mut result: byte[];

    lt.Lifetime_each: |r_raw, paths, locid, lax isStatic, lax isTemp|
    {
        result ~= r_raw;

        if (paths == SR_empty)
        {
            result ~= paths;
            continue;
        }

        if (SELF_TEST)
            locid || BUG("Lifetime_op: non-locid non-x00x00 subregion.");

        //
        lax let result0 = result.len;

        each(:result, :paths);

        assertPathsValid(result[result0 ..], :minPathDepth);
    }

    return Lifetime(uni0n: result);
}

pub fn Lifetime_op_field(lt: Lifetime, flatCount: i32, flatOffset: i32)
{
    return lt.Lifetime_op(|paths, ref result|
    {
        mut offset = 0;
        paths.walkPaths(:offset,

            onLastSubRegion: |isLastSubRegion, isLastPath, raw_prefix, flatCount!struct_flatCount, flatOffset!struct_flatOffset|
            {
                if (SELF_TEST)
                    flatCount + flatOffset <= struct_flatCount || BUG(
                        "Lifetime_op_field: field.flatOffset(" ~ flatOffset ~ ")"
                            ~ " + field.flatCount(" ~ flatCount ~ ")"
                            ~ " !<= struct.flatCount(" ~ struct_flatCount ~ ")");

                result ~= raw_prefix;
                result.appendSubRegion(
                    :flatCount, :isLastSubRegion, :isLastPath,
                    flatOffset: struct_flatOffset + flatOffset);
            });
    });
}

pub fn Lifetime_op_deref(lt: Lifetime, flatCount!deref_flatCount: i32)
{
    return lt.Lifetime_op(minPathDepth: 2, |paths, ref result|
    {
        mut offset = 0;
        paths.walkPaths(:offset,

            onLastSubRegion: |isLastPath, raw_prefix, flatCount!parent_flatCount, flatOffset!parent_flatOffset|
            {
                if (SELF_TEST)
                    parent_flatCount == 1 || BUG("Lifetime_op_deref: parent_flatCount(" ~ parent_flatCount ~ ") != 1");

                result ~= raw_prefix;

                result.appendSubRegion(
                    flatCount:  parent_flatCount,
                    flatOffset: parent_flatOffset,
                    :isLastPath, isLastSubRegion: false);

                // This is the actual deref.
                result.appendSubRegion(
                    flatCount:  deref_flatCount,
                    flatOffset: 0,
                    :isLastPath, isLastSubRegion: true);
            });
    });
}

pub fn Lifetime_op_join(lt: Lifetime, child: byte[..])
{
    return lt.Lifetime_op(|paths!parent, ref result|
    {
        mut _p0 = 0;
        parent.walkPaths(offset: _p0,

            onLastSubRegion: |
                isLastPath      !parent_isLastPath,

                flatCount       !parent_flatCount,
                flatOffset      !parent_flatOffset,

                raw_prefix      !parent_rawPrefix|
            {
                // So we've got the raw parent prefix,
                //  the last parent subregion flatCount and flatOffsets.
                //
                // We offset each final parent flatOffset
                //  with each head offset of the child path,
                //   this is an N*M combo + needs uniqueness:
                //
                // Last Parent Subregion: [ parentOffset0, parentOffset1 ]
                // First Child Subregion: [ childOffset0, childOffset1 ]
                //
                // Resulting Subregion: [ p0 + c0, p0 + c1, p1 + c0, p1 + c1 ]
                //
                mut _c0 = 0;
                child.walkPaths(offset: _c0,

                    onSubRegion: |
                        isFirstSubRegion    !child_isFirstSubRegion,
                        isLastSubRegion     !child_isLastSubRegion,
                        isLastPath          !child_isLastPath,

                        flatCount           !child_flatCount,
                        flatOffset          !child_flatOffset|
                    {
                        // Begin a new path -
                        //  take everything from parent path,
                        //   up to the final subregion.
                        //
                        if (child_isFirstSubRegion)
                            result ~= parent_rawPrefix;

                        let result_flatOffset =
                            !child_isFirstSubRegion ? child_flatOffset :
                            {
                                if (SELF_TEST)
                                    child_flatOffset + child_flatCount <= parent_flatCount || BUG(
                                        "Lifetime_op_join: child_flatOffset(" ~ child_flatOffset ~ ")"
                                            ~ " + child_flatCount(" ~ child_flatCount ~ ")"
                                            ~ " !<= parent_flatCount(" ~ parent_flatCount ~ ")");

                                child_flatOffset + parent_flatOffset
                            };

                        // Use the child flatCount.
                        result.appendSubRegion(
                            flatCount:          child_flatCount,
                            flatOffset:         result_flatOffset,
                            isLastSubRegion:    child_isLastSubRegion,
                            isLastPath:         parent_isLastPath && child_isLastPath);
                    });
            });
    });
}
