import module;
import fail;


//

let Region_TEMP     = byte(1);
let Region_STATIC   = byte(0);

fn parseRegion(ref offset: i32, str: byte[])
{
    mut shift:  u32;
    mut result: u32;

    mut c: byte;
    while (offset < str.len
            && (c = str[offset++]).u32 >= 128)
    {
        result |= (c.u32 & 0x7f) << shift;
        shift  += 7;
    }

    return result | c.u32 << shift;
}

fn appendRegion(ref str: byte[], mut v: u32)
{
    while (v >= 128)
    {
        str ~= byte((v & 0x7f) | 0x80);
        v  >>= 7;
    }

    str ~= byte(v);
}


//

pub fn Lifetime_from(locid!: i32): Lifetime =
{
    if (SELF_TEST)
        locid > 0 || BUG("Lifetime_from: Bad locid");

    mut uni0n: byte[];
    uni0n.appendRegion(locid.u32 << 1);
    return Lifetime(:uni0n);
}

pub fn Lifetime_from(argidx!: i32): Lifetime =
{
    if (SELF_TEST)
        argidx >= 0 || BUG("Lifetime_from: Bad argidx");

    mut uni0n: byte[];
    uni0n.appendRegion((argidx.u32 << 2) | 3);
    return Lifetime(:uni0n);
}


//

inline fn merge !<B, L, R, Else, Rest>(

    l_chars.uni0n,
    r_chars.uni0n,

    both!?: B, left!?: L, right!?: R, else!?: Else,

    left_done!?,
    right_done!?,

    rest!?: Rest)
{
    mut l_start: i32;
    mut r_start: i32;

    mut l_offset: i32;
    mut r_offset: i32;

    mut l: u32;
    mut r: u32;

    mut l_dirty = true;
    mut r_dirty = true;

    mut l_done = false;
    mut r_done = false;

    lax let rest_chars =
    {
        :REST
        {
            for (;;)
            {
                if (l_dirty) {
                    l_dirty = false;
                    l_start = l_offset;

                    if (l_offset < l_chars.len) {
                        l = parseRegion(l_chars, offset: l_offset);
                    }
                    else {
                        left_done();
                        if !(Rest -> [])
                            break :REST r_chars[r_dirty ? r_offset : r_start :];
                        else
                            l_done = true;
                    }
                }

                if (r_dirty) {
                    r_dirty = false;
                    r_start = r_offset;

                    if (r_offset < r_chars.len) {
                        r = parseRegion(r_chars, offset: r_offset);
                    }
                    else {
                        right_done();
                        if !(Rest -> [])
                            break :REST l_chars[l_dirty ? l_offset : l_start :];
                        else
                            r_done = true;
                    }
                }

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1

                        // Because we historically like to iterate lifetimes
                        //  from innermost to outermost, we compare backwards here,
                        //   so that we end up with the same reverse iteration order,
                        //    we basically store them innermost to outermost.
                        //
                        : (l == 0) != (r == 0)      ? r == 0    ? -1 : +1
                        : (l == 1) != (r == 1)      ? r == 1    ? +1 : -1
                                                    : r <> l;

                if (cmp == 0)
                {
                    l_dirty = true;
                    r_dirty = true;
                    if !(B -> [])
                    {
                        both(l_chars[l_start : l_offset]);
                        continue;
                    }
                }
                else if (cmp < 0)
                {
                    l_dirty = true;
                    if !(L -> [])
                    {
                        left(l_chars[l_start : l_offset]);
                        continue;
                    }
                }
                else
                {
                    r_dirty = true;
                    if !(R -> [])
                    {
                        right(r_chars[r_start : r_offset]);
                        continue;
                    }
                }

                if !(Else -> [])
                {
                    else(cmp > 0 ? r_chars[r_start : r_offset]
                                 : l_chars[l_start : l_offset]);
                }
            }

            return;
        }
    };

    //
    rest(rest_chars);
}


//

pub fn Lifetime_union(a: Lifetime, b: Lifetime): Lifetime =
{
    mut result: Lifetime;

    merge(a, b,
        else: |raw| result.uni0n ~= raw,

        // Early exits.
        left_done: || {
            if (!result)
                return b;
        },
        right_done: || {
            if (!result)
                return a;
        },
        rest: |either| {
            result.uni0n ~= either;
            break;
        });

    return result;
}

pub fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime =
{
    mut result: Lifetime;

    merge(a, b,
        both: |raw| result.uni0n ~= raw,

        // Early exits.
        rest: |_| { break; });

    return result;
}

pub fn Lifetime_diff(from: Lifetime, remove: Lifetime): Lifetime =
{
    mut result: Lifetime;

    merge(from, remove,
        left: |raw| result.uni0n ~= raw,

        // Early exits.
        left_done: || {

            // TODO FIX - must be `break;` instead
            return result;
        },
        rest: |left| { // right done, left-leftovers
            result.uni0n ~= left;
            break;
        });

    return result;
}


//

pub fn Lifetime_add(ref l: Lifetime, r: Lifetime)
{
    if (r)
        l = Lifetime_union(l, r);
}

pub fn Lifetime_rem(ref l: Lifetime, r: Lifetime)
{
    if (l && r)
        l = Lifetime_diff(l, r);
}


//

pub fn Lifetime_each(lifetime: Lifetime, each)
{
    let chars = lifetime.uni0n;
    mut offset = 0;

    while (offset < chars.len)
    {
        let r = parseRegion(chars, :offset);

        each(
            locid?:     i32(r & 1 ? 0 : r >> 1),
            argidx?:    i32(r & 1 ? r >> 2 : 0),
            isStatic?:  r == 0,
            isTemp?:    r == 1,
            isArgIdx?:  r & 3 == 3);
    }
}

pub fn Lifetime_process(lifetime: Lifetime, each)
{
    mut result:         Lifetime;
    lax mut dedupe:     Lifetime;
    mut replacements:   Lifetime;

    fn visit(shadow lifetime: Lifetime)
    {
        let chars = lifetime.uni0n;
        mut offset = 0;

        while (offset < chars.len)
        {
            let offset0 = offset;
            let r = parseRegion(chars, :offset);

            :TEST
            {
                fn continue_climb(mut parent: Lifetime)
                {
                    // Init the deduper lazily,
                    //  we want this to compile away if noone uses it.
                    if (!dedupe)
                        dedupe = lifetime;

                    // Don't visit anything twice.
                    parent.Lifetime_rem(dedupe);
                    dedupe.Lifetime_add(parent);

                    visit(parent);
                    continue;
                }

                fn continue_replace(replacement: Lifetime)
                {
                    replacements.Lifetime_add(replacement);
                    continue;
                }

                fn continue_keep()
                {
                    // Doing this in a convoluted way so that
                    //  you can inline this multiple times at no cost.
                    break :TEST;
                }

                each(continue_keep?: fn continue_keep,
                    continue_climb?: fn continue_climb,
                  continue_replace?: fn continue_replace,

                    // Same as above.
                    locid?:     i32(r & 1 ? 0 : r >> 1),
                    argidx?:    i32(r & 1 ? r >> 2 : 0),
                    isStatic?:  r == 0,
                    isTemp?:    r == 1,
                    isArgIdx?:  r & 3 == 3);

                continue;
            }

            result.uni0n ~= chars[offset0 : offset];
        }
    }

    visit(lifetime);

    result.Lifetime_add(replacements);

    return result;
}


//

pub let Lifetime_static =
    Lifetime(uni0n: [ Region_STATIC ]);

pub let Lifetime_temporary =
    Lifetime(uni0n: [ Region_TEMP ]);

pub fn hasTemporary(lifetime: Lifetime): bool
    lifetime.uni0n.starts(with: Region_TEMP);

pub fn hasStatic(lifetime: Lifetime): bool
    lifetime.uni0n.ends(with: Region_STATIC);


//

fn Lifetime_some(lifetime: Lifetime, some)
{
    Lifetime_each(:lifetime):
        |lax locid, lax argidx, lax isStatic, lax isTemp, lax isArgIdx|
    {
        if (some(locid?:    locid,    argidx?: argidx,
                 isStatic?: isStatic, isTemp?: isTemp,
                 isArgIdx?: isArgIdx))
        {
            return true;
        }
    }

    return false;
}

pub fn Lifetime_if_only(lifetime: Lifetime, if_only)
{
    mut first = true;

    Lifetime_each(:lifetime):
        |lax locid, lax argidx, lax isStatic, lax isTemp, lax isArgIdx|
    {
        if (!first)
            break;

        first = false;

        //
        if (if_only(locid?:    locid,    argidx?: argidx,
                    isStatic?: isStatic, isTemp?: isTemp,
                    isArgIdx?: isArgIdx))
        {
            return true;
        }
    }

    return false;
}

pub fn Lifetime_has(lifetime: Lifetime, locid!search: i32)
    lifetime.Lifetime_some(
        |locid| locid == search);

pub fn Lifetime_has(lifetime: Lifetime, argidx!search: i32)
    lifetime.Lifetime_some(
        |isArgIdx, argidx| isArgIdx && argidx == search);

pub fn Lifetime_makeShared(lifetime: Lifetime): Lifetime =
    Lifetime_union(lifetime, Lifetime_static);
