import compiler;


// A quick self-test without I/O.

let TEST_SRC =
`
    fn test(one: i32) {
        let zero = one - 1;
        let two  = one * 2;

        fn inner(i: i32): i32
            i > zero ? outer(i - one) : zero;

        fn outer(i: i32): i32
            two * inner(i);

        return outer(one) + (two - one) * 17;
    }

    fn main(): i32 {
        return test(1) - 17;
    }
`;

pub fn self_test(): i32
{
    let cpp = snippet2cpp(TEST_SRC);
    return cpp.find("int main()") ? 0 : 101;
}

fn TODO(src: string)
{
    try {
        ZERO(src);
    }
    catch (e) {
        println("  TODO: ", e, "\n", src);
        return;
    }

    throw("TODO test is actually passing: " ~ src);
}

fn TODO(src: string[])
{
    try {
        ZERO(src);
    }
    catch (e) {
        println("  TODO: ", e, "\n", src.join("\n\n"));
        return;
    }

    throw("TODO test is actually passing: " ~ src.join("\n\n"));
}

fn TODO_gcc(src: string)
{
    if (process::LINUX)     TODO(src);
    else                    ZERO(src);
}


// Run the whole battery & build self.

pub fn runTests()
{
    ////////////////////////////////////////////////
    let TESTDIFFS_FILE = PRJDIR ~ "testdiff/now.td";

    let implicit mut testdiffs =
        testdiff::parse(
            file::read(TESTDIFFS_FILE));
    ////////////////////////////////////////////////

    ZERO(`
        return 1 - 1;
    `);

    ZERO(`
        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);


    // Mutation & references.

    ZERO(`
        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;
    `);

    ZERO(`
        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        fn decr(ref num: i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    FAIL(`
        //*F
        let sum = 0;
        /*/
        mut sum = 0;
        //*/
        while (sum < 15)
            sum++; //ERR ++ overload

        return sum - 15;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;
    `);

    TODO(`
        mut i = 5;
        mut sum = 0;
        while (let x = i--) sum += x - i;
        return sum - 5;
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);
    `);


    // Structs & using.

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;
    `);

    FAIL(`
        struct Range {
            min: i32;
            max: i32;
        }

        //*F
        let r =
        /*/
        mut r =
        //*/
        Range(1, 2);

        r.min++; //ERR ++ overload
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            r_min: i32;
            r_max: i32;
        }

        fn size(using r: Range)
            r_max - r_min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct X {
            a: i32;
        }

        fn test(using x: X, b: i32) a + b;
        fn hey(using x: X) test(-1);

        return X(1).hey;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);

    FAIL(`
        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using a: A, using b: B)
            //*F
            x + z;
            /*/
            y + z;
            //*/

        fn main() test(A(1, 1), B(-1, -1));
    `);

    ZERO(`
        struct CurrentFn {
            parent_idx: i32;
            using RoR?: CurrentFn_ResetOnResolve; // not yet populated
        };

        struct CurrentFn_ResetOnResolve {
            ret_count: i32;
        };

        fn test(f: CurrentFn) f.parent_idx - f.ret_count;
        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));
    `);


    // Templating checks.

    ZERO(`
        let x = 3;
        return x / 2 - 1;
    `);

    ZERO(`
        fn hey(a) a * a;
        fn main() 0.hey;
    `);

    ZERO(`
        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;
    `);

    ZERO(`
        fn div3by(a) 3 / a;
        return div3by(2) - 1;
    `);

    ZERO(`
        fn add3(a: $T, b = 3) a + b;
        struct v1 { x: i32; };
        fn +(a: v1, b: i32) v1(a.x + b);
        fn main() add3(2.v1).x - 5;
    `);

    ZERO(`
        fn mul_ab_init(a: $T, b = 0) a*b;
        fn main() mul_ab_init(1);
    `);

    ZERO(`
        fn mul_ab_annot_init(a: $T, b: $T = 0) a*b;
        fn main() mul_ab_annot_init(1);
    `);

    ZERO(`
        fn mul_ab_opt(a: $T, b?: $T) a*b;
        fn main() mul_ab_opt(1);
    `);

    ZERO(`
        fn ab(a, b) a + b*2;
        fn main() ab(b: 1, a: -2);
    `);

    ZERO(`
        struct yi32 { y: i32; };
        fn add_s_vy(v, s) s + v.y;
        fn main() add_s_vy(v: yi32(1), -1);
    `);

    ZERO(`
        struct xi32 { x: i32; };
        fn add_s_vx(s, v) s + v.x; // <- args reordered
        fn main() add_s_vx(v: xi32(1), -1);
    `);

    ZERO(`
        fn ab(a, b = 0, c = 0) a + b*2 + c*3;
        fn main() ab(3, c: -1);
    `);

    ZERO(`
        fn ab(a, b = -1) a + b*2;
        fn main() ab(3.0, -1.5).i32;
    `);

    ZERO(`
        let NEG_ONE_FIVE = -1.5;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(3, NEG_ONE_FIVE).i32;
    `);

    ZERO(`
        let TWO = 2.0;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(TWO).i32;
    `);

    ZERO(`
        fn self_rec_template(x: $T): $T                     ;; !FN_resolve
            x > 0 ? self_rec_template(x / 2 - 5) : x;

        fn main()
            self_rec_template(7) + 2;
    `);

    ZERO(`
        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;
        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;
        fn main() ab_rec(11) + 200;
    `);

    ZERO(`
        fn main() {
            let a = 1;
            fn add1(b) a + b;
            return 2.add1 - 3;
        }
    `);

    ZERO(`
        pub fn map(a: [$T], fn) {               ;; !DEAD_code
            mut res: fn($T)[];
            res.grow_junk(a.len);
            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);
            return res;
        }

        pub fn clone(a: $T)
        case ($T -> @copy) a;
        case ($T -> [$U]) a.map(fn clone);
        default {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };
        pub struct ModuleOutputs { deps: Scope[]; };

        pub fn test(a: ModuleOutputs) {
            let b = a.clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);
    `);

    ZERO(`
        struct X { a: i32; };
        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;
        fn hey(using x: X) add_uxa_b_inline(-1);
        return X(1).hey;
    `);

    ZERO(`
        struct X { a: i32; };
        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;
        fn hey(using x: X) add_uxa_b_template(-1);
        return X(1).hey;
    `);

    TODO(`
        fn a_len(a: [$T]) a.len; // a conversion could navigate this here
        struct Test { using a: i32[]; };
        fn main() Test.a_len;
    `);


    // Lexical vs dynamically scoped templates -
    //  I guess we want both, but how?
    //   Should we just make it explicit?

    ZERO([
    `
        pub fn identity(dont_leak_me) dont_leak_me;
    `,
    `
        let dont_leak_me = 1;
        fn main() _0::identity(dont_leak_me * 2) - 2;
    `
    ]);

    ZERO(`
        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;
        let dont_leak_me = 1;
        fn main() inl_id_leak(dont_leak_me * 2) - 2;
    `);

    ZERO(`
        let static = 1;
        fn template(arg) static + arg;
        let arg = 7;                        // <- template shouldn't see this
        let result = template(arg / -4);    // <- when specializing here
        fn main() result;
    `);

    ZERO(`
        fn main() {
            let static = 1;
            fn template(arg) static + arg;
            let arg = 7; // same here, except we're in a fn.
            return template(arg / -4);
        }
    `);


    // Recursion, closures & implicit args.

    ZERO(`
        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);
    `);

    ZERO(`
        fn test(one: i32)
        {
            let zero = one - 1;
            let two  = one * 2;

            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;
    `);

    ZERO(`
        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn inner_noret(i: i32)
            outer_noret(i - 1);

        fn outer_noret(implicit x: i32, i: i32)
            i > 0   ? inner_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_noret(1) - 7;
    `);

    ZERO(`
        inline fn inner_inl(i: i32): i32
            outer_inl(i - 1);

        /*TODO inline tailrec*/
        fn outer_inl(implicit x: i32, i: i32): i32
            i > 0   ? inner_inl(i)
                    : x + i;

        let implicit x = 7;
        return outer_inl(1) - 7;
    `);

    ZERO(`
        fn inner_templ(i): i32
            outer_templ(i - 1);

        fn outer_templ(implicit x: i32, i): i32
            i > 0   ? inner_templ(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ(1) - 7;
    `);

    ZERO(`
        fn inner_templ_noret(i)
            outer_templ_noret(i - 1);

        fn outer_templ_noret(implicit x: i32, i)
            i > 0   ? inner_templ_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ_noret(1) - 7;
    `);

    ZERO(`
        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);
    `);

    ZERO(`
        inline fn outer_inl(i: i32): i32
            i > 0   ? inner_inl(i)
                    : 2 * i;

        /*TODO inline tailrec*/
        fn inner_inl(implicit x: i32, i: i32): i32
            outer_inl(i - 2 * x);

        let implicit x = 3;
        return outer_inl(6);
    `);

    ZERO(`
        fn outer_templ(i): i32
            i > 0   ? inner_templ(i)
                    : 2 * i;

        fn inner_templ(implicit x: i32, i): i32
            outer_templ(i - 2 * x);

        let implicit x = 3;
        return outer_templ(6);
    `);

    ZERO(`
        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        fn inner(i: i32): i32
            outer(i - 1);

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn outer(implicit x: i32, i: i32)
            i > 0   ? inner(i)
                    : x + i;

        fn noret(i: i32) = outer(i);

        fn template(i) = i & 1 ? outer(i) : noret(i);

        fn inner(i: i32): i32
            template(i - 1);

        fn main() {
            let implicit x = 7;
            return outer(1) - 7;
        }
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_1(call_self = false): i32
            = !call_self ? returns_x : calls_self_1 * 2;

        let implicit x = 7;
        return calls_self_1(true) - 14;
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_2(call_self = false): i32
            = call_self ? calls_self_2 * 3 : returns_x;

        let implicit x = 7;
        return calls_self_2(true) - 21;
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_3(call_self = false): i32
        {
            let add = 1; // <- this wasnt visible
            fn do_call_self(mul: i32 = 0)
                = calls_self_3 * mul + add;

            return call_self ? do_call_self(4) : returns_x;
        }

        let implicit x = 7;
        return calls_self_3(true) - 29;
    `);

    ZERO(`
        fn noret_x(implicit x: i32) x;

        fn templ_calls_self_2(call_self): i32
            = call_self ? templ_calls_self_2(false) * 3 : noret_x;

        fn main() {
            let implicit x = 7;
            return templ_calls_self_2(true) - 21;
        }
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;
    `);

    ZERO(`
        fn main() {
            let a = 1;
            let b = 2;
            let c = 3;

            fn depth1(x: i32) {
                fn depth2(y: i32) {
                    return sibling1(x + y + b);
                }

                return depth2(x + a);
            }

            fn sibling1(z: i32): i32 {
                return z + c;
            }

            return depth1(0) - 6;
        }
    `);

    ZERO(`
        fn goto0(x): i32 = x ? goto0(x / 2) : 0;
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x ? goto0(x / 2) : 0;
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]
        fn main() goto0(1);
    `);

    ZERO(`
        fn impl(implicit ref _impl: i32) _impl;
        fn arg_or_impl(ref arg: i32) arg || impl;
        fn main() {
            let implicit mut _impl: i32;
            mut arg: i32;
            ref ref = arg_or_impl(arg);
            return arg - ref;
        }
    `);

    ZERO(`
        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {
            if (x == 0) return a;
            if (x == 1) return b;
            return hello(b, a, x / 17);
        }

        fn main() {
            mut a = [1, 2, 3];
            mut b = [4, 5, 6];
            hello(a, b, 397)[1] *= 5;
            return b[1] - 25;
        }
    `);

    ZERO(`
        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                ZERO( --x ); // Same as below but without the unused 'y' thing,
                sum += x;    //  everything works because the call to ZERO isnt really unconditional,
            }                //   and if it were, then the never return would actually be correct.
        }

        fn main() {
            let implicit mut sum = 0;
            ZERO(4);
            return sum - 11;
        }
    `);

    TODO(`
        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                let y = x / 2;
                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,
                ZERO(   y ); //  meaning y remains unused here on first solve.
                sum += x;
            }
        }

        fn main() {
            let implicit mut sum = 0;
            ZERO(4);
            return sum - 12;
        }
    `);


    //

    ZERO(`
        let x = 1;

        fn test(): &i32
            x;

        return test - 1;
    `);

    ZERO(`
        let a = 1;
        let x: &i32 = a;

        return a - x;
    `);

    ZERO(`
        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;
    `);

    ZERO(`
        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;
    `);


    // Arrays.

    ZERO(`
        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];
    `);


    // A basic testing setup for array ops,
    //  that can be flipped around for making sure
    //   e.g. copy-on-write behaves as expected.

    fn ARROPS(
        literal: string,
        operation: string,
        mut assertion: string)
    {
        assertion = "(" ~ assertion ~ ")";

        fn EXPR(varname: string)
            assertion.replace(
                all: "@", with: varname);

        mut src: string;

        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr0 = [" ~ literal ~ "];";
        src ~= "\n        arr0." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr0") ~ " != 0) return 13;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    mut orig = [" ~ literal ~ "];";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr1 = CLONE(orig);";
        src ~= "\n        arr1." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr1") ~ " != 0) return 17;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr2 = STEAL(orig);";
        src ~= "\n        if (orig.len) return 19;";
        src ~= "\n        arr2." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr2") ~ " != 0) return 23;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    return 0;";
        src ~= "\n";

        ZERO(src);
    };

    ARROPS( "0,1,2,3,4",
            "push(5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "insert(5, 5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "pop()",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "splice(4, 1)",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "unshift(5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "insert(0, 5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "shift()",
            "@[0] + @[2] - @[3]");

    ARROPS( "0,1,2,3,4",
            "insert(1, 5)",
            "@[2] + @[5] - @[1]");

    ARROPS( "0,1,2,3,100",
            "splice(1, 3)",
            "@.len + @[0] + @[1] - 102");


    //

    ZERO(`
        let OPERATORS = [ "+", "-", "*", "/" ];

        fn main()
            OPERATORS[2] == "*" ? 0 : 1;
    `);

    ZERO(`
        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;
    `);

    ZERO(`
        struct SelfRec { x: SelfRec[]; };
        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        struct ABRec { x: BARec[]; };
        struct BARec { x: ABRec[]; };
        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        struct ABRec { x: BARec[]; y: ABBARec[]; };
        struct BARec { x: ABRec[]; y: ABBARec[]; };
        struct ABBARec { x: ABRec[]; y: BARec[]; };
        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];
    `);


    // Strings.

    ZERO(`
        mut str = "hello ";
        str ~= "world";

        return str.len - 11;
    `);

    ZERO(`
        let str = "hello " ~ "world";

        return str.starts(with: "hel")
             ? str.len - 11
             : 171;
    `);

    ZERO(`
        let str = "a" ~ 1710010;

        return str == "a1710010"
             ? 0 : 101;
    `);

    ZERO(`
        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);
    `);

    ZERO(`
        return "hello world".find("world")
             - 2 * [1, 7, 13, 14, 19].find(14);
    `);

    ZERO(`
        return ("hello world".has("world") ? 1 : 0)
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;
    `);

    ZERO(`
        let hw = "hello world!";
        let a = hw.slice(6, 6 + 5);
        let b = hw.substr(6, 5);
        return a == b && a == "world" ? a.len - 5 : 1;
    `);

    ZERO(`
        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;
    `);


    // String opti checkers.

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
        {
            let a0 = alloc::STAT_COUNT();
            strA.slice(0, 26) == "0123456789abcdef0123456789" || throw("bad slice");

            let a1 = alloc::STAT_COUNT();
            a0 == a1 || throw("did alloc");

            return 0;
        }
    `);

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;
    `);


    // Maps.

    ZERO(`
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        return x["hello"] - x["world"] + 1;
    `);

    ZERO(`
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        let b = "hello world";
        mut offset = 0;

        fn pop(): string {
            mut a = "";

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a ~= c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;
    `);


    // Default arguments.

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test() - 3;
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(b: -1);
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(-2);
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.b;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey() Test();
        return hey.x;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey(y: i32 = 0)
            y   ? Test(1)
                : Test();

        return hey.x;
    `);

    FAIL(`
        //*F
        fn test(a = "hello") a.len; //ERR assign
        /*/
        fn test(a = 0) a + 1;
        //*/
        fn main() test(-1);
    `);


    // Truth tests.

    ZERO(`
        let s = 7;
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = 0;
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = "hello";
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = "";
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = [ 4 ];
        return s ? 0 : 1;
    `);

    ZERO(`
        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;
    `);


    // Loop labels.

    ZERO(`
        mut sum = 0;
        outer: for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :outer;
                if (x == 2) break    :outer;
            }
        }

        return sum - 34;
    `);

    ZERO(`
        mut sum = 0;
        outer: for (mut x = 0;; x++) {
            for (mut y = 0; y < x; y++) {
                if (y & 1 && !(x & 1))
                    continue :outer;

                sum += x;
            }

            sum += x * 1000 + 100;
            if (x > 1) ;; EXPECT break;
                break; // anon
        }

        // x=0:           + 0100
        // x=1: 1         + 1100
        // x=2: 2
        // x=3: 3 + 3 + 3 + 3100 break
        return sum - 4312;
    `);


    // Lint.

    FAIL(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        //*F
        t.test; //ERR orphan
        /*/
        t.test();
        //*/

        return t.x - 1;
    `);


    // Logical selectors.

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        fn what(a: i32) {
            a == 2 || a & 1 || throw("what1");
            a  > 1 && a & 1 && throw("what2");
            a  > 0 && a & 3 || throw("what3");
            return a + 4;
        }
        fn main() 1.what - 2.what + 1;
    `);

    ZERO(`
        fn gen(len: i32) {
            mut res: i32[];
            for (mut i = 0; i < len; i++) res ~= i;
            return res;
        }
        fn test(len: i32) {
            let x = [-5, +5];
            let y = len.gen && x;
            return x[y.len / 2];
        }
        fn main() 0.test + 1.test;
    `);


    // Short-circuit assignment, esp. useful for maps
    //  and the cpp `map[k] = v`,
    //   which doesn't decompose safely.

    ZERO(`
        mut i = 7;
        i ||= 11;
        return i - 7;
    `);

    ZERO(`
        mut i = 0;
        i ||= 11;
        return i - 11;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m["hello"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m["_not_hello_"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g - 1;
    `);


    // Lint checks.

    ZERO(`
        {
            {
                return 0;
            }
        }
    `);

    FAIL(`
        {
        //*F
        {
            return 0; //ERR block
        }
        /*/
            {
                return 0;
            }
        }
        //*/
    `);

    ZERO(`
        {
            return 0;
        }
    `);

    FAIL(`
        {
            return 0; //ERR block
        //*F
       }
        /*/
        }
        //*/
    `);

    FAIL(`
        {
            return 0; //ERR block
        //*F
         }
        /*/
        }
        //*/
    `);

    FAIL(`
        let y = [ 1 ];              ;; TODO fu::slate<1, int> { 1 }
        let
        //*F
        /*/ lax //*/ //ERR unused
        z = [ 2 ];                  ;; TODO fu::slate<1, int> { 2 }

        return y[0] - 1
    `);

    FAIL(`
        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,
            //*F
            /*/ lax //*/ //ERR unused
            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;
    `);


    // Stuff that isn't working out quite right -
    //  Keep those around, there's no principle to these tests,
    //   they just stressed our stuff in weird ways.

    ZERO(`

    struct BINOP {
        P: Map(string, i32);
    };

    fn setupOperators(): BINOP
    {
        mut out: BINOP;

        fn binop(op: string)
            out.P[op] = 7;

        binop(",");

        return out;
    }

    shadow let BINOP = setupOperators();
    let P_COMMA = BINOP.P[","] || assert();

    fn main() P_COMMA - 7;

    `);

    ZERO(`

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;

    `);

    ZERO(`
        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags?:     i32;
            value?:     string;
            items?:     SolvedNode[];
            token:      Token;

            type:       Type;
            target?:    ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: "definit",
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;
    `);

    ZERO(`
        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);
    `);

    ZERO(`
        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;
    `);

    ZERO(`

        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;
    `);

    ZERO(`
        fn test(id: i32) id;
        return test(/*id*/0); // <- bad parse
    `);

    ZERO(`
        return 0b101.i32 - 5;
    `);

    ZERO(`
        return 0o101.i32 - 65;
    `);

    ZERO(`
        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part: &string = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            return path.join("/");
        }

        fn main() path_normalize("./hello///hey") == "hello/hey" ? 0 : 1;
    `);

    ZERO(`

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == "..")
                    path.splice(--i, 2);
            }

            return path.join("/");
        }

        fn path_join(a: string, b: string)
            path_normalize(a ~ "/" ~ b);

        fn main()
            path_join("hello/hey", "./../you//") == "hello/you/"
                ? 0 : 1;
    `);

    ZERO(`
        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial
        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done
        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done

        pub fn main() {
            let a = Template(ScopeMemo(+3));
            let b = Template(ScopeMemo(-3));
            return a.locals + b.locals; // <- fails to match.
        }
    `);

    ZERO(`
        pub struct MeshBuilder
        {
            verts?:     byte[];
            indices?:   byte[];
            vert_bytes: i32;
            num_verts?: i32;
        };

        pub fn alloc(
            using mb: &mut MeshBuilder,
            new_verts: i32,
            new_indices: i32)
        {
            verts.resize_junk((verts.len + new_verts) * vert_bytes);

            let index_bytes = 4;
            indices.resize_junk((indices.len + new_indices) * index_bytes);
        }

        pub fn setup_quads(
            using mb: &mut MeshBuilder, // <- the 'using' introduced more bindings,
            num_quads: i32)             // <-  advancing the target index number of this arg,
                : &mut [byte]           // <-   confusing the callsite lifetime of this view.
        {
            let b0 = verts.len;
            let v0 = num_verts;
            let i0 = indices.len;

            alloc(num_quads * 4, num_quads * 6);

            mut v1 = v0;

            let indices_i32: &mut [i32] =
                indices[i0, indices.len]
                    .view(i32);

            for (mut i = 0; i < indices_i32.len; i += 6)
            {
                indices_i32[i    ] = v1;
                indices_i32[i + 1] = v1 + 1;
                indices_i32[i + 2] = v1 + 2;

                indices_i32[i + 3] = v1;
                indices_i32[i + 4] = v1 + 2;
                indices_i32[i + 5] = v1 + 3;

                v1 += 4;
            }

            num_verts = v1;

            return verts[b0, verts.len];
        }

        let QUAD_VBO: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0,
            +1, +1, 0,      0, 0, 1,    1, 1,
            -1, +1, 0,      0, 0, 1,    0, 1,
        ];

        pub fn main()
        {
            mut mb = MeshBuilder(
                vert_bytes: 4 * (3+3+2));

            mb.setup_quads(1).view(f32) .= QUAD_VBO;

            return mb.num_verts - 4;
        }
    `);

    ZERO(`
        fn target(implicit ref _target: i32) _target;

        // this suddenly reported that it doesn't see __solveStruct
        fn GET_mut(ref x: i32) x || target;

        // while i was trying to reproduce an ambig "o" fail here
        fn __solveStruct(mut arg: i32): i32 {
            if (arg) {
                ref o = GET_mut(arg);
                o++;
                checkRecursions(o, o);
            }
            return arg;
        }

        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

        fn main()
        {
            let implicit mut _target = 0;

            return __solveStruct(1) - 4;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn target(implicit ref _itarg: i32) _itarg;

        fn main()
        {
            let implicit mut _itarg = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn target(implicit ref _itarg: i32) _itarg;
        fn GET_mut(ref x: i32) x || GET_mut(target += 1);

        fn main()
        {
            let implicit mut _itarg = 0;
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(++target);
            return GET_mut(target) - 1;
        }
    `);

    TODO_gcc(`
        fn main()
        {
            mut target = 0;
            fn __solveStruct(mut arg: i32): i32 {
                ref o = GET_mut(arg); o += target;
                return target;
            }

            fn GET_mut(ref x: i32) x || (target = __solveStruct(target += 1));
            return __solveStruct(0) - 2;
        }
    `);

    FAIL(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || //*F
                              a = A(incr(a))    /*/         // Lint should complain here,
                             (a = A(incr(a))); //*/         //  this was an honest mistake.
        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || (a = B(incr(a)));
        fn B(ref b: i32) b || (b = A(incr(b)));
        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }
        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }
        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn main()
        {
            fn each(cond, cons) cond && cons();
            fn arg(implicit ref __arg: i32) __arg;
            fn __solveStruct(x = 3) each(arg, || arg += x);
            let implicit mut __arg = 1;
            return __solveStruct - 4;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;

            fn each(cond, cons) cond && cons();

            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));

            fn __solveStruct(mut arg: i32, x = 0): i32 {
                each(arg, || arg += x);
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;

            // this suddenly reported that it doesn't see __solveStruct
            fn GET_mut(ref x) x || (target = __solveStruct(target));

            // while i was trying to reproduce an ambig "o" fail here
            fn __solveStruct(mut arg: i32): i32 {
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }
    `);

    FAIL(`
        struct ValueType { modid: i32; };
        struct Type { using vtype: ValueType; };
        struct Target { modid: i32; index: i32; };
        struct Overload { name: string; id: string; };

        fn GET(target: Target): Overload =
            Overload(
                name: "N" ~ target.index,
                  id: "I" ~ target.index);

        fn main() {
            mut specs: Map(string, Target);

            fn setSpec(mangle: string) {
                ref t = specs[mangle] ||= Target;

                // This template should start expanding on GET(target).name,
                //  which should conflict with overload name.
                fn name(shadow target)
                    GET(target) //*F
                        .name; /*/ .id; //*/

                return t.name;
            }

            return setSpec("hey").len - 2;
        }
    `);

    ZERO(`
        pub struct ScopeSkip { start: i32; end: i32; };

        pub fn each(items: [$T], scope_skip: ScopeSkip[], fn, start = 0) {
            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

            mut i0 = start;
            for (mut i = 0; i < scope_skip.len + 1; i++) {
                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
                if (ss.end <= i0)
                    continue;

                let i1 = ss.start;
                for (shadow mut i = i0; i < i1; i++)
                    fn(items[i]);

                i0 = ss.end;
            }
        }

        pub fn test(items?: i32[]) {
            mut sum = 0;
            let ss: ScopeSkip[];
            items.each(ss, |item| sum += item, start: sum);
            return sum;
        }

        pub fn main() test();
    `);

    ZERO(`
        fn setupOperators(P_PREFIX_UNARY) // <- template
        {
            struct BINOP {
                PRECEDENCE:     Map(string, i32);
                RIGHT_TO_LEFT:  Map(i32,   bool);
            };

            mut out: BINOP; // <- no BINOP in scope
            mut precedence = P_PREFIX_UNARY;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT[precedence] = rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE[ops[i]] = precedence;
            }

            binop([ "|>" ]);

            //
            return out;
        }

        let BINOP = setupOperators(-1);

        fn main() {
            let precedence = BINOP.PRECEDENCE["|>"];
            return precedence;
        }
    `);

    ZERO([`
        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- no OPTOKENS in scope
                    return idx - 1;
            }

            return src.len;
        }
    `,
    `
        fn main() _0::lex("3 - 3") - 2; // <- from here
    `]);

    ZERO(`
        fn each(a: [$T], fn, start?!: i32)
            for (mut i = start; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut sum = 0;
            let a = [ 1, 2, 3 ];
            a.each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit
            return sum - 6;                     //     perhaps we can use the optionality to infer constness
        }
    `);

    ZERO(`
        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }
    `);

    ZERO(`
        struct Module  { cpp:    string; };
        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here

        fn snippet2cpp(cpp: string): string {
            let ctx = Context( Module(cpp) );
            {
                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.
                if (module.cpp)
                    return module.cpp;          ;; EXPECT return static_cast<fu_STR&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;
    `);

    ZERO(`
        struct Module  { cpp:     string;   };
        struct Context { modules: Module[]; };  // Module[] is COW-capable -
                                                //  - either prove there's no COW,
        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.
            let ctx = Context([ Module(cpp) ]);
            for (mut i = 0; i < ctx.modules.len; i++)
            {
                let module = ctx.modules[i];    ;; TODO .unique(i)
                if (module.cpp)
                    return module.cpp;          ;; TODO return static_cast<fu_STR&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;
    `);

    ZERO(`
        fn test(x: string) {
            // cg fail: fwd annots of the two fns where unconsting hey to "enable move",
            //          basically the decision was made in the wrong scope.
            let hey = "hey";
            fn inner(you: string) you && hey ~ you || outer("what#1");
            fn outer(arg: string) inner(arg && " " ~ arg) || inner("what#2");
            return outer(x);
        }

        fn main() test("you").len - 7;
    `);

    TODO(`
        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(args: &mut Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //
            let badref = args.len && args[0];
            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }
    `);

    ZERO(`
        pub struct Target { modid!: i32; packed!: i32; };
        pub inline fn index(a: Target) a.packed;

        <split/>

        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;
    `);

    ZERO(`
        struct ID   { offset: i32;  };
        struct Data { items:  ID[]; };

        using fn Data(implicit all: Data[], nid: ID): Data {
            return all[nid.offset];
        }

        fn test(node: ID) {
            let init = node.items[0];
            return init.items.len;
        }

        fn main() {
            let implicit all =  [ Data([ ID(1)      ])
                                , Data([ ID, ID, ID ]) ];

            return 0.ID.test - 3;
        }
    `);

    ZERO(`
        struct Context
        {
            fuzzy: Map(string, string);
            files: string[];
        }

        fn resolveFile(
            implicit ctx: &mut Context,
            from: string, name: string): string
        {
            let path    = from ~ name;
            let cached  = ctx.fuzzy[path];
            if (cached)
                return cached == "\v" ? "" : cached;

            fn tryResolve(): string
            {
                let exists = file::size(path) >= 0;
                if (exists)
                    return path;

                return "";
            };

            let resolve = tryResolve();
            ctx.fuzzy[path] = resolve || "\v";
            return resolve;
        }

        pub fn resolveFile(
            implicit ctx: &mut Context,
            path: string): string
        {
            let fuzzy = path.find('\v');
            if (fuzzy > 0)
            {
                let from = path.slice(0, fuzzy);
                let name = path.slice(fuzzy + 1);
                if (from && name && !name.has('\v'))
                {
                    let res = resolveFile(:from, :name);
                    if (res)
                        return res;

                    // Tests have the files prepopulated,
                    //  we only pay the cost of lookup when about to fail compile.
                    let prepopulated = from ~ name;
                    if (ctx.files.has(prepopulated))
                        return prepopulated;
                }
            }

            return path;
        }

        fn main() {
            let implicit mut ctx: Context;
            return resolveFile("a").len - 1;
        }
    `);

    ZERO(`
        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }
    `);

    ZERO(`
        fn lex(src: string) {
            let end = src.len;
            mut idx = 0;

            fn err_str(idx1: i32) {
                while (idx < end && src[idx] == ' ') idx++;
                return src.slice(idx, idx1);
            }

            fn err(idx1_x2: i32) err_str(idx1_x2 /2);
            return err(end *2);
        }

        fn main() lex("    hello").len - 5;
    `);

    ZERO(`
        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void
        {
            // Fuzzing module splits.
            for (mut i = 0; i < sources.len; i++)
            {
                // Note: redundant "ref" here.
                ref src = sources[i];
                for (;;)
                {
                    mut start0 = src.find("[split/]");
                    if (start0 < 0)
                        break;

                    let start00 = start0;
                    let start1  = start0 + 8;
                    while (start0 && src[start0 - 1] == ' ') start0--;

                    let moduleA = src.slice(0, start0);
                    let moduleB = src[start0, start00] ~ "import _" ~ i ~ ";" ~ src[start1, src.len];
                    let without = src[0, start0] ~ src[start1, src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                }

                sum += src.len;
            }
        }

        fn main() {
            let implicit mut sum: i32;

            ZERO( "AAAA|BB[split/]CC".::split("|") );
            let expect = 4+2+2 + 4+2+2 + 10; // 10 = "import _0;"

            return sum - expect;
        }
    `);

    ZERO(`
        struct SolvedNode {
            bli: i32;
        };

        // --> [2] ... triggered the solve of this fn, ...
        fn SolvedNode(blah: string) {
            return SolvedNode(blah.len.NOT_PREPPED_YET);
        }

        // [1] During prep, this type annotation ...
        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {
            return node.bli + 2;
        }

        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).
        fn NOT_PREPPED_YET(x: i32) {
            return x * 2;
        }

        fn main() {
            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode("hello")) - (2*5+2);
        }
    `);


    // Let's move on to some cooler quality of life shit.

    ZERO(`
        let a = 7;
        let b = a && 3;
        return b - 3;
    `);

    ZERO(`
        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw("woot");
    `);

    ZERO(`

        struct TrueStory { kind: string; value: string; };

        mut specialized = TrueStory(kind: "fn", value: "val");

        specialized.kind == "fn" && specialized.value || throw("nope");

        let v: &mut string = specialized.kind == "fn"
                          && specialized.value
                          || throw("nope");
        v ~= "ue";

        return specialized.value == "value" ? 0 : 1;

    `);

    ZERO(`
        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };
    `);

    FAIL(`
        struct ScopeIdx { raw: i32; };
        //*F
        fn thing(x: i32) x;
        /*/
        fn thing(x: i32) ScopeIdx(x);
        //*/
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);
    `);


    // Various templating fallacies.
    //
    // TODO figure these out -
    //  These are problematic in a bunch of ways here.
    //   But mostly, the case patterns for this kind of thing are outright moronic.

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        fn main()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;
    `);

    ZERO(`
        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;
    `);

    ZERO(`
        struct mat4 { i: i32; };
        struct RenderFrame { u_mat4_VP: mat4; };

        inline fn mat4_identity() mat4(1);

        fn test(output: &mut RenderFrame) {
            output.u_mat4_VP = mat4_identity;
        }

        fn main() {
            mut ret: RenderFrame;
            test(ret);
            return ret.u_mat4_VP.i - 1;
        }
    `);

    FAIL(`
        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()
            //*F
            ScopeSkip(min: -1, max: +1)
            /*/
            ScopeSkip(start: -1, end: +1)
            //*/
                .end - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        struct mat34 {
            mx: vec3; my: vec3; mz: vec3;
            mo: vec3;
        };

        inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        // What broke is this using reports a conflict,
        //  because 'determinant' got expanded within 'inverse',
        //   and there's another using mat34 there.
        //    Basically we totally don't want it to expand there.
        inline fn determinant(using _: mat34): f32
            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z
            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;

        fn inverse(using mat: mat34): mat34
        {
            let idet = 1 / mat.determinant;

            let i_mx = vec3(
                idet * (- mz.y * my.z + my.y * mz.z),
                idet * (+ mz.y * mx.z - mx.y * mz.z),
                idet * (- my.y * mx.z + mx.y * my.z));

            let i_my = vec3(
                idet * (+ mz.x * my.z - my.x * mz.z),
                idet * (- mz.x * mx.z + mx.x * mz.z),
                idet * (+ my.x * mx.z - mx.x * my.z));

            let i_mz = vec3(
                idet * (- mz.x * my.y + my.x * mz.y),
                idet * (+ mz.x * mx.y - mx.x * mz.y),
                idet * (- my.x * mx.y + mx.x * my.y));

            return mat34(
                i_mx, i_my, i_mz,

                vec3( // point3
                      mo.x * -i_mx.x
                    + mo.y * -i_my.x
                    + mo.z * -i_mz.x,

                      mo.x * -i_mx.y
                    + mo.y * -i_my.y
                    + mo.z * -i_mz.y,

                      mo.x * -i_mx.z
                    + mo.y * -i_my.z
                    + mo.z * -i_mz.z));
        }

        fn main() i32 <|
            mat34_identity.inverse.determinant - 1;
    `);

    ZERO(`
        struct TEA
        {
            v0: u32;
            v1: u32;
        }

        inline fn r4(using _: &mut TEA, sum: &mut u32)
        {
            mut delta: u32 = 0x9e3779b9;

            for (mut i = 0; i < 4; i++) {
                sum += delta;

                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        // Stack overflow solving this,
        //  argmax is +inf, and it just
        //   re-enters and re-enters.
        inline fn r4(tea: &mut TEA) {
            mut sum: u32; tea.r4(sum);
        }

        fn main() {
            mut tea: TEA;
            tea.r4();
            return (tea.v0 ^ tea.v0).i32;
        }
    `);

    TODO(`
        struct ScopeSkip {
            min: i32;
            max: i32;
        };

        fn main() {
            let a = 1;
            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.
            mut t: ScopeSkip; t = x.min && [ x.min, a ];
            return a + t.min + t.max;
        }
    `);

    ZERO(`
        // Same as below, but avoids the $T call, which is also broken somehow.
        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -
        //   we emit useless overloads for mutrefs when its clearly useless.

        fn rec_cases(a: $T)
        case ($T -> @primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i) {
                shadow mut a = a;
                a.i /= 2;
                return rec_cases(a);
            }
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;
    `);

    ZERO(`
        fn rec_cases(a: $T)
        case ($T -> @primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i)    return rec_cases($T(i: a.i / 2));
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;
    `);

    ZERO(`
        struct X { i: i32; };
        type Y = X;
        fn main() Y(1).i / 2;
    `);

    ZERO(`
        struct Node {
            kind  ?: string;
            items ?: Node[];
            value ?: string;
        };

        fn astReplace(node: Node, mutate): Node {
            fn walk(shadow ref node: Node) {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        fn test(n: Node, a: string, b: string) {
            return astReplace(n, |ref item: Node| {
                if (item.value == a) {
                    if (item.items.len == 1 && item.kind == "call")
                        item.value = b;
                    else if (item.kind == "str")
                        item.value = b;
                }
            });
        }

        fn main() {
            let v0 = Node(kind: "str", value: "woot");
            let v1 = v0.test("woot", "who");
            return v1.value.len - 3;
        }
    `);


    // Let's try something new.

    ZERO(`
        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);

            <alt>
            // This is an aside, managed to lose the copy qual when working structs
            //  Initially noticed it because visitNodes tried to change its sighash
            mut cpy = tree; if (cpy) {} // <- but this fails cleanly when tree is nocopy
            </alt>

            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

    `);

    ZERO(`
        return 0 > 1 ? throw("should type check") : 0;
    `);

    ZERO(`
        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            let _x = throw_hey()
                catch err
                    return err.len - 3;

            return _x || 7;
        }
    `);

    ZERO(`
        fn throw_hey() {
            throw("hey");
        }

        fn main(): i32 {
            let _x = throw_hey()
                catch err
                    return err.len - 3;

            return _x || 7;
        }
    `);

    ZERO(`
        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                return throw_hey();
            }
            catch (e) {
                return e.len - 3;
            }

            return 11;
        }
    `);

    ZERO(`

        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }
    `);


    // Lifetimes, type inference, copy elision, temporaries.

    ZERO(`
        fn test() {
            mut x = 5;
            return x;
        }

        fn main()
            test() - 5;
    `);

    ZERO(`
        struct Test { i: i32; };

        fn test() {
            mut x = Test(5);
            return x;
        }

        fn main()
            test().i - 5;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; };

        fn test() {
            mut x = Test(5, -5);
            return x;
        }

        fn main()
            test().a + test().b;
    `);

    ZERO(`
        struct X { x: i32; };
        fn ref2arg(x: X) = x;

        fn main() {
            let NOTREF = ref2arg(X(101));
            return NOTREF.x - 101;
        }
    `);

    FAIL(`
        //*F
        nocopy
        /*/
        //*/
        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32; };
        fn ref2arg(v: XY) = v;

        fn main() {
            let a = XY(99, 2);
            let ref2a = ref2arg(a);
            return mem::ptr_eq(a, ref2a) ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };
        fn retmutref(ref nc: NoCopy) nc;

        fn main() {
            mut nc: NoCopy;
            nc.retmutref.retmutref.i++;
            return nc.i - 1;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };
        fn mutrefself(ref nc: NoCopy) {
            nc.i++;
            return nc;
        }

        fn main() {
            mut nc: NoCopy;
            nc.mutrefself().mutrefself();
            return nc.i - 2;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;
            let b: NoCopy;
            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;                      // <- b now temp

            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a) a;                    // <- now templates
        fn  retargs_if(a, b) a.i ? b : a;
        fn  retargs_or(a, b) a || b;
        fn retargs_and(a, b) a && b;

        fn main() {
            mut a: NoCopy;                      // <- now muts
            mut b: NoCopy;
            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;
            return a.i + b.i - 1;
        }
    `);

    ZERO(`
        fn as_blocks_after(x: i32) {
            mut zero = 0;
            if (x > 2) // a broken stmt emit lifted the loop out of the conditional
                for (mut i = 0; i < x; i++)
                    zero = i + i*zero;

            return zero;
        }

        fn main() 2.as_blocks_after;
    `);

    TODO(`
        struct Lifetime { woot: Lifetime[]; };

        // We could codegen this as a cpp template!
        //  We'd need to auto& all inner locals too.
        //
        fn Lifetime_test(x: Lifetime) {
            x.woot.len & 1 && throw("This is very important.");
            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);
            return x;
        }

        fn Lifetime_fromBinding(x: i32) {
            mut woot: Lifetime[];
            for (mut i = 0; i < x; i++) woot[i] = Lifetime();

            // Or we can just add const_casts at such callsites,
            //  so that things end up working as if the call was inlined,
            //   which weakens the validation we get but is way cleaner.
            //
            // TODO: needs to track uniqueness for that to work.
            //
            return Lifetime_test(Lifetime(:woot));
        }

        fn main() 0.Lifetime_fromBinding.woot.len;
    `);

    ZERO(`
        fn test(x: i32) {                       // none of these need vecs
            let c = [10007];                    ;; TODO fu::slate<1, int> { 10007 }
            let a = [7, 11];                    ;; TODO fu::slate<2, int> { 7, 11 }
            let b = {                           ;; TODO fu::slate<1, int> { int(x) }
                BRK: {
                    if (x & 2) break :BRK c;
                    if (x & 1) break :BRK [ x ]; // a val
                    a; // a ref
                }
            };
            return a[0] - b[0] * a[1];
        }

        fn main() 1.test + 4;
    `);


    // Returning a mut arg.

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test) {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test): Test {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);

    ZERO(`
        fn compile_snippets(x: string) x.find('a') && throw("throw#1");
        fn ZERO(x: string) x.find('b') && throw("throw#2");

        fn FAIL(x: string): string {
            let ctx = compile_snippets(x) && "hey"
                catch e return ZERO(x) && e;

            return ctx;
        }

        fn main() FAIL("a").len;
    `);

    ZERO(`
        // The thing below but shorter:
        //  the '|| throw' introduces a bullshit lambda during codegen,
        //   which misreturns a dangling reference to its own frame.
        fn test(x: string) [x][0] || throw("nope!");
        fn main() "what".test.len - 4;
    `);

    ZERO(`
        fn only(s: $T[]) s.len == 1 ? s[0] : throw ("len != 1: " ~ s.len);

        struct Node       { kind: string; };
        struct SolvedNode { kind: string; };

        fn solveNodes(n: Node[]) {
            mut r: SolvedNode[];
            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);
            return r;
        }

        // the '|| throw' introduces a bullshit lambda during codegen,
        //  which misreturns a dangling reference to its own frame.
        fn solveDeclExpr(n: Node) solveNodes([ n ]).only || throw ("!only");

        fn main() solveDeclExpr(Node("a")).kind.len - 1;
    `);

    ZERO(`
        pub fn test(x: i32): i32[] { ;; !NONTRIV_autocopy
            mut a = [ 4 ];
            mut b = [ 5 ];
            mut c = [ 6 ];

            for (mut i = 0; i < x; i++) {
                a.unshift(x);
                b.unshift(x);
                c.unshift(x);
            }

            inline fn which() {
                return :test x & 1 ? a : b;
            }

            if !(x & 2)
                return which();

            return c;
        }

        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];
    `);


    // Returning never vs void.

    ZERO(`
        fn incr_x_to_1(ref x: i32) {
            x && throw("this reports return t_never");
            fn incr_x() { return x++; }
            incr_x();
        }
        fn main() {
            mut x = 0;
            incr_x_to_1(x);
            return x - 1;
        }
    `);

    ZERO(`
        fn main() {
            mut x = 0;
            fn incr_x_to_1() {
                x && throw("this reports return t_never");
                fn incr_x() { return x++; }
                incr_x();
            }
            incr_x_to_1();
            return x - 1;
        }
    `);

    ZERO(`
        fn apply(fn, v) fn(v);
        fn main() {
            mut x = 0;
            fn scope_using(via: i32) {
                x && throw("this reports return t_never");
                // which messed up retcount for scope_using
                fn visit(item: i32) {
                    if (item) return item;
                    return x++;
                }
                apply(fn visit, via);
            }

            scope_using(x);
            return x - 1;
        }
    `);


    // Usability of numeric literals.

    ZERO(`
        fn main()
            i32(PI * 2.0) - 6;
    `);

    ZERO(`
        fn main()
            i32(PI * 2 - 6);
    `);

    ZERO(`
        fn main()
            PI * 2 - 6 |> i32;
    `);

    ZERO(`
        fn main()
            i32 <| PI * 2 - 6;
    `);

    ZERO(`
        let x: f32 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: f32 = 1.0; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: u8 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x = 1.f32; fn main() 1 - x.i32;
    `);

    ZERO(`
        fn gt0(x: f32) x > 0;
        fn main() gt0(1.f32) ? 0 : 1;
    `);

    ZERO(`
        struct Hey { x: f32; };
        fn hey() Hey(1);
        fn main() hey.x.i32 - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);
        fn main() {
            let v = test(1);
            return (v.x + v.z).i32;
        }
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(f: f32) vec3(x: f, z: -1);
        fn main() {
            let v = test(-1);
            return (v.x - v.z).i32;
        }
    `);

    ZERO(`
        fn hey(i: f32) i.f32 + 0.5;
        fn main() hey(1).i32 - 1;
    `);

    ZERO(`
        fn lin2srgb(l: f32): f32
            l <= 0.0031308
                ? l * 12.92
                : 1.055 * pow(l, 1/2.4.f32) - 0.055;

        fn lin255(v: f32) u32 <|
            v.lin2srgb.max(0).min(1) * 255.99;

        fn main() i32 <|
            lin255(1) - 255;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        inline fn /(a: f32, b: vec3)
            vec3(a / b.x, a / b.y, a / b.z);

        fn main() i32 <|
            (1/vec3(x: 1)).x - 1;
    `);

    ZERO(`
        let QUAD_DATA: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
            -1, +1, 0,      0, 0, 1,    0, 1, 0,

            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
        ];

        fn main() QUAD_DATA.len - 6 * 9;
    `);

    ZERO(`
        fn test(a: bool): u8 = a ? 1 : 0;

        fn main() test(false).i32;
    `);

    ZERO(`
        fn test(a: bool): u8 = a && 1;

        fn main() test(false).i32;
    `);

    ZERO(`
        pub let A_u8: u8 = 0x0;

        fn ATTRIB(type: u8, count: i32, srgb = false): u8
            = type & 0x3 | count.u8 << 2

            // TODO can't deep-retype the last cast unfortunately:
            //  we need another hint to drive typing here,
            //   perhaps monogenous signatures, or else.
            | (srgb && 0x80.u8);

        fn main() ATTRIB(A_u8, 4).i32 - 16;
    `);

    ZERO(`
        pub struct Geometry    { g: i32; };
        pub struct Texture     { t: i32; };
        pub struct RenderFrame { r: i32; };

        pub struct LogicFrame_in
        {
            lastLogic:  LogicFrame;
        };

        pub struct LogicFrame
        {
            DATA_fbx:   Geometry;
            TEX_A:      Texture;
            TEX_AO:     Texture;
            TEX_M:      Texture;
            TEX_N:      Texture;
            TEX_R:      Texture;
            HDR:        Texture;
        };

        pub struct RenderFrame_in
        {
            w:          i16;
            h:          i16;
            frame:      i32;

            mouseX:     f32;
            mouseY:     f32;
            mouseBtns:  i32;

            using logic:    LogicFrame;
            lastRender:     RenderFrame;
        };

        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame
        {
            return RenderFrame(args.HDR.t);
        }

        fn main() 0;
    `);

    ZERO(`
        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;
        fn main() "hello".leadingDigit.i32;
    `);


    // Typedefs.

    ZERO(`
        type Test = i32[];
        fn yo(t: Test) t[0] + t[1];
        fn main() yo([-1, +1]);
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        fn hello(a: i32[]) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];
        fn hello(a: X) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];

        fn list(): i32[][] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];

        fn list(): X[] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);


    // Trivial equality.

    ZERO(`
        let arr = [1, 2];
        fn eq(a: i32[], b: i32[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;
    `);

    ZERO(`
        let arr = [1, 2];
        fn eq(a: $T[], b: $T[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;
    `);


    // Slices, pass one.

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main()
            test([-1, +1]);

        ;; EXPECT fu::slate<2, int> { -1, +1 }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [-1, +1];
            return hey.test();
        }
    `);

    ZERO(`
        fn test(i: i32) [ i, i + 1 ];
        fn main() test(0)[1] - 1;
    `);

    ZERO(`
        fn test(hey: byte[])
            hey.view(u32)[0];

        fn main() {
            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];
            return (hey.test - 0x1010101).i32;
        }
    `);

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main() {
            let hey = [7, -1, +1];
            return test(hey[1, 3]);
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [7, -1, +1];
            return hey[1, 3].test();
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey.= [2, -3];

        fn main() {
            mut hey = [1, 0, 0];
            test(hey[1, 3]);
            return hey[0] + hey[1] + hey[2];
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(out: &mut [Hey]) {
            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];
        }

        fn main() {
            mut a = [ Hey ];
            a.test();
            return a[0].i - 16843009;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(x: &mut [i32], y: [ Hey ])
            x .= y.view(i32);

        fn main() {
            mut a = [ 0 ];
            test(a, [ Hey(13) ]);
            return a[0] - 13;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn main() {
            mut a = [ 0 ];
            a .= [ Hey(13) ].view(i32);
            return a[0] - 13;
        }
    `);

    ZERO(`
        fn test(a: [byte], b?: [byte]) a == b;
        fn main() test("") ? 0 : 1;

        ;; EXPECT test(fu::view<std::byte>{}, fu::view<std::byte>{})
    `);

    ZERO(`
        // When we spec find(), the second arg is a view, not an array, so the $T specs to a less than array:
        //  next thing that happens is that the first argument, which is $T[] specs to an array of views except they're not even refs for some reason.
        //   so then we try to use the spec but quals matching doesn't descend through the type cannon, so they mismatch with:
        //
        // First arg of find(), the $T[] to search:
        //
        // ACTUAL CANON: []+1028[]+28byte
        //                        ^^^^^^^ of bytes
        //                 ^^^^^^^ of arrays (resize + copy)
        //               ^^ view of
        //
        // EXPECT CANON: [][]+28byte
        //                   ^^^^^^^ of bytes
        //                 ^^ not a view (not a ref), nor an array - no resize/copy
        //               ^^ view of
        //
        let NOTES = [ "AAA", "BBB", "CCC" ];
        fn what(annot: string) NOTES.find(annot[1, annot.len]);
        fn main() what("!BBB") - 1;
    `);


    // Don't repeat yourself ctors.

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a: Hey[] = [ [ -1 ], [ +1 ] ];
            return a[0].i + a[1].i;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn test(): Hey {
            return [ 0 ];
        }

        fn main() test.i;
    `);


    // Non-defaulted struct members.

    FAIL(`
        struct Test {
        //*F
            a: i32;
        /*/
            a?: i32;
        //*/
            b: i32;
        };

        return Test(b: 1).a;
    `);

    FAIL(`
        struct Test {
            b: i32;
        //*F
            a: i32;
        /*/
            a?: i32;
        //*/
        };

        return Test(1).a;
    `);


    // Recursive structs.

    ZERO(`
        struct Node {
            items?: Node[];
            stuff?: Node[];
        };

        fn rec_copy(ref a: Node) {
            // If implemented naively,
            //  by the time you copy stuff it's no longer there.
            a = a.items[0];
        }

        fn main() {
            mut a = Node(items: [ Node(stuff: [ Node ]) ]);
            rec_copy(a);
            return a.stuff.len - 1;
        }
    `);


    // Explicit arguments & struct members.

    ZERO(`
        fn test(a: i32, b!: i32 = 1) a + b;
        return test(-1);
    `);

    FAIL(`
        fn test(a: i32, b!: i32 = 1) a + b;
        //*F
        return test(-2, +2);
        /*/
        return test(-2, b: +2);
        //*/
    `);

    FAIL(`
        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;
        //*F
        return Test(-2, +2).test;
        /*/
        return Test(-2, b: +2).test;
        //*/
    `);

    FAIL(`
        struct Test { a?: i32; b?!: i32; };
        fn test(t: Test) t.a + t.b;
        //*F
        return Test(-2, +2).test;
        /*/
        return Test(b: +2).test - 2;
        //*/
    `);

    ZERO(`
        let _precedence = 0;
        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;
        fn main() parseExpression();
    `);

    ZERO_SAME([
    `
        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x?!: i32) x;
        fn B(x?: i32) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x! = 0) x;
        fn B(x = 0) A(:x);
        fn main() A + B;
    `
    ]);


    // Optional arguments.

    FAIL(`
        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, //*F
                              c
                              /*/
                              b
                              //*/
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;
    `);

    ZERO(`
        pub fn reveach(items: [$T], fn)
            for (mut i = items.len; i --> 0; )
                fn(items[i], i?: i);

        pub fn main() {
            mut sum = 0;
            [1, 2, 3].reveach(|x   | sum += x          );
            [1, 2, 3].reveach(|x, i| sum += x * i * 100);
            return sum - 806;
        }
    `);


    // Intlit sizechecks.

    FAIL(`
        fn main() {
            let ret: i8 =
            //*F
            128
            /*/
            127
            //*/
            ;

            return (ret - 100).i32 - 27;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i16 =
            //*F
            32768
            /*/
            32767
            //*/
            ;

            return (ret - 32700).i32 - 67;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i32 =
            //*F
            2147483648
            /*/
            2147483647
            //*/
            ;

            return (ret - 2147483600).i32 - 47;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i64 =
            //*F
            9223372036854775808
            /*/
            9223372036854775807
            //*/
            ;

            return (ret - 9223372036854775800).i32 - 7;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i8 =
            //*F
            -129
            /*/
            -128
            //*/
            ;

            return (ret + 100).i32 + 28;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i16 =
            //*F
            -32769
            /*/
            -32768
            //*/
            ;

            return (ret + 32700).i32 + 68;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i32 =
            //*F
            -2147483649
            /*/
            -2147483648
            //*/
            ;

            return (ret + 2147483600).i32 + 48;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i64 =
            //*F
            -9223372036854775809
            /*/
            -9223372036854775808
            //*/
            ;

            return (ret + 9223372036854775800).i32 + 8;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u8 =
            //*F
            256
            /*/
            255
            //*/
            ;

            return (ret - 0xff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u16 =
            //*F
            65536
            /*/
            65535
            //*/
            ;

            return (ret - 0xffff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u32 =
            //*F
            4294967296
            /*/
            4294967295
            //*/
            ;

            return (ret - 0xffffffff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u64 =
            //*F
            18446744073709551616
            /*/
            18446744073709551615
            //*/
            ;

            return (ret - 0xffffffffffffffff).i32;
        }
    `);

    ZERO(`
        pub fn set_once(ref entry, bit: i32): bool
        {
            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'
            if (entry & mask)           //  which doesnt work for some reason
                return false;

            entry |= mask;
            return true;
        }

        fn main() {
            mut entry: u64;
            let a = set_once(entry, 32);
            let b = set_once(entry, 32);
            return a && !b ? 0 : 101;
        }
    `);


    // Imports & pubs.

    FAIL([
    `
        pub fn noop() {} // AUTOPUB
        //*F
        /*/
        pub
        //*/
        fn hello() 3;
    `,
    `
        import _0;
        fn main() 6 - hello * 2;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        fn main() 1._0::Hey.i - 1;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        import _0;
        pub inline fn test(h: Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        fn main() 1._0::Hey._1::test - 3;
    `
    ]);

    ZERO([
    `
        pub struct You { i: i32; };
    `,
    `
        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];
    `,
    `
        pub inline fn test(using h = _1::init3) i + 7;
    `,
    `
        fn main() _2::test - 10;
    `
    ]);

    ZERO([
    `
        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };
    `,
    `
        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);
    `,
    `
        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;
    `,
    `
        pub fn main()
        {
            let m34 = _1::mat34_identity;
            let m44 = _2::mat4(m34);

            return m44.determinant.i32 - 1;
        }
    `
    ]);

    ZERO(`
        import vec3;

        fn main() vec3.maxc.i32;
    `);

    ZERO(`
        fn main() ::vec3.maxc.i32;
    `);

    ZERO([
    `
        pub fn _0(i: i32) i + 1;
    `,
    `
        fn main() (-1).::_0;
    `
    ]);

    ZERO([
    `
        pub fn add(ref to: $T[], item: $T) {
            for (mut i = 0; i < to.len; i++) {
                if (to[i] >= item) {
                    if (to[i] != item)
                        to.insert(i, item);

                    return;
                }
            }

            to.push(item);
        }
    `,
    `
        fn main() {
            mut x = [1, 2, 3];
            x._0::add(3); if (x.len != 3) return 33;
            x._0::add(4); return x.len - x[3];
        }
    `
    ]);

    ZERO([
    `
        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";
    `,
    `
        import _0;
        fn test(i: i32) {
            let v = i & 1 ? A : B;
            return v.len;
        }

        fn main() 0.test - 1.test;
    `
    ]);

    ZERO([
    `
        pub fn clone(a: $T)
        case ($T -> @copy) a;
        case ($T -> $T) {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }
    `,
    `
        pub nocopy struct Scope { x: i32; };

        pub struct ModuleOutputs {
            deps: i32[];
            scope: Scope;
        };

        pub fn test(a: ModuleOutputs) {
            let b = a._0::clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);
    `
    ]);

    ZERO([`
        // a private fn
        fn createShader(src: string) = src;

        // inits a public let
        pub let GEOMETRY_PASS_TEST = createShader("source code");
    `,
    `
        pub fn main() _0::GEOMETRY_PASS_TEST.len - 11;
    `]);


    // Explicit shadowing.

    ZERO(`
        let a = 1;
        shadow let a = a + 1;
        return a - 2;
    `);

    ZERO(`
        inline fn outer() inner(); // <- this reset root-scope
        inline fn inner() {
            // <- so main::i was visible here
            for (mut i = 0; i < 10; i++) return i;
            return 1;
        }
        fn main() {
            for (mut i = 0; i < 10; i++) return outer();
            return 1;
        }
    `);

    ZERO(`
        pub struct Target { modid: i32; packed: u32; };

        pub fn index(t: Target) i32(t.packed & 0x7fffffff);

        pub fn local_eq(t: Target, index: i32, implicit modid: i32)
            modid - t.modid || index - t.index;

        fn main() {
            let implicit modid = 1;
            return local_eq(Target(1, 0x80000002), 7) - 5;
        }
    `);


    // Return inference.

    ZERO(`
        struct HasInt { i: i32; };

        fn test(s: HasInt): &i32 {
            let i = s.i;
            return i;
        }

        fn main() HasInt(-1).test + 1;
    `);

    ZERO(`
        fn test(x: i32): &i32 = x;
        fn main() test(3) - 3;
    `);

    ZERO(`
        fn test(x: i32): &i32 {
            fn inner() x;
            return inner;
        }

        fn main() test(3) - 3;
    `);

    ZERO(`
        struct I { v: i32; };

        fn test(x: I): &i32 {
            fn inner() x.v;
            return inner;
        }

        fn main() test(I(3)) - 3;
    `);

    ZERO(`
        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() x.v[0];
            return inner;
        }

        fn main() test(I([3])) - 3;
    `);

    ZERO(`
        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() {
                let v = x.v;
                return v[0];
            }

            return inner;
        }

        fn main() test(I([3])) - 3;
    `);

    ZERO(`
        fn noReturn() throw ("ex");

        fn doesReturn(a: i32) {
            if (a > 0) return noReturn();
            return a;
        }

        fn main() doesReturn(-3) + 3;
    `);

    ZERO(`
        struct Context { modules: Module[]; };
        struct Module  { fname: i32; };

        fn test(implicit ctx: Context) {
            fn findModule(fname: i32): &Module {
                let modules = ctx.modules;
                for (mut i = 0; i < modules.len; i++) {
                    let module = modules[i];
                    if (module.fname == fname)
                        return module;
                }

                throw("Cannot locate: " ~ fname);
            }

            return findModule(0);
        }

        fn main() {
            let implicit ctx = Context([ Module ]);
            return test.fname;
        }
    `);

    ZERO(`
        fn noReturn() throw ("ex");

        fn returnVoid(a: i32): void {
            if (a > 0) return noReturn();
        }

        fn main() {
            returnVoid(0);
            return 0;
        }
    `);

    ZERO(`
        fn parseQualifierChain(mut i: i32): i32 {
            for (;;) {
                if !(i & 15) return i;
                i--;
            }
        }

        fn main() parseQualifierChain(15);
    `);

    ZERO(`
        fn main()
        {
            mut sum = 0;
            fn compile(x: i32)
            {
                // 1. this throw contributed a 'never' ret_count.
                x || throw ("x=0");
                if (x & 1) compile(x + 1); // 2. then this recursion did something.
                sum += x; // <- also this must be a closure.
                // 3. finally no ret_actual but non-zero ret_count.
            }

            compile(2);
            return sum - 2;
        }
    `);

    ZERO(`
        fn main()
        {
            mut sum = 0;
            fn getModule(fname: string) fname.len;
            fn compile(fname: string, via: string = "")
            {
                let module = getModule(fname) || throw ("import circle: '" ~ via ~ fname ~ "'.");
                if (module & 1) {
                    let fuzimports = fname.split("a");
                    for (mut i = 0; i < fuzimports.len; i++)
                        compile(
                            fname: fuzimports[i],
                              via: fname ~ " <- " ~ via);
                }

                sum += module;
            }

            compile("ab");
            return sum - 2;
        }
    `);

    ZERO(`
        fn A(implicit _A: i32[]) _A;
        fn B(implicit _B:  u8[]) _B;

        fn AB(x: i32) A[x] - B[x].i32;
        fn BA(x: i32) B[x].i32 - A[x];

        fn cycleA_inner(x: i32)
            x & 1   ? either(x + 1) + AB(x)
                    : BA(x);

        fn cycleA_outer(x: i32)
            x & 1   ? cycleA_inner(x + 1) + AB(x)
                    : BA(x);

        fn cycleB_inner(x: i32)
            x & 2   ? either(x + 1) + BA(x)
                    : AB(x);

        fn cycleB_outer(x: i32)
            x & 2   ? cycleB_inner(x + 1) + BA(x)
                    : AB(x);

        fn either(x: i32)
            x & 4   ? cycleA_outer(x)
                    : cycleB_outer(x);

        fn main() {
            let implicit _A = [ 0,    1,    2    ];
            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];

            return either(0);
        }
    `);


    // Dead code elim.

    ZERO(`
        fn if0_ret101(x: i32) {
            if      (x > 2) return x * 2;
            else if (x > 1) return x + 1; // <- left branch seeded right with never
            return x + 101;
        }

        fn main() 0.if0_ret101 - 101;
    `);

    FAIL(`
        fn hello(x: i32) {
            if (x & 1)
                return x * 2;
            //*F
            x; //ERR return
            /*/
            return x;
            //*/
        }

        fn main() 0.hello;
    `);


    // Let's start having fun.

    ZERO(`
        struct X { i: i32; };

        fn         ++(using x: &mut X) ++i;
        postfix fn ++(using x: &mut X) i++;

        fn main() {
            mut x: X;
            let a = x++;
            let b = ++x;
            return a || b - 2;
        }
    `);

    FAIL(`
        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()
        //*F
            -1.0
        /*/
            (-1.0)
        //*/
                .abs;

        fn main() test ? 0 : 7;
    `);

    ZERO(`
        fn test(s: $T) {
            mut sum = 0;
            for (fieldname i: $T) sum += s.i;
            return sum;
        }

        struct XY { x: i32; y: i32; };

        fn main() {
            let thing = XY(1, 2);
            let sum = test(thing);
            return sum - 3;
        }
    `);


    // Type assert.

    ZERO(`
        fn test() [] -> i32;
        fn main() test;
    `);


    // Defer.

    ZERO(`
        fn main() {
            mut a = 1;
            mut b = 0;
            {
                defer a++;
                b = a;
            }
            return (b+1) - a;
        }
    `);

    ZERO(`
        fn main() {
            mut a = 1;
            mut b = 0;
            mut c = 0;
            {
                defer a++;
                defer c = a;
                b = a;
            }
            return (b*27) - (a*11 + c*5);
        }
    `);

    ZERO(`
        fn test_defer_if_errok(throw_err: bool) {
            mut x      = 1;
            mut if_err = 0;
            mut if_ok  = 0;
            try {
                defer x++;
                defer:err if_err += x;
                defer:ok  if_ok  += x;

                if (throw_err)
                    throw("len=5");

                x += 8; // 9 defer++ = 10
            }
            catch (e) {
                x += e.len; // 6 defer++ = 7
            }

            return x * 3 + if_err * 5 + if_ok * 7;
        }

        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)
            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);
    `);


    // Conversions / ctors.

    ZERO(`
        type Test = i8;
        fn main() 256.Test.i32;
    `);

    FAIL(`
        fn test(a: $A, b: $B) b + //*F
            a;
            /*/
            $B(a);
            //*/
        fn main() i8(-1).test(+1);
    `);


    // First stab at higher-order functions.

    ZERO(`
        let x = { mut z = 0; z++; z };
        return x - 1;
    `);

    ZERO(`
        fn mul2(a) a*2;
        fn test(b, fn) fn(1 + fn(b));
        fn main() 14 - test(3, fn mul2);
    `);

    ZERO(`
        fn map(items: $T[], fn) {
            mut result: fn(items[0])[];
            for (mut i = 0; i < items.len; i++)
                result.push(fn(items[i]));

            return result;
        }

        fn sqr(x) x*x;

        fn main() [2].map(fn sqr)[0] - 4;
    `);

    ZERO(`
        fn reduce(items: $T[], fn, init?: $T) {
            mut result = init;
            for (mut i = 0; i < items.len; i++)
                result = fn(result, items[i]);

            return result;
        }

        fn main() [1, 2].reduce(|a, b| a + b) - 3;
    `);

    ZERO(`
        fn each(items: $T[], fn) {
            for (mut i = 0; i < items.len; i++) // <- one i
                fn(items[i]);
        }

        fn main() {
            mut i = 0;                  // <- another i, i got them to shadow each other
            [1, 2].each(|x| i += x);    //      in the everything-a-free-function
            return i - 3;               //      impl of closures
        }
    `);

    ZERO(`
        mut sum = 2;

        fn FnDecl_update(parent_idx: i32) {
            fn each(fn) fn();
            each(|| makeDirty(:parent_idx));
        }

        fn makeDirty(parent_idx: i32): void {
            sum += parent_idx;
        }

        FnDecl_update(1);

        return sum - 3;
    `);


    // Conversion functions.

    ZERO(`
        struct A { a: i32; };
        struct B { b: i32; };

        using fn bananas(a: A) B(a.a * 2);

        fn main() 1.A.b - 2;
    `);

    ZERO(`
        struct A { a: i32; };
        struct B { b: i32; };

        using fn bananas(a) B(a.a * 2); // <- template

        fn main() 1.A.b - 2;
    `);

    ZERO(`
        fn sqr(a: i32) a * a;
        fn woot(a.sqr) a + 1;
        fn main() 2.woot - 5;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B  { b:  i32; };

        fn a0(a1: A1) a1.a1 * 100;
        fn bananas(a) B(a.a0 * 2); // <- template
        fn woot(a.bananas: B) a.b; // <- check

        fn main() 1.A0.woot + 1.A1.woot - 202;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b0: i32; };
        struct B1 { b1: i32; };
        struct C  { c:  i32; };

        fn bananas(using _: A0) B0(a0 * 2);
        fn bananas(using _: A1) B1(a1 * 3);
        using fn c0(using _: B0) C(c: b0 * 5);
        using fn c1(using _: B1) C(c: b1 * 7);
        fn woot(using a.bananas: C) c; // extra conversion

        fn main() 1.A0.woot + 1.A1.woot - 31;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b:  i32; };
        struct B1 { b:  i32; };

        fn bananas(a0: A0) B0(a0.a0 * 2);
        fn bananas(a1: A1) B1(a1.a1 * 3);
        fn woot(a.bananas) a.b; // <- template

        fn main() 1.A0.woot + 1.A1.woot - 5;
    `);

    ZERO(`
        fn times_implicit(x: i32, implicit y: i32) x * y;
        fn times7(x: i32) x * 7;

        fn woot(a.times_implicit, b: u32) a * b.i32;
        fn woot(a: i32, b.times7: i32) a * b;

        fn test0() 3.woot(2.i32);

        fn test1() {
            let implicit y = 7;
            return 3.woot(2.u32);
        }

        fn main() test0 + test1 * 1000 - 42042;
    `);

    ZERO(`
        fn varargs(a[]) a[0] + a[1];
        fn main() varargs(1, 2) - 3;
    `);

    ZERO(`
        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;

        fn inspect(items.to_debug_str[]) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;
    `);

    ZERO(`
        struct vec32  { x: f32; };
        struct conv32 { v: f32; };

        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);

        fn main() i32 <| (1/vec32(1)).x - 1;
    `);

    TODO(`
        struct vec32  { x: f32; };
        struct conv32 { v: f32; };

        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x, a.v / b.y, a.v / b.z);

        fn main() i32 <| (1/vec32(1)).x - 1;
    `);

    TODO(`
        struct vec_u  { x: u32; };
        struct vec32  { x: f32; };
        struct vec64  { x: f64; };

        struct conv_u { v: u32; };
        struct conv32 { v: f32; };
        struct conv64 { v: f64; };

        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before
        using inline fn convert(v: f32): conv32 = [ v ];
        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after

        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);

        fn main() i32 <| (1/vec32(1)).x - 1;
    `);

    ZERO(`
        pub struct Module       { modid: i32; };
        pub struct Target       { modid: i32; index: i32; };
        pub struct Type         { using vtype: ValueType; };
        pub struct ValueType    { modid: i32; canon: string; };
        pub struct Overload     { kind: string; locals?: Overload[]; };

        fn main() {
            let implicit mut overloads: Overload[];

            using fn GET(target: Target, implicit overloads: Overload[]) {
                target.index > 0 || assert();
                if (target.modid < 0)
                    return overloads[-target.modid - 1].locals[target.index - 1];
                else
                    return overloads[target.index - 1];
            }

            fn try_GET(target: Target)
                target && GET(target);

            overloads ~= Overload("What");
            return try_GET(Target(0, 1)).kind.len - 4;
        }
    `);


    // Addrofns of struct fields.

    ZERO(`
        fn fn_v(fn, v) fn(v);
        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);

    ZERO(`
        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);

    ZERO(`
        fn fn_w(x, y) x(y);             // same thing but
        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);


    // Let's try to break scope-skips.

    ZERO(`
        fn identity(x) x;
        fn main() {
            fn outer(depth1) {
                let sum = depth1; return identity(|| sum);
            }
            let sum = 0; return outer(sum);
        }
    `);

    ZERO(`
        fn identity(x) x;
        fn test(depth0) {
            fn outer(depth1) {
                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);
    `);

    ZERO(`
        fn test(depth0) {
            fn identity(x) x;
            fn outer(depth1) {
                fn inner(depth2) {
                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);
                }
                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);
    `);

    ZERO(`
        fn test(depth0)
        {
            fn first(depth1) {
                fn first_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum;
                }

                let sum = depth0 + depth1;
                return first_inner(|| sum);
            }

            fn second(depth1) {
                fn second_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum + first(|| sum);
                }

                let sum = depth0 + depth1;
                return second_inner(|| sum);
            }

            let sum = depth0 + depth0;
            return second(|| sum);
        }

        fn main() test(0);
    `);

    ZERO(`
        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;

        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }

        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }

        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }

        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }
    `);


    // Template structs.

    ZERO(`
        fn sA(_: $T) struct { hey: $T; };

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;
    `);

    FAIL(`
        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey //*F
            ; /*/ .i32; //*/
    `);

    ZERO(`
        fn sB(_: $T) struct { hey: $T; };

        // Prep for the thing below.
        fn test(x) x.hey - 1;

        // 'a' must be callable.
        type a = sB(i32);
        fn main() a(1).test;
    `);

    TODO(`
        fn sB(_: $T) struct { hey: $T; };

        // Pattern & partial spec, how?
        fn test(x: sB($T)): $T =
            x.hey - 1;

        type a = sB(i32);
        fn main() a(1).test;
    `);


    // Macros & loops.

    ZERO(`
        fn test(x: i32) {
            outer: {
                inner: {
                    if (x > 1) break: outer;
                    if (x > 0) break: inner;
                    return 2;
                }
                return 1;
            }
            return 0;
        }

        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;
    `);

    ZERO(`
        fn test(x: i32) {
            return {
                BLOCK: {
                    if (x & 1) break :BLOCK 1;
                    if (x & 2) return 2;
                    3
                }
            };
        }

        fn main() 4.test - 5.test - 6.test; // 3-1-2
    `);

    ZERO(`
        fn test(a: i32) {
            mut w = 3;
            OUTER: w += {
                INNER: {
                    if (a & 1)  break: INNER;
                    else        break: OUTER;
                };
                5
            };
            return w;
        }
        fn main() 0.test + 1.test - 11;
    `);

    ZERO(`
        fn v(x: i32) {
            return {
                BLOCK:                          5000 + { // *2:
                    if (x == 9) continue :BLOCK 2000;    //   - here
                    if (x == 8) return           300;
                    if (x == 7) break :BLOCK      40;
                    else                           5;    //   - and here!
                };
            }; // -----------------------------------
        }
        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;
    `);

    ZERO(`
        fn each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn some(arr, fn) {
            arr.each(|x| { if (fn(x)) return x; });
            return 0;
        }

        fn main() [ 1, 2, 3 ].some(|v| v & 1 == 0) - 2;
    `);

    ZERO(`
        fn outer() {
            mut sum = 0;

            inline fn inner(v: i32) {
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return :outer sum;
                }

                return v * 2;
            }

            mut x = 1;
            for (;;) x = inner(x);
        }

        fn main() outer - 42; // extra points for style
    `);

    ZERO(`
        inline fn each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn main() {
            mut sum = 0;
            OUTER: [1, 2, 3, 4].each(|x| {
                sum += x;
                for (mut i = 1; i--; ) // once
                    if (sum == 6) break :OUTER;
            });
            return sum - 6;
        }

        ;; !NONTRIV_autocopy
    `);

    ZERO(`
        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) break; });
            return x - 1;
        }
    `);

    ZERO(`
        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) return x - 1; });
            return 101;
        }
    `);

    ZERO(`
        fn loop2d(x0, x1, y0, y1, fn) {
            for (mut y = y0; y < y1; y++)
            for (mut x = x0; x < x1; x++) fn(x, y);
        }

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }
    `);

    ZERO(`
        inline fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn loop2d(x0, x1, y0, y1, fn)
            loop1d(y0, y1, |y|
                loop1d(x0, x1, |x|
                    fn (x, y)));

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }
    `);


    // Relaxer.

    ZERO(`
        fn hello(a) a * a;          ;; EXPECT (const int a)
        fn main() {
            mut a = 3;
            let b = hello(a);
            return b - 9;
        }
    `);

    ZERO(`
        struct AB { a: i32; b: i32; };
        fn sqr   (ref x: i32) x * x;
        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        ;; EXPECT const s_AB&
        fn main() {
            mut ab = AB(3, 5);
            return ab.outer - 34;
        }
    `);

    ZERO(`
        pub fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }

        <split/>

        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;
    `);

    ZERO(`
        fn main() {
            mut a = [[ 7 ]];
            return a[0][0] - 7;        ;; EXPECT a[0][0]
        }
    `);

    ZERO(`
        struct Overload     { args: Argument[]; };
        struct SolvedNode   { x: i32; };
        struct Argument     { default: SolvedNode; };

        pub fn test(overload: Overload, ref args: SolvedNode[])
        {
            let host_args = overload.args;          ;; EXPECT fu::view<s_Argument> host_args

            args.resize(host_args.len);             // .len didnt relax its arg
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default;
                }
            }
        }

        fn main() {
            mut o: Overload;
            for (mut i = 0; i < 3; i++)
                o.args ~= Argument(default: SolvedNode(x: i));

            mut args: SolvedNode[];
            test(o, args);
            return args.len - args[args.len - 1].x - 1;
        }
    `);


    // Enum basics.

    // FAIL(`
    //     enum Test: i32 { A; B; C; };
    //     fn main() C.i32 - 2;
    //         //*F
    //         C - 2;
    //         /*/
    //         C.i32 - 2;
    //         //*/
    // `);

    // FAIL(`
    //     //*F
    //     /*/
    //     flags //*/
    //     enum Test: i32 { A; B; };
    //     fn main() (A | B).i32 - 3;
    // `);

    // ZERO(`
    //     enum Test: i32 { A = 1; };
    //     fn main() A.i32 - 1;
    // `);

    // ZERO(`
    //     enum Test { A = 1; B; };
    //     fn main() B.i32 - 2;
    // `);

    // ZERO(`
    //     enum Test { A; B = 2; C; };
    //     fn main() C.i32 - 3;
    // `);

    // ZERO(`
    //     enum Test { A; B = A; C; };
    //     fn main() C.i32 - 1;
    // `);

    // ZERO(`
    //     //*F
    //     /*/
    //     arithmetic //*/
    //     enum Test { A; B; };
    //     fn main() (B - A).i32 - 1;
    // `);

    // ZERO(`
    //     enum Thing {
    //         None;
    //         enum Animal { Cat; Dog; }
    //         enum Food { Apple; Orange; }
    //     };
    //
    //     fn main() Apple.i32 - Dog.i32 - 1;
    // `);

    // ZERO(`
    //     tuple enum TextureType: u32 {
    //
    //         enum Kind {
    //             None;
    //
    //             T_unorm; T_snorm;  T_uint; T_int;
    //             T_float; T_ufloat; T_srgb; T_depth;
    //         };
    //
    //         enum Size {
    //             None;
    //
    //             T_8x4; T_16x4; T_32x4;
    //             T_8x3; T_16x3; T_32x3;
    //             T_8x2; T_16x2; T_32x2;
    //             T_8x1; T_16x1; T_32x1;
    //
    //             T_10x3_2; T_11x2_10; T_24x1_8;
    //         };
    //
    //         flags enum Usage {
    //             T_nosample;
    //             T_nomips;
    //             T_fmin_nearest;
    //             T_fmag_nearest;
    //             T_clamp_u;
    //             T_clamp_v;
    //         };
    //     };
    //
    //     pub let T_d24_s8            = T_24x1_8 | T_depth;
    //     pub let T_DepthRenderBuffer = T_d24_s8 | T_nosample;
    //
    //     fn main()
    //         TODO;
    // `);

    ////////////////////////////////////////////////
    file::write(TESTDIFFS_FILE,
        testdiff::serialize(testdiffs));
    ////////////////////////////////////////////////
}
