import compiler;


// A quick self-test without I/O.

let TEST_SRC = `
    fn test(one: i32) {
        let zero = one - 1;
        let two  = one * 2;

        fn inner(i: i32): i32
            i > zero ? outer(i - one) : zero;

        fn outer(i: i32): i32
            two * inner(i);

        return outer(one) + (two - one) * 17;
    }

    fn main(): i32 {
        return test(1) - 17;
    }
`;

pub fn self_test(): i32
{
    let cpp = snippet2cpp(TEST_SRC);
    return cpp.find("int main()") ? 0 : 101;
}


// Run the whole battery & build self.

pub fn runTests()
{
    ZERO(`
        return 1 - 1;
    `);

    ZERO(`
        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);


    // Mutation & references.

    ZERO(`
        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;
    `);

    ZERO(`
        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        fn decr(ref num: i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    FAIL(`
        //*F
        let sum = 0;
        /*/
        mut sum = 0;
        //*/
        while (sum < 15)
            sum++; //ERR ++ overload

        return sum - 15;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);
    `);


    // Structs & using.

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;
    `);

    FAIL(`
        struct Range {
            min: i32;
            max: i32;
        }

        //*F
        let r =
        /*/
        mut r =
        //*/
        Range(1, 2);

        r.min++; //ERR ++ overload
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using r: Range)
            max - min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct X {
            a: i32;
        }

        fn test(using x: X, b: i32) a + b;
        fn hey(using x: X) test(-1);

        return X(1).hey;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);


    // Recursion, closures & implicit args.

    ZERO(`
        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);
    `);

    ZERO(`
        fn test(one: i32)
        {
            let zero = one - 1;
            let two  = one * 2;

            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;
    `);

    ZERO(`
        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;
    `);


    //

    ZERO(`
        let x = 1;

        fn test(): &i32
            x;

        return test - 1;
    `);

    ZERO(`
        let a = 1;
        let x: &i32 = a;

        return a - x;
    `);

    ZERO(`
        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;
    `);

    ZERO(`
        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;
    `);


    // Templating checks.

    ZERO(`
        let x = 3;
        return x / 2 - 1;
    `);

    // FAIL(`
    //     fn div3by(a: i32) 3 / a; //ERR overload
    //     return div3by(2) - 1;
    // )");

    ZERO(`
        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;
    `);

    // It's too early for this test,
    //  let's get everything else working first,
    //   not smart working on supersugar so early.
    //
    // ZERO(`
    //     fn div3by(a) 3 / a;
    //     return div3by(2) - 1;
    // )");

    ZERO(`
        fn add3(a: $T, b = 3) a + b;
        struct v1 { x: i32; };
        fn +(a: v1, b: i32) v1(a.x + b);
        fn main() add3(2.v1).x - 5;
    `);


    // Arrays.

    ZERO(`
        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];
    `);


    // A basic testing setup for array ops,
    //  that can be flipped around for making sure
    //   e.g. copy-on-write behaves as expected.

    fn ARROPS(
        literal: string,
        operation: string,
        mut assertion: string)
    {
        assertion = "(" ~ assertion ~ ")";

        fn EXPR(varname: string)
            assertion.replace(
                all: "@", with: varname);

        mut src: string;

        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr0 = [" ~ literal ~ "];";
        src ~= "\n        arr0." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr0") ~ " != 0) return 13;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    mut orig = [" ~ literal ~ "];";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr1 = CLONE(orig);";
        src ~= "\n        arr1." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr1") ~ " != 0) return 17;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr2 = STEAL(orig);";
        src ~= "\n        if (orig.len) return 19;";
        src ~= "\n        arr2." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr2") ~ " != 0) return 23;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    return 0;";
        src ~= "\n";

        ZERO(src);
    };

    ARROPS( "0,1,2,3,4",
            "push(5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "insert(5, 5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "pop()",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "splice(4, 1)",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "unshift(5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "insert(0, 5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "shift()",
            "@[0] + @[2] - @[3]");

    ARROPS( "0,1,2,3,4",
            "insert(1, 5)",
            "@[2] + @[5] - @[1]");

    ARROPS( "0,1,2,3,100",
            "splice(1, 3)",
            "@.len + @[0] + @[1] - 102");


    //

    ZERO(`
        let OPERATORS = [ "+", "-", "*", "/" ];

        fn main()
            OPERATORS[2] == "*" ? 0 : 1;
    `);

    ZERO(`
        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;
    `);

    ZERO(`
        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];
    `);


    // Strings.

    ZERO(`
        mut str = "hello ";
        str ~= "world";

        return str.len - 11;
    `);

    ZERO(`
        let str = "hello " ~ "world";

        return str.starts(with: "hel")
             ? str.len - 11
             : 171;
    `);

    ZERO(`
        let str = "a" ~ 1710010;

        return str == "a1710010"
             ? 0 : 101;
    `);

    ZERO(`
        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);
    `);

    ZERO(`
        return "hello world".find("world")
             - 2 * [1, 7, 13, 14, 19].find(14);
    `);

    ZERO(`
        return ("hello world".has("world") ? 1 : 0)
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;
    `);

    ZERO(`
        let hw = "hello world!";
        let a = hw.slice(6, 6 + 5);
        let b = hw.substr(6, 5);
        return a == b && a == "world" ? a.len - 5 : 1;
    `);

    ZERO(`
        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;
    `);


    // String opti checkers.

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
        {
            let a0 = ALLOC_STAT_COUNT();
            strA.slice(0, 26) == "0123456789abcdef0123456789" || throw("bad slice");

            let a1 = ALLOC_STAT_COUNT();
            a0 == a1 || throw("did alloc");

            return 0;
        }
    `);

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;
    `);


    // Maps.

    ZERO(`
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        return x["hello"] - x["world"] + 1;
    `);

    ZERO(`
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        let b = "hello world";
        mut offset = 0;

        fn pop(): string {
            mut a = "";

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a ~= c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;
    `);


    // Default arguments.

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test() - 3;
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(b: -1);
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(-2);
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.b;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey() Test();
        return hey.x;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey(y: i32 = 0)
            y   ? Test(1)
                : Test();

        return hey.x;
    `);


    // Truth tests.

    ZERO(`
        let s = 7;
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = 0;
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = "hello";
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = "";
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = [ 4 ];
        return s ? 0 : 1;
    `);

    ZERO(`
        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;
    `);


    // Loop labels.

    ZERO(`
        mut sum = 0;

        :outer for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :outer;
                if (x == 2) break    :outer;
            }
        }

        return sum - 34;
    `);


    // Comma operator.

    ZERO(`
        mut a = 0;
        return (a++, a - 1);
    `);


    // Lint.

    FAIL(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        //*F
        t.test; //ERR orphan
        /*/
        t.test();
        //*/

        return t.x - 1;
    `);


    // Logical selectors.

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;
    `);


    // Short-circuit assignment, esp. useful for maps
    //  and the cpp `map[k] = v`,
    //   which doesn't decompose safely.

    ZERO(`
        mut i = 7;
        i ||= 11;
        return i - 7;
    `);

    ZERO(`
        mut i = 0;
        i ||= 11;
        return i - 11;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m["hello"] = "world";
        fn f() (
            g++, "cruel world");

        m["hello"] ||= f();
        return g;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m["_not_hello_"] = "world";
        fn f() (
            g++, "cruel world");

        m["hello"] ||= f();
        return g - 1;
    `);


    // Lint checks.

    ZERO(`
        {
            {
                return 0;
            }
        }
    `);

    FAIL(`
        {
        //*F
        {
            return 0; //ERR block
        }
        /*/
            {
                return 0;
            }
        }
        //*/
    `);

    ZERO(`
        {
            return 0;
        }
    `);

    FAIL(`
        {
            return 0; //ERR block
        //*F
       }
        /*/
        }
        //*/
    `);

    FAIL(`
        {
            return 0; //ERR block
        //*F
         }
        /*/
        }
        //*/
    `);


    // Stuff that isn't working out quite right -
    //  Keep those around, there's no principle to these tests,
    //   they just stressed our stuff in weird ways.

    ZERO(`

    struct BINOP {
        P: Map(string, i32);
    };

    fn setupOperators(): BINOP
    {
        mut out: BINOP;

        fn binop(op: string)
            out.P[op] = 7;

        binop(",");

        return out;
    }

    shadow let BINOP = setupOperators();
    let P_COMMA = BINOP.P[","] || assert();

    fn main() P_COMMA - 7;

    `);

    ZERO(`

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;

    `);

    ZERO(`
        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags?:     i32;
            value?:     string;
            items?:     SolvedNode[];
            token:      Token;

            type:       Type;
            target?:    ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: "definit",
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;
    `);

    ZERO(`
        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);
    `);

    ZERO(`
        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;
    `);

    ZERO(`

        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;
    `);

    ZERO(`
        fn test(id: i32) id;
        return test(/*id*/0); // <- bad parse
    `);

    ZERO(`
        return 0b101.i32 - 5;
    `);

    ZERO(`
        return 0o101.i32 - 65;
    `);

    ZERO(`

        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == "..")
                    path.splice(--i, 2);
            }

            return path.join("/");
        }

        fn path_join(a: string, b: string)
            path_normalize(a ~ "/" ~ b);

        fn main()
            path_join("hello/hey", "./../you//") == "hello/you/"
                ? 0 : 1;
    `);


    // Let's move on to some cooler quality of life shit.

    ZERO(`
        let a = 7;
        let b = a && 3;
        return b - 3;
    `);

    ZERO(`
        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw("woot");
    `);

    ZERO(`

        struct TrueStory { kind: string; value: string; };

        mut specialized = TrueStory(kind: "fn", value: "val");

        specialized.kind == "fn" && specialized.value || throw("nope");

        let v: &mut string = specialized.kind == "fn"
                          && specialized.value
                          || throw("nope");
        v ~= "ue";

        return specialized.value == "value" ? 0 : 1;

    `);

    ZERO(`
        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };
    `);

    FAIL(`
        struct ScopeIdx { raw: i32; };
        //*F
        fn thing(x: i32) x;
        /*/
        fn thing(x: i32) ScopeIdx(x);
        //*/
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);
    `);


    // Various templating fallacies.
    //
    // TODO figure these out -
    //  These are problematic in a bunch of ways here.
    //   But mostly, the case patterns for this kind of thing are outright moronic.

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        fn main()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;
    `);

    ZERO(`
        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;
    `);

    ZERO(`
        struct mat4 { i: i32; };
        struct RenderFrame { u_mat4_VP: mat4; };

        inline fn mat4_identity() mat4(1);

        fn test(output: &mut RenderFrame) {
            output.u_mat4_VP = mat4_identity;
        }

        fn main() {
            mut ret: RenderFrame;
            test(ret);
            return ret.u_mat4_VP.i - 1;
        }
    `);

    FAIL(`
        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()
            //*F
            ScopeSkip(min: -1, max: +1)
            /*/
            ScopeSkip(start: -1, end: +1)
            //*/
                .end - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        struct mat34 {
            mx: vec3; my: vec3; mz: vec3;
            mo: vec3;
        };

        inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        // What broke is this using reports a conflict,
        //  because 'determinant' got expanded within 'inverse',
        //   and there's another using mat34 there.
        //    Basically we totally don't want it to expand there.
        inline fn determinant(using _: mat34): f32
            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z
            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;

        fn inverse(using mat: mat34): mat34
        {
            let idet = 1 / mat.determinant;

            let i_mx = vec3(
                idet * (- mz.y * my.z + my.y * mz.z),
                idet * (+ mz.y * mx.z - mx.y * mz.z),
                idet * (- my.y * mx.z + mx.y * my.z));

            let i_my = vec3(
                idet * (+ mz.x * my.z - my.x * mz.z),
                idet * (- mz.x * mx.z + mx.x * mz.z),
                idet * (+ my.x * mx.z - mx.x * my.z));

            let i_mz = vec3(
                idet * (- mz.x * my.y + my.x * mz.y),
                idet * (+ mz.x * mx.y - mx.x * mz.y),
                idet * (- my.x * mx.y + mx.x * my.y));

            return mat34(
                i_mx, i_my, i_mz,

                vec3( // point3
                      mo.x * -i_mx.x
                    + mo.y * -i_my.x
                    + mo.z * -i_mz.x,

                      mo.x * -i_mx.y
                    + mo.y * -i_my.y
                    + mo.z * -i_mz.y,

                      mo.x * -i_mx.z
                    + mo.y * -i_my.z
                    + mo.z * -i_mz.z));
        }

        fn main() i32 <|
            mat34_identity.inverse.determinant - 1;
    `);

    ZERO(`
        struct TEA
        {
            v0: u32;
            v1: u32;
        }

        inline fn r4(using _: &mut TEA, sum: &mut u32)
        {
            mut delta: u32 = 0x9e3779b9;

            for (mut i = 0; i < 4; i++) {
                sum += delta;

                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        // Stack overflow solving this,
        //  argmax is +inf, and it just
        //   re-enters and re-enters.
        inline fn r4(tea: &mut TEA) {
            mut sum: u32; tea.r4(sum);
        }

        fn main() {
            mut tea: TEA;
            tea.r4();
            return (tea.v0 ^ tea.v0).i32;
        }
    `);


    // Let's try something new.

    ZERO(`

        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);

            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

    `);

    ZERO(`
        return 0 > 1 ? throw("should type check") : 0;
    `);

    ZERO(`
        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            let x = throw_hey()
                catch err
                    return err.len - 3;

            return x || 7;
        }
    `);

    ZERO(`

        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }
    `);


    // Lifetimes & type inference.

    ZERO(`
        fn test() {
            mut x = 5;
            return x;
        }

        fn main()
            test() - 5;
    `);

    ZERO(`
        struct Test { i: i32; };

        fn test() {
            mut x = Test(5);
            return x;
        }

        fn main()
            test().i - 5;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; };

        fn test() {
            mut x = Test(5, -5);
            return x;
        }

        fn main()
            test().a + test().b;
    `);


    // Returning a mut arg.

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test) {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test): Test {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);


    // Usability of numeric literals.

    ZERO(`
        fn main()
            i32(PI * 2.0) - 6;
    `);

    ZERO(`
        fn main()
            i32(PI * 2 - 6);
    `);

    ZERO(`
        fn main()
            PI * 2 - 6 |> i32;
    `);

    ZERO(`
        fn main()
            i32 <| PI * 2 - 6;
    `);

    ZERO(`
        let x: f32 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: f32 = 1.0; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: u8 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x = 1.f32; fn main() 1 - x.i32;
    `);

    ZERO(`
        fn gt0(x: f32) x > 0;
        fn main() gt0(1.f32) ? 0 : 1;
    `);

    ZERO(`
        struct Hey { x: f32; };
        fn hey() Hey(1);
        fn main() hey.x.i32 - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);
        fn main() {
            let v = test(1);
            return (v.x + v.z).i32;
        }
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(f: f32) vec3(x: f, z: -1);
        fn main() {
            let v = test(-1);
            return (v.x - v.z).i32;
        }
    `);

    ZERO(`
        fn hey(i: f32) i.f32 + 0.5;
        fn main() hey(1).i32 - 1;
    `);

    ZERO(`
        fn lin2srgb(l: f32): f32
            l <= 0.0031308
                ? l * 12.92
                : 1.055 * pow(l, 1/2.4.f32) - 0.055;

        fn lin255(v: f32) u32 <|
            v.lin2srgb.max(0).min(1) * 255.99;

        fn main() i32 <|
            lin255(1) - 255;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        inline fn /(a: f32, b: vec3)
            vec3(a / b.x, a / b.y, a / b.z);

        fn main() i32 <|
            (1/vec3(x: 1)).x - 1;
    `);

    ZERO(`
        let QUAD_DATA: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
            -1, +1, 0,      0, 0, 1,    0, 1, 0,

            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
        ];

        fn main() QUAD_DATA.len - 6 * 9;
    `);

    ZERO(`
        fn test(a: bool): u8 = a ? 1 : 0;

        fn main() test(false).i32;
    `);

    ZERO(`
        fn test(a: bool): u8 = a && 1;

        fn main() test(false).i32;
    `);

    ZERO(`
        pub let A_u8: u8 = 0x0;

        fn ATTRIB(type: u8, count: i32, srgb = false): u8
            = type & 0x3 | count.u8 << 2

            // TODO can't deep-retype the last cast unfortunately:
            //  we need another hint to drive typing here,
            //   perhaps monogenous signatures, or else.
            | (srgb && 0x80.u8);

        fn main() ATTRIB(A_u8, 4).i32 - 16;
    `);

    ZERO(`
        pub struct Geometry    { g: i32; };
        pub struct Texture     { t: i32; };
        pub struct RenderFrame { r: i32; };

        pub struct LogicFrame_in
        {
            lastLogic:  LogicFrame;
        };

        pub struct LogicFrame
        {
            DATA_fbx:   Geometry;
            TEX_A:      Texture;
            TEX_AO:     Texture;
            TEX_M:      Texture;
            TEX_N:      Texture;
            TEX_R:      Texture;
            HDR:        Texture;
        };

        pub struct RenderFrame_in
        {
            w:          i16;
            h:          i16;
            frame:      i32;

            mouseX:     f32;
            mouseY:     f32;
            mouseBtns:  i32;

            using logic:    LogicFrame;
            lastRender:     RenderFrame;
        };

        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame
        {
            return RenderFrame(args.HDR.t);
        }

        fn main() 0;
    `);


    // Typedefs.

    ZERO(`
        type Test = i32[];
        fn yo(t: Test) t[0] + t[1];
        fn main() yo([-1, +1]);
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        fn hello(a: i32[]) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];
        fn hello(a: X) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];

        fn list(): i32[][] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];

        fn list(): X[] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);


    // Trivial equality.

    ZERO(`
        let a = [1, 2];
        fn eq(a: i32[], b: i32[]) a == b;
        fn main() eq(a, a) ? 0 : 1;
    `);

    ZERO(`
        let a = [1, 2];
        fn eq(a: $T[], b: $T[]) a == b;
        fn main() eq(a, a) ? 0 : 1;
    `);


    // Slices, pass one.

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main()
            test([-1, +1]);
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [-1, +1];
            return hey.test();
        }
    `);

    ZERO(`
        fn test(i: i32) [ i, i + 1 ];
        fn main() test(0)[1] - 1;
    `);

    ZERO(`
        fn test(hey: byte[])
            hey.view(u32)[0];

        fn main() {
            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];
            return (hey.test - 0x1010101).i32;
        }
    `);

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main() {
            let hey = [7, -1, +1];
            return test(hey[1, 3]);
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [7, -1, +1];
            return hey[1, 3].test();
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey.= [2, -3];

        fn main() {
            mut hey = [1, 0, 0];
            test(hey[1, 3]);
            return hey[0] + hey[1] + hey[2];
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(out: &mut [Hey]) {
            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];
        }

        fn main() {
            mut a = [ Hey ];
            a.test();
            return a[0].i - 16843009;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(x: &mut [i32], y: [ Hey ])
            x .= y.view(i32);

        fn main() {
            mut a = [ 0 ];
            test(a, [ Hey(13) ]);
            return a[0] - 13;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn main() {
            mut a = [ 0 ];
            a .= [ Hey(13) ].view(i32);
            return a[0] - 13;
        }
    `);

    ZERO(`
        fn test(a: [byte], b?: [byte]) a == b;
        fn main() test("") ? 0 : 1;
    `);


    // Don't repeat yourself ctors.

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a: Hey[] = [ [ -1 ], [ +1 ] ];
            return a[0].i + a[1].i;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn test(): Hey {
            return [ 0 ];
        }

        fn main() test.i;
    `);


    // Non-defaulted struct members.

    FAIL(`
        struct Test {
        //*F
            a: i32;
        /*/
            a?: i32;
        //*/
            b: i32;
        };

        return Test(b: 1).a;
    `);

    FAIL(`
        struct Test {
            b: i32;
        //*F
            a: i32;
        /*/
            a?: i32;
        //*/
        };

        return Test(1).a;
    `);


    // Explicit arguments & struct members.

    ZERO(`
        fn test(a: i32, b!: i32 = 1) a + b;
        return test(-1);
    `);

    FAIL(`
        fn test(a: i32, b!: i32 = 1) a + b;
        //*F
        return test(-2, +2);
        /*/
        return test(-2, b: +2);
        //*/
    `);

    FAIL(`
        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;
        //*F
        return Test(-2, +2).test;
        /*/
        return Test(-2, b: +2).test;
        //*/
    `);

    FAIL(`
        struct Test { a?: i32; b?!: i32; };
        fn test(t: Test) t.a + t.b;
        //*F
        return Test(-2, +2).test;
        /*/
        return Test(b: +2).test - 2;
        //*/
    `);

    ZERO(`
        let _precedence = 0;
        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;
        fn main() parseExpression();
    `);

    ZERO_SAME([
    `
        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x?!: i32) x;
        fn B(x?: i32) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x! = 0) x;
        fn B(x = 0) A(:x);
        fn main() A + B;
    `
    ]);


    // Intlit sizechecks.

    FAIL(`
        fn main() {
            let ret: i8 =
            //*F
            128
            /*/
            127
            //*/
            ;

            return (ret - 100).i32 - 27;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i16 =
            //*F
            32768
            /*/
            32767
            //*/
            ;

            return (ret - 32700).i32 - 67;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i32 =
            //*F
            2147483648
            /*/
            2147483647
            //*/
            ;

            return (ret - 2147483600).i32 - 47;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i64 =
            //*F
            9223372036854775808
            /*/
            9223372036854775807
            //*/
            ;

            return (ret - 9223372036854775800).i32 - 7;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i8 =
            //*F
            -129
            /*/
            -128
            //*/
            ;

            return (ret + 100).i32 + 28;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i16 =
            //*F
            -32769
            /*/
            -32768
            //*/
            ;

            return (ret + 32700).i32 + 68;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i32 =
            //*F
            -2147483649
            /*/
            -2147483648
            //*/
            ;

            return (ret + 2147483600).i32 + 48;
        }
    `);

    FAIL(`
        fn main() {
            let ret: i64 =
            //*F
            -9223372036854775809
            /*/
            -9223372036854775808
            //*/
            ;

            return (ret + 9223372036854775800).i32 + 8;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u8 =
            //*F
            256
            /*/
            255
            //*/
            ;

            return (ret - 0xff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u16 =
            //*F
            65536
            /*/
            65535
            //*/
            ;

            return (ret - 0xffff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u32 =
            //*F
            4294967296
            /*/
            4294967295
            //*/
            ;

            return (ret - 0xffffffff).i32;
        }
    `);

    FAIL(`
        fn main() {
            let ret: u64 =
            //*F
            18446744073709551616
            /*/
            18446744073709551615
            //*/
            ;

            return (ret - 0xffffffffffffffff).i32;
        }
    `);


    // Imports & pubs.

    FAIL([
    `
        //*F
        /*/
        pub
        //*/
        fn hello() 3;
    `,
    `
        import _0;
        fn main() 6 - hello * 2;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        fn main() 1._0::Hey.i - 1;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        import _0;
        pub inline fn test(h: Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        fn main() 1._0::Hey._1::test - 3;
    `
    ]);

    ZERO([
    `
        pub struct You { i: i32; };
    `,
    `
        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];
    `,
    `
        pub inline fn test(using h = _1::init3) i + 7;
    `,
    `
        fn main() _2::test - 10;
    `
    ]);

    ZERO([
    `
        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };
    `,
    `
        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);
    `,
    `
        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;
    `,
    `
        pub fn main()
        {
            let m34 = _1::mat34_identity;
            let m44 = _2::mat4(m34);

            return m44.determinant.i32 - 1;
        }
    `
    ]);

    ZERO(`
        import vec3;

        fn main() vec3.maxc.i32;
    `);

    ZERO(`
        fn main() ::vec3.maxc.i32;
    `);

    ZERO([
    `
        pub fn _0(i: i32) i + 1;
    `,
    `
        fn main() (-1).::_0;
    `
    ]);


    // Let's start having fun.

    ZERO(`
        let a =     1;
        let a = a + 1;
        return  a - 2;
    `);

    ZERO(`
        struct X { i: i32; };

        fn        ++(using x: &mut X) ++i;
        fn postfix++(using x: &mut X) i++;

        fn main() {
            mut x: X;
            let a = x++;
            let b = ++x;
            return a || b - 2;
        }
    `);

    FAIL(`
        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()
        //*F
            -1.0
        /*/
            (-1.0)
        //*/
                .abs;

        fn main() test ? 0 : 7;
    `);


    // Type assert.

    ZERO(`
        fn test() [] -> i32;
        fn main() test;
    `);


    // Conversions / ctors.

    ZERO(`
        type Test = i8;
        fn main() 256.Test.i32;
    `);

    FAIL(`
        fn test(a: $A, b: $B) b + //*F
            a;
            /*/
            $B(a);
            //*/
        fn main() i8(-1).test(+1);
    `);


    // First stab at higher-order functions.

    ZERO(`
        let x = { mut z = 0; z++; z };
        return x - 1;
    `);

    // ZERO(`
    //     fn reduce(items: $T[], fn: $F, init?: $T) {
    //         mut result = init;
    //         for (mut i = 0; i < items.len; i++)
    //             result = fn(result, items[i]);
    //
    //         return result;
    //     }
    //
    //     fn main() [1, 2].reduce(fn (a, b) a + b) - 3;
    // `);

    // ZERO(`
    //     fn map(items: $T[], fn: $F) {
    //         mut result: fn(items[0])[];
    //         for (mut i = 0; i < items.len; i++)
    //             result.push(fn(items));
    //
    //         return result;
    //     }
    //
    //     fn sqr(x) x*x;
    //
    //     fn main() [1].map(sqr)[0] - 3;
    // `);


    // Template structs.

    ZERO(`
        fn sA(t: $T) struct { hey: $T; };

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;
    `);

    FAIL(`
        fn sB(t: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey //*F
            ;
            /*/
            .i32;
            //*/
    `);

    // ZERO(`
    //     struct Hey(t: $T) { hey: $T; };
    //     fn test(a: $T) Hey(a + 2);
    //     fn main() 1.test.hey - 3;
    // `);

    // ZERO(`
    //     struct Hey(t: $T) { a: $T; b: $T; };
    //     fn test(a: $T) Hey(a, 2);
    //     fn main() {
    //         let r = (-2).test;
    //         return r.a - r.b;
    //     }
    // `);


    // Enum basics.

    // FAIL(`
    //     enum Test: i32 { A; B; C; };
    //     fn main() C.i32 - 2;
    //         //*F
    //         C - 2;
    //         /*/
    //         C.i32 - 2;
    //         //*/
    // `);

    // FAIL(`
    //     //*F
    //     /*/
    //     flags //*/
    //     enum Test: i32 { A; B; };
    //     fn main() (A | B).i32 - 3;
    // `);

    // ZERO(`
    //     enum Test: i32 { A = 1; };
    //     fn main() A.i32 - 1;
    // `);

    // ZERO(`
    //     enum Test { A = 1; B; };
    //     fn main() B.i32 - 2;
    // `);

    // ZERO(`
    //     enum Test { A; B = 2; C; };
    //     fn main() C.i32 - 3;
    // `);

    // ZERO(`
    //     enum Test { A; B = A; C; };
    //     fn main() C.i32 - 1;
    // `);

    // ZERO(`
    //     //*F
    //     /*/
    //     arithmetic //*/
    //     enum Test { A; B; };
    //     fn main() (B - A).i32 - 1;
    // `);

    // ZERO(`
    //     enum Thing {
    //         None;
    //         enum Animal { Cat; Dog; }
    //         enum Food { Apple; Orange; }
    //     };
    //
    //     fn main() Apple.i32 - Dog.i32 - 1;
    // `);

    // ZERO(`
    //     tuple enum TextureType: u32 {
    //
    //         enum Kind {
    //             None;
    //
    //             T_unorm; T_snorm;  T_uint; T_int;
    //             T_float; T_ufloat; T_srgb; T_depth;
    //         };
    //
    //         enum Size {
    //             None;
    //
    //             T_8x4; T_16x4; T_32x4;
    //             T_8x3; T_16x3; T_32x3;
    //             T_8x2; T_16x2; T_32x2;
    //             T_8x1; T_16x1; T_32x1;
    //
    //             T_10x3_2; T_11x2_10; T_24x1_8;
    //         };
    //
    //         flags enum Usage {
    //             T_nosample;
    //             T_nomips;
    //             T_fmin_nearest;
    //             T_fmag_nearest;
    //             T_clamp_u;
    //             T_clamp_v;
    //         };
    //     };
    //
    //     pub let T_d24_s8            = T_24x1_8 | T_depth;
    //     pub let T_DepthRenderBuffer = T_d24_s8 | T_nosample;
    //
    //     fn main()
    //         TODO;
    // `);


    // We have to deduce the rh-types from the assignment calls.
    //
    // ZERO(`
    //     struct ScopeSkip {
    //         min: i32;
    //         max: i32;
    //     };
    //
    //     fn main() {
    //         let a = 1;
    //         mut x: ScopeSkip; x = [ -2, 0 ];
    //         mut t: ScopeSkip; t = x.min && [ x.min, a ];
    //         return a + t.min + t.max;
    //     }
    // `);


    // A mutref fail.

    // ZERO(`
    //     struct Arg { i: i32; };

    //     fn mutargs(args: &mut Arg[])
    //     {
    //         // This miscompiles to ref into args,
    //         //  after which we invalidate the reference.
    //         //
    //         // Notice the "let" would bind cleanly,
    //         //  if it weren't for the "&&", which loses the mutrefsness.
    //         //
    //         let arg_t = args.len && args[0];
    //         args = [ Arg(11) ];
    //         return arg_t.i;
    //     }

    //     fn main()
    //     {
    //         mut args = [ Arg(7) ];
    //         return mutargs(args) - 7;
    //     }
    // `);
}
