import compiler;
import test_utils;


// Run the whole battery & build self.

pub extern fn runTests()
{
    ////////////////////////////////////////////////
    let TESTDIFFS_FILE = FUDIR ~ "testdiff/now.td";
    let implicit mut testdiffs = testdiff::TestDiffs;
    defer:ok file::write(
        TESTDIFFS_FILE, testdiff::serialize(testdiffs));
    ////////////////////////////////////////////////


    // Solo mode, so you can mute all tests
    //  but what you want to work on -

    /*
    let SOLO            = fn ZERO;

    lax fn SOLO_muteRest (lax a, lax currently?: string, lax options?: options::Options) {}
    let ZERO            = fn SOLO_muteRest;
    let TODO            = fn SOLO_muteRest;
    let ZERO_SAME       = fn SOLO_muteRest;

    defer:ok throw("\n\n\tDONT COMMIT:\n\n\tSOLO mode is on.\n");
    // */


    // Parallel mode,
    //  comment it out to set breakpoints & such.

    //*
    mut PARZERO_queue: string[][];

    fn PARZERO(src: string[])
        PARZERO_queue ~= src;

    fn PARZERO(src: string)
        PARZERO_queue ~= [ src ];

    defer:ok
    {
        struct TestResult
        {
            error:      string;
            testdiffs:  testdiff::TestDiffs;
        };

        let results = PARZERO_queue.par::map(|lax test|
        {
            mut error: string;
            let implicit shadow mut testdiffs: testdiff::TestDiffs;

            lax let options = options::Options(dev: "DEV_Parallel");

            try
                ZERO(test, :options);
            catch (e)
                error = e;

            continue TestResult(:error, :testdiffs);
        });

        mut error: string;
        for (mut i = 0; i < results.len; i++)
        {
            let result = results[i];
            if (result.error)
                error ~= result.error ~ "\n";
            else
                testdiffs.append(result.testdiffs);
        }

        if (error)
            throw(error);
    }

    shadow let ZERO = fn PARZERO;
    /*/

    println("\n\n\tDONT COMMIT:\n\n\tPARZERO mode is off.\n");
    // */


    // Categorizing what doesn't work and why -

    let TODO_recursion  = fn TODO;
    let TODO_enums      = fn TODO;
    let TODO_structs    = fn TODO;
    let TODO_borrowck   = fn TODO;
    let TODO_disjoint   = fn TODO;
    let TODO_semantics  = fn TODO;
    let TODO_move       = fn TODO;
    let TODO_unique     = fn TODO;
    let TODO_inline     = fn TODO;
    let TODO_varargs    = fn TODO;
    let TODO_args       = fn TODO;
    let TODO_conv       = fn TODO;
    let TODO_relaxer    = fn TODO;
    let TODO_ambig      = fn TODO;
    let TODO_licm       = fn TODO;
    let TODO_slices     = fn TODO;
    let TODO_cow        = fn TODO;
    let TODO_mangle     = fn TODO;
    let TODO_specpat    = fn TODO;
    let TODO_control    = fn TODO;
    let TODO_prelude    = fn TODO;
    let TODO_definit    = fn TODO;
    let TODO_ooe        = fn TODO;
    let TODO_pub        = fn TODO;
    let TODO_zst        = fn TODO;
    let TODO_StaticEval = fn TODO;

    let LEGACY_Map      = fn TODO;

    let SKETCH          = fn TODO;


    //

    ZERO(`
        <fail return>
        fn main(): i32 {}               <pass/>
        fn main(): i32 { return 0; }    </fail>
    `);

    ZERO(`
        <fail return>
        fn test(): i32 {}               <pass/>
        fn test(): i32 { return 0; }    </fail>
        fn main() test();
    `);

    ZERO(`
        return 1 - 1;
    `);

    ZERO(`
        return <fail COMPILER BUG or INCORRECT TESTCASE exit code 3>
                        3 <pass/>
                        0 </fail>
    `);

    ZERO(`
        return 0
        <fail COMPILER BUG or INCORRECT TESTCASE exit code>
            || throw("TESTERR")
                 <pass/></fail>
    `);

    ZERO(`
        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn main() {
            let  i = -1;
            let sb = i.i8;
            let  b = i.u8;

            return sb == -1 && b == 255 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let sb = (-1).i8;
            let  i =  sb.i32;
            let  u =  sb.u32;

            return i == -1 && u.i32 == 255 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let b = byte(200);
            let i = b.i32;
            return i == 200 ? 0 : 1;
        }
    `);


    // Mutation & references.

    ZERO(`
        mut arr = [ 0 ];
        return arr[0];
    `);

    ZERO(`
        let a = 3;
        mut b = a;
        b++;
        return b - (a + 1);
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;
    `);

    ZERO(`
        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        fn decr(ref num: i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    ZERO(`
        <fail ++>
        let sum = 0;        <pass/>
        mut sum = 0;        </fail>
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;
    `);

    ZERO(`
        mut i = 5;
        mut sum = 0;
        while (let x = i--) sum += x - i;
        return sum - 5;
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);
    `);

    ZERO(`
        fn ret_only_arg(a) a;
        <split/>
        fn main() 0.ret_only_arg;
    `);


    // Structs & using.

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        <fail ++>
        let r =             <pass/>
        mut r =             </fail>
            Range(1, 2);

        r.min++;
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            r_min: i32;
            r_max: i32;
        }

        fn size(using r: Range)
            r_max - r_min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct X {
            a: i32;
        }

        fn test(using x: X, b: i32) a + b;
        fn hey(using x: X) test(-1);

        return X(1).hey;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);

    ZERO(`
        struct A { x: i32; y: i32; };
        struct B { x: i32; z: i32; };
        fn test(using left: A, using right: B)
            <fail ambig x 2:20+1 using left 4:17+5 3:20+1 using right 4:32+5>
            x + z; <pass/>
            y + z; </fail>

        fn main() test(A(1, 1), B(-1, -1));
    `);

    ZERO(`
        struct CurrentFn {
            parent_idx: i32;
            using RoR?: CurrentFn_ResetOnResolve; // not yet populated
        };

        struct CurrentFn_ResetOnResolve {
            ret_count: i32;
        };

        fn test(f: CurrentFn) f.parent_idx - f.ret_count;
        fn main() test(CurrentFn(1, CurrentFn_ResetOnResolve(1)));
    `);

    ZERO(`
        struct HasPredicate {
            true kind   : string;
            items       : i32;
        };

        fn main() {
            let isTrue  = HasPredicate("let", 0);
            let isFalse = HasPredicate("",    1);
            return isTrue && !isFalse ? 0 : 1;
        }
    `);

    ZERO(`
        struct Stuff { name: string };

        fn shadowsStructMember(using stuff: Stuff, other: string) {
            shadow let name = other || name;
            return name;
        }

        fn main() = shadowsStructMember(Stuff("a"), "bb").len - 2;
    `);

    ZERO(`
        fn call_with_using_and_explicit_arg(x: i32, y: i32) = x + 7*y;
        fn main () {
            using let y = 1;
            return call_with_using_and_explicit_arg(x: 2) - 9;
        }
    `);

    ZERO(`
        fn call_with_using_explicit_and_trailing(x: i32, y: i32, m: i32) = (x + 7*y) * m;
        fn main () {
            using let x = 1;
            return call_with_using_explicit_and_trailing(y: 2, 3) - 45;
        }
    `);

    ZERO(`
        <fail items not trivial>
        trivial<pass/></fail>
        struct Node { items: Node[]; };

        fn main() {
            mut n: Node;
            return n.items.len;
        }
    `);

    ZERO(`
        struct Other { using w: Node };

        struct Node {
            <fail self recursive (Node|Other) (2:30+1|6:13+1)>
            v: Node;           <fail/>
            v: Other;          <pass/>
            v: i32;            </fail>
        };

        fn main() {
            mut node: Node;
            return node.v ? 1 : 0;
        }
    `);

    ZERO(`
        fn sqr(implicit ref b: i32) {
            return b *= b;
        }
        <split/>
        fn main() {
            struct Hey {
                implicit a: i32;
                implicit b: i32;
            };

            using mut hey = Hey(10, 20);
            sqr();
            return hey.a == 10 && hey.b == 400 ? 0 : 1;
        }
    `);

    // /using


    // Type annotations.

    ZERO(`
        fn test(x: i32) {
            <fail annotation not a type 4:20+1>
            mut y: x;                   <pass/>
            mut y = x;                  </fail>
            y += x;
            return y;
        }

        fn main() test(2) - 4;
    `);

    ZERO(`
        struct Hey { v: i32 }

        fn test(x: Hey) {
            <fail annotation not a type 6:23+1>
            mut y: Hey(1);              <pass/>
            mut y = Hey(1);             </fail>
            y.v += x.v;
            return y;
        }

        fn main() test(Hey(2)).v - 3;
    `);

    // /Type Annotations


    // Template args.

    ZERO(`
        let x = 3;
        return x / 2 - 1;
    `);

    ZERO(`
        fn hey(a) a * a;
        fn main = 0.hey;
    `);

    ZERO(`
        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;
    `);

    ZERO(`
        fn div3by(a) 3 / a;
        return div3by(2) - 1;
    `);

    ZERO(`
        fn add3(a: i32, b = 3) a + b;
        fn main() add3(-3);
    `);

    ZERO(`
        fn add3(a: $T, b = 3) a + b;
        struct v1 { x: i32; };
        fn +(a: v1, b: i32) v1(a.x + b);
        fn main() add3(2.v1).x - 5;
    `);

    ZERO(`
        fn mul_ab_init(a: $T, b = 0) a*b;
        fn main() mul_ab_init(1);
    `);

    ZERO(`
        fn mul_ab_annot_init(a: $T, b: $T = 0) a*b;
        fn main() mul_ab_annot_init(1);
    `);

    ZERO(`
        fn mul_ab_opt(a: $T, b?: $T) a*b;
        fn main() mul_ab_opt(1);
    `);

    ZERO(`
        fn ab(a, b) a + b*2;
        fn main() ab(b: 1, a: -2);
    `);

    ZERO(`
        struct yi32 { y: i32; };
        fn add_s_vy(v, s) s + v.y;
        fn main() add_s_vy(v: yi32(1), -1);
    `);

    ZERO(`
        struct xi32 { x: i32; };
        fn add_s_vx(s, v) s + v.x; // <- args reordered
        fn main() add_s_vx(v: xi32(1), -1);
    `);

    ZERO(`
        fn ab(a, b = 0, c = 0) a + b*2 + c*3;
        fn main() ab(3, c: -1);
    `);

    ZERO(`
        fn ab(a, b = -1) a + b*2;
        fn main() ab(3.0, -1.5).i32;
    `);

    ZERO(`
        let NEG_ONE_FIVE = -1.5;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(3, NEG_ONE_FIVE).i32;
    `);

    ZERO(`
        let TWO = 2.0;
        fn ab(a: $T, b: $T = -1) a + b*2;
        fn main() ab(TWO).i32;
    `);

    ZERO(`
        fn self_rec_template(x: $T): $T
            x > 0 ? self_rec_template(x / 2 - 5) : x;

        fn main()
            self_rec_template(7) + 2;
    `);

    ZERO(`
        fn ab_rec(a: $T): $T = a ? ba_rec(a - 2) : -100;
        fn ba_rec(a: $T): $T = a ? ab_rec(a - 7) : -200;
        fn main() ab_rec(11) + 200;
    `);

    ZERO(`
        fn main() {
            let a = 1;
            fn add1(b) a + b;
            return 2.add1 - 3;
        }
    `);

    ZERO(`
        pub fn MAP(a: [$T], fn) {               ;; !N_DeadCode
            mut res: typeof( fn($T) )[];
            res.grow_junk(a.len);
            for (mut i = 0; i < a.len; i++) res[i] = fn(a[i]);
            return res;
        }

        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> [$U]) a.MAP(fn clone);
        default {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }

        pub nocopy struct Scope { x: i32; };
        pub struct ModuleOutputs { deps: Scope[]; };

        pub fn test(a: ModuleOutputs) {
            let b = a.clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);
    `);

    ZERO(`
        struct X { a: i32; };
        inline fn add_uxa_b_inline(using x: X, b: i32) a + b;
        fn hey(using x: X) add_uxa_b_inline(-1);
        return X(1).hey;
    `);

    ZERO(`
        struct X { a: i32; };
        fn add_uxa_b_template(using x: X, b /* untyped */) a + b;
        fn hey(using x: X) add_uxa_b_template(-1);
        return X(1).hey;
    `);

    ZERO(`
        fn incr(a) a++;
        fn main() {
            mut a = 1;
            incr: || a;
            return a - 2;
        }
    `);

    ZERO(`
        inline fn inl_lies(x: u32)<fail actual return match annot>: i32<pass/></fail> = x;
        fn main() 0.inl_lies ? 1 : 0;                           ;; PointlessLocal
    `);

    ZERO(`
        fn what(ref x: i32, ref y: i32) {
            <fail bad call swap>
            let z = y;   <pass/>
            ref z = y;   </fail>
            swap(x, z);  // swap is defined(ref x: $T, ref y: $T),
        }                //  we ignore the 'ref' part in type patterns,
                         //   so we only notice later when checking the spec
        fn main() {
            mut a = 1; mut b = 0; what(a, b);
            return a;
        }
    `);

    ZERO(`
        fn any(a, b) a || b;
        fn main() any(0, []);
    `);

    ZERO(`
        fn both(a, b) a && b;
        fn main() both(1, []);
    `);

    ZERO(`
        fn either(a, b) a ? a : b;
        fn main() either(0, []);
    `);

    ZERO(`
        fn both_same_type(_<fail $T is not defined><pass/>: $T</fail>, y) =
            typeof(y) -> $T;

        fn main()   = both_same_type(1.u32, 1.i32) ? 1
                    : both_same_type(1.i32, 1.i32) ? 0
                    : 2;
    `);

    ZERO(`
        fn arrof !T(lax _: T[], type U)
            case (T -> U)   true;
            default         false;

        fn main() {
            mut a: i32[];
            return arrof(a, i32) && !arrof(a, u32) ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            mut x: i32 = 0;
            return (typeof(x) -> &mut i32).i32 - 1;
        }
    `);

    ZERO(`
        fn work(visit) visit(1, 2);
        fn main() work: |_, _| return 0;
    `);

    ZERO(`
        fn each(ref moot: u32) moot++;

        fn Lifetime_process(lt: string, each) {
            for (mut i = 0; i < lt.len; i++) {
                fn climb(mut parent: string) // .... ///// what happened is this recursively picked up fn each from prelude
                    Lifetime_process(parent, fn each); ///  on each nested iteration, which grew the addrofn type,
                                             // ^^^^ /////   resulting in a new mangle on each go.
                each(climb: fn climb, lt.slice(i, lt.len));
            }
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= " " ~ lt;
                if (let init = lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == " abc ab a b bc b c" ? 0 : 1;
        }
    `);

    ZERO(`
        using flags Flags { F_SOME; F_OTHER };

        fn parseInlineDecl(mut flags, flag = F_OTHER) {
            flags |= flag;
            return flags;
        }

        fn parseNoInline(mut flags) {
            return parseInlineDecl(:flags, flag: []);
        }

        fn main() = parseInlineDecl(F_SOME).i32
                  - parseNoInline(F_SOME).i32 * 3;
    `);

    ZERO([`
        struct Range { lo_incl: int; hi_excl: int };

        fn each(using _: Range, each)
            for (mut i = lo_incl; i < hi_excl; i++)
                each(i);
    `,`
        fn main() {
            mut sum = 0;
            _0::Range(0, 10).each: |i| sum += i;
            return sum - 45 ;
        }
    `]);

    // /Template args


    // Lexical vs dynamically scoped templates -
    //  I guess we want both, but how?
    //   Should we just make it explicit?

    ZERO([
    `
        pub fn identity(dont_leak_me) dont_leak_me;
    `,
    `
        let dont_leak_me = 1;
        fn main() _0::identity(dont_leak_me * 2) - 2;
    `
    ]);

    ZERO(`
        pub inline fn inl_id_leak(dont_leak_me) dont_leak_me;
        let dont_leak_me = 1;
        fn main() inl_id_leak(dont_leak_me * 2) - 2;            ;; PointlessLocal
    `);

    ZERO(`
        let static = 1;
        fn template(arg) static + arg;
        let arg = 7;                        // <- template shouldn't see this
        let result = template(arg / -4);    // <- when specializing here
        fn main() result;
    `);

    ZERO(`
        fn main() {
            let static = 1;
            fn template(arg) static + arg;
            let arg = 7; // same here, except we're in a fn.
            return template(arg / -4);
        }
    `);

    ZERO([`
        fn template_add(a, b) a + b;
    `,`
        struct HasInt { i: i32 };
        <split/>
        fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i);
        fn main() _0::template_add(HasInt(1), HasInt(2)).i - 3;
    `]);

    TODO_ambig(currently: "Bad call to + 2:33+1", [`
        fn template_add(a, b) a + b;
    `,`
        struct HasInt { i: i32 };
        fn main() {
            infix fn +(a: HasInt, b: HasInt) HasInt(a.i + b.i); // its hard to defend this -
            _0::template_add(HasInt(1), HasInt(2)).i - 3;       //  the thing above works but this doesn't.
        }                                                       //   given the autoshadowing, we might just want to allow everything.
    `]);


    // Recursion, closures & implicit args.

    ZERO(`
        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);
    `);

    ZERO(`
        fn test(one: i32) {
            let zero = one - 1;
            let two  = one * 2;

            <alt>
            inline </alt>
            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn main() test(1) - 17;
    `);

    ZERO(`
        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn inner_noret(i: i32)
            outer_noret(i - 1);

        fn outer_noret(implicit x: i32, i: i32)
            i > 0   ? inner_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_noret(1) - 7;
    `);

    ZERO(`
        inline fn inner_inl(i: i32): i32
            outer_inl(i - 1);

        fn outer_inl(implicit x: i32, i: i32): i32
            i > 0   ? inner_inl(i)
                    : x + i;

        let implicit x = 7;
        return outer_inl(1) - 7;
    `);

    ZERO(`
        fn inner_templ(i): i32
            outer_templ(i - 1);

        fn outer_templ(implicit x: i32, i): i32
            i > 0   ? inner_templ(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ(1) - 7;
    `);

    ZERO(`
        fn inner_templ_noret(i)
            outer_templ_noret(i - 1);

        fn outer_templ_noret(implicit x: i32, i)
            i > 0   ? inner_templ_noret(i)
                    : x + i;

        let implicit x = 7;
        return outer_templ_noret(1) - 7;
    `);

    ZERO(`
        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);
    `);

    ZERO(`
        fn has_implicit(implicit i: i32, add: i32): i32
            i + add;

        inline fn injects_implicit_while_inlined(): i32
            has_implicit(1); // broken by no ss.declash

        fn main() {
            let implicit i = 2;
            return injects_implicit_while_inlined() - 3;
        }
    `);

    ZERO(`
        inline fn outer_inl(i: i32): i32
            i > 0   ? inner_inl(i)
                    : 2 * i;

        fn inner_inl(implicit x: i32, i: i32): i32
            outer_inl(i - 2 * x); // broken by no ss.declash

        let implicit x = 3;
        return outer_inl(6);
    `);

    ZERO(`
        fn outer_templ(i): i32
            i > 0   ? inner_templ(i)
                    : 2 * i;

        fn inner_templ(implicit x: i32, i): i32
            outer_templ(i - 2 * x);

        let implicit x = 3;
        return outer_templ(6);
    `);

    ZERO(`
        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        fn inner(i: i32): i32
            outer(i - 1);

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn outer(implicit x: i32, i: i32)
            i > 0   ? inner(i)
                    : x + i;

        fn noret(i: i32) = outer(i);

        fn template(i) = i & 1 ? outer(i) : noret(i);

        fn inner(i: i32): i32
            template(i - 1);

        fn main() {
            let implicit x = 7;
            return outer(1) - 7;
        }
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_1(call_self = false): i32
            = !call_self ? returns_x : calls_self_1 * 2;

        let implicit x = 7;
        return calls_self_1(true) - 14;
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_2(call_self = false): i32
            = call_self ? calls_self_2 * 3 : returns_x;

        let implicit x = 7;
        return calls_self_2(true) - 21;
    `);

    ZERO(`
        fn returns_x(implicit x: i32): i32
            = x;

        fn calls_self_3(call_self = false): i32
        {
            let add = 1; // <- this wasnt visible
            fn do_call_self(mul: i32 = 0)
                = calls_self_3 * mul + add;

            return call_self ? do_call_self(4) : returns_x;
        }

        let implicit x = 7;
        return calls_self_3(true) - 29;
    `);

    ZERO(`
        fn noret_x(implicit x: i32) x;

        fn templ_calls_self_2(call_self): i32
            = call_self ? templ_calls_self_2(false) * 3 : noret_x;

        fn main() {
            let implicit x = 7;
            return templ_calls_self_2(true) - 21;
        }
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;
    `);

    ZERO(`
        fn main() {
            let a = 1;
            let b = 2;
            let c = 3;

            fn depth1(x: i32) {
                fn depth2(y: i32) {
                    return sibling1(x + y + b);
                }

                return depth2(x + a);
            }

            fn sibling1(z: i32): i32 {
                return z + c;
            }

            return depth1(0) - 6;
        }
    `);

    ZERO(`
        fn goto0(x): i32 = x ? goto0(x / 2) : 0;
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x ? goto0(x / 2) : 0;
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x ? goto0(x / 2) : x; // ideally same as above
        fn main() goto0(1);
    `);

    ZERO(`
        fn goto0(x) x && goto0(x / 2); // ideally same as above [again]
        fn main() goto0(1);
    `);

    ZERO(`
        fn ref_a(ref a: i32) a;

        fn main() {
            mut a: i32;
            ref r = ref_a(a);
            r++;
            return a - 1;
        }
    `);

    ZERO(`
        fn ref_a_or_ref_b(ref a: i32, ref b: i32)
            a || b;

        fn main() {
            mut a: i32;
            mut b: i32;
            ref a_or_b = ref_a_or_ref_b(a, b);
            a_or_b++;
            return b - 1;
        }
    `);

    ZERO(`
        fn impl(implicit ref _impl: i32) _impl;
        fn arg_or_impl(ref arg: i32) arg || impl;
        fn main() {
            implicit mut _impl: i32;
            mut arg: i32;
            ref ref = arg_or_impl(arg);
            return arg - ref;
        }
    `);

    ZERO(`
        fn hello(ref a: i32[], ref b: i32[], x: i32): &mut i32[] {
            if (x == 0) return a;
            if (x == 1) return b;
            return hello(b, a, x / 17);
        }

        fn main() {
            mut a = [1, 2, 3];
            mut b = [4, 5, 6];
            hello(a, b, 397)[1] *= 5;
            return b[1] - 25;
        }
    `);

    ZERO(`
        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                ZERO( --x ); // Same as below but without the unused 'y' thing,
                sum += x;    //  everything works because the call to ZERO isnt really unconditional,
            }                //   and if it were, then the never return would actually be correct.
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 11;
        }
    `);

    ZERO(`
        pub fn ZERO(implicit ref sum: i32, mut x: i32) {
            while (x) {
                let y = x / 2;
                ZERO( --x ); // Unconditional self recursion, initially hinted as t_never,
                ZERO(   y ); //  meaning y remains unused here on first solve.
                sum += x;
            }
        }

        fn main() {
            implicit mut sum = 0;
            ZERO(4);
            return sum - 12;
        }
    `);

    ZERO(`
        struct Node {
            items: Node[];
        }

        fn solve(root: Node)
        {
            fn solveBlock(node: Node) {
                let items = solveNodes(node.items);
                return solveBlock(items);                       ;; ConstCast
            }

            fn solveBlock(items: i32[]) {
                if (!Lifetime_allowsMutrefReturn(items))
                    throw("Nope!");

                return items;
            }

            fn solveNode(node: Node, implicit ref next: i32) {
                if (!node.items)
                    return [ next++ ];

                let implicit CTX = node.items.len; // <- this shows up as an closure-arg with an outdated revision
                return solveBlock(node);
            }

            fn Lifetime_each(items, visit)
                for (mut i = items.len; i --> 0; )
                    visit(items[i]);

            fn Lifetime_allowsMutrefReturn(items: i32[]) {
                Lifetime_each(:items, visit: |item, implicit CTX: i32| {
                    if (item == CTX)
                        return false;
                });

                return true;
            }

            fn solveNodes(nodes: Node[]) {
                mut result: i32[];
                for (mut i = 0; i < nodes.len; i++)
                    result ~= solveNode(nodes[i]);

                return result;
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut next = 0;

            let solve = solve(Node([
                Node([ Node ]),
                Node(),
            ]));

            return solve.len - 2;
        }
    `);

    ZERO(`
        fn woot(implicit x: i32) = x;

        fn main() {
            <fail no implicit x>
            <pass/>
            let implicit x = 2;
            </fail>
            return woot() - 2;
        }
    `);

    ZERO(`
        <fail no implicit y>
        fn woot(implicit y: i32) = y;
        <pass/>
        fn woot(implicit x: i32) = x;
        </fail>

        fn hey() {
            let implicit x = 2;
            return woot() - 2;
        }

        let here = hey();
        fn main() = here;
    `);

    ZERO(`
        fn main() {
            mut x = +1;
            mut y: typeof(x) = -x;
            return x + y;
        }
    `);

    ZERO(`
        ;; N_UnusedImplicit
        fn dont_inject_my_implicit_args(implicit unused_implicit_arg: i32) {
            return unused_implicit_arg;
        }

        fn not_extern() {
            mut x: typeof(dont_inject_my_implicit_args) = 2;
            return x;
        }

        fn not_extern(mut x: typeof(dont_inject_my_implicit_args)) {
            return x;
        }

        fn main() {
            return not_extern() + not_extern(-2);
        }
    `);

    ZERO(`
        fn mustwarn_unused_implicit(implicit forgot_to_use: i32, ref x: i32) {
            <fail unused forgot_to_use>
            x *= 3;             <pass/>
            x *= forgot_to_use; </fail>
        }

        fn main() {
            mut x = 7;
            implicit forgot_to_use = 3;
            mustwarn_unused_implicit(x);
            return x == forgot_to_use * 7 ? 0 : 1;
        }
    `);

    ZERO(`
        fn log_append(implicit ref log_out: string, str: string)
            log_out ~= str;

        let VERBOSE = false;

        fn verbose(implicit ref log_events: i32, inline stuff: string)
        {
            if (VERBOSE) log_append(stuff);
            log_events++;
        }

        fn main() {
            <fail unused log_out 15:30+7>
            implicit     mut log_out: string; <pass/>
            implicit lax mut log_out: string; </fail>

            implicit mut log_events: i32;
            verbose("Hello!");
            verbose("World!");

            return log_events == 2 ? 0 : 1;
        }
    `);

    TODO_recursion(currently: "BUG exit code", `

        // TODO remove this, currently gets repeatedly
        //  rebuilt & rejected because of -Werror
        pragma emit(\`#pragma GCC diagnostic ignored "-Wpragmas"\`);
        pragma emit(\`#pragma GCC diagnostic ignored "-Winfinite-recursion"\`);

        fn infRec(x: i32) {
            if (x > 1)
                return infRec(x - 1);
            else                        <fail infinite recur X:X>
                return infRec(x + 1);   <pass/>
                return x;               </fail>
        }

        fn main() infRec(1);
    `);

    ZERO([`
        struct NeverImported { x: i32 };
        fn wrap(x: i32) NeverImported(x * 10);
    `,
    `
        fn rec(y: i32)
            if (y < 0)  return _0::wrap(rec(y + 7).x);
            else        return _0::wrap(y);

        fn main() rec(-2).x - 500;
    `])

    ZERO([`
        fn wantsImplicit(implicit ref x: i32) = x++;
    `,`
        fn main() {
            <fail no implicit x 4:37+1 2:39+1>  <pass/>
            implicit mut x: i32 = 0;            </fail>
            return _0::wantsImplicit();
        }
    `]);

    ZERO([`
        struct TokenIdx { id: i32 };
    `,`
        import _0;
        fn fail(implicit a: TokenIdx, b: i32) =
            a.id + b;
    `,`
        import _1;
        fn cleanID(c: i32) =
            fail(c) + 3;
    `,`
        import _0;
        import _2;
        fn solvePrelude(d: i32) {
            <fail no implicit in scope 10:25+1 6:27+1 4:17+1 3:26+1><pass/>
            let implicit a: TokenIdx = TokenIdx(2);                 </fail>
            return cleanID(d) + 5;
        }

        let CTX_PRELUDE =
            solvePrelude(7);

        fn main() =
            CTX_PRELUDE - 17;
    `]);

    ZERO(`
        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {                   <alt>
                    inline fn climb(mut parent)           visit(parent);<alt/>
                    noinline fn climb(mut parent)         visit(parent);<alt/>
                    inline fn climb(mut parent: string)   visit(parent);<alt/>
                    noinline fn climb(mut parent: string) visit(parent);<alt/>
                    let climb = fn visit;                               </alt>

                    each(climb?: fn climb, chars.slice(i, chars.len))
                }
            }

            visit(lt);
        }

        fn main() {
            mut result = "";
            Lifetime_process("abc", each: |lt, climb| {
                result ~= lt;
                if (let init = lt && lt.slice(0, lt.len - 1))
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Helper { id: i32; type: string };

        fn main() {
            mut helpers = [
                Helper(13, "This is a long string, shouldn't fit in small string opti."),
            ];

            fn solveNode(
                <fail solveNode 23:32+1 helpers type both alias 5:17+7>
                ref <pass/>
                mut </fail>
                type: string) {
                helpers && helpers.pop();
                return type;
            }

            mut fallback: string;
            fn lookup(id: i32) {
                helpers.each: |h| if (h.id == id) return h.type;
                return fallback;
            }

            mut str = solveNode(lookup(13));
            str ~= str;
            return helpers.len * 1000 + str.len - 116;
        }
    `);

    ZERO(`
        enum Kind       { return; expr }
        struct Type     { canon: string }
        struct Helpers  { id: string; ret_actual: Type }
        struct Node     { kind: Kind; value: string; items?: Node[] }

        fn Scope_pop(implicit ref _helpers: Helpers[])
            _helpers && _helpers.pop();

        fn test(implicit mut _helpers: Helpers[], root: Node)
        {
            fn solveNode(node: Node,

                // TODO fix this is stupid, just documenting the reasoning here
                <fail arg solveNode:type is ref-returned from fn solveNode 28:33+1><pass/>
                mut
                </fail>
                type?: Type
            ) {
                if (node.kind == Kind.return)
                    return solveJump(node);

                Scope_pop();
                return type;
            }

            fn solveJump(node: Node) {
                let h       = Scope_lookupLabel(node.value);
                let n_expr  = node.items && node.items[0];
                return solveNode(n_expr, type: h.ret_actual);
            }

            fn Scope_lookupLabel(id: string) {
                _helpers.each: |item| item.id == id && { return item };
                throw("No label '" ~ id ~ "' in scope.");
            }

            return solveNode(root);
        }

        fn main() {
            implicit mut _helpers = [
                Helpers("hello", Type("Hello")),
                Helpers("world", Type("World")),
            ];

            let res = test(
                Node(Kind.return, "world", [
                    Node(Kind.expr, "hello")
                ]));

            return res.canon == "World" ? 0 : 1;
        }
    `);

    TODO_relaxer(currently: "BUG spec.args.len(3) != original.args.len(4)", `
        struct Target { globid: i32 };
        struct SolvedNode { target: Target; items?: SolvedNode[] }
        struct Argument { target: Target };
        struct Overload { solved: SolvedNode };
        struct Extended { args: Argument[] };

        noinline fn lazySolveStartDetectRecursionBug(overloads: Overload[], extended: Extended[], root: SolvedNode)
        {
            using fn GET(target: Target)
                overloads[target.globid];

            using fn EXT(target: Target)
                extended[target.globid];

            fn cgNode(n: SolvedNode) {
                mut src = "";
                n.items.each: |member|
                    src ~= cgFn(member.target);

                return src;
            }

            fn cgFn(target: Target) {
                mut src = cgNode(target.solved);
                target.args.each: |host_arg|
                    src ~= binding(host_arg);

                return src;
            }

            fn binding(target: Target)      cgNode(target.solved);
            fn binding(arg: Argument)       binding(arg.target);

            return cgNode(root);
        }

        fn main() {
            return lazySolveStartDetectRecursionBug(
                [ Overload() ], [ Extended() ], SolvedNode()).len;
        }
    `);

    // /Recursion, closures & implicit arguments.


    //

    ZERO(`
        let x = 1;

        fn test(): &i32
            x;

        return test - 1;
    `);

    ZERO(`
        let a = 1;
        let x: &i32 = a;

        return a - x;
    `);

    ZERO(`
        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;
    `);

    ZERO(`
        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;
    `);


    // Arrays.

    ZERO(`
        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];
    `);

    ZERO(`
        <fail name>
        let x = [ named: 0 ]; <pass/>
        let x = [        0 ]; </fail>
        return x[0];
    `);

    ZERO(`
        mut other: i32[][];
        mut arr:   i32[][];
        for (mut i = 4; i --> 0; )
        {
            arr.resize(i);

            // fill up with non small vecs so we can check alloc counts
            for (shadow mut i = 0; i < arr.len; i++)
                arr[i] ||= [ i, i, i, i, i, i, i, i ]; // defeat small vec

            // now this convers the "Last chance to do nothing" opti -
            //  noop resize a shared vec.
            other = arr;
            arr.resize(other.len || i);
        }
        return other.len;
    `);

    // /Arrays.


    // COW

    ZERO(`
        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            <fail COW will break (8:27+4|8:41+4) 7:17+4>
            ref zero    = nums[nums.len / 2];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            <pass/>
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            ref zero    = nums[nums.len / 2];
            </fail>

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];

            <fail COW will break (13:34+2|13:48+2) 9:17+4>
            ref zero    = nums[nums.len / 2];
            let woot    = OPAQUE && nums;
            <pass/>
            let woot    = OPAQUE && nums;
            ref zero    = nums[nums.len / 2];
            </fail>

            let allOnes = <alt>OPAQUE && woot<alt/>indirect_copy(OPAQUE && woot)</alt>;

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            let OPAQUE  = nums.len == 100 * nums[nums.len / 2];
            mut other   = 0;

            <fail COW will break (12:27+4|12:41+4|11:27+4|11:41+4)>
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            <fail/>
            ref woot    = nums[nums.len / 2];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            ref zero    = OPAQUE ? woot : other;
            <pass/>
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            ref woot    = nums[nums.len / 2];
            ref zero    = OPAQUE ? woot : other;
            </fail>

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        <alt>
        noinline fn cow_after_ref_indirect(ref zero: i32, allOnes: i32[]) cow_after_ref(:zero, :allOnes);
        noinline fn cow_after_ref(ref zero: i32, allOnes: i32[])
        <alt/>
        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zero: i32) cow_after_ref(:allOnes, :zero);
        noinline fn cow_after_ref(allOnes: i32[], ref zero: i32)
        </alt>
        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            return zero == 0 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;

            <alt>
            return cow_after_ref(           <alt/>
            return cow_after_ref_indirect(  </alt>
                zero: nums[nums.len / 2], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++) nums ~= 1;

            <fail COW will break (8:27+4|8:41+4) 30:19+3 7:17+6>
            ref zeroes  = nums[10:20];
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            <pass/>
            let allOnes = <alt>nums<alt/>indirect_copy(nums)</alt>;
            ref zeroes  = nums[10:20];
            </fail>

            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        <alt>
        noinline fn cow_after_ref_indirect(ref zeroes: [i32], allOnes: i32[]) cow_after_ref(:zeroes, :allOnes);
        noinline fn cow_after_ref(ref zeroes: [i32], allOnes: i32[])
        <alt/>
        noinline fn cow_after_ref_indirect(allOnes: i32[], ref zeroes: [i32]) cow_after_ref(:allOnes, :zeroes);
        noinline fn cow_after_ref(allOnes: i32[], ref zeroes: [i32])
        </alt>
        {
            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return z == 10 && o == 100 ? 0 : 1;
        }

        fn main() {
            mut nums: i32[];
            for (mut i = 0; i < 100; i++)
                nums ~= 1;

            <alt>
            return cow_after_ref(           <alt/>
            return cow_after_ref_indirect(  </alt>
                zeroes: nums[10:20], allOnes: <alt>nums<alt/>indirect_copy(nums)</alt>);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        fn test(ref nums: i32[][])
        {
            <fail COW will break (6:31+1|6:45+1) 36:19+3 5:17+6>
            ref zeroes  = nums[nums.len / 2];
            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;
            <pass/>
            mut allOnes = <alt>nums[nums.len / 2]<alt/>indirect_copy(nums[nums.len / 2])</alt>;
            ref zeroes  = nums[nums.len / 2];
            </fail>

            for (mut i = 0; i < zeroes.len; i++)
                zeroes[i] = 0;

            mut o = 0;
            for (mut i = 0; i < allOnes.len; i++)
                if (allOnes[i] == 1)
                    o++;

            mut z = 0;
            for (mut i = 0; i < zeroes.len; i++)
                if (!zeroes[i])
                    z++;

            return o == 10 && z == 10 ? 0 : 10;
        }

        fn main() {
            mut nums: i32[][];
            for (mut i = 0; i < 4; i++)
                nums ~= [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ];

            return test(nums);
        }

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        struct TwoVecs {
            ones: i32[]; twos: i32[];
        };

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }

            <fail COW will break (15:27+4|15:41+4) 34:40+1 40:19+3>
            ref zero    = orig.ones[orig.ones.len / 2];
            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;
            <pass/>
            let all     = <alt>orig<alt/>indirect_copy(orig)</alt>;
            ref zero    = orig.ones[orig.ones.len / 2];
            </fail>

            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        struct TwoVecs {
            ones: i32[];
            twos: i32[];
        };

        <alt>
        noinline fn cow_after_ref_indirect(ref zero: i32, all: TwoVecs) cow_after_ref(:zero, :all);
        noinline fn cow_after_ref(ref zero: i32, all: TwoVecs)
        <alt/>
        noinline fn cow_after_ref_indirect(all: TwoVecs, ref zero: i32) cow_after_ref(:all, :zero);
        noinline fn cow_after_ref(all: TwoVecs, ref zero: i32)
        </alt>
        {
            zero = 0;

            mut o = 0;
            for (mut i = 0; i < all.ones.len; i++)
                if (all.ones[i] == 1)
                    o++;

            mut t = 0;
            for (mut i = 0; i < all.twos.len; i++)
                if (all.twos[i] == 2)
                    t++;

            return zero == 0 && o == 100 && t == 100 ? 0 : 1;
        }

        fn main() {
            mut orig: TwoVecs;
            for (mut i = 0; i < 100; i++) {
                orig.ones ~= 1;
                orig.twos ~= 2;
            }

            <alt>
            return cow_after_ref(           <alt/>
            return cow_after_ref_indirect(  </alt>
                zero: orig.ones[orig.ones.len / 2], all: <alt>orig<alt/>indirect_copy(orig)</alt>);
        }

        noinline fn indirect_copy(tv: TwoVecs)
            TwoVecs(ones: indirect_copy(tv.ones),
                    twos: indirect_copy(tv.twos));

        noinline fn indirect_copy(arr: i32[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            <fail COW will break (20:24+3|20:38+3) 31:19+3>
            ref x = arr[0];
            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;
            <pass/>
            mut barr = <alt>arr<alt/>indirect_copy(arr)</alt>;
            ref x = arr[0];
            </fail>

            test(:barr, x);

            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        noinline fn test(ref barr: i32[][], ref x: i32[]) {
            for (mut i = 0; i < x.len; i++)
                x[i] += 2;

            for (mut i = 0; i < barr.len; i++) {
                ref b = barr[i];
                for (mut j = 0; j < b.len; j++)
                    b[j] += 1;
            }

            barr ~= [ 0 ];
        }

        noinline fn outer(ref a: i32[][], ref b: i32[][])
        {
            <fail both alias arr (28:17+3|28:31+3|27:17+3|27:31+3) 30:35+3>
            ref x = a[0];
            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;
            <fail/>
            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;
            ref x = a[0];
            <pass/>
            mut barr = <alt>b<alt/>indirect_copy(b)</alt>;
            mut x = a[0];
            </fail>

            test(:barr, x);

            return barr;
        }

        fn main() {
            mut arr: i32[][] = [ [0,1,2,3,4,5,6,7], [8,9,10,11,12,13,14,15] ];

            let barr = outer(arr, arr);
            return barr == [ [1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [0] ] ? 0 : 1;
        }

        noinline fn indirect_copy(arr: i32[][])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        struct Ephemeral {
            id:             i32;
            scope_skip?:    Ephemeral[];
        };

        struct SolverState {
            _scope_skip:    Ephemeral[];
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            ref eph        = s._ephs[i]; // cannotCOW false positive, copy(s._scope_skip) <- ref eph, but they're disjoint
            eph.scope_skip = <alt>s._scope_skip<alt/>indirect_copy(s._scope_skip)</alt>;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.len - 3;
        }

        noinline fn indirect_copy!<T>(arr: T[])
            arr.len & 1
                ? arr[: arr.len / 2] ~ arr[arr.len / 2 :]
                : arr; // <- we take this branch
    `);

    ZERO(`
        // This one unrelated to COW but variation of test above.
        <flip>
        struct Ephemeral { // When first, we cg declarations in the wrong order
            id:             i32;
            scope_skip?:    ScopeSkip;
        };
        <flip/>
        struct ScopeSkip { // When first, we complain about recursive types
            left:           Ephemeral[];
            right:          Ephemeral[];
        };
        </flip>

        struct SolverState {
            _scope_skip:    ScopeSkip;
            _ephs:          Ephemeral[];
        };

        fn snap(i: i32, ref s: SolverState) {
            mut scope_skip  = s._scope_skip;
            ref eph         = s._ephs[i];
            eph.scope_skip  = scope_skip;
            return eph;
        }

        fn main() {
            mut s = SolverState(
                _scope_skip: ScopeSkip(
                    [ Ephemeral(1), Ephemeral(2), Ephemeral(3) ],
                    [ Ephemeral(4), Ephemeral(5) ]
                ),
                _ephs:       [ Ephemeral(4) ],
            );

            return snap(:s, 0).scope_skip.left.len - 3;
        }
    `);

    ZERO(`
        struct Node { items: Node[] };

        fn unwrap_all(ref nodes: Node[]) {
            for (mut i = 0; i < nodes.len; i++) {
                ref n = nodes[i];
                if (n.items)        // cannotCOW false pos
                    n = n.items[0]; //  copy(n.items[0]) <- ref n
            }                       //   via parent nodes
        }

        fn count(nodes: Node[]) {
            mut N = nodes.len;
            for (mut i = 0; i < nodes.len; i++)
                N += nodes[i].items.count;
            return N;
        }

        fn main() {
            mut nodes = [ Node([ Node() ]) ];
            nodes.unwrap_all();
            return nodes.count - 1;
        }
    `);

    ZERO(`
        noinline fn conditionalCopyOrWrite(ref a: i32[][], ref b: i32[][]) {
            ref either = (a || b)[0];
            <alt>
            if (either.len & 1)
                b = a;              // <- no issue here
            else                    //  either only written to
                either ~= 1;        //   if copy never created.
            <alt/>
            if (either.len & 1 == 0)
                either ~= 1;
            else
                b = a;
            </alt>
        }

        fn arr(n: i32) {
            mut arr: i32[];
            for (mut i = 1; i <= n; i++) arr ~= i;
            return arr;
        }

        fn check(arr: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum;
        }

        fn check(arr: i32[][]) {
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum = sum * 100 + check(arr[i]);
            return sum;
        }

        fn main() {
            mut a = [ arr( 8), arr( 9) ];
            mut b = [ arr(10), arr(11) ];

            conditionalCopyOrWrite(:a, :b);

            return check(a) == 3600 + 45 + 100
                && check(b) == 5500 + 66
                    ? 0 : 1;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            result.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateThenCopy(a, a);
            return 1000 * a.count + b.count - 2004;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopy(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                result.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopy();
            return 1000 * a.count + b.count - 2004;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref callsite: SolvedNode, ref root: SolvedNode) {
            callsite.items ~= callsite;
            mut result = root;
            root.items ~= root;
            return result;
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = mutateCopyMutate(a, a);
            return 1000 * a.count + b.count - 4002;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateCopyMutate(ref root: SolvedNode) {
            fn copyRoot() {
                mut result = root;
                root.items ~= root;
                return result;
            }

            fn bck_call(ref callsite: SolvedNode) {
                callsite.items ~= callsite; // mutation
                return copyRoot();          // copy inside
            }

            return bck_call(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateCopyMutate();
            return 1000 * a.count + b.count - 4002;
        }
    `);

    TODO_ambig(currently: "if/else no common supertype SolvedNode[] 17:21+1", `
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn mutateThenCopyAfterRecursion(ref root: SolvedNode) {
            fn mutateThenCopy(ref callsite: SolvedNode) {
                callsite.items ~= callsite;

                mut result = root;
                result.items ~= root;
                return result;
            }
<flip>
            fn indirectRecursion(ref node: SolvedNode) {
                ref items = node.items;

                // The root copies made at the end of each bck_node call
                //  would indeed be invalid if they survived,
                //   but they get return-discarded here.
                for (mut i = items.len; i --> 1; )
                    bck_node(items[i]);                         ;; !N_COWRestrict
                                                                ;; PointlessMustSeq
                return items && bck_node(items[0]);
            }
<flip/>
            fn bck_node(ref node: SolvedNode)
                node.items
                    ? indirectRecursion(node)
                    : mutateThenCopy(node);
</flip>
            return bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut a: SolvedNode;
            mut b = a.mutateThenCopyAfterRecursion();
            return 1000 * a.count + b.count - 2004;
        }
    `);

    ZERO(`
        struct Node {
            items?: Node[];
        };

        fn obtuseEscapeOnNextLoopIter(ref node: Node, ref root: Node) {
            mut escape: Node;
            <fail both alias root 26:17+4>
            ref <pass/>
            fn  </fail> items = node.items;

            for (mut i = items.len; i --> 0; ) {
                <alt>
                if (i)      escape = root;
                else        items[i].items ~= escape;
                <alt/>
                if (i == 0) items[i].items ~= escape;
                else        escape = root;
                </alt>
            }
        }

        fn main() {
            fn count(node: Node) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut root = Node([ Node, Node ]);
            obtuseEscapeOnNextLoopIter(root, root);

            // Now root should be:
            // Node([ Node([ Node([ Node, Node ]) ]), Node ])
            //
            // If COW breaks this can get self-recursive,
            //  currently blows up with a segfault if 'ref items'.
            //
            return root.count - 6;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn cowAfterConditionalWithLoop(ref a: SolvedNode, ref b: SolvedNode) {
            if (a.items.len & 1) {
                ref items = a.items;
                for (mut i = 0; i < items.len; i++)
                    cowAfterConditionalWithLoop(items[i], b);
            }

            a.items ~= b;
        }

        fn main() {
            mut x = SolvedNode([ SolvedNode ]);
            <fail both alias x>
            ref y = x;  <pass/>
            mut y = x;  </fail>
            cowAfterConditionalWithLoop(x, y);                  ;; N_COWRestrict

            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            return x.count == 6 ? 0 : 1;
        }
    `);

    ZERO(`
        struct SolvedNode {
            items: SolvedNode[];
        };

        fn copiesRootBeforeThrow(ref root: SolvedNode, ref escape: SolvedNode)
        {
            fn fail(reason: string)
                reason.len & 1 && throw("odd: " ~ reason)
                               || throw(reason);

            fn bck_node(ref node: SolvedNode) {
                ref items = node.items;
                for (mut i = 0; i < items.len; i++) {
                    ref item = items[i];
                    bck_node(item);

                    if (item.items.len > 1) {
                        escape = root;
                        <fail both alias root 29:21+1>
                        if (escape.items.len > 3)       <pass/>
                        if (true)                       </fail>
                            fail("#" ~ escape.items.len);
                    }
                }

                node.items ~= node;
            }

            bck_node(root);
        }

        fn main() {
            fn count(node: SolvedNode) {
                mut c = 1;
                node.items.each: |item| c += count(item);
                return c;
            }

            mut escape: SolvedNode;
            mut a = SolvedNode([ SolvedNode ]);
            a.copiesRootBeforeThrow(:escape);

            let C0 = a.count;
            if (C0 != 6)            return 1;

            try {
                a.copiesRootBeforeThrow(:escape);
            }
            catch (e) {
                a.items ~= SolvedNode(); // escape !== a
                let C1 = a.count;
                let C2 = escape.count;
                if (C1 != 11)           return 2;
                if (C2 != 10)           return 3;
                else if (e != "#2")     return 4;
                else                    return 0;
            }

            return 5;
        }
    `);

    ZERO(`
        struct A { ints: i32[] };

        fn copyInts_then_mutateBytes(ref bytes: byte[], a: A) {
        <flip>
            for (mut i = 0; i < bytes.len; i++)
                bytes[i] = 0.byte;
        <flip/>
            mut ret = a;
        </flip>
            ret.ints.pop();
            return ret;
        }

        fn main() {
            mut a = A([ 1, 1, 1, 1, 1, 2, 2, 2, 2, 2 ]);

            <fail var a 16:17+1 COW will break 21:56+1 due to bytes 19:18+5>
            ref <pass/>
            fn  </fail> bytes = a.ints.view(of: byte);

            let b = copyInts_then_mutateBytes(:bytes, :a);

            mut sum = 0;
            for (mut i = 0; i < b.ints.len; i++)
                sum += b.ints[i];

            return sum - 13;
        }
    `);

    ZERO(`
        struct Wrapper { str: string };

        fn validateCOW_falsePos_with_typeMayPointInto_disabled(
            ref _scope: Wrapper[])
        {
            fn findFirstSet() {
                _scope.each: |wrapper|
                    if (wrapper.str)
                        return wrapper.str;

                return "None";
            }

            fn wrapper_cannotPointInto_String(h: int) {
                ref wrapper = _scope[h];
                wrapper.str = findFirstSet();
            }

            for (mut i = 0; i < _scope.len; i++)
                wrapper_cannotPointInto_String(i);
        }

        fn main() {
            mut _scope = [ Wrapper() ];
            validateCOW_falsePos_with_typeMayPointInto_disabled(_scope);
            return _scope.len == 1 && _scope[0].str.len - 4;
        }
    `);

    // /COW


    // A basic testing setup for array ops,
    //  that can be flipped around for making sure
    //   e.g. copy-on-write behaves as expected.

    lax fn ARROPS(
        literal: string,
        operation: string,
        mut assertion: string)
    {
        assertion = "(" ~ assertion ~ ")";

        fn EXPR(varname: string)
            assertion.replace(
                all: "@", with: varname);

        mut src: string;

        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr0 = [" ~ literal ~ "];";
        src ~= "\n        arr0." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr0") ~ " != 0) return 13;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    mut orig = [" ~ literal ~ "];";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        mut arr1 = orig;";
        src ~= "\n        arr1." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr1") ~ " != 0) return 17;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    {";
        src ~= "\n        ref arr2 = orig;";
        src ~= "\n        if (arr2.len != 5) return 38;";
        src ~= "\n        arr2." ~ operation ~ ";";
        src ~= "\n        if (" ~ EXPR("arr2") ~ " != 0) return 23;";
        src ~= "\n    }";
        src ~= "\n";
        src ~= "\n    return 0;";
        src ~= "\n";

        ZERO(src);
    };

    ARROPS( "0,1,2,3,4",
            "push(5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "insert(5, 5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "pop()",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "splice(4, 1)",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "unshift(5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "insert(0, 5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "shift()",
            "@[0] + @[2] - @[3]");

    ARROPS( "0,1,2,3,4",
            "insert(1, 5)",
            "@[2] + @[5] - @[1]");

    ARROPS( "0,1,2,3,100",
            "splice(1, 3)",
            "@.len + @[0] + @[1] - 102");


    //

    ZERO(`
        let OPERATORS = [ "+", "-", "*", "/" ];

        fn main()
            OPERATORS[2] == "*" ? 0 : 1;
    `);

    ZERO(`
        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;
    `);

    ZERO(`
        struct SelfRec { x: SelfRec[]; };
        fn main() SelfRec( [ SelfRec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        struct ABRec { x: BARec[]; };
        struct BARec { x: ABRec[]; };
        fn main() ABRec( [ BARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        struct ABRec { x: BARec[]; y: ABBARec[]; };
        struct BARec { x: ABRec[]; y: ABBARec[]; };
        struct ABBARec { x: ABRec[]; y: BARec[]; };
        fn main() ABRec( [ BARec() ], [ ABBARec() ] ).x.len - 1; // <- solved with a dirty selfrec & defctor
    `);

    ZERO(`
        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];
    `);

    ZERO(`
        fn collectDedupes(mut vals<alt>: i32[]</alt>) {
            vals.sort();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }
    `);

    ZERO(`
        fn sort01(ref arr: [$T]) {
            mut tmp: $T;
            if (arr[0] > arr[1]) {
                swap(arr[0], tmp);
                swap(arr[1], tmp);
            }
        }

        fn collectDedupes(mut vals) {
            vals.sort01();
            return vals[0];
        }

        fn main() {
            let vals = [ 1, 0 ];
            return collectDedupes(vals);
        }
    `);


    // Strings.

    ZERO(`
        mut str = "hello ";
        str ~= "world";

        return str.len - 11;
    `);

    ZERO(`
        let str = "hello " ~ "world";

        return str.starts(with: "hel")
             ? str  .ends(with: "rld")
             ? str.len - 11
             : 171
             : 173;
    `);

    ZERO(`
        let str = "a" ~ 1710010;

        return str == "a1710010"
             ? 0 : 101;
    `);

    ZERO(`
        let str = "hello world";
        mut cpy = "";
        for (mut i = 0; i < str.len; i++)
            cpy ~= str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);
    `);

    ZERO(`
        return "hello world".find("world")
             - 2 * [1, 7, 13, 14, 19].find(14);
    `);

    ZERO(`
        return ("hello world".has("world") ? 1 : 0)
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;
    `);

    ZERO(`
        let hw = "hello world!";
        let a = hw.slice(6, 6 + 5);
        let b = hw.substr(6, 5);
        return a == b && a == "world" ? a.len - 5 : 1;
    `);

    ZERO(`
        let tests =
        [
            "",
            " ",
            "  ",
            "hey you duders",
            " hey you duders",
            "hey you duders ",
            "  hey you duders ",
            "  hey you  duders ",
            "  hey you  duders  "
        ];

        fn test(item: string)
            item == item.split(" ").join(" ")
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;
    `);

    ZERO(`
        fn main() {
            let sj = "heelloo"  .split("ee").join("e")
                                .split('o').join("o!")
                                .split("he").join();            ;; DuplicateFunctions

            return sj == "llo!o!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() '\\e'.i32 - 27
             ||   '\\0'.i32
             || '\\x11'.i32 - 17
             || '\\xaA'.i32 - 170;
    `);

    ZERO(`
        fn main()   <fail unterminated char literal 3:13+2>
            'c      <fail/>  // '
            'c
            '       <pass/>
            'c'     </fail>
                .i32 - 99;
    `);

    ZERO(`
        fn main()   <fail invalid char literal 3:13+4>
            'cb'    <pass/>
            'c'     </fail>
                .i32 - 99;
    `);

    ZERO(`
        fn main()   <fail unterminated string use backticks 3:13+2>
            "c      <fail/>  // "
            "c
            "       <pass/>
            \`c
            \`      </fail>
                [0].i32 - 99;
    `);

    ZERO(`
        fn main()                           <fail invalid code point 3:14+10>
            "\\u{ffffff}".u32               <pass/>
            "\\u{042e}" == ""  ? 0 : 1     </fail>
            ;
    `);

    ZERO(`
        fn main() {
            mut hello = "hello";
            mut olleh = hello;
            olleh.reverse();
            return olleh == "olleh" ? 0 : 1;
        }
    `);

    ZERO(`
        fn main()
            "hello".replace(all: "h", with: "H") == "Hello" &&
            "hello".replace(all: 'e', with: 'E') == "hEllo" &&
            "hello".replace(all: "l", with: 'L') == "heLLo" &&
            "hello".replace(all: 'o', with: "O") == "hellO" &&
            "hello".replace(all: "l", with:  []) == "heo"
                ? 0 : 1;
    `);

    ZERO(`
        fn cnct(a: string, b: string) a ~ b;

        fn main()
            cnct( <fail missing comma before world 6:29>
                a: "hello, "\`world!
\` <pass/>
                a: "hello, ", \`world!
\` </fail>
            ).len - 14;
    `);

    ZERO(`
        fn main() ("" ~ "").len;
    `);

    ZERO([`
        let empty_str = "";
    `,`
        fn main() = _0::empty_str.len;
    `]);

    ZERO([`
        let empty_str = "";
        let empty_str_ref = empty_str;
    `,`
        fn main() = _0::empty_str_ref.len;
    `]);

    ZERO([`
        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_str_ref = non_empty_str;
    `,`
        fn main() = _0::non_empty_str_ref.len - 65;
    `]);

    ZERO([`
        let non_empty_str = "This is a non-empty string that's too long for small string opti.";
        let non_empty_slice = non_empty_str[5:];
    `,`
        fn main() = _0::non_empty_slice.len - 60;
    `]);

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
        {
            let a0 = mem::ALLOC_STAT_COUNT();
            strA.slice(0, 26) == "0123456789abcdef0123456789" || throw("bad slice");

            let a1 = mem::ALLOC_STAT_COUNT();
            a0 == a1 || throw("did alloc");

            return 0;
        }
    `);

    ZERO(`
        let strA = "0123456789abcdef0123456789ABCDEF";

        fn main()
            strA.slice(26, 32) == "ABCDEF"
                ? 0 : 1;
    `);

    ZERO(`
        struct NotAString { hey: string };
        fn main() {
            mut a = "Hello";
            mut b = NotAString("World!");
            <fail NotAString not a string 7:22+1>
            return a < b ? 0 : 1;         <pass/>
            return a < b.hey ? 0 : 1;     </fail>
        }
    `);

    // /Strings.


    // Maps.

    LEGACY_Map(currently: "Map is not defined", `
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        return x["hello"] - x["world"] + 1;
    `);

    LEGACY_Map(currently: "Map is not defined", `
        mut x: Map(string, i32);

        x["hello"] = 1;
        x["world"] = 2;

        let b = "hello world";
        mut offset = 0;

        fn pop(): string {
            mut a = "";

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a ~= c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;
    `);


    // Default arguments.

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test() - 3;
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(b: -1);
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(-2);
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(1);
        return t.b;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a?: i32; b?: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey() Test();
        return hey.x;
    `);

    ZERO(`
        struct Test { x?: i32; };
        fn hey(y: i32 = 0)
            y   ? Test(1)
                : Test();

        return hey.x;
    `);

    ZERO(`
        <fail bad call>
        fn test(a = "hello") a.len;     <pass/>
        fn test(a = 0) a + 1;           </fail>
        fn main() test(-1);
    `);

    TODO_args(currently: "no implicit test:a in scope", `
        fn test(a = 3, b = a * 2) a + b;
        fn main() test + test(a: -1) * 3;
    `);

    ZERO(`
        fn woot(ref a: i32, ref b: i32) {
            ref c = a || b;
            fn arg_defaulted_to_closure(ref x = c)
                x *= 2;

            arg_defaulted_to_closure( );
            arg_defaulted_to_closure(a);
            arg_defaulted_to_closure(b);
        }

        fn main() {
            mut a = 1;
            mut b = 1;
            woot(a, b);
            return a == 4 && b == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        fn test(ref a: i32, mut incr: i32) {
            fn woot(ref x, ref b = a) { // 'a' closes over here!
                if (x & 1) {
                    x /= 2;
                    return test(x, b);
                }
                return b += x;
            }

            return woot(incr<alt>, a</alt>);
        }

        fn main() {
            mut x = 10;
            return test(x, 5) == 12 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Arg { name: string };
        fn main() {
            let arg = Arg(<fail argument name id>id<pass/>name</fail>: "hey");
            return arg.name.len - 3;
        }
    `);

    ZERO(`
        fn uses_implicit(implicit ref sum: i32) {
            return sum++;
        }
        <split/>
        inline fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit) {
            return hello * defaulted_argument;
        }
        <split/>
        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);         ;; GNUStmtExpr
            return sum == 4 && res == 9 ? 0 : 1;
        }
    `);

    ZERO(`
        // reduct: inline_implicit_from_defarg ooe bug
        fn main() {
            <alt>
            return ooe_block_arg(z: 0, a: 3);
        }

        fn ooe_block_arg(mut z: i32, mut a: i32) {
            <alt/>
            mut z = 0;
            mut a = 3;
            return ooe_block_arg(:z, :a);
        }

        fn ooe_block_arg(ref z: i32, ref a: i32) {
            <alt/>
            mut z = 0;
            mut a = 3;
            </alt>
                        ;; N_BckMustSeq
            <alt>
            let res = a * { ref x = z || a; x++ };              ;; GNUStmtExpr
            return a == 4 && res == 9 ? 0 : 1;
            <alt/>
            let res = { ref x = z || a; x++ } * a;              ;; GNUStmtExpr
            return a == 4 && res == 12 ? 0 : 1;
            </alt>
        }
    `);

    ZERO(`
        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {
            <alt>
            inline                                              ;; N_BckMustSeq
            <alt/>
            noinline                                            ;; N_AARMustSeq
            </alt>
            fn ooe_closure(ref hello<alt>: i32</alt>) {
                let res = hello * { ref x = z || a; x++ };      ;; GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 9 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }
    `);

    ZERO(`
        // gcc doesn't cg RTL with just * for this testcase, but this breaks it
        noinline fn mul(a: i32, b: i32) = a * b;

        // reduct: inline_implicit_from_defarg
        fn test(ref a: i32, ref z: i32) {
            <alt>
            inline                                              ;; N_BckMustSeq
            <alt/>
            noinline                                            ;; N_AARMustSeq
            </alt>
            fn ooe_closure(ref hello<alt>: i32</alt>) {
                let res = mul({ ref x = z || a; x++ }, hello);  ;; GNUStmtExpr
                hello += 10;
                return res;
            }

            let res = ooe_closure(a);
            return a == 14 && res == 12 ? 0 : 1;
        }

        fn main() {
            mut a = 3;
            mut z = 0;
            return test(:a, :z);
        }
    `);

    ZERO(`
        inline fn uses_implicit_inside() {
            inline fn uses_implicit(implicit ref sum: i32) {
                return sum++;
            }

            return uses_implicit;
        }

        <alt>
        inline                                                  ;; GNUStmtExpr
        <alt/>
        ;; N_BckMustSeq
        </alt>
        fn inline_implicit_from_defarg(hello: i32, defaulted_argument: i32 = uses_implicit_inside) {
            return hello * defaulted_argument;
        }

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(sum);
            return sum == 4 && res == 9 ? 0 : 1;
        }
    `);

    ZERO(`
        inline fn uses_implicit(implicit ref sum: i32) = sum++;
        inline fn uses_implicit_inside() = uses_implicit;

        <alt>
        inline                                                  ;; GNUStmtExpr
        <alt/>
        ;; N_BckMustSeq
        </alt>
        fn inline_implicit_from_defarg(defaulted_argument: i32 = uses_implicit_inside, hello: i32 = 0)
            hello * defaulted_argument;

        fn main() {
            implicit mut sum = 3;
            let res = inline_implicit_from_defarg(hello: sum);
            return sum == 4 && res == 12 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            struct Type { canon: string };

            mut _lookups: int;
            mut _t_bool: Type;

            fn t_bool() {
                return _t_bool ||= Scope_lookupType("bool");
            }

            fn Scope_lookupType(canon: string) {
                _lookups++;
                return Type(:canon);
            }

            fn check(a<alt>: Type</alt>, b = t_bool) {
                return a.canon.len + b.canon.len;
            }

            return check(t_bool) + _lookups - 9;
        }
    `);

    TODO_recursion(currently: "Declaration cycle 10:16+10", `
        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn solve(root: Node)
        {
            mut _t_bool: Type;

            fn createBool(value: string, type = t_bool)
                return SolvedNode(:value, :type);

            fn solveNode(node: Node)
                return node.kind == "bool"
                    && createBool(:node.value);
    <alt>
            fn solveNode(canon: string)
                return Type(:canon);

            fn t_bool()
                return _t_bool ||= solveNode("t_bool");
    <alt/>
            fn t_bool()
                return _t_bool ||= Type("t_bool");
    </alt>
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }
    `);

    TODO_recursion(currently: "Declaration cycle 11:30+1", `
        struct Type { canon: string };
        struct Node { kind: string; value: string };
        struct SolvedNode { value: string; type: Type };

        fn createBool(value: string, type = t_bool)
            return SolvedNode(:value, :type);

        fn solveNode(node: Node)
            return node.kind == "bool"
                && createBool(:node.value);
<alt>
        fn solveNode(canon: string)
            return Type(:canon);

        fn t_bool(implicit ref _t_bool: Type)
            return _t_bool ||= solveNode("t_bool");
<alt/>
        fn t_bool(implicit ref _t_bool: Type)
            return _t_bool ||= Type("t_bool");
</alt>
        fn solve(root: Node)
        {
            implicit mut _t_bool: Type;
            return solveNode(root);
        }

        fn main() {
            let s = solve(Node(kind: "bool", value: "Hello!"));
            return s.value      == "Hello!"
                && s.type.canon == "t_bool"
                    ? 0 : 1;
        }
    `);

    ZERO(`
        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {
            mut res = 0;
            woot(hello: |one| res += one);                      ;; DuplicateFunctions
            woot(world: |two| res += two);
            return res - 3;
        }
    `);

    ZERO(`
        fn woot(hello!?, world!?) {
            hello(one?: 1);
            world(two?: 2);
        }

        fn main() {                                             ;; DuplicateFunctions
            mut res = 0;
            <fail duplicate explicitly named argument hello 10:17+1>
            woot(hello: |one| res += one, hello: |one| res += one); <pass/>
            woot(hello: |one| res += one, world: |two| res += two); </fail>
            return res - 3;
        }
    `);

    // /Default arguments.


    // Truth tests.

    ZERO(`
        let s = 7;
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = 0;
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = "hello";
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = "";
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = [ 4 ];
        return s ? 0 : 1;
    `);

    ZERO(`
        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;
    `);


    // Loop labels.

    ZERO(`
        mut sum = 0;
        :OUTER for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    ;; Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;
    `);

    ZERO(`
        fn for_fn(mut i: i32, n: i32, visit)
            for (; i < n; i++)
                visit(i);

        mut sum = 0;
        :OUTER for_fn(1, 10): |y| // same as above but via helper fn
        {
            sum += y * 10; // 10, 20
            for_fn(1, 10): |x|
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :OUTER;                    ;; Goto
                if (x == 2) break    :OUTER;
            }
        }

        return sum - 34;
    `);

    ZERO(`
        fn twice(what)
            for (mut i = 0; i < 2; i++)
                what(i);

        mut x = 0;
        :TWICE twice: |i<alt>: int</alt>| {
            x += i;
            if (!x++) continue :TWICE;
        }

        return x - 3;
    `);

    ZERO(`
        mut sum = 0;
        :OUTER for (mut x = 0;; x++) {
            for (mut y = 0; y < x; y++) {
                if (y & 1 && !(x & 1))
                    continue :OUTER;                            ;; Goto

                sum += x;
            }

            sum += x * 1000 + 100;
            if (x > 1) ;; EXPECT break;
                break; // anon
        }

        // x=0:           + 0100
        // x=1: 1         + 1100
        // x=2: 2
        // x=3: 3 + 3 + 3 + 3100 break
        return sum - 4312;
    `);

    ZERO(`
        fn test(ref sum: i32) {
            :FIRST {
                if (sum & 1)
                    break:
                        FIRST;
                sum++;
            }
            :SECOND {
                if (sum & 1)
                    break:
                        <fail label>
                        FIRST;      <pass/>
                        SECOND;     </fail>
                sum++;

                if (sum & 2)
                    break:
                        SECOND;
                sum++;
            }
        }

        fn main() {
            mut sum = 0;
            test(sum);
            return sum - 1;
        }
    `);


    // Logic and selectors.

    ZERO(`
        let x = "hello";
        lax let y = "world";
        let w = x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let w = x && y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        lax let y = "world";
        let w = 3 && x || y;

        return w == "hello" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y;

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        let x = "hello";
        let y = "world";
        let arr: i32[];
        let w = arr && x || y || throw("Nope.");

        return w == "world" ? 0 : 1;
    `);

    ZERO(`
        fn what(a: i32) {
            a == 2 || a & 1 || throw("what1");
            a  > 1 && a & 1 && throw("what2");
            a  > 0 && a & 3 || throw("what3");
            return a + 4;
        }
        fn main() 1.what - 2.what + 1;
    `);

    ZERO(`
        fn gen(len: i32) {
            mut res: i32[];
            for (mut i = 0; i < len; i++) res ~= i;
            return res;
        }
        fn test(len: i32) {
            let x = [-5, +5];
            let y = len.gen && x;
            return x[y.len / 2];
        }
        fn main() 0.test + 1.test;
    `);

    ZERO(`
        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;

        fn test(ref init: string, ref annot: string)
            init.is_mutref && annot ||
            init.is_never  && annot || throw("noreturn");

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot).len - 4;
        }
    `);

    ZERO(`
        fn test(mut init: string) {
            init.len && init || throw("noreturn");
            return init.len;
        }

        fn main() test("woot!") - 5;
    `);

    ZERO(`
        fn is_mutref(t: string)     t.len == 6;
        fn is_never(t: string)      t.len == 5;
        let F_ARG = 1;

        fn test(ref init: string, ref annot: string, mut flags: i32) {
            init.is_mutref  || init.is_never  && annot
                            || !init && flags & F_ARG
                            || throw("noreturn");
            return flags;
        }

        fn main() {
            mut annot = "hey!";
            mut init = "woot!";
            return test(:init, :annot, 0);
        }
    `);

    ZERO(`
        fn a(a)  a ?  a : [];   // ifs used cons-type to seed alt-type
        fn b(b) !b ? [] : b;    //  which works for 'a', but not for 'b'.
        fn main() 1.a - 1.b;
    `);

    ZERO(`
        struct Type { i: i32 };
        fn is_mutref (t: Type) !!(t.i & 3);
        fn is_ref    (t: Type) !!(t.i & 1);
        fn clear_refs(t: Type) Type(t.i &~ 3);

        fn tryClearRefs(t: Type, mutref?: bool): Type =     // type-hints vs type-assertions:
            (mutref ? t.is_mutref : t.is_ref)               //  solveBlocks used within '&&' and '?'
                && clear_refs(t);                           //   so the '?' complained 'bool' doesnt assign to 'Type'

        fn main() {
            let a = tryClearRefs(Type(6), true);
            let b = tryClearRefs(Type(6), false);
            return a.i + b.i - 4;
        }
    `);

    ZERO(`
        fn ambig_or(x: i32, y: f32)
            "Hello: " ~
                <fail ambig operand non bool context>       // So it happened that at some point I had an 'a || b'
                    (x || y)                  <pass/>       //  where a and b were of the same type used in string concat like this,
                    (x || y.i32)              </fail>       //   and then later when the types no longer matched this fell back silently to a '!!a || !!b'
                ;                                           //    which was is not the intent but compiled fine because str concat also accepts bool.

        fn main() {
            mut res = ambig_or(1, 2);
            return res == "Hello: 1" ? 0 : 1;
        }
    `);

    ZERO(`
        fn unambig_or(b: bool, i: i32, f: f32)  <alt>
            b || i || f;                        <alt/>      // But currently the thinking is that so long as one operand is a bool
            i || f || b;                        </alt>      //  the whole thing should weaken to (!!a || !!b) instead of erroring out.

        fn main() = unambig_or(false, 0, 0).i32;
    `);

    ZERO(`
        struct Node { items: Node[] };

        fn isFieldChain(arg: Node) {
            if (arg.items.len > 1)
                return false;

            return !arg.items || isFieldChain(arg.items[0]);
        }

        fn main() {
            let empty       = Node();
            let chain       = Node([ Node ]);
            let not_chain   = Node([ Node, Node ]);

            return empty.isFieldChain
                && chain.isFieldChain
                && !not_chain.isFieldChain ? 0 : 1;
        }
    `);

    ZERO(`
        fn underconcat(dedupe: string, sighash: string)
            dedupe && sighash
                ? dedupe ~ '_' ~ sighash
                : dedupe || sighash;

        fn main() {
            let a   = underconcat("a", "");
            let b   = underconcat("", "b");
            let c   = underconcat("", "");
            let ab  = underconcat("a", "b");

            let res = a ~ "," ~ b ~ "," ~ c ~ "," ~ ab;
            return res == "a,b,,a_b" ? 0 : 1;
        }
    `);

    ZERO(`
        <alt>
        noinline                <alt/>
        inline    ;; GNUStmtExpr</alt>
        fn twiceUnlessEmpty(x) {
            return x && [ x, x ];
        }

        fn main() {
            return  twiceUnlessEmpty(2)
                && !twiceUnlessEmpty(0) ? 0 : 1;
        }
    `);

    ZERO(`
        fn hello(ref str) {
            str ~= "world";
            <fail condition is void 9:17+1 2:12+5>  <pass/>
            return str.len & 1;                     </fail>
        }

        fn main() {
            mut str = "hello, ";
            if (!hello(str)) str ~= "!";
            return str.len - 13;
        }
    `);

    ZERO(`
        fn test(x: i32) {
            <fail y is not defined 6:24+1>
            if (x > 1) let y = 20;      <pass/>
            let y = x > 1 && 20;        </fail>

            return x + y;
        }

        fn main() test(7) - 27;
    `);

    ZERO(`
        fn test(x: i32) {
            <fail misleading indent 5:13+3>
            if (x > 1)
            let y = 20;                 <pass/>
            let y = x > 1 && 20;        </fail>

            return x + y;
        }

        fn main() test(7) - 27;
    `);

    // /Logic and selectors.


    // Short-circuit assignment, esp. useful for maps
    //  and the cpp `map[k] = v`,
    //   which doesn't decompose safely.

    ZERO(`
        mut i = 7;
        i ||= 11;
        return i - 7;
    `);

    ZERO(`
        mut i = 0;
        i ||= 11;
        return i - 11;
    `);

    ZERO(`
        mut a = 1;
        mut b = 0;
        a ||= ++b;
        return  b;
    `);

    ZERO(`
        mut CHANGE = false;
        CHANGE ||= true;
        return CHANGE.i32 - 1;
    `);

    LEGACY_Map(currently: "Map is not defined", `
        mut m: Map(string, string);
        mut g = 0;

        m["hello"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g;
    `);

    LEGACY_Map(currently: "Map is not defined", `
        mut m: Map(string, string);
        mut g = 0;

        m["_not_hello_"] = "world";
        fn f() {
            g++;
            return "cruel world";
        }

        m["hello"] ||= f();
        return g - 1;
    `);

    ZERO(`
        fn and_incr(ref x: i32, v: i32)
            x &&= x + v;

        fn main() {
            mut x: i32 = 0;
            and_incr(x, 10);
            return x;
        }
    `);


    // Lints.

    ZERO(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        <fail orphan>
        t.test;             <pass/>
        t.test();           </fail>
        return t.x - 1;
    `);

    ZERO(`
        {
            {
                return 0;
            }
        }
    `);

    ZERO(`
        {
        <fail block>
        {
            return 0;
        }
        <pass/>
            {
                return 0;
            }
        </fail>
        }
    `);

    ZERO(`
        {
            return 0;
        }
    `);

    ZERO(`
        {
            return 0;
        <fail block>
       }
        <pass/>
        }
        </fail>
    `);

    ZERO(`
        {
            return 0;
        <fail block>
         }
        <pass/>
        }
        </fail>
    `);

    ZERO(`
        let y = [ 1 ];              ;; TODO fu::slate<1, int> y
        let <fail unused><pass/>lax</fail>
            z = [ 2 ];              ;; TODO fu::slate<1, int> z

        return y[0] - 1
    `);

    ZERO(`
        fn fail(a: string) throw("hey: " ~ a);
        fn hello(a: string,
            <fail unused><pass/>lax</fail>
            b: string)
                a && fail(a) ? b : a;

        fn main() hello("", "nope").len;
    `);

    ZERO(`
        fn incr(ref x: i32) x++;
        fn lints_ambig_expr_indent(ref a: i32, ref b: i32) {
            return a.incr
            <fail indent>
            +
            <pass/>
              +
            </fail>
                b.incr;
        }

        fn main() {
            mut a = 0; mut b = 0;
            lints_ambig_expr_indent(a, b);
            return a - b;
        }
    `);

    ZERO(`
        fn lints_ambig_jump_semis(mut x: i32) {
            <fail indent>
            return
            x;
            <pass/>
            return x;
            </fail>
        }

        fn main() 0.lints_ambig_jump_semis;
    `);

    ZERO(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || <fail parenthes left side>
                              a = A(incr(a));    <pass/> // Lint should complain here,
                             (a = A(incr(a)));   </fail> //  this was an honest mistake.

        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn test(is_mutref: bool, args: i32[], ref sum: i32) {
            <fail indent else>
            if (is_mutref)
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];
            <pass/>
            if (is_mutref) {
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 1)
                        sum += args[i];
            }
            </fail>
            else
                for (mut i = 0; i < args.len; i++)
                    if (args[i] & 2)
                        sum += args[i];
        }

        fn main() {
            mut sum = 0;
            test(true , [ 1,  2,  3  ], sum);
            test(false, [ 11, 22, 33 ], sum);
            return sum - 1 - 3 - 11 - 22;
        }
    `);

    ZERO(`
        //
        // The -1.abs problem.
        //
        // Ruby lexes the minus into the numeric literal.
        //  This is kinda inconsistent, altough it does make sense.
        //
        // Rust & all c-likes lex to -abs(1).
        //  Rust linters warn about this.
        //
        // One thing we can do is change the precedence of some unaries
        //  to above method call - others, like ! benefit from usual precedence.
        //   In my experience, the unary * op in c/cpp always disappoints re: precedence,
        //    but the & op usually works the way you want it to.
        //     So introducing more precedence rules is a really questionable idea.
        //
        // We'll go the rust way for starters,
        //  this will be a compile time error for now.
        //
        fn test()   <fail parenthes explicit>
            -1.0    <pass/>
            (-1.0)  </fail>
                .abs;

        fn main() test ? 0 : 7;
    `);

    ZERO(`
        fn id(x) = x;
        fn main() {
            return id(
                0 +
            <fail ambig indent>
               0  <pass/>
                0 </fail>
            );
        }
    `);

    ZERO(`
        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            doStuff(
                <alt>
                stuff: |_?| {
                <alt/>
                stuff: |_?|
                {
                <alt/>
                stuff: |
                    _?| {
                <alt/>
                stuff: |
                    _?|
                {
                </alt>
                    return 0;
                });
        }
    `);

    ZERO(`
        fn doStuff(stuff) {
            stuff();
        }

        fn main() {
            <alt>
            doStuff(stuff: || {
            <alt/>
            doStuff(stuff: ||
                {
            </alt>
                    return 0;
                });
        }
    `);


    // Borrow checker.

    ZERO(`
        noinline fn test(ref a: i32, ref b: i32) {
            return (++a) + 10 * (++b);                          ;; N_AARMustSeq
        }

        fn main() {                                             ;; N_AARSoftRisk
            mut x = 0;
        <alt>
            let z = test(x, x);
        <alt/>
            ref y = x;
            let z = test(x, y);
        </alt>
            return x == 2 && z == 21 ? 0 : 1;
        }
    `);

    ZERO(`
        noinline fn test_inner(ref a: i32, ref b: i32)
            (++a) + 10 * (++b);                                 ;; N_AARMustSeq

        noinline fn test_outer(ref a: i32, ref b: i32)
            test_inner(a, b);

        fn main() {                                             ;; N_AARSoftRisk
            mut x = 0;
        <alt>
            let z = test_outer(x, x);
        <alt/>
            ref y = x;
            let z = test_outer(x, y);
        </alt>
            return x == 2 && z == 21 ? 0 : 1;
        }
    `);

    ZERO(`
        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) {
                <fail invalidate 9:13 6:19>
                a ~= 1; // Invalidates 'b'.
                <pass/>
                b++;
                </fail>
            }
            b++;
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }
    `);

    ZERO(`
        nocopy struct nci32 { i: i32; };

        noinline fn test(ref a: nci32, b: nci32) a.i++ || b.i;
        fn main() {
            mut x = nci32(0);
            <fail arguments b and a both alias var x 6:17+1>
            ref y = x;                        <pass/>
            let y = nci32(0);                 </fail>

            return test(x, y);
        }
    `);

    ZERO(`
        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            if (a.len & 1) { // Lets be extra sure here.
                <fail invalidate 7:17 6:19>
                a ~= 1; // Invalidates 'b'.
                b++;
                <pass/>
                b++;
                a ~= 1;
                </fail>
            }
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 3;
        }
    `);

    ZERO(`
        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                b++; // Same thing but reordered as a loop.
                if (a.len & 3) {
                    <fail inval next iter 9:23 6:17>
                    a ~= 1; // Invalidates 'b'.
                    <pass/>
                    b++;
                    </fail>
                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 105;
        }
    `);

    ZERO(`
        noinline fn test(ref a: i32[]) {
            ref b = a[0];
            for (mut i = 2; i --> 0; )
            {
                if (i & 1) {
                    b += 2; // Same thing but reordered as a loop.
                }
                else {
                    <fail inval next iter 11:23 7:21>
                    a ~= 1; // Invalidates 'b', same as a above, but now in an if/else -
                    <pass/> //  got the used-in-a-loop stuff wrong when switching to cant_invalidate.
                    b += 3;
                    </fail>
                }
            }
            a ~= 100; // Invalidates 'b' but that's fine!
        }

        fn main() {
            mut arr = [ 1 ]; test(arr);
            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 106;
        }
    `);

    ZERO(`
        // both args alias, but there's no risk of inval.
        noinline fn incr_a_or_b(ref a: i32, ref b: i32)
            (a || b)++;

        fn main() {
            mut Z = 0;
            mut A = 1;
            mut B = 0;

            incr_a_or_b(Z, B); // incr B, now 1
            incr_a_or_b(A, B); // incr A, now 2
            incr_a_or_b(B, B); // incr _target, now 2 // alias!

            return (100*A + B) - 202;
        }
    `);

    ZERO(`
        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            ref c = a || b;
            return ++++c - 3; // double mutation of a union
        }
    `);

    ZERO(`
        struct V { v: i32; };

        fn main() {
            mut A: V = [ 1 ];
            ref a = A.v;
            ref b = A.v;
            return ++++(a || b) - 3; // same, without a helper var
        }
    `);

    ZERO(`
        struct V { v: i32; w?: i32; ww?: i32; };

        fn main() {
            mut A: V = [ 1 ];
            mut B: V = [ 1 ];

            <fail invalidate 20:20 18:15>
            ref aa = A.v || A.w; <pass/>
            fn  aa = A.v || A.w; </fail>

            ref bb = B.v || B.w;
            ++++bb;

            ref a = A.v || A.ww;
            ref b = B.v || B.ww;

            ref c = a || b;
            ++++c;

            return aa - 3; // same, without a helper var
        }
    `);

    ZERO(`
        // a can alias b
        // c can alias d
        noinline fn ab_cd(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        fn main() {
            mut ab = 0;
            mut cd = 0;

            <fail alias>
            ab_cd(ab, cd, ab, cd); <pass/>
            ab_cd(ab, ab, cd, cd); </fail>

            return ab - cd;
        }
    `);

    ZERO(`
        struct X { i: i32; j: i32; };
        // a can alias b
        // c can alias d
        noinline fn ab_cd_defer(ref a: X, ref b: X, ref c: X, ref d: X, j?: bool) {
            ref ab = a || b;
            defer {
                ref abi = j ? ab.j : ab.i;
                ++++abi;
            }
            ref cd = c || d;
            ref cdi = j ? cd.j : cd.i;
            ++++cdi;
        }

        fn main() {
            mut ab = X(0, 0);
            mut cd = X(0, 0);

            <fail alias>
            ab_cd_defer(ab, cd, ab, cd); <pass/>
            ab_cd_defer(ab, ab, cd, cd); </fail>

            return ab.i - cd.i;
        }
    `);

    ZERO(`
        // a can alias b
        // c can alias d
        noinline fn ab_cd_inner(ref a: i32, ref b: i32, ref c: i32, ref d: i32) {
            ref ab = a || b;
            ref cd = c || d;
            ++++ab;
            ++++cd;
        }

        noinline fn ab_cd_outer(ref a: i32, ref b: i32, ref c: i32, ref d: i32)
            ab_cd_inner(a, b, c, d);

        fn main() {
            mut ab = 0;
            mut cd = 0;

            <fail alias>
            ab_cd_outer(ab, cd, ab, cd); <pass/>
            ab_cd_outer(ab, ab, cd, cd); </fail>

            return ab - cd;
        }
    `);

    ZERO(`
        // a can alias b
        // c can alias d
        // e can alias f
        // g can alias h
        noinline fn abcd_efgh(
            ref a: i32, ref b: i32, ref c: i32, ref d: i32,
            ref e: i32, ref f: i32, ref g: i32, ref h: i32)
        {
            ref ab = a || b; ref cd = c || d; ref abcd = ab || cd;
            ref ef = e || f; ref gh = g || h; ref efgh = ef || gh;
            ++++abcd; ++++ab; ++++cd;
            ++++efgh; ++++ef; ++++gh;
        }

        fn main() {
            mut ab = 0; mut cd = 0;
            mut ef = 0; mut gh = 0;

            <fail alias var cd 17:29+2>
            abcd_efgh(ab, ab, cd, gh, ef, ef, cd, gh); <pass/>
            abcd_efgh(ab, ab, cd, cd, ef, ef, gh, gh); </fail>

            return (ab + cd) - (ef + gh);
        }
    `);

    ZERO(`
        noinline fn incr_a_or_b_and_b_or_a(ref a: i32, ref b: i32) {
            ref x = a || b; ++x;
            ref y = b || a; ++y;                                ;; N_AARSoftRisk
        }

        fn main() {
            mut a = 0;

            <alt>
            incr_a_or_b_and_b_or_a(a, a);
            <alt/>
            ref b = a;
            incr_a_or_b_and_b_or_a(a, b);
            </alt>

            return a - 2;
        }
    `);

    ZERO(`
        // same as below -
        //  but using a helper variable
        //   which provides a "name" for the outcome of a|b.
        noinline fn incr_a_or_b_by2_via_x(ref a: i32, ref b: i32) {
            ref x = a || b;
            ++++x;
        }

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2_via_x(Z, B); // incr B, now 2
            incr_a_or_b_by2_via_x(A, B); // incr A, now 4
            incr_a_or_b_by2_via_x(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }
    `);

    ZERO(`
        // same as above -
        //  but notice we increment twice, which breaks current setup.
        noinline fn incr_a_or_b_by2(ref a: i32, ref b: i32)
            ++++(a || b);

        fn main() {
            mut Z = 0;
            mut A = 2;
            mut B = 0;

            incr_a_or_b_by2(Z, B); // incr B, now 2
            incr_a_or_b_by2(A, B); // incr A, now 4
            incr_a_or_b_by2(B, B); // incr _target, now 4 // alias!

            return (100*A + B) - 404;
        }
    `);

    ZERO(`
        noinline fn alias(ref arr: i32[], ref item: i32) {
            arr ~= 1;
            return item;
        }

        fn main() {
            mut a = [ 0 ];
            <fail alias>
            ref c = alias(a, a[0]);
            <pass/>
            mut b = [ 0 ];
            ref c = alias(a, b[0]);
            </fail>
            return c++;
        }
    `);

    ZERO(`
        noinline fn test(ref a: i32[], ref b: i32[]) {
            <fail invalidate 7:28 6:30>
            ref aa = a[0]; <pass/>
            fn  aa() a[0]; </fail>

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            ref cc = bb || aa;     // Mustn't compile.
            return cc;
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }
    `);

    ZERO(`
        noinline fn test(ref a: i32[], ref b: i32[]) {
            <fail invalidate 7:26 6:30>
            ref aa = a[0]; <pass/>
            fn  aa() a[0]; </fail>

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return bb || aa;       // Same as above, but no explicit binding.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }
    `);

    ZERO(`
        noinline fn noop(x) x;
        noinline fn test(ref a: i32[], ref b: i32[]) {
            <fail invalidate 8:31 7:30>
            ref aa = a[0]; <pass/>
            fn  aa() a[0]; </fail>

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return noop(bb || aa); // Same as above, but bound at callsite.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }
    `);

    ZERO(`
        noinline fn either(a, b) a || b;
        noinline fn test(ref a: i32[], ref b: i32[]) {
            <fail invalidate 8:31 7:30>
            ref aa = a[0]; <pass/>
            fn aa()  a[0]; </fail>

            ref bb = b[0]; a ~= 1; // Invalidates 'aa' if ref.
            return either(bb, aa); // For completeness.
        }

        fn main() { mut a = [ 0 ]; mut b = [ 0 ]; return test(a, b); }
    `);

    ZERO(`
        noinline fn what(ref cond: i32, ref cons: i32)
            cond && (cons += 1);

        fn main() {
            mut x = 1;
            return what(x, x) - 2;
        }
    `);

    ZERO(`
        struct Target {
            overload: i32[];
            extended: i32[];
        };

        noinline fn which(ref t: Target, i: i32) i & 1
            ? t.overload
            : t.extended;

        fn test(ref target: Target)
        {
            ref overload = target.which(target.overload.len);
            ref extended = target.which(target.overload.len + 1);

            mut change = false;
            if (overload)
            {
                for (mut i = 0; i < overload.len; i++)
                {
                    let a = overload[i];
                    let b = extended[i];
                    if (a != b)
                    {
                        change = true;
                        break;
                    }
                }
            }

            if (change)
            {
                extended[0] = 3;

                shadow ref overload = target.which(target.overload.len);
                overload[0] = 5; // Said write to overload invalidates ext on next loop iter.
            }
        }

        fn main()
        {
            mut target = Target([ 0 ], [ 1 ]);
            target.test();
            return target.overload[0] * 10 + target.extended[0] * 100 - 350;
        }
    `);

    ZERO(`
        fn test(ref a: i32, ref b: i32) {
            a += b;
            b += a;
        }

        struct AB { a: i32; b: i32 };

        fn main() {
            mut ab = AB(1, 2);
<fail test:a test:b both alias ab 16:21+1>
        <alt>
            ref a = ab.a;
            ref b = ab.a;
        <alt/>
            ref a = ab.b;
            ref b = ab.b;
        </alt>
            test(a, b);
<pass/>
        <alt>
            ref a = ab.a;
            ref b = ab.b;
            test(a, b);
        <alt/>
            ref a = ab.a;
            test(a, ab.b);
        <alt/>
            test(ab.a, ab.b);
        </alt>
</fail>
            return ab.b - 5;
        }
    `);

    TODO_borrowck(currently: "ref old 7:23+3", `
        struct Helper { vars: i32[]; };

        fn test(ref _helpers: Helper[], helpers_idx: i32) {
            ref old = _helpers[helpers_idx - 1].vars;
            ref new = _helpers[helpers_idx    ].vars;
            new    ~= old[helpers_idx];
        }

        fn main() {
            mut helpers = [ Helpers([ 1, 2 ]), Helpers([ 4, 8 ]) ];
            test(helpers, 1);
            return helpers[1][2] - 2;
        }
    `);

    ZERO(`
        fn outer() {
            mut sum = 0;
            mut x = 1;
            for (;;) {      // bck complained that the write to 'x' at the end
                let v = x;  //  invalidates use of 'v' on next loop iter here, which is not true
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return sum;
                }

                x = v * 2;
            }
        }

        fn main() outer - 42;
    `);

    ZERO(`
        fn append_self(ref a: i32[])
        {
            let b = a;
            a ~= b; // b narrowed down to a slice which is non-copyable
                    //  but it (unfortunately) wanted to copy to a temp.
        }

        fn main() {
            mut arr = [1, 2];
            arr.append_self();
            return arr[2] + arr[3] - 3;
        }
    `);

    ZERO(`
        fn but_is_it_pure(ref x: i32) {
            <fail not pure 6:9 8:34 4:21>
            return x++; <pass/>
            return x;   </fail>
        }
        pure fn pure_fn(ref a: i32, ref b: i32) {
            ref x = a || b;
            return but_is_it_pure(x);
        }
        fn main() {
            mut x = 0;
            mut y = 0;
            return pure_fn(x, y);
        }
    `);

    ZERO(`
        noinline fn inner(ref x: i32, n: i32) {
            return outer(x, n);
        }

        noinline fn report_write_here(ref x: i32, n: i32) {
            <fail outer 24:25 report_write_here 16:45 += 8:22>
            return x += n;                             <pass/>
            return x + n;                              </fail>
        }

        noinline fn outer(ref x: i32, n: i32) {
            if (n & 3) {
                if (n & 2)
                    return inner(x, n / 2);
                else
                    return report_write_here(x, n);
            }
            else {
                return inner(x, n + 1);
            }
        }

        pure fn not_pure(ref x: i32, n: i32) {
            return outer(x, n);
        }

        fn main() {
            mut x = 0;
            return not_pure(x, 0) == 1 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            mut _info: string[];

            pure fn fail(mut reason: string = "") {
                for (mut i = _info.len; i --> 0; ) {
                    ref info = _info[i]; // notice the ref, has to relax away
                    reason ~= info<alt> && i<alt/> ? i : []</alt>;
                }

                return reason;
            }

            return fail.len;
        }
    `);

    ZERO(`
        fn main() {
            mut _info = [ 101 ];

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info<alt> && ("" ~ info)<alt/> ? ("" ~ info) : []</alt>;
                return reason;
            }

            return fail.len - 3; // "101".len is 3.
        }
    `);

    ZERO(`
        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_H(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_H(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }
    `);

    ZERO(`
        struct Helpers { row: i32[]; };

        fn test(ref _helpers: Helpers[], mut N: i32, row: i32)
        {
            fn solveNode_HH_inner(h: Helpers) {
                while (N % h.row[h.row.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveNode_HH(h: Helpers) {
                return solveNode_HH_inner(h);
            }

            fn solveJump() {
                solveNode_HH(_helpers[row]);
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [ Helpers([ 1, 2, 3, 4, 5 ]) ];
            return test(_helpers, row: 0, N: 4)
        }
    `);

    ZERO(`
        fn test(ref _helpers: i32[][], mut N: i32, row: i32)
        {
            fn solveNode_a(h: i32[]) {
                while (N % h[h.len - 1]) {
                    N--;
                    _helpers.grow(_helpers.len * 2);
                }
            }

            fn solveJump() {
                solveNode_a(_helpers[row]); // We've relaxed to a view, which bck can't copy
                return _helpers.len;
            }

            return solveJump() - 1 * 2*2*2*2;
        }

        fn main()
        {
            mut _helpers = [[ 1, 2, 3, 4, 5 ]];
            return test(_helpers, row: 0, N: 4)
        }
    `);

    ZERO(`
        struct Arg { i: i32; };

        // A mutref fail.
        fn mutargs(args: &mut Arg[])
        {
            // This miscompiles to ref into args,
            //  after which we invalidate the reference.
            //
            <fail inval badref>
            ref <pass/>
            mut </fail> badref = args[0];

            args = [ Arg(11) ]; // INVALIDATE badref.
            return badref;
        }       // oct2021: now latest issue here is that
                //  this gets bcked AFTER jump lifetimes are unwound
                //   and it all looks as if everything's fine (lt badref == lt args).

        fn main()
        {
            mut args = [ Arg(7) ];
            return mutargs(args).i - 7;
        }
    `);

    ZERO(`
        struct Arg { i: i32[]; };

        fn witharg(using a: Arg)
            i[i.len - 1] * 4;

        fn mutargs(args: &mut Arg[]) {
            <fail invalidate badref>
            ref <pass/>
            let </fail> badref = args[0];

            args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            return witharg(badref);
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }
    `);

    ZERO(`
        struct Arg { i: i32[]; };

        fn witharg(using a: Arg, x: i32)
            i[i.len - 1] * x;

        fn mutargs(args: &mut Arg[]) {
            <fail inval badref>
            ref <pass/>
            let </fail> badref = args[0];

            for (mut i = 0;; i++) {
                let ret = witharg(badref, i * 4);
                if (ret)
                    return ret;

                args = [ Arg([ 11 ]) ]; // INVALIDATE badref.
            }
        }

        fn main() {
            mut args = [ Arg([ 7 ]) ];
            return mutargs(args) - 28;
        }
    `);

    ZERO(`
        fn test(ref woot: i32[], x: i32, y: i32) {
            ref b = woot[y];
            ref a = woot[x]; // the 'shadow ref' below ...
            if (a == 1) {
                <fail invalidate write to woot at 4:25>
                <pass/>
                shadow ref a = woot[x]; // ... should relax 'ref a' above to a let ...
                </fail>
                a += 1;
            }
            else {
                b += 1; // ... and this should ignore cond write above.
            }
        }

        fn main() {
            mut x = [ -1, +1 ];
            test(x, 0, 1);
            return x[1] - 2;
        }
    `);

    ZERO(`
        fn test(ref a: i32[], ref b: i32[]) {
            <alt>
            if (a[0]++ == 1)                                    ;; N_AARSoftRisk
            <alt/>
            if (a[0] == 1)
            </alt>
                a ~= 1;
            else
                b ~= 1;
        }

        fn main() {
            mut x = [ 1 ];
            test(x, x);
            return x.len - 2;
        }
    `);

    ZERO(`
        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w: Woot) {
            ref x = w.x;
            <fail cannot access x 9:13+1 inval write y 8:15+2>
            ref y = w.x; <pass/>
            ref y = w.y; </fail>
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w = Woot([ 1, 2, 3, 4, 5, 6, 7 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            test(w);
            return w.x.len - 25;
        }
    `);

    TODO_disjoint(currently: "arguments test:w1 and test:w0 14:21+1 both alias var w 13:17+1", `
        nocopy struct Woot { x: i32[]; y: i32[] };

        fn test(ref w0: Woot, ref w1: Woot) {
            ref x = w0.x;
            <fail arguments test:w1 and test:w0 14:21+1 both alias var w 13:17+1>
            ref y = w1.x; <pass/>
            ref y = w1.y; </fail> // <- doesnt realize w0.x can't alias w1.y
            y ~= y; // <- DONT RESOLVE BY COPY! ref can relax to let
            x ~= y;
        }

        fn main() {
            mut w: Woot;
            test(w, w);
            return w.x.len;
        }
    `);

    ZERO(`
        fn indexIntoImplicit(j: i32, implicit strings: string[]) strings[j];

        fn selfRecurBeforeImplicitDep(x: i32)
        {
            // On second solve we're talking about a region, but the argnode is gone.
            fn T(i: i32) selfRecurBeforeImplicitDep(i / 2);
            if (x > 1) return T(x);
            return indexIntoImplicit(x);
        }

        fn main() {
            let implicit strings = [ "a", "b" ];
            return selfRecurBeforeImplicitDep(2) == "b" ? 0 : 1;
        }
    `);

    ZERO(`
        <fail arg a 27:42+1 inval by subseq write injected arg out 27:48+1 via grow 8:21+1>
        nocopy                 <pass/></fail>
        struct Type       { canon: string; };
        struct SolvedNode {  type: Type;   };

        fn solved(type: Type, implicit ref out: SolvedNode[]) {
            out.grow(out.len * 100 + 1);

            ref tail = out[out.len - 1];
            tail.type.canon = type.canon;
            return tail;
        }

        fn createMap(a: Type, b: Type): Type {
            return Type(a.canon ~ b.canon);
        }

        fn evalTypeAnnot(nodes: string[]): SolvedNode
        {
            fn T(i: i32)
                evalTypeAnnot([ nodes[i] ]).type;

            // Each T() call should invalidate the results from previous T() calls -
            //  so this shouldn't compile if Type is nocopy.
            if (nodes.len > 1)
                return solved(createMap(T(0), T(1)));           ;; PointlessMustSeq

            return solved(Type(nodes[0]));
        }

        fn main() {
            implicit mut out: SolvedNode[];
            let annot = evalTypeAnnot([ "a", "b" ]);
            return out.len == 10101 && annot.type.canon.len == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            mut x = 0;
            let s = ++x + ++x;
            return s - 3; // Not 4! one arg must invalidate
        }
    `);

    ZERO(`
        <fail arg inval subsequent write 14:23 14:26+4 14:34+4 8:16+2>
        nocopy <pass/></fail>
        struct X { x: i32; }
        fn sum(a: X, b: X) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn main() {
            mut x: X;
            return sum(x.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }
    `);

    ZERO(`
        <fail arg inval subsequent write 23:23 23:26+4 23:34+4 16:18+2>
        nocopy <pass/></fail>
        struct X { x: i32; }
        struct Y { y: X;   }

        fn x(y: Y) y.y.x;
        fn sum(a, b) a.x + b.x;

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn incr(ref y: Y) {
            y.y.x++;
            return y;
        }

        fn main() {
            mut x: Y;
            ref y = x.y;
            return sum(y.incr, x.incr) - 3; // Not 4! one arg must invalidate
        }
    `);

    ZERO(`
        <fail arg inval subsequent write 19:27+2 19:33+4 19:22+4 7:16+2>
        nocopy <pass/></fail>
        struct X { x: i32; };

        fn incr(ref x: X) {
            x.x++;
            return x;
        }

        fn +=(a: X, b: X) {
            // Notice, this is not a real +=,
            //  just checking the order of eval here.
            return a.x + b.x;
        }

        fn test(ref x: X, ref y: X) {
            ref xy = y || x;
            return x.incr += xy.incr; // <- xy invalidated by x.incr
        }

        fn main() {
            mut x: X;
            mut y: X;
            return test(x, y) - 3;
        }
    `);

    TODO_move(currently: "cannot be copied or moved 6:38+1", `
        <alt>
        nocopy
        </alt>
        struct X { items: i32[]; };
        fn popfirst(mut arr: X[]) arr[0]; // mcom_BlockReturn after relax: arr[] adds 'static
        fn main() popfirst([ X() ]).items.len;
    `);

    ZERO(`
        struct AB { a: i32[][]; b: i32[][]; };

        fn problematic_moves(mut ab: AB) {
            ref ra = ab.a;
            return ra.len & 1 ? ra[0] : ab.b[0];
        }

        fn main() {
            mut ab = AB(
                [[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]],
                [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]);

            mut pick = ab.problematic_moves;
            return pick[9] - ab.a[0][9];
        }
    `);

    ZERO(`
        <fail cannot be copied or moved 20:31>
        nocopy <pass/></fail>
        struct NC { x: i32; y: i32 };

        fn wants_val(mut a: NC) {
            a.x++;
            a.y++;
            return a;
        }

        fn incr_by(mut a: NC, b: NC) {
            a.x += b.x;
            a.y += b.y;
            return a;
        }

        fn main() {
            mut v = NC(-1, -1);
            mut w = wants_val(v);
            return (w || v).x + 1;
        }
    `);

    ZERO(`
        nocopy struct SolvedNode {
            items: SolvedNode[];
        };

        fn test(mut a: SolvedNode, mut b: SolvedNode) {
            <alt>
            ref n = a || b;
            <alt/>
            ref n = a.items ? a : b;
            </alt>
            return n;
        }

        fn main() test([], []).items.len;
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct SolvedNode { len: i32; }

        fn createBlock(mut last: SolvedNode) {
            let tail     = last || last;
            let unwrap   = tail || tail;
            last.len--;
            return unwrap;
        }

        fn main() {
            return createBlock([]).len;
        }
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct SolvedNode { items: SolvedNode[] };

        fn popAndOr(ref node: SolvedNode) {
            let N = node.items.len;

            let pop = node.items[N - 1];
            if (N > 2) {
                node.items.pop();
            }
            else {
                let head = node.items[0];
                node = head;
            }

            return pop;
        }

        fn main() {
            mut a = SolvedNode([ SolvedNode, SolvedNode ]);
            let b = a.popAndOr();
            return a.items.len + b.items.len;
        }
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct Items {
            len: i32;
        }

        struct SolvedNode {
            items: Items;
        }

        struct Nodes {
            last: SolvedNode;
        }

        fn pop(ref n: Nodes) {
            n.last.items.len--;
        }

        fn createBlock(mut items: Nodes) {
            let tail = items.last;
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock(Nodes(SolvedNode([]))).len;
        }
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct SolvedNode {
            items: SolvedNode[];
        };

        // Reducing the thing below.
        fn createBlock(mut items: SolvedNode[]) {
            let tail = items[items.len - 1];
            let unwrap = tail.items;
            items.pop();
            return unwrap;
        }

        fn main() {
            return createBlock([ SolvedNode ]).len;
        }
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as below but mut.
        fn createBlock(mut items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1]; // const-indexed but generated mutref tail, must be F_RRET?
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items;
                items.pop();
                return unwrap;
            }

            return [];
        }

        fn main() {
            return createBlock([]).len;
        }
    `);

    ZERO(`
        <fail cannot access invalidated>
        nocopy            <pass/></fail>
        struct SolvedNode {
            kind: string;
            items: SolvedNode[];
        };

        // Same as above but ref.
        fn createBlock(ref items: SolvedNode[]) {
            if (items.len) for (;;) {
                let tail = items[items.len - 1];
                if (tail.kind != "block")
                    break;

                let unwrap = tail.items; // unwrap needs to copy here
                items.pop(); ////////////// <- nuked here, but ignored!
                return unwrap;
            }

            return [];
        }

        fn main() {
            mut items: SolvedNode[];
            return createBlock(items).len;
        }
    `);

    ZERO(`
        fn test(ref a: i32[]) = a.swap(0, 1);

        fn main() {
            mut nums = [1, 2];
            nums.test();
            return nums.len == 2 && nums[0] == 2 && nums[1] == 1
                 ? 0
                 : 1;
        }
    `);

    TODO_unique(currently: "arg a 3:21+1 inval by subseq write arr 3:29+1", `
        fn Swap(ref arr: i32[], x: i32, y: i32)
            swap(arr[x], arr[y]);

        fn main() {
            mut a = [ 1, 2 ];
            a.Swap(0, 1);
            return a[0] - 2 == 0 && a[1] - 1 == 0 ? 0 : 1;
        }
    `);

    ZERO(`
        fn test(ref arg: i32[]) {
            let encloses_unchanged = arg;

            fn closure()
                for (mut i = 0; i < arg.len; i++)
                    arg[i] += encloses_unchanged[i];

            closure();
            if (arg.len & 1)
                closure();
        }

        fn main() {
            mut a = [ 3 ];
            test(a);
            return a[0] - 9;
        }
    `);

    ZERO(`
        inline fn must_not_return_ref_or_view(ref x: i32[][]) {
            let y = x[100];
            x.shrink(y.len);
            return y;
        }

        fn main() {
            mut arr: i32[][];
            arr.grow(101);
            arr[100] = [ 7 ]
            return arr.must_not_return_ref_or_view()[0] - 7;
        }
    `);

    ZERO(`
        struct HasVec { x: i32[] };
        inline fn last(x: i32[]) x[x.len - 1];                  ;; GNUStmtExpr

        <alt>
        inline                                                  ;; GNUStmtExpr
                                                                ;; PointlessLocal
        </alt>
        fn will_return_value(ref x: HasVec) {
            let bck_will_cpy = x;

            let vec0 = bck_will_cpy.x;
            if (bck_will_cpy.x.len & 1)
                return vec0;

            x.x ~= x.x.len;
            let vec1 = bck_will_cpy.x;
            return vec1;
        }

        fn main() {
            mut x = HasVec([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
            return will_return_value(x).last/*9*/ - x.x.last/*10*/ + 1;
        }
    `);

    ZERO(`
        fn PASS_borrowCheck_incr_a_ret_b(ref a: i32, ref b: i32) {
            a++;        // we're done writing to a before
            return b;   //  EXTRA DRAMA: we dont cg const refs for primitives right now
        }

        fn main() {
            mut x = 5;
            PASS_borrowCheck_incr_a_ret_b(x, x);
            return x - 6;
        }
    `);

    ZERO(`
        fn PASS_borrowCheck_reduct(ref a: i32, ref b: i32[])
        {
            // If this were (ref!b a, ref b):
            //
            // When a points into b:
            //  - a++ read ok, write ok
            //   - b read ok, write ok + invalidates a
            //    - a not usable from here on
            //
            // The point is we should be able to deduce this automatically,
            //  if nothing a-related is used after b gets used for the first time,
            //   then we're fine if b aliases a ...
            //
            // ... EXCEPT that's if b doesn't acceptTempCopies -
            //  meaning it's either F_IMPLICIT or F_REF -
            //   otherwise there's ambiguity.
            //
            a++;
            b ~= 10;
        }

        fn main() {
            mut arr = [ 9 ];
            PASS_borrowCheck_reduct(arr[0], arr);               ;; PointlessMustSeq
            return arr[0] - arr[1];
        }
    `);

    ZERO(`
        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        fn PASS_borrowCheck(ref root: Node) {
            mut n: i32;
            fn count(id: i32)
                traverse(root): |i|
                    if (i.id == id)
                        n++;

            fn check(ref node: Node) {
                if (node.items)
                    for (mut i = 0; i < node.items.len; i++)
                        check(node.items[i]);                   ;; PointlessMustSeq
                else
                    count(node.id++);
            }

            check(root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }
    `);

    ZERO(`
        fn check(implicit root: i32[], node: i32[])
            root.len - node.len;

        fn PASS_borrowCheck(        <fail because of 2:27+4 NOT implicit arg root 6:22+4>
                     root: i32[])   <pass/>
            implicit root: i32[])   </fail>
                check(root);

        fn main()
            [ 1, 2, 3 ].PASS_borrowCheck();
    `);

    ZERO(`
        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but not a closure.
        fn count(id: i32, implicit root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        fn check(ref node: Node) {
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(node.items[i]);                   ;; PointlessMustSeq
            else
                count(node.id++);
        }

        fn PASS_borrowCheck(implicit ref root: Node) {
            implicit mut n: i32;
            check(root); // <- Usage intersection failure: Node & Node
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }
    `);

    ZERO(`
        struct Node { id: i32; items?: Node[]; };

        fn traverse(node: Node, visit) {
            visit(node);
            for (mut i = 0; i < node.items.len; i++)
                traverse(node.items[i], fn visit);
        }

        // Same as above, but no implicits.
        fn count(id: i32, ref root: Node, implicit ref n: i32)
            traverse(root): |i|
                if (i.id == id)
                    n++;

        // AAR: check(ref node, ref root) accepted,
        //       but (ref root, ref node) rejected.
        <alt>
        fn check(ref root: Node, ref node: Node) { <alt/>
        fn check(ref node: Node, ref root: Node) { </alt>
            if (node.items)
                for (mut i = 0; i < node.items.len; i++)
                    check(:root, node.items[i]);                ;; PointlessMustSeq
            else
                count(:root, node.id++);
        }

        fn PASS_borrowCheck(ref root: Node) {
            implicit mut n: i32;
            check(:root, root);
            return n;
        }

        fn main() {
            mut tree = Node(0, [ Node(2), Node(2) ]);
            return PASS_borrowCheck(tree) - 1;
        }
    `);

    ZERO(`
        pub fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn grow_if_oob_to_len_from_self(ref arr: i32[], idx: i32)
            arr.grow_if_oob(arr[idx]); // i was F_REF for some reason

        fn main() {
            mut arr = [3];
            arr.grow_if_oob_to_len_from_self(0) = 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 5;
        }
    `);

    ZERO(`
        fn used_in_a_loop__invalidated__by_new_var(
            ref arr: i32[], ref barr: i32[], ref carr: i32[])
        {
            ref head = arr[arr.len - 1];
            for (mut i = 0; i < arr.len; i++) {
                head += arr.len;
                let head_cpy = head + 0;
                ref barrcarr = barr || carr;
                barrcarr.resize(head_cpy);
            }
        }

        fn main() {
            mut arr = [ 1 ];

            <fail both alias arr 15:17+3>
            ref barr = arr; <pass/>
            mut barr = arr; </fail>

            used_in_a_loop__invalidated__by_new_var(arr, barr, barr);
            return barr.len == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];

            <fail arg 3 x 2 brr both alias 20:51>
            ref x = brr[0];               <pass/>
            mut x = 0;                    </fail>

            return two_writes_in_an_arg(arr, brr, x);
        }
    `);

    ZERO(`
        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref what: i32, ref to: i32) to = what;

        fn two_writes_in_an_arg(ref arr: i32[], ref brr: i32[], ref x: i32)
            assign( what: x ? arr.grow_if_oob(10)
                            : brr.grow_if_oob(10), to: x );

        fn main() {                         <flip>
            mut zero = 0;
            mut empty: i32[];               <flip/>
            mut arr = [ 0, 1, 2, 3 ];
            mut brr = [ 0, 2, 4, 6 ];       </flip>

            <fail arg 3 x 2 brr both alias 25:58+8>
            ref x = brr[0];                 <pass/>
            mut x = 0;                      </fail>

            ref opaque_x    = brr.len > arr.len ? zero  : x;
            ref opaque_brr  = brr.len > arr.len ? empty : brr;

            return two_writes_in_an_arg(arr, opaque_brr, opaque_x);
        }
    `);

    ZERO(`
        struct Node { items: Node[] };

        fn main() {
            mut root = Node([
                Node([ Node, Node ])
            ]);

            <fail both arg alias root>
            swap(root.items[0], root);  <pass/> // write to root invalidates root.items[0]
            root = root.items[0];       </fail> // this is fine

            return root.items.len - 2;
        }
    `);

    ZERO(`
        fn grow_if_oob(ref a: i32[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn assign(ref to: i32, ref what: i32) to = what;

        fn two_writes_in_an_arg(ref x: i32, ref arr: i32[], ref brr: i32[])
            assign( to: x,  what: arr.grow_if_oob(10)           ;; !N_BckMustSeq
                               || brr.grow_if_oob(10));         ;; !N_MoveMustSeq

        fn test(ref x: i32, ref arr: i32[], ref brr: i32[]) {
            two_writes_in_an_arg(
                <fail arg 2 arr 1 x both alias 17:22>
                    x || arr[0],              <pass/>
                    x,                        </fail>
                    :arr, :brr);

            return x;
        }

        fn main() {
            mut arr = [ 0 ];
            mut brr = [ 0 ];
            mut x   = 0;

            return test(:x, :arr, :brr);
        }
    `);

    ZERO(`
        fn writes_to_two_args(ref item: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            <fail alias brr>
            ref item = brr[0]; <pass/>
            mut item = brr[0]; </fail>

            return writes_to_two_args(:item, :arr, :brr);
        }
    `);

    ZERO(`
        fn reads_from_two_args(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[]) {
            ref arrbrr = arr || brr;
            ref item = left || right;
            arrbrr.resize(100 + arrbrr.len);
            return item += arrbrr.len;
        }

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;

            <fail alias brr>
            ref right = brr[0]; <pass/>
            mut right = brr[0]; </fail>

            return reads_from_two_args(:left, :right, :arr, :brr);
        }
    `);

    ZERO(`
        fn grow(ref arr: i32[], by!n: i32) {
            arr.resize(arr.len + n);
            return arr;
        }

        fn incr__ltr_oee(ref what: i32, by: i32)
            what += by;

        fn reads_from_two_args__single_expr(ref left: i32, ref right: i32, ref arr: i32[], ref brr: i32[])
            incr__ltr_oee(left || right, grow(arr || brr, by: 100).len);

        fn main() {
            mut arr: i32[] = [      ];
            mut brr: i32[] = [ -101 ];

            mut left = 0;

            <fail alias brr>
            ref right = brr[0]; <pass/>
            mut right = brr[0]; </fail>

            return reads_from_two_args__single_expr(:left, :right, :arr, :brr);
        }
    `);

    ZERO(`
        fn main() {
            mut arr = [ 1,1,1,1,1 ];
            mut sum = 0;

            // veach(view) should decay to a slice -
            //  which push will invalidate.
            //
            fn veach(view, fn) {
                for (mut i = 0; i < view.len; i++) {
                    fn(view[i]);
                    arr ~= arr; // Relocate arr.
                }
            }

            arr.veach: |i| sum += <fail both alias arr 3:17+3>
                            (i *= 2)            <pass/>
                            (i  * 2)            </fail>;

            return sum - 10;
        }
    `);

    ZERO([`
        struct Context {
            modules:    Module[];
        };

        nocopy struct Module {
            in?:        string;
            fname:      string;
        };

        fn getFile(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i].in;

            ctx.modules ~= Module(:fname, in: fname ~ '\\n' ~ fname ~ '\\n');
            return ctx.modules[ctx.modules.len - 1].in;
        }

        fn getModule(implicit ref ctx: Context, fname: string) {
            for (mut i = 0; i < ctx.modules.len; i++)
                if (ctx.modules[i].fname == fname)
                    return ctx.modules[i];

            return [];
        }
    `,
    `
        import _0;

        fn ensureParsed(fname: string) {
            let module = getModule(fname);
            if (!module.in)
                return getFile(fname).len
                <fail module invalidated by write to ctx>
                    || module.in.len;
                <pass/>
                    || throw(fname);
                </fail>

            return module.in.len;
        }

        fn main() {
            implicit mut ctx: Context;
            return ensureParsed("a") - 4;
        }
    `]);

    ZERO(`
        nocopy struct NCThing {
            items: i32[];
        };

        fn mut_in_loop_before_break(ref thing: NCThing) {
            mut sum = 0;

            ref items = thing.items;
            for (mut i = 0; i < items.len; i++)
            {
                sum += items[i];
                if (sum > 10)
                {
                    thing = NCThing();
                    <fail write 15:27 inval use items next loop iter 10:33>
                    if (sum > 20)                                   <pass/>
                    if (true)                                       </fail>
                        break;
                }

                items[i] *= 2;
            }

            return sum;
        }

        fn main() {
            mut thing = NCThing([ 10 ]);
            return mut_in_loop_before_break(thing)
                 + mut_in_loop_before_break(thing)
                 - 30
                 + thing.items.len;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;
            <fail ref x 13:20+1 invalidated by write to xy 10:18+2>
            ref x = xy.x;                                   <pass/>
            fn  x = xy.x;                                   </fail>

            pragma emit(\`
                \`xy\`.x++;
            \`);

            return x - 1;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32 };

        fn main() {
            mut xy: XY;
            <fail 11:22 inval next loop iter 9:21>
            ref x = xy.x;                  <pass/>
            fn  x = xy.x;                  </fail>

            while (!x)
                pragma emit(\`
                    \`xy\`.x++;
                \`);

            return xy.x - 1;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32 };

        fn bckErr_fromPragmaEmit(ref xy: XY) {
            pragma emit(\`
                \`xy\`.x++;
            \`);
        }

        fn main() {
            mut xy: XY;
            <fail bckErr_fromPragmaEmit>
            ref x = xy.x;        <pass/>
            fn  x = xy.x;        </fail>

            bckErr_fromPragmaEmit(xy);
            return x - 1;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32 };

        fn test(ref xy: XY, ref zw: XY) {
            <fail cannot access ref x 12:20+1 inval by write xy 9:21+2>
            ref x = xy.x;                                   <pass/>
            fn  x = xy.x;                                   </fail>

            pragma emit(\`
                \`xy || zw\`.x++;
            \`);

            return x;
        }

        fn main() {
            mut xy: XY;
            return test(xy, xy) - 1;
        }
    `);

    ZERO(`
        struct Ext { ext: Ext[] };

        fn EXT(implicit ext: Ext[], a: i32) ext[a];

        fn EXT_insert(implicit ref ext: Ext[], a: i32) {
            ext.insert(a, Ext());
            return ext[a];
        }

        fn solveTypedef(a: i32, b: i32) EXT_insert(a) = EXT(b);

        fn main() {
            implicit mut ext = [ Ext([ Ext, Ext ]) ];

            for (mut i = 0; i < 128; i++)
                solveTypedef(0, 0);

            return ext[0].ext.len == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        fn ints(implicit ref _ints: i32[]) _ints;
        fn sum (implicit ref _sum:  i32)   _sum;

        // while trying to sort implicit args i noticed tests didnt catch
        //  args getting reordered but AAR masks not updating
        //   this tries to reproduce the same thing
        fn flippedInjectedArgsWithBrokenAARMasks()
            if (sum) // the point of this is to inject _sum before _ints
                for (mut i = ints.len; i --> 0; )
                    ints.push(sum);

        fn main() {
            implicit mut _ints: i32[] = [ 0 ];
            <fail alias _ints>
            implicit ref _sum = _ints[0];
            <pass/>
            implicit mut _sum = 0;
            </fail>

            flippedInjectedArgsWithBrokenAARMasks();
            return ints[0];
        }
    `);

    ZERO(`
        struct Node {
            nodes: Node[];
        };

        noinline fn append_a_onto_b_100_times(ref willPush: Node, ref pushWhat: Node) {
            for (mut i = 0; i < 100; i++)
                willPush.nodes ~= pushWhat;
        }

        noinline fn clear_and_return_ref_to_self(ref node: Node) {
            node.nodes.clear();
            return node;
        }

        noinline fn crash_if_b_refs_into_a(ref willEmpty: Node, ref willPush: Node) {
            return append_a_onto_b_100_times(
                // indexes inside, should crash
                willPush.nodes[0],
                // empties the nodes
                clear_and_return_ref_to_self(willEmpty));
        }

        fn main() {
            mut willEmpty: Node = [[ Node() ]];

            <fail both alias willEmpty 28:47>
            crash_if_b_refs_into_a(willEmpty, willEmpty);
            <pass/>
            mut willPush = willEmpty;
            crash_if_b_refs_into_a(willEmpty, willPush);
            </fail>

            return willEmpty.nodes.len == 0 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Node { nodes: Node[] };

        noinline fn soft_risk_inner(ref a: Node, ref b: Node)
            for (mut i = 0; i < 100; i++)
                a.nodes ~= b;

        noinline fn soft_risk_outer(ref a: Node, ref b: Node)
            soft_risk_inner(a, b.nodes[0]);

        fn main() {
            mut root = Node([ Node ]);

            <fail both alias root 12:17+4>
            soft_risk_outer(root, root);    <pass/>
            mut cpy = root;
            soft_risk_outer(root, cpy);     </fail>

            return root.nodes.len == 101 ? 0 : 1;
        }
    `);

    ZERO(`
        struct ScopeItem { k: string; v: i32 };

        fn dequalify_andGetScope(ref id: string, implicit locals: ScopeItem[], implicit globals: ScopeItem[]) {
            if (id.ends(with: "g")) {
                id.pop();
                return globals;
            }

            return locals;
        }

        fn solveAddrOfFn(mut id: string) {
            fn visitScope(items: ScopeItem[]) {
                items.each: |item|
                    if (item.k == id)
                        return item.v;

                return -1;
            }

            // on gcc visitScope:id bound to a slice before mutation
            return visitScope(dequalify_andGetScope(id));       ;; N_BckMustSeq
        }

        fn main() {
            let implicit locals  = [ ScopeItem("a", 1), ScopeItem("b", 2), ScopeItem("c", 3) ];
            let implicit globals = [ ScopeItem("a", 10), ScopeItem("b", 20), ScopeItem("c", 30) ];
            let result = solveAddrOfFn("a") + solveAddrOfFn("bg");
            return result == 21 ? 0 : 1;
        }
    `);

    ZERO(`
        fn cmp_ooe(mut stuff: i32[], ref needSort: bool) {
            mut result: i32[] = [];
            mut last = -1;
            for (mut i = 0; i < stuff.len; i++) {
                let t = stuff[i];
                if !(t & 1) continue;
                if (last > (last = t)) needSort = true;
                result ~= t;
            }

            if (needSort) result.sort();
            return result;
        }

        fn checksum(stuff: i32[]) {
            mut result = 0;
            for (mut i = 0; i < stuff.len; i++) {
                result *= stuff[i];
                result += stuff[i];
            }
            return result;
        }

        fn main() {
            mut needSort = false;
            let aa = checksum(cmp_ooe([1, 2, 3, 4, 5], :needSort));
            let bb = !needSort
                  && checksum(cmp_ooe([7, 4, 3, 2, 1], :needSort));

            return needSort ? aa * 100 + bb - 3549 : 1;
        }
    `);

    ZERO(`
        fn clearAndReturn(ref a: i32[]) {
            a.clear();
            return a;
        }

        <alt>
        fn refOOE(ref a: i32[], b: i32[]) <alt/>
        fn refOOE(b: i32[], ref a: i32[]) </alt>
            a ~= b;

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
            refOOE(a: clearAndReturn(ints), b: ints);
            return ints.len - 10;
        }
    `);

    ZERO(`
        struct Type { nontriv: Type[] };
        struct Node { type: Type };

        let zero    = Type();
        let one     = Type([ Type ]);
        let two     = Type([ Type, Type ]);

        noinline fn solve(ref nodes: Node[])
        {
            noinline fn propagateType(ref node: Node, slot: Type) {
                shadow let slot =
                    node.type.nontriv.len == 2 ? two : slot;

            <alt>
                for (mut i = 0; i < nodes.len; i++)
                    nodes[i].type = zero;
            <alt/>
                nodes = nodes.map(|lax n| Node(zero));
            </alt>

                nodes ~= Node(slot);
            }

            for (mut i = nodes.len; i --> 0; ) {
                ref node = nodes[i];

                propagateType(node,
                <alt>
                    node.type.nontriv.len == 0 ? zero : node.type
                    //              missing copy around ^^^^^^^^^
                    //      alt-1: wrong result, alt-2: segfault
                <alt/>
                    node.type
                </alt>);
            }
        }

        fn main() {
            mut nodes = [ Node(one) ];
            solve(nodes);

            return nodes.len == 2
                && nodes[0].type == zero
                && nodes[1].type == one
                    ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NC { x: i32 };

        noinline fn add(a: i32, b: i32)
            a + b;

        noinline fn test(a: NC, ref b: NC)
            add(10 * a.x, ++b.x);                               ;; N_AARMustSeq

        fn main() {
            mut nc = NC(1);
            return test(nc, nc) - 12;
        }
    `);

    ZERO(`
        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_nested_loop_after_break(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {
                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        // write followed by inner-loop break -
                        //  not on the same path as the use of first below ...
                        n.children ~= Node(i);

                        <fail cannot access first 23:21+5 inval by write n 16:36+2>
                        break;                                              <pass/>
                        return sum;                                         </fail>
                    }

                    // ... which will be used again on next outer-loop iter.
                    first.value += sum;
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_nested_loop_after_break(n);
            return sum - 3;
        }
    `);

    ZERO(`
        struct Node { value: i32; children?: Node[] };

        noinline fn used_in_a_preceding_nested_loop(ref n: Node)
        {
            ref first = n.children[0];

            mut sum = 0;
            for (mut i = 0; i < n.children.len; i++) {

                for (shadow mut i = 0; i < n.children.len; i++)
                    first.children ~= Node(i);

                for (shadow mut i = 0; i < n.children.len; i++) {
                    sum += n.children[i].value;

                    if (sum & 1) {
                        n.children ~= Node(i);

                        <fail write to n 18:36+2 inval use of first 12:21+5 on next loop iter>
                        break;          <pass/>
                        return sum;     </fail>
                    }
                }
            }

            return sum;
        }

        fn main() {
            mut n = Node(0, [ Node(2), Node(1) ]);
            let sum = used_in_a_preceding_nested_loop(n);
            return sum - 3;
        }
    `);

    ZERO(`
        noinline fn used_after_break_from_block(ref arr: i32[])
        {
            <fail cannot access first 18:20+5 inval by write to arr 10:34+1>
            ref <pass/>
            mut </fail> first = arr[0];

            :BLOCK {
                if (first & 2) {
                    if (first & 1) {
                        arr.clear();
                        break :BLOCK;                           ;; Goto
                    }

                    first++;
                }
            }

            return first;
        }

        fn main() {
            mut arr = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19 ];
            return used_after_break_from_block(arr) - 3;
        }
    `);

    // I was trying to test the __preceding_ref_arg stuff,
    //  but the concat_self_ret_last strikes me
    //   as something that should actually work.
    //
    TODO_slices(currently: "arr 13:19+3 inval by subseq 13:44+1 concat_self_ret_last", `
        fn hello(ref arr: i32[], ref item: i32)
            arr ~= ++item;

        fn ret_last(ref arr: i32[])
            arr[arr.len - 1];

        fn concat_self_ret_last(ref arr: i32[])
            ret_last(arr ~= arr)

        fn main() {
            mut arr = [ 1, 2, 3 ];
            hello(arr, concat_self_ret_last(arr));
            return ret_last(arr) - 4;
        }
    `);

    ZERO(`
        fn Last(ref arr: i32[])
            arr[arr.len - 1];

        fn Push(ref arr: i32[]) {
            arr.push([]);
            return arr.Last;
        }

        fn Assign(ref b: i32, ref into: i32)
            into = ++b;

        fn main() {
            mut arr = [ 1, 2, 3 ];

            <fail write to arr 21:43+1 inval use b 21:30+1 next loop iter>
            ref <pass/>
            fn  </fail> b = arr.Last;

            for (mut i = 0; i < 10; i++) {
                mut tmp: i32;
                Assign(tmp = b, into: Push(arr));
            }

            return arr.Last - 13;
        }
    `);

    ZERO(`
        fn main() {
            mut arr = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];
            <fail ref item4 11:26+5 inval by write to arr 10:18+3>
            ref <pass/>
            let </fail> item4 = arr[4];

            mut out = 7;

            pragma emit(\`
                \`arr\` = {};
                \`out\` = \`item4\`;
            \`);

            return out * 2 - 8;
        }
    `);

    ZERO(`
        struct A { ints: i32[] };
        struct B { a0: A; a1: A };

        noinline fn either(ref a: B) a.a0 || a.a1;

        fn main() {
            mut b0 = B( A([ 1, 2, 3, 4, 5, 6, 7, 8 ]),
                        A([ 9, 10, 11, 12, 13, 14, 15, 16 ]));

            let b1 = b0;

            ref a0 = either(b0);
            a0.ints.clear();
            a0.ints ~= 1;

            return    1 * b0.a0.ints.len +   10 * b0.a1.ints.len
                 +  100 * b1.a0.ints.len + 1000 * b1.a1.ints.len
                 - 8881;
        }
    `);

    ZERO(`
        struct TokenIdx { tokidx: i32 };

        fn FAIL(implicit _here: TokenIdx, reason: string): never
            throw(_here && reason);

        noinline fn opaque_bool_check(lt: string)
            return !!lt;

        fn Lifetime_process(lt: string, each) {
            fn visit(chars) {
                for (mut i = 0; i < chars.len; i++) {
                    fn climb(mut parent: string) {
                        visit(parent);
                        continue;
                    }

                    each(climb?: fn climb, chars.slice(i, chars.len))
                    i == chars.len - 1 || <alt>FAIL<alt/>throw</alt>("here-0");
                }
            }

            visit(lt);
        }

        fn main() {
            let implicit mut _here: TokenIdx;

            fn fail(mut reason: string, backtrack!?: string): never {
                if (backtrack) _here = [];
                return FAIL(reason);
            }

            fn climbWhat(mut str: string) {
                str || fail("here-1");
                str.pop();
                return str;
            }

            mut result = "";
            Lifetime_process("abc", each: |lt, climb|
            {
                result ~= lt;
                let init = lt.climbWhat;
                if (init.opaque_bool_check)
                    climb(init);
            });

            return result == "abcababbcbc" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Module { modid: i32; scope: string[] }
        struct Target { modid: i32; globid: i32 }
        struct Solver { scope: string[]; tp: string }

        // This hit flatCount asserts in lifetime paths during bck
        fn test(
            implicit ref ctx:       Module[],
            using implicit ref ss:  Solver,
            target:                 Target)
        {
            ref s = ctx.len > target.modid
                    ? ctx[target.modid].scope
                    : scope;

            return s.len > target.globid
                    ? s[target.globid]
                    : tp;
        }

        fn main() {
            implicit mut ss = Solver(scope: [ "h", "w" ], tp: "Hello!");
            implicit mut ctx = [
                Module(modid: 0, scope: [ "hello", "world" ]),
                Module(modid: 1, scope: [ "Hello", "World" ]),
            ];

            let append = ", " ~ test(Target(modid: 1, globid: 1))
                       ~ "! " ~ test(Target(modid: 0, globid: 2));

            ref res = test(Target(modid: 0, globid: 0));
            res ~= append;

            return res == "hello, World! Hello!" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target       { modid: i32; globid: i32 }
        struct SolvedNode   { items: SolvedNode[]; target?: Target }

        fn stealInit(ref allNodes: SolvedNode[], t: Target)
        {
            fn GET_mut(target: Target)
                allNodes[target.globid];

            ref node = GET_mut(t);
            if (node.items && node.items[0]) {
                mut init: SolvedNode;
                swap(init, node.items[0]); // flatCount mismatch here
                return init;
            }

            return [];
        }

        fn main() {
            mut allNodes = [
                SolvedNode([
                    SolvedNode([
                        SolvedNode(),
                    ]),
                ]),
            ];

            novec fn count(items: SolvedNode[]) {
                mut count = items.len;
                items.each: |node| count += node.items.count;
                return count;
            }

            let cnt0 = allNodes.count;
            let init = stealInit(allNodes, Target(0, 0));
            let cnt1 = [ init ].count;
            let cnt2 = allNodes.count;

            return cnt0 == 3 && cnt1 == 2 && cnt2 == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        noinline fn test(ref ints: i32[], ref iview: i32[:]) {
            inline fn a() {
                mut empty: i32[];
                ref indirect = ints || empty;
                indirect ~= indirect;
            }

            inline fn b() {
                mut empty: i32[];
                ref indirect = iview || empty;

                ref head = indirect[: indirect.len / 2];
                for (mut i = 0; i < head.len; i++) head[i] *= 2;

                ref tail = indirect[indirect.len - indirect.len / 2 :];
                for (mut i = 0; i < tail.len; i++) tail[i] *= 2;
            }

            <fail at call to test 26:24+4 both alias ints 25:17+4>
            a(); b(); <pass/>
            b(); a(); </fail>
        }

        fn main() {
            mut ints = [ 1, 2, 3, 4, 5 ];
            test(ints, ints);
            return ints == [ 2, 4, 3, 8, 10, 2, 4, 3, 8, 10 ] ? 0 : 1;
        }
    `);

    ZERO(`
        struct TEA { a: byte[]; b: byte[] };

        fn hash(ref res: TEA, u8view: byte[]) {
            let u32len  = u8view.len & ~3;
            let u32view = u8view[: u32len];
            ref out     = res.a || res.b;
            out        ~= out;
            mut x       = u32view ~ "?";
            out        ~= x;
        }

        fn main() {
            mut res: TEA;
            res.b = "hello, world! ";
            hash(res, res.b);
            return res.b == "hello, world! hello, world! hello, world?"
                 ? 0 : 1;
        }
    `);

    ZERO(`
        struct TwoVecs { a: i32[]; b: i32[] };

        noinline fn disjoint_refs(ref tv: TwoVecs) {
            <alt>
            ref         <alt/>
            noinline fn <alt/>
            inline fn   </alt> a = tv.a;

            <alt>
            ref         <alt/>
            noinline fn <alt/>
            inline fn   </alt> b = tv.b;

            a ~= b; // 21
            b ~= a; // 32
            a ~= b; // 53
        }

        fn main() {
            mut tv = TwoVecs(
                [  1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
                [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]);

            disjoint_refs(tv);
            return tv.a.len - 53;
        }
    `);

    TODO_disjoint(currently: "both alias ref arg ss 6:69+2", `
        nocopy struct PrimArray { prims: i32[]; }
        nocopy struct Node { index: i32; items?: Node[]; }
        nocopy struct SolverState { _root: Node; _prim_arrays: PrimArray[] }

        noinline fn AAR_typesCantAlias_lifetimesIntersect(using ref ss: SolverState)
        {
            fn unorderedPrep_B(ref root: Node) {
                let index  = root.index;
                if (_prim_arrays.len > index) {
                    ref eph     = _prim_arrays[index];
                    eph.prims  ~= root.index += eph.prims.len;
                               // ^^^^^^^^^^ should notice eph can't alias root
                }
            }

            return _root.unorderedPrep_B();
        }

        fn main() {
            mut ss = SolverState(Node(), [ PrimArray() ]);
            ss.AAR_typesCantAlias_lifetimesIntersect();
            return ss._eph.len == 1 && ss._eph[0].things.len == 1 ? 0 : 1;
        }
    `);

    // /Borrow checker


    // Move on last use

    ZERO(`
        nocopy struct Val { x: i32 };
        struct Out { v: Val };
        fn move_Val_into_Out(mut v: Val)    = Out(:v);
        fn main()                           = move_Val_into_Out(Val(0)).v.x;
    `);

    ZERO(`
        fn must_not_move_mystr(n: i32) {
            mut mystr = "";
            for (mut i = 0; i < n; i++)
                mystr ~= "!";

            mut result: string[];
            for (mut i = 0; i < n; i++)
                result ~= mystr;

            return result.join();
        }

        fn main() = must_not_move_mystr(3).len - 9;
    `);

    ZERO(`
        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_ref_and_val(ref r!: Type, mut v!: Type) {
            v.canon ~= r.canon;
            r.canon ~= v.canon;
            v.quals |= r.quals;
            return r;
        }

        fn main() {
            mut t = Type("abc", 123);
            return takes_ref_and_val(r: t, v: t).canon.len - 9;
        }
    `);

    ZERO(`
        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings(mut a: Type, mut b: Type) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            return a;
        }

        fn move_on_last_use_OOE(mut canon: string, quals: int) {
            canon ~= canon;
            return takes_two_strings(   ;; N_MoveMustSeq
                Type(:canon, :quals),
                Type(:canon, :quals));  // out of order move-into-struct will break this
        }

        fn main() {
            let res = move_on_last_use_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    1000);

            return res.canon.len + res.quals - 1192;
        }
    `);

    ZERO(`
        struct Type {
            canon: string;
            quals: int;
        };

        fn takes_two_strings_and_an_int(mut a: Type, mut b: Type, c: int) {
            b.canon ~= a.canon;
            a.canon ~= b.canon;
            a.quals |= b.quals;
            a.quals += c;
            return a;
        }

        fn moves_reordered_by_bck_OOE(mut canon: string, mut quals: int) {
            canon ~= canon;
            return takes_two_strings_and_an_int(    ;; N_MoveMustSeq
                Type(:canon, 0),
                Type(:canon, quals++), // quals++ triggered bck MUSTSEQ
                             quals  ); //  which reordered arg b BEFORE arg a,
        }                              //   which broke move-on-last-use.

        fn main() {
            let res = moves_reordered_by_bck_OOE(
                "1234567890abcdef1234567890abcdef" // len=32, *2 = 64, *3 = 192
                    0);

            return res.canon.len + res.quals - 193;
        }
    `);

    TODO_cow(currently: "COW will break 16:22+1 9:17+1", `
        fn track_last_loop_confusion(mut a: string, mut b: string)
        {
            for (mut i = 0; i < 6; i++) {
                a ~= a; // foil smallstring opti
                b ~= b; //  both are 64 chars long
            }

            ref x = a.len == 64 ? b : a;
            ref y = b.len == 64 ? x : a; // y points to b two refs deep

            mut result = b; // <-- BROKEN MOVE FROM b HERE

            // once
            for (mut i = result.len / 64; i --> 0; ) {
                y ~= y;         // now 128, ensures y not a view
                result ~= y;    // for a total of 192
            }

            return result;
        }

        fn main() {
            mut res = track_last_loop_confusion("a", "b");
            return res.len == 192 ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NCItem { x: i32 };

        fn unshift_odds_push_evens(n: i32) {
            mut arr: NCItem[];
            for (mut i = 0; i < n; i++) {
                let item = NCItem(i);
                if (i & 1)  arr.unshift(item);                  ;; !*MustSeq
                else        arr.push(item);
            }
            return arr;
        }

        fn main() {
            let arr = unshift_odds_push_evens(3);
            return arr[0].x == 1
                && arr[1].x == 0
                && arr[2].x == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NCThing { x: i32 };

        fn last_used_before_break(mut nc: NCThing, N: i32) {
            mut res: NCThing;
            for (mut i = 0; i < N; i++) {
                nc.x *= 2;
                if (nc.x > 10) {
                    if (nc.x > 20) return nc;
                    res = nc; // <- should move here ...
                    break;
                }
            }

            <fail cannot be copied or moved 10:27>
            if (nc.x > 15) return nc; // <- ... unless used here.
            <pass/></fail>

            res.x *= 10;
            return res;
        }

        fn main() {
            let res = last_used_before_break(NCThing(3), 10);
            return res.x - 120;
        }
    `);

    ZERO(`
        nocopy struct NCThing { str: string };

        fn last_used_in_defer(mut nc: NCThing, ref other: NCThing) {
            defer other = nc; // last use, move here!
            while (nc.str.len < 64)
                nc.str ~= nc.str;

            <fail cannot be copied or moved 10:20>
            return nc;                     <pass/>
            return nc.str.len;             </fail>
        }

        fn main() {
            mut other: NCThing;
            last_used_in_defer(NCThing("Hello!"), other);
            return other.str.len - 96;
        }
    `);

    ZERO(`
        nocopy struct Node { nodes: Node[]; }

        noinline fn add(a: i32, b: i32) {
            return a + b;
        }

        fn main() {
            mut res = Node([ Node ]);
            mut cpy: Node;

            mut res_len = 0;
            mut cpy_len = 0;                                    ;; N_MoveMustSeq
            <alt>
            mut sum = (res_len = res.nodes.len) + (cpy_len = (cpy = res).nodes.len); <alt/>
            mut sum = add(res_len = res.nodes.len, cpy_len = (cpy = res).nodes.len); </alt>

            return cpy.nodes.len == cpy_len
                && res_len == 1
                && cpy_len == 1
                && sum == 2             ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NC { ncs: NC[] };

        struct Foreign { name: NC; kind: i32; flags: i32 };
        struct Local   { kind: i32; flags: i32; name: NC };

        fn intoLocal(using mut f: Foreign) = Local(:kind, :flags, :name);

        <split/>
        fn main() {
            let foreign = Foreign(NC([ NC(), NC() ]), 0, 0);
            let local = intoLocal(foreign);
            return local.name.ncs.len - 2;
        }
    `);

    ZERO(`
        struct A { items: i32[] };
        struct B { items: i32[] };

        <alt>
        fn takesRef_OOE(ref a: A, b: B) <alt/>
        fn takesRef_OOE(b: B, ref a: A) </alt>
            a.items ~= b.items;

        struct C { items: i32[] };

        fn C2B(mut c: C) B(c.items);

        fn selectA(mut c: C, ref a0: A, ref a1: A) {
            ref a   = c.items.len & 1 ? a0 : a1;
            a.items = c.items;
            return a;
        }

        fn main() {
            mut c = C([ 1, 2, 3, 4, 5, 6, 7 ]);
            mut a0: A;
            mut a1: A;

            takesRef_OOE(                                       ;; N_MoveMustSeq
                a: selectA(:c, :a0, :a1),
                b: C2B(:c));

            return a0.items.len - 14;
        }
    `);

    // /Move on last use


    // quite right

    LEGACY_Map(currently: "Map is not defined", `
        struct BINOP {
            P: Map(string, i32);
        };

        fn setupOperators(): BINOP
        {
            mut out: BINOP;

            fn binop(op: string)
                out.P[op] = 7;

            binop(",");

            return out;
        }

        shadow let BINOP = setupOperators();
        let P_COMMA = BINOP.P[","] || throw("Assertion failed.");

        fn main() P_COMMA - 7;
    `);

    ZERO(`
        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = "x";
        if (!(trail >= "0" && trail <= "9") &&
            !(hex && (trail >= "a" && trail <= "f"
                   || trail >= "A" && trail <= "F")))
        {
            return 0;
        }

        return 1;
    `);

    ZERO(`
        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags?:     i32;
            value?:     string;
            items?:     SolvedNode[];
            token:      Token;

            type:       Type;
            target?:    ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: "definit",
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;
    `);

    ZERO(`
        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            "", id, t_template,
            min, max, arg_n,
            :template);
    `);

    ZERO(`
        let i = 0;
        let items = [ "" ];
        i == items.len - 1 || throw("what?");
        return i;
    `);

    ZERO(`
        return false /* test */
             ? 0xffffff.i32 // what is this
             : 0 // madness
             ;
    `);

    ZERO(`
        fn test(id: i32) id;
        return test(/*id*/0); // <- bad parse
    `);

    ZERO(`
        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part: &string = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            return path.join("/");
        }

        fn main() path_normalize("./hello///hey") == "hello/hey" ? 0 : 1;
    `);

    ZERO(`
        fn path_normalize(p: string): string {
            mut path = p.split("/");

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == "." || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == "..")
                    path.splice(--i, 2);
            }

            return path.join("/");
        }

        fn path_join(a: string, b: string)
            path_normalize(a ~ "/" ~ b);

        fn main()
            path_join("hello/hey", "./../you//") == "hello/you/"
                ? 0 : 1;
    `);

    ZERO(`
        pub struct Template { locals: ScopeMemo; }; // <- used ahead of the def, was missing q_trivial
        pub struct ScopeMemo { x: i32; }; // <- trivial, discovered on solve here after Template is done
        pub fn +(a: ScopeMemo, b: ScopeMemo) a.x + b.x; // <- used here after both structs are done

        pub fn main() {
            let a = Template(ScopeMemo(+3));
            let b = Template(ScopeMemo(-3));
            return a.locals + b.locals; // <- fails to match.
        }
    `);

    ZERO(`
        novec fn novec_each(a: $T[], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut a = [ 1 ];
            a.novec_each: |ref i| i *= 2;
            return a[0] - 2;
        }
    `);

    ZERO(`
        novec fn Each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        struct Node { kind: string; items: Node[]; flags: i32; };

        let F_PREDICATE = 2;

        fn parse(tokens: byte[]): Node {
            mut _idx = 0;

            fn parseStructDecl(flags! = 0): Node {
                mut items = parseBlockLike('}');

                :F_PREDICATE {
                    items.Each: |item|
                        if (item.kind == "let")
                            if (item.flags & F_PREDICATE)
                                break :F_PREDICATE;             ;; Goto

                    items.Each: |ref item|
                        if (item.kind == "let")
                            item.flags |= F_PREDICATE;
                }

                return Node("struct", items, :flags);
            }

            fn parseBlockLike(endToken: byte): Node[] {
                mut items: Node[] = [];
                for (;;) {
                    let token = tokens[_idx++];                 ;; !N_BckMustSeq
                    if (token == endToken)                      ;; !N_MoveMustSeq
                        break;

                    items ~= Node("let", [], flags: token == '+' && F_PREDICATE);
                }

                return items;
            }

            return parseStructDecl();
        }

        fn main() {
            let tokens = "+-}";
            let p = parse(tokens).items;
            return p.len - p[0].flags
                         + p[1].flags * 17;
        }
    `);

    ZERO(`
        pub struct MeshBuilder
        {
            verts?:     byte[];
            indices?:   byte[];
            vert_bytes: i32;
            num_verts?: i32;
        };

        pub fn alloc(
            using mb: &mut MeshBuilder,
            new_verts: i32,
            new_indices: i32)
        {
            verts.resize_junk((verts.len + new_verts) * vert_bytes);

            let index_bytes = 4;
            indices.resize_junk((indices.len + new_indices) * index_bytes);
        }

        pub fn setup_quads(
            using mb: &mut MeshBuilder, // <- the 'using' introduced more bindings,
            num_quads: i32)             // <-  advancing the target index number of this arg,
                : &mut [byte]           // <-   confusing the callsite lifetime of this view.
        {
            let b0 = verts.len;
            let v0 = num_verts;
            let i0 = indices.len;

            mut v1 = v0;

            alloc(num_quads * 4, num_quads * 6);

            let indices_i32: &mut [i32] =
                indices[i0 : indices.len]
                    .view(i32);

            for (mut i = 0; i < indices_i32.len; i += 6)
            {
                indices_i32[i    ] = v1;
                indices_i32[i + 1] = v1 + 1;
                indices_i32[i + 2] = v1 + 2;

                indices_i32[i + 3] = v1;
                indices_i32[i + 4] = v1 + 2;
                indices_i32[i + 5] = v1 + 3;

                v1 += 4;
            }

            num_verts = v1;

            return verts[b0 : verts.len];
        }

        let QUAD_VBO: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0,
            +1, +1, 0,      0, 0, 1,    1, 1,
            -1, +1, 0,      0, 0, 1,    0, 1,
        ];

        pub fn main()
        {
            mut mb = MeshBuilder(
                vert_bytes: 4 * (3+3+2));

            mb.setup_quads(1).view(f32) .= QUAD_VBO;

            return mb.num_verts - 4;
        }
    `);

    ZERO(`
        fn target(implicit ref _target: i32) _target;

        // this suddenly reported that it doesn't see __solveStruct
        fn GET_mut(ref x: i32) x || target;

        // while i was trying to reproduce an ambig "o" fail here
        fn __solveStruct(mut arg: i32): i32 {
            if (arg) {
                ref o = GET_mut(arg);
                o++;
                checkRecursions(o, o);
            }
            return arg;
        }

        fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

        fn main() {
            implicit mut _target = 0;
            return __solveStruct(1) - 4;
        }
    `);

    ZERO(`
        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn target(implicit ref _itarg: i32) _itarg;

        fn main() {
            implicit mut _itarg = 0;
            fn GET_mut(ref x: i32) x || GET_mut(target += 1);   ;; PointlessMustSeq
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn target(implicit ref _itarg: i32) _itarg;
        fn GET_mut(ref x: i32) x || GET_mut(target += 1);       ;; PointlessMustSeq

        fn main() {
            implicit mut _itarg = 0;
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        fn main() {
            mut target = 0;
            fn GET_mut(ref x: i32) x || GET_mut(++target);      ;; PointlessMustSeq
            return GET_mut(target) - 1;
        }
    `);

    ZERO(`
        // TODO use something like pragma lax to opt-out of cc warnings.
        // Output looks fine & works on gcc/clang but gcc warns and breaks build.
        pragma emit(\`#pragma GCC diagnostic ignored "-Wsequence-point"\`);

        fn main() {
            mut target = 0;
            fn __solveStruct(mut arg: i32): i32 {
                ref o = GET_mut(arg); o += target;
                return target;
            }

            fn GET_mut(ref x: i32)
                x || (target = __solveStruct(target += 1));     ;; PointlessMustSeq

            return __solveStruct(0) - 2;
        }
    `);

    ZERO(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) a || (a = B(incr(a)));
        fn B(ref b: i32) b || (b = A(incr(b)));
        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn incr(ref a: i32) ++a;
        fn A(ref a: i32) { ref aa = a || (a = B(incr(a))); return aa; }
        fn B(ref b: i32) { ref bb = b || (b = A(incr(b))); return bb; }
        fn main() { mut v = 0; return A(v) - 1; }
    `);

    ZERO(`
        fn main()
        {
            fn Each(cond, cons) cond && cons();
            fn arg(implicit ref __arg: i32) __arg;
            fn __solveStruct(x = 3) Each(arg, || arg += x);
            implicit mut __arg = 1;
            return __solveStruct - 4;
        }
    `);

    ZERO(`
        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32)             Each(arg, || arg);
            return arg_incr_x(+7) - 7;
        }
    `);

    ZERO(`
        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0)      Each(arg, || arg += x);
            return arg_incr_x(+7, -11) + 4;
        }
    `);

    ZERO(`
        fn main() {
            fn Each(cond, cons)                     cond && cons();
            fn arg_incr_x(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                return arg;
            }
            return arg_incr_x(+7, -11) + 4;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;

            fn Each(cond, cons) cond && cons();

            fn GET_mut(ref x: i32) x || (target = __solveStruct(target));

            fn __solveStruct(mut arg: i32, x = 0): i32 {
                Each(arg, || arg += x);
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }
    `);

    ZERO(`
        fn main()
        {
            mut target = 0;

            // this suddenly reported that it doesn't see __solveStruct
            fn GET_mut(ref x) x || (target = __solveStruct(target));

            // while i was trying to reproduce an ambig "o" fail here
            fn __solveStruct(mut arg: i32): i32 {
                if (arg) {
                    ref o = GET_mut(arg);
                    o++;
                    checkRecursions(o, o);
                }
                return arg;
            }

            fn checkRecursions(ref o: i32, incr: i32): void { GET_mut(o) += incr; }

            return __solveStruct(1) - 4;
        }
    `);

    LEGACY_Map(currently: "Map is not defined", `
        struct ValueType { modid: i32; };
        struct Type { using vtype: ValueType; };
        struct Target { modid: i32; index: i32; };
        struct Overload { name: string; id: string; };

        fn GET(target: Target): Overload =
            Overload(
                name: "N" ~ target.index,
                  id: "I" ~ target.index);

        fn main() {
            mut specs: Map(string, Target);

            fn setSpec(mangle: string) {
                ref t = specs[mangle] ||= Target;

                // This template should start expanding on GET(target).name,
                //  which should conflict with overload name.
                fn name(shadow target)
                    GET(target) <fail ambig>
                        .name;  <pass/>
                        .id;    </fail>

                return t.name;
            }

            return setSpec("hey").len - 2;
        }
    `);

    ZERO(`
        pub struct ScopeSkip { start: i32; end: i32; };

        pub fn Each(items: [$T], scope_skip: ScopeSkip[], fn, start = 0) {
            let END_DUMMY = ScopeSkip(start: items.len, end: items.len);

            mut i0 = start;
            for (mut i = 0; i < scope_skip.len + 1; i++) {
                let ss = i < scope_skip.len ? scope_skip[i] : END_DUMMY;
                if (ss.end <= i0)
                    continue;

                let i1 = ss.start;
                for (shadow mut i = i0; i < i1; i++)
                    fn(items[i]);

                i0 = ss.end;
            }
        }

        pub fn test(items?: i32[]) {
            mut sum = 0;
            let ss: ScopeSkip[];
            items.Each(ss, |item| sum += item, start: sum);
            return sum;
        }

        pub fn main() test();
    `);

    LEGACY_Map(currently: "Map is not defined", `
        fn setupOperators(P_PREFIX_UNARY) // <- template
        {
            struct BINOP {
                PRECEDENCE:     Map(string, i32);
                RIGHT_TO_LEFT:  Map(i32,   bool);
            };

            mut out: BINOP; // <- no BINOP in scope
            mut precedence = P_PREFIX_UNARY;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT[precedence] = rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE[ops[i]] = precedence;
            }

            binop([ "|>" ]);

            //
            return out;
        }

        let BINOP = setupOperators(-1);

        fn main() {
            let precedence = BINOP.PRECEDENCE["|>"];
            return precedence;
        }
    `);

    ZERO(`
        fn Each(a: [$T], fn, start!?: i32)
            for (mut i = start; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut sum = 0;
            let a = [ 1, 2, 3 ];
            a.Each(|i| sum += i, start: sum);   // <- start inferred to ref i32, which couldnt definit
            return sum - 6;                     //     perhaps we can use the optionality to infer constness
        }
    `);

    ZERO(`
        <fail novec>
        novec // Abusing to test novec, unrelated to the test
        <pass/></fail>
        fn ScopeSkip_push(ref scope_skip: i32[]) {
            if (scope_skip) scope_skip[0]++;
            else            scope_skip ~= 1;
        }

        fn main() {
            mut scope_skip = [ 1 ];
            ScopeSkip_push(scope_skip);
            return scope_skip[0] - 2;
        }
    `);

    ZERO(`
        struct Hello { v: i32[] };

        fn main() {
            let h = Hello();

            <fail novec>
            novec // qSTACK bug with args.len == 0 at call to Hello
            <pass/></fail>
            fn hello(woot?: i32)
                woot ? Hello() : h;

            return hello.v.len;
        }
    `);

    ZERO(`
        struct Module  { cpp:    string; };
        struct Context { module: Module; };     // Simplification of next test, no need to consider COW here

        fn snippet2cpp(cpp: string): string {
            let ctx = Context( Module(cpp) );
            {
                let module = ctx.module;        // This was const Module& =  ... which can't be moved from.
                if (module.cpp)
                    return module.cpp;          ;; EXPECT return static_cast<fu::str&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;
    `);

    ZERO(`
        struct Module  { cpp:     string;   };
        struct Context { modules: Module[]; };  // Module[] is COW-capable -
                                                //  - either prove there's no COW,
        fn snippet2cpp(cpp: string): string {   //  - or don't attempt to move out the item.
            let ctx = Context([ Module(cpp) ]);
            for (mut i = 0; i < ctx.modules.len; i++)
            {
                let module = ctx.modules[i];    ;; TODO .unique(i)
                if (module.cpp)
                    return module.cpp;          ;; TODO return static_cast<fu::str&&>
            }

            return "";
        }

        fn main() snippet2cpp("1").len - 1;
    `);

    ZERO(`
        fn test(x: string) {
            // cg fail: fwd annots of the two fns where unconsting hey to "enable move",
            //          basically the decision was made in the wrong scope.
            let hey = "hey";
            fn inner(you: string) you && hey ~ you || outer("what#1");
            fn outer(arg: string) inner(arg && " " ~ arg) || inner("what#2");
            return outer(x);
        }

        fn main() test("you").len - 7;
    `);

    ZERO(`
        struct Target { modid!: i32; packed!: i32; };
        inline fn index(a: Target) a.packed;

        <split/>

        struct CurrentFn { using target: Target; };
        fn hello(c?: CurrentFn) c.index;
        fn main() hello;
    `);

    ZERO(`
        struct ID   { offset: i32;  };
        struct Data { items:  ID[]; };

        using fn Data(implicit all: Data[], nid: ID): Data {
            return all[nid.offset];
        }

        fn test(node: ID) {
            let init = node.items[0];
            return init.items.len;
        }

        fn main() {
            let implicit all =  [ Data([ ID(1)      ])
                                , Data([ ID, ID, ID ]) ];

            return 0.ID.test - 3;
        }
    `);

    LEGACY_Map(currently: "Map is not defined", `
        struct Context
        {
            fuzzy: Map(string, string);
            files: string[];
        }

        fn resolveFile(
            implicit ctx: &mut Context,
            from: string, name: string): string
        {
            let path    = from ~ name;
            let cached  = ctx.fuzzy[path];
            if (cached)
                return cached == "\v" ? "" : cached;

            fn tryResolve(): string
            {
                let exists = file::size(path) >= 0;
                if (exists)
                    return path;

                return "";
            };

            let resolve = tryResolve();
            ctx.fuzzy[path] = resolve || "\v";
            return resolve;
        }

        pub fn resolveFile(
            implicit ctx: &mut Context,
            path: string): string
        {
            let fuzzy = path.find('\v');
            if (fuzzy > 0)
            {
                let from = path.slice(0, fuzzy);
                let name = path.slice(fuzzy + 1);
                if (from && name && !name.has('\v'))
                {
                    let res = resolveFile(:from, :name);
                    if (res)
                        return res;

                    // Tests have the files prepopulated,
                    //  we only pay the cost of lookup when about to fail compile.
                    let prepopulated = from ~ name;
                    if (ctx.files.has(prepopulated))
                        return prepopulated;
                }
            }

            return path;
        }

        fn main() {
            implicit mut ctx: Context;
            return resolveFile("a").len - 1;
        }
    `);

    ZERO(`
        struct S { i: i32; };

        fn hello(ref s: S, w: i32) {
            infix fn |=(<fail ambig 6:17><pass/>shadow </fail>ref s: S, v: i32)
                s.i |= v << w;

            s |= 2;
        }

        fn main() {
            mut s = 1.S;
            s.hello(3);
            return s.i - 17;
        }
    `);

    ZERO(`
        fn lex(src: string) {
            let end = src.len;
            mut idx = 0;

            fn err_str(idx1: i32) {
                while (idx < end && src[idx] == ' ') idx++;
                return src.slice(idx, idx1);
            }

            fn err(idx1_x2: i32) err_str(idx1_x2 /2);
            return err(end *2);
        }

        fn main() lex("    hello").len - 5;
    `);

    ZERO(`
        pub fn ZERO(implicit ref sum: i32, mut sources: string[]): void
        {
            // Fuzzing module splits.
            for (mut i = 0; i < sources.len; i++)
            {
                for (;;)
                {
                    ref src     = sources[i];

                    mut start0  = src.find("[split/]");
                    if (start0 < 0)
                        break;

                    let start00 = start0;
                    let start1  = start0 + 8;
                    while (start0 && src[start0 - 1] == ' ') start0--;

                    let moduleA = src.slice(0, start0);
                    let moduleB = src[start0 : start00] ~ "import _" ~ i ~ ";" ~ src[start1 : src.len];
                    let without = src[0 : start0] ~ src[start1 : src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                }

                sum += sources[i].len;
            }
        }

        fn main() {
            implicit mut sum: i32;

            ZERO( "AAAA|BB[split/]CC".split("|") );
            let expect = 4+2+2 + 4+2+2 + 10; // 10 = "import _0;"

            return sum - expect;
        }
    `);

    ZERO(`
        struct SolvedNode {
            bli: i32;
        };

        // --> [2] ... triggered the solve of this fn, ...
        fn SolvedNode(blah: string) {
            return SolvedNode(blah.len.NOT_PREPPED_YET);
        }

        // [1] During prep, this type annotation ...
        fn ARG_ANNOT_TRIGGERS_SOLVE(node: SolvedNode) {
            return node.bli + 2;
        }

        // --> --> [3] ... which couldnt yet see this fn (prep didnt reach here).
        fn NOT_PREPPED_YET(x: i32) {
            return x * 2;
        }

        fn main() {
            return ARG_ANNOT_TRIGGERS_SOLVE(SolvedNode("hello")) - (2*5+2);
        }
    `);

    ZERO(`
        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                let o = overloads[target.index];
                return o;
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                let nodes = overloads[nid.nodeidx].nodes;
                return nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }
    `);

    ZERO(`
        struct SolvedNode       { nodeidx: i32; };
        struct CurrentFn        { using out: SolvedNode; };

        struct Target           { index: i32; };
        struct SolvedNodeData   { target: Target; };
        struct Overload         { nodes: SolvedNodeData[]; };

        fn test(ref overloads: Overload[],
                ref _current_fn: CurrentFn)
        {
            using fn GET(target: Target) {
                if (target.index != 303) // Same as above, different setup.
                    return overloads[target.index];

                return []; // Also this fails to solve: cannot definit mutref
            }

            using fn SolvedNodeData(nid: SolvedNode) {
                return nid.nodeidx != 303 // Same as above, rewording as a logical.
                    && overloads[nid.nodeidx].nodes[nid.nodeidx];
            }

            let current_fn  = _current_fn.target;               // <- this is a ref into overloads
            let debug_2     = current_fn && GET(current_fn);    // <- this is the perceived write to overloads
            return debug_2 && current_fn.index;                 // <- which invalidates this read
        }

        fn main() {
            mut _current_fn = CurrentFn(SolvedNode(0));
            mut overloads   = [ Overload([ SolvedNodeData(Target(0)) ]) ];

            return test(overloads, _current_fn);
        }
    `);

    ZERO(`
        struct Token {
            col: i32;
            line: i32;
            value: string;
        };

        fn parse(tokens: Token[]) {
            mut _idx = 0;
            mut _loc = 0;

            fn fail(mut reason = "") {
                let loc  = tokens[_loc];
                let here = tokens[_idx];
                if (!reason)
                    reason = "Unexpected '" ~ here.value ~ "'.";

                let l0 = loc.line;  let c0 = loc.col;
                let l1 = here.line; let c1 = here.col;

                let addr = l1 == l0
                    ? "@" ~ l1 ~ ":" ~ c1
                    : "@" ~ l0 ~ ":" ~ c0 ~ ".." ~ l1 ~ ":" ~ c1;

                return throw(addr ~ ":\\n\\t" ~ reason);
            }

            fn consume(value: [byte], err = "") {
                let token = tokens[_idx];
                if (token.value == value) {
                    _idx++;
                    return token;
                }

                return fail((err || "Expected") ~ " '" ~ value ~ "', got '" ~ token.value ~ "'.");
            }

            fn parseRoot() {
                let ret = consume("sof");
                _loc = _idx;
                return ret;
            }

            return parseRoot();
        }

        fn main() {
            return parse([ Token(1, 1, "sof") ]).value.len - 3;
        }
    `);

    ZERO(`
        fn CallerNode(mut t?: i32, arr?: i32[])
        {
            for (mut i = 0; i < arr.len; i++) {
                return CallerNode(arr[i]);
                //     ^^^^^^^^^^
                // fn CallerNode: Arg #1, arr not assignable to host_arg:
                //      expect: []+252i32: ref copy resize
                //      actual: []+252i32: ref
            }

            return t;
        }

        fn main() = CallerNode();
    `);

    ZERO(`
        struct Target       { index: i32; };
        struct SolvedNode   { target: Target; args: SolvedNode[]; };

        fn CallerNode(
            mut target: Target,
            mut args: SolvedNode[] = [],
            reorder?: i32[],
            conversions?: Target[][]): SolvedNode
        {
            if (reorder) {
                mut args_out: SolvedNode[]; args_out.resize(reorder.len);
                for (mut i = 0; i < reorder.len; i++) {
                    let idx = reorder[i];
                    if (idx >= 0)
                        args_out[i] = args[idx];
                }

                args = args_out;
            }

            for (mut argIdx = 0; argIdx < conversions.len; argIdx++) {
                let conversion = conversions[argIdx];
                for (mut i = 0; i < conversion.len; i++) {
                    args[argIdx] = CallerNode(conversion[i]);
                    //             ^^^^^^^^^^
                    // fn CallerNode: Arg #2, reorder not assignable to host_arg:
                    //      expect: []+252i32: ref copy resize
                    //      actual: []+252i32: ref copy
                }
            }

            return SolvedNode(:target, :args);
        }

        fn main() {
            return CallerNode(Target(0)).target.index;
        }
    `);

    ZERO(`
        fn qSTACK(x: i32) {
            let rec = x & 1 && "rec ";
            let via = !rec && qSTACK(x / 2);
            return "\\n" ~ rec ~ "at #" ~ x ~ via;
        }

        fn main() qSTACK(2).len - 2 - 4 - 8 - 2;
    `);

    ZERO(`
        struct SolvedNode { items: SolvedNode[] };

        fn solve(node: SolvedNode) {
            mut events = 0;

            fn propagateType(shadow node: SolvedNode) {
                fn tryTrackLastUse() !(node.items.len & 1);
                let canDiscard = node.items.len != 0;
                fn discardIntoBlock() tryTrackLastUse();

                if (canDiscard && discardIntoBlock)
                    propagateType(node.items[0]);

                events++;
            }

            propagateType(node);
            return events;
        }

        fn main() solve(SolvedNode([ SolvedNode(), SolvedNode() ])) == 2 ? 0 : 1;
    `);

    ZERO(`
        fn path_relative(from: string, to: string): string {
            let min = from.len < to.len ? from.len : to.len;

            mut same = 0;
            for (mut i = 0; i < min; i++) {
                let a = from[i];
                let b = to[i];

                if (b != a)
                    break;

                if (b == '/')
                    same = i + 1;
            }

            mut res: string;
            for (mut i = same; i < from.len; i++)
                if (from[i] == '/')
                    res ~= "../";

            res ~= to.slice(same);
            return res;
        }

        fn main() {
            let from    = "/a/b/c";
            let to      = "/a/e/f";
            let rel     = path_relative(:from, :to);

            return rel == "../e/f" ? 0 : 1;
        }
    `);

    ZERO(`
        inline fn test(ref a: i32[]) {
            if ((a[0] + a[2]) & 1) {
                shadow ref a = a[0 : 2];                        ;; GNUStmtExpr
                return a;
            }
            else {
                shadow ref a = a[2 : 4];                        ;; PointlessLocal
                return a;
            }
        }

        inline fn sum(ref a: [i32]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            for (mut i = 0; i < a.len; i++) a[i] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            return sum(test(a))[0] - 7;
        }
    `);

    ZERO(`
        inline fn test(ref a: i32[], ref b: i32[]) {
            if ((a[0] + b[0]) & 1)
                return a;

            return b;
        }

        inline fn sum(ref a: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < a.len; i++) sum += a[i];
            a.shrink(1);
            a[0] = sum;
            return a;
        }

        fn main() {
            mut a = [ 1, 2 ];
            mut b = [ 3, 4 ];
            return sum(test(a, b))[0] - 7;                      ;; GNUStmtExpr
        }
    `);

    ZERO(`
        inline fn grow_if_oob(ref a: $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        inline fn hey(ref arr: i32[], a: i32) {
            if (a & 1) {
                arr.grow_if_oob(a)++;
                <alt>
                return arr[0 : a + 1];
                </alt>
            }

            return arr;
        }

        fn main() {
            mut a = [ 1 ];
            return a[0] - hey(a, 1)[1];                         ;; GNUStmtExpr
        }
    `);

    ZERO(`
        fn serializeType(type: string, debug: string)
            debug ~ ":" ~ type;

        fn mangleArguments(args: [$T]): string {
            mut mangle = "";
            for (mut i = 0; i < args.len; i++) {
                if (i) mangle ~= ",";
                mangle ~= serializeType(args[i], debug: "M");
            }
            return mangle;
        }

        fn trySpecialize(args: string[], ref args_mangled: string) {
            args_mangled ||= mangleArguments(args);
            return args_mangled.len;
        }

        fn main() {
            mut args_mangled: string;
            return trySpecialize([ "a", "b" ], args_mangled) - 7;
        }
    `);

    ZERO(`
        let EMIT_CPP = 1 << 0;
        let EMIT_OBJ = 1 << 1;
        let EMIT_BIN = 1 << 2;

        struct Cmd { self: string; options: i32 };

        inline fn unlessHasExt(str: string) {
            let idx = str.find('.');                            ;; GNUStmtExpr
            if (idx > 0)
                return [];

            return str;
        }

        fn parseOptions(argv: string[]) {
            mut idx = 0;
            fn next(): string {
                let i = idx++;
                if (i < argv.len) return argv[i];
                return "";
            }

            let self = next();
            if (argv.len == 1) // Exit 0 on no command, else we fail build-checks.
                return [];

            mut options: i32;
            mut val = next();
            while (val.len > 1 && val[0] == '-') {
                mut opt = val;
                if (opt[1] != '-') {
                    opt = [ opt[1] ];
                    val = '-' ~ val.slice(2);
                    if (val == "-")
                        val = next();
                }
                else
                    val = next();

                fn option(short: string, o: i32) {
                    if (opt == short) {
                        options |= o;
                        opt = "";
                    }
                }

                option("c", EMIT_CPP);
                option("o", EMIT_OBJ);
                option("b", EMIT_BIN);

                if (opt)
                    throw("Unknown option: '" ~ opt ~ "'.");
            }

            return Cmd(unlessHasExt(self), options);
        }

        fn main() = parseOptions([ "./hey", "-c", "-b" ]).options - (EMIT_CPP | EMIT_BIN);
    `);

    ZERO(`
        fn withPrefixed(b: byte, view: [byte], fn) {
            mut tmp: string;
            return fn(view.len > 1 ? view : tmp = b ~ view);
        }

        fn main() withPrefixed('a', "b"): |ab| return ab.len - 2;
    `);

    // Note: see the other tryIntersect test -
    //  this used to work/compile/run but perhaps by sheer luck,
    //   anyway, the fn is inline, withMatch doesn't really need an array, etc,
    //    plently of ways to make this work.
    //
    TODO_relaxer(currently: "cannot move from slice 17:41+5", `
        fn tryIntersect(left: [byte], right: [byte], withMatch) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;

            <alt>
            mut tmp: string;
            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : tmp = (qq.byte ~ left[lq && 1 : left.len]),
            <alt/>
            return withMatch(qq == ll ? left
                           : qq == rr ? right
                           : qq.byte ~ left[lq && 1 : left.len],
            </alt>
                left?:  qq == ll,
                right?: qq == rr);
        }

        fn main() {
            tryIntersect("7a012345678900123456789001234567890"
                       , "5a012345678900123456789001234567890"): |m, left!|
            {
                return m == "7a012345678900123456789001234567890" && left ? 0 : 100;
            }

            return 101;
        }
    `);

    ZERO(`
        // Added this while replacing the inliner, used to compile with a [byte].
        <fail cannot be copied or moved from 20:50>
        type Right = byte[:]; <pass/>
        type Right = byte []; </fail>

        fn tryIntersect(left: [byte], right: Right, ifLeft, ifNotLeft) {
            let l =  left[0];
            let r = right[0];
            let lq = l > '0' && l < '8';
            let rq = r > '0' && r < '8';

            if (left[lq && 1 : left.len] != right[rq && 1 : right.len])
                return false;

            let ll = lq && l.i32 - '0'.i32;
            let rr = rq && r.i32 - '0'.i32;
            let qq = ll | rr;

            if (qq == ll)   ifLeft();
            else            ifNotLeft(qq == rr ? right : qq ~ right[rq && 1 : right.len]);

            return true;
        }

        fn TP_get(typeParams!: string, id!: string)
        {
            id || throw("Assertion failed.");

            mut start = 0;
            for (;;)
            {
                let idx = typeParams.find(id, :start);
                if (idx < 0)
                    return -1;

                start = id.len;
                if (typeParams[start] == ' ')
                    return start + 1;
            }
        }

        fn TP_upsert(ref typeParams!: string, id!: string, canon: string) {
            let start = TP_get(:typeParams, :id);
            if (start < 0) {
                typeParams ~= id;
                typeParams ~= canon;
                typeParams ~= '\t';
                return true;
            }

            let end = typeParams.find('\t', :start);
            return tryIntersect(typeParams[start : end], canon,
                ifLeft: || { /* egyptian */
                    return true;
                },                  // <- Lint complained about the nested curlies here ...
                ifNotLeft: |inter|
                { /* pedantic */
                    typeParams.splice(start, end - start, inter);
                    return true;
                });                 // <-  ... and here.

            return false;
        }

        fn main() {
            mut typeParams = "$T 3hey\t";

            // I was fiddling with jumps, and broke return type reporting,
            //  so that TP_upsert here was always assumed to return true (tryIntersect can return false above),
            //   adding this because the test didn't care.
            if (TP_upsert(:typeParams, id: "$T", "x4x"))
                return 202;

            return TP_upsert(:typeParams, id: "$T", "4hey")
                && typeParams == "$T 7hey\t" ? 0 : 101;
        }
    `);

    ZERO(`
        fn fails_with_silly_error(ref set: i32[], i) {
            <fail bad call arg 4:18>
            set  ||= i; <pass/> // this BUGged out instead of
            set   ~= i; </fail> //  outputing a decent err msg
            return set;
        }

        fn main() {
            mut set = [ 0 ];
            fails_with_silly_error(set, 2);

            mut sum = 0;
            for (mut i = 0; i < set.len; i++) sum += set[i];
            return sum - 2;
        }
    `);

    ZERO(`
        fn solve(ref output: i32[], input: i32[])
        {
            fn SLOW_traverse(visit)
                for (mut i = 0; i < input.len; i++)
                    visit(input[i]);

            fn qSTACK(id: i32, implicit _current_fnort: i32) {
                SLOW_traverse: |x|
                    if (id == x)
                        return id || _current_fnort;

                return 0;
            }

            fn doTrySpecialize(target: i32)
            {
                fn updateScope(result: i32)
                    output ~= result || qSTACK(result + 1);

                if (target & 1) {
                    updateScope(target); // 1 - 1
                    return;
                }

                let implicit _current_fnort = target;
                updateScope(target / 2); // 4 - 2, 2 - 1, 0 - 0
            }

            let implicit _current_fnort = 1;

            doTrySpecialize(1);
            for (mut i = 0; i < input.len; i++)
                doTrySpecialize(input[i]);
        }

        fn main() {
            mut output: i32[];
            solve(output, input: [ 0, 3 ]);

            return output[0] == 1
                && output[1] == 0
                && output[2] == 3 ? 0 : 1;
        }
    `);

    ZERO(`
        <fail does nothing><pass/>
        lax                </fail>
        fn noop_let_lax(lax ref x: i32) {
            let lax y = x;
        }

        fn main() {
            mut x = 0;
            noop_let_lax(x);
            return x;
        }
    `);

    ZERO([`
        fn compile_begin(mul: i32) {
            let id = mul * 10;
            let implicit options = getModule(:id);
            return compile(:id);
        }

        fn compile(implicit options: i32, id: i32) {
            return getModule(id) + options;
        }

        fn getModule(id: i32, implicit ctx: i32) {
            return ctx + id;
        }
    `,
    `
        import _0;

        fn main() {
            let implicit ctx = 2;
            return compile_begin(3) - 64;
        }
    `]);

    ZERO([
    `
        // An empty file.
    `,
    `
        fn sqr(x: i32) x * x;
    `,
    `
        import _0;
        import _1;

        fn main() = 0.sqr;
    `]);

    ZERO(`
        struct vec2 {
            x?: f32;
            y?: f32;
        };

        inline fn *=(ref a: vec2, b: f32) {
            a.x *= b;
            a.y *= b;
            return a;
        }

        fn main() {
            mut v = vec2(1, 1);
            v *= 0.5; // BUG: Considering copy or move for incompatible types: vec2: copy <- f32: copy
            return v.x.i32;
        }
    `);

    ZERO([
    `
        struct vec3 { x: f32; y: f32; z: f32; };

        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn vec3(x!: f32, y!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(y!: f32, x!?: f32, z!?: f32) vec3(x, y, z);
        inline fn vec3(z!: f32, x!?: f32, y!?: f32) vec3(x, y, z);

        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
    `,
    `
        import _0;

        struct Atmosphere { pView: vec3; rPlanet: f32; };

        let rEarth: f32 = 1e3;

        fn Atmosphere(
            altitude: f32,
            rPlanet: f32 = rEarth,
            vUp = vec3(z: 1)) // <- this crashes
        {
            let pView = vUp * (rPlanet + altitude);
            return Atmosphere(:rPlanet, :pView);                ;; GNUStmtExpr
        }
    `,
    `
        import _0;
        import _1;

        fn main() {
            let atmo = Atmosphere(altitude: 1e2);
            return atmo.pView.z == 11e2 ? 0 : 1;                ;; GNUStmtExpr
        }
    `]);

    ZERO([
    `
        inline fn vec3(fill!: f32) fill;

        let kMie_min: f32 = 3e-6;
        inline fn Atmo(kMie = vec3(fill: kMie_min)) = kMie;     ;; PointlessLocal

        fn main() Atmo == 3e-6 ? 0 : 1;                         ;; GNUStmtExpr
    `]);

    ZERO([
    `
        struct vec3 { x: f32; y: f32; z: f32; };
        inline fn vec3(fill!: f32) vec3(fill, fill, fill);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);

        <split/>
        let kMie_min: f32 = 3e-6;
        inline fn Atmosphere(kMie = vec3(fill: kMie_min)) = kMie.y * 2;

        <split/>
        fn main() Atmosphere == 6e-6 ? 0 : 1;                   ;; GNUStmtExpr
    `]);

    ZERO(`
        struct Loop { l: i32 };
        struct Ring { r: i32 };
        struct Mesh { m: i32 };

        fn op(ref m: Mesh, x: i32, l: Loop) m.m += l.l + x;
        fn op(ref m: Mesh, r: Ring, x: i32) m.m *= r.r + x;
        fn op(using ref m: Mesh, l: Loop, r: Ring, x: i32) {
            l.op(:x);
            r.op(:x);
        }

        fn main() {
            mut m = Mesh(1);
            m.op(Loop(2), Ring(7), x: 1);
            return m.m == 32 ? 0 : 1;
        }
    `);

    ZERO([`
        pub struct MultiDraw { id: i32; }
    `,
    `
        import _0;
        type ViewQuads = MultiDraw;

        fn ViewQuads(id!: i32, populate!): ViewQuads {
            mut vq = ViewQuads(:id);
            populate(vq);
            return vq;
        }
    `,
    `
        import _1;
        fn ViewQuads(id!: i32, camera!: i32): ViewQuads {
            return ViewQuads(:id, populate: |ref vq| vq.id += camera);
        }

        fn main() {
            return ViewQuads(id: 2, camera: 5).id - 7;
        }
    `]);

    ZERO(`
        fn setupOperators()
        {
            struct Maplike {
                keys: string[];
                vals: i32[];
            };

            fn set(ref m: Maplike, k: string, v: i32) {
                m.keys ~= k;
                m.vals ~= v;
            }

            struct BINOP {
                PRECEDENCE: Maplike;
                RIGHT_TO_LEFT: bool[];
            };

            mut out: BINOP;
            mut precedence: i32 = -1;
            mut rightToLeft = false;

            fn binop(ops: string[]) {
                precedence++;
                out.RIGHT_TO_LEFT ~= rightToLeft;
                for (mut i = 0; i < ops.len; i++)
                    out.PRECEDENCE.set(ops[i], precedence);
            }

            rightToLeft = false;
            binop([ "*", "/", "%" ]);

            rightToLeft = true;
            binop([ "*=", "/=", "%=" ]);

            return out;
        }

        let BINOP = setupOperators();
        fn main() BINOP.RIGHT_TO_LEFT[1] && BINOP.PRECEDENCE.vals[3] == 1 ? 0 : 1;
    `);

    ZERO(`
        fn Split !T(str: T[], sep: T or T[:], each) {
            mut last_idx = 0;
            mut next_idx = 0;

            let N = typeof(sep) -> T[:] ? sep.len : 1;
            if (N) while ((next_idx = str.find(sep, start: last_idx)) >= 0) {
                each(str.slice(last_idx, next_idx), first?: !last_idx, last?: false);
                last_idx = next_idx + N;
            }

            if (last_idx)
                each(str.slice(last_idx), first?: false, last?: true);
            else
                each(str, first?: true, last?: true);
        }

        fn Replace !T(str: T[], all: T or T[:], with: T or T[:] or []) {
            mut result: T[];
            Split(str, sep: all, |substr, lax first, lax last| {
                if !(first) {
                    if !(typeof(with) -> [])
                        result ~= with;
                }
                else if (last) {
                    return str;
                }

                result ~= substr;
            });

            return result;
        }

        fn main() {
            let res = "hello".Replace(all: "ll", with: []);
            return res == "heo" ? 0 : 1;
        }
    `);

    ZERO(`
        struct BitSet { _data: u8[] };

        fn add(using _: &mut BitSet, idx: int) {
            let no_neg = idx & int.MIN;
            let bucket = idx >> 3 | no_neg;
            let bit    = idx & 7;
            let mask   = 1 << bit.u8;

            if (_data.len <= bucket)
                _data.grow(bucket + 1);

            _data[bucket] |= mask;
        }

        fn each(using _: BitSet, visit) {
            for (mut i = 0; i < _data.len; i++) {
                let item = _data[i];
                if (item) for (mut b = 0; b < 8; b++) {
                    let mask = 1 << b.u8;
                    if (item & mask)
                        visit(i << 3 | b.int);
                }
            }
        }

        struct Node { items: Node[] }

        fn each(using n: Node, visit)
            for (mut i = 0; i < n.items.len; i++)
                visit(n.items[i]);

        fn traverse(ref node: Node, ref bitset: BitSet) {
            bitset.add(node.items.len);
            node.each(.traverse(:bitset));

            mut res = 0;
            bitset.each: |index|
                res += index;

            return res;
        }

        fn main() {
            mut bitset: BitSet;
            return traverse(Node([ Node([ Node, Node, Node ]), Node ]), :bitset) == 5 ? 0 : 1;
        }
    `);

    ZERO([`
        struct Type {
            quals: i32;
            canon: string;
        };

        fn is_never (t: Type) t.canon == "never";
        fn is_zeroes(t: Type) t.canon == "zeroes";

        let CANNOT_definit_mutrefs = true;

        fn clear_mutref(mut t: Type) {
            t.quals &= ~1;
            return t;
        }

        fn union(a: Type, b: Type, DONT_match_zeroes!?: bool) {
            if (a.canon != b.canon)
                return a.is_never  ? b
                     : b.is_never  ? a
                     : a.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(b) : b
                     : b.is_zeroes && !DONT_match_zeroes ? CANNOT_definit_mutrefs ? clear_mutref(a) : a
                     : [];

            return Type(:a.canon, a.quals | b.quals);
        }
    `,`
        import _0;
        fn main() {
            let Hey1    = Type(1, "hey");
            let Zeroes  = Type(0, "zeroes");
            let res     = union(Hey1, Zeroes);
            return res.canon == "hey" && res.quals == 0 ? 0 : 1;
        }
    `]);

    TODO_inline(currently: "BUG exit code", `
        fn inline_args_and_closures(inline nums: i32[]) {       ;; GNUStmtExpr
            mut sum: i32;
            noinline fn woot(z: i32)                // previously a new woot was emitted
                for (mut i = 0; i < nums.len; i++)  //  with the nums expr inlined,
                    sum += nums[i] & z;             //   now nums doesnt inline inside woot

            for (mut i = 0; i < nums.len; i++) {
                if (i > 0) woot(nums[i] & nums[i - 1]);         ;; PointlessMustSeq
                if (i > 1) woot(nums[i] & nums[i - 2]);
            }

            return sum;
        }

        fn main() {
            mut x = 0;
            let res = inline_args_and_closures([ x++, x++, x++ ]);
            return x == 93 && res == 290 ? 0 : 1;
        }
    `);

    ZERO(`
        <fail inline recursi>
        inline <pass/></fail>
        fn inlineSelfRecursion(x: int)
            x > 10  ? inlineSelfRecursion(x / 2)
                    : x;

        fn main() inlineSelfRecursion(15) == 7 ? 0 : 1;
    `);

    ZERO(`
        <fail inline recursi>
        inline <pass/></fail>
        fn inlineMutualRecursion_a(x: int)
            x > 10  ? inlineMutualRecursion_b(x / 2)
                    : x;

        inline fn inlineMutualRecursion_b(x: int)
            x > 5   ? inlineMutualRecursion_a(x / 2)
                    : x;

        fn main() inlineMutualRecursion_a(15) == 3 ? 0 : 1;
    `);

    ZERO(`
        nocopy struct SolverOutput {
            content?: SolverOutput[];
        };

        fn test(ref _helpers_data: i32[], mut content: SolverOutput[])
        {
            _helpers_data.len & 1 && _helpers_data.pop();
            {
                _helpers_data && throw("non-empty _helpers_data.");
                {
                    content.len & 1 && content.pop();
                    {
                        return SolverOutput(:content);
                    }
                }
            }
        }

        fn main() {
            mut _helpers_data: i32[];
            mut content: SolverOutput[];
            return test(_helpers_data, content).content.len;    ;; !*MustSeq
        }
    `);

    ZERO(`
        struct Type { quals: i32; };
        struct Node { type: Type; };

        fn unusedLetExprOrBlock(args_in: [Node], default: Node) {
            mut inType: Type;
            for (mut i = 0; i < args_in.len; i++) {
                // got this while auto-reducing smth else,
                //  nonsense but currently bugs mcom
                lax let inValue = args_in[i] || {
                    inType = default.type;  //      <- then, mcom tries to copy here
                    default                 // <- first this gets discarded
                };
            }

            return inType;
        }

        fn main() {
            return unusedLetExprOrBlock([ Node() ], Node(Type(1))).quals - 1;
        }
    `);

    ZERO(`
        fn parse !T(v: [byte], lax as!: T) {
            mut result: T;

            if (T.is::bitfield) {
                for (mut i = 1; i < v.len; i++) {
                    if (v[i] == '|') {
                        return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);
                    }
                }
            }

            for (mut i = 0; i < v.len; i++) {
                if (v[i] == '*') {
                    let prefix = v[0 : i];
                    let suffix = v[i + 1 : v.len]

                    for (fieldname i: T) {
                        let opt = "i";
                        if (opt.starts(with: prefix) && opt.ends(with: suffix))
                            result |= T.i;
                    }

                    return result;
                }
                else if (i > 0 && v[i] == '|') {
                    return parse(v[0 : i], :as) | parse(v[i + 1 : v.len], :as);
                }
            }

            for (fieldname i: T)
                if (v == "i")
                    return T.i;

            return [];
        }

        flags UpperCase { Hello = 1; World = 2; Cruel = 4; CruelWorld = 8 };
        flags LowerCase { hello = 16; world = 32; cruel = 64; cruel_world = 128 };

        fn parseUpperOrLower(str: string) {
            if (let upper = parse(str, as: UpperCase))
                return upper.i32;
            else if (let lower = parse(str, as: LowerCase))
                return lower.i32;
            else
                return 0;
        }

        fn main() {
            if (parseUpperOrLower("World|Cruel*") != 2|4|8) return 1;
            if (parseUpperOrLower("*world|hello") != 16|32|128) return 2;
            return 0;
        }
    `);

    ZERO(`
        struct Type { items: Type[]; }

        fn solve(root: Type) {
            mut out = 0;
            fn test_node(node: Type) {
                for (mut i = 0; i < node.items.len; i++)
                    test_node(node.items[i]);

                fn checkLt(actual: Type) {
                    out += node.items.len;
                    for (mut i = 0; i < actual.items.len; i++)
                        checkLt(actual.items[i]);
                }

                checkLt(node);
            }

            test_node(root);
            return out;
        }

        fn main() solve(Type([ Type([ Type, Type ]), Type([ Type, Type, Type ]) ])) == 34 ? 0 : 1;
    `);

    ZERO(`
        fn runSolver(
            implicit ref notes: i32,
            break_notes: i32,
            implicit ref value: i32)
        {
            fn makeNote(note: i32, inline reason: string) {
                if (break_notes & note)
                    throw("#" ~ note ~ ": " ~ reason);

                notes |= note;
            }

            if (value > 0) {
                if (value++ & 1) return makeNote(1, "A: " ~ value);
                if (value++ & 2) return makeNote(2, "B: " ~ value);
            }
            else {
                if (value++ & 4) return makeNote(4, "C: " ~ value);
                if (value++ & 8) return makeNote(8, "D: " ~ value);
            }
        }

        fn main() {
            implicit mut notes: i32;
            <fail unused print>
            implicit mut print: string; <pass/></fail>
            implicit mut value = 0;

            runSolver(1|2);
            runSolver(4|8);
            return value == 4 && notes == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target { x: i32; };

        fn ScopeSkip_push_bad_args(targets: Target[], ref sum: i32) {
            fn descend(acc?: bool) {
                fn foreach(t: Target) {
                    if (acc)    sum += t.x;
                    else        descend(true);
                }

                targets.each(|u| foreach(u));
            }

            descend();
        }

        fn main() {
            mut targets = [ Target(1), Target(2) ];
            mut sum = 0;
            ScopeSkip_push_bad_args(:targets, :sum);
            return sum == 6 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Module { events: i32; };

        <alt>
        inline   <alt/>
        noinline </alt>
        fn profile(implicit ref module: Module, id: i32, op) {
            let events0 = module.events;
            op();
            module.events += (events0 + id);
        }

        <alt>
        inline   <alt/>
        noinline </alt>
        fn propagateType(implicit ref module: Module) {
            profile(2, |<alt>lax unused?</alt>| module.events = 1);
        }

        <alt>
        inline   <alt/>
        noinline </alt>
        fn runAllPasses() {
            profile(3, fn propagateType);
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Module { events: i32; };

        // Same as above but uses unwrap.
        fn profile(implicit ref module: Module, id: i32) unwrap {
            let events0 = module.events;
            defer module.events += (events0 + id);
        }

        <alt>
        inline   <alt/>
        noinline </alt>
        fn propagateType(implicit ref module: Module) {
            profile(2);
            module.events = 1;
        }

        <alt>
        inline   <alt/>
        noinline </alt>
        fn runAllPasses() {
            profile(3);
            propagateType();
        }

        fn main() {
            implicit mut module: Module;
            runAllPasses();
            return module.events == 1 + 2 + 3 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target { template: string; };
        fn BUG(what?: string) throw(what || "Assertion failed.");

        fn assign_WOOT(ref into: Target) {
            mut name = "";
            mut what = "WOOT";
            name ||= what || BUG(); // arg inliner out of range local
            into.template = name;
        }

        fn main() {
            mut t = Target();
            assign_WOOT(into: t);
            return t.template == "WOOT" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Overload { type: Type; }
        struct Type     { lifetime: i32[]; }

        fn BUG(implicit _here: i32, reason: string)
            throw(_here ~ ": " ~ reason);

        fn is_even(type: Type) {
            let a = !(type.lifetime.len & 1);
            let b =   type.lifetime.len < 4;
            a && !b && BUG("THROW-1");
            return a;
        }

        fn solve(check: Type) {
            let implicit mut _here: i32;

            using fn GET(implicit overloads: Overload[], target: i32)
                target < 0 || target >= overloads.len
                    ? BUG("THROW-2")
                    : overloads[target];

            fn Lifetime_each(type, visit)
                for (mut i = type.lifetime.len; i --> 0; )
                    visit(t: type.lifetime[i]);

            fn Lifetime_allEven(type: Type): bool {
                Lifetime_each(:type, visit: |t| {
                    if (!t.type.is_even)                return false;
                    if (!Lifetime_allEven(t.type))      return false;
                    _here = t;
                });

                return true;
            }

            return Lifetime_allEven(check);
        }

        fn main() {
            let implicit overloads = [
                Overload(),             // 0] even
                Overload(Type([0])),    // 1] odd
                Overload(Type([0, 0])), // 2] even
                Overload(Type([0, 2])), // 3] even
            ];

            if !(solve(Type()))         return 1;
            if  (solve(Type([ 1, 2 ]))) return 2;
            if !(solve(Type([ 2, 3 ]))) return 3;
            return 0;
        }
    `);

    ZERO(`
        struct Overload { name: string; args?: Argument[]; }
        struct Argument { name: string; }
        struct Target   { index: i32; }

        fn solve(overloads: Overload[], check: Target, from?: Target)
        {
            fn fail(mut reason: string) {
                if (from)
                    reason ~= GET(from).qWHAT;

                return throw(reason);
            }

            fn qWHAT(o: Overload) o.name.human;
            fn qWHAT(a: Argument) a.name.human;

            fn tryParse(id: string)
                id.len == 1 && id[0] >= '0' && id[0] <= '9'
                    && Target(index: id[0].i32 - '0'.i32);

            fn human(id: string) {
                let t = tryParse(:id);
                return t ? GET(t).name : id;
            }

            fn parent(target: Target)
                target.index > 0
                    && Target(target.index - 1);

            using fn GET(target: Target) {
                if (overloads.len < target.index)
                    fail("Parent: " ~ (target.parent ? GET(target.parent).name : "-"));

                return overloads[target.index - 1];
            }

            return check.qWHAT;
        }

        fn main() {
            let overloads = [
                Overload("hello"),
                Overload("1"),
            ];

            return solve(overloads, check: Target(2)) == "hello" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Type { quals: i32; lifet: i32 };

        fn tryInter(a: Type, b: Type) {
            let quals = a.quals & b.quals;
            let lifet = a.lifet & b.lifet;
            if (!lifet && (a.lifet || b.lifet))
                return [];

            return quals;
        }

        fn fail(reason: string) {
            return 101 + reason.len;
        }

        fn intersect(reason: string, a: Type, b: Type) {
            return tryInter(a, b) || fail(reason);
        }

        fn main() {
            let a = Type(quals: 1, lifet: 1);
            let b = Type(quals: 3, lifet: 3);
            return intersect("Hello!", a, b) == 1 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Item { val: i32 };

        fn Each !T(a: T[:], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i], i?: i);

        fn parseStructDecl(ref items: [Item], ref sum: i32) {
            if (items.len & 2)
                parseStructDecl(items[1 : items.len], sum);     ;; PointlessMustSeq

            :BLOCK {
                items.Each: |item|
                    if ((sum += item.val) & 2)
                        break :BLOCK;                           ;; Goto

                items.Each: |ref item|
                    item.val += sum;
            }

            items.Each: |ref item|
                item.val++;
        }

        fn main() {
            mut sum = 0;
            mut items = [ Item(0), Item(1) ];
            parseStructDecl(items, sum);
            return sum == 4
                && items[0].val == 5
                && items[1].val == 8 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Node {
            value?: string;
            items?: Node[];
        };

        fn SLOW_traverse(node: Node, visit) {
            mut stack = [ node ];
            while (stack) {
                shadow mut node = stack[stack.len - 1];
                stack.pop();
                visit(node);
                for (mut i = node.items.len; i --> 0; )
                    stack ~= node.items[i];
            }
        }

        fn qSTACK(node: Node) {
            SLOW_traverse(node): |n| {
                if (n.value && n.items)
                    return n.value ~ ", " ~ qSTACK(n.items[0]);
            }

            return node.value ~ "!";
        }

        fn main() {
            let res = qSTACK(
                Node(items: [
                    Node("Ignore me"),
                    Node("Hello", [ Node("World") ]),
                ]));

            return res == "Hello, World!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn merge !T(l: [T], r: [T], left, right, both) {
            mut li = 0;
            mut ri = 0;
            for (;;) {
                inline fn L = l[li];
                inline fn R = r[ri];
                let l_done = li == l.len;
                let r_done = ri == r.len;

                let cmp = l_done ? r_done ? { return; } : +1
                                 : r_done ? -1
                                 : L <> R;
                if (cmp == 0) {
                    both(L, left?: li, right?: ri);
                    li++;
                    ri++;
                }
                else if (cmp < 0) {
                    left(L, left?: li, right?: ri);
                    li++;
                }
                else {
                    right(R, left?: li, right?: ri);
                    ri++;
                }
            }
        }

        fn inter !T(l: T[], r: T[]) {
            if (r.len < l.len)
                return inter(r, l);

            mut result: T[];
            mut useResult = false;

            merge(l, r,

            left: |_, left| {
                if (!useResult) {
                    useResult = true;
                    result = l.slice(0, left);
                }
            },

            right: |_| {},

            both: |item| {
                if (useResult)
                    result ~= item;
            });

            return useResult ? result : l;
        }

        <split/>
        struct Region { index: i32 };
        struct Lifetime { uni0n: i32[]; };

        fn Lifetime_inter(a: Lifetime, b: Lifetime): Lifetime = // nested { return } in merge
            Lifetime(uni0n: inter(a.uni0n, b.uni0n));           ;; GNUStmtExpr

        <split/>
        fn main() {
            mut a = Lifetime([ 1, 2, 3 ]);
            mut b = Lifetime([ 2, 3, 4 ]);
            mut c = Lifetime_inter(a, b);
            return c.uni0n == [ 2, 3 ] ? 0 : 1;
        }
    `);

    ZERO(`
        struct Type { canon: string; quals: i32 };
        struct Node { type: Type; value: string };

        let t_f32 = Type("f32", 2);
        let t_f64 = Type("f32", 2);

        fn solveReal(lax v: string, type: Type): Type {
            if (type.canon == t_f32.canon) return t_f32;
            return t_f64;
        }

        fn tryRetype(node: Node, expect: Type): Type {
            return solveReal(node.value, expect);
        }

        fn main() {
            let a = Node(t_f64, "0.0");
            let b = tryRetype(a, t_f32);
            return b.canon == "f32" ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            nocopy struct Nc { items: Nc[]; };

            fn rem_odd(ref items: Nc[])
                for (mut i = items.len; i --> 0; )
                    if (i & 1)
                        items.splice(i, 1);

            mut items: Nc[];
            for (mut i = 0; i < 11; i++)
                items ~= Nc(i & 1 ? [ Nc ] : [ Nc, Nc ]);

            rem_odd(items);

            mut sum = 0;
            fn visit(shadow items: [Nc])
            {
                fn visit(nc: Nc) {
                    sum++;
                    visit(nc.items);
                }

                for (mut i = 0; i < items.len; i++)
                    visit(items[i]);
            }

            visit(items);
            return sum == 18 ? 0 : 1;
        }
    `);

    ZERO(`
        let SMTH = false;

        fn FAIL(reason: string, implicit ref log: string)
            log ~= reason ~ '\\n';

        fn fail_appendStack(lax mut reason: string)
            SMTH ? reason : [];

        fn fail(mut reason: string)
            FAIL(reason.fail_appendStack());

        fn main() {
            implicit mut log = "";
            fail("Hello!");
            return log.len - 1;
        }
    `);

    ZERO(`
        struct Type { quals: i32 };
        pub fn tryLookupUserType(type: Type) = type;
        fn propagateType(type: Type) {
            let s = tryLookupUserType(type);
            if (s.quals != 13 || true) return 17;
            return 19;
        }

        fn main = 1.Type.propagateType - 17;
    `);

    ZERO(`
        <alt>
        inline          <alt/>
        noinline        </alt>
        fn voidfn(ref a: i32) { a += 100; }

        <alt>
        inline   ;; Goto<alt/>
        noinline        </alt>
        fn returnVoidExpr(ref a: i32, ref b: i32) {
            while (b --> 0) {
                a++;        // bad cg emitted just 'return;'
                if (a & 1)  return voidfn(a);
            }
        }

        fn main() {
            mut a = 0;
            mut b = 10;
            returnVoidExpr(a, b);
            return a == 101 && b == 9 ? 0 : 1;
        }
    `);

    ZERO(`
        fn hello(implicit<alt>: i32</alt>) = implicit;
        fn main() = 0.hello;
    `);

    ZERO(`
        fn voidIf(ref a: i32, ref b: u32)
            <fail no common supertype i32 u32 4:17+1>
            a   ? a++
                : b++;
            <pass/>
            if (a)  a++;
            else    b++;
            </fail>

        fn main() {
            mut a: i32;
            mut b: u32;
            voidIf(:a, :b);
            return !a && b ? 0 : 1;
        }
    `);

    ZERO(`
        struct ScopeItem { id: string; uval: u32 }

        fn search(ref items: [ScopeItem], id: string, ref scope_iterator: i32): u32
        {
            if (!scope_iterator)
                scope_iterator = items.len;

            defer if (scope_iterator == 0)
                scope_iterator = -1;

            while (scope_iterator --> 0) {
                let item = items[scope_iterator];
                if (item.id == id)
                    return item.uval;
            }

            return [];
        }

        fn main() {
            mut items = [ ScopeItem("a", 1), ScopeItem("a", 2), ScopeItem("a", 3) ];
            mut scope_iterator = 0;
            mut uval: u32;

            mut result: u32;
            while (uval = items.search("a", scope_iterator))
                result += uval;

            return (result - 6).signed;
        }
    `);

    ZERO(`
        fn woot!E (e?: E) {
            if (E -> [])
                return 2;
            else
                return e(3);
        }

        fn main() woot * woot(|x| x * 5) - 30;
    `);

    ZERO(`
        fn woot(myfn) myfn(1);

        fn main() {
            mut sum = 0;            // PARSE DRAMA
            woot: |one| sum += one; //  stmt lambda, followed by
            (sum += 1) += 1;        //   '(' which continued as-if-expr
            return sum -3;
        }
    `);

    ZERO([`
        let PROFILE = <alt>true<alt/>false</alt>;

        struct Empty {};
        struct NonEmpty { v: i32 };

        type Item = PROFILE ? NonEmpty : Empty;

        lax fn +=(ref a: Item, b: Item)
            for (fieldname v: Item)
                a.v += b.v;

        fn get(a: Item) PROFILE ? a.v : 0;
    `,`
        import _0;
        fn main() {
            mut a: Item;
            a += Item();
            return a.get();
        }
    `]);

    TODO_ooe(currently: "N_BckMustSeq not listed", `
        fn +=(ref a: i64, b: bool)  // Doesn't cg c++ operator (illegal, operands all prim),
            a += b ? 100 : 0;       //  which drops the RTL ooe guarantee, solver fails to notice.

        fn rellocate(ref a: i64[]) {
            for (mut i = 0; i < 6; i++)
                a ~= a;

            return !!a.len;
        }

        fn main() {
            mut items = [ i64(1), i64(2), i64(3), i64(4) ];
            items[0] += rellocate(items);                       ;; N_BckMustSeq
            return (items[0] - 101).i32;
        }
    `);

    ZERO(`
        fn test(x: i32): bool   <fail return type void does not match annot bool 3:17+1>
            let y = x > 10;     <pass/>
                    x > 10;     </fail>

        fn main() test(3).i32;
    `);

    TODO_ambig(currently: "actual return Node does not match annot bool 9:21+6", `
        fn main() {
            struct Node {};
    <alt>
            fn evalTypeAnnot(node: Node) =
                return !!node;
    <alt/>
            fn evalTypeAnnot(node: Node): bool =
                return node && [];
    </alt>
            fn trySolveTypeParams(node: Node): bool =   <fail actual return void does not match annot bool 9:21+6>
                let expect = evalTypeAnnot(node);       <pass/>
                             evalTypeAnnot(node);       </fail>

            return trySolveTypeParams([]) && 0;
        }
    `);

    ZERO(`
        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Scope    { overloads: Overload[]; extended: Extended[] };
        struct Overload { name: string };
        struct Extended { locals?: Overload[] };

        fn Scope_create(ref scope: Scope, name: string, nest!?: i32): i32 {
            ref overloads = nest > 0
                ? scope.extended.grow_if_oob(nest - 1).locals
                : scope.overloads;

            overloads.push(Overload(:name));
            return overloads.len;
        }

        fn main() {
            mut scope = Scope(
                overloads:  [ Overload("Hello!") ],
                extended:   []);

            let a = scope.Scope_create("World!", nest: 1);
            let b = scope.Scope_create("Bananas!");
            return a * 10 + b - 12;
        }
    `);

    ZERO(`
        fn bfind !T(keys, item: T, hit, miss) {
            mut lo = 0;
            mut hi = keys.len;

            while (lo < hi) {
                let i   = (hi + lo) >> 1;
                let cmp = keys[i] <> item;
                if (cmp == 0)
                    return hit(i);
            }

            return miss(lo);
        }

        fn update !<T, U>(keys, item: T, extras, extra: U)
            bfind(fn keys, :item,
                hit:  |i| { extras[i] = extra; },
                miss: |_| {});

        fn get !<T, U>(keys: T[], item: T, extras: U[])
            bfind(:keys, :item,
                hit:  |i| { return extras[i]; },
                miss: |_| { return []; });

        fn Map(type K, type V)
            struct { keys: K[]; vals: V[] };

        fn set(using ref _: Map(_, _), key, value)
            update(|| keys, key, || vals, value);

        fn get(using _: Map(_, _), key)
            get(keys, key, vals);

        fn resolveFile(ref cache: Map(string, string), path: string): string
        {
            if (let cached = cache.get(path))
                return cached == "\v" ? "" : cached;

            cache.set(path, "\v");
            return "";
        }

        fn main() {
            mut cache: Map(string, string);
            return cache.resolveFile("abc").len;
        }
    `);

    ZERO(`
        struct Target       { globid: i32; locid: i32 }
        struct Overload     { name: string }
        struct Extended     { locals: Overload[] }

        nocopy struct Scope {
            overloads: Overload[]; extended: Extended[]; total: i32
        }

        fn grow_if_oob(ref a: $T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        fn CREATE(ref scope: Scope, name: string, nest!?: Target) {
            ref overloads = nest
                ? scope.extended.grow_if_oob(nest.globid - 1).locals
                : scope.overloads;

            <flip>
            scope.total++;
            <flip/>
            overloads ~= Overload(:name);
            let index = overloads.len;
            </flip>

            return Target(
                globid: nest ? nest.globid : index,
                 locid: nest ? index       : 0);
        }

        fn GET(ref scope: Scope, target: Target)
            target.locid
                ? scope.extended[target.globid - 1].locals[target.locid - 1]
                : scope.overloads[target.globid - 1];

        fn DUPE(ref scope: Scope, target: Target)
            CREATE(scope, GET(scope, target).name);

        fn main() {
            mut scope: Scope;
            let hello = scope.CREATE("hello!");
            let world = scope.CREATE("world!", nest: hello);
            scope.DUPE(world);

            mut result  = "";
            scope.overloads.each: |o, i| {
                result ~= "+" ~ o.name;
                if (scope.extended.len > i)
                    scope.extended[i].locals.each: |x|
                        result ~= "-" ~ x.name;
            }

            return scope.total == 3 && result == "+hello!-world!+world!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn first(s: [$T;]) s.len && s[0];
        struct Node { items: Node[] }

        fn tryFirst(node: Node)
            node.items
                ? tryFirst(node.items.first)
                : node;

        fn main()
            tryFirst(
                Node([ Node([ Node, Node ])]))
                    .items.len;
    `);

    ZERO(`
        fn first(s: [$T;]) s.len && s[0];
        struct Node { value: i32; items: Node[] }

        fn tryFirst(node: Node)
            node.items
                ? tryFirst(node.items.first)
                : node;

        fn main()
            tryFirst(
                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))
                    .value - 3;
    `);

    ZERO(`
        fn first(s: [$T;]) s.len && s[0];
        fn last (s: [$T;]) s.len && s[s.len - 1];
        struct Node { value: i32; items: Node[] }

        fn tryFirst(node: Node)
            node.items  ? tryLast(node.items.first)
                        : node;

        fn tryLast(node: Node)
            node.items  ? tryFirst(node.items.last)
                        : node;

        fn main()
            tryFirst(
                Node(1, [ Node(2, [ Node(3, []), Node(4, []) ])]))
                    .value - 4;
    `);

    ZERO(`
        struct Thing { a: i32; b: i32 };
        struct Stuff { _gets: Thing[]; _root: Thing; _exts: Thing[] };

        fn GET(ref s: Stuff, i: int) s._gets[i];
        fn EXT(ref s: Stuff, i: int) s._exts[i];

        fn lookup(ref s: Stuff, i: int) {
            let start = s._root || s.GET(i);
            if (!start) return start;
            return s.EXT(i);
        }

        fn main() {
            mut s = Stuff([ Thing(0, 1) ], Thing(1, 2), [ Thing(2, 3) ]);
            return s.lookup(0).a - 2;
        }
    `);

    ZERO([`
        fn Zero(implicit ref result: i32, src: i32[:]) =
            src.each: |x, i| result += x * (i + 1);
        fn Todo(implicit ref result: i32, src: i32[:]) =
            src.each: |x, i| result += x * (i + 1) * 7;

        fn Zero(src: i32) = Zero([ src ]);
        fn Todo(src: i32) = Todo([ src ]);
    `,
    `
        import _0;
        fn main() {
            implicit mut result = 0;

            let Solo    = fn Zero;
            lax fn Solo_muteRest(_) {}
            let Zero    = fn Solo_muteRest;
            let Todo    = fn Solo_muteRest;

            let Todo_A  = fn Todo;
            let Todo_B  = fn Todo;

            Zero([ 10 ]);   Zero(11);
            Todo([ 12 ]);   Todo(13);
            Todo_A([ 14 ]); Todo_A(15);
            Todo_B([ 16 ]); Todo_B(17);
            Solo([ 18 ]);   Solo(19);

            return result - 37;
        }
    `]);

    ZERO(`
        struct Node { items: Node[]; }
        struct Type { value: i32 };

        let t_void = Type(0);

        fn main() {
            fn createEmpty(lax type: Type or Node = t_void) = [];

            fn solveTypedef(node): Type {
                let annot = node.items
                    && solveTypedef(node.items[0]);

                if (annot) {
                    mut relaxed = annot;
                    return createEmpty(type: relaxed);
                }

                return createEmpty();
            }

            return solveTypedef(Node()).value;
        }
    `);

    ZERO(`
        using flags DeclAsserts { A; B };
        flags SomethingElse { AA; BB };

        fn GET_NEXT_LOCAL_oob() {
            fn parseNoCopy(x: DeclAsserts or SomethingElse = A) x;
            fn parseBlockLike(y) y | parseNoCopy();
            return parseBlockLike(B);
        }

        fn main() GET_NEXT_LOCAL_oob().i32 - 3;
    `);

    ZERO(`
        fn main() ("hello" == "world").i32;
    `);

    ZERO(`
        struct Node { items?: Node[]; value?: i32 };

        fn tryConvert(ref default: Node) {
            if (default.items) {
                default.items ~= default;
                default.value += 10;
                return true;
            }

            return false;
        }

        fn updateScope(unspecced: Node[], ref defaults: Node[]) {
            for (mut i = 0; i < defaults.len; i++) {
                defaults[i] = {
                    :DEFAULT {
                        if (!unspecced)
                            break :DEFAULT (i < defaults.len - 1)
                                && defaults[i + 1];

                        mut default = unspecced.len > i && unspecced[i];
                        if (default && tryConvert(default))
                            break :DEFAULT default;

                        break :DEFAULT [];
                    }
                };
            }
        }

        fn main() {
            mut nodes = [ Node(items: [ Node() ]) ];
            for (mut i = 0; i < 4; i++) {
                mut node = nodes[nodes.len - 1];
                tryConvert(node);
                nodes ~= node;
            }

            updateScope(nodes, nodes);

            mut checksum = 0;
            fn checksum(shadow nodes: Node[]) {
                checksum += nodes.len;
                for (mut i = 0; i < nodes.len; i++) {
                    let node = nodes[i];
                    checksum(node.items);
                    checksum += 1000 * node.value;
                }
            }

            checksum(nodes);
            return checksum == 570124 ? 0 : 1;
        }
    `);

    TODO_ambig(currently: "Ambig call to u32 4:49+3 matches inline u32 13:19+3", `
        struct TEA { v0: u32; v1: u32 }

        inline fn r4(using ref _: TEA, ref sum: u32) {
            mut delta: u32 = 0x9e3779b9;
            for (mut i = 0; i < 4; i++) {
                sum += delta;
                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        inline fn u32(tea: TEA): u32 =
            tea.v0 ^ tea.v1;                                    ;; GNUStmtExpr

        fn main() {
            mut tea: TEA;
            mut sum: u32;
            tea.r4(sum);
            let actual = tea.u32;
            return actual == 0x93bfa05 ? 0 : 1;
        }
    `);

    ZERO(`
        let a = 7;
        let b = a && 3;
        return b - 3;
    `);

    ZERO(`
        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw("woot");
    `);

    ZERO(`
        struct KindValue { kind: string; value: string; };

        mut spec = KindValue(kind: "fn", value: "val");
        spec.kind == "fn" && spec.value || throw("nope");
        ref v = spec.kind == "fn" ? spec.value : throw("nope");

        v ~= "ue";
        return spec.value == "value" ? 0 : 1;
    `);

    ZERO(`
        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token("hey");
        };

        fn main(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };
    `);

    ZERO(`
        struct ScopeIdx { raw: i32; };
        <fail bad call = 12:27+1 incompatible types for T>
        fn thing(x: i32) x;             <pass/>
        fn thing(x: i32) ScopeIdx(x);   </fail>
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);
    `);

    ZERO(`
        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= [ "world!" ]; // same as below but wrapped
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn maybe_empty(N: i32) {
            mut res: string[];
            for (mut i = 0; i < N; i++) res ~= "world!"; // cpp template issue here
            return res;
        }
        fn main() {
            mut arr = [ "Hello" ];
            for (mut i = 0; i < 2; i++) arr ~= maybe_empty(i); // will append empty
            return arr.join(" ") == "Hello world!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            mut _info = "abc";

            pure fn fail(mut reason: string = "") {
                ref info = _info[0]; // <- notice the ref, has to relax away
                reason ~= info && info.i32;
                return reason;
            }

            return fail.len - 2; // 'a' is 97, "97".len is 2.
        }
    `);

    ZERO([
    `
        let q_mutref = 1;
        pub let RELAX_mutref_only = q_mutref;
        pub fn what(relax_mask: i32) relax_mask -1;
    `,
    `
        import _0;
        fn main() what(RELAX_mutref_only);
    `]);

    LEGACY_Map(currently: "Map is not defined", `
        pub fn pairs(a: Map($K, $V), fn) {
            let k = a.keys;
            let v = a.values;
            for (mut i = 0; i < k.len; i++)
                fn(k[i], v[i]);
        }

        fn main() {
            mut map: Map(i32, i32);
            map[1] = 2;
            map[3] = 4;

            mut sum = 0;
            map.pairs(|k, v| sum += k + v * 100);
            return sum - 604;
        }
    `);

    ZERO(`
        fn main() {
            try         { return 0; }
            catch (e)   { return e == "x=2: even!" ? 11 : 22; }
        }
    `);

    ZERO(`
        fn fail(str: string)
            throw(str ~ "!");

        fn test(x: i32)
        {
            // We want to override fail but
            //  we want to call it within the override,
            //   so we can do this i guess?
            //
            shadow let fail = |mut str: string| {
                str = "x=" ~ x ~ ": " ~ str;
                fail(str);
            };

            return x & 1 || fail("even");
        }

        fn main() {
            try {
                return test(2);
            }
            catch (e) {
                <alt>
                return e == "x=2: even!" ? 0 : 10;
                <alt/>
                shadow let e = "hello " ~ e;
                return e == "hello x=2: even!" ? 0 : 10;
                </alt>
            }
        }
    `);

    ZERO(`
        // The Cats&Dogs example from
        //  JuliaCon 2019: The Unreasonable Effectiveness of Multiple Dispatch
        //   https://www.youtube.com/watch?v=kc9HwsxE1OY
        //
        fn encounter(a, b) {
            let verb = meets(a, b);
            return a.name ~ " meets " ~ b.name ~ " and " ~ verb ~ "\\n";
        }

        struct Dog { name: string };
        struct Cat { name: string };

        fn meets(lax a: Dog, lax b: Dog) "sniffs";
        fn meets(lax a: Dog, lax b: Cat) "chases";
        fn meets(lax a: Cat, lax b: Dog) "hisses";
        fn meets(lax a: Cat, lax b: Cat) "slinks";

        fn main() {
            let fido        = Dog("Fido");
            let rex         = Dog("Rex");
            let whiskers    = Cat("Whiskers");
            let spots       = Cat("Spots");

            mut res = encounter(fido, rex)
                    ~ encounter(fido, whiskers)
                    ~ encounter(whiskers, rex)
                    ~ encounter(whiskers, spots);

            return res == "Fido meets Rex and sniffs\\n"
                        ~ "Fido meets Whiskers and chases\\n"
                        ~ "Whiskers meets Rex and hisses\\n"
                        ~ "Whiskers meets Spots and slinks\\n"
                            ? 0 : 1;
        }
    `);

    ZERO(`
        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;
    `);

    ZERO(`                                  ;; DuplicateFunctions
        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;
    `);

    ZERO(`
        struct mat4 { i: i32; };
        struct RenderFrame { u_mat4_VP: mat4; };

        inline fn mat4_identity() mat4(1);

        fn test(output: &mut RenderFrame) {
            output.u_mat4_VP = mat4_identity;
        }

        fn main() {
            mut ret: RenderFrame;
            test(ret);
            return ret.u_mat4_VP.i - 1;
        }
    `);

    ZERO(`
        pub struct ScopeSkip {
            start: i32;
            end:   i32;
        };

        pub fn search(skip: ScopeSkip = [])
            skip.end - skip.start;

        pub fn main()
            <fail bad call to ScopeSkip 12:22>
            ScopeSkip(min: -1, max: +1)     <pass/>
            ScopeSkip(start: -1, end: +1)   </fail>
                .end - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        struct mat34 {
            mx: vec3; my: vec3; mz: vec3;
            mo: vec3;
        };

        inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);

        // What broke is this using reports a conflict,
        //  because 'determinant' got expanded within 'inverse',
        //   and there's another using mat34 there.
        //    Basically we totally don't want it to expand there.
        inline fn determinant(using _: mat34): f32
            - mz.x * my.y * mx.z + my.x * mz.y * mx.z + mz.x * mx.y * my.z
            - mx.x * mz.y * my.z - my.x * mx.y * mz.z + mx.x * my.y * mz.z;

        fn inverse(using mat: mat34): mat34
        {
            let idet = 1 / mat.determinant;

            let i_mx = vec3(
                idet * (- mz.y * my.z + my.y * mz.z),
                idet * (+ mz.y * mx.z - mx.y * mz.z),
                idet * (- my.y * mx.z + mx.y * my.z));

            let i_my = vec3(
                idet * (+ mz.x * my.z - my.x * mz.z),
                idet * (- mz.x * mx.z + mx.x * mz.z),
                idet * (+ my.x * mx.z - mx.x * my.z));

            let i_mz = vec3(
                idet * (- mz.x * my.y + my.x * mz.y),
                idet * (+ mz.x * mx.y - mx.x * mz.y),
                idet * (- my.x * mx.y + mx.x * my.y));

            return mat34(
                i_mx, i_my, i_mz,

                vec3( // point3
                      mo.x * -i_mx.x +
                      mo.y * -i_my.x +
                      mo.z * -i_mz.x,

                      mo.x * -i_mx.y +
                      mo.y * -i_my.y +
                      mo.z * -i_mz.y,

                      mo.x * -i_mx.z +
                      mo.y * -i_my.z +
                      mo.z * -i_mz.z));
        }

        fn main() i32 <|
            mat34_identity.inverse.determinant - 1;             ;; GNUStmtExpr
    `);

    ZERO(`
        struct TEA { v0: u32; v1: u32 }

        inline fn r4(using _: &mut TEA, sum: &mut u32) {
            mut delta: u32 = 0x9e3779b9;
            for (mut i = 0; i < 4; i++) {
                sum += delta;
                v0 += ((v1<<4) + 0xA341316C) ^ (v1 + sum) ^ ((v1>>5) + 0xC8013EA4);
                v1 += ((v0<<4) + 0xAD90777D) ^ (v0 + sum) ^ ((v0>>5) + 0x7E95761E);
            }
        }

        // Stack overflow solving this,
        //  argmax is +inf, and it just
        //   re-enters and re-enters.
        inline fn r4(tea: &mut TEA) {
            mut sum: u32; tea.r4(sum);
        }

        fn main() {
            mut tea: TEA;
            tea.r4();
            return (tea.v0 ^ tea.v0).i32;
        }
    `);

    TODO_conv(currently: "Incompatible types for T 9:41+1", `
        struct ScopeSkip {
            min: i32;
            max: i32;
        };

        fn main() {
            let a = 1;
            mut x: ScopeSkip; x = []; x = [ -2, 0 ]; // Inference fail.
            mut t: ScopeSkip; t = x.min && [ x.min, a ];
            return a + t.min + t.max;
        }
    `);

    TODO_conv(currently: "Bad call to BINOP 7:25+1", `
        fn setupOperators(i: i32) {
            <alt>
            struct sB { hey: i32; };
            struct BINOP { i: sB; };
            <alt/>
            fn sB(_: $T) struct { hey: $T; };
            struct BINOP { i: sB(i32); };
            </alt>
            return BINOP([ i ]); // Inference fail.
        }

        fn main() setupOperators(0).i.hey;
    `);

    ZERO(`
        struct X { i: i32; };
        type Y = X;
        fn main() Y(1).i / 2;
    `);

    ZERO(`
        struct Node {
            kind  ?: string;
            items ?: Node[];
            value ?: string;
        };

        fn astReplace(node: Node, mutate): Node {
            fn walk(shadow ref node: Node) {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        fn test(n: Node, a: string, b: string) {
            return astReplace(n, |ref item: Node| {
                if (item.value == a) {
                    if (item.items.len == 1 && item.kind == "call")
                        item.value = b;
                    else if (item.kind == "str")
                        item.value = b;
                }
            });
        }

        fn main() {
            let v0 = Node(kind: "str", value: "woot");
            let v1 = v0.test("woot", "who");
            return v1.value.len - 3;
        }
    `);

    ZERO(`
        fn main() {
            mut x:  <fail redundant typeof not a value 4:28+3>
                    typeof(i32)     <pass/>
                    i32             </fail> = 0;
            return x;
        }
    `);

    ZERO(`
        struct SolvedNode {
            value: i32;
            items?: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn main(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);

            <alt>
            // This is an aside, managed to lose the copy qual when working structs
            //  Initially noticed it because visitNodes tried to change its sighash
            mut cpy = tree; cpy = tree; // <- but this fails cleanly when tree is nocopy
            </alt>

            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };
    `);

    ZERO(`
        return 0 > 1 ? throw("should type check") : 0;
    `);

    ZERO(`
        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }
    `);

    ZERO(`
        fn throw_hey() {
            throw("hey");
        }

        fn main(): i32 {
            try {
                let _x = throw_hey();
                return _x || 7;
            }
            catch (err) {
                return err.len - 3;
            }
        }
    `);

    ZERO(`
        fn throw_hey(): i32 {
            throw("hey");
            return 1;
        }

        fn main(): i32 {
            try {
                return throw_hey();
            }
            catch (e) {
                return e.len - 3;
            }

            return 11;
        }
    `);

    ZERO(`
        fn main()
            cli_handle([ "hello", "you" ]);

        fn cli_handle(args: string[]): i32
        {
            mut idx = 0;

            fn next() {
                let i = idx++;
                if (i < args.len)
                    return args[i];

                return "";
            }

            // Router.
            return next().len - 5;
        }
    `);

    ZERO(`
        struct X { i: i32; };

        fn         ++(using x: &mut X) ++i;
        postfix fn ++(using x: &mut X) i++;

        fn main() {
            mut x: X;
            let a = x++;
            let b = ++x;
            return a || b - 2;
        }
    `);

    ZERO(`
        fn test(s: $T) {
            mut sum = 0;
            for (fieldname i: $T) sum += s.i;
            return sum;
        }

        struct XY { x: i32; y: i32; };

        fn main() {
            let thing = XY(1, 2);
            let sum = test(thing);
            return sum - 3;
        }
    `);

    ZERO(`
        struct ScopeSkip     { imports:     i32[]; implicits:     i32[]; }
        struct ScopeSkipMemo { imports_len: i32;   implicits_len: i32;   }

        fn snap(ss: ScopeSkip) {
            mut r: ScopeSkipMemo;
            for (fieldname i: typeof(ss))
                r.i_len = ss.i.len;

            return r;
        }

        fn check(v) {
            mut sum = 0; mut mul = 1;
            for (fieldname i: typeof(v)) {
                sum += v.i * mul; mul *= 10;
            }

            return sum;
        }

        fn main() check(snap(ScopeSkip([ 1 ], [ 2, 2 ]))) - 21;
    `);

    ZERO(`
        fn Lazy(getValue) {
            struct Lazy {
                evaluated?: bool;
                value?:     typeof(getValue());
                getValue?:  typeof(fn getValue);
            };

            return Lazy();
        }

        fn get(ref lazy) {
            if (!lazy.evaluated) {
                lazy.evaluated  = true;

                // This is just exploratory stuff,
                //  don't feel obliged to keep this working.
                let getValue    = lazy.getValue;
                lazy.value      = getValue();
            }

            return lazy.value;
        }

        fn main() {
            mut calls   = 0;
            mut lazy    = Lazy(|| calls++);
            mut res     = lazy.get() + lazy.get();

            return res == 0 && calls == 1 ? 0 : 1;
        }
    `);

    // /quite right


    // Template cases.

    ZERO(`
        fn args_in_cases(a, b)              <fail not a type (3:19+1|3:32+1)>
            case (a -> b)                   <fail/>
            case (typeof(a) -> b)           <fail/>
            case (a -> typeof(b))           <pass/>
            case (typeof(a) -> typeof(b))   </fail> = a + b;

        fn main() args_in_cases(+1, -1);
    `);

    ZERO(`                                  ;; DuplicateFunctions
        fn ARR_LAST(a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        fn main()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };
    `);

    ZERO(`                                  ;; DuplicateFunctions
        fn ARR_LAST(a: $T[])
            case (typeof(a) -> &mut $T[]): &mut $T a[a.len - 1];
            case (typeof(a) -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;
    `);

    ZERO(`
        // Same as below, but avoids the $T call, which is also broken somehow.
        //  DONT DELETE ME after you fix the $T, its a great example of stupid codegen -
        //   we emit useless overloads for mutrefs when its clearly useless.

        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i) {
                shadow mut a = a;
                a.i /= 2;
                return rec_cases(a);
            }
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;
    `);

    ZERO(`
        fn rec_cases(a: $T)
        case ($T.is::primitive) {
            if (a)      return rec_cases(a / 2);
            else        return a;
        }
        default {
            if (a.i)    return rec_cases($T(i: a.i / 2));
            else        return rec_cases(a.i);
        }

        struct X { i: i32; };
        fn main() X(1).rec_cases;
    `);

    // /Template cases


    // Lifetimes, type inference, copy elision, temporaries.

    ZERO(`
        fn test() {
            mut x = 5;
            return x;
        }

        fn main()
            test() - 5;
    `);

    ZERO(`
        struct Test { i: i32; };

        fn test() {
            mut x = Test(5);
            return x;
        }

        fn main()
            test().i - 5;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; };

        fn test() {
            mut x = Test(5, -5);
            return x;
        }

        fn main()
            test().a + test().b;
    `);

    ZERO(`
        struct X { x: i32; };
        fn ref2arg(x: X) = x;

        fn main() {
            let NOTREF = ref2arg(X(101));
            return NOTREF.x - 101;
        }
    `);

    ZERO(`
        <fail cannot be copied or moved 8:21>
        nocopy <pass/></fail>
        struct Copied { x: i32; };

        fn main() {
            let a = Copied(1);
            mut b = a;
            b.x++;
            return b.x - a.x * 2;
        }
    `);

    ZERO(`
        struct XY { x: i32; y: i32; };
        fn ref2arg(v: XY) = v;

        fn main() {
            let a = XY(99, 2);
            let ref2a = ref2arg(a);
            return mem::ptr_eq(a, ref2a) ? 0 : 1;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };
        fn retmutref(ref nc: NoCopy) nc;

        fn main() {
            mut nc: NoCopy;
            nc.retmutref.retmutref.i++;
            return nc.i - 1;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };
        fn mutrefself(ref nc: NoCopy) {
            nc.i++;
            return nc;
        }

        fn main() {
            mut nc: NoCopy;
            nc.mutrefself().mutrefself();
            return nc.i - 2;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;
            let b: NoCopy;
            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a: NoCopy) a;
        fn  retargs_if(a: NoCopy, b: NoCopy) a.i ? b : a;
        fn  retargs_or(a: NoCopy, b: NoCopy) a || b;
        fn retargs_and(a: NoCopy, b: NoCopy) a && b;

        fn main() {
            let a: NoCopy;                      // <- b now temp

            return retarg(retargs_if(a, retargs_and(a, retargs_or(a, NoCopy)))).i;
        }
    `);

    ZERO(`
        nocopy struct NoCopy { i: i32; };

        fn      retarg(a) a;                    // <- now templates
        fn  retargs_if(a, b) a.i ? b : a;
        fn  retargs_or(a, b) a || b;
        fn retargs_and(a, b) a && b;

        fn main() {
            mut a: NoCopy;                      // <- now muts
            mut b: NoCopy;
            retarg(retargs_if(a, retargs_and(a, retargs_or(a, b)))).i++;
            return a.i + b.i - 1;
        }
    `);

    ZERO(`
        fn as_blocks_after(x: i32) {
            mut zero = 0;
            if (x > 2) // a broken stmt emit lifted the loop out of the conditional
                for (mut i = 0; i < x; i++)
                    zero = i + i*zero;

            return zero;
        }

        fn main() 2.as_blocks_after;
    `);

    ZERO(`
        struct Lifetime { woot: Lifetime[]; };

        fn Lifetime_test(x: Lifetime) {
            x.woot.len & 1 && throw("This is very important.");
            for (mut i = 0; i < x.woot.len; i++) Lifetime_test(x.woot[i]);
            return x;
        }

        fn Lifetime_fromBinding(x: i32) {
            mut woot: Lifetime[];
            for (mut i = 0; i < x; i++)
                woot[i] = Lifetime();

            ;; !N_NonTrivAutoCopy
            //
            //  1. Move 'woot' into Lifetime
            //      instead of naively copying it.
            //                             ....
            return Lifetime_test(Lifetime(:woot));              ;; ConstCast
            //     ....
            //  2. Move the result out even though
            //      Lifetime_test takes and returns refs.
        }

        fn main() 0.Lifetime_fromBinding.woot.len;
    `);

    ZERO(`
        fn test(x: i32) {                       // none of these need vecs
            let c = [10007];                    ;; TODO fu::slate<1, int> c
            let a = [7, 11, 9, 21, x, x, x, x]; ;; TODO fu::slate<2, int> a
            let b = {                           ;; TODO fu::slate<1, int> b
                :BRK {                          // !N_NonTrivAutoCopy
                    if (x & 2) break :BRK c;
                    if (x & 1) break :BRK [ x ]; // a val
                    a // a ref
                }
            };
            return a[0] - b[0] * a[1];
        }

        fn main() 1.test + 4.test + 74;
    `);


    // Returning a mut arg.

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test) {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);

    ZERO(`
        struct Test { i: i32[]; };

        fn test(mut x: Test): Test {
            x.i[0] += x.i[1];
            return x;
        }

        fn main() {
            let s = Test([ 1, 2 ]);
            return test(s).i[0] - s.i[0] * 3;
        }
    `);

    ZERO(`
        fn compile_snippets(x0: string) x0.find('a') && throw("throw#1");
        fn ZERO(x1: string) x1.find('b') && throw("throw#2");

        fn FAIL(x2: string): string {                   ;; EXPECT fu::view<char> x2
            try {
                let ctx = compile_snippets(x2) && "hey";
                return ctx;
            }
            catch (e) {
                return ZERO(x2) && e;
            }
        }

        fn main() FAIL("a").len;
    `);

    ZERO(`
        // The thing below but shorter:
        //  the '|| throw' introduces a bullshit lambda during codegen,
        //   which misreturns a dangling reference to its own frame.
        fn test(x: string) [x][0] || throw("nope!");
        fn main() "what".test.len - 4;
    `);

    ZERO(`
        fn only(s: $T[]) s.len == 1 ? s[0] : throw ("len != 1: " ~ s.len);

        struct Node       { kind: string; };
        struct SolvedNode { kind: string; };

        fn solveNodes(n: Node[]) {
            mut r: SolvedNode[];
            for (mut i = 0; i < n.len; i++) r ~= SolvedNode(n[i].kind);
            return r;
        }

        // the '|| throw' introduces a bullshit lambda during codegen,
        //  which misreturns a dangling reference to its own frame.
        fn solveDeclExpr(n: Node) solveNodes([ n ]).only || throw ("!only");

        fn main() solveDeclExpr(Node("a")).kind.len - 1;
    `);

    ZERO(`
        pub fn test(x: i32): i32[] { ;; !N_NonTrivAutoCopy
            mut a = [ 4 ];
            mut b = [ 5 ];
            mut c = [ 6 ];

            for (mut i = 0; i < x; i++) {
                a.unshift(x);
                b.unshift(x);
                c.unshift(x);
            }

            inline fn which() {
                return :test x & 1 ? a : b;
            }

            if !(x & 2)
                return which();

            return c;
        }

        fn main() test(2)[2] + test(1)[1] - 2 * test(0)[0];
    `);


    // Returning never vs void.

    ZERO(`
        fn incr_x_to_1(ref x: i32) {
            x && throw("this reports return t_never");
            fn incr_x() { return x++; }
            incr_x();
        }
        fn main() {
            mut x = 0;
            incr_x_to_1(x);
            return x - 1;
        }
    `);

    ZERO(`
        fn main() {
            mut x = 0;
            fn incr_x_to_1() {
                x && throw("this reports return t_never");
                fn incr_x() { return x++; }
                incr_x();
            }
            incr_x_to_1();
            return x - 1;
        }
    `);

    ZERO(`
        fn apply(fn, v) fn(v);
        fn main() {
            mut x = 0;
            fn scope_using(via: i32) {
                x && throw("this reports return t_never");
                // which messed up retcount for scope_using
                fn visit(item: i32) {
                    if (item) return item;
                    return x++;
                }
                apply(fn visit, via);
            }

            scope_using(x);
            return x - 1;
        }
    `);


    // Usability of numeric literals.

    ZERO(`
        fn main()   <fail leading zero in numeric literal 3:13+1>
            010     <pass/>
            0o10    </fail>
                == 8 ? 0 : 1;
    `);

    ZERO(`
        <alt>
        fn main() 0b101 ==   5 ? 0 : 1; <alt/>
        fn main() 0o101 ==  65 ? 0 : 1; <alt/>
        fn main() 0x101 == 257 ? 0 : 1; </alt>
    `);

    ZERO(`
        fn main()
            i32(f64.PI * 2.0) - 6;
    `);

    ZERO(`
        fn main()
            i32(f64.PI * 2 - 6);
    `);

    ZERO(`
        fn main()
            f64.PI * 2 - 6 |> i32;
    `);

    ZERO(`
        fn main()
            i32 <| f64.PI * 2 - 6;
    `);

    ZERO(`
        let x: f32 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: f32 = 1.0; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x: u8 = 1; fn main() 1 - x.i32;
    `);

    ZERO(`
        let x = 1.f32; fn main() 1 - x.i32;
    `);

    ZERO(`
        fn gt0(x: f32) x > 0;
        fn main() gt0(1.f32) ? 0 : 1;
    `);

    ZERO(`
        struct Hey { x: f32; };
        fn hey() Hey(1);
        fn main() hey.x.i32 - 1;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(i: i32) vec3(x: (i - 2).f32, z: 1);
        fn main() {
            let v = test(1);
            return (v.x + v.z).i32;
        }
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        fn test(f: f32) vec3(x: f, z: -1);
        fn main() {
            let v = test(-1);
            return (v.x - v.z).i32;
        }
    `);

    ZERO(`
        fn hey(i: f32) i.f32 + 0.5;
        fn main() hey(1).i32 - 1;
    `);

    ZERO(`
        fn lin2srgb(l: f32): f32
            l <= 0.0031308
                ? l * 12.92
                : 1.055 * pow(l, 1/2.4.f32) - 0.055;

        fn lin255(v: f32) u32 <|
            v.lin2srgb.max(0).min(1) * 255.99;

        fn main() i32 <|
            lin255(1) - 255;
    `);

    ZERO(`
        struct vec3 { x?: f32; y?: f32; z?: f32; };

        inline fn /(a: f32, b: vec3)                            ;; GNUStmtExpr
            vec3(a / b.x, a / b.y, a / b.z);

        fn main() i32 <|
            (1/vec3(x: 1)).x - 1;
    `);

    ZERO(`
        let QUAD_DATA: f32[] =
        [
            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
            -1, +1, 0,      0, 0, 1,    0, 1, 0,

            -1, -1, 0,      0, 0, 1,    0, 0, 0,
            +1, -1, 0,      0, 0, 1,    1, 0, 0,
            +1, +1, 0,      0, 0, 1,    1, 1, 0,
        ];

        fn main() QUAD_DATA.len - 6 * 9;
    `);

    ZERO(`
        fn test(a: bool): u8 = a ? 1 : 0;

        fn main() test(false).i32;
    `);

    ZERO(`
        fn test(a: bool): u8 = a && 1;

        fn main() test(false).i32;
    `);

    ZERO(`
        pub let A_u8: u8 = 0x0;

        fn ATTRIB(type: u8, count: i32, srgb = false): u8
            = type & 0x3 | count.u8 << 2

            // TODO can't deep-retype the last cast unfortunately:
            //  we need another hint to drive typing here,
            //   perhaps monogenous signatures, or else.
            | (srgb && 0x80.u8);

        fn main() ATTRIB(A_u8, 4).i32 - 16;
    `);

    ZERO(`
        pub struct Geometry    { g: i32; };
        pub struct Texture     { t: i32; };
        pub struct RenderFrame { r: i32; };

        pub struct LogicFrame_in
        {
            lastLogic:  LogicFrame;
        };

        pub struct LogicFrame
        {
            DATA_fbx:   Geometry;
            TEX_A:      Texture;
            TEX_AO:     Texture;
            TEX_M:      Texture;
            TEX_N:      Texture;
            TEX_R:      Texture;
            HDR:        Texture;
        };

        pub struct RenderFrame_in
        {
            w:          i16;
            h:          i16;
            frame:      i32;

            mouseX:     f32;
            mouseY:     f32;
            mouseBtns:  i32;

            using logic:    LogicFrame;
            lastRender:     RenderFrame;
        };

        pub fn APP_renderFrame(using args: RenderFrame_in): RenderFrame
        {
            return RenderFrame(args.HDR.t);
        }

        fn main() 0;
    `);

    ZERO(`
        fn leadingDigit(name: string) name[0].u8 - '0'.u8 < 10;
        fn main() "hello".leadingDigit.i32;
    `);

    ZERO(`
        fn main() 1_000_000 - 1000000
               || 0xffff_ffff.i32 - 0xffffffff.i32
               || 123_456.789.i32 - 123456.789.i32;
    `);

    ZERO(`                                  // litfix through && /////
        fn test(a: u32, shadows: bool)      (a << 1) | (shadows && 1);
        fn main()                           test(1, true).i32 - 3;
    `);

    ZERO([`
        struct vec3 { x?: f32; y?: f32; z?: f32; };
        inline fn *(a: vec3, b: vec3) vec3(a.x * b.x, a.y * b.y, a.z * b.z);
        inline fn *(a: vec3, b: f32) vec3(a.x * b, a.y * b, a.z * b);
        inline fn lensq(a: vec3) a.x * a.x + a.y * a.y + a.z * a.z;
        inline fn len(a: vec3) a.lensq.sqrt;

        inline fn norm(a: vec3) {
            mut n = 1 / a.len;
            n = n.finite ? n : 0;
            return a * n;
        }
    `,`
        inline fn test(ref v) {
            v = v.norm();                                       ;; GNUStmtExpr
            return v.len;
        }

        fn main() {
            mut v = _0::vec3(2, 0, 0);
            return v.test() == 1 ? 0 : 1;
        }
    `]);

    ZERO(`
        fn sub15(x: i32) x - 15;
        fn main() 0xf.sub15;
    `);

    ZERO(`
        fn pick(albedo: i32 = 0x12345678, shift = 16)
            albedo >> shift & 0xf;
        fn main()
            pick() == 4 ? 0 : 1;
    `);

    ZERO(`
        fn main() abs(-19191) - 19191
                + abs(+72713) - 72713;
    `);


    // Typedefs.

    ZERO(`
        type Test = i32[];
        fn yo(t: Test) t[0] + t[1];
        fn main() yo([-1, +1]);
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        fn hello(a: i32[]) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];
        fn hello(a: X) a.if_first;
        fn main() hello([ 3 ]) - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];

        fn list(): i32[][] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);

    ZERO(`
        fn if_first(a: $T[]) a && a[0];
        type X = i32[];

        fn list(): X[] {
            return [[ 3 ]];
        }

        fn hello() list.if_first.if_first;
        fn main() hello - 3;
    `);


    // Trivial equality.

    ZERO(`
        let arr = [1, 2];
        fn eq(a: i32[], b: i32[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;
    `);

    ZERO(`
        let arr = [1, 2];
        fn eq(a: $T[], b: $T[]) a == b;
        fn main() eq(arr, arr) ? 0 : 1;
    `);


    // Slices.

    ZERO(`
        fn main() {
            mut a = [ 1, 2, 3, 4 ];
            mut b = a[1: ];
            mut c = a[ :3];
            mut d = a[1:3];

            mut res = b ~ c ~ d;
            return res <> [ 2, 3, 4,  1, 2, 3,  2, 3 ];
        }
    `);

    ZERO(`
        fn main() {
            let str = "hello world";
            let s10 = str[:5] ~ str[6:];
            return s10.len - 10;
        }
    `);

    ZERO(`
        fn main() {
            mut strs = [ "hello", "world" ];
            let hello = strs[0];
            strs.insert(1,
                <fail bad call>
                hello[0:5] /* should work too, but currently expected to mismatch */ <pass/>
                hello.slice(0, 5)</fail>
            );
            return strs.len - 3;
        }
    `);

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main()
            test([-1, +1]);

        ;; EXPECT fu::slate<2, int> { -1, +1 }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [-1, +1];
            return hey.test();
        }
    `);

    ZERO(`
        fn test(i: i32) [ i, i + 1 ];
        fn main() test(0)[1] - 1;
    `);

    ZERO(`
        fn test(hey: byte[])
            hey.view(u32)[0];

        fn main() {
            mut hey: byte[] = [ byte(1), byte(1), byte(1), byte(1) ];
            return (hey.test - 0x1010101).i32;
        }
    `);

    ZERO(`
        fn test(hey: [i32])
            hey[0] + hey[1];

        fn main() {
            let hey = [7, -1, +1];
            return test(hey[1 : 3]);
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey[0] += hey[1];

        fn main() {
            mut hey = [7, -1, +1];
            return hey[1 : 3].test();
        }
    `);

    ZERO(`
        fn test(hey: &mut [i32])
            hey.= [2, -3];

        fn main() {
            mut hey = [1, 0, 0];
            test(hey[1 : 3]);
            return hey[0] + hey[1] + hey[2];
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(out: &mut [Hey]) {
            out.view(u8) .= [ 1.u8, 1.u8, 1.u8, 1.u8 ];
        }

        fn main() {
            mut a = [ Hey ];
            a.test();
            return a[0].i - 16843009;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn test(x: &mut [i32], y: [ Hey ])
            x .= y.view(i32);

        fn main() {
            mut a = [ 0 ];
            test(a, [ Hey(13) ]);
            return a[0] - 13;
        }
    `);

    ZERO(`
        struct Hey {
            i: i32;
        };

        fn main() {
            mut a = [ 0 ];
            a .= [ Hey(13) ].view(i32);
            return a[0] - 13;
        }
    `);

    ZERO(`
        fn test(a: [byte], b?: [byte]) a == b;
        fn main() test("") ? 0 : 1;

        ;; EXPECT (""_fu, fu::view<char>{})

        // This is what we had before, it's better.
        ;; TODO (fu::view<char>{}, fu::view<char>{})
    `);

    ZERO(`
        let NOTES = [ "AAA", "BBB", "CCC" ];
        fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
        fn main() what("!BBB") - 1;
    `);

    TODO_slices(currently: "fn what arg annot is not novec 7:9+5", `
        // When you pass this, delete the test above, they're the same.
        //  The slice() should relax to a get_view, which doesnt need annot to be a string.
        //   We generally want to remove the distinction between slice(a,b) and [a:b] altogether.
        //
        let NOTES = [ "AAA", "BBB", "CCC" ];
        novec fn what(annot: string) NOTES.find(annot.slice(1, annot.len));
        fn main() what("!BBB") - 1;
    `);

    ZERO(`
        fn Join(a: $T[][], lax sep = [])            // The sep is of type any-init.
        {                                           //
            if (a.len < 2)                          //
                return a.len && a[0];               // NOT SURE WHAT'S 100% IDEAL, BUT:
                                                    //
            let N = typeof(sep) -> [$T;] ? sep.len  // should either match here,
                  : typeof(sep) ->  $T   ? 1        //                                    but currently matches here, which is just wrong.
                                 : 0;               //                           or here,

            mut size = a[0].len;
            for (mut i = 1; i < a.len; i++)
                size += N + a[i].len;

            mut res: $T[];
            res.grow_junk(size);

            let head = a[0];
            size = head.len;
            res[0 : head.len] .= head;
            for (mut i = 1; i < a.len; i++)
            {
                let range = a[i];
                if (typeof(sep) -> [$T;])
                    res[size : size + N] .= sep;
                else if (typeof(sep) -> $T)
                    res[size] = sep;

                size += N;
                res[size : size + range.len] .= range;
                size += range.len;
            }

            return res;
        }

        fn main() {
            let res = Join([ "hello", "world" ], []); // the [] fails the case above
            return res == "helloworld" ? 0 : 1;
        }
    `);

    ZERO(`
        // one of these things reported there's no $S in scope.
        fn Join(a: $T, b: $T, lax sep: $S = [])
            case ($S -> $T || $S -> [$T;] || $S -> [])
        {
            return typeof(sep) -> $T || typeof(sep) -> [$T;]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }
    `);

    ZERO(`
        // This is the initial type union concept
        fn Join(a: $T, b: $T, lax sep?: $T or [$T;] or [])
        {
            return typeof(sep) -> $T || typeof(sep) -> [$T;]
                 ? a ~ sep ~ b
                 : a ~ b;
        }

        fn main() {
            let res = Join("hello", "world");
            return res == "helloworld" ? 0 : 1;
        }
    `);

    ZERO(`
        fn Replace(str: $T[], all: $T or [$T;], with: $T or [$T;] or [])
            str.len + (typeof(all)  -> $T ? 1 : all.len)
                    + (typeof(with) -> [] ? 0 : typeof(with) -> $T ? 1 : with.len);

        fn main()
            "Hello".Replace(all: "ll", with: []) == 7 ? 0 : 1;
    `);


    // Don't repeat yourself ctors.

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a = 1;
            let r: Hey = a && [ a ];
            return r.i - 1;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn main() {
            let a: Hey[] = [ [ -1 ], [ +1 ] ];
            return a[0].i + a[1].i;
        }
    `);

    ZERO(`
        struct Hey { i: i32; }

        fn test(): Hey {
            return [ 0 ];
        }

        fn main() test.i;
    `);


    // Non-defaulted struct members.

    ZERO(`
        struct Test {
        <fail bad call to Test expects 2 arg 11:20>
            a: i32;  <pass/>
            a?: i32; </fail>
            b: i32;
        };

        return Test(b: 1).a;
    `);

    ZERO(`
        struct Test {
            b: i32;
        <fail bad call to Test expects 2 arg 11:20>
            a: i32;  <pass/>
            a?: i32; </fail>
        };

        return Test(1).a;
    `);


    // Recursive structs.

    ZERO(`
        struct Node {
            items?: Node[];
            stuff?: Node[];
        };

        fn rec_copy(ref a: Node) {
            // If implemented naively,
            //  by the time you copy stuff it's no longer there.
            a = a.items[0];
        }

        fn main() {
            mut a = Node(items: [ Node(stuff: [ Node ]) ]);
            rec_copy(a);
            return a.stuff.len - 1;
        }
    `);


    // Explicit arguments & struct members.

    ZERO(`
        fn test(a: i32, b!: i32 = 1) a + b;
        return test(-1);
    `);

    ZERO(`
        fn test(hey!: i32) hey * 2;
        <fail arg hey explicit name 4:25+4>
        fn main() = (0).test;       <pass/>
        fn main() = test(hey: 0);   </fail>
    `);

    ZERO(`
        fn test(a: i32, b!: i32 = 1) a + b;
        <fail bad call to test arg b explicit name 7:20>
        return test(-2, +2);    <pass/>
        return test(-2, b: +2); </fail>
    `);

    ZERO(`
        struct Test { a: i32; b!: i32; };
        fn test(t: Test) t.a + t.b;
        <fail bad call to Test arg b explicit name 8:20>
        return Test(-2, +2).test;    <pass/>
        return Test(-2, b: +2).test; </fail>
    `);

    ZERO(`
        struct Test { a?: i32; b!?: i32; };
        fn test(t: Test) t.a + t.b;
        <fail bad call to Test arg b explicit name 8:20>
        return Test(-2, +2).test;    <pass/>
        return Test(b: +2).test - 2; </fail>
    `);

    ZERO(`
        let _precedence = 0;
        fn parseExpression(p1 = _precedence, mode! = 0) p1 + mode;
        fn main() parseExpression();
    `);

    ZERO_SAME([
    `
        fn A(x!: i32 = 0) x;
        fn B(x: i32 = 0) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x!?: i32) x;
        fn B(x?: i32) A(:x);
        fn main() A + B;
    `,
    `
        fn A(x! = 0) x;
        fn B(x = 0) A(:x);
        fn main() A + B;
    `
    ]);

    ZERO(`
        fn what(a = -1, b!: i32) a + b; // Trailing explicit args.
        fn main() what(b: +1);
    `);

    ZERO(`
        fn greet(with!greeting: string)     greeting.len;
        fn main()                           greet(with: "Hello!") - 6;
    `);

    ZERO(`
        fn Each(arr: $T[], visit)
            for (mut i = 0; i < arr.len; i++)
                visit(arr[i], i?: i);

        fn main() {
            mut muls = 0;
            mut arr = [ 1, 2, 3 ];

            arr.Each: |v, i!index|
                muls += v * index; // complained no index in scope

            return muls - 8;
        }
    `);

    ZERO(`
        struct Lifetime { using regions: i32[] };
        fn isInvalidatedBy(write: i32[]) write.len * write[0];

        // This blew up with a TODO: bck_node(non-empty argid).
        fn main() isInvalidatedBy(write: Lifetime([ 3, 5 ])) - 6;
    `);

    ZERO(`
        struct Node { a: i32; b: i32; c: i32; d: i32 };

        fn make(a: i32, b?: i32, c?: i32)
            Node(a, :b, :c, d: 10);

        fn make(a: i32, b?: i32, c?: i32, d!: i32)
            Node(a, :b, :c, :d);

        fn res(using n: Node)
            return a + 10 * b + 100 * c + 1000 * d;

        fn main()
            make(4, 5).res      == 10054 &&
            make(3, b: 4).res   == 10043 &&
            make(2, c: 3).res   == 10302 &&
            make(1, d: 2).res   == 2001 ? 0 : 1;
    `);

    // /Explicit arguments.


    // Optional arguments.

    ZERO(`
        fn a0o0() 0;
        fn a1o0(a : i32) a;
        fn a2o1(a : i32, b?: i32) a + b;
        fn a2o2(a?: i32, b?: i32) a + b;
        fn main() a0o0(a?: 1, b?: 2) *      1   //      .
                + a1o0(a?: 1, b?: 2) *     10   //     10
                + a2o1(a?: 1, b?: 2) *    100   //    300
                + a2o2(a?: 1, b?: 2) *   1000   //   3000
                + a2o1(a : 1, <fail bad call>
                              c       <pass/>
                              b       </fail>
                               ?: 2) *  10000   //  30000
                + a2o1(a : 1)        * 100000   // 100000
                                // ----------------------
                                     - 133310;
    `);

    ZERO(`
        pub fn reveach(items: [$T], fn)
            for (mut i = items.len; i --> 0; )
                fn(items[i], i?: i);

        pub fn main() {
            mut sum = 0;
            [1, 2, 3].reveach(|x   | sum += x          );
            [1, 2, 3].reveach(|x, i| sum += x * i * 100);
            return sum - 806;
        }
    `);

    ZERO(`
        pub lax fn noop() 0;
        pub fn woot(ref i: i32, fn) i += fn(i?: i += 1); // Will not add 1.

        fn main() {
            mut sum = 0;
            woot(sum, fn noop);
            return sum;
        }
    `);

    ZERO(`
        fn takesFns(x, f)
            f(x * 2, optAndUnused?: x * 3);

        fn hasUnusedOptArg(x: int, alt = 7, lax optAndUnused?: int)
            x + alt;

        fn main()
            takesFns(2, fn hasUnusedOptArg) - 11;
    `);


    // Intlit sizechecks.
    //
    // TODO investigate the error messages,
    //  they seem to be coming from different places,
    //   the whole thing is a bit fishy.

    ZERO(`
        fn main() {
            let ret: i8 = <fail annot match>
                128 <pass/>
                127 </fail>;

            return (ret - 100).i32 - 27;
        }
    `);

    ZERO(`
        fn main() {
            let ret: i16 = <fail annot match>
                32768 <pass/>
                32767 </fail>;

            return (ret - 32700).i32 - 67;
        }
    `);

    ZERO(`
        fn main() {
            let ret: i32 = <fail annot match>
                2147483648 <pass/>
                2147483647 </fail>;

            return (ret - 2147483600).i32 - 47;
        }
    `);

    ZERO(`
        fn main() { // weird error, see the other two below
            let ret: i64 = <fail bad int literal>
                9223372036854775808 <pass/>
                9223372036854775807 </fail>;

            return (ret - 9223372036854775800).i32 - 7;
        }
    `);

    ZERO(`
        fn main() {
            let ret: i8 = <fail annot match>
                -129 <pass/>
                -128 </fail>;

            return (ret + 100).i32 + 28;
        }
    `);

    ZERO(`
        fn main() {
            let ret: i16 = <fail annot match>
                -32769 <pass/>
                -32768 </fail>;

            return (ret + 32700).i32 + 68;
        }
    `);

    ZERO(`
        fn main() {
            let ret: i32 = <fail annot match>
                -2147483649 <pass/>
                -2147483648 </fail>;

            return (ret + 2147483600).i32 + 48;
        }
    `);

    ZERO(`
        fn main() { // wording different from the ones above and below
            let ret: i64 = <fail oversized signed int literal>
                -9223372036854775809 <pass/>
                -9223372036854775808 </fail>;

            return (ret + 9223372036854775800).i32 + 8;
        }
    `);

    ZERO(`
        fn main() {
            let ret: u8 = <fail annot match>
                256 <pass/>
                255 </fail>;

            return (ret - 0xff).i32;
        }
    `);

    ZERO(`
        fn main() {
            let ret: u16 = <fail annot match>
                65536 <pass/>
                65535 </fail>;

            return (ret - 0xffff).i32;
        }
    `);

    ZERO(`
        fn main() {
            let ret: u32 = <fail annot match>
                4294967296 <pass/>
                4294967295 </fail>;

            return (ret - 0xffffffff).i32;
        }
    `);

    ZERO(`
        fn main() { // this is the best of the weird ones
            let ret: u64 = <fail integer overflows u64>
                18446744073709551616 <pass/>
                18446744073709551615 </fail>;

            return (ret - 0xffffffffffffffff).i32;
        }
    `);

    ZERO(`
        pub fn set_once(ref entry, bit: i32): bool
        {
            let mask = 1 << bit.u64;    // cg'd into '1u << uint64_t(bit)'
            if (entry & mask)           //  which doesnt work for some reason
                return false;

            entry |= mask;
            return true;
        }

        fn main() {
            mut entry: u64;
            let a = set_once(entry, 32);
            let b = set_once(entry, 32);
            return a && !b ? 0 : 101;
        }
    `);

    ZERO(`
        fn main() {
            let hey: u128 = 0x8000000000000000.u128;
            let res = hey + hey;
            return res > hey ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let v = <alt>u8<alt/>byte</alt>(128);
            return v.i32 == 128 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let v = <alt>i32<alt/>u32</alt>(128);
            return byte(v) == byte(128) ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let v = <alt>i32<alt/>u32</alt>(2147483648);
            return byte(v) == byte(0) ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let v = <alt>i32<alt/>u32</alt>(-1);
            return byte(v) == byte(255) ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            return i32(byte(i32(128))) == 128 ? 0 : 1;
        }
    `);

    ZERO(`
        fn hello(a?: i32, b?: i32) = 10 * a + 100 * b;

        <alt>
        inline                                                  ;; GNUStmtExpr
        </alt>
        fn test(f) {
            let a = 1; // none of these should need 'lax',
            let b = 2; //  they're all SS_MATCHED below,
            let c = 3; //   and their use is explicitly discard-ok.
            return f(?:a, ?:b, ?:c);
        }

        fn main() test(fn hello) - 210;
    `);

    // /Optional arguments.


    // Pubs & imports.

    ZERO([
    `
        pub lax fn noop() {} // AUTOPUB
        <fail hello is not defined><pass/>
        pub
        </fail>
        fn hello() 3;
    `,
    `
        import _0;
        fn main() 6 - hello * 2;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        fn main() 1._0::Hey.i - 1;
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        import _0;
        pub inline fn test(h: Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;                           ;; GNUStmtExpr
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        import _1;
        fn main() 1._0::Hey.test - 3;                           ;; GNUStmtExpr
    `
    ]);

    ZERO([
    `
        pub struct Hey { i: i32; };
    `,
    `
        pub inline fn test(h: _0::Hey) h.i + 2;
    `,
    `
        fn main() 1._0::Hey._1::test - 3;                       ;; GNUStmtExpr
    `
    ]);

    ZERO([
    `
        pub struct You { i: i32; };
    `,
    `
        pub struct Hey { using you: _0::You; };
        pub fn init3(): Hey = [ _0::You(3) ];
    `,
    `
        pub inline fn test(using h = _1::init3) i + 7;
    `,
    `
        fn main() _2::test - 10;                                ;; GNUStmtExpr
    `
    ]);

    ZERO([
    `
        pub struct vec3 {
            x?: f32;
            y?: f32;
            z?: f32;
        };
    `,
    `
        import _0;

        pub struct mat34 {
            mx: vec3;
            my: vec3;
            mz: vec3;
            mo: vec3;
        };

        pub inline fn mat34_identity()
            mat34(
                vec3(x: 1),
                vec3(y: 1),
                vec3(z: 1), vec3 /*point3*/);
    `,
    `
        pub struct mat4 {
            m0: f32; m1: f32; m2: f32; m3: f32;
            m4: f32; m5: f32; m6: f32; m7: f32;
            m8: f32; m9: f32; mA: f32; mB: f32;
            mC: f32; mD: f32; mE: f32; mF: f32;
        };

        pub inline fn mat4(using m: _1::mat34)
            mat4(
                mx.x, mx.y, mx.z, 0,
                my.x, my.y, my.z, 0,
                mz.x, mz.y, mz.z, 0,
                mo.x, mo.y, mo.z, 1);

        pub fn determinant(using _: mat4)
            + mC * m9 * m6 * m3 - m8 * mD * m6 * m3 - mC * m5 * mA * m3
            + m4 * mD * mA * m3 + m8 * m5 * mE * m3 - m4 * m9 * mE * m3
            - mC * m9 * m2 * m7 + m8 * mD * m2 * m7 + mC * m1 * mA * m7
            - m0 * mD * mA * m7 - m8 * m1 * mE * m7 + m0 * m9 * mE * m7
            + mC * m5 * m2 * mB - m4 * mD * m2 * mB - mC * m1 * m6 * mB
            + m0 * mD * m6 * mB + m4 * m1 * mE * mB - m0 * m5 * mE * mB
            - m8 * m5 * m2 * mF + m4 * m9 * m2 * mF + m8 * m1 * m6 * mF
            - m0 * m9 * m6 * mF - m4 * m1 * mA * mF + m0 * m5 * mA * mF;
    `,
    `
        pub fn main()
        {
            let m34 = _1::mat34_identity;
            let m44 = _2::mat4(m34);

            return m44.determinant.i32 - 1;
        }
    `
    ]);

    ZERO([`
        struct _0 { x?: f32; y?: f32 };
        fn maxc(using vec: _0) x > y ? x : y;
    `,
    `
        <alt>
        import _0;
        fn main() _0.maxc.i32;
        <alt/>
        fn main() ::_0.maxc.i32;
        </alt>
    `]);

    ZERO([
    `
        pub fn _0(i: i32) i + 1;
    `,
    `
        fn main() (-1).::_0;
    `
    ]);

    ZERO([
    `
        pub fn add(ref to: $T[], item: $T) {
            for (mut i = 0; i < to.len; i++) {
                if (to[i] >= item) {
                    if (to[i] != item)
                        to.insert(i, item);

                    return;
                }
            }

            to.push(item);
        }
    `,
    `
        fn main() {
            mut x = [1, 2, 3];
            x._0::add(3); if (x.len != 3) return 33;
            x._0::add(4); return x.len - x[3];
        }
    `
    ]);

    ZERO([
    `
        pub let pad0 = 0; pub let pad1 = 1; pub let pad2 = 2; pub let pad3 = 3; pub let pad4 = 4; pub let pad5 = 5; pub let pad6 = 6; pub let pad7 = 7; pub let pad8 = 8; pub let pad9 = 9;
        pub let PAD0 = 0; pub let PAD1 = 1; pub let PAD2 = 2; pub let PAD3 = 3; pub let PAD4 = 4; pub let PAD5 = 5; pub let PAD6 = 6; pub let PAD7 = 7; pub let PAD8 = 8; pub let PAD9 = 9;

        pub let A = "hello";
        pub let B = "world";
    `,
    `
        import _0;
        fn test(i: i32) {
            let v = i & 1 ? A : B;
            return v.len;
        }

        fn main() 0.test - 1.test;
    `
    ]);

    ZERO([
    `
        pub fn clone(a: $T)
        case ($T.is::copy) a;
        case ($T -> $T) {
            mut res: $T;
            for (fieldname i: $T) res.i = a.i.clone();
            return res;
        }
    `,
    `
        pub nocopy struct Scope { x: i32; };

        pub struct ModuleOutputs {
            deps: i32[];
            scope: Scope;
        };

        pub fn test(a: ModuleOutputs) {
            let b = a._0::clone();
            return a.deps.len - b.deps.len;
        }

        pub fn main() test(ModuleOutputs);
    `
    ]);

    ZERO([`
        // a private fn
        fn createShader(src: string) = src;

        // inits a public let
        pub let GEOMETRY_PASS_TEST = createShader("src");       ;; ConstCast
    `,
    `
        pub fn main() _0::GEOMETRY_PASS_TEST.len - 3;
    `]);

    ZERO([`
        struct List {
            vals: string[];
        };

        fn add(using ref _: List, val: string)
            vals ~= val;

        fn [](using _: List, val: string) {
            mut count = 0;
            for (mut i = 0; i < vals.len; i++)
                if (vals[i] == val)
                    count++;

            return count;
        }
    `,
    `
        fn main() {
            mut list: _0::List;
            for (mut i = 0; i < 3; i++)
                list.add(i & 1 ? "a" : "b");

            return list["b"] - 2;
        }
    `]);

    ZERO([`
        struct Int { i: i32; };
        fn -(a: Int) Int(-a.i);
        fn +(a: Int, b: Int) Int(a.i + b.i);
        fn +=(ref a: Int, b: Int) { a.i += b.i; return a; };
        postfix fn ++(ref a: Int) { a.i++; };
    `,
    `
        fn main() {
            mut x: _0::Int = [ 1 ];
            x += -(x + x);
            x++;
            return x.i;
        }
    `]);

    ZERO([`
        fn private(x)           x * 3;              // Scope_import is broken,
        pub fn public(y)        private(y) * 2;     //  doesnt always import privates.
        <split/>
        fn main()               1.public - 6;
    `]);

    ZERO([`
        fn private(x: i32)      x * 3;              // cg fail:
        pub fn public(y)        private(y) * 2;     //  fn private hidden in first translation unit.
    `,`
        fn main()               1._0::public - 6;
    `]);

    ZERO([`
        let OPTOKENS = "{}[]()!?~@#$%^&*/-+<=>,.;:|";   // nowadays problem is OPTOKENS cgs to static in first translation unit

        pub fn lex(src) // <- template
        {
            let end = src.len;
            mut idx = 0;

            while (idx < end) {
                let c = src[idx++];
                if (OPTOKENS.has(c)) // <- originally, no OPTOKENS in scope ...
                    return idx - 1;
            }

            return src.len;
        }
    `,
    `
        fn main() _0::lex("3 - 3") - 2; // <- from here
    `]);

    ZERO([`
        pub fn pubbed(a: i32) a * 2;
        <fail not_pubbed not defined><pass/>
        pub                          </fail>
        fn not_pubbed(b: i32) b * 3;
    `,`
        fn main() 1._0::pubbed._0::not_pubbed - 6;
    `]);

    ZERO([`
        let SELF_TEST           = true;
        let NODEIDX_signbits    = SELF_TEST && 4;
        let NODEIDX_signmask    = (1 << NODEIDX_signbits) - 1;
    `,`
        fn main() _0::NODEIDX_signmask - 15;
    `]);

    ZERO([`
        struct Helpers { index: i32; }
        fn +(a: Helpers, b: Helpers) a.index - b.index;
    `,`
        import _0;
        fn main() {
            <fail ambig><pass/> // autoshadowing surprised me here
            shadow      </fail> //  feels like this override should be explicit
            infix fn +(a: Helpers, b: Helpers) a.index + b.index;
            return Helpers(+1) + Helpers(-1);
        }
    `]);

    ZERO([`
        struct Options { v: i32; };
    `,
    `
        fn compile(o: _0::Options) = o.v;
    `,
    `
        // Won't find Options if solving in reverse modid order.
        fn compile_snippets(o: _0::Options) = o.v;
    `,
    `
        import _1;
        import _2;

        fn main() {
            let o = _0::Options(0);
            return compile(o) + compile_snippets(o);
        }
    `]);

    ZERO([`
        let x: i32 = 2;
    `,`
        pub import _0;
        let y: i32 = 3;
    `,`
        import _1;
        fn main() x + y - 5;
    `]);

    ZERO([`
        struct Profile {
            a: i32;
            b: i32;
            c: i32;
        };

        fn incr(implicit ref p: Profile, which) {
            p.which++;
        }
    `,`
        fn main() {
            implicit mut p: _0::Profile;

            _0::incr(fn _0::a);
            _0::incr(|i| i._0::b);
            _0::incr(|i| i.b);                                  ;; DuplicateFunctions
            _0::incr(._0::c);
            _0::incr(.c);

            return p._0::a + p.b * 10 + p.c * 100 == 221 ? 0 : 1;
        }
    `]);

    ZERO([
    `
        inline fn isStruct(type: string) =
            type.starts(with: '/');

        inline fn isStructOrUnion(type: string) =
            type.isStruct;
    `,`
        fn lookupUserType(type: string) =
            "<" ~ type.len ~ ">";

        fn tryLookupUserType(type: string) =
            type._0::isStruct && lookupUserType(type);
    `,`
        fn getFlatCount(type: string) =
            type._0::isStructOrUnion
                ? _1::tryLookupUserType(type).len
                : 1;
    `,`
        fn main() = "/a"._2::getFlatCount() == 3 ? 0 : 1;
    `]);

    ZERO([`
        noinline fn recA(x) x & 1 ? recB(x) : x;
        noinline fn recB(x) recA(x + 1);

        pub inline fn fun(x: i32) recB(x);
    `,`
        fn main() _0::fun(0) == 2 ? 0 : 1;                      ;; GNUStmtExpr
    `]);

    ZERO([`
        fn add2(x: i32) x + 2;
        fn times10(x: i32)
            <fail import circ 2:9+6 5:23+2>
                x * _1::add5(5)     <pass/>
                x * 10              </fail>;
    `,
    `
        import _0;
        fn add5(x: i32) add2(x) + 3;
    `,
    `
        fn main() _0::times10(_1::add5(8)) - 130;
    `]);

    ZERO([`
        fn hello(x: i32) x * 3;
    `,
    `
        <fail could not resolve import _2 3:9+6>
        import _2;                       <pass/>
        import _0;                       </fail>
        fn main() hello(4) - 12;
    `]);

    ZERO([`
        pub struct What { thing: i32 };

        <fail must_be_public not defined 2:33+14><pass/>
        pub </fail>
        fn must_be_public(x: What) = x.thing * 11;
    `,`
        fn main() = _0::What(3).must_be_public - 33;
    `]);

    ZERO([`
        struct Module { modid: i32; target: Target }
        struct Target { _packed: u64 }

        let modid = 2;
        inline fn modid(t: Target) i32(t._packed);
        inline fn index(t: Target) i32(t._packed >> 32);

        fn Target(shadow modid: i32, index: i32) {
            return Target(modid.u64 | index.u64 << 32);
        }
    `,`
        import _0;
        fn inspect(m: Module) {
            return modid + m.modid + m.target.modid;            ;; GNUStmtExpr
        }
    `,`
        import _0;
        fn main() {
            let m = Module(3, Target(5, 7));
            return m._1::inspect() - 10;
        }
    `]);

    ZERO([`
        struct Module { modid: i32; };
        struct Target { _packed: u64; };

        fn modid(t: Target) i32(t._packed & 0xffffff);

        fn Target(modid: i32, index: i32, local: i32) {
            return Target(modid.u64
                        | index.u64 << 24
                        | local.u64 << 44);
        }
    `,`
        import _0;
        fn inspect(module: Module) = module.modid;
    `,`
        fn main() _1::inspect([]);
    `]);

    ZERO([`
        struct Opts { b: i32 };
    `,`
        fn main() {
            fn muteRest(a, opts?: _0::Opts) a + opts.b;
            return 0.muteRest;
        }
    `]);

    ZERO([`
        noinline fn ifArray(type: string, hit) {
            if (type.starts(with: "[]"))
                hit(type.slice(2));
        }

        noinline fn tryClearArray(type: string, else!?) {
            ifArray(type): |item|
                return item;

            return else();
        }

        inline fn clearArray(type: string) {
            return tryClearArray(type, else: ||
                throw("Not an array: " ~ type));
        }
    `,`
        fn main() = _0::clearArray("[]int").len - 3;            ;; GNUStmtExpr
    `]);

    ZERO([`
        fn Arr(type V) struct { items: V[] };
        fn append !V(
            using ref _:    <fail ARR is not defined 5:20+1>
                ARR(V),     <pass/>
                Arr(V),     </fail>
            item: V) items ~= item;
    `,
    `
        fn main() {
            mut arr: _0::Arr(i32);
            return arr.append(0).len - 1;
        }
    `]);

    TODO_pub(currently: "BUG !isExtLinked but off-module 2:33+1", [`
        <fail not defined X:X><pass/>
        pub</fail>
        fn not_public(x: i32) x * 2;
        pub fn public(x: i32) x * 3;
    `,
    `
        fn test(x, apply) apply(x);
        fn main() test(5, fn _0::not_public) - 10;
    `]);

    // /Pubs & imports.


    // Explicit shadowing.

    ZERO(`
        let a = 1;
        shadow let a = a + 1;
        return a - 2;
    `);

    ZERO(`
        inline fn outer() inner(); // <- this reset root-scope
        inline fn inner() {
            // <- so main::i was visible here
            for (mut i = 0; i < 10; i++) return i;
            return 1;
        }
        fn main() {
            for (mut i = 0; i < 10; i++) return outer();
            return 1;
        }
    `);

    ZERO(`
        pub struct Target { modid: i32; packed: u32; };

        pub fn index(t: Target) i32(t.packed & 0x7fffffff);

        pub fn local_eq(t: Target, index: i32, implicit modid: i32)
            modid - t.modid || index - t.index;

        fn main() {
            let implicit modid = 1;
            return local_eq(Target(1, 0x80000002), 7) - 5;
        }
    `);

    ZERO(`
        nocopy struct P { secs: P[] };

        fn matchImplicitArgByName_closuresAndShadowing(prims: P[]) {
            struct Helper { idx: i32; };

            using fn GET(using _: Helper) prims[idx];

            shadow mut prims = {
                mut res: Helper[];
                for (mut i = 0; i < prims.len; i++)
                    res ~= Helper(i);
                res                                             ;; GNUStmtExpr
            };

            prims.sort(|a, b| a.secs.len < b.secs.len);

            mut res = 101;
            for (mut i = 0; i < prims.len; i++) {
                let m = prims[i];
                res += m.secs.len;
                res *= m.secs.len;
            }

            return res;
        }

        fn main() {
            let prims = [ P([ P, P, P ]), P, P([ P ]), P([ P, P ]) ];
            let res = matchImplicitArgByName_closuresAndShadowing(prims);
            return res == 27 ? 0 : 1;
        }
    `);


    // Return inference.

    ZERO(`
        struct HasInt { i: i32; };

        fn test(s: HasInt): &i32 {
            let i = s.i;
            return i;
        }

        fn main() HasInt(-1).test + 1;
    `);

    ZERO(`
        fn test(x: i32): &i32 = x;
        fn main() test(3) - 3;
    `);

    ZERO(`
        fn test(x: i32): &i32 {
            fn inner() x;
            return inner;
        }

        fn main() test(3) - 3;
    `);

    ZERO(`
        struct I { v: i32; };

        fn test(x: I): &i32 {
            fn inner() x.v;
            return inner;
        }

        fn main() test(I(3)) - 3;
    `);

    ZERO(`
        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() x.v[0];
            return inner;
        }

        fn main() test(I([3])) - 3;
    `);

    ZERO(`
        struct I { v: i32[]; };

        fn test(x: I): &i32 {
            fn inner() {
                let v = x.v;
                return v[0];
            }

            return inner;
        }

        fn main() test(I([3])) - 3;
    `);

    ZERO(`
        fn noReturn() throw ("ex");

        fn doesReturn(a: i32) {
            if (a > 0) return noReturn();
            return a;
        }

        fn main() doesReturn(-3) + 3;
    `);

    ZERO(`
        struct Context { modules: Module[]; };
        struct Module  { fname: i32; };

        fn test(implicit ctx: Context) {
            fn findModule(fname: i32): &Module {
                let modules = ctx.modules;
                for (mut i = 0; i < modules.len; i++) {
                    let module = modules[i];
                    if (module.fname == fname)
                        return module;
                }

                throw("Cannot locate: " ~ fname);
            }

            return findModule(0);
        }

        fn main() {
            let implicit ctx = Context([ Module ]);
            return test.fname;
        }
    `);

    ZERO(`
        fn noReturn() throw ("ex");

        fn returnVoid(a: i32): void {
            if (a > 0) return noReturn();
        }

        fn main() {
            returnVoid(0);
            return 0;
        }
    `);

    ZERO(`
        fn parseQualifierChain(mut i: i32): i32 {
            for (;;) {
                if !(i & 15) return i;
                i--;
            }
        }

        fn main() parseQualifierChain(15);
    `);

    ZERO(`
        fn main()
        {
            mut sum = 0;
            fn compile(x: i32)
            {
                // 1. this throw contributed a 'never' ret_count.
                x || throw ("x=0");
                if (x & 1) compile(x + 1); // 2. then this recursion did something.
                sum += x; // <- also this must be a closure.
                // 3. finally no ret_actual but non-zero ret_count.
            }

            compile(2);
            return sum - 2;
        }
    `);

    ZERO(`
        fn main()
        {
            mut sum = 0;
            fn getModule(fname: string) fname.len;
            fn compile(fname: string, via: string = "")
            {
                let module = getModule(fname) || throw ("import circle: '" ~ via ~ fname ~ "'.");
                if (module & 1) {
                    let fuzimports = fname.split("a");
                    for (mut i = 0; i < fuzimports.len; i++)
                        compile(
                            fname: fuzimports[i],
                              via: fname ~ " <- " ~ via);
                }

                sum += module;
            }

            compile("ab");
            return sum - 2;
        }
    `);

    ZERO(`
        fn A(implicit _A: i32[]) _A;
        fn B(implicit _B:  u8[]) _B;

        fn AB(x: i32) A[x] - B[x].i32;
        fn BA(x: i32) B[x].i32 - A[x];

        fn cycleA_inner(x: i32)
            x & 1   ? either(x + 1) + AB(x)
                    : BA(x);

        fn cycleA_outer(x: i32)
            x & 1   ? cycleA_inner(x + 1) + AB(x)
                    : BA(x);

        fn cycleB_inner(x: i32)
            x & 2   ? either(x + 1) + BA(x)
                    : AB(x);

        fn cycleB_outer(x: i32)
            x & 2   ? cycleB_inner(x + 1) + BA(x)
                    : AB(x);

        fn either(x: i32)
            x & 4   ? cycleA_outer(x)
                    : cycleB_outer(x);

        fn main() {
            let implicit _A = [ 0,    1,    2    ];
            let implicit _B = [ 0.u8, 1.u8, 2.u8 ];

            return either(0);
        }
    `);


    // Dead code elim.

    ZERO(`
        fn if0_ret101(x: i32) {
            if      (x > 2) return x * 2;
            else if (x > 1) return x + 1; // <- left branch seeded right with never
            return x + 101;
        }

        fn main() 0.if0_ret101 - 101;
    `);

    ZERO(`
        fn hello(x: i32) {
            if (x & 1)
                return x * 2;

            <fail missing return>
            x;            <pass/>
            return x;     </fail>
        }

        fn main() 0.hello;
    `);

    ZERO(`
        fn throws()         { throw("WHAT!");   }
        fn myfn(a = throws) { return a;         } // never in default argument position!
        fn main() {
            try             { return myfn();                }
            catch (e)       { return e == "WHAT!" ? 0 : 1;  }
        }
    `);

    ZERO(`
        fn printus(parts: string[], implicit ref out: i32)
            parts.each(|part| part.each(|c| out += c.i32 ));

        <alt>
        inline  <alt/>
        lax     </alt>
        fn silent(lax parts) {}

        fn main() {
            implicit mut out: i32;

            printus([ "Hel","lo" ]);
            if (out != 500)
                return 1;

            // Tries to test dead array literals.
            shadow let printus = fn silent;

            printus([ "Hel","lo" ]);
            return out == 500 ? 0 : 1;
        }
    `);


    // Type assert.

    ZERO(`
        fn test() [] => i32;
        fn main() test;
    `);

    ZERO(`
        fn main() {
            <alt>
            if (true) return 0;     <alt/>
            if (!false) return 0;   <alt/>
            if !(false) return 0;   </alt>
            DOESNT_EXIST();
        }
    `);

    ZERO(`
        fn test(a) {
            if (typeof(a) -> _[:])
                return a.len;

            return a * 10;
        }

        fn main() {
            let A = [ 0, 1 ].test;
            let B = 4.test;
            return A + B == 42 ? 0 : 1;
        }
    `);

    ZERO(`
        fn staticIfSymmetry(
            <fail $T is not defined>
            ref a: $U[], b)  <pass/>
            ref a: $T[], b)  </fail>
        {
            let N = typeof(b) ->  $T   ? 1 : 2;
            let M = typeof(b) -> [$T;] ? 2 : 1;
            a ~= b;
            return N == M ? 0 : 1;
        }

        fn main() {
            mut arr = [ 0 ];
            return staticIfSymmetry(arr, 0)
                 + staticIfSymmetry(arr, [ 0, 0 ])
                 + arr.len * 10 - 40;
        }
    `);

    ZERO(`
        fn main() {
            let a: <fail bad call unsigned 4:23+8>f32<pass/>i32</fail> = 1;
            let b = a.unsigned;
            let c = a.signed;
            if (typeof(a) -> u32) return 1;
            if (typeof(a) -> i32) {
                if (typeof(b) -> i32) return 2;
                if (typeof(b) -> u32) {
                    if (typeof(c) -> i32) {
                        if (typeof(0.i8.unsigned)   -> u8  &&
                            typeof(0.i16.unsigned)  -> u16 &&
                            typeof(0.i32.unsigned)  -> u32 &&
                            typeof(0.i64.unsigned)  -> u64 &&
                            typeof(0.i128.unsigned) -> u128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }
    `);

    ZERO(`
        fn main() {
            let a: <fail bad call signed 4:23+6>f64<pass/>u64</fail> = 1;
            let b = a.signed;
            let c = a.unsigned;
            if (typeof(a) -> i64) return 1;
            if (typeof(a) -> u64) {
                if (typeof(b) -> u64) return 2;
                if (typeof(b) -> i64) {
                    if (typeof(c) -> u64) {
                        if (typeof(0.u8.signed)   -> i8  &&
                            typeof(0.u16.signed)  -> i16 &&
                            typeof(0.u32.signed)  -> i32 &&
                            typeof(0.u64.signed)  -> i64 &&
                            typeof(0.u128.signed) -> i128)
                        {
                            return 0;
                        }
                        return 3;
                    }
                    return 4;
                }
            }
            return 5;
        }
    `);


    // Defer.

    ZERO(`
        fn main() {
            mut a = 1;
            mut b = 0;
            {
                defer a++;
                b = a;
            }
            return (b+1) - a;
        }
    `);

    ZERO(`
        fn main() {
            mut a = 1;
            mut b = 0;
            mut c = 0;
            {
                defer a++;
                defer c = a;
                b = a;
            }
            return (b*27) - (a*11 + c*5);
        }
    `);

    ZERO(`
        fn test_defer_if_errok(throw_err: bool) {
            mut x      = 1;
            mut if_err = 0;
            mut if_ok  = 0;
            try {
                defer x++;
                defer:err if_err += x;
                defer:ok  if_ok  += x;

                if (throw_err)
                    throw("len=5");

                x += 8; // 9 defer++ = 10
            }
            catch (e) {
                x += e.len; // 6 defer++ = 7
            }

            return x * 3 + if_err * 5 + if_ok * 7;
        }

        fn main()   (test_defer_if_errok(true)  - 7 *3 - 1*5 - 0*7)
            + 100 * (test_defer_if_errok(false) - 10*3 - 0*5 - 9*7);
    `);

    ZERO(`
        fn test(ref x: i32) {
            x++;
            <alt>
            defer x++;      <alt/>
            defer:ok x++;   </alt>
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        fn test(ref x: i32) {
            <fail missing final return 8:13+5>
            if (x & 1)              // ------ currently highlights the defer
                return x;           //         probably should highlight the semicollon
            <pass/></fail>
            x++;
            defer:err x++;
        }

        fn main() {
            mut x = 0;
            test(x);
            return x == 1 ? 0 : 1;
        }
    `);

    ZERO(`
        fn sum_amulb(a: i32[], b: i32[], ref sum: i32)
            for (mut i = 0; i < a.len; i++)
                sum += a[i] * b[i];

        fn incrarr_by1(ref a: i32[])
            for (mut i = 0; i < a.len; i++)
                a[i] += 1;

        fn test(ref a: i32[], ref sum: i32) {
            let b = a;
            defer sum_amulb(:a, :b, :sum);

            <alt>
            for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 2;
            <alt/>
            defer for (mut i = 0; i < a.len; i++) a[i] += 1;
            return a[0] - 1;
            <alt/>
            incrarr_by1(:a);
            return a[0] - 2;
            <alt/>
            defer incrarr_by1(:a);
            return a[0] - 1;
            </alt>
        }

        fn main() {
            mut a = [ 1 ];
            mut sum = 0;
            let ret = 100 * test(:a, :sum);
            return sum - 2 + ret;
        }
    `);

    ZERO(`
        fn main() {
            mut res = 1;            // single statement blocks unwrap
            { defer res--; }        //  fix by unwraping tailing defers
            return res;
        }
    `);

    ZERO(`
        fn unwraps_defer(ref x: i32) unwrap {
            defer x++;
        }

        fn main() {
            mut y = 0;
            { unwraps_defer(y); }
            mut x = 0;
            unwraps_defer(x);
            return y == 1 && x == 0 ? 0 : 1;
        }
    `);


    // Conversions / ctors.

    ZERO(`
        type Test = i8;
        fn main() 256.Test.i32;
    `);

    ZERO(`
        fn test(a: $A, b: $B) b +   <fail bad call>
            a;                      <pass/>
            $B(a);                  </fail>

        fn main() i8(-1).test(+1);
    `);

    ZERO(`
        struct Test { v: u32 };
        fn test(v   <fail bad call type Test expect u32 got i32 5:23+1 2:9+6>
                        <pass/>
                 : u32  </fail>
            ): Test = [ v ];

        fn main() test(2).v == 2 ? 0 : 1;
    `);


    // Higher-order functions.

    ZERO(`
        let x = { mut z = 0; z++; z };
        return x - 1;
    `);

    ZERO(`
        fn mul2(a) a*2;
        fn test(b, fn) fn(1 + fn(b));
        fn main() 14 - test(3, fn mul2);
    `);

    ZERO(`
        let overloaded = 1;
        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() 14 - test(3, fn overloaded);
    `);

    ZERO(`
        fn overloaded(a) a*2;
        fn test(b, fn) fn(fn + fn(b));
        fn main() {
            let overloaded = 1;
            return 14 - test(3, fn overloaded);
        }
    `);

    ZERO(`
        fn MAP(items: $T[], fn) {
            mut result: typeof( fn(items[0]) )[];
            for (mut i = 0; i < items.len; i++)
                result.push(fn(items[i]));

            return result;
        }

        fn sqr(x) x*x;

        fn main() [2].MAP(fn sqr)[0] - 4;

        ;; EXPECT (fu::slate<1, int> { 2 })
        //  During the propagateType rework
        //   the 'mut result: fn(items[0])[]' type annot
        //    was found listed as a callsite for items,
        //     but wasn't reachable for relax.
    `);

    ZERO(`
        fn reduce(items: $T[], fn, init?: $T) {
            mut result = init;
            for (mut i = 0; i < items.len; i++)
                result = fn(result, items[i]);

            return result;
        }

        fn main() [1, 2].reduce(|a, b| a + b) - 3;
    `);

    ZERO(`
        fn Each(items: $T[], fn) {
            for (mut i = 0; i < items.len; i++) // <- one i
                fn(items[i]);
        }

        fn main() {
            mut i = 0;                  // <- another i, i got them to shadow each other
            [1, 2].Each: |x| i += x;    //      in the everything-a-free-function
            return i - 3;               //      impl of closures
        }
    `);

    ZERO(`
        mut sum = 2;

        fn FnDecl_update(parent_idx: i32) {
            fn Each(fn) fn();
            Each(|| makeDirty(:parent_idx));
        }

        fn makeDirty(parent_idx: i32): void {
            sum += parent_idx;
        }

        FnDecl_update(1);

        return sum - 3;
    `);

    ZERO(`
        // something complains about no final return
        fn main() {
            let addret = |a: i32, b: i32| {
                return a + b;
            };

            let hey = |x: i32| {
                if !(x & 1)
                    return x;

                // this complains about indentation
                // TODO should work without the continue
                <alt>
                continue "".len                                 ;; GNUStmtExpr
                <alt/>
                "".len.addret(x)
                </alt>
            };

            // and this complains about no match for *(void, void)
            return hey(0) * hey(1);
        }

        // misfired during the removal of maybeCopyOrMove(isReturn)
        ;; !*MustSeq
    `);

    ZERO(`
        // something complains about no final return
        fn main() {
            let hey = |x: i32| {
                if !(x & 1)
                    return x;                                   ;; GNUStmtExpr

                "".len + x
            };

            // and this complains about no match for *(void, void)
            return hey(1) * hey(0);
        }
    `);

    ZERO(`
        fn check(a, b, compare! = infix fn <>)
            compare(a, b);

        fn main() check(0, 0);
    `);

    ZERO(`
        fn check(a, b, compare! = |aa, bb| aa <> bb)
            compare(a, b);

        fn main() check(0, 0);
    `);

    // /Higher-order functions.


    // Conversion functions.

    ZERO(`
        struct A { a: i32; };
        struct B { b: i32; };

        <alt>
        using fn bananas(a: A)  B(a.a * 2); <alt/>
        using fn bananas(a)     B(a.a * 2); <alt/>
        using fn bananas(a.a)   B(  a * 2); </alt>

        <split/>
        fn main() 1.A.b - 2;
    `);

    ZERO(`
        fn sqr(a: i32) a * a;
        fn woot(a.sqr) a + 1;
        fn main() 2.woot - 5;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B  { b:  i32; };

        fn a0(a1: A1) a1.a1 * 100;
        fn bananas(a) B(a.a0 * 2); // <- template
        fn woot(a.bananas: B) a.b; // <- check

        fn main() 1.A0.woot + 1.A1.woot - 202;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b0: i32; };
        struct B1 { b1: i32; };
        struct C  { c:  i32; };

        fn bananas(using _: A0) B0(a0 * 2);
        fn bananas(using _: A1) B1(a1 * 3);
        using fn c0(using _: B0) C(c: b0 * 5);
        using fn c1(using _: B1) C(c: b1 * 7);
        fn woot(using a.bananas: C) c; // extra conversion

        fn main() 1.A0.woot + 1.A1.woot - 31;
    `);

    ZERO(`
        struct A0 { a0: i32; };
        struct A1 { a1: i32; };
        struct B0 { b:  i32; };
        struct B1 { b:  i32; };

        fn bananas(a0: A0) B0(a0.a0 * 2);
        fn bananas(a1: A1) B1(a1.a1 * 3);
        fn woot(a.bananas) a.b; // <- template

        fn main() 1.A0.woot + 1.A1.woot - 5;
    `);

    ZERO(`
        fn times_implicit(x: i32, implicit y: i32) x * y;
        fn times7(x: i32) x * 7;

        fn woot(a.times_implicit, b: u32) a * b.i32;
        fn woot(a: i32, b.times7: i32) a * b;

        fn test0() 3.woot(2.i32);

        fn test1() {
            let implicit y = 7;
            return 3.woot(2.u32);
        }

        fn main() test0 + test1 * 1000 - 42042;
    `);

    ZERO(`
        struct X { str: string; };
        fn ~(a: X, b: X) X(a.str ~ b.str);          // currently: invalid operator~ cg
        inline fn ~(a: X, b.to_debug_str) a ~ b;    // currently: pointless blocks

        fn to_debug_str(a: i32) X("i" ~ a);

        fn main() {
            let hey = X("Hey! ") ~ 5;                           ;; GNUStmtExpr
            return hey.str == "Hey! i5" ? 0 : 1;
        }
    `);

    ZERO(`
        struct vec32  { x: f32; };
        struct conv32 { v: f32; };

        <alt>
        using inline fn convert(v: i32): conv32 = [ v.f32 ]; // no litfix
        <alt/>
        using inline fn convert(v: f32): conv32 = [ v ]; // litfix in a conv: i32 -> f32
        </alt>

        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        fn main() i32 <| (1/vec32(1)).x - 1;                    ;; GNUStmtExpr
    `);

    ZERO(`
        struct vec_u  { x: u32; };
        struct vec32  { x: f32; };
        struct vec64  { x: f64; };

        struct conv_u { v: u32; };
        struct conv32 { v: f32; };
        struct conv64 { v: f64; };

        using inline fn convert(v: u32): conv_u = [ v ]; // matchfail before
        using inline fn convert(v: f32): conv32 = [ v ];
        using inline fn convert(v: f64): conv64 = [ v ]; // matchfail after

        inline fn /(a: conv_u, b: vec_u) vec_u(a.v / b.x);
        inline fn /(a: conv32, b: vec32) vec32(a.v / b.x);
        inline fn /(a: conv64, b: vec64) vec64(a.v / b.x);

        fn main() i32 <| (1/vec32(1)).x - 1;                    ;; GNUStmtExpr
    `);

    ZERO(`
        pub struct Module       { modid: i32; };
        pub struct Target       { modid: i32; index: i32; };
        pub struct Type         { using vtype: ValueType; };
        pub struct ValueType    { modid: i32; canon: string; };
        pub struct Overload     { kind: string; locals?: Overload[]; };

        fn main() {
            using fn GET(target: Target, implicit overloads: Overload[]) {
                target.index > 0 || throw("Assertion failed.");
                if (target.modid < 0)
                    return overloads[-target.modid - 1].locals[target.index - 1];
                else
                    return overloads[target.index - 1];
            }

            fn try_GET(target: Target)
                target && GET(target);

            implicit mut overloads: Overload[];
            overloads ~= Overload("What");
            return try_GET(Target(0, 1)).kind.len - 4;
        }
    `);

    ZERO(`
        struct RWEvent { rw_target!: i32 };
        struct ReadID  { id: i32 };

        fn main()
        {
            <fail ambig rw_target>
            using   <pass/></fail>
            fn RWEvent(read: ReadID)    RWEvent(rw_target: read.id);

            fn rw_target(read: ReadID)  read.id;

            return ReadID(0).rw_target;
        }
    `);

    TODO_conv(currently: "Bad call to a_len 4:24+5", `
        fn a_len(a: [$T]) a.len; // a conversion could navigate this here
        struct Test { using a: i32[]; };
        fn main() Test.a_len;
    `);

    TODO_conv(currently: "Bad call to ~ 6:24+1", `
        struct CodegenOutput { using src: string; };

        fn test(ref str: string, out: CodegenOutput) {
            str ~= out && "b";
            return str ~ out;
        }

        fn main() {
            mut str = "a";
            return str.test(CodegenOutput("what")).len - 6; // "abwhat".len;
        }
    `);

    ZERO(`
        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };

        <fail ambig conversion 14:18+1 lin2srgb 6:9+5 srgb2lin 9:9+5>
        using    <pass/></fail>
        fn lin2srgb(c: linearRGB): sRGB = [ c.r / 3 ];

        using
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 3 ];

        fn RGB(linear: bool, r: i32) {
            return linear
                 ? linearRGB(r)
                 :      sRGB(r);
        }

        fn main() {
            mut c = RGB(linear: false, 7);
            return c.r - 21;
        }
    `);

    ZERO(`
        struct linearRGB    { r: i32; };
        struct sRGB         { r: i32; };

        <fail cannot convert><pass/>
        using                </fail>
        fn srgb2lin(c: sRGB): linearRGB = [ c.r * 7 ];

        fn main() = (sRGB(r: 3) => linearRGB).r - 21;
    `);

    ZERO(`
        struct Overload     { name: string; };
        struct Target       { o_index: i32; };

        struct Helpers      { hd_index: i32; };
        struct HelpersData  { target: Target; };

        fn solve(ref overloads: Overload[], ref helpers: HelpersData[])
        {
            using fn GET(h: Helpers)
                helpers[h.hd_index];

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(t: Target) {
                ref o = overloads[t.o_index];

                // The qWHAT here tried to (pointlessly) solve qWHAT below,
                //  but GET hadn't solved yet so it wasn't available.
                return o.qWHAT ? o : GET(Target(t.o_index + 1));
            }

            fn qWHAT(hd: HelpersData)
                hd.target.qWHAT;

            return Helpers(0).qWHAT;
        }

        fn main() {
            mut overloads: Overload[];
            mut helpers: HelpersData[];

            for (mut i = 0; i < 2; i++) {
                overloads ~= Overload(i && "o=" ~ i);
                helpers ~= HelpersData(Target(i));
            }

            return solve(overloads, helpers) == "o=1" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target       { index: int };
        struct Overload     { name: string; };

        fn solve(_overloads: Overload[], _targets: Target[]) {
            fn fail(mut reason: string): never {
                for (mut i = _targets.len; i --> 0; ) {
                    let t = _targets[i];
                    if (t)
                        reason ~= GET(t).qWHAT;
                }

                return throw(reason);
            }

            fn qWHAT(o: Overload)
                o.name;

            using fn GET(target: Target) {
                _overloads.len >= target.index || fail(
                    GET(Target(_overloads.len - 1)).qWHAT);

                return _overloads[target.index];
            }

            fn qWHAT(n: Target[]) {
            <alt>
                mut res = "";
                for (mut i = 0; i < n.len; i++)
                    res ~= n[i].qWHAT;

                return res;
            <alt/>
                return n.map(|t| t.qWHAT).join();
            </alt>
            }

            return _targets.qWHAT;
        }

        fn main() {
            mut res = solve(
                [ Overload("Hello"), Overload(", "), Overload("! "), Overload("World!") ],
                [ Target(0), Target(1), Target(3) ]);

            return res == "Hello, World!" ? 0 : 1;
        }
    `);

    ZERO(`
        fn a_slash_b(a: f32, b: f32) {
            return a ~ "/" ~ b;                                 ;; DuplicateFunctions
        }

        fn main() {
            return a_slash_b(1, 2) == "1.000000/2.000000" ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            let s: i32 = -3;
            let u: u32 =  3;
            <fail 6:22+1 9:10+1 T: incompatible types i32 u32>
            return s + u;             <pass/>
            return s + u.i32;         </fail>
        }
    `);

    ZERO(`
        struct Start { s: i32 };
        struct MidA { a: i32 };
        struct MidB { b: i32 };
        struct End { e: i32 };

        using fn toMidA(start: Start) MidA(start.s * 2);
        using fn toMidB(start: Start) MidB(start.s * 3);
        using fn toEnd(mida: MidA) End(mida.a * 5);

        <fail 18:26+1 multiple ways to conv Start into End toMidA 7:9+5 toEnd 9:9+5 toMidB 8:9+5 toEnd 12:9+5>
        using <pass/></fail>
        fn toEnd(midb: MidB) End(midb.b * 7);
        <split/>

        fn main() {
            let start = Start(1);
            return start.e - 2*5;
        }
    `);

    ZERO(`
        struct vec3 { x: i32 };
        fn woot(
            using a: vec3,
            <fail ambig using multiple ways to obtain vec3 9:20+1 4:13+5 6:13+5>
            using <pass/></fail>
            b: vec3)
        {
            return x + b.x;
        }

        fn main() vec3(1).woot(vec3(-1));
    `);

    ZERO(`
        struct B { v: i32 };
        struct C { v: i32 };

        <fail ambig 7:31+1 6:20+1 3:20+1 using fn AC 8:9+5>
        struct A { v: i32 };
        using fn AB(a: A) B(a.v * 2);
        using fn AC(a: A) C(a.v * 3);
        <pass/>
        struct A { a: i32 };
        using fn AB(a: A) B(a.a * 2);
        using fn AC(a: A) C(a.a * 3);
        </fail>

        fn main() {
            let a = A(1);
            let b: B = a;
            let c: C = a;
            return b.v * c.v - 6;
        }
    `);

    ZERO(`
        struct A1 { v: i32 };
        struct A2 { v: i32 };
        struct B { v: i32 };

        using fn A1B(a: A1) B(a.v * 2);
        using fn A2B(a: A2) B(a.v * 3);

        fn test(a): B = a;

        fn main() A1(1).test.v * A2(1).test.v - 6;
    `);

    SKETCH(currently: "Bad call to T A 13:24+1", `
        struct A { a: i32 };
        struct B { b: i32 };

        // Currently this would have to be named fn A -
        //  because we match by type *name*, instead of
        //   attempting conversions to type A.
        //
        // We want to replace match-by-name by tryConvert.
        //
        using fn A2B(a: A): B = [ a.a + 3 ];

        fn main() A(2)<alt>.B</alt>.b - 5;
    `);

    SKETCH(currently: "Bad call to T u32 11:21+1", `
        fn Wrap(type T) =
            struct { value!: T };

        infix fn => !<A, B>
            (from: Wrap(A), lax _: Wrap(B)): Into =
                [ Into(from.value) + 4 ];
    <alt>
        fn main() =
            (7.u32 => Wrap(int)).value - 14;
    <alt/>
        fn main() {
            type T = Wrap(int);
            return T(7.u32).value - 14;
        }
    </alt>
    `);

    ZERO(`
        struct A { target: i32; };
        struct B { target: u32; };

        fn definit()    <fail ambig call zeroes A:target B:target><pass/>
            : A         </fail>
                = [];

        fn main() = definit.target;
    `);

    // /Conversion functions.


    // Autocall, varargs & rest params.

    ZERO(`
        fn varargs(a[]) a[0] + a[1];
        fn main() varargs(1, 2) - 3;
    `);

    ZERO(`
        fn to_debug_str(a: i32) a     * 2;
        fn to_debug_str(b: u32) b.i32 * 3;

        <alt>
        inline                                                  ;; GNUStmtExpr
        </alt>
        fn inspect(items.to_debug_str[]) // <- varargs!
        {
            mut a = 0;
            for (mut i = 0; i < items.len; i++)
                a += items[i];

            return a;
        }

        fn main() inspect(5.i32, 7.u32) - 31;
    `);

    ZERO(`
        fn va(args[]: i32[]) {
            mut sum = 0;
            for (mut i = 0; i < args.len; i++) sum += args[i];
            return sum;
        }

        fn main() va(1, 2) - 3;
    `);

    ZERO(`
        fn Stringy(i: i32) "i:" ~ i;

        inline fn Printy(x: string): string = x;                ;; PointlessLocal
        inline fn Printy(x.Stringy): string = x;

        fn Println(parts.Printy[]<alt>: [string]</alt>) {
            mut total = 0;
            for (mut i = 0; i < parts.len; i++) total += parts[i].len;
            return total;
        }

        fn main() Println("str", 10) - 7; // 'stri:10'.len
    `);

    ZERO(` // inline fn empty retval on autocall                ;; GNUStmtExpr
        inline fn concatable(a: bool)               a ? "yes" : "no";
        inline fn concat(a.concatable, b: string)   a ~ b;
        fn main()                                   concat(true, "!") == "yes!" ? 0 : 1;
    `);

    ZERO(` // inline fn empty retval on autocall
        inline fn inl_print(a: byte)                a;          ;; PointlessLocal
        fn inl_println(a.inl_print[]: string)       a.len;
        fn main()                                   inl_println('a', 'b') == 2 ? 0 : 1;
    `);

    ZERO(`
        struct My { i: i32 };

        fn test(oh: My)
        {
            // autocall(): never
            let str = |my: My|: never {             ;; N_DeadConv
                return my.i; // exits test() here
            };

            <alt>
            let hello = "Hello, " ~ oh;     <alt/> // both mess up, this one emits a pointless overload,
            let hello = oh ~ "!";           </alt> //  this one messes up earlier in the solver

            return hello.len;
        }

        fn main() {
            return test(My(3)) - 3;
        }
    `);

    ZERO(`
        fn printlike(topic: string, stuff.print[]: [string], implicit ref out: string) {
            out ~= topic ~ ": " ~ stuff.join() ~ '\\n';
        }

        fn main() {
            let topic = "A";
            implicit mut out: string;
            printlike(:topic, "Hello, ", "World", "!");         ;; PointlessLocal
            return out == "A: Hello, World!\\n" ? 0 : 1
        }
    `);

    ZERO(`
        fn main() {
            mut out: string;                                    ;; PointlessLocal
            fn lazywarn(prefix: string, inline stuff.print[]: [string]) {
                out ||= prefix ~ stuff.join();
            }

            mut once = 0;
            fn once(str: string) {
                once++;
                return str;                                     ;; ConstCast
            }

            lazywarn(once("Hello"), ", ", "World", "!", prefix: "X: ");
            lazywarn(prefix: "Y: ", once("Hello"), "!");

            return out == "X: Hello, World!" && once == 1 ? 0 : 1
        }
    `);

    ZERO(`
        fn ifThenElse(inline cond, inline cons, inline alt)
            cond ? cons : alt;

        fn main() {
            mut cond = 0;
            ifThenElse(cond++,
                { return 10; },
                { return cond == 1 ? 0 : 100; });
        }
    `);

    ZERO(`
        fn not_ambig !T(ref sum!: i32,
            <alt>
            inline                                              ;; GNUStmtExpr
            </alt>
            v[]: T[])
        {
            fn acc(inline x: string)    sum += x.len;
            fn acc(inline x: i32)       sum += x;

            for (mut i = 0; i < v.len; i++) acc(v[i]);
            return sum;
        }

        fn not_ambig !T(ref sum: i32, a: i32, b: string) sum += (a + b.len);
        fn not_ambig !T(ref sum: i32, a: string, b: i32) sum += (a.len + b);

        fn main() {
            mut sum = 0;

            let a = not_ambig(:sum, 1, "ab");
            let b = not_ambig(:sum, "bc", 2);
            let c = not_ambig(:sum, "abc", "de");
            let d = not_ambig(:sum, 3, 3);
            let e = not_ambig(:sum, "abcdef",
                <fail bad call to not_ambig 23:30>
                                     'g'); <pass/>
                                     "g"); </fail>

            return a == 3 && b == 7 && c == 12 && d == 18 && e == 25 ? 0 : 1;
        }
    `);

    TODO_varargs(currently: "optional argument ambiguity 6:31+1", `
        fn count_args!T (
            <alt>
            inline
            </alt>
            v[]: T[]) = v.len;

        fn main() = count_args(
            hello?: "ignore me",
            1, 2, 3,
            world?: "ignore me too")
                == 3 ? 0 : 1;
    `);

    ZERO(`
        inline fn descend_a(ref data: i32[], offset: i32, implicit ref TWO: i32) {
            return TWO * will_relax_args_a(data, offset + 1);
        }

        noinline fn will_relax_args_a(ref data: i32[], offset: i32, implicit ref THREE: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_b(data, offset);
        <alt>
                if (offset & 2)
                    return 2 * will_relax_args_a(data, offset + 1);
        </alt>
                return descend_a(:data, :offset);
            }

            return THREE * offset;
        }

        noinline fn will_relax_args_b(ref data: i32[], offset: i32, implicit ref FOUR: i32) {
            if (offset < data.len) {
                if (offset & 1)
                    return descend_a(data, offset);
        <alt>
                if (offset & 2)
                    return 5 * will_relax_args_b(data, offset + 1);
        </alt>
                return descend_b(:data, :offset);
            }

            return FOUR * offset;
        }

        inline fn descend_b(ref data: i32[], offset: i32, implicit ref FIVE: i32) {
            return FIVE * will_relax_args_b(data, offset + 1);
        }

        fn main() {
            implicit mut TWO    = 2;
            implicit mut THREE  = 3;
            implicit mut FOUR   = 4;
            implicit mut FIVE   = 5;

            mut data = [ 0, 0, 0, 0, 0 ];
            let res = descend_b(data, 0);                       ;; GNUStmtExpr
            return res == 10000 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Token { index: i32 };
        struct Node  { token: Token };
        <split/>
        fn HERE(t.token<alt>: Token</alt>) t.index * 11;
        <split/>
        fn main = HERE(Node(Token(3))) - 33;
    `);

    ZERO([`
        struct Token { index: i32 };
        struct Node  { token: Token };
    `,`
        fn HERE(t.token<alt>: _0::Token</alt>) t.index * 11;
    `,`
        fn main = _1::HERE(_0::Node(_0::Token(3))) - 33;
    `]);

    // /Autocall, varargs & rest params.


    // Addrofns of struct fields.

    ZERO(`
        fn fn_v(fn, v) fn(v);
        struct XY { x: i32; y: i32; };  // fields weren't visible to addroffns
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);

    ZERO(`
        fn fn_v(x, v) x(v);             // same but name conflict - x arg and .x field
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);

    ZERO(`
        fn fn_w(x, y) x(y);             // same thing but
        fn fn_v(y, x) fn_w(fn y, x);    // extra nasty
        struct XY { x: i32; y: i32; };
        fn main() {
            let v = XY(11, 13);
            return fn_v(.x, v) + fn_v(.y, v) - 24;
        }
    `);


    // Inliner.

    ZERO(`
        fn identity(x) x;
        fn main() {
            fn outer(depth1) {
                let sum = depth1; return identity(|| sum);
            }
            let sum = 0; return outer(sum);
        }
    `);

    ZERO(`
        fn identity(x) x;
        fn test(depth0) {
            fn outer(depth1) {
                let sum = depth1; inline fn lambda1() sum; return identity(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);
    `);

    ZERO(`
        fn test(depth0) {
            fn identity(x) x;
            fn outer(depth1) {
                fn inner(depth2) {
                    let sum = depth2; inline fn lambda2() sum; return identity(fn lambda2);
                }
                let sum = depth1; inline fn lambda1() sum; return inner(fn lambda1);
            }
            let sum = depth0; inline fn lambda0() sum; return outer(fn lambda0);
        }
        fn main() test(0);
    `);

    ZERO(`
        fn test(depth0)
        {
            fn first(depth1) {
                fn first_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum;
                }

                let sum = depth0 + depth1;
                return first_inner(|| sum);                     ;; DuplicateFunctions
            }

            fn second(depth1) {
                fn second_inner(depth2) {
                    let sum = depth0 + depth1 + depth2;
                    return sum + first(|| sum);
                }

                let sum = depth0 + depth1;
                return second_inner(|| sum);
            }

            let sum = depth0 + depth0;
            return second(|| sum);
        }

        fn main() test(0);
    `);

    TODO_inline(currently: "COMPILER BUG host_args.len != args.len", `
        inline fn parseStuff(x: i32) descend(x);                ;; GNUStmtExpr

        inline fn descend(x: i32) {
            fn inner() x & 1 ? parseStuff(x / 2) : x;
            return inner();
        }

        fn main() parseStuff(5) == 2 ? 0 : 1;
    `);

    ZERO(`
        fn use_a(implicit a: i32) a * a;
        fn use_b(implicit b: i32) b * b;
        fn use_c(implicit c: i32) c * c;

        <alt>
        inline                                                  ;; GNUStmtExpr
        </alt>
        fn parseStuff(x: i32) {
            fn doStuff(y: i32) doSomething(y * y);
            return doStuff(x * x);
        }

        <alt>
        inline </alt>
        fn doSomething(x: i32) {
            fn doSomething_inner(y: i32) y * use_a * descend(y * y);
            return doSomething_inner(x * x);
        }

        <alt>
        inline                                                  ;; GNUStmtExpr
        </alt>
        fn descend(x: i32) { // <- x here
            fn descend_inner(y: i32)
                y & 1 ? parseStuff(y / 2) * parseStuff(x) // x not defined here?
                      : doSomethingElse(y * y) * use_c;

            return descend_inner(x * x);
        }

        <alt>
        inline                                                  ;; GNUStmtExpr
        </alt>
        fn doSomethingElse(x: i32) {
            fn doSomethingElse_inner(y: i32) y * use_b;
            return doSomethingElse_inner(x * x);
        }

        fn main() {
            let implicit a = 0;
            let implicit b = 0;
            let implicit c = 0;
            return parseStuff(0);
        }
    `);

    ZERO(`
        fn main() {
            mut stuff = "";
            fn doThing(thing)
                try         stuff = "continue " ~ thing();
                catch (e)   stuff = "throw " ~ e;

            :DO_THING doThing: ||
            {
                fn cannotDoThing(inline reason: string)
                    continue :DO_THING reason;
            <alt>
                cannotDoThing(throw("Reason"));
            };
            return stuff.len - 12; // "throw Reason"
            <alt/>
                cannotDoThing("Reason");
            };
            return stuff.len - 15; // "continue Reason"
            </alt>
        }
    `);

    ZERO(`
        fn nested(ref index: i32)
            return index++ && [];

        fn Lifetime_each(ref lifetime: i32[], visit)
            for (mut i = lifetime.len; i --> 0; )
                visit(nested(lifetime[i]));

        fn Lifetime_allowsMutrefReturn(ref lifetime: i32[])
            Lifetime_each(:lifetime): |t|
                return t;

        fn main() {
            mut arr: i32[] = [ 5, -2 ];
            Lifetime_allowsMutrefReturn(arr);

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 4;
        }
    `);

    ZERO(`
        fn Incr(ref x: i32) ++x;

        struct N { v: i32 };

        <alt>
        inline
        </alt>
        fn +=(ref a: N, b: i32) {
            a.v = a.v * 10 + b;
            return a;
        }

        fn main() {
            mut c: i32;
            mut a: N;
            (a = N(c.Incr)) += c.Incr;
            return a.v - 21;
        }
    `);

    ZERO(`
        struct Lifetime { regions: i32[] };

        let Region_STATIC = 0;

        fn Region_asLocal(r: i32) r > 1000 ? r - 1000 : 0;

        fn Lifetime_each !<S, A, L, E>(lt.regions,
            static: S = [], argidx: A = [],
            local:  L = [], else:   E = [])
        {
            for (mut i = 0; i < lt.len; i++)
            {
                let r = lt[i];

                :ELSE {                                         ;; Goto
                    if (r == Region_STATIC)
                        S -> [] ? { break :ELSE; }
                                : static(i?: i);
                    else if (let locid = Region_asLocal(r))
                        L -> [] ? { break :ELSE; }
                                : local(:locid, i?: i);
                    else
                        A -> [] ? { break :ELSE; }
                                : argidx(r, i?: i);

                    continue;
                }

                else(i?: i);
            }
        }

        fn isMovedFrom(locid: i32) locid & 1;

    <alt>
        fn main() {
    <alt/>
        fn main() = test();
        fn test() {
    </alt>
            mut lt = Lifetime([ 1001, <alt>1002<alt/>1</alt>, 1003 ]);
            mut locids = 0;
            mut force_mut = true;

            Lifetime_each(lt,
                local: |locid| {
                    if (!locid.isMovedFrom) {
                        force_mut = false;
                        break;
                    }

                    locids += locid;
                },
                else: || {
                    force_mut = false;
                    break;
                });

            return force_mut == false && locids == 1 ? 0 : 1;
        }
    `);

    TODO_inline(currently: "BUG reason not assignable string never 11:20+1", `
        struct Overload { name: string };
        struct Target { globid: i32 };

        fn solve(overloads: Overload[], target: Target, BUG)
        {
            using fn GET(t: Target)
                overloads[t.globid];

            fn BUG2(<alt>inline </alt>topic: string)
                BUG(topic);

            fn relaxBlockVar(t: Target)
                BUG2(t.name.BUG2);

            return target.relaxBlockVar();
        }

        fn main() {
            try
                solve([ Overload("hello") ], Target(0), fn throw);
            catch (e)
                return e == "hello" ? 0 : 1;

            return 2;
        }
    `);

    ZERO(`
        let SELF_TEST = <alt>true<alt/>false</alt>;

        inline fn LT_each(lt: i32[:], each)
            for (mut i = 0; i < lt.len; i++)
                each(lt[i]);

        lax fn assertPathsValid(lax lt: i32[:], lax minPathDepth)
            if (SELF_TEST)
                lt.LT_each: |value: i32|
                    if (value < minPathDepth)
                        throw("BAD: " ~ value);

        inline fn LT_op(lt: i32[], each, minPathDepth! = 1) {
            mut result: i32[];

            lt.LT_each: |value: i32| {
                let result0 = result.len;
                each(:result, :value);
                assertPathsValid(result[result0 :], :minPathDepth);
            }

            return result;
        }

        fn LT_double(lt: i32[])
            lt.LT_op(minPathDepth: 2): |value, ref result|  <alt>
                result ~= value * 2;                        <alt/>
              { result ~= value * 2; }                      </alt>

        fn main() = [ 1, 2, 3 ].LT_double == [ 2, 4, 6 ] ? 0 : 1;
    `);

    ZERO(`
        struct Target { _packed: u32 }
        inline fn globid(t: Target) i32(t._packed);

        fn solve(ref TRACE_out: string, a: Target, b: Target)
        {
            fn TRACE_BRACKET(inline msg: string) unwrap {
                mut len0: int;
                defer if (TRACE_out.len > len0) {
                    shadow let msg = msg;                       ;; GNUStmtExpr
                    TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");
                    TRACE_out ~= "</" ~ msg ~ ">";
                }
            }

            fn TRACE(msg: string) TRACE_out ~= msg;

            fn doTrySpecialize(mut target: Target, what) {
                mut mul = 10;
                TRACE_BRACKET("Hello " ~ (target.globid * mul++));
                what();
            }

            doTrySpecialize(a, || {});
            doTrySpecialize(b, || TRACE("World!"));
        }

        fn main() {
            mut TRACE_out = "";
            solve(:TRACE_out, Target(1), Target(2));
            return TRACE_out == "<Hello 20>World!</Hello 20>" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target { _packed: u32 }
        inline fn globid(t: Target) i32(t._packed);

        fn TRACE_BRACKET(implicit ref TRACE_out: string, inline msg: string) unwrap {
            mut len0: int;
            defer if (TRACE_out.len > len0) {
                // unlike the test above, we'll inline msg twice
                TRACE_out.splice(len0, 0, "<" ~ msg ~ ">");     ;; GNUStmtExpr
                TRACE_out ~= "</" ~ msg ~ ">";
            }
        }

        fn TRACE(implicit ref TRACE_out: string, msg: string) TRACE_out ~= msg;

        fn doTrySpecialize(mut target: Target, what) {
            mut mul = 10;
            TRACE_BRACKET("Hello " ~ (target.globid * mul++));
            what();
        }

        fn solve(a: Target, b: Target) {
            doTrySpecialize(a, || {});
            doTrySpecialize(b, || TRACE("World!"));
        }

        fn main() {
            implicit mut TRACE_out = "";
            solve(          <fail wrong number of arguments 29:18+1>
                :TRACE_out, <pass/></fail>
                Target(1), Target(2));
            return TRACE_out == "<Hello 20>World!</Hello 22>" ? 0 : 1;
        }
    `);

    ZERO(`
        fn incr_do_incr(ref count: i32, inline do) {
            count++;
            count += do;
            count++;
        }

        fn main() {
            mut count = 0;
            try         incr_do_incr(count, throw("what"));
            catch (e)   count += 10 * e.len;
            return count - 41;
        }
    `);

    TODO_inline(currently: "BUG ensureArgSeq host_args.len != args.len 24:45+1", `
        struct Struct { items: Target[] };
        struct Target { index: i32 };
        struct Scope { type: Type };
        struct Type { canon: i32 };

        noinline fn doNothingCreatively(_types: Struct[], _out: string, _type: Type)
        {
            using fn zeroInit(lax target: Target)
                return [];

            noinline fn noInline(type, ref out): string =
                return type && inlineOuter(type, :out);

            fn inlineOuter(inline type, ref out): string = {
                inlineInner(_types[type.canon], :out);
                return [];
            }

            fn inlineInner(inline s, ref out) {
                let fields = s.items;
                for (mut i = 0; i < fields.len; i++) {
                    let field = zeroInit(fields[i]);
                    lax let annot = noInline(field.type, :out);
                }
            }

            fn cgCopyOrMove(type: Type, ref out: string)
                inlineOuter(type, :out);

            return cgCopyOrMove(_type, _out);
        }

        fn main() {
            mut structs = [ Struct() ];
            mut out: string;
            doNothingCreatively(structs, out, []);
            return out.len;
        }
    `);

    // /Inliner.


    // Template types.

    ZERO(`
        fn sA(_: $T) struct { hey: $T; };

        fn fA(a: $T): sA($T) = [ a + 2 ];
        fn main() 1.fA.hey - 3;
    `);

    ZERO(`
        fn sB(_: $T) struct { hey: $T; };

        fn fB(a: $T): sB($T) = [ a + 2 ];
        fn main() 1.fB.hey - 1.u32.fB.hey <fail bad call><pass/> .i32 </fail> ;
    `);

    ZERO(`
        fn sB(_: $T) struct { hey: $T; };

        // Prep for the thing below.
        fn test(x) x.hey - 1;

        // 'a' must be callable.
        type a = sB(i32);
        fn main() a(1).test;
    `);

    ZERO(`
        fn setupOperators(i: i32) {
            struct BINOP { i: i32; };
            return BINOP(:i);
        }

        fn main() setupOperators(0).i;
    `);

    ZERO(`
        fn sB(_: $T) struct { hey: $T; };

        fn setupOperators(i: i32) {
            struct BINOP { i: sB(i32); };
            mut s: sB(i32) = [ i ];
            return BINOP(s);
        }

        fn main() setupOperators(0).i.hey;
    `);

    ZERO([`
        fn Hey = struct { i: i32 }; // fn Hey generated nonsense code
        fn get(s: Hey) s.i;
    `,`
        fn main() {
            mut s: _0::Hey;
            return s.get();
        }
    `]);

    ZERO([`
        fn Hey(_: $T) = struct { i: $T };
        fn get(s) s.i;
    `,`
        fn main() {
            mut s: _0::Hey(i32);
            return s.get(); // get(): wasn't visible, the struct didnt remember its template origin module.
        }
    `]);

    ZERO([`
        fn Hey(_: $T) = struct { v: $T };
    `,`
        fn unwrap(h: _0::Hey(i32)) = h.v * 10;
    `,`
        fn wrap(v: i32): _0::Hey(i32) = [ v + 3 ];
    `,`
        fn main() = _1::unwrap(_2::wrap(4)) - 70;
    `]);

    ZERO([`
        fn Hello(_: $T) struct { world: $T };
    `,`
        fn getHello(x: i32): _0::Hello(i32) = [ x * x ];
    `,`
        fn hello(x: i32) _1::getHello(x + 3);
    `,`
        fn main() _2::hello(2).world - 25;
    `]);

    ZERO(`
        fn sB(_: $T) struct { hey: $T; };

        // Pattern & partial spec, how?
        fn test(x: sB($T)): $T = x.hey - 1;

        type a = sB(i32);
        fn main() a(1).test;
    `);

    ZERO(`
        fn M(lax k: $K, lax v: $V) =
            struct { k: $K; v: $V };
        <split/>

        <alt>
        fn add(a: M($K, $V), b: M($K, $V)): M($K, $V) = <alt/>
        type Mu32 = M(u32, u32);
        fn add(a: Mu32, b: Mu32): Mu32 =                </alt>
            [ a.k + b.k, a.v + b.v ];

        fn incr_by(ref a: $T, b: $T) =
            a = add(a, b);

        fn K(_: $K) = M($K, u32);
        fn KK(k: $K, v: u32): K($K) = [ k, v ];
        <split/>
        fn V(_: $V) = M(u32, $V);
        fn VV(k: u32, v: $V): V($V) = [ k, v ];
        <split/>

        fn main() {
            mut a = KK(0x1, 2);
            mut b = VV(3, 0x4);

            a.incr_by(b);
            b.incr_by(a);
            return b.k * 100 + b.v == 710 ? 0 : 1;
        }
    `);

    ZERO(`
        fn Hey(_: $T) struct { hey: $T; };

        fn hello(x: i32) x * 10;
        fn hello(x: Hey(i32)) x.hey * 100;
        fn hello(x: Hey($T)) case ($T.is::unsigned) x.hey * 1000;

        fn main() hello(1)
                + hello([ 1 ]   => Hey(i32))
                + hello([ 0x1 ] => Hey(u32)).i32
                    - 1110;
    `);

    ZERO(`
        fn Hey(_: $T) struct { hey: $T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }
    `);

    ZERO(`
        fn Hey(type T) struct { hey: T };

        fn main() {
            using let _ = Hey(i32[]);
            return hey.len;
        }
    `);

    ZERO(`
        fn Hey !T(<alt>lax _: T<alt/>type T</alt>)
            case (T.is::arithmetic) = struct { hello: T };
            default                 = struct { world: T };

        fn main() {
            using let _a = Hey(i32);
            using let _b = Hey(i32[]);
            return hello + world.len;
        }
    `);

    ZERO(`
        fn new(type T): T = [];
        fn main() =
            <fail arg T expects a type, got a value 2:12+3>
            new(0)   <pass/>
            new(i32) </fail>;
    `);

    ZERO(`
        type A = struct { x: i32 };
        type B = struct { y: i32 };
        fn main() {
            mut a: A;
            mut b: B;
            return a.x + b.y;
        }
    `);

    ZERO(`
        fn Hey(type T) {
            <alt>
            struct A { a: T };
            struct B { b: T };
            <alt/>
            type A = struct { a: T };
            type B = struct { b: T };
            </alt>
            return struct { a: A; b: B };
        }

        <alt>
        fn fill(s, ref v: i32)
            for (fieldname i: typeof(s))
                if (typeof(s.i) -> i32)     s.i = v++;
                else                        fill(s.i, v);
        <alt/>
        fn fill(ref s, ref v: i32) {
            if (typeof(s) -> Hey(_)) {
                fill(s.a, v);
                fill(s.b, v);
            }
            else for (fieldname i: typeof(s)) {
                s.i = v++;
            }
        }
        <alt/>
        fn fill(ref s, ref v: i32)
        case (typeof(s) -> Hey(_)) {
            fill(s.a, v);
            fill(s.b, v);
        }
        default {
            for (fieldname i: typeof(s))
                s.i = v++;
        }
        </alt>

        fn main() {
            mut ab = Hey(i32);
            mut v = 11;
            fill(ab, v);
            return ab.a.a + ab.b.b - 23;
        }
    `);

    ZERO(`
        <fail not a type 4:23+1>
        let  X = i32; <pass/>
        type X = i32; </fail>
        struct Y { x: X };

        fn main() {
            mut y = Y(1 + 2);
            return y.x - 3;
        }
    `);

    ZERO(`
        struct Hello { a: i32; b: i32 };

        fn Wrap(type T) = struct { using v: T };
        fn incr_a1_b2 !T(using w: Wrap(T)) =
            T(:a + 1, :b + 2);

        fn main() {
            mut zeroes: Wrap(Hello);
            let ones = incr_a1_b2(zeroes);
            return ones.a * 10 + ones.b * 100 - 210;
        }
    `);

    ZERO(`
        fn typeArgRename(type Outer!Inner)
            case (Inner.is::primitive)
                = Inner;

        fn main() {
            mut x: typeArgRename(
                <fail explicitly named 7:33+1><pass/>Outer: </fail>
                    i32);

            return x;
        }
    `);

    // /Template types


    // Macros & loops.

    ZERO(`
        fn test(x: i32) {
            :OUTER {
                :INNER {
                    if (x > 1) break :OUTER;                    ;; Goto
                    if (x > 0) break :INNER;
                    return 2;
                }
                return 1;
            }
            return 0;
        }

        fn main() 2.test * 11 + (1.test - 1) * 13 + (0.test - 2) * 17;
    `);

    ZERO(`
        fn test(x: i32) {
            return {
                :BLOCK {
                    if (x & 1) break :BLOCK 1;
                    if (x & 2) return 2;
                    3
                }
            };
        }

        fn main() 4.test - 5.test - 6.test; // 3-1-2
    `);

    ZERO(`
        fn brkif(mut x: i32)
        {
            :WOOT
            if (x & 1) {
                if (x & 2) x++;
                if (x & 4) break :WOOT;                         ;; Goto
                x *= x;
            }

            return x;
        }

        fn main()
            brkif(1) + brkif(3) * 10 + brkif(5) * 100 + brkif(9) * 1000
                == 81541 ? 0 : 1;
    `);

    ZERO(`
        fn test(a: i32) {
            mut w = 3;
            :OUTER w += {                                       ;; GNUStmtExpr
                :INNER {
                    if (a & 1)  break :INNER;
                    else        break :OUTER;                   ;; Goto
                };
                5
            };
            return w;
        }
        fn main() 0.test + 1.test - 11;
    `);

    ZERO(`
        fn ifbrk(a: i32) {
            mut x = 0;
            if (a & 3) {
                x += a;

                :IF_LABEL
                if (a & 1) {
                    mut incr    = a & 4 ? a * 2
                                : a & 2 ? { break :IF_LABEL; }  ;; Goto
                                        : a;                    ;; GNUStmtExpr
                    x += incr;
                }
            }

            return x;
        }

        fn main() 1.ifbrk + 3.ifbrk * 10 + 5.ifbrk * 100 - 1532;
    `);

    ZERO(`
        fn test(x: i32) {
            return {
                :BLOCK 2 * {
                    if (x) break :BLOCK 3;                      ;; GNUStmtExpr
                    1
                }
            };
        }

        fn main() = test(0) == 2 && test(1) == 3 ? 0 : 1;
    `);

    ZERO(`
        fn v(x: i32) {                                          ;; GNUStmtExpr
            return {
                :BLOCK                          5000 + { // *2:
                    if (x == 9) continue :BLOCK 2000;    //   - here
                    if (x == 8) return           300;
                    if (x == 7) break :BLOCK      40;

                    5                                    //   - and here!
                }
            }  // -----------------------------------
        }
        fn main() 9.v + 8.v + 7.v + 6.v      - 12345;
    `);

    ZERO(`
        pub fn test(x: i32[], y: i32[]) {
            let z = {
                :BLOCK {
                    mut w: i32[] = x;
                    if (y[0]) w ~= y;
                    if (w[0] != 17)
                        break :BLOCK w;
                    x
                }
            };

            return z[0] + z[z.len - 1];
        }

        fn main() test([ 1 ], [ 2 ]) - 3;
    `);

    ZERO(`
        fn test(mut x: i32) {
            {
                x++;
                :CANT_FLATTEN { // naive block flattening
                                //  can damage this label
                    if (x & 1) break :CANT_FLATTEN;
                    return x;
                }
            }
            return x * 2;
        }

        fn main() test(1) + test(2) - 8;
    `);

    ZERO(`
        fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn Some(arr, fn) {
            arr.Each: |x| if (fn(x)) return x;
            return 0;
        }

        fn main() [ 1, 2, 3 ].Some(|v| v & 1 == 0) - 2;

        ;; EXPECT (fu::slate<3, int> { 1, 2, 3 })
    `);

    ZERO(`
        fn outer() {
            mut sum = 0;

            inline fn inner(v: i32) {                           ;; GNUStmtExpr
                for (mut i = 0; i < 10; i++) {
                    sum += v;
                    if (sum > 40)
                        return :outer sum;
                }

                return v * 2;
            }

            mut x = 1;
            for (;;) x = inner(x);
        }

        fn main() outer - 42; // extra points for style
    `);

    ZERO(`
        inline fn Each(arr, fn)
            for (mut i = 0; i < arr.len; i++)
                fn(arr[i]);

        fn main() {
            mut sum = 0;
            :OUTER [1, 2, 3, 4].Each(|x| {
                sum += x;
                for (mut i = 1; i--; ) // once
                    if (sum == 6) break :OUTER;                 ;; Goto
            });
            return sum - 6;
        }

        ;; !N_NonTrivAutoCopy
    `);

    ZERO(`
        inline fn hello(ref sum) {  //     when inlined into woot
            if (sum > 2) return;    //      the hello block now looks like an expr
            sum += 2;               // <-    with a diverging tail return here
        }

        fn woot(ref sum) hello(sum);

        fn main() {
            mut sum = -2;
            sum.woot();
            return sum;
        }
    `);

    ZERO(`
        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) break; });
            return x - 1;
        }
    `);

    ZERO(`
        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn main() {
            mut x = 0;
            loop1d(0, 10, |i| { if (x += i) return x - 1; });
            return 101;
        }
    `);

    ZERO(`
        fn loop2d(x0, x1, y0, y1, fn) {
            for (mut y = y0; y < y1; y++)
            for (mut x = x0; x < x1; x++) fn(x, y);
        }

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }
    `);

    ZERO(`
        fn loop1d(i0, i1, fn)
            for (mut i = i0; i < i1; i++)
                fn(i);

        fn loop2d(x0, x1, y0, y1, fn)
            loop1d(y0, y1, |y|
                loop1d(x0, x1, |x|
                    fn (x, y)));

        fn main() {
            mut sum = 0;
            loop2d( x0:  0, x1: 10,
                    y0: 10, y1: 12, |x, y|
            {
                if (y < 11) {
                    sum++;          // for (x: 0, 10) so 10 times
                    continue;       // <- inner loop
                }

                if (x == 1) break;  // <- outer loop
                sum += (x + 1) * y; // once: (0+1)*(y=11)
            });

            return sum - 21;
        }
    `);

    ZERO(`
        fn next(implicit ref sum: i32, lifetime: [i32], locals_start: i32) {
            sum += lifetime.len;
            return lifetime[locals_start : lifetime.len];
        }

        fn Lifetime_each(lifetime: [i32], visit) {
            for (mut i = 0; i < lifetime.len; i++)
                visit(lifetime[i : lifetime.len]);
        }

        fn Lifetime_F_TODO_FIX_RRET(lifetime: [i32], locals_start: i32) {
            Lifetime_each(:lifetime, visit: |l| {
                if (l)
                    Lifetime_F_TODO_FIX_RRET(l.next(locals_start), locals_start);
            });
        }

        fn main() {
            let lifetime = [ 1, 2 ];
            implicit mut sum = 0;
            Lifetime_F_TODO_FIX_RRET(lifetime, locals_start: 1);
            return sum - 4;
        }
    `);

    ZERO(`
        fn test(x: i32, ref odds: i32) {
            return x & 1 ? { odds++; x } : x + 1;
        }

        fn main() {
            let nums = [ 1, 2, 3 ];
            mut odds = 0;
            mut sum  = 0;
            for (mut i = 0; i < nums.len; i++)
                sum += test(nums[i], :odds);

            return odds != 2 ? 100
                 : sum  != 7 ? 200
                 : 0;
        }
    `);

    ZERO(`
        fn test(ref x: i32) {
            return {
                :BLOCK {
                    if (x & 1)  break :BLOCK x++;
                    else        break :BLOCK x * 2;
                }
            };
        }

        fn main() {
            mut x = 1;
            return test(x) == 1 && test(x) == 4 ? 0 : 1;
        }
    `);

    ZERO(`
        fn PASS_borrowCheck(ref x: i32[]) {
            fn bck_node(add: i32) {
                for (mut i = 0; i < x.len; i++) {
                    x[i] *= x[i];
                    x[i] += add;
                }
            }

            bck_node(1);

            :SOLVE_AAR {
                if (x.len & 2)
                    bck_node(2);

                if (x.len & 1)
                    break :SOLVE_AAR;

                bck_node(3);
            }
        }

        fn main() {
            mut a = [ 1, 2, 3 ];
            mut b = [ 1, 2 ];
            PASS_borrowCheck(a);
            PASS_borrowCheck(b);
            return a[2] == 102 && b[1] == 732 ? 0 : 1;
        }
    `);

    ZERO(`
        fn rev(arr, fn) {
            for (mut i = arr.len; i --> 0; ) {
                if (!arr[i])
                    break;
                <alt>
                else
                    fn(arr[i], i?: i);
                <alt/>
                fn(arr[i], i?: i);
                </alt>
            }
        }

        fn test(arr) {
            mut sum = 0;
            arr.rev: |x| {
                if (x & 1) continue;
                sum += x;
            }
            return sum;
        }

        fn main() {
            return test([2, 4, 6, 8]) == 20
                && test([2, 4, 7, 8]) == 14
                && test([2, 4, 0, 8]) ==  8 ? 0 : 1;
        }
    `);

    ZERO(`
        fn main() {
            fn exit(code: i32) { return :main code; }
            fn exitViaArgdef(what: i32 = exit(0)) = what;
            exitViaArgdef();
        }
    `);

    ZERO(`
        fn main() {
            fn exit(code: i32) { return :main code; }
            fn exitViaArgdef(a: i32 = exit(0), b?) = a + b;
            exitViaArgdef()
        }
    `);

    ZERO_SAME([
    `
        fn test(x: i32)
        {
            fn mayExitTest() {
                return x & 1 ? { return :test x * x; }          ;; GNUStmtExpr
                             : x * 2;
            }

            fn mayExitTestFromDefarg(y: i32 = mayExitTest) {
                return y * x;
            }

            return x & 2 ? mayExitTestFromDefarg()
                         : mayExitTestFromDefarg(x * 2);
        }

        fn main() {
            return test(3) == 9 && test(4) == 32 ? 0 : 1;
        }
    `,
    `
        fn test(x: i32)
        {
            fn mayExitTest()
                x & 1   ? { return :test x * x; }
                        : x * 2;

            fn mayExitTestFromDefarg(y: i32 = mayExitTest)
                y * x;

            return x & 2 ? mayExitTestFromDefarg()
                         : mayExitTestFromDefarg(x * 2);
        }

        fn main()
            test(3) == 9 && test(4) == 32 ? 0 : 1;
    `]);

    ZERO(`
        <alt>
        inline                                                  ;; Goto
        </alt>
        fn test(mut x: i32) {
            fn loopInsideInlineArg(inline theLoop = {
                while (x) {
                    if (x & 1)  return x;
                    if (x & 2)  break;
                    if (x & 8)  return :test x * 100;
                    x /= 2;
                }
            }) {
                theLoop();
                return x * 10;
            }

            return loopInsideInlineArg() * 3;                   ;; GNUStmtExpr
        }

        fn main() {
            let a = test(5);
            let b = test(4);
            let c = test(16);
            return a == 5 && b == 60 && c == 800 ? 0 : 1;
        }
    `);

    ZERO(`
        fn UnusedArgError(arr: i32[], fn)
            for (mut i = 0; i < arr.len; i++)
                fn(hello: arr[i], i?: i);

        fn main() {
            mut sum = 0;
            let arr = [ 1, 2, -3 ];
            arr.UnusedArgError: |lax i, hello|
                <fail unused arg hello 9:41+5>
                sum += arr[i];         <pass/>
                sum += hello;          </fail>

            return sum;
        }
    `);

    TODO_control(currently: "no label in scope 4:13+5", `
        fn test() {
            <fail nothing to break>
            break;   <pass/></fail>
            return 0;
        }
        fn main() = test();
    `);

    TODO_control(currently: "does not match annotation i32 void 11:25+1", `
        fn test() {
            let hello = || {
                <fail nothing to break>
                break;   <pass/></fail>
                return 0;
            };

            return hello;
        }
        fn main() = test();
    `);

    ZERO(`
        fn each(ref arr: i32[], even, odd)
            for (mut i = 0; i < arr.len; i++)
                if (!i) odd(i?: i, it?: arr[i]);
                else   even(i?: i, it?: arr[i]);

        fn main() {
            mut arr = [ 1, 2, 3 ];
            arr.each(odd: |it| it++, even: || { break; });

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++) sum += arr[i];
            return sum - 7;
        }
    `);

    // /Macros & loops.


    // Relaxer.

    ZERO(`
        fn hello(a) a * a;          ;; EXPECT (const int a)
        fn main() {
            mut a = 3;
            let b = hello(a);
            return b - 9;
        }
    `);

    ZERO(`
        struct AB { a: i32; b: i32; };
        fn sqr   (ref x: i32) x * x;
        fn outer (ref ab: AB) sqr(ab.a) + sqr(ab.b);        ;; EXPECT const s_AB&
        fn main() {
            mut ab = AB(3, 5);
            return ab.outer - 34;
        }
    `);

    ZERO(`
        fn ascii_lower(a: string): string
        {
            let offset = 'a'.i32 - 'A'.i32;

            mut res = a;
            for (mut i = 0; i < res.len; i++)
            {
                let c = res[i];
                if (c >= 'A' && c <= 'Z')
                    res[i] = byte(c.i32 + offset);
            }

            return res;
        }

        <split/>

        fn main() "WORLD!".ascii_lower[2].i32 - 'r'.i32;
    `);

    ZERO(`
        fn main() {
            mut a = [[ 7 ]];
            return a[0][0] - 7;        ;; EXPECT a[0][0]
        }
    `);

    ZERO(`
        lax fn doNothing(pointlessArg: i32) {
            if (pointlessArg == 1)
                return;
        }

        fn main() {
            doNothing(1);
            return 0;
        }
    `);

    ZERO(`
        struct Target   { index: i32 };
        struct Overload { uni0n: i32[] };

        fn solve(all: Overload[], check: Target) {
            fn GET(t: Target) {
                if (t.index < 1 || t.index > all.len) throw("nope");
                return all[t.index - 1];
            }

            fn propagateType(t: Target) {
                if (t.GET.uni0n.has(t.index)) {}
                return t.index;
            }

            return propagateType(check);
        }

        fn main() solve([ Overload([ 1, 2, 3 ])], Target(1)) - 1;
    `);

    ZERO(`
        struct Overload     { args: Argument[]; };
        struct SolvedNode   { x: i32; };
        struct Argument     { default: SolvedNode; };

        pub fn test(overload: Overload, ref args: SolvedNode[])
        {
            let host_args = overload.args;          ;; EXPECT fu::view<s_Argument> /*overload*/ host_args

            args.resize(host_args.len);             // .len didnt relax its arg
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default;
                }
            }
        }

        fn main() {
            mut o: Overload;
            for (mut i = 0; i < 3; i++)
                o.args ~= Argument(default: SolvedNode(x: i));

            mut args: SolvedNode[];
            test(o, args);
            return args.len - args[args.len - 1].x - 1;
        }
    `);

    TODO_borrowck(currently: "Both alias mc 10:51+2", `
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_001(ref m!: S, c!: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn test(ref mc: S) {
            return m_and_c_cant_alias_001(m:mc, c:mc);  // Can't return a ref into c!
        }                                               //  But can be made to work by creating an intermediate copyvar
                                                        //   and move-returning from there.
        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
            let hey = test(mc);
            return hey.len - 10;
        }
    `);

    ZERO(`
        // !!!! The m_and_c_cant_alias_001 test obsoletes this,
        // !!!!  this is just detects what we definitely don't want to see -
        // !!!!   returning a reference into a temporary copy.
        //
        struct S { hey: i32[]; };

        fn m_and_c_cant_alias_002(ref m: S, c: S) {
            m.hey.clear();
            return c.hey; // noalias
        }

        fn main() {
            mut mc  = S([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]);
            <fail alias>
            let hey = m_and_c_cant_alias_002(mc, mc);
            <pass/>
            mut bc  = mc;
            let hey = m_and_c_cant_alias_002(mc, bc);
            </fail>
            return hey.len - 10;
        }
    `);

    ZERO(`
        fn grow_if_oob(a: &mut $T[], i: i32): &mut $T {
            if (a.len <= i)
                a.grow(i + 1);

            return a[i];
        }

        struct BitSet { _data: u8[]; }

        fn add_once(using _: &mut BitSet, idx: i32): bool {
            let no_neg = idx < 0 ? -1 : 0;
            let bucket = idx / 8 | no_neg;
            let bit    = idx % 8;
            let mask   = 1 << bit.u8;

            ref entry = _data.grow_if_oob(bucket);
            if !(entry & mask) {
                entry |= mask;
                return true;
            }

            // Already there.
            return false;
        }

        type BitSet2D = BitSet[];

        fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool {
            return bs
                .grow_if_oob(i)
                .add_once(j);                                   ;; !*MustSeq
        }

        fn main() {
            mut bs: BitSet2D;
            bs.add_once(9, 9);
            return bs.len + 1000 * bs[9]._data.len - 2010;
        }
    `);

    ZERO(`
        fn test(mut _precedence = 0)
        {
            fn parseExpression(p1?: i32): i32 {
                if !(_precedence = p1)
                    return parseExpressionHead();

                return _precedence;
            }

            fn parseExpressionHead()
                parseExpression(_precedence * 101 + 1);

            return parseExpression();
        }

        fn main() = test() - 1;
    `);

    ZERO(`
        struct Overload {
            is_var?: bool;
            lifetime?: i32[];
        }

        fn GET(implicit overloads: Overload[], idx: i32) {
            return overloads[idx];
        }

        // Uncommenting the inline passes this,
        //  this is shit, we can't leave this like this.
        //
        // inline
        fn Lifetime_each(mut lifetime: i32[], visit) {
            for (mut i = 0; i < lifetime.len; i++) {
                let r = lifetime[i];
                let o = GET(r);
                visit(:o, i?: i, lifetime?: lifetime);
            }
        }

        fn Lifetime_ascend(mut lifetime: i32[], visit) {
            Lifetime_each(:lifetime, visit: |o, shadow lifetime| {
                visit(o);
                lifetime ~= o.lifetime; // set::add
            });
        }

        fn Lifetime_allowsMutrefReturn(lifetime: i32[]): bool {
            Lifetime_ascend(:lifetime, visit: |o| {
                if (o.is_var)
                    return false; // ERR: propagateType(jump): h.ret_actual not available.
            });

            return true;
        }

        fn main() {
            let implicit overloads = [
                Overload,
                Overload(lifetime: [ 0 ]),
                Overload(lifetime: [ 1 ], is_var: true),
                Overload(lifetime: [ 1 ]),
                Overload(lifetime: [ 2 ]), /* the isvar */
                Overload(lifetime: [ 3 ]), /* the non-isvar */
            ];

            let expect_false = Lifetime_allowsMutrefReturn([ 4 ]);
            let expect_true  = Lifetime_allowsMutrefReturn([ 5 ]);

            if (expect_false) return 20;
            if (!expect_true) return 10;
            return 0;
        }
    `);

    TODO_slices(currently: "bad call to last 12:63+4 not an array", `
        struct Overload { items: string[]; };

        // This is a bit borderline -
        //  the problem here is that a: $T[] doesn't relax to a: [$T] (not during prep) -
        //   so we don't match at all. Still, that's what's written -
        //    perhaps regular fns are what doesn't behave correctly,
        //     since their relax can create ambiguity?
        //
        fn last(a: $T[])                    a[a.len - 1];
        fn arg_lets(overload: Overload)     overload.items[0 : overload.items.len - 2];
        fn test(overload: Overload)         overload.arg_lets.last.len;
        fn main()                           Overload([ "hello", "cruel", "world!" ]).test - 5;
    `);

    ZERO(`
        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        using inline fn GET(h: Helpers, implicit ref _helpers_data: HelpersData[]): HelpersData
            _helpers_data[h.index];
                                                            //////////////////
        fn isFnOrType(h: Helpers): bool                     ;; EXPECT fu::view
            !!(h.mask & (HM_Function | HM_Struct));         //////////////////

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];
            return Helpers(0).isFnOrType.i32;
        }
    `);

    ZERO(`
        struct Helpers      { index: i32; };
        struct HelpersData  { mask!: i16; };

        let HM_Function     = 1.i16 << 3;
        let HM_Struct       = 1.i16 << 5;

        fn main() {
            implicit mut _helpers_data = [ HelpersData(mask: 0) ];

            using inline fn GET(h: Helpers): HelpersData
                _helpers_data[h.index];
                                                            //////////////////
            fn isFnOrType(h: Helpers): bool                 ;; EXPECT fu::view
                !!(h.mask & (HM_Function | HM_Struct));     //////////////////

            return Helpers(0).isFnOrType.i32;
        }
    `);

    ZERO([`
        pub fn ref(dest, item: $T, extras) {
            for (mut i = 0; i < dest.len; i++) {
                if (dest[i] >= item) {
                    if (dest[i] != item) {
                        dest.insert(i, item);
                        extras.insert(i, []);
                    }
                    return extras[i];
                }
            }

            dest.push(item);
            extras.push([]);
            return extras[extras.len - 1];
        }
    `,
    `
        fn Map(lax k: $K, lax v: $V) struct {
            keys: $K[];
            vals: $V[];
        };

        fn ref(using ref _, key)
            _0::ref(
                || keys, key,
                || vals);
    `,
    `
        fn main() {
            mut _map: _1::Map(string, string);

            fn upsert(k: string, v: string) _map._1::ref(k) = v;
            upsert("hello", "world");

            // Relaxer failed here while I was trying to get rid of F_REFs from specTypes.
            fn check(k: string) _map._1::ref(k) == "world" ? 0 : 1;
            return check("hello");
        }
    `]);

    ZERO(`
        fn useless_ref_lambda(ref sources: string[]) {
            fn src = sources[sources.len / 2]; // didn't relax the ref, failed bck
            return src[1 : src.len] ~ src[0 : 1];
        }
        fn main() {
            mut sources = [ "ab" ];
            return useless_ref_lambda(sources) == "ba" ? 0 : 1;
        }
    `);

    ZERO(`
        struct Node { items: Node[] };

        pure fn rec_useless_ref_simple(ref n: Node, offset: i32)
            offset < n.items.len
                ? rec_useless_ref_simple(:n, offset + 1)
                : offset;

        fn main() {
            mut n = Node([ Node(), Node() ]);
            return rec_useless_ref_simple(:n, 0) - 2;
        }
    `);

    ZERO(`
        struct Node { items: Node[]; };

        pure fn rec_useless_ref(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += rec_useless_ref(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node(), Node() ]);
            return rec_useless_ref(tree) - 2;
        }
    `);

    ZERO(`
        struct Node { items: Node[]; };

        fn mrec_useless_ref_A(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ?      mrec_useless_ref_A(n.items[i])
                    : 50 * mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        pure fn mrec_useless_ref_B(ref n: Node) {
            mut ret = n.items.len;
            for (mut i = 0; i < n.items.len; i++)
                ret += i & 1
                    ? 10 * mrec_useless_ref_A(n.items[i])
                    :      mrec_useless_ref_B(n.items[i]);

            return ret;
        }

        fn main() {
            mut tree = Node([ Node([ Node, Node ]), Node([ Node ]) ]);
            return mrec_useless_ref_A(tree) - 103;
        }
    `);

    ZERO(`
        fn last(s: $T[])
            s.len ? s[s.len - 1] : throw("len == 0");

        struct Node { kind: string; items: Node[] }

        pure fn check(ref node: Node)
            node.kind != "block" ||
            node.items.last.kind == "return";

        fn main() {
            mut node: Node;
            return node.check ? 0 : 1;
        }
    `);

    ZERO(`
        fn relaxes_arr_to_slice_and_fails(ref arr) {
            arr.pop();
            return arr;
        }

        fn main() {
            mut arr = [ 1 ];
            relaxes_arr_to_slice_and_fails(arr);
            return arr.len;
        }
    `);

    ZERO(`
        type Context = string[];

        fn compile_snippets(sources: string[], fnames?: string[]): Context {
            return sources ~ fnames;
        }

        fn ZERO(implicit ref output: string, mut sources: string[]): Context {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                let idx = src.find('X');
                if (idx >= 0) {
                    let moduleA = src.slice(0, idx);
                    let moduleB = src[idx : idx] ~ src[idx + 1 : src.len];
                    let without = src[0 : idx] ~ src[idx + 1 : src.len];

                    sources[i]  = without;
                    ZERO(:sources);

                    sources[i]  = moduleA;
                    sources.insert(i + 1, moduleB);
                    i--;
                }
            }

            let ctx = compile_snippets(:sources);
            output ~= sources.join(',') ~ ";";
            return ctx;
        }

        fn ZERO(src: string) ZERO(sources: [ src ]);

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "abc;ab,c;a,bc;a,b,c;" ? 0 : 1;
        }
    `);

    ZERO(`
        fn ZERO(mut sources: string[], implicit ref output: string) {
            for (mut i = 0; i < sources.len; i++) {
                ref src = sources[i];
                mut idx = 0;
                while ((idx = src.find("X")) > 0) {
                    let sources1 = sources[0 : i]
                        ~ src.slice(0, idx)
                        ~ src.slice(idx + 1, src.len)
                        ~ sources[i + 1 : sources.len];

                    ZERO(sources1);
                    src = src[0 : idx] ~ src[idx + 1 : src.len];
                }
            }

            output ~= sources.join(",") ~ ";";
        }

        fn ZERO(src: string) {
            return ZERO([ src ]);
        }

        fn main() {
            implicit mut output: string;
            ZERO("aXbXc");
            return output == "a,b,c;a,bc;ab,c;abc;" ? 0 : 1;
        }
    `);

    ZERO(`
        fn test(str: [byte]) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }
    `);

    TODO_slices(currently: "BUG incorrect exit code", `
        fn test(str: string) {
            mut res = 1;
            str.split('/'): |piece| res *= piece.len;
            return res;
        }

        fn main() {
            let res = test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            if (mem::ALLOC_STAT_COUNT() != 0) return 101;
            return res == 196608 ? 0 : 1;
        }
    `);

    ZERO(`
        novec fn doesnt_copy_arg(arg: string, suffix: byte) <alt>
            arg     && arg ~ suffix;                        <alt/>
            arg      ? arg ~ suffix : "";                   <alt/>
            arg.len && arg ~ suffix;                        <alt/>
            arg.len  ? arg ~ suffix : "";                   <alt/>
            !!arg   && arg ~ suffix;                        <alt/>
            !!arg    ? arg ~ suffix : "";                   </alt>

        fn main() {
            mut share = "01234567abcdefghABCDEFGH01234567abcdefghABCDEFGH";
            mut a = doesnt_copy_arg(share, '!');
            mut b = doesnt_copy_arg(share, '?');
            mut c = doesnt_copy_arg("", '.');
            return a.len == b.len && a.len == 49 && c.len == 0 ? 0 : 1;
        }
    `);

    ZERO(`
        fn loop(cond, body)         <alt>
            while (cond) body();    <alt/>
            do body();
            while (cond);           </alt>

        novec fn doesnt_copy_arg(ref nums: i32[]) {
            loop(nums): || {
                mut sum = 0;
                for (mut i = 0; i < nums.len; i++)
                    sum += nums[i]++;
                if (sum >= 10)
                    return sum;
            }
            return 0;
        }

        fn main() {
            mut nums: i32[];
            mut a = doesnt_copy_arg(nums);
            nums ~= 1;
            mut b = doesnt_copy_arg(nums);
            nums ~= 2;
            mut c = doesnt_copy_arg(nums);
            return a == 0 && b == 10 && c == 13 ? 0 : 1;
        }
    `);

    ZERO(`
        fn grow_if_oob !T(ref a: T[], i: i32) {
            if (a.len <= i) a.grow(i + 1);
            return a[i];
        }

        struct Target { modid: i32; index: i32 }
        struct Scope { overloads: Overload[]; extended: Extended[] };
        struct Overload { modid: i32 };
        struct Extended { min: i32; locals: Overload[] };

        fn create(ref scope: Scope, modid: i32): Target {
            ref overloads = modid
                ? scope.extended.grow_if_oob(modid).locals
                : scope.overloads;

            let target = Target(:modid, index: overloads.len + 1);
            overloads.push(Overload(:modid));
            return target;
        }

        fn main() {
            mut scope: Scope;
            scope.create(0);
            scope.create(1);
            return scope.overloads.len == 1
                && scope.extended .len == 2 ? 0 : 1;
        }
    `);

    ZERO(`
        using flags TPFlags { ArgSpec; Typename; NeedsConsumed };

        struct TP { flags: TPFlags };

        fn doTrySpec(ref typeParams: TP[]) {
            fn useConsumedType(tp<alt>: TP</alt>)
                tp.flags & (ArgSpec | Typename) == ArgSpec;

            typeParams.each: |ref tp|
                if (tp.useConsumedType)
                    tp.flags |= NeedsConsumed;
        }

        fn main() {
            mut typeParams: TP[] = [
                [ ArgSpec ],
                [ ArgSpec | Typename ],
                [ Typename ],
            ];

            doTrySpec(typeParams);

            mut count = 0;
            typeParams.each: |tp|
                if (tp.flags & NeedsConsumed)
                    count++;

            return count - 1;
        }
    `);

    TODO_zst(currently: "BUG invalid c++ void[] 5:17+1", `
        struct Empty {};

        fn main() {
            mut e = [ Empty(), Empty() ];
            fn GET(idx: i32) e.len > idx && e[idx];
            return GET(0) == GET(1) ? 0 : 1;
        }
    `);

    TODO_zst(currently: "BUG invalid c++ void[] 19:17+2", `
        struct Module { modid: i32 };
        struct Ephemeral { <alt>broke_when_zst?: i32</alt> };
        struct SolverState { _ephemeral: Ephemeral[] };
        struct Target { modid: i32; globid: i32 };

        fn test(implicit ref module: Module, using ref ss: SolverState, target: Target): Ephemeral {
    <alt>
            fn EPH(shadow target: Target)
                return target.modid == module.modid
                    && _ephemeral[target.globid];

            return EPH(target);
    <alt/>
            using fn EPH(shadow target: Target)
                return target.modid == module.modid
                    && _ephemeral[target.globid];

            return target;
    </alt>
        }

        fn main() {
            implicit mut module = Module(1);
            mut ss = SolverState([ Ephemeral(), Ephemeral(), Ephemeral() ]);
            return test(ss, Target(modid: 1, globid: 2)) == [] ? 0 : 1;
        }
    `);

    ZERO(`
        fn Map(type K, type V) struct {
            keys: K[];
            vals: V[];
        };

        fn ref !<K, V>(using ref _: Map(K, V), key: K) {
            for (mut i = 0; i < keys.len; i++)
                if (keys[i] == key)
                    return vals[i];

            keys.push(key);
            vals.push([]);
            return vals[vals.len - 1];
        }

        struct Type { using vtype: i32 };

        fn find_if_odd(ref map: Map(i32, Type), key: i32)
            key & 1
                ? map.ref(key)
                : key & 2 && throw("never");

        fn main() {
            mut map: Map(i32, Type);
            map.keys ~= 1;
            map.vals ~= Type(2);
            return find_if_odd(map, 1) - 2;
        }
    `);

    ZERO(`
        lax                         <alt>
        inline      ;; PointlessLocal   <alt/>
        noinline    ;; ConstCast        </alt>
        fn longer(                  <alt>
            l: string, r: string,       <alt/>
            l: $T[:], r: $T[:],         </alt>
            pick!)
        {
            let longer = {                                      ;; GNUStmtExpr
                :PICK {
                    for (;;) {
                        if (l.len > r.len)
                            break :PICK l;                      ;; Goto

                        break :PICK r;
                    }
                }
            };

            return pick(longer);
        }

        fn main() {
            longer("does", "nothing",
                pick: |_| { break; });

            let longer = longer("Hello", " World!",
                pick: |longer| { break longer; });

            return longer.len - 7;
        }
    `);

    ZERO(`
        noinline fn longer(             <fail cannot move from a slice 15:26+1>
            l: byte[:], r: byte[:])     <pass/>
            l: $T[:],   r: $T[:])       </fail>
        {
            return l.len > r.len ? l : r;
        }

        <split/>
        noinline fn strsqr(mut str: string, n: i32) {
            for (mut i = 1; i < n; i++) str ~= str;
            return str;
        }

        noinline fn mightConstCast() {
            return longer(
                "A---A".strsqr(4),
                "B-BB-B".strsqr(4));                            ;; ConstCast
        }

        fn main() {
            let longer = mightConstCast();
            shadow let longer = longer ~ longer;
            return longer.split("BB").len == 32 ? 0 : 1;
        }
    `);

    ZERO(`
        struct Target   { index: i32 }
        struct Lifetime { uni0n!: byte[] };
        type Type = Lifetime;

        fn is_ref(type: Type) = !!type;

        fn Lifetime_process(lifetime: Lifetime, each) {
            fn visit(shadow lifetime) {
                do {
                    fn continue_climb(mut parent: Lifetime) {
                        visit(parent);
                        continue;
                    }

                    each(lifetime, fn continue_climb);
                }
                while (false);
            }

            return visit(lifetime);
        }

        fn main() {
            fn Lifetime_climbType(lax lifetime: Lifetime) return [];

            mut count = 0;
            Lifetime_process([], each: |lifetime, continue_climb| {
                count++;

                let init = lifetime.Lifetime_climbType;
                if (init.is_ref)
                    continue_climb(init);
            });

            return count - 1;
        }
    `);

    ZERO(`
        using flags Flags { A; B }

        fn parseExoticDecl(shadow mut flags: Flags) {
            if (flags) {
                fn add(flag) flags |= flag;
                return add(B);
            }

            return flags;
        }

        fn main() = parseExoticDecl(A).i32 - 3;
    `);

    ZERO(`
        struct Node { items: string };

        pub fn solve(using ref _current_fn: Node, root) {
            fn solveNode(node) {
                if (_current_fn) {
                    fn outItems(back) items[items.len - back];
                    _current_fn.items ~= "! ";
                    return outItems(2);
                }

                _current_fn.items ~= node.items;
                return [];
            }

            return solveNode(root);
        }

        fn main() {
            mut n = Node("hello");
            return solve(n, n).i32 - '!'.i32;
        }
    `);

    ZERO(`
        struct Node { items: string };

        pure fn closure_of_explicit_ref_cant_relax(ref n) {
            fn solveNode(ref items) {
                fn outItems(back) items[items.len - back];
                if (n) return outItems(1);
                return [];
            }

            return solveNode(n.items);
        }

        fn main() {
            mut n = Node("hello");
            return closure_of_explicit_ref_cant_relax(n).i32 - 'o'.i32;
        }
    `);

    ZERO(`
        struct Node { items: string };

        pure fn injected_args_ignore_relaxed_types(using ref n) {
            fn solveNode(lax _) {
                fn outItems(back) items[items.len - back];
                if (n) return outItems(1);
                return [];
            }

            return solveNode(0);
        }

        fn main() {
            mut n = Node("hello");
            return injected_args_ignore_relaxed_types(n).i32 - 'o'.i32;
        }
    `);

    TODO_relaxer(currently: "BUG block.tail not listed in block.type lifetime", `
        struct SolvedNode { value: string; items?: SolvedNode[] };

        noinline fn blockTailHasLocals_but_blockTypeIsTemp(root: SolvedNode)
        {
            fn declareStruct(node: SolvedNode) {
                mut def = "";
                node.items.each: |item|
                    def ~= item.value ~ cgCall(item);

                return def;
            }

            fn cgCall(node: SolvedNode) {
                mut item_src: string[] = [ "", "" ];
                fn ooeWrap(src) src && [];
                fn ARG(i) item_src[i];

                let id = node.value;
                if (id.len & 1)
                    return ooeWrap((ARG(0)<alt> = ""</alt>) ~ "" ~ (ARG(1)<alt> = ""</alt>));
                else if (!id)
                    return "" ~ id;
                else
                    return [];
            }

            return declareStruct(root);
        }

        fn main() {
            return blockTailHasLocals_but_blockTypeIsTemp(
                SolvedNode("none of this does anything")).len;
        }
    `);

    // /Relaxer.


    // Usage.

    ZERO(`
        fn no_fx() {
            mut res = 0;
            pragma clock(\`
                static int counter;
                \`res\`  = counter++;
            \`);
            return res;
        }

        struct X { a: i32[]; b: i32[] };
        fn test(x: X, ref y: i32[])
            y ~= x.a;

        fn main() {
            mut x = X(
                [ no_fx(), 2, 3, 4, 5, 6, 7, 8 ],
                [ no_fx(), 3, 4, 5, 6, 7, 8, 9 ]);

            test(x, x.a);
            return x.a.len + no_fx * 1000 - 1016;
        }
    `);

    ZERO(`
        struct A { a: X[] };
        struct B { b: X[] };
        struct C { c: X[] };
        struct X { a: A[]; b: B[]; c?: C[]; };

        fn GET(implicit ref x: X[], idx: int) {
            return x[idx];
        }

        fn DUPE(implicit ref x: X[], idx: int) {
            let src = GET(idx);                                 ;; GNUStmtExpr
            let idx1 = x.len;

            x.grow(idx1 + 1)
            ref dest = x[idx1];
            dest.a = src.a;
            dest.b = src.b;
        }

        fn main() {
            implicit mut x = [ X([ A(), A() ], [ B(), B(), B() ], [ C(), C(), C(), C(), C() ]) ];
            DUPE(0);
            mut sum = 0;
            for (mut i = 0; i < x.len; i++) {
                shadow let x = x[i];
                sum *= x.a.len || 1; sum += x.a.len;
                sum *= x.b.len || 1; sum += x.b.len;
                sum *= x.c.len || 1; sum += x.c.len;
            }
            return sum - 309;
        }
    `);

    // /Usage.


    // Mangling.

    ZERO([`
        noinline fn hello(x: i32) x;
    `,`
        noinline fn hello(x: i32) x;
    `,`
        fn main() 0._0::hello + 0._1::hello;
    `]);

    ZERO([`
        noinline fn hello(x) x;
    `,`
        noinline fn hello(x) x;
    `,`
        fn main() 0._0::hello + 0._1::hello;                    ;; DuplicateFunctions
    `]);

    ZERO([`
        noinline fn hello(x: i32) x;
    `,`
        noinline fn hello(x) x;
    `,`
        fn main() 0._0::hello + 0._1::hello;
    `]);

    ZERO([`
        fn Each(y<alt>: i32</alt>)
            y & 1   ? y
                    : y / 2 + Each(y / 2);
    `,
    `
        fn Each(y<alt>: i32</alt>)
            y & 1   ? y / 2
                    : y / 2 + Each(y / 2);
    `,
    `
        fn main() {
            let a = _0::Each(100);
            let b = _1::Each(8);

            return a+b - 107;
        }
    `]);

    ZERO([`
        fn find(keys: $T[], item: $T) {
            for (mut i = 0; i < keys.len; i++) {
                if (keys[i] >= item) {
                    if (keys[i] != item)
                        return -1;

                    return i;
                }
            }

            return -1;
        }
    `,
    `
        fn Set(_: $K) struct { keys: $K[]; };

        fn has(using _, key)
            _0::find(keys, key) >= 0;
    `,
    `
        fn use_Set(a: string) {
            mut set: _1::Set(string);
            set.keys ~= a;
            return set._1::has(a);
        }

        fn dont_use_Set(a: string, b: string) {
            mut keys: string[];
            keys ~= b;
            keys ~= a;
            return keys.find(a);
        }

        fn main() {
            if (!use_Set("a"))
                return -1;

            return dont_use_Set("a", "b") - 1;
        }
    `]);

    ZERO(`
        fn test(tokens: i32[]) {
            mut lidx = 0;
            mut sum  = 0;

            fn token(idx: i32, col!: i32)       = sum += idx * col;
            fn token(idx: i32)                  = token(:idx, col: lidx - idx);

            for (mut i = 0; i < tokens.len; i++)
                token(tokens[i]);

            return sum;
        }

        fn main() [ 1 ].test + 1;
    `);

    ZERO([`
        fn sum_each(a, b, Each)     a.Each + b.Each;

        fn hello(x) {
            if (x & 1) {
                fn Each(y) y    ? y * Each(y - 1)
                                : 100;

                return sum_each(x, x, fn Each);
            }
            else {
                fn Each(y) y    ? y * Each(y - 1)
                                : 10000;

                return sum_each(x, x, fn Each);
            }
        }
    `,
    `
        fn Each(y) y & 1    ? y
                            : y / 2 + Each(y / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);
    `]);

    TODO_ambig(currently: "BUG exit code", [`
        fn sum_each(a, b)       // Same as above,
            a.Each + b.Each;    //  but we don't explicitly pass the fn Each in.

        fn hello(x) {
            if (x & 1) {
                fn Each(a) a    ? a * Each(a - 1)   // These get ignored?
                                : 100;              //  sum_each goes and selects the one from _1.

                return sum_each(x, x);
            }
            else {
                fn Each(b) b    ? b * Each(b - 1)
                                : 10000;

                return sum_each(x, x);
            }
        }
    `,
    `
        fn Each(c) c & 1    ? c
                            : c / 2 + Each(c / 2);

        fn main() _0::hello(1) - 2 * Each(100)
                + _0::hello(2) - 2 * Each(20000);
    `]);

    ZERO(`
        fn a        = "aaa";
        fn shorter  = "bb";
        fn greater  = "aac";

        return a <> shorter == +1
            && a <> greater == -1 ? 0 : 101;
    `);

    ZERO([`
        fn &(a, b) {
            mut res = a;
            for (fieldname i: typeof(a)) res.i &= b.i;
            return res;
        }

        struct XY  { x: i32; y: i32 };
        struct UVW { u: i32; v: i32; w: i32 };
    `,`
        import _0;

        fn main() {
            mut xy  =  XY(1, 2)    &  XY(2, 3);
            mut uvw = UVW(1, 2, 3) & UVW(2, 3, 4);
            return xy.y - uvw.v;
        }
    `]);

    ZERO([`
        struct Projection { x: i32; y: i32 };
        fn Projection(a: i32, b: i32) = Projection(x: a*a, y: b*b);
        fn Projection(c: i32, d: i32) = Projection(x: c+c, y: d+d);
    `,`
        import _0;

        fn main() {
            let p0 = Projection(a: 3,  4);
            let p1 = Projection(c: 20, 30);
            return p0.x + p1.x - 49;
        }
    `]);

    ZERO([`
        struct Woot { i: i32 };
        fn sqr(v) = mul(v, v);
    `,`
        import _0;
        noinline fn mul(x: Woot, y: Woot) = x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);
    `,`
        import _0;
        noinline fn mul(x: Woot, y: Woot) = 2 * x.i * y.i;
        inline fn use_sqr(a: Woot) = sqr(a);
    `,`
        fn main() {
            let x = _0::Woot(2);
            let a = _1::use_sqr(x);
            let b = _2::use_sqr(x);
            return a == 4 && b == 8 ? 0 : 1;
        }
    `]);

    // /Mangling.


    // C++ hacks.

    ZERO(`
        pragma emit(\`
            void ccIncrX2(int& a, int b) {
                a += b * 2;
            }
        \`);

        fn main() {
            mut a = 0;
            pragma emit("ccIncrX2(", a, ", 5);");
            return a - 10;
        }
    `);

    ZERO(`
        pragma emit("// needs newline");
        pragma emit(\`
            namespace {
            }
        \`);
        fn main() 0;
    `);


    // Function types sketch.

    SKETCH(currently: "expected , got . 2:42+1", `
        fn apply(num: i32, func: fn (i32): i32) = func(num);
        fn main()                               = apply([1], |i| i - 1);
    `);

    ZERO(`
        fn desc(a: i32, b: i32) b < a;

        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(fn desc);
            return vals[0] - 2;
        }
    `);

    ZERO(`
        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a: i32, b: i32| b < a);
            return vals[0] - 2;
        }
    `);

    ZERO(`
        fn main() {
            mut vals = [ 1, 2 ];
            vals.sort(|a, b| b < a);
            return vals[0] - 2;
        }
    `);

    ZERO(`
        fn test(ref vals: i32[], xor: i32)
            vals.sort(
                |a: i32, b: i32|
                    a^xor < b^xor);

        fn main() {
            mut vals = [ 1, 2 ];
            vals.test(xor: 3); // xor:3 descs 1 and 2.
            return vals[0] - 2;
        }
    `);


    // Fork/join parallelism.

    ZERO(`
        fn main() {
            mut arr = [ 1, 2, 3, 4 ];

            arr.par::each: |it| it *= 2;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 8;
        }
    `);

    ZERO(`
        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];
            mut sum = 0;

            <fail purectx writes to implicit sum>
            arr.par::each: |it| <pass/>
            arr.seq__each: |it| </fail>
                sum += it *= 2;                                 ;; PointlessMustSeq

            return sum - 2 - 4 - 6 - 8;
        }
    `);

    ZERO(`
        fn seq__each(a: [$T], fn)
            for (mut i = 0; i < a.len; i++)
                fn(a[i]);

        fn main() {
            mut arr = [ 1, 2, 3, 4 ];

            <fail noflow non local control flow>
            arr.par::each: |it| <pass/>
            arr.seq__each: |it| </fail>
                if ((it *= 2) > 4)
                    break;

            mut sum = 0;
            for (mut i = 0; i < arr.len; i++)
                sum += arr[i];

            return sum - 2 - 4 - 6 - 4/*unchanged after break*/;
        }
    `);

    ZERO(`
        fn test(ref arr: i32[])
            arr.par::each: |v, i| v += i;

        fn main() {
            let N = 1087 * 1091;

            mut orig: i32[];
            orig.resize(N);

            mut arr = orig;
            arr.test();

            if (arr.len != N || arr.len != orig.len)
                return 1;

            for (mut i = 0; i < N; i++)
                if (orig[i] != 0)
                    return 2;

            for (mut i = 0; i < N; i++)
                if (arr[i] != i)
                    return 3;

            return 0;
        }
    `);


    // Enums, flags & custom primitives.

    ZERO(`
        fn main() {
            let i: i8 = 0;
            <fail return type annot>
            return i;        <pass/>
            return i.i32;    </fail>
        }
    `);

    ZERO(`
        primitive s32: i32;

        fn main() {
            let i: s32 = 0;
            <fail return type annot>
            return i;        <pass/>
            return i.i32;    </fail>
        }
    `);

    ZERO(`
        enum Enum { None = 0 };

        fn main() {
            let e = Enum.None;
            <fail return type annot>
            return e;        <pass/>
            return e.i32;    </fail>
        }
    `);

    ZERO(`
        using enum Test { A = 5; B; C };
        fn main()
            <fail - bad call>
            C - 7;      <pass/>
            C.i32 - 7;  </fail>
    `);

    ZERO(`
        using
        <alt>
        primitive <alt/>
        enum      </alt> Test: i32 { A1; A2; M5 = 5; A6 };

        fn main()
            A1.i32 + A2.i32 * 10 + M5.i32 * 100 + A6.i32 * 1000
                == 6521 ? 0 : 1;
    `);

    ZERO(`
        using
        <fail bad call to ->
        enum         <pass/>
        primitive    </fail> Test: i32 { A; B };
        fn main() (B - A).i32 - 1;
    `);

    ZERO(`
        enum EnumA: i32;
        enum EnumB: EnumA { Zero = 0 };
        fn main() EnumB.Zero.i32;
    `);

    ZERO(`
        primitive PrimA: i32;
        using primitive PrimB: PrimA { Zero = 0; One };
        fn main() (One - 1).i32;
    `);

    ZERO(`
        primitive PrimA: i32;
        primitive PrimB: PrimA { Zero = 0; One };

    <alt>
        fn and_decr(ref prim: PrimB)
            prim &&= prim - 1;
    <alt/>
        fn and_decr(ref prim: PrimB)
        {
            mut res = prim - 1;
            prim &&= res;
            return prim;
        }
    </alt>

        fn main() {
            mut r = PrimB.One;
            return r.and_decr.i32;
        }
    `);

    ZERO(`
        enum Hey { foo; };
        fn test(hey: Hey) hey.i32;
        fn main() test("foo") - 1;
    `);

    ZERO(`
        using enum Greet { hello; world };
        fn main()
            hello ~ " " ~ world == "hello world"                ;; DuplicateFunctions
                ? 0 : 1;
    `);

    ZERO(`
        enum Greet { hello; world };
        fn woot(hi: Greet) hi == "hello";
        fn main() Greet.hello.woot ? 0 : 1;
    `);

    ZERO([`
        using enum Greet { hello; world };
        fn h() Greet.hello;
        fn w() Greet.world;
    `,`
        fn main()
            _0::h() ~ " " ~ _0::w() == "hello world"            ;; DuplicateFunctions
                ? 0 : 1;
    `]);

    ZERO([`
        using enum _0 { A; B };
    `,`
        fn test(::_0) _0.i32;
        fn main() "A".test - _0::A.i32;
    `]);

    ZERO([`
        enum _0 { A; B };
    `,`
        fn test(x: ::_0 = "B") x.i32;
        fn main() test - ::_0.B.i32;
    `]);

    ZERO(`
        enum Enum { A = 0; B };
        fn inner(x: Enum) x.i32;
        fn outer(x: i32) inner(x & 1 ? "B" : "A");
        fn main() outer(0);
    `);

    TODO_enums(currently: "A is not defined here 2:28+1", `
        enum Test { A; B = A; C; };
        fn main() Test.C.i32 - 1;
    `);

    ZERO(`
        using flags Flags { A; B; C; D };

        fn main() {
            mut flags = A | C;
            return flags.i32 == 5 ? 0 : 1;
        }
    `);

    ZERO(`
        flags Flags: i32 { A; B };

        fn main() {
            mut hello = 5;
            mut world = hello.Flags;
            return world.i32 - 1;
        }
    `);

    ZERO(`
        using flags Hey: u8 { A; B };
        fn main() {
            mut flags = A | B;
            flags &= ~B;
            return flags.i32 - 1;
        }
    `);

    ZERO(`
        enum thing { i32; int; bool }

        // So the problem is the retval annotation for fn ==(template): bool
        //  fails to resolve as it conflicts with enumv from thing here.
        //
        // I'm not terribly sure what we want to do about it,
        //  it's the ambiguity thing again - template sees the enum on expansion,
        //   so it does kinda make sense for thing not to compile,
        //    otherwise imagine the original bool goes away,
        //     it'd fallback to the enumv here, which is exactly not what we want.
        //
        // Perhaps the scoping rules for templates don't make so much sense,
        //  if we didn't make everything from local scope visible
        //   they'll also compile faster.
        //
        fn isInt (k: thing) k == "i32" || k == "int";
        fn isBool(k: thing) k == "bool";
        fn main() isInt("i32") && isBool("bool") ? 0 : 1;
    `);

    ZERO(`
        enum ID: u64 {
            // clang warned with -Wimplicitly-unsigned-literal
            CustomIDs = 0x8000_0000_0000_0000;
            BitmapFontAtlas;
        };

        fn main() {
            mut id: u64 = ID.BitmapFontAtlas.u64;
            // meawhile this outputted the underscores
            return id == 0x8000_0000_0000_0001 ? 0 : 1;
        }
    `);

    ZERO(`
        using enum ID: u32 {
            SecondLast = 0xffff_fffe;
            Last;
            <fail exhaust range>
            NoRoom; <pass/></fail>
        };

        fn main() {
            return Last.u32 == 0xffff_ffff ? 0 : 1;
        }
    `);

    ZERO(`
        enum ID: u64 {
            SecondLast = 0xffff_ffff_ffff_fffe;
            Last;
            <fail exhaust range>
            NoRoom; <pass/></fail>
        };

        fn main() {
            return ID.Last.u64 == 0xffff_ffff_ffff_ffff ? 0 : 1;
        }
    `);

    ZERO([
    `
        enum ID { A = 1 };
        using enum IDOffset { B = 10 };
        fn offset(a: ID, b: IDOffset) = a.i32 + b.i32;
    `,
    `
        fn main() = _0::ID.A.offset(
            _0::<alt>B<alt/>IDOffset.B</alt>) - 11;
    `]);

    ZERO(`
        enum ABC { A; B; C };

        fn isAorB(x: ABC)
            x == "A" ||     <fail 6:15+2 incompatible types for T>
            x == "b";       <pass/>
            x == "B";       </fail>

        fn main() isAorB("A") && isAorB("B") && !isAorB("C") ? 0 : 1;
    `);

    // /Enums


    // Unions, what the hell.

    ZERO(`
        union union_ui {
            i: i32;
            u: u32;
        }

        fn main() {
            mut ui = union_ui(i: -1);
            return (ui.u - 0xffffffff).i32;
        }
    `);


    // Effects & discard.

    ZERO(`
        fn does_throw(mut x: i32) {
            if (x & 1)          return x;
            mut str = "";
            while (x--)         str ~= x;
            throw(str);
        }

        nothrow fn does_catch(mut y: i32) {
            try                 return does_throw(y);
            catch (e)           return e.len;
        }

        <fail does_throw throws>
        nothrow <pass/></fail>
        fn doesnt_catch(mut z: i32) {
            if (z & 2)          return does_throw(z);
            else                return does_catch(z);
        }

        fn main() = doesnt_catch(1) - 1;
    `);

    ZERO(`
        fn has_fx() {
            mut res = 0;
            pragma output(\`
                static int counter;
                \`res\`  = counter++;
            \`);
            return res;
        }

        fn not_dead_mutually_rec_a(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_b(x - 1);
                has_fx();
            }
        }

        fn not_dead_mutually_rec_b(x: i32) {
            if (x > 0) {
                not_dead_mutually_rec_a(x - 1);
                has_fx();
            }
        }

        fn main() {
            <alt>
            not_dead_mutually_rec_a(2); <alt/>
            not_dead_mutually_rec_b(2); </alt>
            return has_fx() - 2;
        }
    `);

    ZERO(`
        fn no_fx() {
            mut res = 0;
            pragma clock(\`
                static int counter;
                \`res\`  = counter++;
            \`);
            return res;
        }

        fn test(lax x: i32) {
            x & 1 && no_fx();
            x & 2 || no_fx();
            if (!no_fx) no_fx(); else no_fx();
            for (mut i = 1; i--> 0; no_fx()) no_fx();

            // the idea is that everything above should go,
            //  and just this one call to no_fx will remain.
            return no_fx();
        }

        fn main() = test(1);
    `);

    ZERO(`
        fn lex(src: string) {
            mut idx = 0;
            let end = src.len;
            while (idx < end) {
                let c = src[idx++]; // bug in discard(if) unused this var
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9') {
                    //
                }
                else {
                    idx--;
                    break;
                }
            }
            return idx;
        }

        fn main() = "hello!".lex - 5;
    `);


    // Static eval.

    ZERO(`
        let se_global_false = false;
        <split/>
        fn main() {
            if (se_global_false) return THIS_DOESNT_EXIST();
            return 0;
        }
    `);

    ZERO(`
        let se_global_true = true;
        <split/>
        fn main() {
            if (!se_global_true) return THIS_DOESNT_EXIST();
            return 0;
        }
    `);

    ZERO(`
        let se_global_let_from_closure = false;
        <split/>
        fn main() {
            fn test() {
                if (se_global_let_from_closure) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }
    `);

    ZERO(`
        fn main() {
            <fail not defined 5:55+1>
            mut <pass/>
            let </fail> se_local_let = false;
            if (se_local_let) return THIS_DOESNT_EXIST();
            return 0;
        }
    `);

    ZERO(`
        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }
        fn main() = Hello(true).v ? 0 : 1;
    `);

    ZERO(`
        // 'v' got mistagged as VFacts.AlwaysFalse
        struct Hello { v?: bool; }

        fn main() {
            let yes = Hello(true);
            let no  = Hello(false);

            let expect_true = yes.v;
            let expect_false = no.v;

            if (!expect_true) return 20;
            if (expect_false) return 10;
            return 0;
        }
    `);

    ZERO(`
        fn main() {
            <fail not defined 6:61+1>
            mut <pass/>
            let </fail> se_closure_let = false;
            fn test() {
                if (se_closure_let) return THIS_DOESNT_EXIST();
                return 0;
            }
            return test();
        }
    `);

    ZERO(`
        fn test(x: i32) {
            let val =                                       <alt>
                x & 1 ? { return 0 } : { return 1 };        <alt/>
                x & 1 && { return 0 } || { return 1 };      <alt/>
                (x & 1 || { return 1 }) && { return 0 };    </alt>

            return UNREACHABLE(val);
        }

        fn main() test(1);
    `);

    ZERO(`
        noinline fn alwaysFalse() false;
        fn main() alwaysFalse.i32;
    `);

    ZERO(`
        fn typeParamsMusntPickUpVFacts(x: i32) {
            let y = x || throw("x == 0"); // Now y is always true.
            if (y & 1) // & 1 is not always true though.
                return y * 10;
            else
                return y * 100;
        }

        fn main() typeParamsMusntPickUpVFacts(3)
                + typeParamsMusntPickUpVFacts(2) == 230 ? 0 : 1;
    `);

    ZERO(`
        fn test() <fail return does not match annotation never 4:23+2>
                : never <pass/></fail>
                    = [];

        fn main() {
            mut x: i32 = test();
            return x;
        }
    `);

    ZERO(`
        fn checkPalindrome(host: string, guest: string)
            return host == guest || throw(":(");

        fn palindrome(value: string) {
            mut rev = value;
            rev.reverse();
            <alt>
            checkPalindrome(value, rev);
            return rev;
            <alt/>
            return checkPalindrome(value, rev)
                && rev;
            </alt>
        }

        fn main() {
            mut n = "opera-arepo";
            return n.palindrome.len - 11;
        }
    `);

    ZERO(`
        struct Node         { value: string };
        struct Target       { index: i32    };
        struct SolvedNode   { value: string };

        fn solve(n_root: Node)
        {
            fn solveNode(node: Node)
                return CallerNode(node.value);

            fn checkAssignable(host: string, guest: string)
                return host == guest || throw(":(");

            fn CallerNode(value: string) {
                <alt>
                checkAssignable(value, n_root.value);
                return SolvedNode(:value);
                <alt/>
                return checkAssignable(value, n_root.value)
                    && SolvedNode(:value);
                </alt>
            }

            return solveNode(n_root);
        }

        fn main() {
            mut n = Node("hello!");
            return n.solve.value.len - 6;
        }
    `);

    ZERO(`
        struct Postdom { a: i32; b?: i32[] };

        fn clear(ref p: Postdom)
            for (fieldname i: Postdom)
                if (typeof(p.i) -> i32[])
                    p.i.clear();

        fn main() {
            mut a = Postdom(a: 3);
            mut b = Postdom(a: 3, b: [ 1 ]);
            if (a == b) return 1;
            b.clear();
            return a == b ? 0 : 1;
        }
    `);

    ZERO(`
        novec fn build(ref a: string, b: string) {
            let cmake       = false;
            <alt>
            let CMakeLists  = cmake && (a ~= b);
            <alt/>
            let OPAQUE      = a.len + b.len;
            let CMakeLists  = cmake && OPAQUE && (a ~= b);
            </alt>
            if (CMakeLists) DOESNT_EXIST();
            return CMakeLists;
        }

        fn main() {
            mut a = "hello, ";
            let b = "world!";
            return build(a, b).len;
        }
    `);

    ZERO(`
        fn doesntSkipIfWithTrailingFalse(x: i32) {
            if (x && false)
                return DOESNT_EXIST;
            else
                return x;
        }

        fn main() = doesntSkipIfWithTrailingFalse(0);
    `);

    // /StaticEval


    // Value vs reference semantics

    ZERO(`
        fn val_keyword(val a, val b) {
            val c = a + b;
            return c;
        }

        fn main() val_keyword(2, 3) - 5;
    `);

    TODO_semantics(currently: "Bad call to val_keyword mutref 7:30+1", `
        fn val_keyword(const ref a, const ref b) {
            const ref c = a || b;
            return c;
        }

        fn main() val_keyword(2, 3) - 2;
    `);

    TODO_semantics(currently: "BUG exit code", `
        <fail explicit_arg closure_arg both alias use val or ref X:X>
        fn foreach_modify(    explicit_arg: int[], foreach)     <pass/>
        fn foreach_modify(ref explicit_arg: int[], foreach)     </fail>
            for (mut i = explicit_arg.len; i --> 0; )
                foreach(explicit_arg[i], i?: i);

        fn main() {
            mut closure_arg = [ 2 ];
            closure_arg.foreach_modify: |item, i| {
                while (item > i) {
                    closure_arg.insert(i, i);
                    i++;
                }
            }

            return closure_arg == [ 0, 1, 2 ] ? 0 : 1;
        }
    `);

    // /Semantics


    // CSE & LICM.

    ZERO(`
        fn pretend_pure(mut res = 0) {
            pragma emit(\`
                static int counter = 100;
                \`res\` += counter++;
            \`);
            return res;
        }

        fn validate_looks_pure() {
            pretend_pure(1);
            return pretend_pure(2);
        }

        fn main() validate_looks_pure() == 102 ? 0 : 1;
    `);

    ZERO(`
        fn pretend_pure(mut res = 0) {
            pragma emit(\`
                static int counter = 100;
                \`res\` += counter++;
            \`);
            return res;
        }

        fn licm_loop_preheader(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++)
            on enter {
                let must_hoist = pretend_pure(n);
            }
            then {
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_loop_preheader(2) == 204 ? 0 : 1;
    `);

    TODO_licm(currently: "BUG exit code", `
        fn pretend_pure(mut res = 0) {
            pragma emit(\`
                static int counter = 100;
                \`res\` += counter++;
            \`);
            return res;
        }

        fn licm_hoist_var(n: i32) {
            mut res = 0;
            for (mut i = 0; i < n; i++) {
                let must_hoist = pretend_pure(n);
                res += must_hoist;
            }
            return res;
        }

        fn main() licm_hoist_var(2) == 204 ? 0 : 1;
    `);


    // ZERO(`
    //     enum Thing {
    //         None;
    //         enum Animal { Cat; Dog; }
    //         enum Food { Apple; Orange; }
    //     };
    //
    //     fn main() Apple.i32 - Dog.i32 - 1;
    // `);

    // ZERO(`
    //     tuple enum TextureType: u32 {
    //
    //         enum Kind {
    //             None;
    //
    //             T_unorm; T_snorm;  T_uint; T_int;
    //             T_float; T_ufloat; T_srgb; T_depth;
    //         };
    //
    //         enum Size {
    //             None;
    //
    //             T_8x4; T_16x4; T_32x4;
    //             T_8x3; T_16x3; T_32x3;
    //             T_8x2; T_16x2; T_32x2;
    //             T_8x1; T_16x1; T_32x1;
    //
    //             T_10x3_2; T_11x2_10; T_24x1_8;
    //         };
    //
    //         flags enum Usage {
    //             T_nosample;
    //             T_nomips;
    //             T_fmin_nearest;
    //             T_fmag_nearest;
    //             T_clamp_u;
    //             T_clamp_v;
    //         };
    //     };
    //
    //     pub let T_d24_s8            = T_24x1_8 | T_depth;
    //     pub let T_DepthRenderBuffer = T_d24_s8 | T_nosample;
    //
    //     fn main()
    //         TODO;
    // `);
}
