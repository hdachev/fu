
fn bfind(keys, item: $T, hit, miss)
{
    // TODO bsearch instead
    mut N = keys.len;
    for (mut i = 0; i < N; i++)
    {
        let cmp = keys[i] <> item;
        if (cmp >= 0)
        {
            if (cmp == 0)
                return hit(i);

            N = i;
            break;
        }
    }

    return miss(N);
}

pub fn has(keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |_| {
        return true;
    },

    miss: |_| {
        return false;
    });
}

pub fn add(ref keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |_| {
        return false;
    },

    miss: |i| {
        keys.insert(i, item);
        return true;
    });
}

// pub fn add_once(ref keys: $T[], item: $T, ref extras: $U[], inline extra: $U)
// {
//     bfind(:keys, :item,
//
//     hit: |_| {
//         return false;
//     },
//
//     miss: |i| {
//         keys.insert(i, item);
//         extras.insert(i, extra);
//         return true;
//     });
// }

pub fn update(keys, item: $T, extras, extra: $U)
{
    bfind(fn keys, :item,

    hit: |i| {
        extras[i] = extra;
        return false;
    },

    miss: |i| {
        keys.insert(i, item);
        extras.insert(i, extra);
        return true;
    });
}

pub fn ref(keys, item: $T, extras)
{
    let idx = bfind(fn keys, :item,

    hit: |i| {
        break i;
    },

    miss: |i| {
        keys.insert(i, item);
        extras.insert(i, []);
        break i;
    });

    return extras[idx];
}

pub fn if_ref(keys, item: $T, extras, visit)
{
    bfind(fn keys, :item,

    hit: |i| {
        visit(extras[i]);
        return true;
    },

    miss: |_| {
        return false;
    });
}

pub fn get(keys: $T[], item: $T, extras: $U[])
{
    bfind(:keys, :item,

    hit: |i| {
        return extras[i];
    },

    miss: |_| {
        return [];
    });
}

pub fn rem(ref keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |i| {
        keys.splice(i, 1);
        return true;
    },

    miss: |_| {
        return false;
    });
}


// TODO these should actually work better if they're push-back style

pub fn union(a: $T[], b: $T[]): $T[]
{
    if (a.len < b.len)
        return union(b, a);

    shadow mut a = a;
    a.add(b);
    return a;
}

pub fn inter(a: $T[], b: $T[]): $T[]
{
    if (a.len > b.len)
        return inter(b, a);

    shadow mut a = a;
    a.keep(b);
    return a;
}

pub fn diff(a: $T[], b: $T[]): $T[]
{
    if (a.len > b.len)
        return diff(b, a);

    shadow mut a = a;
    a.rem(b);
    return a;
}


// TODO instead of this,
//  make sure each item is moved exactly once.

pub fn add(ref a: $T[], b: [$T])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp >= 0) {
            if (cmp != 0) {
                a.insert(x, Y); // TODO FIX
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
        a ~= b[y, b.len];
}

pub fn add(ref a: $T[], b: $T[], ref extras: $U[], extra: $U)
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp >= 0) {
            if (cmp != 0) {
                a.insert(x, Y); // TODO FIX
                extras.insert(x, extra);
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
    {
        a ~= b[y, b.len];

        while (y++ < b.len)
            extras ~= extra;
    }
}

pub fn keep(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp == 0) {
            x++;
            y++;
        }
        else if (cmp > 0) {
            y++;
        }
        else {
            a.splice(x, 1); // TODO FIX
        }
    }

    if (x < a.len)
        a.shrink(x);

    return a;
}

pub fn rem(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp == 0) {
            a.splice(x, 1); // TODO FIX
            y++;
        }
        else if (cmp > 0) {
            y++;
        }
        else {
            x++;
        }
    }

    return a;
}
