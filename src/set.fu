
pub fn add(ref dest: $T[], item: $T)
{
    // TODO bsearch instead
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] >= item) {
            if (dest[i] != item) {
                dest.insert(i, item);
                return true;
            }

            return false;
        }
    }

    dest.push(item);
    return true;
}

pub fn add(ref dest: $T[], item: $T, ref extras: $U[], extra: $U)
{
    // TODO bsearch instead
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] >= item) {
            if (dest[i] != item) {
                dest.insert(i, item);
                extras.insert(i, extra);
                return true;
            }

            return false;
        }
    }

    dest.push(item);
    extras.push(extra);
    return true;
}

pub fn add(ref dest: $T[], src: $T[])
{
    mut some = false;
    for (mut i = 0; i < src.len; i++)
        some = dest.add(src[i]) || some;

    return some;
}

pub fn rem(ref dest: $T[], item: $T)
{
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] == item) {
            dest.splice(i, 1);
            return true;
        }
    }

    return false;
}


// TODO instead of this, loop twice -
//  once to size things up,
//   again to put everything in its place (N).

pub fn union(a: $T[], b: $T[]): $T[]
{
    if (a.len < b.len)
        return union(b, a);

    shadow mut a = a;

    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        if (X >= Y) {
            if (X != Y) {
                a.insert(x, Y);
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
        a ~= b[y, b.len];

    return a;
}
