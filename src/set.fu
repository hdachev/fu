
pub fn add(ref dest: $T[], item: $T)
{
    // TODO bsearch instead
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] >= item) {
            if (dest[i] != item) {
                dest.insert(i, item);
                return true;
            }

            return false;
        }
    }

    dest.push(item);
    return true;
}

pub fn add(ref dest: $T[], item: $T, ref extras: $U[], extra: $U)
{
    // TODO bsearch instead
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] >= item) {
            if (dest[i] != item) {
                dest.insert(i, item);
                extras.insert(i, extra);
                return true;
            }

            return false;
        }
    }

    dest.push(item);
    extras.push(extra);
    return true;
}

pub fn rem(ref dest: $T[], item: $T)
{
    // TODO bsearch instead
    for (mut i = 0; i < dest.len; i++) {
        if (dest[i] >= item) {
            if (dest[i] == item) {
                dest.splice(i, 1);
                return true;
            }

            return false;
        }
    }

    return false;
}



// TODO these should actually work better if they're push-back style

pub fn union(a: $T[], b: $T[]): $T[]
{
    if (a.len < b.len)
        return union(b, a);

    shadow mut a = a;
    a.add(b);
    return a;
}

pub fn inter(a: $T[], b: $T[]): $T[]
{
    if (a.len > b.len)
        return inter(b, a);

    shadow mut a = a;
    a.keep(b);
    return a;
}

pub fn diff(a: $T[], b: $T[]): $T[]
{
    if (a.len > b.len)
        return diff(b, a);

    shadow mut a = a;
    a.rem(b);
    return a;
}


// TODO instead of this,
//  make sure each item is moved exactly once.

pub fn add(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        if (X >= Y) {
            if (X != Y) {
                a.insert(x, Y); // TODO FIX
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
        a ~= b[y, b.len];
}

pub fn keep(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        if (X == Y) {
            x++;
            y++;
        }
        else if (X > Y) {
            y++;
        }
        else {
            a.splice(x, 1); // TODO FIX
        }
    }

    if (x < a.len)
        a.shrink(x);

    return a;
}

pub fn rem(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        if (X == Y) {
            a.splice(x, 1); // TODO FIX
            y++;
        }
        else if (X > Y) {
            y++;
        }
        else {
            x++;
        }
    }

    return a;
}
