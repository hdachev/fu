
pub struct BitSet
{
    _data: u8[];
};

pub fn size(using _: BitSet)
{
    // WTF is this
    return _data.len * 8;
}

pub fn clear(using _: &mut BitSet)
{
    _data.clear();
}

pub fn add_once(using _: &mut BitSet, idx: int): bool
{
    let no_neg = idx & int.MIN;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    ref entry = _data.helpers::grow_if_oob(bucket);
    if !(entry & mask)
    {
        entry |= mask;
        return true;
    }

    // Already there.
    return false;
}

pub fn add(using _: &mut BitSet, idx: int)
{
    let no_neg = idx & int.MIN;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    _data.helpers::grow_if_oob(bucket) |= mask;
}

pub fn add(using _: &mut BitSet, other: BitSet)
{
    let N = other._data.len;
    if (_data.len < N)
        _data.grow(N);

    // TODO zip over in u64s first.
    for (mut i = 0; i < N; i++)
        _data[i] |= other._data[i];
}

pub fn rem(using _: &mut BitSet, other: BitSet)
{
    mut N = other._data.len;
    if (N > _data.len)
        N = _data.len;

    // TODO zip over in u64s first.
    for (mut i = 0; i < N; i++)
        _data[i] &= ~other._data[i];

    // Shrink to fit.
    if (N == _data.len)
    {
        mut end = N;
        while (end --> 0)
            if (_data[end])
                break;

        _data.shrink(end + 1);
    }

    throw("NOT TESTED");
}

pub fn has(using _: BitSet, idx: int)
{
    let no_neg = idx & int.MIN;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    return _data.len > bucket
        && _data[bucket] & mask != 0;
}

pub fn rem(using _: &mut BitSet, idx: int)
{
    let no_neg = idx & int.MIN;
    let bucket = idx >> 3 | no_neg;
    let bit    = idx & 7;
    let mask   = 1 << bit.u8;

    // So this is way more complicated than add() -
    //  but we want to make sure the following works:
    //
    //   - if (bitset) should be false if no bits are set.
    //
    //   - .add(bitset) shouldn't have to loop back through zero bytes
    //      to size up the result.
    //
    if (_data.len > bucket)
    {
        let item = _data[bucket];
        if (item & mask)
        {
            _data[bucket] &= ~mask;

            if (item == mask && _data.len == bucket + 1)
            {
                mut end = bucket;
                while (end --> 0)
                    if (_data[end])
                        break;

                _data.shrink(end + 1);
            }

            return true;
        }
    }

    return false;
}

pub fn add_range(using _: &mut BitSet, end!: int)
{
    let no_neg      =  end & int.MIN;

    let floorBytes  =  end      >> 3 | no_neg;
    let ceilBytes   = (end + 7) >> 3 | no_neg;

    _data.grow(ceilBytes);
    for (mut i = 0; i < floorBytes; i++)
        _data[i] = 0xff;

    if (ceilBytes > floorBytes)
    {
        mut tail: u8;

        mut i = floorBytes << 3;
        do  tail |= 1 << (i & 7).u8;
        while (i++ < end);

        _data[floorBytes] = tail;
    }
}

pub fn popcount(using _: BitSet)
{
    mut sum = 0;

    let N = _data.len >> 3;
    let u64s = _data[0, N << 3].view(u64);
    for (mut i = 0; i < u64s.len; i++)
        sum += bit::popcount(u64s[i]);

    mut tail: u64;
    for (mut i = N << 3; i < _data.len; i++) {
        tail <<= 8;
        tail |= _data[i].u64;
    }

    sum += bit::popcount(tail);
    return sum;
}

pub fn each(using _: BitSet, visit)
{
    for (mut i = 0; i < _data.len; i++)
    {
        let item = _data[i];
        if (item) for (mut b = 0; b < 8; b++)
        {
            let mask = 1 << b.u8;
            if (item & mask)
                visit(i << 3 | b.int);
        }
    }
}


// Ops, this would be nicer as an operator:
//
// fn a &= ~b           // but see, what we want is a single `&=~` op

pub fn and_not_assign(ref a: BitSet, b: BitSet)
{
    let N = a._data.len.min(b._data.len);
    for (mut i = 0; i < N; i++)
        a._data[i] &= ~b._data[i];

    return a;
}
