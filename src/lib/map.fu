/*
struct Map(K, V)
{
    keys: K[];
    vals: V[];

    fn size()
        keys.len;

    fn find(key)
        set::find(keys, key);

    fn has(key)
        find(key) >= 0;

    fn update(key, value)
        set::update(keys, key, vals, value);

    fn get(key) {
        let idx = find(key);
        if (idx >= 0)
            return vals[idx];

        return [];
    }
};
*/

struct Map(type K, type V) {
    keys: set::Set(K)
    vals: V[]
}

fn has(using ref _: Map($K, $V), key: $K): bool {
    set::has(keys, key)
}

fn get(using ref _: Map($K, $V), key: $K): $V {
    set::get(keys, key, vals)
}

fn each(using ref _: Map($K, $V), fn) {
    for (mut i = 0; i < vals.len; i++) {
        let key = keys.keys_asc[i]//// <- Going through a let here prevents bind-by-mutref.
        fn(vals[i], ?:key)          //
    }                               // Not great, maybe we need a `ref ` kw-prefix
}                                   //  at callsites like in c#,
                                    //   it'd work as `&mut ` in rust if possible,
                                    //    still mut-generic.
                                    //
                                    // Wonder what that means for . notation though.
                                    //  What's happening in rust is, they make an exception.
                                    //   Method-invocation via . notation exception
                                    //    triggers what they call an "auto-deref",
                                    //     which basically is it's special thing.
                                    //
                                    // POSSIBLE SOLUTION (FN-TYPES):
                                    //
                                    // Typing the fn(const key: $K, ref val: $V)
                                    //  would also do the trick, probably way cleaner.

fn set(using mut ref _: Map($K, $V), key: $K, value: $V): bool {
    set::update(
        keys, key,
        vals, value)
}

fn ref(using mut ref _: Map($K, $V), key: $K): $V {
    set::ref(
        keys, key,
        vals)
}

fn if(using mut ref _: Map($K, $V), key: $K, visit): void {
    set::if(
        keys, key,
        vals, fn visit)
}

fn remove(using mut ref _: Map($K, $V), key: $K) {
    set::if(keys, key, vals): |_, remove!| {
        remove()
        return true
    }

    false
}

fn clear(using mut ref _: Map($K, $V)): void {
    keys.clear()
    vals.clear()
}
