/*
struct Map(K, V)
{
    keys: K[];
    vals: V[];

    fn size()
        keys.len;

    fn find(key)
        set::find(keys, key);

    fn has(key)
        find(key) >= 0;

    fn update(key, value)
        set::update(keys, key, vals, value);

    fn get(key) {
        let idx = find(key);
        if (idx >= 0)
            return vals[idx];

        return [];
    }
};
*/

fn Map(lax k: $K, lax v: $V) struct
{
    keys: $K[];
    vals: $V[];
};

fn has(using _, key)
    set::has(keys, key);

fn set(using ref _, key, value)
    set::update(
        || keys, key,
        || vals, value);

fn get(using _, key)
    set::get(keys, key, vals);

fn each(using _, fn)
    for (mut i = 0; i < vals.len; i++)
        fn(vals[i], key?: keys[i]);

fn pairs(using _, fn)
    for (mut i = 0; i < keys.len; i++)
        fn(keys[i], vals[i]);

fn ref(using ref _, key)
    set::ref(
        || keys, key,
        || vals);

fn if_ref(using ref _, key, visit)
    set::if_ref(
        || keys, key,
        || vals, fn visit);

// TODO FIX - this is real funny -
//  because i can't limit this to the templated struct above
//   what's happening is naming this 'clear' makes it try spec
//    for the keys & val arrays and obviously blows up.
//
fn clr(using ref _) {
    keys.clear();
    vals.clear();
}
