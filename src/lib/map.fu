/*
struct Map(K, V)
{
    keys: K[];
    vals: V[];

    fn size()
        keys.len;

    fn find(key)
        set::find(keys, key);

    fn has(key)
        find(key) >= 0;

    fn update(key, value)
        set::update(keys, key, vals, value);

    fn get(key) {
        let idx = find(key);
        if (idx >= 0)
            return vals[idx];

        return [];
    }
};
*/

struct Map(type K, type V) {
    keys: K[];
    vals: V[];
};

fn has(using ref _: Map($K, $V), key: $K): bool =
    set::has(keys, key);

fn get(using ref _: Map($K, $V), key: $K): $V =
    set::get(keys, key, vals);

fn each(using ref _: Map($K, $V), fn)
    for (mut i = 0; i < vals.len; i++) {
        let key = keys[i];  // <------ This means to prevent bind-by-mutref here.
        fn(vals[i], ?:key);         //  Not great, maybe we need a `ref ` kw at callsites like in c#,
    }                               //   it'd work as `&mut ` in rust if possible, still mut-generic.
                                    //
                                    // Wonder what that means for . notation though.
                                    //
                                    // Alternatively,
                                    //  typing the fn(ref key: $K, val: $V)
                                    //   would also do the trick, probably way cleaner.

//

fn set(using mut ref _: Map($K, $V), key: $K, value: $V): bool =
    set::update(
        keys, key,
        vals, value);

fn ref(using mut ref _: Map($K, $V), key: $K)
    set::ref(
        keys, key,
        vals);

fn if_ref(using mut ref _: Map($K, $V), key: $K, visit)
    set::if_ref(
        keys, key,
        vals, fn visit);

fn clear(using mut ref _: Map($K, $V)) {
    keys.clear();
    vals.clear();
}
