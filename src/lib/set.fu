
fn bfind(keys, item: $T, hit, miss)
{
    mut lo = 0;
    mut hi = keys.len;

    // TODO if $T is primitive -
    //  use a linear search when hi - lo < 16 or something.
    //   not worth doing for more complicated comparators,
    //    here it's nice we only call the <> in one spot.
    //
    while (lo < hi)
    {
        let i   = (hi + lo) >> 1;

        let cmp = keys[i] <> item;
        if (cmp == 0)
            return hit(i);

        if (cmp < 0)
            lo = i + 1;
        else
            hi = i;
    }

    ///////////////////////////////////////////////////////////////////////////
    // lo == hi && (hi == keys.len || keys[hi]     <> item > 0)              //
    //          && (hi == 0        || keys[hi - 1] <> item < 0) || assert(); //
    ///////////////////////////////////////////////////////////////////////////

    return miss(lo);
}

pub fn has(keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |_| {
        return true;
    },

    miss: |_| {
        return false;
    });
}

pub fn add(ref keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |_| {
        return false;
    },

    miss: |i| {
        keys.insert(i, item);
        return true;
    });
}

// pub fn add_once(ref keys: $T[], item: $T, ref extras: $U[], inline extra: $U)
// {
//     bfind(:keys, :item,
//
//     hit: |_| {
//         return false;
//     },
//
//     miss: |i| {
//         keys.insert(i, item);
//         extras.insert(i, extra);
//         return true;
//     });
// }

pub fn update(keys, item: $T, extras, extra: $U)
{
    bfind(fn keys, :item,

    hit: |i| {
        extras[i] = extra;
        return false;
    },

    miss: |i| {
        keys.insert(i, item);
        extras.insert(i, extra);
        return true;
    });
}

pub fn ref(keys, item: $T, extras)
{
    let idx = bfind(fn keys, :item,

    hit: |i| {
        break i;
    },

    miss: |i| {
        keys.insert(i, item);
        extras.insert(i, []);
        break i;
    });

    return extras[idx];
}

pub fn if_ref(keys, item: $T, extras, visit)
{
    bfind(fn keys, :item,

    hit: |i| {
        visit(extras[i]);
        return true;
    },

    miss: |_| {
        return false;
    });
}

pub fn get(keys: $T[], item: $T, extras: $U[])
{
    bfind(:keys, :item,

    hit: |i| {
        return extras[i];
    },

    miss: |_| {
        return [];
    });
}

pub fn rem(ref keys: $T[], item: $T)
{
    bfind(:keys, :item,

    hit: |i| {
        keys.splice(i, 1);
        return true;
    },

    miss: |_| {
        return false;
    });
}


// TODO instead of this,
//  make sure each item is moved exactly once.

pub fn add(ref a: $T[], b: [$T])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp >= 0) {
            if (cmp != 0) {
                a.insert(x, Y); // TODO FIX
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
        a ~= b[y, b.len];
}

pub fn add(ref a: $T[], b: $T[], ref extras: $U[], extra: $U)
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp >= 0) {
            if (cmp != 0) {
                a.insert(x, Y); // TODO FIX
                extras.insert(x, extra);
                y++;
            }
            else {
                y++;
            }
        }

        x++;
    }

    if (y < b.len)
    {
        a ~= b[y, b.len];

        while (y++ < b.len)
            extras ~= extra;
    }
}

pub fn keep(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp == 0) {
            x++;
            y++;
        }
        else if (cmp > 0) {
            y++;
        }
        else {
            a.splice(x, 1); // TODO FIX
        }
    }

    if (x < a.len)
        a.shrink(x);

    return a;
}

pub fn rem(ref a: $T[], b: $T[])
{
    mut x = 0;
    mut y = 0;
    while (x < a.len && y < b.len) {
        let X = a[x];
        let Y = b[y];

        let cmp = X <> Y;
        if (cmp == 0) {
            a.splice(x, 1); // TODO FIX
            y++;
        }
        else if (cmp > 0) {
            y++;
        }
        else {
            x++;
        }
    }

    return a;
}


// The new thing potentially.

fn merge(l: [$T], r: [$T], left, right, both)
{
    mut li = 0;
    mut ri = 0;

    for (;;)
    {
        inline fn L = l[li];
        inline fn R = r[ri];

        let l_done = li == l.len;
        let r_done = ri == r.len;

        let cmp = l_done ? r_done ? { return; } : +1
                         : r_done ? -1
                         : L <> R;

        // TODO come up with a way to combine these nicely,
        //  unfortunately copy pasted below
        //
        if (cmp == 0) {
            both(L, left?: li, right?: ri);
            li++;
            ri++;
        }
        else if (cmp < 0) {
            left(L, left?: li, right?: ri);
            li++;
        }
        else {
            right(R, left?: li, right?: ri);
            ri++;
        }
    }
}

fn merge(l: [$T], r: [$T], left_or_both, right)
{
    mut li = 0;
    mut ri = 0;

    for (;;)
    {
        inline fn L = l[li];
        inline fn R = r[ri];

        let l_done = li == l.len;
        let r_done = ri == r.len;

        let cmp = l_done ? r_done ? { return; } : +1
                         : r_done ? -1
                         : L <> R;

        // TODO come up with a way to combine these nicely,
        //  unfortunately copy pasted above,
        //   here both case collapsed into left -
        //    and this is only so that we inline the fns in a single spot.
        //
        if (cmp <= 0) {
            left_or_both(L, left?: li, right?: ri);
            li++;
            ri += (cmp == 0).i32;
        }
        else {
            right(R, left?: li, right?: ri);
            ri++;
        }
    }
}


//

pub fn has_inter(l: [$T], r: [$T])
{
    merge(l, r,
        left: |_| {}, right: |_| {},
        both: |_| { return true; });

    return false;
}

pub fn inter(l: $T[], r: $T[])
{
    // First, we'll try to return a copy of left -
    //  can't do that if its the longer of the two,
    //   so we flip args.
    //
    if (r.len < l.len)
        return inter(r, l);

    mut result: $T[];
    mut useResult = false;

    merge(l, r,

    left: |_, left|
    {
        // Can't use left as-is, it has extra stuff.
        //  The slice kinda still make it possible
        //   to share storage unless we start appending.
        //
        if (!useResult) {
            useResult = true;
            result = l.slice(0, left);
        }
    },

    right: |_| {},

    both: |item|
    {
        if (useResult)
            result ~= item;
    });

    return useResult ? result : l;
}

pub fn union(l: $T[], r: $T[])
{
    // Same as above, but flipped,
    //  we want left to be the longer of the two.
    //
    if (r.len > l.len)
        return union(r, l);

    mut result: $T[];
    mut useResult = false;

    merge(l, r,

    left_or_both: |item|
    {
        if (useResult)
            result ~= item;
    },

    right: |item, left|
    {
        if (!useResult) {
            useResult = true;
            result ~= l[0, left];
        }

        result ~= item;
    });

    return useResult ? result : l;
}
