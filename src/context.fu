import lexer;
import parser;
import types;
import scope;
import helpers;

pub nocopy struct Context
{
    modules: Module[];

    // FS facts.
    files: Map(string, string);
    fuzzy: Map(string, string);
};

pub fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

pub fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;



//

fn resolveFile(
    implicit ctx: &mut Context,
    from: string, name: string): string
{
    let path    = from ~ name;
    let cached  = ctx.fuzzy[path];
    if (cached)
        return cached == "\v" ? "" : cached;

    fn tryResolve(): string
    {
        let exists = file::size(path) >= 0;
        if (exists)
            return path;

        // TODO FIX
        {
            shadow let path = from ~ "lib/" ~ name;
            shadow let exists = file::size(path) >= 0;
            if (exists)
                return path;
        }

        // TODO FIX
        {
            shadow let path = from ~ "vendor/" ~ name;
            shadow let exists = file::size(path) >= 0;
            if (exists)
                return path;
        }

        // TODO FIX
        {
            shadow let path = from ~ "fu/lib/" ~ name;
            shadow let exists = file::size(path) >= 0;
            if (exists)
                return path;
        }

        /////////////////////////////////
        let fallback = from.path_dirname;
        if (!fallback || fallback.len >= from.len)
            return "";

        return resolveFile(
            from: fallback, :name);
    };

    let resolve = tryResolve();
    ctx.fuzzy[path] = resolve || "\v";
    return resolve;
}

pub fn resolveFile(
    implicit ctx: &mut Context,
    path: string): string
{
    let fuzzy = path.find('\v');
    if (fuzzy > 0)
    {
        let from = path.slice(0, fuzzy);
        let name = path.slice(fuzzy + 1);
        if (from && name && !name.has('\v'))
        {
            let res = resolveFile(:from, :name);
            if (res)
                return res;

            // Tests have the files prepopulated,
            //  we only pay the cost of lookup when about to fail compile.
            let prepopulated = from ~ name;
            if (ctx.files.has(prepopulated))
                return prepopulated;
        }
    }

    return path;
}

pub fn resolveFile_x(
    implicit ctx: Context,
    path: string)
{
    // TODO FIX
    let clean = path.replace(all: "\v", "");
    let match = ctx.fuzzy[clean];

    return match && match != "\v"
         ? match
         : clean;
}


//

pub fn getFile(
    implicit ctx: &mut Context,
    mut path: string): string
{
    let cached = ctx.files[path];
    if (cached)
        return cached == "\v" ? "" : cached;

    let read = file::read(path);
    ctx.files[path] = read || "\v";
    return read;
}

pub fn getModule(
    implicit ctx: &mut Context,
    fname: string)
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    ctx.modules.push(Module(modid: i, :fname));
    return ctx.modules[i];
}

pub fn setModule(
    implicit ctx: &mut Context,
    module: Module)
{
    ref current = ctx.modules[module.modid];
        current.fname == module.fname || assert();
        current = module.clone();
}


//

pub fn lookupStruct(
    implicit module: Module,
    implicit ctx: Context,
    type: Type)
{
    if (type.modid == module.modid)
        return module.out.types[type.canon]
            || assert();

    return ctx.modules[type.modid].out.types[type.canon]
        || assert();
}

pub fn lookupTypeImports(type: Type)
    type.isStruct && lookupStruct(type).imports;

pub fn lookupTypeConverts(type: Type)
    type.isStruct && lookupStruct(type).converts;
