import helpers;
import module;
import structs;
import quals;


//

pub fn _token(implicit ctx: Context, idx: TokenIdx): Token
    ctx.modules[idx.modid].in.lex.tokens[idx.tokidx];

pub fn _fname(implicit ctx: Context, idx: TokenIdx): string
    ctx.modules[idx.modid].fname;

pub fn lookupUserType_mut(implicit ref module: Module, canon: string)
{
    let scp = parseStructCanon(canon);
    scp.modid == module.modid || throw("lookupUserType_mut: Not from this module (" ~ module.modid ~ ": " ~ canon ~ ")");
    return module.out.types[scp.index];
}


//

fn resolveFile(
    implicit ref ctx: Context,
    from: string, name: string): string
{
    let path    = from ~ name;
    let cached  = ctx.fuzzy.map::get(path);
    if (cached)
        return cached == "\v" ? "" : cached;

    fn tryResolve(): string
    {
        let check = |shadow path: string|
        {
            let exists = file::size(path) >= 0;
            if (exists)
                return path;
        };

        check(path);
        check(from ~    "lib/" ~ name);
        check(from ~ "fu/lib/" ~ name);

        // Finally, try lib/x/x.fu
        if (name.ends(with: ".fu"))
        {
            let ext = name.len - 3;

            mut dir = 0;
            for (mut i = ext; i --> 0; ) {
                if (name[i] == '/') {
                    dir = i + 1;
                    break;
                }
            }

            shadow let name = name[0,   dir]
                            ~ name[dir, ext] ~ '/'
                            ~ name[dir, name.len];

            check(from ~ name);
            check(from ~    "lib/" ~ name);
            check(from ~ "fu/lib/" ~ name);
        }

        /////////////////////////////////
        let fallback = from.path::dirname;
        if (!fallback || fallback.len >= from.len)
            return "";

        return resolveFile(
            from: fallback, :name);
    };

    let resolve = tryResolve();
    ctx.fuzzy.map::set(path, resolve || "\v");
    return resolve;
}

pub fn resolveFile(
    implicit ref ctx: Context,
    path: string): string
{
    let fuzzy = path.find('\v');
    if (fuzzy > 0)
    {
        let from = path.slice(0, fuzzy);
        let name = path.slice(fuzzy + 1);
        if (from && name && !name.has('\v'))
        {
            let res = resolveFile(:from, :name);
            if (res)
                return res;

            // Tests have the files prepopulated,
            //  we only pay the cost of lookup when about to fail compile.
            let prepopulated = from ~ name;
            if (ctx.files.map::has(prepopulated))
                return prepopulated;
        }
    }

    return path;
}

pub fn resolveFile_x(
    implicit ctx: Context,
    path: string)
{
    // TODO FIX
    let clean = path.replace(all: "\v", "");
    let match = ctx.fuzzy.map::get(clean);

    return match && match != "\v"
         ? match
         : clean;
}


//

pub fn getFile(
    implicit ref ctx: Context,
    mut path: string): string
{
    let cached = ctx.files.map::get(path);
    if (cached)
        return cached == "\v" ? "" : cached;

    let read = file::read(path);
    ctx.files.map::set(path, read || "\v");
    return read;
}

pub fn getModule(
    implicit ref ctx: Context,
    fname: string)
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    ctx.modules.push(Module(modid: i, :fname));
    return ctx.modules[i];
}

pub fn setModule(
    implicit ref ctx: Context,
    module: Module)
{
    ref current = ctx.modules[module.modid];
    current.fname == module.fname || assert();
    current = module.clone();
}


//

pub fn lookupUserType(
    implicit module: Module,
    implicit ctx: Context,
    type: ValueType)
{
    let scp = parseStructCanon(type.canon);

    if (scp.modid == module.modid)
        return module.out.types[scp.index]
            || assert();

    return ctx.modules[scp.modid].out.types[scp.index]
        || assert();
}

pub fn is_trivial(type: ValueType)
    type.is_primitive || type.isStruct && lookupUserType(type).all_triv;


//

pub fn tryLookupUserType(type: ValueType): Struct
{
    if (type.isStruct || type.is_primitive && type.canon.quals::basePrimPrefixLen() < type.canon.len)
        return lookupUserType(type);

    return [];
}

pub fn lookupTypeImports(type: ValueType)
    tryLookupUserType(type).imports;

pub fn lookupTypeConverts(type: ValueType)
    tryLookupUserType(type).converts;


//

pub fn getFlatCount(type: ValueType): i32
{
    if (!type.isStructOrUnion)
        return 1;

    return tryLookupUserType(type).flatCount;
}


//

pub fn getModuleSrc(implicit ctx: Context, modid!: i32)
{
    return ctx.modules[modid].in.src;
}

pub fn formatTokenCoord(token: TokenIdx, from!: i32)
{
    return formatTokenCoord(
        fname: from != token.modid && token._fname,
        token: token._token);
}

pub fn formatTokenCoord(fname!: string, token: LineColChars)
{
    let lcc     = token.line ~ ":" ~ token.col ~ "+" ~ token.chars;
    if (!fname)
        return ansi::DIM ~ lcc ~ ansi::RESET;

    let dir     = path::dirname(fname);
    let file    = fname.slice(dir.len, fname.len);
    let ext     = path::ext(file);
    let noext   = file.slice(0, file.len - ext.len);

    return ansi::DIM ~ dir ~ ansi::RESET
         ~ noext
         ~ ansi::DIM
         ~ ext ~ " " ~ lcc
         ~ ansi::RESET;
}

pub flags CodeFmt
{
    NoLeadContext
    NoTailContext
    NoContext
};

pub fn formatCodeSnippet(src!: string, token: LineColChars, fmt?: CodeFmt): string
{
    return formatCodeSnippet(:src, :fmt, highlight: [ token ]);
}

pub fn formatCodeSnippet(src!: string, fmt?: CodeFmt, mut highlight!: LineColChars[])
{
    // TODO should be able to sort without the < 0, moronic
    highlight.sort(
        |a, b| (a.line - b.line || a.col - b.col) < 0);

    for (mut i = highlight.len - 1; i --> 0; )
    {
        let a = highlight[i];
        let b = highlight[i + 1];

        if (a.line != b.line)
        {
            a.line < b.line || assert();
            continue;
        }

        // Discard duplicate / overlapping tokens.
        if (a.col + a.chars > b.col)
            highlight.splice(i, 1);
    }

    if (!highlight)
        return "";

    //
    let lines   = src.split("\n");

    let start   = highlight.first;
    let end     = highlight.last;

    mut l_start = start.line - 1;  // lines are 1 based.
    mut l_end   =   end.line;

    l_start     = l_start.min(lines.len).max(0);
    l_end       = l_end  .min(lines.len).max(0);

    mut result  = "";

    let leadContext = fmt & (NoContext | NoLeadContext) ? 0 : 2;
    let tailContext = fmt & (NoContext | NoTailContext) ? 0 : 2;

    // Leading context lines.
    for (mut i = max(0, l_start - leadContext); i < l_start; i++)
    {
        result ~= ansi::DIM ~ "      | ";
        result ~= lines[i];
        result ~= ansi::RESET ~ "\n";
    }

    // Highlighted lines.
    for (mut i = l_start; i < l_end; i++)
    {
        mut line = lines[i];
        let line_no = i + 1;

        // Numbered line margins.
        {
            mut margin = line_no ~ " | ";
            while (margin.len < 8)
                margin = " " ~ margin;

            result ~= ansi::DIM ~ margin ~ ansi::RESET;
        }

        // Highlight error tokens on this line.
        for (shadow mut i = highlight.len; i --> 0; )
        {
            let token = highlight[i];
            if (token.line == line_no)
            {
                let c0 = (token.col - 1     ).max(0       );
                let c1 = (c0 + token.chars  ).min(line.len);

                line.splice(c1, 0, ansi::RESET);
                line.splice(c0, 0, ansi::BAD);
            }
        }

        result ~= line ~ "\n";
    }

    // Trailing context lines.
    for (mut i = l_end; i < min(lines.len, l_end + tailContext); i++)
    {
        result ~= ansi::DIM ~ "      | ";
        result ~= lines[i];
        result ~= ansi::RESET ~ "\n";
    }

    return result;
}

pub fn formatCodeSnippet(mut tokens: TokenIdx[], from!: i32, fmt?: CodeFmt)
{
    tokens.sort(|a, b| a.modid < b.modid);

    mut append = "";
    for (mut i = 0; i < tokens.len - 1; i++)
    {
        let a = tokens[i];
        let b = tokens[i + 1];

        if (a.modid != b.modid)
        {
            append ~= "\n";
            append ~= formatCodeSnippet(tokens.slice(i + 1), :from);
            tokens.shrink(i + 1);
            break;
        }
    }

    let head = tokens.if_first;
    if (!head)
        return append;

    //
    mut result = "";
    result ~= formatTokenCoord(head, :from);
    result ~= ":\n";

    if !(fmt & (NoContext | NoLeadContext))
        result ~= "\n";

    //
    mut highlight: LineColChars[] = [];
    for (mut i = 0; i < tokens.len; i++)
        highlight.push(tokens[i]._token.lcc);

    let src = getModuleSrc(:head.modid);
    result ~= formatCodeSnippet(:src, :fmt, :highlight);

    //
    result ~= append;
    return result;
}


//

pub fn getShortModuleName(fname: string)
{
    // fname.ends(with: ".fu") || assert();
    let end = fname.len - 3;

    mut found = false;
    for (mut i = end; i --> 0; )
    {
        let c = fname[i];
        if (c != '/')
            continue;

        if (found)
            return fname.slice(i + 1, end);

        found = true;
    }

    assert();
}
