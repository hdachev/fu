import helpers;
import context;
import stat;
import options;
import module;


//

pub fn compile(fname: string, via: string = "")
{
    let implicit mut module = getModule(fname).clone();

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = ModuleOutputs;

        let src = getFile(fname) || throw (
            "import badfile: `" ~ via ~ fname ~ "`.");

        let stat0 = ModuleStat_now();
        let lexer_result = lexer::lex(:fname, :src);

        let stat1 = ModuleStat_now();
        let parser_result = parser::parse(
            :module.modid, :fname, :src, :lexer_result.tokens);

        let stat2 = ModuleStat_now();

        module.in = ModuleInputs(
            :src, lex: lexer_result,
            parse: parser_result);

        // Stat.
        module.stats.lex   = stat1 - stat0;
        module.stats.parse = stat2 - stat1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            "import circle: `" ~ fname ~ "\n\t<- " ~ via ~ "`.");
    }

    // We're good to go here.
    if (!module.out)
    {
        module.out.init_prio = 1;

        // Ensure dependencies.
        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
        {
            let prio =
                compile(
                    fname: resolveFile(fuzimports[i]),
                      via: fname ~ (via && "\n\t<- " ~ via));

            if (module.out.init_prio < prio)
                module.out.init_prio = prio;
        }

        //
        let stat0 = ModuleStat_now();
        module.out.solve = solver::solve();

        let stat1 = ModuleStat_now();
        module.out.cpp = codegen::cpp_codegen();

        let stat2 = ModuleStat_now();

        module.stats.solve   = stat1 - stat0;
        module.stats.codegen = stat2 - stat1;

        // Final repersist.
        setModule(module);
    }

    //
    return module.out.init_prio
        + (module.out.solve.notes & flags::N_SD_HasStaticInit && 1);
}


//

fn absdir(a: string)
    a.if_last == '/' ? a : a ~ '/';

let HOME = absdir(env::get("HOME"));

pub fn locate_FUDIR(): string
{
    let dir = HOME ~ "fu/";
    let fn = dir  ~ "src/compiler.fu";
    let fs = file::size(fn);
    fs > 1000 || throw("Bad compiler.fu: " ~ fn ~ ": " ~ fs);

    println("FUDIR: " ~ dir);
    return dir;
}

pub let FUDIR              = locate_FUDIR();
pub let DEFAULT_WORKSPACE   = FUDIR ~ "build-cpp/";


//

pub fn compile_and_build(

    fname!:     string,
    dir_wrk!:   string,

    //
    bin     !?: string,
    dir_obj !?: string,
    dir_src !?: string,
    dir_cpp !?: string,
    scheme  !?: string,

    // TODO clean these up, this makes NO SENSE //
    run     !?: bool,
    shared  !?: bool,
    hotswap !?: bool,
    //////////////////////////////////////////////

    flags_cc!?: string[],
    flags_ld!?: string[])
{
    let implicit mut ctx = prelude::CTX_PRELUDE.clone();
    let implicit options: Options;

    {
        println("COMPILE ", fname);

        let t0 = now::hr();
        compile(:fname);
        let t1 = now::hr();
        let tt = t1 - t0;

        if (t1 - t0 > 0.025)
        {
            mut lex:        ModuleStat;
            mut parse:      ModuleStat;
            mut solve:      ModuleStat;
            mut codegen:    ModuleStat;

            ref m = ctx.modules;
            for (mut i = 0; i < m.len; i++)
            {
                lex     += m[i].stats.lex;
                parse   += m[i].stats.parse;
                solve   += m[i].stats.solve;
                codegen += m[i].stats.codegen;
            }

            ModuleStat_print(lex,   "\n    lex ");
            ModuleStat_print(parse,   "  parse ");
            ModuleStat_print(solve,   "  solve ");
            ModuleStat_print(codegen, "codegen ", "\n");
        }

        println("        ", tt, "s\n");
    }

    return ::build(
        :ctx, :run, :shared, :hotswap, :bin, :scheme,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp,
        :flags_cc, :flags_ld,
        unity: fname,
        fudir: FUDIR);
}
