// expect_lambda

let WARN_ON_IMPLICIT_COPY   = false;
let WRITE_COMPILER          = true;

// #import 'hello';


// Having fun.

fn last(s: string)
    s.len   ? s[s.len - 1]
            : '';

fn only(s: $T[]): $T
    s.len == 1 ? s[0] : throw (
        'LEN != 1: ' + s.len);

fn hasIdentifierChars(id: string)
{
    for (mut i = 0; i < id.len; i++)
    {
        let c = id[i];
        if (c == '_' || c >= 'a' && c <= 'z'
                     || c >= 'A' && c <= 'Z'
                     || c >= '0' && c <= '9')
        {
            return true;
        }
    }

    return false;
}

fn path_ext(path: string): string
{
    for (mut i = path.len; i --> 0; )
    {
        let c = path[i];
        if (c == '.') return path.slice(i);
        if (c == '/') break;
    }

    return '';
}

fn path_dirname(path: string): string
{
    for (mut i = path.len; i --> 0; )
        if (path[i] == '/')
            return path.slice(0, i + 1);

    return '';
}

fn path_normalize(p: string): string {
    mut path = p.split('/');

    for (mut i = path.len; i --> 0; ) {
        let part = path[i];
        if (part == '.' || !part && i > 0 && i < path.len - 1)
            path.splice(i, 1);
    }

    for (mut i = 1; i < path.len; i++) {
        if (path[i] == '..')
            path.splice(--i, 2);
    }

    return path.join('/');
}

fn path_join(a: string, b: string)
    b && b[0] == '/'    ? b
                        : path_normalize(a + '/' + b);



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Lexer.

let OPTOKENS = '{}[]()!?~@#$%^&*/-+<=>,.;:|';

let OPERATORS =
[
    '+', '++', '-', '--',
    '*', '**', '/', '%',
    '<', '<<', '<<<', '>', '>>', '>>>',
    '===', '==', '!=', '!==', '<=', '>=', '=>', '->', '<=>',
    '!', '?', '??',
    '.', '..', '...', ':', '::', ',', ';',
    '&', '&&', '|', '||', '^', '~',
    '{', '}', '[', ']', '(', ')', '[]',
    '=',
    '+=', '-=', '*=', '**=', '/=', '%=',
    '&=', '|=', '^=',
    '&&=', '||=',
    '@', '#', '$',
];

struct Token
{
    kind:   string;
    value:  string;
    fname:  string;

    idx0:   i32;
    idx1:   i32;
    line:   i32;
    col:    i32;
};

struct LexerOutput
{
    fname:  string;
    tokens: Token[];
};

fn lex(src: string, fname: string): LexerOutput
{
    let end     = src.len;
    mut line    = 1;
    mut lidx    = -1;
    mut idx     = 0;

    mut tokens: Token[];

    fn token(kind: string, value: string, idx0: i32, idx1: i32)
    {
        let col = idx0 - lidx;

        tokens.push(
            Token(  :kind, :value, :idx0, :idx1,
                    :fname, :line, :col ));
    }

    fn err_str(kind: string, idx0: i32, reason: string)
    {
        // exit to nearest whitespace
        while (idx < end && src[idx] > ' ')
            idx++;

        let col = idx0 - lidx;
        let value = src.slice(idx0, idx);

        throw('LEX ERROR: ' + fname + '@' + line + ':' + col
            + ':\n\t' + reason
            + '\n\t' + kind + ': `' + value + '`');
    }

    fn err(kind: string, idx0: i32, reason: i32)
    {
        err_str(kind, idx0, src[reason]);
    }

    fn checkNum(kind: string, src: string): string
    {
        ////////////
        //  TODO  //
        ////////////

        if (src) {} // unused

        return kind;
    }

    fn unescapeStr(src: string, idx0: i32, idx1: i32): string
    {
        mut out = '';

        let n = idx1 - 1;
        for (mut i = idx0 + 1; i < n; i++)
        {
            let c = src[i];
            if (c == '\\')
            {
                let c1 = src[++i];

                if      (c1 == 'n') out += '\n';
                else if (c1 == 'r') out += '\r';
                else if (c1 == 't') out += '\t';
                else if (c1 == 'v') out += '\v';
                else                out += c1;
            }
            else
            {
                out += c;
            }
        }

        return out;
    }

    while (idx < end)
    {
        let idx0 = idx;
        let c = src[idx++];

        // whitespace
        if (c <= ' ')
        {
            if (c == '\n')
            {
                line++;
                lidx = idx - 1;
            }
        }

        // identifiers & keywords
        else if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_')
        {
            while (idx < end)
            {
                let c = src[idx++];
                if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c >= '0' && c <= '9')
                {
                    //
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let idx1 = idx;

            token(
                'id', src.slice(idx0, idx1),
                idx0, idx1);
        }

        // numeric literals
        else if (c >= '0' && c <= '9')
        {
            mut hex = false;
            mut dot = false;
            mut exp = false;

            if (c == '0' && idx < end && src[idx] == 'x')
            {
                hex = true;
                idx++;
            }

            while (idx < end)
            {
                let c = src[idx++];

                if (c >= '0' && c <= '9')
                {
                    //
                }
                else if (c == '.')
                {
                    if (hex || dot || exp)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }

                    dot = true;
                }
                else if ((c == 'e' || c == 'E') && !hex)
                {
                    if (hex || exp)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }

                    if (idx < end && (src[idx] == '-' || src[idx] == '+'))
                        idx++;

                    exp = true;
                }
                else if (c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F')
                {
                    if (!hex)
                    {
                        err('num', idx0, idx - 1);
                        break;
                    }
                }
                else
                {
                    idx--;
                    break;
                }
            }

            let trail = src[idx - 1];
            if (!(trail >= '0' && trail <= '9') &&
                !(hex && (trail >= 'a' && trail <= 'f'
                       || trail >= 'A' && trail <= 'F')))
            {
                err('num', idx0, idx - 1);
            }
            else
            {
                let idx1 = idx;
                let str = src.slice(idx0, idx1);

                token(
                    checkNum(dot || exp ? 'num' : 'int', str), str,
                    idx0, idx1);
            }
        }

        // string literals
        else if (c == '\'' || c == '"' || c == '`')
        {
            mut esc = false;
            mut ok  = false;

            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == c)
                {
                    ok = true;
                    break;
                }
                else if (c1 == '\\')
                {
                    esc = true;
                    idx++;
                }
                else if (c1 == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
            }

            if (!ok)
            {
                err_str('str', idx0, 'Unterminated string literal.');
            }
            else
            {
                let idx1 = idx;
                let str  = esc  ? unescapeStr(src, idx0, idx1)
                                : src.slice(idx0 + 1, idx1 - 1);

                token(
                    'str', str,
                    idx0, idx1);
            }
        }

        // comments
        else if (c == '/' && idx < end && src[idx] == '/')
        {
            idx++;
            while (idx < end)
            {
                let c1 = src[idx++];
                if (c1 == '\n')
                {
                    line++;
                    lidx = idx - 1;
                    break;
                }
            }
        }

        // multiline comments
        else if (c == '/' && idx < end && src[idx] == '*')
        {
            idx++;
            while (idx < end)
            {
                let c = src[idx++];
                if (c == '\n')
                {
                    line++;
                    lidx = idx - 1;
                }
                else if (c == '*' && idx < end && src[idx] == '/')
                {
                    idx++;
                    break;
                }
            }
        }

        // operators
        else if (OPTOKENS.has(c))
        {
            while (idx < end)
            {
                let c = src[idx++];
                if (!OPTOKENS.has(c))
                {
                    idx--;
                    break;
                }
            }

            // split off adjacent operators
            {
                mut begin   = idx0;
                mut end     = idx;
                while (begin < end)
                {
                    let candidate = src.slice(begin, end);
                    let ok = OPERATORS.has(candidate);
                    if (end > begin + 1 && !ok)
                    {
                        end--;
                        continue;
                    }

                    if (!ok)
                        err('op', begin, end);
                    else
                        token(
                            'op', candidate,
                            begin, end);

                    begin = end;
                    end = idx;
                }
            }
        }

        // dunno
        else
        {
            err('?', idx0, idx0);
        }
    }

    // end of file token
    line++;
    lidx = idx + 0;

    token(
        'eof', 'eof',
        idx, idx);

    // err, data
    return LexerOutput( :fname, :tokens );
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Parser.

pub struct Node
{
    kind:       string;
    flags:      i32;
    value:      string;
    items:      Node[];
    token:      Token;
};


// Calltypes, probably an enum is better for the 4 kinds,
//  can't be mixed and matched.

pub let F_METHOD       = 1 << 0;
pub let F_INFIX        = 1 << 1;
pub let F_PREFIX       = 1 << 2;
pub let F_POSTFIX      = 1 << 3;
pub let F_ACCESS       = 1 << 4;
pub let F_ID           = 1 << 5;
pub let F_INDEX        = 1 << 6;

pub let F_LOCAL        = 1 << 8;
pub let F_ARG          = 1 << 9;
pub let F_FIELD        = 1 << 10;

pub let F_MUT          = 1 << 16;
pub let F_IMPLICIT     = 1 << 17;
pub let F_USING        = 1 << 18;

pub let F_UNTYPED_ARGS = 1 << 24;
pub let F_NAMED_ARGS   = 1 << 25;
pub let F_FULLY_TYPED  = 1 << 26;
pub let F_CLOSURE      = 1 << 27;
pub let F_HAS_CLOSURE  = 1 << 28;
pub let F_PATTERN      = 1 << 29;
pub let F_TEMPLATE     = 1 << 30;
pub let F_DESTRUCTOR   = 1 << 31;


// Operator precedence table.

let P_RESET           = 1000;
let P_PREFIX_UNARY    = 3   ;

let PREFIX:  string[] = [ '++', '+', '--', '-', '!', '~', '?', '*', '&', '&mut' ];
let POSTFIX: string[] = [ '++', '--', '[]' ];

struct BINOP {
    PRECEDENCE:     Map(string, i32);
    RIGHT_TO_LEFT:  Map(i32,   bool);
};

fn setupOperators()
{
    mut out: BINOP;

    mut precedence  = P_PREFIX_UNARY;
    mut rightToLeft = false;

    fn binop(ops: string[])
    {
        precedence++;
        out.RIGHT_TO_LEFT[precedence] = rightToLeft;

        for (mut i = 0; i < ops.len; i++)
            out.PRECEDENCE[ops[i]] = precedence;
    }

    binop([ 'as', 'is' ]);

    rightToLeft = true;
    binop([ '**' ]);

    rightToLeft = false;
    binop([ '*', '/', '%' ]);
    binop([ '+', '-' ]);
    binop([ '<<', '>>' ]);
    binop([ '&' ]); // Notice this is not js/c precedence, it's just never usefu]l.
    binop([ '^' ]); // We're doing the rust thing her]e.
    binop([ '|' ]);
    binop([ '<', '<=', '>', '>=' ]);
    binop([ '==', '!=', '<=>' ]);
    binop([ '->' ]);
    binop([ '&&' ]);
    binop([ '||' ]);

    rightToLeft = true;
    binop([ '?' ]);
    binop([ '=', '+=', '-=', '**=', '*=', '/=', '%=', '<<=', '>>=', '&=', '^=', '|=', '||=', '&&=' ]);

    rightToLeft = false;
    binop([ ',' ]);

    //
    return out;
}

let BINOP     = setupOperators();
let P_COMMA   = BINOP.PRECEDENCE[','] || assert();


// Commons.

pub let LET_TYPE       = 0;
pub let LET_INIT       = 1;

pub let FN_RET_BACK    = -2;
pub let FN_BODY_BACK   = -1;
pub let FN_ARGS_BACK   = FN_RET_BACK;

pub let LOOP_INIT      = 0;
pub let LOOP_COND      = 1;
pub let LOOP_POST      = 2;
pub let LOOP_BODY      = 3;
pub let LOOP_POST_COND = 4;


//

pub struct ParserOutput
{
    root:       Node;
    imports:    string[];
}

pub fn parse(fname: string, _tokens: Token[]): ParserOutput
{
    mut _idx        = 0;
    mut _loc: Token = _tokens[0];
    mut _col0       = 0;
    mut _precedence = P_RESET;
    mut _fnDepth    = 0;
    mut _numReturns = 0;
    mut _implicits  = 0;
    mut _structName = '';
    mut _dollars    : string[];
    mut _imports    : string[];


    //

    fn fail(mut reason: string = '')
    {
        let here = _tokens[_idx];

        if (!reason)
            reason = 'Unexpected `' + here.value + '`.';

        let l0 = _loc.line;
        let c0 = _loc.col;

        let l1 = here.line;
        let c1 = here.col;

        let addr = l1 == l0
            ? '@' + l1 + ':' + c1
            : '@' + l0 + ':' + c0 + '..' + l1 + ':' + c1;

        return throw(fname + ' ' + addr + ':\n\t' + reason);
    }

    fn fail_Lint(reason: string)
    {
        // TODO allow opt out
        return fail('Lint: ' + reason);
    }

    fn make(
        kind:  string,
        items: Node[] = [],
        flags: i32    =  0,
        value: string = '')
    {
        return Node(
            :kind, :flags, :value, :items,
                token: _loc || throw('no loc'));
    };

    fn miss() Node();


    //

    fn consume(kind: string, value: string = ''): Token
    {
        let token = _tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return fail('Expected `' + (value || kind) + '`, got `' + token.value + '`.');
    }

    fn tryConsume(kind: string, value: string = ''): Token
    {
        let token = _tokens[_idx];
        if (token.kind == kind && (!value || token.value == value))
        {
            _idx++;
            return token;
        }

        return Token();
    }


    //

    fn parseRoot(): Node
    {
        _loc = _tokens[_idx];

        mut out = make('root',
            parseBlockLike('eof', 'eof'));

        if (_implicits)
            out.flags |= F_IMPLICIT;

        return out;
    }


    //

    fn parseBlock(): Node
    {
        return createBlock(
            parseBlockLike('op', '}'));
    }

    fn createBlock(items: Node[]): Node
    {
        return make('block', items);
    }


    //

    fn parseStructDecl(): Node
    {
        let name = tryConsume('id');
        let id = name && name.value || fail('Anon structs.');

        ////////////////////////////////
        let structName0 = _structName;
        _structName = id;

        consume('op', '{');
        let items = parseBlockLike(
            'op', '}', 'struct');

        _structName = structName0;
        //////////////////////////

        return make(
            'struct', items, 0,
                name ? name.value : '');
    }

    fn parseStructItem(): Node
    {
        //////////////////////////////
        let token = _tokens[_idx++];

        if (token.kind == 'op' || token.kind == 'id')
            if (token.value == 'fn')
                return parseStructMethod();

        _idx--;
        //////////////////////////////

        mut member = parseLet();
        member.flags |= F_FIELD;

        consume('op', ';');
        return member;
    }

    fn parseStructMethod(): Node
    {
        mut fnNode = parseFnDecl();

        // `this` arg annotation -
        //  -----------------------------------
        //  Now what the fuck is happening here -
        //      how do we deal with const/mut here?
        //  --------------------------------------------------------
        //  We dont want cpp-style double definitions for everything,
        //      so how do we go about this?

        let typeAnnot =
            createPrefix('&',
                createRead(_structName || fail()));

        fnNode.items.unshift(
            createLet('this', F_USING, typeAnnot, miss));

        fnNode.flags |= F_METHOD;
        return fnNode;
    }


    //

    fn parseBlockLike(
        endKind: string, endVal: string,
        mode: string = ''): Node[]
    {
        let line0 = _tokens[_idx].line;
        let col00 = _col0;

        mut items: Node[] = [];
        while (true)
        {
            let token = _tokens[_idx];
            if (token.kind == endKind && token.value == endVal)
            {
                // Done.
                _col0 = col00;
                _idx++;

                // Style-check, makes for more helpful errors.
                let line1 = token.line;
                let col1  = token.col;

                line1 == line0 || col1 == _col0 || fail_Lint(
                    'Bad closing `' + token.value + '` indent, expecting ' + (_col0 - 1)
                        + ', got ' + (col1 - 1)
                        + '. Block starts on line ' + line0 + '.');

                break;
            }

            _col0 = token.col;

            _col0 > col00 || fail_Lint(
                'Bad indent, expecting more than ' + col00
                    + '. Block starts on line ' + line0 + '.');

            let expr = mode /*== 'struct'*/
                ? parseStructItem()
                : parseStatement();

            expr.kind != 'call'
                || ((expr.flags & (F_ID | F_ACCESS)) == 0)
                || expr.items.len > 1
                || fail_Lint('Orphan pure-looking expression.');

            let exprIdx = items.len;

            // Filter out excess semicolons.
            if (expr.kind != 'empty')
                items.push(expr);

            // Unpacking & ungrouping node types.
            if (expr.kind == 'struct')
                unwrapStructMethods(items, exprIdx);
        }

        return items;
    }

    fn unwrapStructMethods(
        out: &mut Node[], structNodeIdx: i32): void
    {
        mut structNode = out[structNodeIdx];

        let members: &mut Node[] = structNode.items;
        for (mut i = 0; i < members.len; i++)
        {
            let item: &mut Node = members[i];
            if (item.kind == 'fn')
            {
                if (item.value == 'free')
                {
                    structNode.flags |= F_DESTRUCTOR;
                    item.flags |= F_DESTRUCTOR;
                }

                item.items.len >= 2 || fail();
                out.push(item);

                members.splice(i--, 1);
            }
        }

        out[structNodeIdx] = structNode;
    }


    //

    fn parseStatement(): Node
    {
        ///////////////////////////////////////////////
        let loc0  = _loc;
        let token = _loc = _tokens[_idx++] || fail();
        ///////////////////////////////////////////////

        if (token.kind == 'op')
        {
            let v = token.value;

            if (v == '{')           return parseBlock();
            if (v == ';')           return parseEmpty();
            if (v == ':')           return parseLabelledStatement();

            if (v == '#')           return parsePragma();
        }
        else if (token.kind == 'id')
        {
            let v = token.value;

            if (v == 'let')         return parseLetStmt();
            if (v == 'mut')         return (_idx--, parseLetStmt());
            if (v == 'if')          return parseIf();
            if (v == 'return')      return parseReturn();

            if (v == 'for')         return parseFor();
            if (v == 'while')       return parseWhile();
            if (v == 'do')          return parseDoWhile();
            if (v == 'break')       return parseJump('break');
            if (v == 'continue')    return parseJump('continue');

            if (v == 'fn')          return parseFnDecl();
            if (v == 'struct')      return parseStructDecl();

            // Ignore pubs for now.
            if (v == 'pub')         return parseStatement();
        }

        ////////////
        _idx--;
        _loc = loc0;
        ////////////

        // Expression statement, followed by a semi.
        return parseExpressionStatement();
    }

    fn parsePragma(): Node
    {
        let v = consume('id').value;
        if (v == 'import')
            return parseImport();

        return fail('Unknown #pragma: `' + v + '`.');
    }

    fn parseImport(): Node
    {
        mut value = consume('str').value;
                    consume('op', ';');

        if (!value.path_ext)     value += '.fu';
        if (!value.path_dirname) value = './' + value;

        value = path_join(
            path_dirname(fname), value);

        if (!_imports.has(value))
            _imports.push(value);

        return make('import', :value);
    }

    fn parseLabelledStatement(): Node
    {
        let label = consume('id');
        mut stmt  = parseStatement();

        if (stmt.kind == 'loop')
        {
            stmt.value && fail();
            stmt.value = label.value || fail();
            return stmt;
        }

        return fail();
    }

    fn parseEmpty(): Node
    {
        return make('empty');
    }

    fn parseExpressionStatement(): Node
    {
        let expr = parseExpression(P_RESET);
        consume('op', ';');
        return expr;
    }

    fn parseFnDecl(): Node
    {
        ////////////////////////////////
        let dollars0    = _dollars;
        let numReturns0 = _numReturns;
        ////////////////////////////////

        // fn hello(), fn +()
        let name = tryConsume('id')
                || tryConsume('op');

        // Opening parens.
        consume('op', '(');

        mut items: Node[];
        mut flags = parseArgsDecl(items, 'op', ')');

        ////////////////////////////////
        _fnDepth++;
        ////////////////////////////////

        // Return type annot.
        mut type = tryPopTypeAnnot();
        let retIdx = items.len;
        items.push(type);

        // Body or pattern (case/case).
        flags |= parseFnBodyOrPattern(items);

        // Inject `: void` annot here, easy,
        //  one less thing to deal with later.
        if (!type && _numReturns == numReturns0)
            items[retIdx] = type = createRead('void');

        if (type)
            flags |= F_FULLY_TYPED;

        ////////////////////////////////
        {
            _fnDepth--;
            _numReturns = numReturns0;

            if (_dollars.len > dollars0.len)
                flags |= F_TEMPLATE;

            _dollars = dollars0;
        }
        ////////////////////////////////

        return make('fn', items, flags, name.value);
    }

    fn parseFnBodyOrPattern(
        out_push_body: &mut Node[]): i32
    {
        mut flags = 0;
        mut body: Node;
        //

        if (tryConsume('id', 'case'))
        {
            mut branches: Node[] = [];

            flags |= F_PATTERN;

            do
            {
                let cond = parseUnaryExpression();
                let type = tryPopTypeAnnot();
                let body = parseFnBodyBranch();

                branches.push(
                    make('fnbranch', [ cond, type, body ]));
            }
            while (tryConsume('id', 'case'));

            body = make('pattern', branches);
        }
        else
        {
            body = parseFnBodyBranch();
        }

        //
        out_push_body.push(body);
        return flags;
    }

    fn parseFnBodyBranch(): Node
    {
        let body = parseStatement();

        return body.kind == 'block' || body.kind == 'return'
             ? body
             : (_numReturns++, createReturn(body));
    }

    fn tryPopTypeAnnot(): Node
    {
        return tryConsume('op', ':')
             ? parseTypeAnnot()
             : miss;
    }

    fn parseTypeAnnot(): Node
    {
        return parseUnaryExpression();
    }

    fn parseArgsDecl(
        outArgs: &mut Node[],
        endk: string, endv: string): i32
    {
        mut first = true;
        mut outFlags = 0;

        mut implicit: Node[];
        mut defaults = false;

        while (true)
        {
            if (tryConsume(endk, endv))
                break;

            if (!first)
                consume('op', ',');

            first = false;

            mut arg = parseLet();

            if (!arg.items[LET_TYPE])
                outFlags |= F_UNTYPED_ARGS;

            if (arg.items[LET_INIT])
            {
                if (arg.flags & F_IMPLICIT)
                    fail('TODO default implicit arguments');

                defaults = true;
            }
            else if (defaults)
            {
                fail('TODO non-trailing default arguments');
            }

            arg.flags &= ~F_LOCAL;
            arg.flags |= F_ARG;

            if (arg.flags & F_IMPLICIT)
                implicit.push(arg);
            else
                outArgs.push(arg);
        }

        // Ensures implicit arguments always come last.
        if (implicit)
            for (mut i = 0; i < implicit.len; i++)
                outArgs.push(implicit[i]);

        return outFlags;
    }

    fn parseLetStmt(): Node
    {
        let ret = parseLet();

        // Catch here.
        if (tryConsume('id', 'catch'))
        {
            let err = createLet(
                consume('id').value, 0,
                createRead('string'), Node);

            let catch = parseStatement();

            return make('catch', [ ret, err, catch ]);
        }

        consume('op', ';');
        return ret;
    }

    fn parseLet(): Node
    {
        mut flags = F_LOCAL;

        let numDollars0 = _dollars.len;

        if (tryConsume('id', 'using'   )) flags |= F_USING;
        if (tryConsume('id', 'implicit')) flags |= F_IMPLICIT;
        if (tryConsume('id', 'mut'     )) flags |= F_MUT;

        let id      = consume('id').value;
        let type    = tryPopTypeAnnot();
        let init    = tryConsume('op', '=')
                    ? parseExpression(P_COMMA)
                    : Node();

        if (numDollars0 != _dollars.len)
            flags |= F_TEMPLATE;

        if (flags & F_IMPLICIT)
            _implicits++;

        return createLet(id, flags, type, init);
    }

    fn createLet(
        id: string, flags: i32,
        type: Node, init: Node): Node
    {
        return make('let', [ type, init ], flags, id);
    }

    fn parseExpression(p1 = _precedence): Node
    {
        let p0      = _precedence;
        let loc0    = _loc;

        //////////////////////////////
        _precedence = p1;
        _loc        = _tokens[_idx] || fail();
        //////////////////////////////

        mut head    = parseExpressionHead();
        {
            mut out: Node;
            while (out  = tryParseExpressionTail(head))
            {
                _loc    = _tokens[_idx] || fail();
                head    = out;
            };
        }

        //////////////////////////////
        _precedence = p0;
        _loc        = loc0;
        //////////////////////////////

        return head;
    }

    fn tryParseBinary(left: Node, op: string, p1: i32): Node
    {
        if (p1 > _precedence || p1 == _precedence && !BINOP.RIGHT_TO_LEFT[p1])
            return miss;

        // consume
        _idx++;

        mut mid: Node;
        if (op == '?')
        {
            mid = parseExpression();
            consume('op', ':');
        }

        let right = parseExpression(p1);
        if (mid)
            return createIf(left, mid, right);

        // We'll treat these two differently,
        //  no operator overloading for those guys.
        if (op == '||') return createOr (left, right);
        if (op == '&&') return createAnd(left, right);

        //
        return createCall(
            op, F_INFIX, [ left, right ]);
    }

    fn tryParseExpressionTail(head: Node): Node
    {
        // Consume.
        let token = _tokens[_idx++];
        if (token.kind == 'op')
        {
            let v = token.value;

            if (v == ';') return (_idx--, miss);
            if (v == '.') return parseAccessExpression(head);
            if (v == '(') return parseCallExpression(head);
            if (v == '[') return parseIndexExpression(head);

            let p1 = BINOP.PRECEDENCE[v];
            if (p1)
                return (_idx--, tryParseBinary(head, v, p1));

            if (POSTFIX.has(v))
                return createCall(v, F_POSTFIX, [ head ]);
        }

        // Backtrack.
        return (_idx--, miss);
    }

    fn parseExpressionHead(): Node
    {
        //////////////////////////////
        let token = _tokens[_idx++];
        //////////////////////////////

        {
            let k = token.kind;

            // Literals.
            if (k == 'int' || k == 'num' || k == 'str')
                return createLeaf(
                    token.kind, token.value);

            // Identifier expression.
            if (k == 'id')
                return createRead(token.value);

            // Operators.
            if (k == 'op')
            {
                let v = token.value;

                if (v ==  '(') return parseParens();
                if (v ==  '[') return parseArrayLiteral();
                if (v ==  '$') return parseTypeParam();
                if (v ==  '@') return parseTypeTag();
                if (v == '[]') return make('definit');

                return parsePrefix(token.value);
            }
        }

        ///////
        _idx--;
        ///////

        return fail();
    }

    fn parseParens(): Node
    {
        mut items: Node[] = [];

        do
        {
            items.push(parseExpression(P_COMMA));
        }
        while (tryConsume('op', ','));

        consume('op', ')');

        return items.len > 1
             ? createComma(items)
             : items[0];
    }

    fn createComma(nodes: Node[]): Node
    {
        return make('comma', nodes);
    }

    fn parseTypeParam(): Node
    {
        let value = consume('id').value;
        if (!_dollars.has(value))
            _dollars.push(value);

        return createTypeParam(value);
    }

    fn createTypeParam(value: string): Node
    {
        return make('typeparam', :value);
    }

    fn parseTypeTag(): Node
    {
        return createTypeTag(consume('id').value);
    }

    fn createTypeTag(value: string): Node
    {
        return make('typetag', :value);
    }

    fn parsePrefix(mut op: string): Node
    {
        PREFIX.has(op) || (_idx--, fail());

        if (op == '&' && tryConsume('id', 'mut'))
            op = '&mut';

        return createPrefix(
            op, parseUnaryExpression());
    }

    fn parseUnaryExpression(): Node
    {
        return parseExpression(P_PREFIX_UNARY);
    }

    fn createPrefix(op: string, expr: Node): Node
    {
        if (op == '!')
            return createNot(expr);

        return createCall(op, F_PREFIX, [ expr ]);
    }

    fn createNot(expr: Node): Node
    {
        return make('!', [ expr ]);
    }

    fn parseAccessExpression(expr: Node): Node
    {
        return createCall(
            consume('id').value,
            F_ACCESS, [ expr ]);
    }


    //

    fn parseCallArgs(endop: string, out_args: &mut Node[]): i32
    {
        mut flags = 0;

        mut first = true;
        while (true)
        {
            if (tryConsume('op', endop))
                break;

            // Comma juggle.
            if (!first)
            {
                consume('op', ',');

                // Trailing comma -
                //  array literals, fncalls, etc.
                if (tryConsume('op', endop))
                    break;
            }

            first = false;

            // Named arguments.
            mut name = '';
            mut autoName = false;

            if (_tokens[_idx    ] .kind == 'id' &&
                _tokens[_idx + 1] .kind == 'op' &&
                _tokens[_idx + 1].value == ':')
            {
                name = _tokens[_idx].value;
                _idx += 2;

                flags |= F_NAMED_ARGS;
            }
            else if (_tokens[_idx].kind == 'op'
                  && _tokens[_idx].value == ':')
            {
                autoName = true;
                _idx++;

                flags |= F_NAMED_ARGS;
            }

            let expr = parseExpression(P_COMMA);
            if (autoName)
            {
                expr.kind == 'call' && expr.value.hasIdentifierChars
                    || fail('Can\'t :auto_name this expression.');

                name = expr.value;
            }

            out_args.push(
                name    ? createLabel(name, expr)
                        : expr);
        }

        return flags;
    }

    fn createLabel(id: string, value: Node): Node
    {
        return make('label', [ value ], 0, id);
    }

    fn parseCallExpression(expr: Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(')', args);

        // Uniform call syntax.
        if (expr.kind == 'call' && (expr.flags & F_ACCESS))
        {
            let head = expr.items
                    && expr.items.len == 1
                    && expr.items[0] || fail();

            args.unshift(head);

            return createCall(
                expr.value || fail(), F_METHOD | argFlags,
                args);
        }

        if (expr.kind == 'call' && (expr.flags & F_ID))
            return createCall(
                expr.value || fail(), argFlags, args);

        return fail('TODO dynamic call');
    }

    fn parseArrayLiteral(): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(']', args);

        return createArrayLiteral(argFlags, args);
    }

    fn createArrayLiteral(argFlags: i32, items: Node[]): Node
    {
        return make('arrlit', items, argFlags);
    }

    fn parseIndexExpression(expr: Node): Node
    {
        mut args: Node[] = [];
        let argFlags = parseCallArgs(']', args);

        args.unshift(expr);

        return createCall('[]',
            F_INDEX & argFlags, args);
    }

    fn createLeaf(kind: string, value: string): Node
    {
        return make(kind, :value);
    }

    fn createCall(id: string, flags: i32, args: Node[] = []): Node
    {
        return make('call', args, flags, id);
    }

    fn createRead(id: string): Node
    {
        return createCall(id || fail(), F_ID);
    }


    //

    fn parseReturn(): Node
    {
        _fnDepth > 0 || (_idx--, fail());
        _numReturns++;

        if (tryConsume('op', ';'))
            return createReturn();

        return createReturn(
            parseExpressionStatement());
    }

    fn createReturn(node: Node = Node()): Node
    {
        if (!node)
            return make('return');

        return make('return', [ node ]);
    }

    fn parseJump(kind: string /*'break'|'continue'*/): Node
    {
        let label = tryConsume('op', ':')
                 && consume('id');

        let jump = createJump(kind, label.value);
        consume('op', ';');
        return jump;
    }

    fn createJump(kind: string/*'break'|'continue'*/, label: string): Node
    {
        return make(kind, value: label);
    }


    //

    fn parseIf(): Node
    {
        // A little bit of syntactic sugar -
        //  TBD if this is good or not, i'm 50/50.
        //   At least it's unambiguous.
        let not = tryConsume('op', '!');

        consume('op', '(');

        mut cond = parseExpression();
        if (not)
            cond = createNot(cond);

        consume('op', ')');

        let cons = parseStatement();
        let alt  = tryConsume('id', 'else')
                && parseStatement();

        return createIf(cond, cons, alt);
    }


    //

    fn createIf(cond: Node, cons: Node, alt: Node): Node
    {
        return make('if', [ cond, cons, alt ]);
    }

    fn createOr(left: Node, right: Node): Node
    {
        return flattenIfSame('or', left, right);
    }

    fn createAnd(left: Node, right: Node): Node
    {
        return flattenIfSame('and', left, right);
    }

    fn flattenIfSame(kind: string, left: Node, right: Node): Node
    {
        let k_left  =  left.kind;
        let k_right = right.kind;

        let items =
            k_left == kind && k_right == kind
                ? left.items.concat(right.items)
                : k_left == kind
                    ? left.items.concat([ right ])
                    : k_right == kind
                        ? [ left ].concat(right.items)
                        : [ left, right ];

        return make(kind, items);
    }


    //

    fn parseFor(): Node
    {
        consume('op', '(');

        tryConsume('id', 'let');
        let init = parseLetStmt();
        let cond = parseExpressionStatement();

        let token = _tokens[_idx];
        let post = token.kind == 'op' && token.value == ')'
            ? parseEmpty()
            : parseExpression();

        consume('op', ')');
        let body = parseStatement();

        return createLoop(init, cond, post, body, miss);
    }

    fn parseWhile(): Node
    {
        consume('op', '(');
        let cond = parseExpression();
        consume('op', ')');
        let body = parseStatement();

        return createLoop(miss, cond, miss, body, miss);
    }

    fn parseDoWhile(): Node
    {
        let body = parseStatement();
        consume('id', 'while');
        consume('op', '(');
        let cond = parseExpression();
        consume('op', ')');
        consume('op', ';');

        return createLoop(miss, miss, miss, body, cond);
    }

    fn createLoop(init: Node, cond: Node, post: Node, body: Node, postcond: Node): Node
    {
        return make('loop', [ init, cond, post, body, postcond ]);
    }

    // -------------------------------
    // Good to go.

    // Check EOF.
    _tokens[_tokens.len - 1].kind == 'eof' || fail(
        'Missing `eof` token.');

    // PARSE END

    //
    let root = parseRoot();

    return ParserOutput(
        :root, _imports);
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Types.

// pub struct Primitive
//     'i8'  | 'u8'  |
//     'i16' | 'u16' |
//     'i32' | 'u32' |
//     'i64' | 'u64' | 'bool' | 'void' | 'never'
//                   | 'template'
//                   | 'string';

pub let q_mutref        = 1 << 0;
pub let q_ref           = 1 << 1;

pub let q_copy          = 1 << 2;
pub let q_trivial       = 1 << 3;
pub let q_primitive     = 1 << 4;
pub let q_arithmetic    = 1 << 5;
pub let q_integral      = 1 << 6;
pub let q_signed        = 1 << 7;
pub let q_floating_pt   = 1 << 8;

let TAGS =
[
    'mutref',
    'ref',

    'copy',
    'trivial',
    'primitive',

    'arithmetic',
    'integral',
    'signed',
    'floating_point',
];

pub struct Type
{
    canon: string;
    quals: i32;
    modid: i32;
};


//

fn ==(a: Type, b: Type)
    a.modid == b.modid &&
    a.canon == b.canon &&
    a.quals == b.quals;


//

pub let Trivial     = q_copy     | q_trivial     ;
pub let Primitive   = Trivial    | q_primitive   ;
pub let Arithmetic  = Primitive  | q_arithmetic  ;
pub let Integral    = Arithmetic | q_integral    ;
pub let SignedInt   = Integral   | q_signed      ;
pub let UnsignedInt = Integral                   ;
pub let FloatingPt  = Arithmetic | q_floating_pt | q_signed;

pub let t_i8        = Type( 'i8', SignedInt, 0);
pub let t_i16       = Type('i16', SignedInt, 0);
pub let t_i32       = Type('i32', SignedInt, 0);
pub let t_i64       = Type('i64', SignedInt, 0);

pub let t_u8        = Type( 'u8', UnsignedInt, 0);
pub let t_u16       = Type('u16', UnsignedInt, 0);
pub let t_u32       = Type('u32', UnsignedInt, 0);
pub let t_u64       = Type('u64', UnsignedInt, 0);

pub let t_f32       = Type('f32', FloatingPt, 0);
pub let t_f64       = Type('f64', FloatingPt, 0);

pub let t_void      = Type('void', 0, 0);
pub let t_bool      = Type('bool', Primitive, 0);
pub let t_never     = Type('never', 0, 0);
pub let t_template  = Type('template', 0, 0);
pub let t_string    = Type('string', q_copy, 0);


// https://doc.rust-lang.org/nomicon/subtyping.html:

// Re: covariance of `T` in `Box<T>`:
//
// As it turns out, the argument for why it's ok for Box
//  (and Vec, Hashmap, etc.) to be covariant is pretty similar
//   to the argument for why it's ok for lifetimes to be covariant:
//    as soon as you try to stuff them in something like a mutable
//     reference, they inherit invariance and you're prevented
//      from doing anything bad.

pub fn isAssignable(host: Type, guest: Type)
{
    return host.canon == guest.canon
            && (host.quals == guest.quals ||
                  !(host.quals & q_mutref) // mut invariance
                    && (host.quals & guest.quals) == host.quals)
        || guest == t_never
            && guest.quals == 0;
}


//

pub fn isAssignableAsArgument(
    host: Type, mut guest: Type)
{
    guest.quals |= q_ref;
    return isAssignable(host, guest);
}


//

pub fn qadd(type: Type, q: i32)
{
    return Type(type.canon, type.canon ? type.quals | q : 0, type.modid);
}

pub fn qsub(type: Type, q: i32)
{
    return Type(type.canon, type.quals &~ q, type.modid);
}

pub fn qhas(type: Type, q: i32)
{
    return type.quals & q == q;
}

fn tryClear(type: Type, q: i32): Type
{
    if (!type || !qhas(type, q))
        return Type();

    return qsub(type, q);
}


//

pub fn add_ref(type: Type)
{
    return qadd(type, q_ref);
}

pub fn add_mutref(type: Type)
{
    return qadd(type, q_ref | q_mutref);
}


//

pub fn tryClear_mutref(type: Type)
{
    return tryClear(type, q_ref | q_mutref);
}

pub fn tryClear_ref(type: Type)
{
    let t = tryClear(type, q_ref);

    return t
         ? qsub(t, q_mutref)
         : t;
}

pub fn clear_refs(type: Type)
{
    return qsub(type, q_ref | q_mutref);
}

pub fn clear_mutref(type: Type)
{
    return qsub(type, q_mutref);
}

pub fn add_refs_from(src: Type, dest: Type)
{
    return qadd(dest, src.quals & (q_ref | q_mutref));
}


//

pub fn serializeType(type: Type)
{
    if (type.quals)
        return '(' + type.canon + '{' + type.quals + '})';

    return '(' + type.canon + ')';
}

pub fn type_has(type: Type, tag: string)
{
    let idx = TAGS.find(tag);
    idx >= 0 || throw('Unknown type tag: `' + tag + '`.');
    let mask = 1 << idx;
    return (type.quals & mask) == mask;
}


//

pub fn type_tryInter(a: Type, b: Type)
{
    if (a.canon != b.canon)
        return a == t_never ? b
             : b == t_never ? a
             : Type();

    return Type(
        a.canon,
        a.quals & b.quals,
        a.modid);
}


//

pub struct Struct
{
    kind:   string; // 'struct'|'array'|'map';
    id:     string;
    fields: StructField[];
    flags:  i32;
};

pub struct StructField
{
    id:     string;
    type:   Type;
};


// Build service primitives.

pub struct ModuleInputs
{
    src:        string;
    lex:        LexerOutput;
    parse:      ParserOutput;
};

pub struct ModuleOutputs
{
    deps:       i32[];
    types:      Map(string, Struct);        // canon  -> type info
    specs:      Map(string, SolvedNode);    // mangle -> spec
    solve:      SolverOutput;
    cpp:        string;
};

pub struct ModuleStats
{
    s_lex:      f64;
    s_parse:    f64;
    s_solve:    f64;
    s_cpp:      f64;
};

pub struct Module
{
    modid:      i32;
    fname:      string;

    in:         ModuleInputs;
    out:        ModuleOutputs;
    stats:      ModuleStats;
};

fn MODID(implicit module: &Module) {
    return module.modid;
}


// The temp context -
//  TBD what this will look like in the end -
//   we'll likely need a typespace per module,
//    so everyone can read from immut shared concurrently,
//     and write into their own without having to sync.

pub struct TEMP_Context
{
    modules: Module[];
    files: Map(string, string);
};

pub fn getFile(
    implicit ctx: &mut TEMP_Context,
    path: string)
{
    return ctx.files[path] ||= file_read(path);
}

pub fn getModule(
    implicit ctx: &mut TEMP_Context,
    fname: string): &mut Module
{
    for (mut i = 0; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i];

    let i = ctx.modules.len;
    mut module = Module(modid: i);
        module.fname = fname;

    ctx.modules.push(module);
    return ctx.modules[i];
}

pub fn setModule(
    implicit ctx: &mut TEMP_Context,
    module: Module)
{
    let current: &mut Module = ctx.modules[module.modid];
        current.fname == module.fname || assert();
        current = module;
}

pub fn registerType(
    implicit module: &mut Module,
    canon: string, def: Struct): void
{
    module.out.types[canon] = def;
}

pub fn lookupType(
    implicit module: &Module,
    implicit ctx: &TEMP_Context,
    type: Type): &Struct
{
    if (type.modid == module.modid)
        return module.out.types[type.canon]
            || assert();

    return ctx.modules[type.modid].out.types[type.canon]
        || assert();
}

pub fn lookupType_mut(
    implicit module: &mut Module,
    canon: string): &mut Struct
{
    return module.out.types[canon] || assert();
}


//

pub fn initStruct(id: string, flags: i32)
{
    let canon = 's_' + id;
    let def = Struct(
        kind:   'struct',
        id:     id      || throw('TODO anonymous structs?'),
        flags:  flags|0,
    );

    registerType(canon, def);

    return Type(canon, copyOrMove(flags, def.fields), MODID);
}

pub fn finalizeStruct(id: string, fields: StructField[])
{
    let canon = 's_' + id;
    let def: &mut Struct = lookupType_mut(canon);

    def.fields = fields || throw('TODO empty structs?');
}


//

fn copyOrMove(
    flags: i32,
    fields: StructField[]): i32
{
    if (flags & F_DESTRUCTOR || someFieldNonCopy(fields))
        return 0;

    return q_copy;
}

fn someFieldNonCopy(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_copy)
            return true;

    return false;
}

fn someFieldNotTrivial(fields: StructField[]): bool
{
    for (mut i = 0; i < fields.len; i++)
        if !(fields[i].type.quals & q_trivial)
            return true;

    return false;
}


//

pub fn createArray(item: Type): Type
{
    let flags = 0;
    let fields: StructField[] =
    [
        StructField(
            id:  'Item',
            type: item),
    ];

    let canon = 'Array(' + serializeType(item) + ')';

    registerType(canon, Struct(
        kind:   'array',
        id:     canon,
        :fields,
        :flags));

    return Type(canon, copyOrMove(flags, fields), MODID);
}

pub fn type_isString(type: Type): bool
{
    return type.canon == 'string';
}

pub fn type_isArray(type: Type): bool
{
    return type.canon.starts(with: 'Array(');
}

pub fn tryClear_array(type: Type): Type
{
    if (!type_isArray(type))
        return Type();

    let def = lookupType(type);

    return def.kind == 'array'
        && def.fields[0].type
        || assert();
}


//

pub fn type_isMap(type: Type): bool
{
    return type.canon.starts(with: 'Map(');
}

pub fn createMap(key: Type, value: Type): Type
{
    let flags  = 0;
    let fields =
    [
        StructField(id:  'Key',   type: key  ),
        StructField(id:  'Value', type: value),
    ];

    let canon = 'Map(' + serializeType(key) + ',' + serializeType(value) + ')';

    registerType(canon, Struct(
        kind:   'map',
        id:     canon,
        :fields,
        :flags,
    ));

    return Type(canon, copyOrMove(flags, fields), MODID);
}

pub struct MapFields
{
    key:   Type;
    value: Type;
}

pub fn tryClear_map(type: Type): MapFields
{
    if (!type_isMap(type))
        return MapFields();

    let def = lookupType(type);
    def.kind == 'map' || assert();

    return MapFields(
        key:   def.fields[0].type || assert(),
        value: def.fields[1].type || assert());
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Scope.

struct ScopeIdx { raw: i32; };
struct Target { modid: i32; index: ScopeIdx; }

struct SolvedNode
{
    kind:   string;
    flags:  i32;
    value:  string;
    items:  SolvedNode[];
    token:  Token;

    type:   Type;
    target: Target;
};

struct Template
{
    node: Node;
};

struct Partial
{
    via:    Target;
    target: Target;
};

struct Overload
{
    kind: string;
    name: string;
    type: Type;

    // Arity.
    min: i32;
    max: i32;
    args: Type[];
    names: string[];
    defaults: SolvedNode[];

    // Amazing stuff.
    partial: Partial;
    template: Template;
};

struct ScopeItem
{
    id:         string;
    index:      ScopeIdx;
};

pub struct Scope
{
    items:      ScopeItem[];
    overloads:  Overload[];
};


////////////////////////////////

pub fn Scope_lookup(scope: Scope, id: string): Target[]
{
    mut results: Target[] = [];

    let modid = MODID;
    let items = scope.items;
    for (mut i = 0; i < items.len; i++)
    {
        let item = items[i];
        if (item.id == id)
            results.unshift(
                Target(:modid, :item.index));
    }

    return results;
}

pub fn Scope_push(scope: &mut Scope): i32
{
    return scope.items.len;
}

pub fn Scope_pop(scope: &mut Scope, memo: i32): void
{
    scope.items.shrink(memo);
}


////////////////////////////////

pub fn Scope_add(
    scope: &mut Scope,
    kind: string, id: string, type: Type,

    min: i32 = 0,
    max: i32 = 0,
    arg_n: string[]     = [],
    arg_t: Type[]       = [],
    arg_d: SolvedNode[] = [],
    template: Template  = [],
    partial: Partial    = []): Target
{
    let modid = MODID;
    let target = Target(:modid,
        index: ScopeIdx(scope.overloads.len + 1));

    let item = Overload(
        :kind,
        name: id, :type,
        :min, :max, args: arg_t,
        names: arg_n, defaults: arg_d,
        :partial, :template);

    scope.items.push(
        ScopeItem( :id, :target.index ));

    scope.overloads.push(item);

    return target;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub struct SolverOutput
{
    root:   SolvedNode;
    scope:  Scope;
};

fn Scope_Typedef(scope: &mut Scope, id: string, type: Type)
{
    return Scope_add(scope, 'type', id, type);
}


//

fn solve(
    implicit ctx: &TEMP_Context,
    implicit module: &mut Module,
    parse: Node): SolverOutput
{
    // TODO FIX next
    mut _scope: Scope = ctx.modules[0].out.solve.scope;
    mut _here:  Token;

    // Needs template reset.
    mut _current_fn:    SolvedNode;
    mut _typeParams:    Map(string, Type);

    //
    mut TEST_expectImplicits: bool = false;


    //

    fn GET(
        implicit module: Module,
        implicit ctx: TEMP_Context,
        target: Target): Overload
    {
        target.index.raw > 0 || assert();

        if (target.modid == module.modid)
            return _scope.overloads[target.index.raw - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index.raw - 1];
    }

    fn GET_mut(target: Target): &mut Overload
    {
        target.index.raw > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index.raw - 1];
    }

    fn GET_mut(idx: ScopeIdx): &mut Overload
    {
        idx.raw > 0 || assert();
        return _scope.overloads[idx.raw - 1];
    }


    //

    fn fail(mut reason: string = ''): never
    {
        if (!reason)
            reason = 'Unexpected `' + _here.value + '`.';

        let fname = _here.fname;
        let l0    = _here.line;
        let c0    = _here.col;

        let addr = '@' + l0 + ':' + c0;

        return throw(fname + ' ' + addr + ':\n\t' + reason);
    }


    //

    fn Binding(id: string, type: Type)
    {
        return Scope_add(
            _scope, 'var',
            id || fail(), type || fail());
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope, 'field',
            id || fail(), fieldType || fail(),
            1, 1, [ 'this' ], [ structType || fail() ]);
    }

    fn TemplateDecl(node: Node)
    {
        let id = node.value;

        node.kind == 'fn' || fail('TODO');
        let min = node.items.len + FN_ARGS_BACK;

        let max = node.kind == 'fn'
            ? 0xffffff // implicit args etc, dunno whats happening, allow it all
            : min;

        let template = Template(node);

        mut arg_n: string[];
        if (node.kind == 'fn')
        {
            let items = node.items;
            let numArgs = items.len + FN_ARGS_BACK;
            for (mut i = 0; i < numArgs; i++)
            {
                let arg = items[i] || fail();
                arg.kind == 'let' || fail();
                let name = arg.value || fail();
                arg_n.push(name);
            }
        }

        return Scope_add(
            _scope,
            'template', id, t_template,
            min, max, arg_n, :template);
    }

    fn FnDecl(id: string, node: &mut SolvedNode): Target
    {
        let items = node.items;
        let rnode = items[items.len + FN_RET_BACK];
        let ret   = rnode && rnode.type || fail();

        let max   = items.len + FN_RET_BACK;
        let args  = items.slice(0, max);

        mut arg_t: Type[]       = [];
        mut arg_n: string[]     = [];
        mut arg_d: SolvedNode[] = [];

        mut min = 0;
        for (mut i = 0; i < max; i++)
        {
            let arg = args[i]    || fail();
            arg.kind == 'let'    || fail();
            arg_t.push(arg.type  || fail());
            arg_n.push(arg.value || fail());

            //
            let isImplicit = !!(arg.flags & F_IMPLICIT);

            // Non-implicit, non-defaulted argument?
            if (!isImplicit)
            {
                arg_d.len >= i || fail();

                let def = arg.items[LET_INIT];
                arg_d.push(def);
                if (!def)
                    min++;
            }
        }

        let overload = Scope_add(
            _scope,
            'fn', id, ret,
            min, max, arg_n, arg_t, arg_d);

        node.target = overload;

        return overload;
    }

    fn DefaultCtor(id: string, type: Type, members: SolvedNode[])
    {
        mut arg_t:   Type[] = [];
        mut arg_n: string[] = [];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            arg_t.push(member.type  || fail());
            arg_n.push(member.value || fail());
        }

        //
        let max   = members.len;
        mut min   = 0;
        mut arg_d: SolvedNode[];

        {
            for (mut i = 0; i < members.len; i++)
            {
                let member = members[i];

                let init = member.items[LET_INIT]
                        || tryDefaultInit(member.type);

                // Disable defaulting if any member is non-defaulted.
                if (!init)
                {
                    min = max;
                    arg_d.clear();
                    break;
                }

                arg_d.push(init);
            }
        }

        return Scope_add(
            _scope,
            'defctor', id, type,
            min, max, arg_n, arg_t, arg_d);
    }

    fn tryDefaultInit(type: Type): SolvedNode
    {
        // Reference? No init, else default.
        if (type.quals & q_ref)
            return SolvedNode();

        return createDefaultInit(type);
    }

    fn createDefaultInit(type: Type): SolvedNode
    {
        return SolvedNode(
            kind: 'definit',
            token: _here || fail(),
            :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                'Cannot solve definit, no inferred type.');

        return tryDefaultInit(type)
            || fail('Cannot definit: ' + serializeType(type));
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = 'p-unshift';
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut arg_t = overload.args     ? overload.args    .slice(1) : overload.args;
        mut arg_n = overload.names    ? overload.names   .slice(1) : overload.names;
        mut arg_d = overload.defaults ? overload.defaults.slice(1) : overload.defaults;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != 'var')
        {
            kind = 'p-wrap';
            min++;
            max++;

            let via_t = via.args && via.args[0] || fail();

            //
            arg_t.unshift(via_t);
            if (arg_n)
                arg_n.unshift('using');
            if (arg_d)
                arg_d.unshift(SolvedNode());
        }

        return Scope_add(
            _scope,
            kind, id, overload.type,
            min, max, arg_n, arg_t, arg_d,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();
        let modid   = MODID;

        for (mut i = 0; i < _scope.items.len; i++)
        {
            let item = _scope.items[i];

            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                continue;

            let overloadIdx = item.index;
            let overload = GET_mut(overloadIdx);

            // Needs at least one argument.
            if (overload.min < 1)
                continue;

            // TODO using + templates, the fuck do we do?
            if (overload.template)
                continue;

            // See if we fit.
            let expect = overload.args[0] || fail();
            if (!isAssignableAsArgument(expect, actual))
                continue;

            // Enforce no-collide.
            if (overload.min < 2)
            {
                // Scan through -
                //  no other arity-0 entries are allowable.
                for (mut i = 0; i < _scope.items.len; i++)
                {
                    let o = _scope.items[i];
                    if (o.id == item.id)
                    {
                        let other = GET_mut(o.index);
                        if (other.min < 1)
                            fail('`using` ambiguity: `' + item.id + '`.');
                    }
                }
            }

            //
            Partial(item.id, viaIdx,
                Target(:modid, overloadIdx));
        }
    }


    //

    fn getNamedArgReorder(
        names: string[],
        arg_n: string[]): i32[]
    {
        mut result: i32[] = [];

        mut offset = 0;
        for (mut i = 0; i < arg_n.len; i++)
        {
            mut idx = names.find(arg_n[i]);
            if (idx < 0)
            {
                for (mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }

            result.push(idx);
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        return result;
    }

    fn scope_tryMatch__mutargs(
        id: string, args: &mut SolvedNode[],
        flags: i32 = 0, retType: Type = []): Target
    {
        mut matchIdx: Target;

        //
        let overloads = Scope_lookup(_scope, id);
        if (!overloads)
            return matchIdx;

        // Arity 0 - blind head match.
        // Allows simple shadowing of variables and such, latest wins.
        if (!args)
        {
            for (mut i = 0; i < overloads.len; i++)
            {
                let headIdx = overloads[i];
                if (GET(headIdx).min == 0)
                {
                    matchIdx = headIdx;
                    break;
                }
            }
        }
        else
        {
            let arity = args.len;

            // Prep labelled args for remap.
            mut names: string[];
            if (flags & F_NAMED_ARGS)
            {
                mut some = false;

                for (mut i = 0; i < arity; i++)
                {
                    let arg = args[i];
                    names.push(arg.kind == 'label'
                        ? (some = true, arg.value) || fail()
                        : '');
                }

                some || fail();
            }

            mut reorder: i32[];

            //
            :NEXT
            for (mut i = 0; i < overloads.len; i++)
            {
                mut overloadIdx = overloads[i];
                mut overload = GET(overloadIdx);

                :TEST_AGAIN
                while (true)
                {
                    if (overload.min > arity || overload.max < arity)
                        continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    //
                    if (names && overload.names)
                        reorder = getNamedArgReorder(
                            names, overload.names);
                    else
                        reorder.clear();

                    // Specialize.
                    if (overload.template)
                    {
                        if (reorder)
                            fail('TODO handle argument reorder in template specialization.');

                        let o = GET(overloadIdx);
                        let specIdx = trySpecialize(
                            overloadIdx, o.template, args);

                        if (!specIdx)
                            continue :NEXT;

                        overloadIdx = specIdx;
                        overload = GET(specIdx);

                        // Repeat arity checks and such.
                        continue :TEST_AGAIN;
                    }

                    // Done here.
                    break :TEST_AGAIN;
                }

                // Type check args.
                let arg_t = overload.args || fail();
                let arg_d = overload.defaults;

                let N = reorder ? reorder.len
                                : args.len;

                for (mut i = 0; i < N; i++)
                {
                    let callsiteIndex = reorder ? reorder[i]
                                                : i;
                    if (callsiteIndex < 0)
                    {
                        // Argument may not be defaulted -
                        //  we might be supplying defaults via names
                        //   before we've actually exhausted
                        //    all the non-defaulted stuff.
                        if !(arg_d && arg_d[i])
                            continue :NEXT;

                        continue;
                    }

                    if (!isAssignableAsArgument(arg_t[i], args[callsiteIndex].type || fail()))
                        continue :NEXT;
                }

                // Forbid ambiguity.
                if (matchIdx)
                    fail('Ambiguous callsite, matches multiple functions in scope: `' + id + '`.');

                // Done!
                matchIdx = overloadIdx;

                // Do reorder.
                if (reorder)
                {
                    // TODO:
                    // I shouldn't need this pass, just swaps must do.
                    mut new_args: SolvedNode[];
                    new_args.resize(reorder.len);

                    for (mut i = 0; i < reorder.len; i++)
                    {
                        let idx = reorder[i];
                        if (idx >= 0)
                            new_args[i] = args[idx];
                    }

                    args = new_args;
                }
            }
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let arg_d = matched.defaults;
            if (arg_d)
            {
                if (args.len < arg_d.len)
                    args.resize(arg_d.len);

                for (mut i = 0; i < arg_d.len; i++)
                    args[i] = args[i] || arg_d && arg_d[i] || fail();
            }

            // Implicit argument injection.
            let arg_t = matched.args;

            if (arg_t && args.len < arg_t.len)
            {
                let arg_n = matched.names || fail();
                for (mut i = args.len; i < arg_t.len; i++)
                {
                    let id   = arg_n[i];
                    let type = arg_t[i];

                    // Propagate implicit.
                    bindImplicitArg(args, i, id, type);
                }
            }
        }

        return matchIdx;
    }


    //

    fn scope_match__mutargs(id: string, args: &mut SolvedNode[], flags: i32): Target
    {
        let ret = scope_tryMatch__mutargs(:id, :args, :flags);
        if (ret)
            return ret;

        let debug = scope_tryMatch__mutargs(:id, :args, :flags);
        if (debug)
            return debug;

        return NICERR_scopeMismatch(id, args);
    }

    fn NICERR_scopeMismatch(id: string, args: SolvedNode[]): never
    {
        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = Scope_lookup(_scope, id);

        mut min = 0xffffff;
        for (mut i = 0; i < overloads.len; i++)
        {
            let arity = GET(overloads[i]).min;
            if (min > arity)
                min = arity;
        }

        return overloads
             ? args.len < min
                ? fail('`' + id + '` expects ' + min + ' arguments, ' + args.len + ' provided.')
                : fail('`' + id + '` bad args, provided: ' + TODO_memoize_mangler(args))
             : fail('`' + id + '` is not defined.');
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == 'root')        return solveRoot(node);
        if (k == 'block')       return solveBlock(node);
        if (k == 'label')       return solveComma(node);
        if (k == 'comma')       return solveComma(node);

        if (k == 'let')         return solveLet(node);
        if (k == 'call')        return solveCall(node);
        if (k == 'arrlit')      return solveArrayLiteral(node, type);

        if (k == 'if')          return solveIf(node, type);
        if (k == 'or')          return solveOr(node, type);
        if (k == '!')           return solveNot(node);
        if (k == 'and')         return solveAnd(node, type);

        if (k == 'return')      return solveReturn(node);
        if (k == 'loop')        return solveBlock(node);
        if (k == 'break')       return solveJump(node);
        if (k == 'continue')    return solveJump(node);

        if (k == 'int')         return solveInt(node);
        if (k == 'str')         return solveStr(node);
        if (k == 'empty')       return solveEmpty(node);

        if (k == 'definit')     return solveDefinit(type);

        if (k == 'catch')       return solveCatch(node);
        if (k == 'import')      return solveImport(node);

        return fail('TODO: ' + k);
    }

    fn isUnordered(kind: string)
    {
        return kind == 'fn'
            || kind == 'struct';
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == 'fn')         return uPrepFn(node);
        if (k == 'struct')     return uPrepStruct(node);

        return fail('TODO: ' + k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == 'fn')         return uSolveFn(node, prep);
        if (k == 'struct')     return uSolveStruct(node, prep);

        return fail('TODO: ' + k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        TEST_expectImplicits = !!(node.flags & F_IMPLICIT);

        return solved(node, t_void, solveNodes(node.items, t_void));
    }

    fn solveBlock(node: Node): SolvedNode
    {
        let scope0 = Scope_push(_scope);
        let out = solved(node, t_void, solveNodes(node.items, t_void));
        Scope_pop(_scope, scope0);
        return out;
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(node: Node): SolvedNode
    {
        return solved(node, t_i32);
    }

    fn solveStr(node: Node): SolvedNode
    {
        return solved(node, t_string);
    }

    fn solveEmpty(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: 'typeparam',
            :value, token: _here || fail());
    }

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(false, false, node, SolvedNode, -1);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(true, false, node, prep, -1);
    }

    fn __solveFn(solve: bool, spec: bool, n_fn: Node, prep: SolvedNode, caseIdx: i32): SolvedNode
    {
        let id = n_fn.value || fail('TODO anonymous fns');

        // Template early exit.
        if (spec)
        {
            solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl   = TemplateDecl(n_fn);
            mut out     = solved(n_fn, t_void);
            out.target  = tDecl;
            return out;
        }

        // Prep reject.
        if (!solve && !(n_fn.flags & F_FULLY_TYPED))
            return SolvedNode();

        let inItems = n_fn.items;
        inItems.len >= FN_RET_BACK || fail();

        mut out = prep || solved(n_fn, t_void);

        out.items.resize(inItems.len);

        //
        if (_current_fn && id != 'free')
        {
            _current_fn.flags |= F_HAS_CLOSURE;
            out.flags |= F_CLOSURE;
        }

        //////////////////////////
        {
            let scope0 = Scope_push(_scope);

            SWAP(_current_fn, out);
            let outItems: &mut SolvedNode[] = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == 'let' || fail();

                if (spec)
                {
                    // Specialize with actuals.
                    mut mut_arg = n_arg;
                    mut_arg.items[LET_TYPE] = createTypeParam(mut_arg.value);

                    // Emit value-taking specializations.
                    let type = _typeParams[mut_arg.value];
                    if !(type.quals & q_ref)
                        mut_arg.flags |= F_MUT;

                    outItems[i] = solveLet(mut_arg);
                }
                else
                {
                    outItems[i] = solveLet(n_arg);
                }
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
            mut n_body  = inItems[inItems.len + FN_BODY_BACK] || fail();

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == 'pattern' || fail();
                let branch = n_body.items[caseIdx] || fail();
                let items = branch.items;

                n_ret   = items[items.len + FN_RET_BACK]  || n_ret;
                n_body  = items[items.len + FN_BODY_BACK];
            }

            // Return type annot.
            {
                let s_ret = n_ret
                    ? evalTypeAnnot(n_ret)
                    : SolvedNode();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_RET_BACK] = s_ret;
            }

            // Only if actually solving the fn, the fn body.
            if (solve)
            {
                let s_body = solveNode(n_body);
                s_body || fail();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body;
            }

            //
            /////////////////////////////////////////////////////

            SWAP(_current_fn, out);

            Scope_pop(_scope, scope0);
        }
        //////////////////////////

        if (!prep)
            FnDecl(id, out);

        !solve || out.items[out.items.len + FN_BODY_BACK] || fail();

        return out;
    }


    //

    fn TODO_memoize_mangler(args: SolvedNode[]): string
    {
        mut mangle = '';
        for (mut i = 0; i < args.len; i++)
            mangle += '\v' + serializeType((args[i] || fail()).type);

        return mangle;
    }


    //

    fn trySpecialize(
        target: Target, template: Template, args: SolvedNode[])
            : Target
    {
        // TODO memoize the whole mangle.
        mut mangle = target.modid + '#' + target.index.raw;
            mangle += TODO_memoize_mangler(args);

        // TODO FIX THIS MESS -
        //  A. Not recursion capable: use the general prep-vs-solve approach here too.
        //  B. The multiple map taps here are because stuff
        //      moves around while doTrySpecialize does its work -
        //      if maps values didn't move around we'd be good.
        let spec = module.out.specs[mangle] ||= SolvedNode;
        if (!spec)
        {
            let spec = doTrySpecialize(template, args);
            module.out.specs[mangle] = spec;
            return spec.target;
        }

        return spec.target;
    }

    fn doTrySpecialize(
        template: Template, args: SolvedNode[])
            : SolvedNode
    {
        let node = template.node;

        node.kind == 'fn' || fail('TODO');
        mut result = trySpecializeFn(node, args);
        if (!result)
            result.kind = 'spec-fail';

        return result;
    }


    //

    fn trySpecializeFn(
        node: Node, args: SolvedNode[])
            : SolvedNode
    {
        let items = node.items;
        mut typeParams: Map(string, Type);

        // First off, solve type params.
        let numArgs = items.len + FN_ARGS_BACK;
        for (mut i = 0; i < numArgs; i++)
        {
            let argNode = items[i] || fail();
            argNode.kind == 'let'  || fail();

            mut inType = args.len > i ? args[i].type : Type();
            if (inType)
            {
                let argName = argNode.value || fail();

                // Same pattern - grabs a mutref.
                let argName_typeParam: &mut Type =
                    typeParams[argName] ||= Type;

                argName_typeParam && fail(
                    'Type param name collision with argument: `' + argName + '`.')
                        = inType;
            }

            // All fnargs are refereable.
            inType.quals |= q_ref;

            // Type check.
            let annot = argNode.items[LET_TYPE];
            if (annot)
            {
                let ok = inType && trySolveTypeParams(
                    annot, inType, typeParams);

                if (!ok)
                    return SolvedNode();
            }
        }

        // Match pattern arm here.
        mut caseIdx = -1;

        let pattern = items[items.len + FN_BODY_BACK] || fail();
        if (pattern.kind == 'pattern')
        {
            let branches = pattern.items;
            for (mut i = 0; i < branches.len; i++)
            {
                let branch = branches[i];
                let items = (branch || fail()).items;
                let cond = items[0] || fail();

                if (evalTypePattern(cond, typeParams))
                {
                    caseIdx = i;
                    break;
                }
            }

            // All branches mismatch?
            if (caseIdx < 0)
                return SolvedNode();
        }

        ////////////////////////////////
        mut current_fn0: SolvedNode;

        SWAP(_current_fn, current_fn0);
        SWAP(_typeParams, typeParams);

        let scope0 = Scope_push(_scope);
        ////////////////////////////////

        let specialized = __solveFn(true, true, node, SolvedNode(), caseIdx);
        specialized || fail();

        ////////////////////////////////
        SWAP(_current_fn, current_fn0);
        SWAP(_typeParams, typeParams);

        Scope_pop(_scope, scope0);
        ////////////////////////////////

        return specialized;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(false, node, SolvedNode());
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(true, node, prep);
    }

    fn __solveStruct(solve: bool, node: Node, prep: SolvedNode): SolvedNode
    {
        mut out         = prep || solved(node, t_void);

        let id          = node.value || fail('TODO anonymous structs');
        let structType  = initStruct(id, node.flags);

        // Add the arity-0 type entry.
        if (!prep)
            out.target  = Scope_Typedef(_scope, id, structType);

        if (!solve)
            return out;

        // Struct fields only.
        out.items = solveStructMembers(
            node.items, :structType);

        // Add a default constructor.
        {
            mut members: SolvedNode[];
            let items = out.items;

            mut fields: StructField[];

            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == 'let' && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value || fail(),
                            type: item.type  || fail()));
                }
            }

            finalizeStruct(id, fields);

            DefaultCtor(id, structType, members);
        }

        return out;
    }

    fn solveStructMembers(members: Node[], structType: Type): SolvedNode[]
    {
        mut out: SolvedNode[];

        for (mut i = 0; i < members.len; i++)
        {
            let node = members[i];
            if (node.kind == 'let')
                out.push(solveField(:node, :structType));
            else
                fail('TODO: ' + node.kind);
        }

        return out;
    }


    //

    fn solveReturn(node: Node): SolvedNode
    {
        let out = solved(node, t_void, solveNodes(node.items));

        let nextExpr    = out.items.len ? out.items[0] : out;
        let nextType    = nextExpr.type || fail();

        let retIdx      = _current_fn.items.len + FN_RET_BACK;
        let prevExpr    = _current_fn.items[retIdx];
        let prevType    = prevExpr.type;

        if (prevType)
            isAssignable(prevType, nextType)
                || fail('Non-assignable return types: ' + serializeType(prevType) + ' <- ' + serializeType(nextType));
        else
            _current_fn.items[retIdx] = nextExpr || fail();

        return out;
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveBinding(node: Node): SolvedNode
    {
        let annot       = node.items[LET_TYPE];
        let init        = node.items[LET_INIT];

        let s_annot     = annot && evalTypeAnnot(annot);
        let t_annot     = s_annot.type;

        mut s_init      = init && solveNode(init, t_annot);
        let t_init      = s_init.type;

        let t_let       = t_annot
                            ? node.flags & F_ARG && !(node.flags & F_MUT)
                              ? add_ref(t_annot)
                              : t_annot
                        : t_init.quals & q_mutref || node.flags & F_MUT
                            ? clear_refs(t_init)
                            : t_init || fail('Variable declarations without explicit type annotations must be initialized.');

        if (t_annot && t_init)
            isAssignable(t_annot, t_init) || fail(
                'Type annotation does not match init expression.');

        if (s_init)
            s_init = maybeCopyOrMove(s_init, t_let);

        //
        let out = solved(node, t_let, [s_annot || s_init, s_init]);

        if (node.flags & F_MUT)
            _current_fn || fail(
                'Mutable statics are not currently allowed.');

        return out;
    }

    fn solveLet(node: Node): SolvedNode
    {
        let out = solveBinding(node);
        let overload = Binding(
            id: out.value,
            node.flags & F_MUT
                ? add_mutref(out.type)
                : add_ref(out.type));

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveField(structType: Type, node: Node): SolvedNode
    {
        let out = solveBinding(node);
        let overload = Field(
            id: out.value,
            :structType, fieldType: out.type);

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok  = solveNode(node.items[0]);

        ////////////////////////////////
        let scope0  = Scope_push(_scope);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        var_err.kind == 'let' && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                'catch: exceptions are strings,'
                    + ' consider dropping the annotation.');

        return solved(node, var_ok.type,
            [ var_ok, var_err, catch ]);
    }

    fn solveImport(node: Node): SolvedNode
    {
        if (node) {}

        return fail('TODO - import - put stuff in localscope');
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        if (node.kind == 'call')
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t = evalTypeAnnot(items[0]).type;
                    t || fail();

                    if (node.value == '&')
                        return solved(node, add_ref(t));

                    if (node.value == '&mut')
                        return solved(node, add_mutref(t));

                    if (node.value == '[]')
                        return solved(node, createArray(t));
                }
                else if (items.len == 2)
                {
                    let a = evalTypeAnnot(items[0]).type;
                    let b = evalTypeAnnot(items[1]).type;
                    a && b || fail();

                    if (node.value == 'Map')
                        return solved(node, createMap(a, b));
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == 'type')
                            return solved(node, maybe.type || fail());
                    }
                }

                fail('No type `' + id + '` in scope.');
            }
        }
        else if (node.kind == 'typeparam')
        {
            let id = node.value || fail();
            _typeParams || fail(
                'Unexpected type param: `$' + id + '`.');

            let type = _typeParams && _typeParams[id] || fail(
                'No type param `$' + id + '` in scope.');

            return solved(node, type);
        }

        return fail('TODO');
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, typeParams: &mut Map(string, Type)): bool
    {
        if (node.kind == 'call')
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t   = node.value == '&'    ? tryClear_ref(type)
                            : node.value == '&mut' ? tryClear_mutref(type)
                            : node.value == '[]'   ? tryClear_array(type)
                            : (fail('TODO'), Type);

                    if (!t)
                        return false;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == 'Map')
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == 'type')
                            return isAssignable(maybe.type || fail(), type);
                    }
                }

                fail('No type `' + id + '` in scope.');
            }
        }
        else if (node.kind == 'typeparam')
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            let _param: &mut Type =
                (typeParams[id] ||= Type);

            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }

        return fail('TODO');
    }

    fn evalTypePattern(node: Node, typeParams: Map(string, Type)): bool
    {
        let items = node.items;
        if (node.kind == 'call' && items.len == 2)
        {
            let left  = items[0] || fail();
            let right = items[1] || fail();

            if (node.value == '->')
            {
                if (left.kind  == 'typeparam' &&
                    right.kind == 'typetag')
                {
                    let tag   = right.value || fail();
                    let type  = left.value && typeParams[left.value] || fail(
                        'No type param `$' + left.value + '` in scope.');

                    return type_has(type, tag);
                }
                else
                {
                    ////////////////////////////////
                    let typeParams0 = _typeParams;
                    _typeParams       = typeParams;
                    ////////////////////////////////

                    //               is                //
                    // (actual) left -> right (expect) //
                    let expect = evalTypeAnnot(right).type;
                    let actual = evalTypeAnnot(left ).type;

                    ////////////////////////////////
                    _typeParams = typeParams0;
                    ////////////////////////////////

                    return isAssignable(expect, actual);
                }
            }
            else if (node.value == '&&')
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
            else if (node.value == '||')
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
        }

        return fail('TODO');
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   'call',
            flags:  F_ID,
            value:  id,
            token:  (_here || fail()));
    }

    fn solveCall(node: Node): SolvedNode
    {
        let id          = node.value; id || fail();
        mut args        = solveNodes(node.items);

        mut callTargIdx = scope_match__mutargs(id, args, node.flags);
        mut callTarg    = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == 'p-unshift';

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead('__partial'),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        let items = solveNodes(node.items);

        mut itemType = type
            ? tryClear_array(type)
            : Type;

        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail('Cannot infer empty arraylit.');

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                '[array literal] No common supertype.');
        }

        return solved(node, createArray(itemType), items);
    }


    // This is a weird one,
    //  in case this is the current fn we're solving,
    //   we wont have overload yet, but we do have the node,
    //    otherwise we have the overload and get the node from there.

    fn createLet(id: string, type: Type, flags: i32 = 0): SolvedNode
    {
        return SolvedNode(
            kind:   'let',
            flags:  flags,
            value:  id,
            token:  _here || fail(), :type);
    }

    fn injectImplicitArg__mutfn(
        fnNode: &mut SolvedNode,
        id: string, type: Type): Target
    {
        ///////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0  = Scope_push(_scope);
        let ret     = Binding(id, type);
        Scope_pop(_scope, scope0);
        ///////////////////////////////////////////

        // Reuse existing or add new argnode.
        {
            let n = fnNode.items.len;
            for (mut i = 0; i < n; i++)
            {
                let arg: &mut SolvedNode = fnNode.items[i];
                if (arg.value == id)
                {
                    isAssignable(type, arg.type)
                        || fail('Implicit arg collision: `' + id + '`.');

                    return ret;
                }
            }

            let newArgIdx   = fnNode.items.len + FN_RET_BACK;
            let newArgNode  = createLet(id, type, F_IMPLICIT);

            fnNode.items.insert(newArgIdx, newArgNode);
        }

        // If we dont have the overload yet,
        //  there's nothing else to do here.
        if (fnNode.target)
        {
            let o: &mut Overload = GET_mut(fnNode.target);

            // We'll be mutating the overload.
            o.kind == 'fn' || fail();

            o.names.len == o.args.len || fail();

            o.args .push(type);
            o.names.push(id);
        }

        return ret;
    }

    fn bindImplicitArg(
        mut args: &mut SolvedNode[],
        argIdx: i32, id: string, type: Type)
    {
        TEST_expectImplicits || fail(
            'Attempting to propagate implicit arguments.');

        args.len >= argIdx || fail();

        args.insert(argIdx, CallerNode(
            createRead(id), :type,
            target: getImplicit(id, type)));
    }

    fn getImplicit(id: string, type: Type): Target
    {
        mut args: SolvedNode[];
        mut matched = scope_tryMatch__mutargs(
            :id, :args, retType: type);

        if (!matched)
        {
            if (!_current_fn)
                return fail('No implicit `' + id + '` in scope.');

            matched = injectImplicitArg__mutfn(
                _current_fn, id, type);

            matched || fail();
        }

        return matched;
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let n0      = node.items[0];
        let n1      = node.items[1];
        let n2      = node.items[2];

        let cond    = solveNode(n0, t_bool);
        mut cons    = n1 ? solveNode(n1)            : SolvedNode;
        mut alt     = n2 ? solveNode(n2, cons.type) : SolvedNode;

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt || cons;

        let priType = priExpr.type;
        let secType = secExpr.type;

        if !(type == t_void || type == t_bool)
        {
            type = !secType ? priType
                            : type_tryInter(priType, secType);

            type || fail('[if] No common supertype.');

            if (cons)
                cons = maybeCopyOrMove(cons, type);
            if (alt)
                alt  = maybeCopyOrMove(alt, type);
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type);

        // Statement mode.
        if (type == t_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!(type == t_bool))
        {
            mut sumType: Type;

            // Sum types, ignoring never.
            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item.type == t_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    items[i] = maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items);

        // Statement mode.
        if (type == t_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!(type == t_bool))
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type == t_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type = item.type;
                    sumType = item.type;
                }

                break;
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [])
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        // TBD how we make this stuff work in real life.
        if (overload.kind == 'field')
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs_from(headType, type);
        }

        // Tag copies and moves.
        else if (args.len)
        {
            let arg_t = overload.args || fail();
            for (mut i = 0; i < args.len; i++)
                args[i] = maybeCopyOrMove(
                    args[i] || fail(), arg_t[i]);
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(
        node: SolvedNode, slot: Type): SolvedNode
    {
        // No copy needed when the slot is a reference.
        let q = slot.quals;
        if (q & q_ref)
            return node;

        // Also, no copy needed when the expression is a value.
        if !(node.type.quals & q_ref)
            return node;

        if !(q & q_copy)
            fail('Needs an explicit STEAL or CLONE.');

        if (WARN_ON_IMPLICIT_COPY)
        {
            // if !(node.type.quals & q_trivial)
            //     print('WARN ', _here.line, ':', _here.col, ':\timplicit copy ', node.type.canon);
        }

        // Here we go.
        return SolvedNode(
            kind: 'copy',

            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));
    }


    //

    fn solveNodes(nodes: Node[], type: Type = []): SolvedNode[]
    {
        mut result: SolvedNode[];

        let here0 = _here;

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            if (!isUnordered(node.kind))
            {
                _here       = node.token || _here;
                result[i]   = solveNode(node, type);
                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (mut i = i0; i < nodes.len; i++)
            {
                let node = nodes[i];
                if (!node)
                    continue;

                if (!isUnordered(node.kind))
                {
                    i1 = i;
                    break;
                }

                _here       = node.token || _here;
                result[i]   = unorderedPrep(node);
            }

            // Second pass, do the remaining work.
            for (mut i = i0; i < i1; i++)
            {
                let node = nodes[i];
                if (node)
                {
                    _here       = node.token || _here;
                    result[i]   = unorderedSolve(node, result[i]);
                }
            }

            // Continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++
        }

        result.len == nodes.len || fail();

        _here = here0;

        return result;
    }


    // So lets go.

    return SolverOutput(
        root: solveNode(parse),
        scope: _scope);
}


// Solve & cache the prelude.

fn listGlobals(): Scope
{
    mut scope: Scope;

    Scope_Typedef(scope,  'i8',    t_i8    );
    Scope_Typedef(scope, 'i16',    t_i16   );
    Scope_Typedef(scope, 'i32',    t_i32   );
    Scope_Typedef(scope, 'i64',    t_i64   );

    Scope_Typedef(scope,  'u8',    t_u8    );
    Scope_Typedef(scope, 'u16',    t_u16   );
    Scope_Typedef(scope, 'u32',    t_u32   );
    Scope_Typedef(scope, 'u64',    t_u64   );

    Scope_Typedef(scope, 'f32',    t_f32   );
    Scope_Typedef(scope, 'f64',    t_f64   );

    Scope_Typedef(scope, 'bool',   t_bool  );
    Scope_Typedef(scope, 'void',   t_void  );
    Scope_Typedef(scope, 'string', t_string);
    Scope_Typedef(scope, 'never',  t_never );

    return scope;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Prelude.

let prelude_src = `


// Some lolcode.

fn __native_pure(): never never;
fn __native_pure(id: string): never never;
fn __native_pure(id: string, opt: string): never never;

fn STEAL (a: &mut $T): $T __native_pure;
fn CLONE (a: &    $T): $T __native_pure;

fn print(a: $A): void __native_pure;
fn print(a: $A, b: $B): void __native_pure;
fn print(a: $A, b: $B, c: $C): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E, f: $F): void __native_pure;


// Arithmetics.

fn +(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn +(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;

fn -(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn -(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;
fn *(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;

fn /(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native_pure;
    // case ($T -> @integral && $b -> @non_zero):          $T __native_pure;
    case ($T -> @arithmetic): $T __native_pure;

fn %(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native_pure;
    // case ($T -> @integral && $b -> @non_zero):          $T __native_pure;
    case ($T -> @arithmetic): $T __native_pure;

fn ++(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn --(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn +=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;
fn -=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;

fn ==(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn !=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn > (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn < (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn >=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn <=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;


// Bitwise.

fn ~(a: $T)                 case ($T -> @integral):     $T __native_pure;
fn &(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn |(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn ^(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn <<(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;
fn >>(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;

fn &=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn |=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn ^=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;


// Logic.

fn true (): bool __native_pure;
fn false(): bool __native_pure;


// Assignment.

fn   =(a: &mut $T, b: $T): &mut $T __native_pure;
fn ||=(a: &mut $T, b: $T): &mut $T __native_pure;

fn SWAP(a: &mut $T, b: &mut $T): void __native_pure;


// Arrays.

fn len (a: $T[]): i32 __native_pure;
fn find(a: $T[], b: $T): i32 __native_pure;
fn has (a: $T[], b: $T): bool __native_pure;

fn [](a: $T[], i: i32)
    case ($a -> &mut $T[]): &mut $T __native_pure;
    case ($a -> &    $T[]): &    $T __native_pure;

fn    push(a: &mut $T[], b: $T): void __native_pure;
fn unshift(a: &mut $T[], b: $T): void __native_pure;
fn  insert(a: &mut $T[], i: i32, b: $T): void __native_pure;

fn concat(a: $T[], b: $T[]): $T[] __native_pure;
fn  slice(a: $T[], i0: i32, i1: i32): $T[] __native_pure;
fn  slice(a: $T[], i0: i32): $T[] __native_pure;

fn splice(a: &mut $T[], i: i32, N: i32): void __native_pure;
fn    pop(a: &mut $T[]): void __native_pure;

fn  clear(a: &mut $T[]): void __native_pure;
fn resize(a: &mut $T[], len: i32): void __native_pure;
fn shrink(a: &mut $T[], len: i32): void __native_pure;

fn move(a: &mut $T[], from: i32, to: i32): void __native_pure;
fn sort(a: &mut $T[]): void __native_pure;


// Concats.
//
//  flatten: str/arr a+b+c chains into a n-ary binop -
//  adjoin : str/arr chain adjacent += for the same left-arg.
//
//      Currently just testing notations,
//        but can we make this more generic?
//          Will it be useful? Array ops are really
//            the only thing we care about optimizing.

fn +(a: $T[], b: $T[]): $T[] __native_pure( 'arr+', 'flatjoin' );
fn +(a: $T[], b: $T  ): $T[] __native_pure( 'arr+', 'flatjoin' );
fn +(a: $T  , b: $T[]): $T[] __native_pure( 'arr+', 'flatjoin' );

fn +=(a: &mut string, b: string): &mut string __native_pure( 'arr+', 'flatjoin' );
fn + (a:      string, b: string):      string __native_pure( 'arr+', 'flatjoin' );


// Strings.

fn len(a: string): i32 __native_pure;
fn  [](a: string, i: i32): string __native_pure;

fn ==(a: string, b: string): bool __native_pure;
fn !=(a: string, b: string): bool __native_pure;
fn  >(a: string, b: string): bool __native_pure;
fn  <(a: string, b: string): bool __native_pure;
fn >=(a: string, b: string): bool __native_pure;
fn <=(a: string, b: string): bool __native_pure;

fn   find(a: string, b: string): i32 __native_pure;
fn    has(a: string, b: string): bool __native_pure;
fn starts(a: string, with: string): bool __native_pure;

fn slice (a: string, i0: i32, i1: i32): string __native_pure;
fn slice (a: string, i0: i32): string __native_pure;

fn substr(a: string, i0: i32, i1: i32): string __native_pure;
fn char  (a: string, i0: i32): i32 __native_pure;


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn   split(str: string, sep: string): string[] __native_pure;
fn    join(a: string[], sep: string): string __native_pure;
fn replace(in: string, all: string, with: string): string __native_pure;


// Maps.

fn [](a: Map($K, $V), b: &$K)
    case ($a -> &mut Map($K, $V)): &mut $V __native_pure;
    case ($a -> &    Map($K, $V)): &    $V __native_pure;

fn keys  (a: Map($K, $V)): $K[] __native_pure;
fn values(a: Map($K, $V)): $V[] __native_pure;
fn has   (a: Map($K, $V), b: $K): bool __native_pure;
fn count (a: Map($K, $V)): i32 __native_pure;


// Assertions, bugs & fails.

fn throw(reason: string): never __native_pure;
fn assert(): never __native_pure;


// Butt plugs.

// TODO we should go for an any $B -> call stringify(b) macro.
fn +(a: string, b: i32): string __native_pure;
fn +(a: string, b: f64): string __native_pure;
fn +(a: i32, b: string): string __native_pure;
fn +(a: f64, b: string): string __native_pure;

// TODO fix impure io.
fn now_hr(): f64 __native_pure;
fn now_utc(): f64 __native_pure;

fn env_get(key: string): string __native_pure;

fn file_size(path: string): i32 __native_pure;
fn file_read(path: string): string __native_pure;
fn file_write(path: string, body: string): bool __native_pure;

fn shell_exec(cmd: string): i32 __native_pure;
fn shell_exec(cmd: string, stdout: &mut string): i32 __native_pure;

fn hash_tea(str: string): string __native_pure;

fn i32(v: f64): i32 __native_pure;

fn exit(code: i32): never __native_pure;

`;

fn solvePrelude(): TEMP_Context
{
    // In order to keep the prelude around,
    //  I'm thinking we'll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: TEMP_Context;
    let implicit mut module = getModule('');

    // Hacking things in.
    ctx.modules[0].out.solve.scope = listGlobals();

    let lexed   = lex(prelude_src, '__prelude');
    let root    = parse('__prelude', lexed.tokens).root;
    let solved  = solve(root);

    module.out.solve = solved;
    setModule(module);

    return ctx;
}

let CTX_PROTO: TEMP_Context = solvePrelude();




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Codegen.

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;


//

pub fn cpp_codegen(
    implicit module: &Module,
    implicit ctx: &TEMP_Context,
    root: SolvedNode, scope: Scope): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);
    mut _ffwd: Map(string, string);
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string     = '\n';
    mut _fnN:   i32;
    mut _clsrN: i32;
    mut _faasN: i32;

    fn GET(
        implicit module: Module,
        implicit ctx: TEMP_Context,
        target: Target): Overload
    {
        target.index.raw > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index.raw - 1];
    }

    fn fail(reason = '') throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = '#include ' + lib + '\n';
    }


    //

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        let fwd = typeAnnotBase(type);

        if ((mode & M_RETVAL) && type.canon == 'never')
            return '[[noreturn]] ' + fwd;

        if (type.quals & q_mutref)
            return fwd + '&';
        if (type.quals & q_ref)
            return 'const ' + fwd + '&';

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return 'const ' + fwd;

        if ((mode & M_ARGUMENT) && !(type.quals & q_trivial))
            return fwd + '&&';

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (c ==  'i8')    return 'i8';
        if (c == 'i16')    return 'i16';
        if (c == 'i32')    return 'int'; // TODO fix, pandemic includes
        if (c == 'i64')    return 'i64';

        if (c ==  'u8')    return 'u8';
        if (c == 'u16')    return 'u16';
        if (c == 'u32')    return 'u32';
        if (c == 'u64')    return 'u64';

        if (c == 'f32')    return 'f32';
        if (c == 'f64')    return 'f64';

        if (c == 'bool')   return 'bool';
        if (c == 'void')   return 'void';
        if (c == 'string') return annotateString();
        if (c == 'never')  return annotateNever();

        let tdef = lookupType(type) || fail('TODO: ' + type.canon);
        let k = tdef.kind;

        if (k == 'struct')
        {
            if (!_tfwd.has(type.canon))
            {
                _tfwd[type.canon] = '\nstruct ' + type.canon + ';';

                _tdef += declareStruct(type, tdef);
            }

            return type.canon;
        }

        if (k == 'array')
        {
            annotateVector();

            let item = typeAnnot(tdef.fields[0].type);
            return 'fu_VEC<' + item + '>';
        }

        if (k == 'map')
        {
            let k = typeAnnot(tdef.fields[0].type);
            let v = typeAnnot(tdef.fields[1].type);

            annotateMap();
            return 'fu_COW_MAP<' + k + ', ' + v + '>';
        }

        return fail('TODO: ' + tdef.kind);
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        mut def = '\nstruct ' + t.canon + '\n{';
        mut indent = '\n    ';

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    struct Data\n    {';
            indent += '    ';
        }

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def += indent + typeAnnot(field.type) + ' ' + ID(field.id) + ';';
        }

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    };';
            def += '\n';
            def += '\n    Data data;';
            def += '\n    bool dtor = false;';
            def += '\n';
            def += '\n    ~' + t.canon + '() noexcept;';
            def += '\n    inline ' + t.canon + '(Data data) noexcept : data(data) {};';
            def += '\n    ' + t.canon + '(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '& operator=(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '(' + t.canon + '&&) noexcept;';
            def += '\n    ' + t.canon + '& operator=(' + t.canon + '&&) noexcept;';
        }

        def += '\n    explicit operator bool() const noexcept';
        def += '\n    {';
        def += '\n        return false';

        for (mut i = 0; i < fields.len; i++)
            def += '\n            || '
                + boolWrap(fields[i].type,
                    (s.flags & F_DESTRUCTOR ? 'data.' : '')
                        + ID(fields[i].id));

        def += '\n        ;';
        def += '\n    }';

        return def + '\n};\n';
    }


    //

    fn collectDedupes(
        dedupes: &Map(string, string)): string
    {
        mut out = '';

        mut keys = dedupes.keys();
        keys.sort();

        for (mut i = 0; i < keys.len; i++)
            out += dedupes[keys[i]];

        return out;
    }

    fn cgSpecs(): string
    {
        mut src = '';

        let specs = module.out.specs;
        let keys = specs.keys();
        for (mut i = 0; i < keys.len; i++)
        {
            // Prelude?
            let k = keys[i];
            if (k[0] == '0')
                continue;

            // Emit.
            let s = specs[k];
            if (s.target)
                src += cgNode(s);
        }

        return src;
    }

    fn cgRoot(root: SolvedNode): string
    {
        let src = cgStatements(root.items);

        mut header = collectDedupes(_libs)
                   + collectDedupes(_tfwd)
                   + collectDedupes(_ffwd)
                   + cgSpecs()
                   +               (_tdef)
                   +               (_fdef)
                   ;

        return header + src;
    }


    //

    fn ID(id: string): string
    {
        if (id == 'this')       return '_';
        if (id == 'template')   return 'tempatle';
        if (id == 'catch')      return 'cahtch';
        if (id == 'not')        return 'nott';
        if (id == 'and')        return 'andd';
        if (id == 'or')         return 'orr';

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = '';

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src += _indent + line + (line.last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[], skipCurlies: bool = false): string
    {
        let indent0 = _indent;
        _indent += '    ';

        mut src = cgStatements(nodes);
        if (!skipCurlies || nodes.len != 1 || nodes[0].kind != 'return' && nodes[0].kind != 'call')
            src = indent0 + '{' + src + indent0 + '}';

        _indent = indent0;
        return src;
    }

    fn blockWrapSubstatement(node: SolvedNode): string
    {
        return node.kind != 'block' ? blockWrap([ node ], true)
             : node.items.len == 1  ? blockWrapSubstatement(node.items[0])
                                    : cgBlock(node);
    }

    fn cgBlock(block: SolvedNode): string
    {
        return blockWrap(block.items);
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return '(false /*empty parens*/)';

        if (items.len == 1)
            return items[0];

        mut src = '(';
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src += ', ';
            if (i < items.len - 1)
                src += '(void)';

            src += items[i];
        }

        return src + ')';
    }


    // This is kinda weird - it's an auto-refactor:
    //  it converts a fn that contains closures
    //   into a struct, with its args and leading "lets"
    //    converted into fields, and then leading closures
    //     converted into struct members.

    // The tail of the fn remains in an "EVAL" function,
    //  and currently to limit the damage we emit a macro
    //   that remaps the invocation.

    // TODO this can do more -
    //  we could collect most of the top-level stuff on the struct.

    fn try_cgFnAsStruct(fn: SolvedNode): string
    {
        let body = fn.items[fn.items.len + FN_BODY_BACK];
        if (!body || body.kind != 'block')
            return '';

        let items = body.items;

        // We need at least one closure
        //  in the function "header"
        //   for all of this to make sense.
        mut hasClosuresInHeader = false;
        mut end = 0;
        for (mut i = 0; i < items.len; i++)
        {
            end = i;

            let item = items[i];
            if (item.kind == 'fn')
            {
                if (item.flags & F_CLOSURE)
                    hasClosuresInHeader = true;
            }
            else if (item.kind != 'let' && item.kind != 'struct')
            {
                break;
            }
        }

        if (!hasClosuresInHeader)
            return '';

        // Ok - refactor time.
        let evalName = fn.value + '_EVAL';

        let restFn = SolvedNode(

            kind: 'fn', type: t_void,
            flags: fn.flags | F_CLOSURE,
            token: fn.token,
            value: evalName,

            items:
            [
                fn.items[fn.items.len - 2], // retval
                SolvedNode(
                    kind: 'block', type: t_void,
                    token: fn.token,
                    items: items.slice(
                        end, items.len)),
            ]);

        let head: SolvedNode[] =
            (fn.items.slice(0, fn.items.len + FN_ARGS_BACK))
                .concat(items.slice(0, end))
                .concat([ restFn ]);

        //////////////////////
        _clsrN == 0 || fail();
        _clsrN--; // -1, so root closures come up at 0.
        //////////////////////

        let structName = 'sf_' + fn.value;
        mut src = '\nstruct ' + structName
                + blockWrap(head) + ';'
                + '\n\n#define ' + fn.value + '(...) ((' + structName + ' { __VA_ARGS__ }).' + evalName + '())\n';

        //////////////////////
        _clsrN++;
        //////////////////////

        return src;
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let items   = fn.items;
        let ret     = items[items.len + FN_RET_BACK] || fail();
        let annot   = typeAnnot(ret.type || fail(), M_RETVAL);
        let closure = !!_clsrN && (fn.flags & F_CLOSURE);

        mut src = closure
                ? 'const auto& ' + fn.value + ' = [&]('
                : annot + ' ' + fn.value + '(';

        if (!fn.value.hasIdentifierChars)
            src = annot + ' operator' + fn.value + '(';

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src += ', ';

            src += binding(items[i] || fail());
        }

        src += closure
             ? ') -> ' + annot
             : ')';

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != 'fn')
            return;

        let ffwdKey = target.modid + '#' + target.index.raw;
        if (_ffwd.has(ffwdKey))
            return;

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        mut src = id.hasIdentifierChars
                ? '\n' + annot + ' ' + id + '('
                : '\n' + annot + ' operator' + id + '(';

        let arg_t = overload.args;
        for (mut i = 0; i < arg_t.len; i++)
        {
            if (i)
                src += ', ';

            src += typeAnnot(arg_t[i], M_ARGUMENT);
        }

        src += ');';
        _ffwd[ffwdKey] = src;

        return;
    }


    //

    fn cgFn(fn: SolvedNode): string
    {
        // Template? TODO FIX dunno why this is how we tell, looks terrible.
        if (!fn.items.len)
            return '';

        // Use like-struct output for top-level functions with closures -
        //  We'll try to "close over" a root-level struct.
        if (_faasN == 0 && (fn.flags & F_HAS_CLOSURE))
        {
            /////////
            _faasN++;
            /////////

            let src = try_cgFnAsStruct(fn);

            /////////
            _faasN--;
            /////////

            if (src)
            {
                _fdef += src;
                return '';
            }
        }

        ///////////////////////////
        let f0 = _fnN;
        let c0 = _clsrN;
        let indent0 = _indent;

        _fnN++;
        if (fn.flags & F_CLOSURE) _clsrN++;
        ///////////////////////////

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK] || fail();

        // Both closures and try_cgFnAsStruct
        if (!(fn.flags & F_CLOSURE))
            _indent = '\n';

        mut src = cgFnSignature(fn);
        if (src != 'int main()' && !(fn.flags & F_CLOSURE) && _fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        if (body.kind == 'block')
            src += cgBlock(body);
        else
            src += blockWrap([ body ]);

        //////////////
        _fnN    = f0;
        _clsrN  = c0;
        _indent = indent0;
        //////////////

        if (fn.flags & F_DESTRUCTOR)
        {
            let head = items[0] || fail();
            let name = head.type.canon;

            src += '\n\n' + name + '::~' + name + '() noexcept';
            src += '\n{';
            src += '\n    if (!dtor)';
            src += '\n    {';
            src += '\n        dtor = true;';
            src += '\n        free(*this);';
            src += '\n    }';
            src += '\n}';

            include('<cassert>');
            include('<utility>');

            src += '\n\n' + name + '::' + name + '(' + name + '&& src) noexcept';
            src += '\n    : data(std::move(src.data))';
            src += '\n{';
            src += '\n    assert(!src.dtor);';
            src += '\n    dtor = src.dtor;';
            src += '\n    src.dtor = true;';
            src += '\n}';

            include('<cstring>');

            src += '\n\n' + name + '& ' + name + '::operator=(' + name + '&& src) noexcept';
            src += '\n{';
            src += '\n    if (&src != this)';
            src += '\n    {';
            src += '\n        char temp[sizeof(' + name + ')];';
            src += '\n        std::memcpy(temp, this, sizeof(' + name + '));';
            src += '\n        std::memcpy(this, &src, sizeof(' + name + '));';
            src += '\n        std::memcpy(&src, temp, sizeof(' + name + '));';
            src += '\n    }';
            src += '\n';
            src += '\n    return *this;';
            src += '\n}';
        }

        // This covers both closures & try_cgTryFnAsStruct:
        if (fn.flags & F_CLOSURE)
            return src;

        _fdef += '\n' + src + '\n';
        return '';
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        let id    = node.value || fail();
        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        let head  = (annot || fail()) + ' ' + ID(id);
        let init  = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == 'copy' && !(node.type.quals & q_ref))
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_trivial)
                    return head + ' = ' + expr;

                return head + ' { ' + expr + ' }';
            }

            return head + ' = ' + cgNode(init);
        }

        return head + ' {}';
    }

    fn cgLet(node: SolvedNode): string
    {
        mut src = binding(node, doInit: true);
        if (_fnN || _faasN)
            return src;

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.replace(
            all: '([&](', with: '([](');

        // cpp17 inline const syntax sugars.
        if (src.starts(with: 'const '))
            src = src.slice(6);

        //
        _fdef += src = 'inline const ' + src + ';\n';
        return '';
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type == t_never)
                return src;

            return 'return ' + src;
        }

        return 'return';
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return 'goto L_' + node.value + '_' + node.kind[0];

        return node.kind;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = '';
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc += '\\n';
            else if (c == '\r') esc += '\\r';
            else if (c == '\t') esc += '\\t';
            else if (c == '\v') esc += '\\v';
            else if (c == '\\') esc += '\\\\';
            else if (c ==  '"') esc += '\\"';

            else                esc += c;
        }

        return '"' + esc + '"_fu';
    }

    fn cgArrayLiteral(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot + ' { ' + arrayAnnot
            + '::INIT<' + items.len + '> { '
                + items.join(', ') + ' } }';
    }

    fn cgDefaultInit(node: SolvedNode): string
    {
        return cgArrayLiteral(node);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();
        mut items  = cgNodes(node.items);

        if (target.kind == 'defctor')
        {
            let head = (target.type || fail());
            let type = lookupType(head) || fail();

            //
            mut open = ' { ';
            mut close = ' }';
            if (type.flags & F_DESTRUCTOR)
            {
                open = ' { ' + head.canon + '::Data { ';
                close = ' }}';
            }

            return head.canon + open + items.join(', ') + close;
        }

        let id = target.name || fail();

        if (hasNonIdentifierChars(id))
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? items[0] + id
                     : id + items[0];
            }

            if (items.len == 2)
            {
                if (id == '[]')
                {
                    if (head.type.canon == 'string')
                        return 'fu_TO_STR(' + items[0] + '[' + items[1] + '])';

                    // The new cow_vec is here.
                    if (head.type.quals & q_mutref)
                        return items[0] + '.mutref(' + items[1] + ')';

                    return items[0] + '[' + items[1] + ']';
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == '=')
                {
                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return '(' + cgNode(head.items[0] || fail()) +
                                '.upsert(' + cgNode(head.items[1] || fail()) + ') = ' +
                                    items[1] + ')';
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == '||=')
                {
                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            items[0] = cgNode(head.items[0] || fail()) +
                                '.upsert(' + cgNode(head.items[1] || fail()) + ')';
                    }

                    let annot = typeAnnot(head.type);

                    return '([&](' + annot + ' _) -> ' + annot + ' { if (!' +
                        boolWrap(head.type, '_') + ') _ = ' +
                            items[1] + '; return _; } (' + items[0] + '))';
                }

                // Skip some of the ridiculous parens.
                if (mode & M_STMT)
                    return items[0] + ' ' + id + ' ' + items[1];
                else
                    return '(' + items[0] + ' ' + id + ' ' + items[1] + ')';
            }
        }

        if (target.kind == 'var')
            return ID(id);

        if (target.kind == 'field')
        {
            mut sep = '.';
            let parent = lookupType(node.items[0].type);
            if (parent.flags & F_DESTRUCTOR)
                sep = '.data.';

            return items[0] + sep + ID(id);
        }

        if (id == 'len' && items.len == 1)
            return items[0] + '.size()';

        if (id == 'push' && items.len == 2)
            return items[0] + '.push(' + items[1] + ')';

        if (id == 'pop' && items.len == 1)
            return items[0] + '.pop()';

        if (id == 'unshift' && items.len == 2)
            return items[0] + '.unshift(' + items[1] + ')';

        if (id == 'insert' && items.len == 3)
            return items[0] + '.insert(' + items[1] + ', ' + items[2] + ')';

        if (id == 'splice' && items.len == 3)
            return items[0] + '.splice(' + items[1] + ', ' + items[2] + ')';

        if (id == 'grow' && items.len == 2)
            return items[0] + '.grow(' + items[1] + ')';

        if (id == 'shrink' && items.len == 2)
            return items[0] + '.shrink(' + items[1] + ')';

        if (id == 'resize' && items.len == 2)
            return items[0] + '.resize(' + items[1] + ')';

        if (id == 'clear' && items.len == 1)
            return items[0] + '.clear()';

        if (id == 'find' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::lfind(' + items.join(', ') + ')';
        }

        if (id == 'starts' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::lmatch(' + items.join(', ') + ')';
        }

        if (id == 'has' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::has(' + items.join(', ') + ')';
        }

        if (id == 'replace' && items.len == 3)
        {
            include('"../lib/vec/replace.h"');
            return 'fu::replace(' + items.join(', ') + ')';
        }

        if (id == 'slice' && items.len == 2)
            return 'slice(' + items[0] + ', ' + items[1] + ')';

        if (id == 'slice' && items.len == 3)
            return 'slice(' + items[0] + ', ' + items[1] + ', ' + items[2] + ')';

        if (id == 'substr' && items.len == 3)
            return 'substr(' + items[0] + ', ' + items[1] + ', ' + items[2] + ')';

        if (id == 'sort' && items.len == 1)
        {
            include('<algorithm>');
            return '([&](auto& _) { std::sort(_.mut_begin(), _.mut_end()); } (' + items[0] + '))';
        }

        if (id == 'char' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return 'int(' + items[0] + '[' + items[1] + '])';
        }

        if ((id == 'true' || id == 'false') && !items.len)
            return id;

        if (id == 'throw' && items.len == 1)
            return cgThrow(id, items[0]);

        if (id == 'assert' && items.len == 0)
            return cgThrow(id, '"Assertion failed."');

        if (id == 'move' && items.len == 3)
            return '([&]() { auto* _ = ' + items[0] + '.mut_data(); ' + cgSlide('_ + ' + items[2], '_ + ' + items[1], 'sizeof(*_)') + '; } ())';

        if (id == 'concat' && items.len == 2)
            return cgConcat(items);

        if (id == 'split' && items.len == 2)
            return cgSplit(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'keys' && items.len == 1)
            return cgKeys(items);

        if (id == 'CLONE' && items.len == 1)
            return cgClone(node.type, items[0]);

        if (id == 'STEAL' && items.len == 1)
            return cgSteal(items[0]);

        if (id == 'SWAP' && items.len == 2)
            return cgSwap(items);

        if (id == 'print')
            return cgPrint(items);

        if (id == 'now_hr' || id == 'now_utc')
        {
            include('"../lib/now.h"');
            return 'fu::' + id + '()';
        }

        if (id == 'file_write' || id == 'file_read' || id == 'file_size')
        {
            include('"../lib/io.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'env_get')
        {
            include('"../lib/env.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'hash_tea')
        {
            include('"../lib/tea.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'shell_exec')
        {
            include('"../lib/shell.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        id != '__native_pure' || assert();

        return ID(id) + '(' + items.join(', ') + ')';
    }

    fn cgPrint(items: string[]): string
    {
        include('<iostream>');

        mut src = '(std::cout';
        for (mut i = 0; i < items.len; i++)
            src += ' << ' + items[i];

        src += ' << "\\n")';
        return src;
    }

    fn cgSlide(destExpr: string, srcExpr: string, numBytesExpr: string): string
    {
        let SLIDE = '::slide';
        if (!_tfwd.has(SLIDE))
        {
            include('<cstring>');

            _tfwd[SLIDE] =
////////////////////////////////////
`
template <size_t N>
inline void fu_MEMSLIDE(void* dest, void* source)
{
    char swap_buffer[N];

    std::memcpy(
        swap_buffer, source, N);

    if (source < dest)
        std::memmove(
            source, (char*)source + N,
            (char*)dest - (char*)source);
    else
        std::memmove(
            (char*)dest + N, dest,
            (char*)source - (char*)dest);

    std::memcpy(
        dest, swap_buffer, N);
}
`
////////////////////////////////////
            ;
        }

        return 'fu_MEMSLIDE<' + numBytesExpr + '>(' + destExpr + ', ' + srcExpr + ')';
    }

    fn annotateMap(): void
    {
        include('"../lib/map.h"');
    }

    fn annotateVector(): void
    {
        include('"../lib/vec.h"');
    }

    fn annotateString(): string
    {
        include('"../lib/str.h"');

        return 'fu_STR';
    }

    fn annotateNever(): string
    {
        let NEVER = '::NEVER';
        if (!_tfwd.has(NEVER))
        {
            include('<stdexcept>');

            _tfwd[NEVER] =
////////////////////////////////////
`
struct fu_NEVER
{
    fu_NEVER(const fu_NEVER&) = delete;
    void operator=(const fu_NEVER&) = delete;

    template<typename T>
    [[noreturn]] operator T() const
    {
        throw std::runtime_error("fu_NEVER cast");
    }
};
`
////////////////////////////////////
            ;
        }

        return 'fu_NEVER';
    }

    fn cgThrow(kind: string, item: string): string
    {
        let THROW = '::THROW';
        if (!_ffwd.has(THROW))
        {
            annotateNever();
            include('<stdexcept>');
            include('<string>');

            _ffwd[THROW] =
////////////////////////////////////
`
[[noreturn]] fu_NEVER fu_THROW(const char* what)
{
    throw std::runtime_error(what);
}

template <typename T>
[[noreturn]] fu_NEVER fu_THROW(const T& what)
{
    throw std::runtime_error(
        std::string(
            what.data(), size_t(what.size())));
}
`
////////////////////////////////////
            ;
        }

        if (kind == 'assert')
        {
            // TODO
        }

        return 'fu_THROW(' + item + ')';
    }

    fn cgConcat(items: string[]): string
    {
        let CONCAT = '::CONCAT';
        if (!_ffwd.has(CONCAT))
        {
            annotateVector();

            _ffwd[CONCAT] =
////////////////////////////////////
`
template <typename T>
fu_VEC<T> fu_CONCAT(
    const fu_VEC<T>& a,
    const fu_VEC<T>& b)
{
    fu_VEC<T> result;
    result.reserve(a.size() + b.size());

    for (const auto& i : a) result.push(i);
    for (const auto& i : b) result.push(i);

    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_CONCAT(' + items.join(', ') + ')';
    }

    fn cgJoin(items: string[]): string
    {
        let JOIN = '::JOIN';
        if (!_ffwd.has(JOIN))
        {
            annotateString();
            annotateVector();

            _ffwd[JOIN] =
////////////////////////////////////
`
inline fu_STR fu_JOIN(
    const fu_VEC<fu_STR>& vec,
    const fu_STR& sep)
{
    int len = 0;
    for (int i = 0; i < vec.size(); i++)
    {
        if (i)
            len += sep.size();

        len += vec[i].size();
    }

    fu_STR result;
    result.reserve(len);
    for (int i = 0; i < vec.size(); i++)
    {
        if (i)
            result += sep;

        result += vec[i];
    }

    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_JOIN(' + items.join(', ') + ')';
    }

    fn cgSplit(items: string[]): string
    {
        let SPLIT = '::SPLIT';
        if (!_ffwd.has(SPLIT))
        {
            annotateString();
            annotateVector();
            include('"../lib/vec/find.h"');

            _ffwd[SPLIT] =
////////////////////////////////////
`
inline fu_VEC<fu_STR> fu_SPLIT(
    fu_STR s,
    const fu_STR& sep)
{
    fu_VEC<fu_STR> result;

    int next;
    while ((next = fu::lfind(s, sep)) >= 0)
    {
        result.push(slice(s, 0, next));
        s = slice(s, next + sep.size());
    }

    result.push(static_cast<fu_STR&&>(s));
    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_SPLIT(' + items.join(', ') + ')';
    }

    fn cgKeys(items: string[]): string
    {
        let KEYS = '::KEYS';
        if (!_ffwd.has(KEYS))
        {
            annotateMap();
            annotateVector();

            _ffwd[KEYS] =
////////////////////////////////////
`
template <typename K, typename V>
fu_VEC<K> fu_KEYS(
    const fu_COW_MAP<K, V>& map)
{
    return map.m_keys;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_KEYS(' + items.join(', ') + ')';
    }

    fn cgLiteral(node: SolvedNode): string
    {
        return node.value || fail();
    }

    fn cgEmpty(): string
    {
        return '';
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(node: SolvedNode)
            node.kind == 'if'
                ? ' ' + cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && boolWrap(n0.type, cgNode(n0, M_RETBOOL));
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return 'if (' + cond + ')' + cons + (alt ? _indent + 'else' + alt : '');

        if (cons && alt)
            return '(' + cond + ' ? ' + cons + ' : ' + alt + ')';

        if (cons)
            return '(' + cond + ' && ' + cons + ')';

        if (alt)
            return '(' + cond + ' || ' + alt + ')';

        return fail('TODO');
    }

    fn boolWrap(type: Type, src: string): string
    {
        if (type_isString(type))
            return src + '.size()';

        return src;
    }


    //

    fn cgDefault(type: Type): string
    {
        if (type.quals & q_ref && !(type.quals & q_mutref))
        {
            let DEFAULT = '::DEFAULT';
            if (!_ffwd.has(DEFAULT))
            {
                _ffwd[DEFAULT] =
////////////////////////////////////
`
template <typename T>
struct fu_DEFAULT { static inline const T value {}; };
`
////////////////////////////////////
                ;
            }

            return 'fu_DEFAULT<' + typeAnnot(clear_refs(type)) + '>::value';
        }

        return typeAnnot(type) + '{}';
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            let items = node.items;

            let retSecondLast = items[items.len - 1].type == t_never;

            let condEnd = retSecondLast
                        ? items.len - 2
                        : items.len - 1;

            mut src = '';

            if (condEnd)
            {
                src += 'if (';

                for (mut i = 0; i < condEnd; i++)
                {
                    let item = items[i];
                    if (i) src += ' && ';
                    src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                }

                src += ') ';
            }

            let tail = cgNode(items[condEnd]);

            if (retSecondLast)
            {
                src += '{ ' + typeAnnot(type) + ' _ = ' + tail + '; ';
                src += 'if (!' + boolWrap(type, '_') + ') return _; } ';
                src += cgNode(items[items.len - 1]) + ';'; //FAIL
            }
            else
            {
                src += 'return ' + tail + ';'; //TRUTHY
                src += ' else return ' + cgDefault(type) + ';';
            }

            src = '([&]() -> ' + typeAnnot(type) + ' { ' + src + ' }())';

            return src;
        }

        mut src = '(';
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];

            if (i) src += ' && ';
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ')';
    }

    fn cgNot(node: SolvedNode): string
    {
        let item = node.items[0];
        return '!' + boolWrap(
            item.type, cgNode(item, M_RETBOOL));
    }

    fn cgOr(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            let annot = typeAnnot(type);

            mut src = '([&]() -> ' + annot + ' {';

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == 'and')
                {
                    let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src += ' if (';
                    for (mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src += ' && ';

                        let item = items[i] || fail();
                        src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                    }

                    src += ')';
                }

                src += ' { ' + annot + ' _ = ' + cgNode(tail) + '; if (' + boolWrap(tail.type, '_') + ') return _; }';
            }

            let tail = items[items.len - 1] || fail();
            if (!(tail.type == t_never))
                src += ' return';

            src += ' ' + cgNode(tail) + '; }())';
            return src;
        }

        mut src = '(';
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (i) src += ' || ';
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ')';
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == '}' || fail();
        return src.slice(0, src.len - 1) + postfix + '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = n_init && cgNode(n_init);
        let cond = n_cond && boolWrap(n_cond.type, cgNode(n_cond, M_RETBOOL));
        let post = n_post && cgNode(n_post);
        mut body = n_body && blockWrapSubstatement(n_body);
        let pcnd = n_pcnd && boolWrap(n_pcnd.type, cgNode(n_pcnd, M_RETBOOL));
        mut breakLabel = '';

        if (body && node.value)
        {
            let brk = 'L_' + node.value + '_b';
            let cnt = 'L_' + node.value + '_c';

            if (body.has(cnt))
                body = '{' + postfixBlock(body, _indent +     '    }' + cnt + ':;');
            if (body.has(brk))
                breakLabel = _indent + '    ' + brk + ':;';
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail('TODO extended loop.');

            return 'do' + body + _indent + 'while (' + pcnd + ')' + breakLabel;
        }

        if (init || post || !cond)
            return 'for (' + init + '; ' + cond + '; ' + post + ')' + body + breakLabel;

        return 'while (' + cond + ')' + body + breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let let_main    = items[0];
        let let_init    = cgNode(items[0].items[LET_INIT]);
        let err_id      = items[1].value;
        let catch_body  = blockWrapSubstatement(items[2]);

        mut src =        binding(let_main, forceMut: true) + ';';
        src += _indent + 'try';
        src += _indent + '{';
        src += _indent + '    ' + let_main.value + ' = ' + let_init + ';';
        src += _indent + '}';
        src += _indent + 'catch (const std::exception& o_0)';
        src += _indent + '{';
        src += _indent + '    const fu_STR& ' + err_id + ' = fu_TO_STR(o_0.what());';
        src += _indent + catch_body;
        src += _indent + '}\n';

        return src;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == 'root')        return cgRoot(node);
        if (k == 'block')       return cgBlock(node);
        if (k == 'fn')          return cgFn(node);
        if (k == 'return')      return cgReturn(node);
        if (k == 'break')       return cgJump(node);
        if (k == 'continue')    return cgJump(node);
        if (k == 'call')        return cgCall(node, mode);
        if (k == 'let')         return cgLet(node);
        if (k == 'if')          return cgIf(node, mode);
        if (k == '!')           return cgNot(node);
        if (k == 'or')          return cgOr(node);
        if (k == 'and')         return cgAnd(node);
        if (k == 'loop')        return cgLoop(node);
        if (k == 'int')         return cgLiteral(node);
        if (k == 'str')         return cgStringLiteral(node);
        if (k == 'arrlit')      return cgArrayLiteral(node);
        if (k == 'definit')     return cgDefaultInit(node);
        if (k == 'empty')       return cgEmpty();

        if (k == 'comma')       return cgParens(node);
        if (k == 'parens')      return cgParens(node);
        if (k == 'label')       return cgParens(node);
        if (k == 'struct')      return cgEmpty();

        if (k == 'copy')        return cgCopyMove(node);
        if (k == 'move')        return cgCopyMove(node);
        if (k == 'catch')       return cgCatch(node);

        return fail('TODO: ' + k);
    }


    //

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == 'move')
            return cgSteal(a);

        return cgClone(node.type, a);
    }

    fn cgSteal(src: string): string
    {
        include('<utility>');
        return 'std::move(' + src + ')';
    }

    fn cgSwap(items: string[]): string
    {
        include('<utility>');
        return 'std::swap(' + items.join(', ') + ')';
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) + '(' + src + ')';
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        for (mut i = 0; i < nodes.len; i++)
        {
            let node  = nodes[i];
            let src   = node ? cgNode(node, mode) : '';

            result.push(src);
        }

        return result;
    }


    //

    root.kind == 'root' || fail();

    let src = cgNode(root);
    return src;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     The whole thing in one go.

fn compile(fname: string, via: string = ''): string
{
    let implicit mut module = getModule(fname);

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = ModuleOutputs;

        let src = getFile(fname) || throw (
            '#import badfile: `' + via + fname + '`.');

        let t0 = now_hr();
        let lexer_result =
            lex(:fname, :src);

        let t1 = now_hr();
        module.in = ModuleInputs(
            :src, lex: lexer_result,
            :parse( :fname, lexer_result.tokens));

        let t2 = now_hr();

        // Stat.
        module.stats.s_lex   = t1 - t0;
        module.stats.s_parse = t2 - t1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular #import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            '#import circle: `' + via + fname + '`.');
    }

    // Compile dependencies.
    let imports = module.in.parse.imports;
    for (mut i = 0; i < imports.len; i++)
        compile(
            fname: imports[i],
              via: fname + ' <- ' + via);

    // We're good to go here.
    if (!module.out)
    {
        let t0 = now_hr();
        module.out.solve = solve(
            module.in.parse.root);

        let t1 = now_hr();
        module.out.cpp = cpp_codegen(
            module.out.solve.root,
            module.out.solve.scope);

        let t2 = now_hr();

        module.stats.s_solve = t1 - t0;
        module.stats.s_cpp   = t2 - t1;

        // Final repersist.
        setModule(module);
    }

    // --------------------------------------------- //
    // print('lex     ', module.stats.s_lex,   's'); //
    // print('parse   ', module.stats.s_parse, 's'); //
    // print('solve   ', module.stats.s_solve, 's'); //
    // print('codegen ', module.stats.s_cpp,   's'); //
    // --------------------------------------------- //

    return module.out.cpp;
}

fn compile_testcase(mut src: string, mut fname = ''): string
{
    if (!fname)
        fname = 'testcase';

    // Some nonsense.
    if (!src.has('fn ZERO()'))
        src = '\n\nfn ZERO(): i32 {\n' + src + '\n}\n';

    src += '\nfn main(): i32 ZERO();\n\n';

    //
    let implicit mut ctx = CTX_PROTO;
        ctx.files[fname] = src;

    return compile(:fname);
}





// A very quick test.

let TEST_SRC = `

    fn test(one: i32)
    {
        let zero = one - 1;
        let two  = one * 2;

        fn inner(i: i32): i32
            i > zero ? outer(i - one) : zero;

        fn outer(i: i32): i32
            two * inner(i);

        return outer(one) + (two - one) * 17;
    }

    fn ZERO(): i32
    {
        return test(1) - 17;
    }

`;

fn ZERO(): i32
{
    let cpp = compile_testcase(TEST_SRC);

    return cpp.find('main()') ? 0 : 101;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Orchestration.

fn absdir(a: string)
    a.last == '/' ? a : a + '/';

let HOME = absdir(env_get('HOME') || '/Users/hdachev');

fn locate_PRJDIR(): string {
    let dir = HOME + 'fu/';
    let fn  = dir  + 'src/compiler.fu';
    let fs  = file_size(fn);
        fs  > 10000 || throw('Bad compiler.fu: ' + fn + ': ' + fs);

    print('PRJDIR: ' + dir);
    return dir;
}

let PRJDIR = locate_PRJDIR();

let GCC_CMD = 'g++ -std=c++1z -O3 '
            + '-pedantic-errors -Wall -Wextra -Werror ' // opt-in
            + '-Wno-parentheses-equality ' // opt-out
            ;

fn buildAndRun(cpp: string): string
{
    mut code    : i32;
    mut stdout  : string;

    let hash    = hash_tea(cpp);
    let F       = PRJDIR
                + "build.cpp/tea-"  + hash
                + "-"               + cpp.len;

    fn ERR()
    {
        file_write(
            PRJDIR + "build.cpp/failing-testcase.cpp",
                cpp);

        if (!stdout)
            stdout = "[ EXIT CODE " + code + " ]";

        return stdout;
    }

    if (file_size(F + ".exe") <= 0)
    {
        ///////////////////////
        // NEW_STUFF = true; //
        ///////////////////////

        file_write(F + ".cpp", cpp);

        print('  BUILD ', F, '.cpp');
        let t0 = now_hr();

        code = shell_exec(GCC_CMD+ "-c -o " +F+ ".o " +F+ ".cpp 2>&1", stdout)
            || shell_exec(GCC_CMD+ "-o " +F+ ".tmp " +F+ ".o 2>&1", stdout)
            || shell_exec("chmod 755 " +F+ ".tmp", stdout)
            || shell_exec("mv " +F+ ".tmp " +F+ ".exe", stdout)
            || shell_exec("rm " +F+ ".o", stdout);

        if (code) return ERR;

        let t1 = now_hr();
        print('     OK ', t1 - t0, 's');
    }

    code = shell_exec(F+ ".exe", stdout);
    if (code) return ERR;

    return '';
}

let NICE_THINGS =
[
    "LOOKING GOOD TODAY !",
    "PASSING TESTS LIKE A BOSS !",
    "THIS IS SOME TOP NOTCH SHIT !",
    "VALUE ADDED !",

    "GOING STRONG !",
    "KILLIN IT !",
    "POWER LEVEL INCREASED !",
    "NOW MAKE ME BETTER AGAIN !",

    "NOW MAKE ME EVEN MORE BETTER !",
    "ALL CLEAR !",
    "UPGRADE ACCEPTED !",
    "YOU'RE THE BEST MAN !",

    "I LOVE YOU YOU !",
    "MORE IS MORE !",
    "THIS IS AWESOME !",
    "THIS IS AWESOME !",
];

fn saySomethingNice()
{
    let sec = i32(now_utc());

/////////////////////////////
    let NEW_STUFF = false; //
/////////////////////////////

    if (sec % 5 && !NEW_STUFF)
    {
        mut str = '';
        for (mut i = 0; i < 3; i++)
            if (sec & (1 << i))
                str += '🍒';
            else
                str += '🍊';

        print(str);
    }
    else
    {
        print(NICE_THINGS[(sec >> 6) & 0xf]);
    }
}

fn ZERO(src: string, fname = ''): string
{
    let cpp     = compile_testcase(:src, :fname);
    let result  = buildAndRun(:cpp);
    if (result)
        throw(result);

    return cpp;
}

fn FAIL(src: string): i32
{
    let cpp = compile_testcase(src)
        catch e
            return e.len; // TODO validate

    throw("DID NOT THROW: " + cpp);
}

fn updateCPPFile(path: string, cpp: string)
{
    let fname = path + '.cpp';
    if (file_read(fname) != cpp)
    {
        file_write(fname, cpp);
        print('WROTE ' + fname);
    }
}

fn FU_FILE(mut fname: string)
{
    fname = PRJDIR + 'src/' + fname;

    print('COMPILE ', fname);

    let src = file_read(fname);
    if (!src)
        throw ('BAD FILE: ' + fname);

    let t0  = now_hr();
    let cpp = ZERO(:src, :fname);
    let t1  = now_hr();
    let tt  = t1 - t0;

    print('        ', tt, 's\n');

    if (WRITE_COMPILER)
        updateCPPFile(fname, cpp);
}


//

fn runTestSuiteAndBuildCompiler()
{
    runTestSuite();
    saySomethingNice();
    FU_FILE('compiler.fu');
}


// Test suite!

fn runTestSuite()
{
    ZERO(`
        return 1 - 1;
    `);

    ZERO(`
        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);


    // Mutation & references.

    ZERO(`
        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;
    `);

    ZERO(`
        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    FAIL(`
        let sum = 0;
        while (sum < 15)
            sum++; //ERR ++ overload

        return sum - 15;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);
    `);


    // Structs & using.

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;
    `);

    FAIL(`
        struct Range {
            min: i32;
            max: i32;
        }

        let r = Range(1, 2);
        r.min++; //ERR ++ overload
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using r: Range)
            max - min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;

            fn size()
                max - min;
        }

        let r = Range(14, 21);

        return size(r) - 7;
    `);

    ZERO(`
        struct X {
            a: i32;
            fn test(b: i32) a + b;
        }

        return X(1).test(-1);
    `);

    ZERO(`
        struct X {
            a: i32;
            fn test(b: i32) a + b;
        }

        fn hey(using x: X) test(-1);

        return X(1).hey;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;

            fn dist(other: Player)
                x - other.x;
        }

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);


    // Recursion, closures & implicit args.

    ZERO(`
        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);
    `);

    ZERO(`
        fn test(one: i32)
        {
            let zero = one - 1;
            let two  = one * 2;

            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn ZERO() test(1) - 17;
    `);

    ZERO(`
        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;
    `);


    //

    ZERO(`
        let x = 1;

        fn test(): &i32
            x;

        return test - 1;
    `);

    ZERO(`
        let a = 1;
        let x: &i32 = a;

        return a - x;
    `);

    ZERO(`
        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;
    `);

    ZERO(`
        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;
    `);


    // Templating checks.

    ZERO(`
        let x = 3;
        return x / 2 - 1;
    `);

    // FAIL(`
    //     fn div3by(a: i32) 3 / a; //ERR overload
    //     return div3by(2) - 1;
    // )");

    ZERO(`
        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;
    `);

    // It's too early for this test,
    //  let's get everything else working first,
    //   not smart working on supersugar so early.
    //
    // ZERO(`
    //     fn div3by(a) 3 / a;
    //     return div3by(2) - 1;
    // )");


    // Destructor basics.

    let RAII = `
        let mut i = 0;
        struct S {
            j: &mut i32;
            fn free()
                j += j + 1;
        }
    `;

    ZERO(RAII + `
        let s = S(i);
        return i;
        // <-destructor here
    `);

    ZERO(RAII + `
        { let s = S(i); } // <-destructor here
        return i - 1;
    `);

    ZERO(RAII + `
        fn test(s: &S) { return s.j; }
        test(S(i)); // <-destructor here
        return i - 1;
    `);

    ZERO(RAII + `
        fn test(s: &S) { return s.j; }
        let s = S(i);
        test(s);
        return i;
        // <-destructor here
    `);


    // Move semantics.

    ZERO(RAII + `
        fn test(s: S) { return s.j; } // <-destructor here
        test(S(i));
        return i - 1;
    `);

    FAIL(RAII + `
        fn test(mut s: S) { return s.j; } // <-destructor here

        mut s = S(i);
        test( s ); //ERR explicit

        return i - 1;
    `);

    ZERO(RAII + `
        fn test(mut s: S) {
            let x = STEAL (s);
            return x.j; // <-destructor here
        }

        mut s = S(i);
        test( STEAL(s) );

        return i - 1;
    `);

    /*

    FAIL(RAII + `
        fn test(s: S) {} // <-destructor here
        let s = S(i);
        test(s); // s is moved in
        test(s); //ERR moved
        return i - 1;
    `);


    // Borrow checker.

    const BORROW = `
        struct Borrow {
            x: &i32;
        }
    `;

    FAIL(BORROW + `
        let mut b: Borrow;
        return b.x; //ERR initialize
    `);

    ZERO(BORROW + `
        let mut b: Borrow;
        let i = 0;
        b = Borrow(i);
        return b.x;
    `);

    FAIL(BORROW + `
        let b = Borrow(0); //ERR outlive
        return b.x;
    `);

    ZERO(BORROW + `
        let i = -1;
        let b = Borrow(i);
        b.x++;
        return i;
    `);

    FAIL(BORROW + `
        let b: Borrow;
        {
            let i = -1;
            b = Borrow(i); //ERR outlive
        }
        return ++b.x;
    `);

    FAIL(BORROW + `
        let b: Borrow;

        fn test() {
            let i = -1;
            b = Borrow(i); //ERR outlive
        }

        test();
        return ++b.x;
    `);

    FAIL(BORROW + `
        fn test() {
            let i = -1;
            return Borrow(i); //ERR outlive
        }

        let b = test();
        return ++b.x;
    `);

    // */

    // Arrays.

    ZERO(`
        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];
    `);


    // A basic testing setup for array ops,
    //  that can be flipped around for making sure
    //   e.g. copy-on-write behaves as expected.

    fn ARROPS(
        literal: string,
        operation: string,
        mut assertion: string)
    {
        assertion = '(' + assertion + ')';

        fn EXPR(varname: string)
            assertion.replace(
                all: '@', with: varname);

        mut src: string;

        src += "\n";
        src += "\n    {";
        src += "\n        mut arr0 = [" + literal + "];";
        src += "\n        arr0." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr0") + " != 0) return 13;";
        src += "\n    }";
        src += "\n";
        src += "\n    mut orig = [" + literal + "];";
        src += "\n";
        src += "\n    {";
        src += "\n        mut arr1 = CLONE(orig);";
        src += "\n        arr1." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr1") + " != 0) return 17;";
        src += "\n    }";
        src += "\n";
        src += "\n    {";
        src += "\n        mut arr2 = STEAL(orig);";
        src += "\n        if (orig.len) return 19;";
        src += "\n        arr2." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr2") + " != 0) return 23;";
        src += "\n    }";
        src += "\n";
        src += "\n    return 0;";
        src += "\n";

        ZERO(src);
    };

    ARROPS( "0,1,2,3,4",
            "push(5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "insert(5, 5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "pop()",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "splice(4, 1)",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "unshift(5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "insert(0, 5)",
            "@[2] + @[5] - @[0]");

    // We don't seem to have shifting yet.
    // ARROPS( "0,1,2,3,4",
    //         "shift()",
    //         "@[0] + @[2] - @[3]");

    ARROPS( "0,1,2,3,4",
            "insert(1, 5)",
            "@[2] + @[5] - @[1]");

    ARROPS( "0,1,2,3,100",
            "splice(1, 3)",
            "@.len + @[0] + @[1] - 102");


    //

    ZERO(`
        let OPERATORS = [ '+', '-', '*', '/' ];

        fn ZERO()
            OPERATORS[2] == '*' ? 0 : 1;
    `);

    ZERO(`
        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;
    `);

    ZERO(`
        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];
    `);

    ZERO(`
        mut a = [0, 1, 2, 3, 4]; // [2, 0, 1, 3, 4]
        a.move(2, 0);
        return a[0] + a[3] - a[2] - a[4];
    `);

    ZERO(`
        mut a = [2, 0, 1, 3, 4]; // [0, 1, 2, 3, 4]
        a.move(0, 2);
        return a[1] + a[4] - a[2] - a[3];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];
    `);


    // Strings.

    ZERO(`
        mut str = 'hello ';
        str += 'world';

        return str.len - 11;
    `);

    ZERO(`
        let str = 'hello ' + 'world';

        return str.starts(with: 'hel')
             ? str.len - 11
             : 171;
    `);

    ZERO(`
        let str = 'a' + 1710010;

        return str == 'a1710010'
             ? 0 : 101;
    `);

    ZERO(`
        let str = 'hello world';
        mut cpy = '';
        for (mut i = 0; i < str.len; i++)
            cpy += str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);
    `);

    ZERO(`
        return 'hello world'.find('world')
             - 2 * [1, 7, 13, 14, 19].find(14); // expect_lambda
    `);

    ZERO(`
        return ('hello world'.has('world') ? 1 : 0) // expect_lambda
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;
    `);

    ZERO(`
        let hw = 'hello world!';
        let a = hw.slice(6, 6 + 5); // expect_lambda
        let b = hw.substr(6, 5);
        return a == b && a == 'world' ? a.len - 5 : 1;
    `);

    ZERO(`
        let tests =
        [
            '',
            ' ',
            '  ',
            'hey you duders',
            ' hey you duders',
            'hey you duders ',
            '  hey you duders ',
            '  hey you  duders ',
            '  hey you  duders  '
        ];

        fn test(item: string)
            item == item.split(' ').join(' ')
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;
    `);


    // Maps.

    ZERO(`
        mut x: Map(string, i32);

        x['hello'] = 1;
        x['world'] = 2;

        return x['hello'] - x['world'] + 1;
    `);

    ZERO(`
        mut x: Map(string, i32);

        x['hello'] = 1;
        x['world'] = 2;

        let b = 'hello world';
        mut offset = 0;

        fn pop(): string { // expect_lambda
            mut a = '';

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a += c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;
    `);


    // Default arguments.

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test() - 3;
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(b: -1);
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(-2);
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(1);
        return t.b;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;
    `);

    ZERO(`
        struct Test { x: i32; };
        fn hey() Test(); // expect_lambda private type, technically ok, technically ok though not needed
        return hey.x;
    `);

    ZERO(`
        struct Test { x: i32; };
        fn hey(y: i32 = 0) // expect_lambda private type, technically ok though not needed
            y   ? Test(1)
                : Test();

        return hey.x;
    `);


    // Truth tests.

    ZERO(`
        let s = 7;
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = 0;
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = 'hello';
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = '';
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = [ 4 ];
        return s ? 0 : 1;
    `);

    ZERO(`
        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;
    `);


    // Loop labels.

    ZERO(`
        mut sum = 0;

        :outer for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :outer;
                if (x == 2) break    :outer;
            }
        }

        return sum - 34;
    `);


    // Comma operator.

    ZERO(`
        mut a = 0;
        return (a++, a - 1);
    `);


    // Lint.

    ZERO(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        t.test();
        return t.x - 1;
    `);

    FAIL(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        t.test; //ERR orphan
        return t.x - 1;
    `);


    // Logical selectors.

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = x || y;

        return w == 'hello' ? 0 : 1; // expect_lambda
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = x && y; // expect_lambda

        return w == 'world' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = 3 && x || y; // expect_lambda

        return w == 'hello' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let arr: i32[];
        let w = arr && x || y; // expect_lambda

        return w == 'world' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let arr: i32[];
        let w = arr && x || y || throw("Nope."); // expect_lambda

        return w == 'world' ? 0 : 1;
    `);


    // Short-circuit assignment, esp. useful for maps
    //  and the cpp `map[k] = v`,
    //   which doesn't decompose safely.

    ZERO(`
        mut i = 7;
        i ||= 11; // expect_lambda
        return i - 7;
    `);

    ZERO(`
        mut i = 0;
        i ||= 11; // expect_lambda
        return i - 11;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m['hello'] = 'world';
        fn f() (
            g++, 'cruel world'); // expect_lambda

        m['hello'] ||= f();
        return g;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m['_not_hello_'] = 'world';
        fn f() (
            g++, 'cruel world'); // expect_lambda

        m['hello'] ||= f();
        return g - 1;
    `);


    // Lint checks.

    ZERO(`
        {
            {
                return 0;
            }
        }
    `);

    FAIL(`
        {
        {
            return 0; //ERR block
        }
        }
    `);

    ZERO(`
        {
            return 0;
        }
    `);

    FAIL(`
        {
            return 0; //ERR block
       }
    `);

    FAIL(`
        {
            return 0; //ERR block
         }
    `);


    // Stuff that isn't working out quite right -
    //  Keep those around, there's no principle to these tests,
    //   they just stressed our stuff in weird ways.

    ZERO(`

    struct BINOP {
        P: Map(string, i32);
    };

    fn setupOperators()
    {
        mut out: BINOP;

        fn binop(op: string)
            out.P[op] = 7;

        binop(',');

        return out;
    }

    let BINOP   = setupOperators();
    let P_COMMA = BINOP.P[','] || assert();

    fn ZERO() P_COMMA - 7;

    `);

    ZERO(`

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = 'x';
        if (!(trail >= '0' && trail <= '9') &&
            !(hex && (trail >= 'a' && trail <= 'f'
                   || trail >= 'A' && trail <= 'F')))
        {
            return 0;
        }

        return 1;

    `);

    ZERO(`
        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags:      i32;
            value:      string;
            items:      SolvedNode[];
            token:      Token;

            type:       Type;
            target:     ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: 'definit',
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;
    `);

    ZERO(`
        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        pub fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            '', id, t_template,
            min, max, arg_n,
            :template);
    `);

    ZERO(`
        let i = 0;
        let items = [ '' ];
        i == items.len - 1 || throw('what?');
        return i;
    `);

    ZERO(`

        return false /* test */
             ? 0xffffff // what is this
             : 0 // madness
             ;
    `);

    ZERO(`

        fn path_normalize(p: string): string {
            mut path = p.split('/');

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == '.' || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == '..')
                    path.splice(--i, 2);
            }

            return path.join('/');
        }

        fn path_join(a: string, b: string)
            path_normalize(a + '/' + b);

        fn ZERO()
            path_join('hello/hey', './../you//') == 'hello/you/'
                ? 0 : 1;
    `);


    // Let's move on to some cooler quality of life shit.

    ZERO(`
        let a = 7;
        let b = a && 3;
        return b - 3;
    `);

    ZERO(`
        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw('woot');
    `);

    ZERO(`

        struct TrueStory { kind: string; value: string; };

        mut specialized = TrueStory(kind: 'fn', value: 'val');

        specialized.kind == 'fn' && specialized.value || throw('nope');

        let v: &mut string = specialized.kind == 'fn'
                          && specialized.value
                          || throw('nope');
        v += 'ue';

        return specialized.value == 'value' ? 0 : 1;

    `);

    ZERO(`
        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token('hey');
        };

        fn ZERO(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };
    `);

    FAIL(`
        struct ScopeIdx { raw: i32; };
        fn thing(x: i32) x;
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);
    `);


    // Various templating fallacies.
    //
    // TODO figure these out -
    //  These are problematic in a bunch of ways here.
    //   But mostly, the case patterns for this kind of thing are outright moronic.

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        fn ZERO()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;
    `);

    ZERO(`
        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;
    `);


    // Let's try something new.

    ZERO(`

        struct SolvedNode {
            value: i32;
            items: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn ZERO(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);

            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

    `);


    // Ternary improvements.

    ZERO(`
        return 0 > 1 ? throw('should type check') : 0;
    `);


    // Catch.

    ZERO(`
        fn throw_hey(): i32 {
            throw('hey');
            return 1;
        }

        fn ZERO(): i32 {
            let x = throw_hey()
                catch err
                    return err.len - 3;

            return 7;
        }
    `);
}
