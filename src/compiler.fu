import helpers;
import context;
import stat;


//

fn compile(fname: string, via: string = "")
{
    let implicit mut module = getModule(fname).clone();

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = scope::ModuleOutputs;

        let src = getFile(fname) || throw (
            "import badfile: `" ~ via ~ fname ~ "`.");

        let stat0 = ModuleStat_now();
        let lexer_result = lexer::lex(:fname, :src);

        let stat1 = ModuleStat_now();
        let parser_result = parser::parse( :module.modid, :fname, :lexer_result.tokens );

        let stat2 = ModuleStat_now();

        module.in = scope::ModuleInputs(
            :src, lex: lexer_result,
            parse: parser_result);

        // Stat.
        module.stats.lex   = stat1 - stat0;
        module.stats.parse = stat2 - stat1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            "import circle: `" ~ via ~ fname ~ "`.");
    }

    // We're good to go here.
    if (!module.out)
    {
        // Ensure dependencies.
        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
            compile(
                fname: resolveFile(fuzimports[i]),
                  via: fname ~ " <- " ~ via);

        //
        let stat0 = ModuleStat_now();
        module.out.solve = solver::solve(
            module.in.parse.root);

        let stat1 = ModuleStat_now();
        module.out.cpp = codegen::cpp_codegen(
            module.out.solve.root);

        let stat2 = ModuleStat_now();

        module.stats.solve   = stat1 - stat0;
        module.stats.codegen = stat2 - stat1;

        // Final repersist.
        setModule(module);
    }
}


//

fn absdir(a: string)
    a.if_last == '/' ? a : a ~ '/';

let HOME = absdir(env::get("HOME"));

pub fn locate_PRJDIR(): string
{
    let dir = HOME ~ "fu/";
    let fn = dir  ~ "src/compiler.fu";
    let fs = file::size(fn);
    fs > 1000 || throw("Bad compiler.fu: " ~ fn ~ ": " ~ fs);

    println("PRJDIR: " ~ dir);
    return dir;
}

pub let PRJDIR              = locate_PRJDIR();
pub let DEFAULT_WORKSPACE   = PRJDIR ~ "build-cpp/";
pub let FULIB               = PRJDIR ~ "include/fu/_fulib.cpp";


//

pub fn build(
      fname: string,
        run: bool,

    dir_wrk: string,

    bin     = "",
    dir_obj = "",
    dir_src = "",
    dir_cpp = "",
    scheme  = "")
{
    let implicit mut ctx = prelude::CTX_PRELUDE.clone();

    {
        println("COMPILE ", fname);

        let t0 = now::hr();
        compile(:fname);
        let t1 = now::hr();
        let tt = t1 - t0;

        if (t1 - t0 > 0.025)
        {
            mut lex:        ModuleStat;
            mut parse:      ModuleStat;
            mut solve:      ModuleStat;
            mut codegen:    ModuleStat;

            ref m = ctx.modules;
            for (mut i = 0; i < m.len; i++)
            {
                lex     += m[i].stats.lex;
                parse   += m[i].stats.parse;
                solve   += m[i].stats.solve;
                codegen += m[i].stats.codegen;
            }

            ModuleStat_print(lex,   "\n    lex ");
            ModuleStat_print(parse,   "  parse ");
            ModuleStat_print(solve,   "  solve ");
            ModuleStat_print(codegen, "codegen ", "\n");
        }

        println("        ", tt, "s\n");
    }

    return ::build(
        :ctx, :run, :bin, :scheme,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp,
        unity: fname, fulib: FULIB);
}


// Test running infra.

let NOTES = [
    "FN_recursion",
    "FN_resolve",
    "FN_reopen",
    "TYPE_recursion",
    "TYPE_resolve",
    "TYPE_reopen",
    "DEAD_code",
    "DEAD_call",
    "DEAD_let",
    "DEAD_if",
];

pub fn compile_snippets(sources: string[], fnames?: string[]): Context
{
    fn ensure_main(src: string)
        src.has("fn main(")
            ? src
            : "\n\nfn main(): i32 {\n" ~ src ~ "\n}\n";

    let implicit mut ctx = prelude::CTX_PRELUDE.clone();
    for (mut i = 0; i < sources.len; i++)
    {
        let snippet = sources[i];
        let src     = i == sources.len - 1
                    ? ensure_main(snippet)
                    : snippet;

        let fname   = fnames.len > i ? fnames[i] : PRJDIR ~ "__tests__/_" ~ i ~ ".fu";

        ctx.files[fname] = src;
        compile(:fname);
    }

    for (mut i = 0; i < ctx.modules.len; i++)
    {
        ref module = ctx.modules[i];
        mut notes = module.out.solve.notes;
        for (mut bit = 0; bit < NOTES.len && notes; bit++)
        {
            let mask = 1 << bit;
            let isset = notes & mask;
            let annot = NOTES[bit];
            notes &= ~mask;
            if (isset)
                module.in.src.has(annot) || throw(
                    "SLOW:\n\tMissing " ~ annot ~ " annotation:\n" ~ module.in.src);
            else
                module.in.src.has(annot) && throw(
                    "OVERANNOT:\n\t" ~ annot ~ " not needed for this snippet:\n" ~ module.in.src);
        }
    }

    return ctx;
}

pub fn snippet2cpp(src: string): string
{
    let fname = "SNIPPET";

    let ctx = compile_snippets([ src ], [ fname ]);
    for (mut i = 0; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        if (module.fname == fname)
            return module.out.cpp;
    }

    return "";
}

pub fn ZERO(
    implicit ref testdiffs: testdiff::TestDiffs,
    mut sources: string[]): Context
{
    mut expectations: string[][];

    //
    for (mut i = 0; i < sources.len; i++)
    {
        ref src = sources[i];

        // Trim trailing spaces
        //  to help with manual testdiff edits.
        {
            mut end = src.len;
            for (mut r = src.len; r --> 0 && src[r] == ' '; )
                end = r;

            src.shrink(end);
        }

        // Collect ;; TODO and ;; EXPECTs.
        mut start = 0;
        while ((start = src.find(" ;; ", :start)) >= 0)
        {
            mut end = src.find('\n', start + 4);
            if (end < 0)
                end = src.len;

            expectations.grow_if_oob(i) ~= src.slice(start + 4, end);

            // Turn ;; commands into // comments and hop over.
            src[start + 1]  = '/';
            src[start + 2]  = '/';
            start           = end;
        }
    }

    // We can now safely do the nowrites second -
    //  so that we can first test if the thing works,
    //   and only then allow you to persist it as an OK test output.
    //
    let ctx = compile_snippets(:sources);

    // Deal with expectations first, nicer errors.
    for (mut i = 0; i < expectations.len; i++)
    {
        let arr = expectations[i];
        let src = sources[i];
        let cpp = ctx.modules[i + 1].out.cpp;

        for (shadow mut i = 0; i < arr.len; i++)
        {
            let x = arr[i];
            let idx = x.find(' ');
            let cmd = x.slice(0, idx);
            let rest = x.slice(idx + 1);

            let found = cpp.has(rest);

            if (cmd == "EXPECT")
                found || throw("EXPECT mismatch: `;; " ~ x ~ "` in:\n" ~ src ~ "\n\nOutput is:\n\n" ~ cpp);
            else if (cmd != "TODO")
                throw("Unknown ;; CHECK: `;; " ~ x ~ "` in:\n" ~ src);
            else if (found)
                throw("TODO test is actually passing: `;; " ~ x ~ "` in:\n" ~ src ~ "\n\nOutput is:\n\n" ~ cpp);
            else
                println("  TODO: `;; " ~ x ~ "` in:\n" ~ src);
        }
    }

    let run = true;
    let fulib = FULIB;
    let dir_wrk = DEFAULT_WORKSPACE;

    ::build(:ctx, :run, :fulib, :dir_wrk, scheme: "debug"   , onfail: "print-src");
    ::build(:ctx, :run, :fulib, :dir_wrk                    , onfail: "print-src");

    // OK so it works, let's see if test output actually matches -
    //  this also allows us to perhaps defer all nowrite fails till all tests clear.
    //
    {
        mut key = "";
        for (mut i = 0; i < sources.len; i++)
        {
            key ~= sources[i];
            let actual = ctx.modules
                [i + ctx.modules.len - sources.len]
                    .out.cpp;

            let expect = testdiffs.testdiff::get_current(key);
            if (expect != actual)
            {
                if (!expect)
                {
                    if (!env::get("fu_ALLOW_UNSEEN"))
                        throw("NOWRITE: unknown testcase.\n\nConsider fu_ALLOW_UNSEEN envar:\n" ~ key ~ "\nAbout to write:\n\n" ~ actual);
                }
                else if (!env::get("fu_ALLOW_WRITE"))
                {
                    file::write(PRJDIR ~ "testdiff/expect.tmp", expect);
                    file::write(PRJDIR ~ "testdiff/actual.tmp", actual);

                    throw("NOWRITE: test output mismatch for:\n\n" ~ key ~ "\nPreviously:\n\n" ~ expect ~ "\nNow:\n\n" ~ actual);
                }
            }

            testdiffs.testdiff::set_next(key, actual);
        }
    }

    return ctx;
}

fn FAIL_replace(mut sources: string[]): string[]
{
    for (mut i = 0; i < sources.len; i++)
        sources[i] = sources[i]
            .replace(all: "//*F", with: "/*");

    return sources;
}

fn indent(src: string): string
    src.replace(all: "\n", with: "\n\t");

pub fn FAIL(sources: string[]): string
{
    let ctx = compile_snippets(sources)
        catch e
            return ZERO(FAIL_replace(sources)) && e;

    mut bad = "\nDID NOT THROW:\n";

    for (mut i = 1; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        bad ~= "\n#" ~ i ~ ": "         ~ module.fname ~ "\n";
        bad ~= "\nfu  [" ~ i ~ "]:\n\t" ~ module.in .src.indent
             ~ "\ncpp [" ~ i ~ "]:\n\t" ~ module.out.cpp.indent
             ~ "\n";
    }

    return throw(bad);
}

pub fn ZERO_SAME(alts: string[][])
{
    let expect = ZERO(alts[0]).modules;

    for (mut i = 1; i < alts.len; i++)
    {
        let actual = compile_snippets(sources: alts[i]).modules;
        if (expect.len != actual.len)
            throw("ZERO_SAME: expect/actual len mismatch.");

        for (mut m = 0; m < actual.len; m++)
        {
            let x = expect[m].out.cpp;
            let a = actual[m].out.cpp;

            if (x != a)
                throw(
                    "ZERO_SAME: alts[" ~ i ~ "] mismatch at:\n"
                        ~ "\nexpect[" ~ m ~ "]:\n\t" ~ x.indent
                        ~ "\nactual[" ~ m ~ "]:\n\t" ~ a.indent
                        ~ "\n");
        }
    }
}

pub fn ZERO(src: string) ZERO(sources: [ src ]);
pub fn FAIL(src: string) FAIL(sources: [ src ]);

pub fn ZERO_SAME(alts: string[])
{
    mut wrap: string[][];
    for (mut i = 0; i < alts.len; i++)
        wrap ~= [ alts[i] ];

    return ZERO_SAME(wrap);
}
