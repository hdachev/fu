#import 'helpers';
#import 'lexer';
#import 'parser';
#import 'types';
#import 'solver';

let WRITE_COMPILER = true;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Prelude.

let prelude_src = `


// Some lolcode.

fn __native_pure(): never never;
fn __native_pure(id: string): never never;
fn __native_pure(id: string, opt: string): never never;

fn STEAL (a: &mut $T): $T __native_pure;
fn CLONE (a: &    $T): $T __native_pure;

fn print(a: $A): void __native_pure;
fn print(a: $A, b: $B): void __native_pure;
fn print(a: $A, b: $B, c: $C): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E): void __native_pure;
fn print(a: $A, b: $B, c: $C, d: $D, e: $E, f: $F): void __native_pure;


// Arithmetics.

fn +(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn +(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;

fn -(a: $T)                 case ($T -> @arithmetic):   $T __native_pure;
fn -(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;
fn *(a: $T, b: $T)          case ($T -> @arithmetic):   $T __native_pure;

fn /(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native_pure;
    // case ($T -> @integral && $b -> @non_zero):          $T __native_pure;
    case ($T -> @arithmetic): $T __native_pure;

fn %(a: $T, b: $T)
    // case ($T -> @floating_point):                       $T __native_pure;
    // case ($T -> @integral && $b -> @non_zero):          $T __native_pure;
    case ($T -> @arithmetic): $T __native_pure;

fn ++(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn --(a: &mut $T)           case ($T -> @arithmetic):   $T __native_pure;
fn +=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;
fn -=(a: &mut $T, b: $T)    case ($T -> @arithmetic):   &mut $T __native_pure;

fn ==(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn !=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn > (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn < (a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn >=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;
fn <=(a: $T, b: $T)         case ($T -> @arithmetic):   bool __native_pure;


// Bitwise.

fn ~(a: $T)                 case ($T -> @integral):     $T __native_pure;
fn &(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn |(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn ^(a: $T, b: $T)          case ($T -> @integral):     $T __native_pure;
fn <<(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;
fn >>(a: $T, b: $T)         case ($T -> @integral):     $T __native_pure;

fn &=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn |=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;
fn ^=(a: &mut $T, b: $T)    case ($T -> @integral):     &mut $T __native_pure;


// Logic.

fn true (): bool __native_pure;
fn false(): bool __native_pure;


// Assignment.

fn   =(a: &mut $T, b: $T): &mut $T __native_pure;
fn ||=(a: &mut $T, b: $T): &mut $T __native_pure;

fn SWAP(a: &mut $T, b: &mut $T): void __native_pure;


// Arrays.

fn len (a: $T[]): i32 __native_pure;
fn find(a: $T[], b: $T): i32 __native_pure;
fn has (a: $T[], b: $T): bool __native_pure;

fn [](a: $T[], i: i32)
    case ($a -> &mut $T[]): &mut $T __native_pure;
    case ($a -> &    $T[]): &    $T __native_pure;

fn    push(a: &mut $T[], b: $T): void __native_pure;
fn unshift(a: &mut $T[], b: $T): void __native_pure;
fn  insert(a: &mut $T[], i: i32, b: $T): void __native_pure;

fn  slice(a: $T[], i0: i32, i1: i32): $T[] __native_pure;
fn  slice(a: $T[], i0: i32): $T[] __native_pure;

fn splice(a: &mut $T[], i: i32, N: i32): void __native_pure;
fn    pop(a: &mut $T[]): void __native_pure;

fn  clear(a: &mut $T[]): void __native_pure;
fn resize(a: &mut $T[], len: i32): void __native_pure;
fn shrink(a: &mut $T[], len: i32): void __native_pure;

fn move(a: &mut $T[], from: i32, to: i32): void __native_pure;
fn sort(a: &mut $T[]): void __native_pure;


// Concats.
//
//  flatten: str/arr a+b+c chains into a n-ary binop -
//  adjoin : str/arr chain adjacent += for the same left-arg.
//
//      Currently just testing notations,
//        but can we make this more generic?
//          Will it be useful? Array ops are really
//            the only thing we care about optimizing.

fn +(a: $T[], b: $T[]): $T[] __native_pure( 'arr+', 'flatjoin' );
fn +(a: $T[], b: $T  ): $T[] __native_pure( 'arr+', 'flatjoin' );
fn +(a: $T  , b: $T[]): $T[] __native_pure( 'arr+', 'flatjoin' );

fn +=(a: &mut string, b: string): &mut string __native_pure( 'arr+', 'flatjoin' );
fn + (a:      string, b: string):      string __native_pure( 'arr+', 'flatjoin' );


// Strings.

fn len(a: string): i32 __native_pure;
fn  [](a: string, i: i32): string __native_pure;

fn ==(a: string, b: string): bool __native_pure;
fn !=(a: string, b: string): bool __native_pure;
fn  >(a: string, b: string): bool __native_pure;
fn  <(a: string, b: string): bool __native_pure;
fn >=(a: string, b: string): bool __native_pure;
fn <=(a: string, b: string): bool __native_pure;

fn   find(a: string, b: string): i32 __native_pure;
fn    has(a: string, b: string): bool __native_pure;
fn starts(a: string, with: string): bool __native_pure;

fn slice (a: string, i0: i32, i1: i32): string __native_pure;
fn slice (a: string, i0: i32): string __native_pure;

fn substr(a: string, i0: i32, i1: i32): string __native_pure;
fn char  (a: string, i0: i32): i32 __native_pure;


// TODO: .replace() is a faster impl of .split().join().
//  How do we express this so that .split.joins are automatically promoted?
//   This would be generally useful, e.g.
//    .map.maps and .map.filters could use this to skip allocs.

fn   split(str: string, sep: string): string[] __native_pure;
fn    join(a: string[], sep: string): string __native_pure;
fn replace(in: string, all: string, with: string): string __native_pure;


// Maps.

fn [](a: Map($K, $V), b: &$K)
    case ($a -> &mut Map($K, $V)): &mut $V __native_pure;
    case ($a -> &    Map($K, $V)): &    $V __native_pure;

fn keys  (a: Map($K, $V)): $K[] __native_pure;
fn values(a: Map($K, $V)): $V[] __native_pure;
fn has   (a: Map($K, $V), b: $K): bool __native_pure;
fn count (a: Map($K, $V)): i32 __native_pure;


// Assertions, bugs & fails.

fn throw(reason: string): never __native_pure;
fn assert(): never __native_pure;


// Butt plugs.

// TODO we should go for an any $B -> call stringify(b) macro.
fn +(a: string, b: i32): string __native_pure;
fn +(a: string, b: f64): string __native_pure;
fn +(a: i32, b: string): string __native_pure;
fn +(a: f64, b: string): string __native_pure;

// TODO fix impure io.
fn now_hr(): f64 __native_pure;
fn now_utc(): f64 __native_pure;

fn env_get(key: string): string __native_pure;

fn file_size(path: string): i32 __native_pure;
fn file_read(path: string): string __native_pure;
fn file_write(path: string, body: string): bool __native_pure;

fn shell_exec(cmd: string): i32 __native_pure;
fn shell_exec(cmd: string, stdout: &mut string): i32 __native_pure;

fn hash_tea(str: string): string __native_pure;

fn i32(v: f64): i32 __native_pure;

fn exit(code: i32): never __native_pure;

`;

fn solvePrelude(): TEMP_Context
{
    // In order to keep the prelude around,
    //  I'm thinking we'll just prep a ready-to-copy template,
    //   with prelude solved at modid 0.
    let implicit mut ctx: TEMP_Context;
    let implicit mut module = getModule('');

    let lexed   = lex(prelude_src, '__prelude');
    let root    = parse(0, '__prelude', :lexed.tokens).root;
    let solved  = solve(root);

    module.out.solve = solved;
    setModule(module);

    return ctx;
}

let CTX_PROTO: TEMP_Context = solvePrelude();




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Codegen.

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;


//

pub fn cpp_codegen(
    implicit module: &Module,
    implicit ctx: &TEMP_Context,
    root: SolvedNode, scope: Scope): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);
    mut _ffwd: Map(string, string);
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string     = '\n';
    mut _fnN:   i32;
    mut _clsrN: i32;
    mut _faasN: i32;

    fn GET(
        implicit module: Module,
        implicit ctx: TEMP_Context,
        target: Target): Overload
    {
        target.index > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn fail(reason = '') throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = '#include ' + lib + '\n';
    }


    //

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        let fwd = typeAnnotBase(type);

        if ((mode & M_RETVAL) && type.canon == 'never')
            return '[[noreturn]] ' + fwd;

        if (type.quals & q_mutref)
            return fwd + '&';
        if (type.quals & q_ref)
            return 'const ' + fwd + '&';

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return 'const ' + fwd;

        if ((mode & M_ARGUMENT) && !(type.quals & q_trivial))
            return fwd + '&&';

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (c ==  'i8')    return 'i8';
        if (c == 'i16')    return 'i16';
        if (c == 'i32')    return 'int'; // TODO fix, pandemic includes
        if (c == 'i64')    return 'i64';

        if (c ==  'u8')    return 'u8';
        if (c == 'u16')    return 'u16';
        if (c == 'u32')    return 'u32';
        if (c == 'u64')    return 'u64';

        if (c == 'f32')    return 'f32';
        if (c == 'f64')    return 'f64';

        if (c == 'bool')   return 'bool';
        if (c == 'void')   return 'void';
        if (c == 'string') return annotateString();
        if (c == 'never')  return annotateNever();

        let tdef = lookupType(type) || fail('TODO: ' + type.canon);
        let k = tdef.kind;

        if (k == 'struct')
        {
            if (!_tfwd.has(type.canon))
            {
                _tfwd[type.canon] = '\nstruct ' + type.canon + ';';

                _tdef += declareStruct(type, tdef);
            }

            return type.canon;
        }

        if (k == 'array')
        {
            annotateVector();

            let item = typeAnnot(tdef.fields[0].type);
            return 'fu_VEC<' + item + '>';
        }

        if (k == 'map')
        {
            let k = typeAnnot(tdef.fields[0].type);
            let v = typeAnnot(tdef.fields[1].type);

            annotateMap();
            return 'fu_COW_MAP<' + k + ', ' + v + '>';
        }

        return fail('TODO: ' + tdef.kind);
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        mut def = '\n                                #ifndef DEF_' + t.canon
                + '\n                                #define DEF_' + t.canon
                + '\nstruct ' + t.canon + '\n{';

        mut indent = '\n    ';

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    struct Data\n    {';
            indent += '    ';
        }

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def += indent + typeAnnot(field.type) + ' ' + ID(field.id) + ';';
        }

        if (s.flags & F_DESTRUCTOR)
        {
            def += '\n    };';
            def += '\n';
            def += '\n    Data data;';
            def += '\n    bool dtor = false;';
            def += '\n';
            def += '\n    ~' + t.canon + '() noexcept;';
            def += '\n    inline ' + t.canon + '(Data data) noexcept : data(data) {};';
            def += '\n    ' + t.canon + '(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '& operator=(const ' + t.canon + '&) = delete;';
            def += '\n    ' + t.canon + '(' + t.canon + '&&) noexcept;';
            def += '\n    ' + t.canon + '& operator=(' + t.canon + '&&) noexcept;';
        }

        def += '\n    explicit operator bool() const noexcept';
        def += '\n    {';
        def += '\n        return false';

        for (mut i = 0; i < fields.len; i++)
            def += '\n            || '
                + boolWrap(fields[i].type,
                    (s.flags & F_DESTRUCTOR ? 'data.' : '')
                        + ID(fields[i].id));

        def += '\n        ;';
        def += '\n    }';

        return def + '\n};\n                                #endif\n';
    }


    //

    fn collectDedupes(
        dedupes: &Map(string, string)): string
    {
        mut out = '';

        mut keys = dedupes.keys();
        keys.sort();

        for (mut i = 0; i < keys.len; i++)
            out += dedupes[keys[i]];

        return out;
    }

    fn cgSpecs(): string
    {
        mut src = '';

        let specs = module.out.specs;
        let keys = specs.keys();
        for (mut i = 0; i < keys.len; i++)
        {
            // Prelude?
            let k = keys[i];
            if (k[0] == '0')
                continue;

            // Emit.
            let s = specs[k];
            if (s.target)
                src += cgNode(s);
        }

        return src;
    }

    fn cgRoot(root: SolvedNode): string
    {
        let specs  = cgSpecs();
        let src    = cgStatements(root.items);

        mut header = collectDedupes(_libs)
                   + collectDedupes(_tfwd)
                   + collectDedupes(_ffwd)
                   +               (specs)
                   +               (_tdef)
                   +               (_fdef)
                   ;

        return header + src;
    }


    //

    fn ID(id: string): string
    {
        if (id == 'this')       return '_';
        if (id == 'template')   return 'tempatle';
        if (id == 'catch')      return 'cahtch';
        if (id == 'not')        return 'nott';
        if (id == 'and')        return 'andd';
        if (id == 'or')         return 'orr';

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = '';

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src += _indent + line + (line.last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[], skipCurlies: bool = false): string
    {
        let indent0 = _indent;
        _indent += '    ';

        mut src = cgStatements(nodes);
        if (!skipCurlies || nodes.len != 1 || nodes[0].kind != 'return' && nodes[0].kind != 'call')
            src = indent0 + '{' + src + indent0 + '}';

        _indent = indent0;
        return src;
    }

    fn blockWrapSubstatement(node: SolvedNode): string
    {
        return node.kind != 'block' ? blockWrap([ node ], true)
             : node.items.len == 1  ? blockWrapSubstatement(node.items[0])
                                    : cgBlock(node);
    }

    fn cgBlock(block: SolvedNode): string
    {
        return blockWrap(block.items);
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return '(false /*empty parens*/)';

        if (items.len == 1)
            return items[0];

        mut src = '(';
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src += ', ';
            if (i < items.len - 1)
                src += '(void)';

            src += items[i];
        }

        return src + ')';
    }


    // This barely works unless it doesn't.

    fn try_cgFnAsStruct(fn: SolvedNode): string
    {
        let body = fn.items[fn.items.len + FN_BODY_BACK];
        if (!body || body.kind != 'block')
            return '';

        let items = body.items;

        // We need at least one closure
        //  in the function "header"
        //   for all of this to make sense.
        mut hasClosuresInHeader = false;
        mut end = 0;
        for (mut i = 0; i < items.len; i++)
        {
            end = i;

            let item = items[i];
            if (item.kind == 'fn')
            {
                if (item.flags & F_CLOSURE)
                    hasClosuresInHeader = true;
            }
            else if (item.kind != 'let' && item.kind != 'struct')
            {
                break;
            }
        }

        if (!hasClosuresInHeader)
            return '';

        // Ok - refactor time.
        let evalName = fn.value + '_EVAL';

        let restFn = SolvedNode(

            kind: 'fn', type: t_void,
            flags: fn.flags | F_CLOSURE,
            token: fn.token,
            value: evalName,

            items:
            [
                fn.items[fn.items.len - 2], // retval
                SolvedNode(
                    kind: 'block', type: t_void,
                    token: fn.token,
                    items: items.slice(
                        end, items.len)),
            ]);

        let head: SolvedNode[] =
            fn.items.slice(0, fn.items.len + FN_ARGS_BACK)
                + items.slice(0, end)
                + [ restFn ];

        //////////////////////
        _clsrN == 0 || fail();
        _clsrN--; // -1, so root closures come up at 0.
        //////////////////////

        let structName = 'sf_' + fn.value;
        mut src = '\nstruct ' + structName
                + blockWrap(head) + ';';

        //////////////////////
        {
            mut args: string[];

            for (mut i = 0; i < fn.items.len + FN_ARGS_BACK; i++)
            {
                let argNode = fn.items[i];
                let argType = argNode.type;
                let arg     = argNode.value;

                args.push(
                    argType.quals & q_ref
                        ? arg
                        : cgSteal(arg));
            }

            src += '\n';
            src += cgFnSignature(fn);
            src += '\n{\n    return (' + structName + ' { ' + args.join(', ') + ' }).' + evalName + '();\n}\n\n';
        }

        //////////////////////
        _clsrN++;
        //////////////////////

        return src;
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let items   = fn.items;
        let ret     = items[items.len + FN_RET_BACK] || fail();
        let annot   = typeAnnot(ret.type || fail(), M_RETVAL);
        let closure = !!_clsrN && (fn.flags & F_CLOSURE);

        mut src = closure
                ? 'const auto& ' + fn.value + ' = [&]('
                : annot + ' ' + fn.value + '(';

        if (!fn.value.hasIdentifierChars)
            src = annot + ' operator' + fn.value + '(';

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src += ', ';

            src += binding(items[i] || fail());
        }

        src += closure
             ? ') -> ' + annot
             : ')';

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != 'fn')
            return;

        let ffwdKey = target.modid + '#' + target.index;
        if (_ffwd.has(ffwdKey))
            return;

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let isOp    = !id.hasIdentifierChars;

        // TODO FIX
        //  Running into issues with attempting to forward declare
        //   builtin operators specialized in other modules
        //    when importing their inline const stuff - a perfect storm.
        if (isOp && id != '==')
            return;

        mut src = isOp
                ? '\n' + annot + ' operator' + id + '('
                : '\n' + annot + ' ' + id + '(';

        let arg_t = overload.args;
        for (mut i = 0; i < arg_t.len; i++)
        {
            if (i)
                src += ', ';

            src += typeAnnot(arg_t[i], M_ARGUMENT);
        }

        src += ');';
        _ffwd[ffwdKey] = src;

        return;
    }


    //

    fn cgFn(fn: SolvedNode): string
    {
        // Template? TODO FIX dunno why this is how we tell, looks terrible.
        if (!fn.items.len)
            return '';

        // Use like-struct output for top-level functions with closures -
        //  We'll try to "close over" a root-level struct.
        if (_faasN == 0 && (fn.flags & F_HAS_CLOSURE))
        {
            /////////
            _faasN++;
            /////////

            let src = try_cgFnAsStruct(fn);

            /////////
            _faasN--;
            /////////

            if (src)
            {
                _fdef += src;
                return '';
            }
        }

        ///////////////////////////
        let f0 = _fnN;
        let c0 = _clsrN;
        let indent0 = _indent;

        _fnN++;
        if (fn.flags & F_CLOSURE) _clsrN++;
        ///////////////////////////

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK] || fail();

        // Both closures and try_cgFnAsStruct
        if (!(fn.flags & F_CLOSURE))
            _indent = '\n';

        mut src = cgFnSignature(fn);
        if (src != 'int main()' && !(fn.flags & F_CLOSURE) && _fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        if (body.kind == 'block')
            src += cgBlock(body);
        else
            src += blockWrap([ body ]);

        //////////////
        _fnN    = f0;
        _clsrN  = c0;
        _indent = indent0;
        //////////////

        if (fn.flags & F_DESTRUCTOR)
        {
            let head = items[0] || fail();
            let name = head.type.canon;

            src += '\n\n' + name + '::~' + name + '() noexcept';
            src += '\n{';
            src += '\n    if (!dtor)';
            src += '\n    {';
            src += '\n        dtor = true;';
            src += '\n        free(*this);';
            src += '\n    }';
            src += '\n}';

            include('<cassert>');
            include('<utility>');

            src += '\n\n' + name + '::' + name + '(' + name + '&& src) noexcept';
            src += '\n    : data(std::move(src.data))';
            src += '\n{';
            src += '\n    assert(!src.dtor);';
            src += '\n    dtor = src.dtor;';
            src += '\n    src.dtor = true;';
            src += '\n}';

            include('<cstring>');

            src += '\n\n' + name + '& ' + name + '::operator=(' + name + '&& src) noexcept';
            src += '\n{';
            src += '\n    if (&src != this)';
            src += '\n    {';
            src += '\n        char temp[sizeof(' + name + ')];';
            src += '\n        std::memcpy(temp, this, sizeof(' + name + '));';
            src += '\n        std::memcpy(this, &src, sizeof(' + name + '));';
            src += '\n        std::memcpy(&src, temp, sizeof(' + name + '));';
            src += '\n    }';
            src += '\n';
            src += '\n    return *this;';
            src += '\n}';
        }

        // This covers both closures & try_cgTryFnAsStruct:
        if (fn.flags & F_CLOSURE)
            return src;

        _fdef += '\n' + src + '\n';
        return '';
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        let id    = node.value || fail();
        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        let head  = (annot || fail()) + ' ' + ID(id);
        let init  = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == 'copy' && !(node.type.quals & q_ref))
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_trivial)
                    return head + ' = ' + expr;

                return head + ' { ' + expr + ' }';
            }

            return head + ' = ' + cgNode(init);
        }

        return head + ' {}';
    }

    fn cgLet(node: SolvedNode): string
    {
        return binding(node, doInit: true);
    }

    fn cgGlobal(node: SolvedNode): string
    {
        mut src = cgLet(node);

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.replace(
            all: '([&](', with: '([](');

        // cpp17 inline const syntax sugars.
        if (src.starts(with: 'const '))
            src = src.slice(6);

        //
        _fdef  += '\n                                #ifndef DEF_' + node.value
                + '\n                                #define DEF_' + node.value
                + '\ninline const ' + src + ';'
                + '\n                                #endif\n';

        return '';
    }

    fn cgForeignGlobal(target: Target): void
    {
        let key = target.modid + '#' + target.index;
        if (_ffwd.has(key))
            return;

        _ffwd[key] = '';
        let o = GET(target);
        cgGlobal(o.constant);
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type == t_never)
                return src;

            return 'return ' + src;
        }

        return 'return';
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return 'goto L_' + node.value + '_' + node.kind[0];

        return node.kind;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = '';
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc += '\\n';
            else if (c == '\r') esc += '\\r';
            else if (c == '\t') esc += '\\t';
            else if (c == '\v') esc += '\\v';
            else if (c == '\\') esc += '\\\\';
            else if (c ==  '"') esc += '\\"';

            else                esc += c;
        }

        return '"' + esc + '"_fu';
    }

    fn cgArrayLiteral(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot + ' { ' + arrayAnnot
            + '::INIT<' + items.len + '> { '
                + items.join(', ') + ' } }';
    }

    fn cgDefaultInit(node: SolvedNode): string
    {
        return cgArrayLiteral(node);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();
        mut items  = cgNodes(node.items);

        if (target.kind == 'defctor')
        {
            let head = (target.type || fail());
            let type = lookupType(head) || fail();

            //
            mut open = ' { ';
            mut close = ' }';
            if (type.flags & F_DESTRUCTOR)
            {
                open = ' { ' + head.canon + '::Data { ';
                close = ' }}';
            }

            return head.canon + open + items.join(', ') + close;
        }

        let id = target.name || fail();

        if (target.kind == 'global')
        {
            if (node.target.modid != module.modid)
                cgForeignGlobal(node.target);

            return ID(id); // TODO ensure const emit.
        }

        if (target.kind == 'var')
            return ID(id);

        if (target.kind == 'field')
        {
            mut sep = '.';
            let parent = lookupType(node.items[0].type);
            if (parent.flags & F_DESTRUCTOR)
                sep = '.data.';

            return items[0] + sep + ID(id);
        }

        if (node.target.modid && node.target.modid != module.modid)
            ensureFwdDecl(node.target);

        if (hasNonIdentifierChars(id))
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? items[0] + id
                     : id + items[0];
            }

            if (items.len == 2)
            {
                if (id == '[]')
                {
                    if (head.type.canon == 'string')
                        return 'fu_TO_STR(' + items[0] + '[' + items[1] + '])';

                    // The new cow_vec is here.
                    if (head.type.quals & q_mutref)
                        return items[0] + '.mutref(' + items[1] + ')';

                    return items[0] + '[' + items[1] + ']';
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == '=')
                {
                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return '(' + cgNode(head.items[0] || fail()) +
                                '.upsert(' + cgNode(head.items[1] || fail()) + ') = ' +
                                    items[1] + ')';
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == '||=')
                {
                    if (head.kind == 'call' && head.value == '[]' && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            items[0] = cgNode(head.items[0] || fail()) +
                                '.upsert(' + cgNode(head.items[1] || fail()) + ')';
                    }

                    let annot = typeAnnot(head.type);

                    return '([&](' + annot + ' _) -> ' + annot + ' { if (!' +
                        boolWrap(head.type, '_') + ') _ = ' +
                            items[1] + '; return _; } (' + items[0] + '))';
                }

                // Skip some of the ridiculous parens.
                if (mode & M_STMT)
                    return items[0] + ' ' + id + ' ' + items[1];
                else
                    return '(' + items[0] + ' ' + id + ' ' + items[1] + ')';
            }
        }

        if (id == 'len' && items.len == 1)
            return items[0] + '.size()';

        if (id == 'push' && items.len == 2)
            return items[0] + '.push(' + items[1] + ')';

        if (id == 'pop' && items.len == 1)
            return items[0] + '.pop()';

        if (id == 'unshift' && items.len == 2)
            return items[0] + '.unshift(' + items[1] + ')';

        if (id == 'insert' && items.len == 3)
            return items[0] + '.insert(' + items[1] + ', ' + items[2] + ')';

        if (id == 'splice' && items.len == 3)
            return items[0] + '.splice(' + items[1] + ', ' + items[2] + ')';

        if (id == 'grow' && items.len == 2)
            return items[0] + '.grow(' + items[1] + ')';

        if (id == 'shrink' && items.len == 2)
            return items[0] + '.shrink(' + items[1] + ')';

        if (id == 'resize' && items.len == 2)
            return items[0] + '.resize(' + items[1] + ')';

        if (id == 'clear' && items.len == 1)
            return items[0] + '.clear()';

        if (id == 'find' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::lfind(' + items.join(', ') + ')';
        }

        if (id == 'starts' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::lmatch(' + items.join(', ') + ')';
        }

        if (id == 'has' && items.len == 2)
        {
            include('"../lib/vec/find.h"');
            return 'fu::has(' + items.join(', ') + ')';
        }

        if (id == 'replace' && items.len == 3)
        {
            include('"../lib/vec/replace.h"');
            return 'fu::replace(' + items.join(', ') + ')';
        }

        if (id == 'slice' && items.len == 2)
            return 'slice(' + items[0] + ', ' + items[1] + ')';

        if (id == 'slice' && items.len == 3)
            return 'slice(' + items[0] + ', ' + items[1] + ', ' + items[2] + ')';

        if (id == 'substr' && items.len == 3)
            return 'substr(' + items[0] + ', ' + items[1] + ', ' + items[2] + ')';

        if (id == 'sort' && items.len == 1)
        {
            include('<algorithm>');
            return '([&](auto& _) { std::sort(_.mut_begin(), _.mut_end()); } (' + items[0] + '))';
        }

        if (id == 'char' && items.len == 2)
        {
            let head = node.items[0] || fail();
            if (head.type.canon == 'string')
                return 'int(' + items[0] + '[' + items[1] + '])';
        }

        if ((id == 'true' || id == 'false') && !items.len)
            return id;

        if (id == 'throw' && items.len == 1)
            return cgThrow(id, items[0]);

        if (id == 'assert' && items.len == 0)
            return cgThrow(id, '"Assertion failed."');

        if (id == 'move' && items.len == 3)
            return '([&]() { auto* _ = ' + items[0] + '.mut_data(); ' + cgSlide('_ + ' + items[2], '_ + ' + items[1], 'sizeof(*_)') + '; } ())';

        if (id == 'split' && items.len == 2)
            return cgSplit(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'join' && items.len == 2)
            return cgJoin(items);

        if (id == 'keys' && items.len == 1)
            return cgKeys(items);

        if (id == 'CLONE' && items.len == 1)
            return cgClone(node.type, items[0]);

        if (id == 'STEAL' && items.len == 1)
            return cgSteal(items[0]);

        if (id == 'SWAP' && items.len == 2)
            return cgSwap(items);

        if (id == 'print')
            return cgPrint(items);

        if (id == 'now_hr' || id == 'now_utc')
        {
            include('"../lib/now.h"');
            return 'fu::' + id + '()';
        }

        if (id == 'file_write' || id == 'file_read' || id == 'file_size')
        {
            include('"../lib/io.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'env_get')
        {
            include('"../lib/env.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'hash_tea')
        {
            include('"../lib/tea.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        if (id == 'shell_exec')
        {
            include('"../lib/shell.h"');
            return 'fu::' + id + '(' + items.join(', ') + ')';
        }

        id != '__native_pure' || assert();

        return ID(id) + '(' + items.join(', ') + ')';
    }

    fn cgPrint(items: string[]): string
    {
        include('<iostream>');

        mut src = '(std::cout';
        for (mut i = 0; i < items.len; i++)
            src += ' << ' + items[i];

        src += ' << "\\n")';
        return src;
    }

    fn cgSlide(destExpr: string, srcExpr: string, numBytesExpr: string): string
    {
        let SLIDE = '::slide';
        if (!_tfwd.has(SLIDE))
        {
            include('<cstring>');

            _tfwd[SLIDE] =
////////////////////////////////////
`
template <size_t N>
inline void fu_MEMSLIDE(void* dest, void* source)
{
    char swap_buffer[N];

    std::memcpy(
        swap_buffer, source, N);

    if (source < dest)
        std::memmove(
            source, (char*)source + N,
            (char*)dest - (char*)source);
    else
        std::memmove(
            (char*)dest + N, dest,
            (char*)source - (char*)dest);

    std::memcpy(
        dest, swap_buffer, N);
}
`
////////////////////////////////////
            ;
        }

        return 'fu_MEMSLIDE<' + numBytesExpr + '>(' + destExpr + ', ' + srcExpr + ')';
    }

    fn annotateMap(): void
    {
        include('"../lib/map.h"');
    }

    fn annotateVector(): void
    {
        include('"../lib/vec.h"');
    }

    fn annotateString(): string
    {
        include('"../lib/str.h"');

        return 'fu_STR';
    }

    fn annotateNever(): string
    {
        include('"../lib/never.h"');

        return 'fu::never';
    }

    fn cgThrow(kind: string, item: string): string
    {
        annotateNever();

        if (kind == 'assert')
        {
            //////////
            // TODO //
            //////////
        }

        return 'fu::fail(' + item + ')';
    }

    fn cgJoin(items: string[]): string
    {
        include('"../lib/vec/join.h"');

        return 'fu::join(' + items.join(', ') + ')';
    }

    fn cgSplit(items: string[]): string
    {
        let SPLIT = '::SPLIT';
        if (!_ffwd.has(SPLIT))
        {
            annotateString();
            annotateVector();
            include('"../lib/vec/find.h"');

            _ffwd[SPLIT] =
////////////////////////////////////
`
inline fu_VEC<fu_STR> fu_SPLIT(
    fu_STR s,
    const fu_STR& sep)
{
    fu_VEC<fu_STR> result;

    int next;
    while ((next = fu::lfind(s, sep)) >= 0)
    {
        result.push(slice(s, 0, next));
        s = slice(s, next + sep.size());
    }

    result.push(static_cast<fu_STR&&>(s));
    return result;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_SPLIT(' + items.join(', ') + ')';
    }

    fn cgKeys(items: string[]): string
    {
        let KEYS = '::KEYS';
        if (!_ffwd.has(KEYS))
        {
            annotateMap();
            annotateVector();

            _ffwd[KEYS] =
////////////////////////////////////
`
template <typename K, typename V>
fu_VEC<K> fu_KEYS(
    const fu_COW_MAP<K, V>& map)
{
    return map.m_keys;
}
`
////////////////////////////////////
            ;
        }

        return 'fu_KEYS(' + items.join(', ') + ')';
    }

    fn cgLiteral(node: SolvedNode): string
    {
        return node.value || fail();
    }

    fn cgEmpty(): string
    {
        return '';
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(node: SolvedNode)
            node.kind == 'if'
                ? ' ' + cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && boolWrap(n0.type, cgNode(n0, M_RETBOOL));
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return 'if (' + cond + ')' + cons + (alt ? _indent + 'else' + alt : '');

        if (cons && alt)
            return '(' + cond + ' ? ' + cons + ' : ' + alt + ')';

        if (cons)
            return '(' + cond + ' && ' + cons + ')';

        if (alt)
            return '(' + cond + ' || ' + alt + ')';

        return fail('TODO');
    }

    fn boolWrap(type: Type, src: string): string
    {
        if (type_isString(type))
            return src + '.size()';

        return src;
    }


    //

    fn cgDefault(type: Type): string
    {
        if (type.quals & q_ref && !(type.quals & q_mutref))
        {
            let DEFAULT = '::DEFAULT';
            if (!_ffwd.has(DEFAULT))
            {
                _ffwd[DEFAULT] =
////////////////////////////////////
`
template <typename T>
struct fu_DEFAULT { static inline const T value {}; };
`
////////////////////////////////////
                ;
            }

            return 'fu_DEFAULT<' + typeAnnot(clear_refs(type)) + '>::value';
        }

        return typeAnnot(type) + '{}';
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            let items = node.items;

            let retSecondLast = items[items.len - 1].type == t_never;

            let condEnd = retSecondLast
                        ? items.len - 2
                        : items.len - 1;

            mut src = '';

            if (condEnd)
            {
                src += 'if (';

                for (mut i = 0; i < condEnd; i++)
                {
                    let item = items[i];
                    if (i) src += ' && ';
                    src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                }

                src += ') ';
            }

            let tail = cgNode(items[condEnd]);

            if (retSecondLast)
            {
                src += '{ ' + typeAnnot(type) + ' _ = ' + tail + '; ';
                src += 'if (!' + boolWrap(type, '_') + ') return _; } ';
                src += cgNode(items[items.len - 1]) + ';'; //FAIL
            }
            else
            {
                src += 'return ' + tail + ';'; //TRUTHY
                src += ' else return ' + cgDefault(type) + ';';
            }

            src = '([&]() -> ' + typeAnnot(type) + ' { ' + src + ' }())';

            return src;
        }

        mut src = '(';
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];

            if (i) src += ' && ';
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ')';
    }

    fn cgNot(node: SolvedNode): string
    {
        let item = node.items[0];
        return '!' + boolWrap(
            item.type, cgNode(item, M_RETBOOL));
    }

    fn cgOr(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            let annot = typeAnnot(type);

            mut src = '([&]() -> ' + annot + ' {';

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == 'and')
                {
                    let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src += ' if (';
                    for (mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src += ' && ';

                        let item = items[i] || fail();
                        src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                    }

                    src += ')';
                }

                src += ' { ' + annot + ' _ = ' + cgNode(tail) + '; if (' + boolWrap(tail.type, '_') + ') return _; }';
            }

            let tail = items[items.len - 1] || fail();
            if (!(tail.type == t_never))
                src += ' return';

            src += ' ' + cgNode(tail) + '; }())';
            return src;
        }

        mut src = '(';
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (i) src += ' || ';
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ')';
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == '}' || fail();
        return src.slice(0, src.len - 1) + postfix + '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = n_init && cgNode(n_init);
        let cond = n_cond && boolWrap(n_cond.type, cgNode(n_cond, M_RETBOOL));
        let post = n_post && cgNode(n_post);
        mut body = n_body && blockWrapSubstatement(n_body);
        let pcnd = n_pcnd && boolWrap(n_pcnd.type, cgNode(n_pcnd, M_RETBOOL));
        mut breakLabel = '';

        if (body && node.value)
        {
            let brk = 'L_' + node.value + '_b';
            let cnt = 'L_' + node.value + '_c';

            if (body.has(cnt))
                body = '{' + postfixBlock(body, _indent +     '    }' + cnt + ':;');
            if (body.has(brk))
                breakLabel = _indent + '    ' + brk + ':;';
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail('TODO extended loop.');

            return 'do' + body + _indent + 'while (' + pcnd + ')' + breakLabel;
        }

        if (init || post || !cond)
            return 'for (' + init + '; ' + cond + '; ' + post + ')' + body + breakLabel;

        return 'while (' + cond + ')' + body + breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let let_main    = items[0];
        let let_init    = cgNode(items[0].items[LET_INIT]);
        let err_id      = items[1].value;
        let catch_body  = blockWrapSubstatement(items[2]);

        mut src =        binding(let_main, forceMut: true) + ';';
        src += _indent + 'try';
        src += _indent + '{';
        src += _indent + '    ' + let_main.value + ' = ' + let_init + ';';
        src += _indent + '}';
        src += _indent + 'catch (const std::exception& o_0)';
        src += _indent + '{';
        src += _indent + '    const fu_STR& ' + err_id + ' = fu_TO_STR(o_0.what());';
        src += _indent + catch_body;
        src += _indent + '}\n';

        return src;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == 'root')        return cgRoot(node);
        if (k == 'block')       return cgBlock(node);
        if (k == 'fn')          return cgFn(node);
        if (k == 'return')      return cgReturn(node);
        if (k == 'break')       return cgJump(node);
        if (k == 'continue')    return cgJump(node);
        if (k == 'call')        return cgCall(node, mode);
        if (k == 'let')         return cgLet(node);
        if (k == 'global')      return cgGlobal(node);
        if (k == 'if')          return cgIf(node, mode);
        if (k == '!')           return cgNot(node);
        if (k == 'or')          return cgOr(node);
        if (k == 'and')         return cgAnd(node);
        if (k == 'loop')        return cgLoop(node);
        if (k == 'int')         return cgLiteral(node);
        if (k == 'str')         return cgStringLiteral(node);
        if (k == 'arrlit')      return cgArrayLiteral(node);
        if (k == 'definit')     return cgDefaultInit(node);
        if (k == 'empty')       return cgEmpty();

        if (k == 'comma')       return cgParens(node);
        if (k == 'parens')      return cgParens(node);
        if (k == 'label')       return cgParens(node);
        if (k == 'struct')      return cgEmpty();

        if (k == 'copy')        return cgCopyMove(node);
        if (k == 'move')        return cgCopyMove(node);
        if (k == 'catch')       return cgCatch(node);

        return fail('TODO: ' + k);
    }


    //

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == 'move')
            return cgSteal(a);

        return cgClone(node.type, a);
    }

    fn cgSteal(src: string): string
    {
        include('<utility>');
        return 'std::move(' + src + ')';
    }

    fn cgSwap(items: string[]): string
    {
        include('<utility>');
        return 'std::swap(' + items.join(', ') + ')';
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) + '(' + src + ')';
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        for (mut i = 0; i < nodes.len; i++)
        {
            let node  = nodes[i];
            let src   = node ? cgNode(node, mode) : '';

            result.push(src);
        }

        return result;
    }


    //

    root.kind == 'root' || fail();

    let src = cgNode(root);
    return src;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     The whole thing in one go.

fn compile(fname: string, via: string = ''): string
{
    let implicit mut module = getModule(fname);

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = ModuleOutputs;

        let src = getFile(fname) || throw (
            '#import badfile: `' + via + fname + '`.');

        let t0 = now_hr();
        let lexer_result =
            lex(:fname, :src);

        let t1 = now_hr();
        module.in = ModuleInputs(
            :src, lex: lexer_result,
            :parse( :module.modid, :fname, :lexer_result.tokens ));

        let t2 = now_hr();

        // Stat.
        module.stats.s_lex   = t1 - t0;
        module.stats.s_parse = t2 - t1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular #import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            '#import circle: `' + via + fname + '`.');
    }

    // Compile dependencies.
    let imports = module.in.parse.imports;
    for (mut i = 0; i < imports.len; i++)
        compile(
            fname: imports[i],
              via: fname + ' <- ' + via);

    // We're good to go here.
    if (!module.out)
    {
        let t0 = now_hr();
        module.out.solve = solve(
            module.in.parse.root);

        let t1 = now_hr();
        module.out.cpp = cpp_codegen(
            module.out.solve.root,
            module.out.solve.scope);

        let t2 = now_hr();

        module.stats.s_solve = t1 - t0;
        module.stats.s_cpp   = t2 - t1;

        // Final repersist.
        setModule(module);
    }

    // --------------------------------------------- //
    // print('lex     ', module.stats.s_lex,   's'); //
    // print('parse   ', module.stats.s_parse, 's'); //
    // print('solve   ', module.stats.s_solve, 's'); //
    // print('codegen ', module.stats.s_cpp,   's'); //
    // --------------------------------------------- //

    return module.out.cpp;
}

fn compile_testcase(mut src: string, fname: string): TEMP_Context
{
    // Some nonsense.
    if (!src.has('fn ZERO()'))
        src = '\n\nfn ZERO(): i32 {\n' + src + '\n}\n';

    src += '\nfn main(): i32 ZERO();\n\n';

    //
    let implicit mut ctx = CTX_PROTO;
        ctx.files[fname] = src;

    compile(:fname);

    return ctx;
}

fn compile_testcase(src: string): string
{
    let fname = 'testcase';
    let ctx = compile_testcase(src, fname);
    for (mut i = 1; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i].out.cpp;

    assert();
}





// A very quick test.

let TEST_SRC = `

    fn test(one: i32)
    {
        let zero = one - 1;
        let two  = one * 2;

        fn inner(i: i32): i32
            i > zero ? outer(i - one) : zero;

        fn outer(i: i32): i32
            two * inner(i);

        return outer(one) + (two - one) * 17;
    }

    fn ZERO(): i32
    {
        return test(1) - 17;
    }

`;

fn ZERO(): i32
{
    let cpp = compile_testcase(TEST_SRC);

    return cpp.find('main()') ? 0 : 101;
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Orchestration.

fn absdir(a: string)
    a.last == '/' ? a : a + '/';

let HOME = absdir(env_get('HOME') || '/Users/hdachev');

fn locate_PRJDIR(): string {
    let dir = HOME + 'fu/';
    let fn  = dir  + 'src/compiler.fu';
    let fs  = file_size(fn);
        fs  > 10000 || throw('Bad compiler.fu: ' + fn + ': ' + fs);

    print('PRJDIR: ' + dir);
    return dir;
}

let PRJDIR = locate_PRJDIR();

let GCC_CMD = 'g++ -std=c++1z -O3 '
            + '-pedantic-errors -Wall -Wextra -Werror ' // opt-in
            + '-Wno-parentheses-equality ' // opt-out
            ;

fn buildAndRun(ctx: TEMP_Context): string
{
    mut code: i32;
    mut stdout: string;

    //
    mut Fs: string[];
    mut len_all: i32;

    // Starting after prelude.
    for (mut i = 1; i < ctx.modules.len; i++)
    {
        let module  = ctx.modules[i];
        let cpp     = module.out.cpp;
        let F       = PRJDIR
                    + 'build.cpp/o-'    + hash_tea(cpp)
                    + '-'               + cpp.len;

        Fs.push(F);
        len_all += cpp.len;
    }

    //
    let F_exe   = PRJDIR
                + 'build.cpp/b-'    + hash_tea(Fs.join('/'))
                + '-'               + len_all
                + '-'               + Fs.len;

    //
    fn ERR(mut cpp: string = '')
    {
        if (!cpp)
            for (mut i = Fs.len; i --> 0; )
                cpp += '#include "' + Fs[i] + '.cpp"\n';

        let fname = PRJDIR + 'build.cpp/failing-testcase.cpp';
        print('  WRITE ' + fname);
        file_write(fname, cpp);

        //
        if (!stdout)
            stdout = '[ EXIT CODE ' + code + ' ]';

        return stdout;
    }

    if (file_size(F_exe) < 1)
    {
        // Build.
        for (mut i = 0; i < Fs.len; i++)
        {
            let F     = Fs[i];
            let F_cpp = F + '.cpp';
            let F_tmp = F + '.o.tmp';
            let F_obj = F + '.o';

            if (file_size(F_obj) < 1)
            {
                // Prelude @ 0.
                let cpp = ctx.modules[i + 1].out.cpp;

                file_write(F_cpp, cpp);

                print('  BUILD ', F_cpp);
                let t0 = now_hr();

                code = shell_exec(GCC_CMD + '-c -o ' + F_tmp + ' ' + F_cpp + ' 2>&1', stdout)
                    || shell_exec('mv ' + F_tmp + ' ' + F_obj + ' 2>&1', stdout);

                if (code) return ERR(cpp);

                let t1 = now_hr();
                print('     OK ', t1 - t0, 's');
            }
        }

        // Link.
        let F_tmp = F_exe + '.tmp';

        mut cmd = GCC_CMD + '-o ' + F_tmp + ' ';
        for (mut i = Fs.len; i --> 0; )
            cmd += Fs[i] + '.o ';

        {
            print('   LINK ', F_exe);
            let t0 = now_hr();

            code = shell_exec(cmd + ' 2>&1', stdout)
                || shell_exec('chmod 755 ' + F_tmp + ' 2>&1', stdout)
                || shell_exec('mv ' + F_tmp + ' ' + F_exe + ' 2>&1', stdout);

            if (code)
            {
                print('   FAIL ' + Fs.join('\n        ' + '\n'));
                return ERR;
            }

            let t1 = now_hr();
            print('     OK ', t1 - t0, 's');
        }

        // Delete single object file.
        if (Fs.len == 1)
            code = shell_exec('rm ' + Fs[0] + '.o 2>&1', stdout);

        if (code) return ERR;
    }

    code = shell_exec(F_exe, stdout);

    if (code) return ERR;

    return '';
}

let NICE_THINGS =
[
    "LOOKING GOOD TODAY !",
    "PASSING TESTS LIKE A BOSS !",
    "THIS IS SOME TOP NOTCH SHIT !",
    "VALUE ADDED !",

    "GOING STRONG !",
    "KILLIN IT !",
    "POWER LEVEL INCREASED !",
    "NOW MAKE ME BETTER AGAIN !",

    "NOW MAKE ME EVEN MORE BETTER !",
    "ALL CLEAR !",
    "UPGRADE ACCEPTED !",
    "YOU'RE THE BEST MAN !",

    "I LOVE YOU YOU !",
    "MORE IS MORE !",
    "THIS IS AWESOME !",
    "THIS IS AWESOME !",
];

fn saySomethingNice()
{
    let sec = i32(now_utc());

/////////////////////////////
    let NEW_STUFF = false; //
/////////////////////////////

    if (sec % 5 && !NEW_STUFF)
    {
        mut str = '';
        for (mut i = 0; i < 3; i++)
            if (sec & (1 << i))
                str += '🍒';
            else
                str += '🍊';

        print(str);
    }
    else
    {
        print(NICE_THINGS[(sec >> 6) & 0xf]);
    }
}

fn ZERO(src: string, mut fname = ''): TEMP_Context
{
    if (!fname)
        fname = 'testcase.ZERO';

    let ctx     = compile_testcase(:src, :fname);
    let result  = buildAndRun(:ctx);
    if (result)
        throw(result);

    return ctx;
}

fn FAIL(src: string)
{
    let cpp = compile_testcase(src)
        catch e
            return e.len; // TODO validate

    throw("DID NOT THROW: " + cpp);
}

fn updateCPPFile(module: Module)
{
    let fname = module.fname + '.cpp';
    let cpp   = module.out.cpp;

    if (file_read(fname) != cpp)
    {
        file_write(fname, module.out.cpp);
        print('WROTE ' + fname);
    }
}

fn FU_FILE(mut fname: string)
{
    fname = PRJDIR + 'src/' + fname;

    print('COMPILE ', fname);

    let src = file_read(fname);
    if (!src)
        throw ('BAD FILE: ' + fname);

    let t0  = now_hr();
    let ctx = ZERO(:src, :fname);
    let t1  = now_hr();
    let tt  = t1 - t0;

    print('        ', tt, 's\n');

    if (WRITE_COMPILER)
        for (mut i = 1; i < ctx.modules.len; i++)
            updateCPPFile(ctx.modules[i]);

    // Test imports.
    {
        #import 'hello';
        sayHello();
    }
}


//

fn runTestSuiteAndBuildCompiler()
{
    runTestSuite();
    saySomethingNice();
    FU_FILE('compiler.fu');
}


// Test suite!

fn runTestSuite()
{
    ZERO(`
        return 1 - 1;
    `);

    ZERO(`
        fn sum(a: i32, b: i32): i32
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sum(a: i32, b: i32)
            a + b;

        return sum(1, -1);
    `);

    ZERO(`
        fn sign(a: i32)
            a > 0 ? 1 : a < 0 ? -1 : 0;

        return sign(7) + sign(-3) + sign(0);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;

            return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);

    ZERO(`
        fn sign(a: i32) {
            if (a > 0)
                return 1;
            else
                return -2;
        }

        return sign(10) * 2 + sign(-5);
    `);


    // Mutation & references.

    ZERO(`
        mut sum = 0;
        for (mut i = 0; i < 10; i++)
            sum++;

        return sum * 2 - 20;
    `);

    ZERO(`
        mut sum = 0;
        for (mut i = 10; i --> 0; )
            sum--;

        return sum * 2 + 20;
    `);

    ZERO(`
        fn decr(num: &mut i32)
            num--;

        mut res = 0;
        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr()
            res--;

        decr();
        return res + 1;
    `);

    ZERO(`
        mut res = 0;
        fn decr(num: &mut i32) { num--; } // ret void

        decr(res);
        return res + 1;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum++;

        return sum - 15;
    `);

    FAIL(`
        let sum = 0;
        while (sum < 15)
            sum++; //ERR ++ overload

        return sum - 15;
    `);

    ZERO(`
        mut sum = 0;
        while (sum < 15)
            sum += 2;

        return sum - 16;
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        return named(b: 3, 6);
    `);

    ZERO(`
        fn named(a: i32, b: i32)
            a - b * 2;

        fn other(a: i32, b: i32)
            named(:b, :a);

        return other(b: 3, 6);
    `);


    // Structs & using.

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(r: Range)
            r.max - r.min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        mut r = Range(1, 2);
        r.min++;
        return r.max - r.min;
    `);

    FAIL(`
        struct Range {
            min: i32;
            max: i32;
        }

        let r = Range(1, 2);
        r.min++; //ERR ++ overload
        return r.max - r.min;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using r: Range)
            max - min;

        return size(Range(14, 21)) - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;

            fn size()
                max - min;
        }

        let r = Range(14, 21);

        return size(r) - 7;
    `);

    ZERO(`
        struct X {
            a: i32;
            fn test(b: i32) a + b;
        }

        return X(1).test(-1);
    `);

    ZERO(`
        struct X {
            a: i32;
            fn test(b: i32) a + b;
        }

        fn hey(using x: X) test(-1);

        return X(1).hey;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;
        }

        fn dist(using p: Player, other: Player)
            x - other.x;

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);

    ZERO(`
        struct Pos {
            x: i32;
        }

        struct Player {
            using pos: Pos;

            fn dist(other: Player)
                x - other.x;
        }

        let a = Player(Pos(10));
        let b = Player(Pos( 4));

        return dist(a, b) - 6;
    `);


    // Recursion, closures & implicit args.

    ZERO(`
        fn inner(i: i32): i32
            i > 0 ? outer(i - 1) : 0;

        fn outer(i: i32): i32
            2 * inner(i);

        return outer(1);
    `);

    ZERO(`
        fn test(one: i32)
        {
            let zero = one - 1;
            let two  = one * 2;

            fn inner(i: i32): i32
                i > zero ? outer(i - one) : zero;

            fn outer(i: i32): i32
                two * inner(i);

            return outer(one) + (two - one) * 17;
        }

        fn ZERO() test(1) - 17;
    `);

    ZERO(`
        fn inner(i: i32): i32
            outer(i - 1);

        fn outer(implicit x: i32, i: i32): i32
            i > 0   ? inner(i)
                    : x + i;

        let implicit x = 7;
        return outer(1) - 7;
    `);

    ZERO(`
        fn outer(i: i32): i32
            i > 0   ? inner(i)
                    : 2 * i;

        fn inner(implicit x: i32, i: i32): i32
            outer(i - 2 * x);

        let implicit x = 3;
        return outer(6);
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn test()
            size();

        let implicit r = Range(14, 21);

        return test  - 7;
    `);

    ZERO(`
        struct Range {
            min: i32;
            max: i32;
        }

        fn size(using implicit r: Range)
            max - min;

        fn inner()
            size();

        fn outer()
            inner();

        let implicit r = Range(14, 21);

        return outer() - 7;
    `);


    //

    ZERO(`
        let x = 1;

        fn test(): &i32
            x;

        return test - 1;
    `);

    ZERO(`
        let a = 1;
        let x: &i32 = a;

        return a - x;
    `);

    ZERO(`
        struct Test {
            x: &i32;
        }

        let a = 1;
        let test = Test(a);

        return test.x - 1;
    `);

    ZERO(`
        mut a = 0;
        mut b = a;
        b++;
        let c = a = b;

        return a - c;
    `);


    // Templating checks.

    ZERO(`
        let x = 3;
        return x / 2 - 1;
    `);

    // FAIL(`
    //     fn div3by(a: i32) 3 / a; //ERR overload
    //     return div3by(2) - 1;
    // )");

    ZERO(`
        fn div3by(a: $T) 3 / a;
        return div3by(2) - 1;
    `);

    // It's too early for this test,
    //  let's get everything else working first,
    //   not smart working on supersugar so early.
    //
    // ZERO(`
    //     fn div3by(a) 3 / a;
    //     return div3by(2) - 1;
    // )");


    // Destructor basics.

    let RAII = `
        let mut i = 0;
        struct S {
            j: &mut i32;
            fn free()
                j += j + 1;
        }
    `;

    ZERO(RAII + `
        let s = S(i);
        return i;
        // <-destructor here
    `);

    ZERO(RAII + `
        { let s = S(i); } // <-destructor here
        return i - 1;
    `);

    ZERO(RAII + `
        fn test(s: &S) { return s.j; }
        test(S(i)); // <-destructor here
        return i - 1;
    `);

    ZERO(RAII + `
        fn test(s: &S) { return s.j; }
        let s = S(i);
        test(s);
        return i;
        // <-destructor here
    `);


    // Move semantics.

    ZERO(RAII + `
        fn test(s: S) { return s.j; } // <-destructor here
        test(S(i));
        return i - 1;
    `);

    FAIL(RAII + `
        fn test(mut s: S) { return s.j; } // <-destructor here

        mut s = S(i);
        test( s ); //ERR explicit

        return i - 1;
    `);

    ZERO(RAII + `
        fn test(mut s: S) {
            let x = STEAL (s);
            return x.j; // <-destructor here
        }

        mut s = S(i);
        test( STEAL(s) );

        return i - 1;
    `);

    /*

    FAIL(RAII + `
        fn test(s: S) {} // <-destructor here
        let s = S(i);
        test(s); // s is moved in
        test(s); //ERR moved
        return i - 1;
    `);


    // Borrow checker.

    const BORROW = `
        struct Borrow {
            x: &i32;
        }
    `;

    FAIL(BORROW + `
        let mut b: Borrow;
        return b.x; //ERR initialize
    `);

    ZERO(BORROW + `
        let mut b: Borrow;
        let i = 0;
        b = Borrow(i);
        return b.x;
    `);

    FAIL(BORROW + `
        let b = Borrow(0); //ERR outlive
        return b.x;
    `);

    ZERO(BORROW + `
        let i = -1;
        let b = Borrow(i);
        b.x++;
        return i;
    `);

    FAIL(BORROW + `
        let b: Borrow;
        {
            let i = -1;
            b = Borrow(i); //ERR outlive
        }
        return ++b.x;
    `);

    FAIL(BORROW + `
        let b: Borrow;

        fn test() {
            let i = -1;
            b = Borrow(i); //ERR outlive
        }

        test();
        return ++b.x;
    `);

    FAIL(BORROW + `
        fn test() {
            let i = -1;
            return Borrow(i); //ERR outlive
        }

        let b = test();
        return ++b.x;
    `);

    // */

    // Arrays.

    ZERO(`
        mut arr = [0, 1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        mut arr: i32[] = [1, 2, 3, 4];
        arr.push(5);

        fn test(view: &i32[]): i32 {
            mut sum = 0;
            for (mut i = 0; i < view.len; i++)
                sum += view[i];

            return sum - 15;
        }

        return test(arr);
    `);

    ZERO(`
        let x = 5;
        mut arr = [ -5 ];
        arr.push(x);
        return arr[0] + arr[1];
    `);


    // A basic testing setup for array ops,
    //  that can be flipped around for making sure
    //   e.g. copy-on-write behaves as expected.

    fn ARROPS(
        literal: string,
        operation: string,
        mut assertion: string)
    {
        assertion = '(' + assertion + ')';

        fn EXPR(varname: string)
            assertion.replace(
                all: '@', with: varname);

        mut src: string;

        src += "\n";
        src += "\n    {";
        src += "\n        mut arr0 = [" + literal + "];";
        src += "\n        arr0." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr0") + " != 0) return 13;";
        src += "\n    }";
        src += "\n";
        src += "\n    mut orig = [" + literal + "];";
        src += "\n";
        src += "\n    {";
        src += "\n        mut arr1 = CLONE(orig);";
        src += "\n        arr1." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr1") + " != 0) return 17;";
        src += "\n    }";
        src += "\n";
        src += "\n    {";
        src += "\n        mut arr2 = STEAL(orig);";
        src += "\n        if (orig.len) return 19;";
        src += "\n        arr2." + operation + "; // expect_lambda";
        src += "\n        if (" + EXPR("arr2") + " != 0) return 23;";
        src += "\n    }";
        src += "\n";
        src += "\n    return 0;";
        src += "\n";

        ZERO(src);
    };

    ARROPS( "0,1,2,3,4",
            "push(5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "insert(5, 5)",
            "@[1] + @[4] - @[5]");

    ARROPS( "0,1,2,3,4",
            "pop()",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "splice(4, 1)",
            "@[1] + @[3] - @.len");

    ARROPS( "0,1,2,3,4",
            "unshift(5)",
            "@[2] + @[5] - @[0]");

    ARROPS( "0,1,2,3,4",
            "insert(0, 5)",
            "@[2] + @[5] - @[0]");

    // We don't seem to have shifting yet.
    // ARROPS( "0,1,2,3,4",
    //         "shift()",
    //         "@[0] + @[2] - @[3]");

    ARROPS( "0,1,2,3,4",
            "insert(1, 5)",
            "@[2] + @[5] - @[1]");

    ARROPS( "0,1,2,3,100",
            "splice(1, 3)",
            "@.len + @[0] + @[1] - 102");


    //

    ZERO(`
        let OPERATORS = [ '+', '-', '*', '/' ];

        fn ZERO()
            OPERATORS[2] == '*' ? 0 : 1;
    `);

    ZERO(`
        struct Y { b: bool; }
        struct X { y: Y[]; }

        mut x: X[];
        x.push( X([ Y(true) ]) );

        return x.len + x[0].y.len * 2 - 3;
    `);

    ZERO(`
        mut a = [7, 1, 5, 3, 99, -13]; // [-13, 1, 3, 5, 7, 99]
        a.sort();
        return a[0] + a[1] + a[3] + a[4];
    `);

    ZERO(`
        mut a = [0, 1, 2, 3, 4]; // [2, 0, 1, 3, 4]
        a.move(2, 0);
        return a[0] + a[3] - a[2] - a[4];
    `);

    ZERO(`
        mut a = [2, 0, 1, 3, 4]; // [0, 1, 2, 3, 4]
        a.move(0, 2);
        return a[1] + a[4] - a[2] - a[3];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1, 3);
        return b.len - b[1];
    `);

    ZERO(`
        let a = [0, 1, 2, 3];
        let b = a.slice(1);
        return b.len - b[2];
    `);


    // Strings.

    ZERO(`
        mut str = 'hello ';
        str += 'world';

        return str.len - 11;
    `);

    ZERO(`
        let str = 'hello ' + 'world';

        return str.starts(with: 'hel')
             ? str.len - 11
             : 171;
    `);

    ZERO(`
        let str = 'a' + 1710010;

        return str == 'a1710010'
             ? 0 : 101;
    `);

    ZERO(`
        let str = 'hello world';
        mut cpy = '';
        for (mut i = 0; i < str.len; i++)
            cpy += str[i];

        return (cpy.len - 11) + (cpy == str ? 0 : 1);
    `);

    ZERO(`
        return 'hello world'.find('world')
             - 2 * [1, 7, 13, 14, 19].find(14); // expect_lambda
    `);

    ZERO(`
        return ('hello world'.has('world') ? 1 : 0) // expect_lambda
             + ([1, 14, 96, 2].has(14)     ? 2 : 0)
             - 3;
    `);

    ZERO(`
        let hw = 'hello world!';
        let a = hw.slice(6, 6 + 5); // expect_lambda
        let b = hw.substr(6, 5);
        return a == b && a == 'world' ? a.len - 5 : 1;
    `);

    ZERO(`
        let tests =
        [
            '',
            ' ',
            '  ',
            'hey you duders',
            ' hey you duders',
            'hey you duders ',
            '  hey you duders ',
            '  hey you  duders ',
            '  hey you  duders  '
        ];

        fn test(item: string)
            item == item.split(' ').join(' ')
                ? 0
                : item.len;

        mut sum = 0;
        for (mut i = 0; i < tests.len; i++)
            sum += test(tests[i]);

        return sum;
    `);


    // Maps.

    ZERO(`
        mut x: Map(string, i32);

        x['hello'] = 1;
        x['world'] = 2;

        return x['hello'] - x['world'] + 1;
    `);

    ZERO(`
        mut x: Map(string, i32);

        x['hello'] = 1;
        x['world'] = 2;

        let b = 'hello world';
        mut offset = 0;

        fn pop(): string { // expect_lambda
            mut a = '';

            while (offset < b.len) {
                let c = b[offset++];
                if (c == ' ')
                    break;

                a += c;
            }

            return a;
        }

        return x[pop()] - x[pop()] + 1;
    `);


    // Default arguments.

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test() - 3;
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(b: -1);
    `);

    ZERO(`
        fn test(a = 1, b = 2) a + b;
        return test(-2);
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(1);
        return t.b;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(a: 1);
        return t.a - 1 + t.b * 7;
    `);

    ZERO(`
        struct Test { a: i32; b: i32; }
        let t = Test(b: 1);
        return t.b - 1 + t.a * 7;
    `);

    ZERO(`
        struct Test { x: i32; };
        fn hey() Test(); // expect_lambda private type, technically ok, technically ok though not needed
        return hey.x;
    `);

    ZERO(`
        struct Test { x: i32; };
        fn hey(y: i32 = 0) // expect_lambda private type, technically ok though not needed
            y   ? Test(1)
                : Test();

        return hey.x;
    `);


    // Truth tests.

    ZERO(`
        let s = 7;
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = 0;
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = 'hello';
        return s ? 0 : 1;
    `);

    ZERO(`
        let s = '';
        return s ? 1 : 0;
    `);

    ZERO(`
        let s = [ 4 ];
        return s ? 0 : 1;
    `);

    ZERO(`
        mut s = [ 4 ];
        s.pop();
        return s ? 1 : 0;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S = S(1);
        return s ? 0 : 1;
    `);

    ZERO(`
        struct S { x: i32; }
        let s: S;
        return s ? 1 : 0;
    `);


    // Loop labels.

    ZERO(`
        mut sum = 0;

        :outer for (mut y = 1; y < 10; y++)
        {
            sum += y * 10; // 10, 20
            for (mut x = 1; x < 10; x++)
            {
                sum += x; // 1, 1, 2
                if (y == 1) continue :outer;
                if (x == 2) break    :outer;
            }
        }

        return sum - 34;
    `);


    // Comma operator.

    ZERO(`
        mut a = 0;
        return (a++, a - 1);
    `);


    // Lint.

    ZERO(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        t.test();
        return t.x - 1;
    `);

    FAIL(`
        struct Test { x: i32; }
        fn test(t: &mut Test) t.x++;
        mut t = Test();
        t.test; //ERR orphan
        return t.x - 1;
    `);


    // Logical selectors.

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = x || y;

        return w == 'hello' ? 0 : 1; // expect_lambda
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = x && y; // expect_lambda

        return w == 'world' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let w = 3 && x || y; // expect_lambda

        return w == 'hello' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let arr: i32[];
        let w = arr && x || y; // expect_lambda

        return w == 'world' ? 0 : 1;
    `);

    ZERO(`
        let x = 'hello';
        let y = 'world';
        let arr: i32[];
        let w = arr && x || y || throw("Nope."); // expect_lambda

        return w == 'world' ? 0 : 1;
    `);


    // Short-circuit assignment, esp. useful for maps
    //  and the cpp `map[k] = v`,
    //   which doesn't decompose safely.

    ZERO(`
        mut i = 7;
        i ||= 11; // expect_lambda
        return i - 7;
    `);

    ZERO(`
        mut i = 0;
        i ||= 11; // expect_lambda
        return i - 11;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m['hello'] = 'world';
        fn f() (
            g++, 'cruel world'); // expect_lambda

        m['hello'] ||= f();
        return g;
    `);

    ZERO(`
        mut m: Map(string, string);
        mut g = 0;

        m['_not_hello_'] = 'world';
        fn f() (
            g++, 'cruel world'); // expect_lambda

        m['hello'] ||= f();
        return g - 1;
    `);


    // Lint checks.

    ZERO(`
        {
            {
                return 0;
            }
        }
    `);

    FAIL(`
        {
        {
            return 0; //ERR block
        }
        }
    `);

    ZERO(`
        {
            return 0;
        }
    `);

    FAIL(`
        {
            return 0; //ERR block
       }
    `);

    FAIL(`
        {
            return 0; //ERR block
         }
    `);


    // Stuff that isn't working out quite right -
    //  Keep those around, there's no principle to these tests,
    //   they just stressed our stuff in weird ways.

    ZERO(`

    struct BINOP {
        P: Map(string, i32);
    };

    fn setupOperators(): BINOP
    {
        mut out: BINOP;

        fn binop(op: string)
            out.P[op] = 7;

        binop(',');

        return out;
    }

    let BINOP   = setupOperators();
    let P_COMMA = BINOP.P[','] || assert();

    fn ZERO() P_COMMA - 7;

    `);

    ZERO(`

        // -no-lambda
        // This converted to a ref-returning
        // logical chain for some reason.
        let hex = true;
        let trail = 'x';
        if (!(trail >= '0' && trail <= '9') &&
            !(hex && (trail >= 'a' && trail <= 'f'
                   || trail >= 'A' && trail <= 'F')))
        {
            return 0;
        }

        return 1;

    `);

    ZERO(`
        struct Type     { i: i32; };
        struct Token    { i: i32; };
        struct ScopeIdx { i: i32; };

        struct SolvedNode
        {
            kind:       string;
            flags:      i32;
            value:      string;
            items:      SolvedNode[];
            token:      Token;

            type:       Type;
            target:     ScopeIdx;
        };

        let _here: Token;

        fn createDefaultInit(type: Type): SolvedNode
        {
            // Broken arg re-arrange.
            return SolvedNode(
                kind: 'definit',
                token: _here,
                :type);
        }

        return createDefaultInit(Type()).target.i;
    `);

    ZERO(`
        struct Type         { i: i32; };
        struct Scope        { i: i32; };
        struct Partial      { i: i32; };
        struct Template     { i: i32; };
        struct SolvedNode   { i: i32; };

        pub fn Scope_add(
            scope: &mut Scope,
            kind: string, id: string, type: Type,

            min: i32 = 0,
            max: i32 = 0,
            arg_n: string[]     = [],
            arg_t: Type[]       = [],
            arg_d: SolvedNode[] = [],
            template: Template  = [],
            partial: Partial    = []): i32
        {
            return scope.i
                 + kind.len + id.len + type.i
                 + min + max + arg_n.len + arg_t.len + arg_d.len
                 + template.i + partial.i;
        }

        mut _scope: Scope;
        let id: string;
        let t_template: Type;
        let min: i32;
        let max: i32;
        let arg_n: string[];
        let template: Template;

        return Scope_add(
            _scope,
            '', id, t_template,
            min, max, arg_n,
            :template);
    `);

    ZERO(`
        let i = 0;
        let items = [ '' ];
        i == items.len - 1 || throw('what?');
        return i;
    `);

    ZERO(`

        return false /* test */
             ? 0xffffff // what is this
             : 0 // madness
             ;
    `);

    ZERO(`

        fn path_normalize(p: string): string {
            mut path = p.split('/');

            for (mut i = path.len; i --> 0; ) {
                let part = path[i];
                if (part == '.' || !part && i > 0 && i < path.len - 1)
                    path.splice(i, 1);
            }

            for (mut i = 1; i < path.len; i++) {
                if (path[i] == '..')
                    path.splice(--i, 2);
            }

            return path.join('/');
        }

        fn path_join(a: string, b: string)
            path_normalize(a + '/' + b);

        fn ZERO()
            path_join('hello/hey', './../you//') == 'hello/you/'
                ? 0 : 1;
    `);


    // Let's move on to some cooler quality of life shit.

    ZERO(`
        let a = 7;
        let b = a && 3;
        return b - 3;
    `);

    ZERO(`
        struct S { i: i32; }

        let a = S(0);
        let b = S(3);

        return a.i
            || (b || S(4)).i * 2 - (a || S(6)).i
            && throw('woot');
    `);

    ZERO(`

        struct TrueStory { kind: string; value: string; };

        mut specialized = TrueStory(kind: 'fn', value: 'val');

        specialized.kind == 'fn' && specialized.value || throw('nope');

        let v: &mut string = specialized.kind == 'fn'
                          && specialized.value
                          || throw('nope');
        v += 'ue';

        return specialized.value == 'value' ? 0 : 1;

    `);

    ZERO(`
        struct Token {
            value: string;
        };

        fn consume(): Token {
            return Token('hey');
        };

        fn ZERO(): i32 {
            let a = 3;
            let v = a && consume().value;
            return v.len - a;
        };
    `);

    FAIL(`
        struct ScopeIdx { raw: i32; };
        fn thing(x: i32) x;
        mut _return_scope: ScopeIdx;

        fn hey(x: i32) {
            let scope0 = thing(x);
            _return_scope = scope0; //overload
            return _return_scope.raw;
        }

        return hey(0);
    `);


    // Various templating fallacies.
    //
    // TODO figure these out -
    //  These are problematic in a bunch of ways here.
    //   But mostly, the case patterns for this kind of thing are outright moronic.

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        fn ZERO()
        {
            let a = [1];
            mut b = [2];

            b.ARR_LAST += a.ARR_LAST;
            return b.ARR_LAST - 3;
        };
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            case ($a -> &mut $T[]): &mut $T a[a.len - 1];
            case ($a -> &    $T[]): &    $T a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - 3;
    `);

    ZERO(`
        struct S { i: i32; }
        fn test(mut x: S) x.i += 1;
        return S(-1).test;
    `);

    ZERO(`
        fn ARR_LAST(a: $T[])
            a[a.len - 1];

        let a = [1];
        mut b = [2];

        b.ARR_LAST += a.ARR_LAST;
        return b.ARR_LAST - [3].ARR_LAST;
    `);


    // Let's try something new.

    ZERO(`

        struct SolvedNode {
            value: i32;
            items: SolvedNode[];
        };

        fn visitNodes(_v: &mut $V, _n: SolvedNode) {

            fn traverse(v: &mut $V, n: SolvedNode) {
                v.visit(n);
                for (mut i = 0; i < n.items.len; i++)
                    traverse(v, n.items[i]);
            }

            traverse(_v, _n);
        };

        struct Visitor {
            sum: i32;
        };

        fn visit(using v: &mut Visitor, node: SolvedNode) {
            sum += node.value;
        };

        fn ZERO(): i32 {
            let tree = SolvedNode(3,
                [ SolvedNode(5), SolvedNode(7) ]);

            mut myVisitor: Visitor;
            myVisitor.visitNodes(tree);
            return myVisitor.sum - 15;
        };

    `);


    // Ternary improvements.

    ZERO(`
        return 0 > 1 ? throw('should type check') : 0;
    `);


    // Catch.

    ZERO(`
        fn throw_hey(): i32 {
            throw('hey');
            return 1;
        }

        fn ZERO(): i32 {
            let x = throw_hey()
                catch err
                    return err.len - 3;

            return 7;
        }
    `);
}
