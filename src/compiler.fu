import helpers;
import context;
import stat;


//

fn compile(fname: string, via: string = "")
{
    let implicit mut module = getModule(fname).clone();

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = scope::ModuleOutputs;

        let src = getFile(fname) || throw (
            "import badfile: `" ~ via ~ fname ~ "`.");

        let stat0 = ModuleStat_now();
        let lexer_result = lexer::lex(:fname, :src);

        let stat1 = ModuleStat_now();
        let parser_result = parser::parse( :module.modid, :fname, :lexer_result.tokens );

        let stat2 = ModuleStat_now();

        module.in = scope::ModuleInputs(
            :src, lex: lexer_result,
            parse: parser_result);

        // Stat.
        module.stats.lex   = stat1 - stat0;
        module.stats.parse = stat2 - stat1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            "import circle: `" ~ via ~ fname ~ "`.");
    }

    // We're good to go here.
    if (!module.out)
    {
        // Ensure dependencies.
        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
            compile(
                fname: resolveFile(fuzimports[i]),
                  via: fname ~ " <- " ~ via);

        //
        let stat0 = ModuleStat_now();
        module.out.solve = solver::solve(
            module.in.parse.root);

        let stat1 = ModuleStat_now();
        module.out.cpp = codegen::cpp_codegen(
            module.out.solve.root);

        let stat2 = ModuleStat_now();

        module.stats.solve   = stat1 - stat0;
        module.stats.codegen = stat2 - stat1;

        // Final repersist.
        setModule(module);
    }
}


//

fn absdir(a: string)
    a.if_last == '/' ? a : a ~ '/';

let HOME = absdir(env::get("HOME"));

pub fn locate_PRJDIR(): string
{
    let dir = HOME ~ "fu/";
    let fn  = dir  ~ "src/compiler.fu";
    let fs  = file::size(fn);
        fs  > 1000 || throw("Bad compiler.fu: " ~ fn ~ ": " ~ fs);

    println("PRJDIR: " ~ dir);
    return dir;
}

pub let PRJDIR              = locate_PRJDIR();
pub let DEFAULT_WORKSPACE   = PRJDIR ~ "build.cpp/";
pub let FULIB               = PRJDIR ~ "include/fu/_fulib.cpp";


//

pub fn build(
      fname: string,
        run: bool,

    dir_wrk: string,

    bin     = "",
    dir_obj = "",
    dir_src = "",
    dir_cpp = "",
    scheme  = "",

    nowrite = false)
{
    let implicit mut ctx = prelude::CTX_PRELUDE.clone();

    {
        println("COMPILE ", fname);

        let t0 = now::hr();
        compile(:fname);
        let t1 = now::hr();
        let tt = t1 - t0;

        if (t1 - t0 > 0.025)
        {
            mut lex:        ModuleStat;
            mut parse:      ModuleStat;
            mut solve:      ModuleStat;
            mut codegen:    ModuleStat;

            ref m = ctx.modules;
            for (mut i = 0; i < m.len; i++)
            {
                lex     += m[i].stats.lex;
                parse   += m[i].stats.parse;
                solve   += m[i].stats.solve;
                codegen += m[i].stats.codegen;
            }

            ModuleStat_print(lex,   "\n    lex ");
            ModuleStat_print(parse,   "  parse ");
            ModuleStat_print(solve,   "  solve ");
            ModuleStat_print(codegen, "codegen ", "\n");
        }

        println("        ", tt, "s\n");
    }

    return ::build(
        ctx, :run, :bin, :scheme,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp,
        unity: fname, fulib: FULIB, :nowrite);
}


// Test running infra.

pub fn compile_snippets(sources: string[], fnames?: string[]): Context
{
    fn ensure_main(src: string)
        src.has("fn main(")
            ? src
            : "\n\nfn main(): i32 {\n" ~ src ~ "\n}\n";

    let implicit mut ctx = prelude::CTX_PRELUDE.clone();
    for (mut i = 0; i < sources.len; i++)
    {
        let snippet = sources[i];
        let src     = i == sources.len - 1
                    ? ensure_main(snippet)
                    : snippet;

        let fname   = fnames.len > i ? fnames[i] : PRJDIR ~ "__tests__/_" ~ i ~ ".fu";

        ctx.files[fname] = src;
        compile(:fname);
    }

    for (mut i = 0; i < ctx.modules.len; i++)
    {
        ref module = ctx.modules[i];
        if (module.out.solve.SLOW_resolve)
            module.in.src.has("//! SLOW_resolve")
                || throw("SLOW:"
                        ~ "\n\tUnexpected SLOW_resolve:"
                        ~ "\n\t    we recursively type-checked something multiple times"
                        ~ "\n\t    which shouldn't be needed for this snippet:\n"
                            ~ module.in.src);
        else
            module.in.src.has("//! SLOW_resolve")
                && throw("We're getting better!"
                        ~ "\n\t    SLOW_resolve not needed for this snippet:\n"
                            ~ module.in.src);
    }

    return ctx;
}

pub fn snippet2cpp(src: string): string
{
    let fname = "SNIPPET";

    let ctx = compile_snippets([ src ], [ fname ]);
    for (mut i = 0; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        if (module.fname == fname)
            return module.out.cpp;
    }

    return "";
}

pub fn ZERO(sources: string[]): Context
{
    let ctx = compile_snippets(:sources);

    let run = true;
    let fulib = FULIB;
    let dir_wrk = DEFAULT_WORKSPACE;

    let nowrite = !sources.last.has("//! ALLOW_WRITE") && !env::get("fu_ALLOW_WRITE");

    ::build(:ctx, :run, :fulib, :dir_wrk, scheme: "debug", :nowrite);
    ::build(:ctx, :run, :fulib, :dir_wrk, :nowrite);

    return ctx;
}

fn FAIL_replace(mut sources: string[]): string[]
{
    for (mut i = 0; i < sources.len; i++)
        sources[i] = sources[i]
            .replace(all: "//*F", with: "/*");

    return sources;
}

fn indent(src: string): string
    src.replace(all: "\n", with: "\n\t");

pub fn FAIL(sources: string[]): string
{
    let ctx = compile_snippets(sources)
        catch e
            return ZERO(FAIL_replace(sources)) && e;

    mut bad = "\nDID NOT THROW:\n";

    for (mut i = 1; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        bad ~= "\n#" ~ i ~ ": "         ~ module.fname ~ "\n";
        bad ~= "\nfu  [" ~ i ~ "]:\n\t" ~ module.in .src.indent
             ~ "\ncpp [" ~ i ~ "]:\n\t" ~ module.out.cpp.indent
             ~ "\n";
    }

    return throw(bad);
}

pub fn ZERO_SAME(alts: string[][])
{
    let expect = ZERO(alts[0]).modules;

    for (mut i = 1; i < alts.len; i++)
    {
        let actual = compile_snippets(sources: alts[i]).modules;
        if (expect.len != actual.len)
            throw("ZERO_SAME: expect/actual len mismatch.");

        for (mut m = 0; m < actual.len; m++)
        {
            let x = expect[m].out.cpp;
            let a = actual[m].out.cpp;

            if (x != a)
                throw(
                    "ZERO_SAME: alts[" ~ i ~ "] mismatch at:\n"
                        ~ "\nexpect[" ~ m ~ "]:\n\t" ~ x.indent
                        ~ "\nactual[" ~ m ~ "]:\n\t" ~ a.indent
                        ~ "\n");
        }
    }
}

pub fn ZERO(src: string) ZERO(sources: [ src ]);
pub fn FAIL(src: string) FAIL(sources: [ src ]);

pub fn ZERO_SAME(alts: string[])
{
    mut wrap: string[][];
    for (mut i = 0; i < alts.len; i++)
        wrap ~= [ alts[i] ];

    return ZERO_SAME(wrap);
}
