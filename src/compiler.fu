import helpers;
import context;
import stat;
import options;


//

fn compile(fname: string, via: string = "", options?: Options)
{
    let implicit mut module = getModule(fname).clone();

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = scope::ModuleOutputs;

        let src = getFile(fname) || throw (
            "import badfile: `" ~ via ~ fname ~ "`.");

        let stat0 = ModuleStat_now();
        let lexer_result = lexer::lex(:fname, :src);

        let stat1 = ModuleStat_now();
        let parser_result = parser::parse( :module.modid, :fname, :lexer_result.tokens, :options );

        let stat2 = ModuleStat_now();

        module.in = scope::ModuleInputs(
            :src, lex: lexer_result,
            parse: parser_result);

        // Stat.
        module.stats.lex   = stat1 - stat0;
        module.stats.parse = stat2 - stat1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            "import circle: `" ~ via ~ fname ~ "`.");
    }

    // We're good to go here.
    if (!module.out)
    {
        // Ensure dependencies.
        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
            compile(
                fname: resolveFile(fuzimports[i]),
                  via: fname ~ " <- " ~ via);

        //
        let stat0 = ModuleStat_now();
        module.out.solve = solver::solve(
            module.in.parse.root,
            :options);

        let stat1 = ModuleStat_now();
        module.out.cpp = codegen::cpp_codegen(
            module.out.solve.root);

        let stat2 = ModuleStat_now();

        module.stats.solve   = stat1 - stat0;
        module.stats.codegen = stat2 - stat1;

        // Final repersist.
        setModule(module);
    }
}


//

fn absdir(a: string)
    a.if_last == '/' ? a : a ~ '/';

let HOME = absdir(env::get("HOME"));

pub fn locate_PRJDIR(): string
{
    let dir = HOME ~ "fu/";
    let fn = dir  ~ "src/compiler.fu";
    let fs = file::size(fn);
    fs > 1000 || throw("Bad compiler.fu: " ~ fn ~ ": " ~ fs);

    println("PRJDIR: " ~ dir);
    return dir;
}

pub let PRJDIR              = locate_PRJDIR();
pub let DEFAULT_WORKSPACE   = PRJDIR ~ "build-cpp/";
pub let FULIB               = PRJDIR ~ "include/fu/_fulib.cpp";


//

pub fn build(
      fname: string,
        run: bool,

    dir_wrk: string,

    bin     = "",
    dir_obj = "",
    dir_src = "",
    dir_cpp = "",
    scheme  = "")
{
    let implicit mut ctx = prelude::CTX_PRELUDE.clone();

    {
        println("COMPILE ", fname);

        let t0 = now::hr();
        compile(:fname);
        let t1 = now::hr();
        let tt = t1 - t0;

        if (t1 - t0 > 0.025)
        {
            mut lex:        ModuleStat;
            mut parse:      ModuleStat;
            mut solve:      ModuleStat;
            mut codegen:    ModuleStat;

            ref m = ctx.modules;
            for (mut i = 0; i < m.len; i++)
            {
                lex     += m[i].stats.lex;
                parse   += m[i].stats.parse;
                solve   += m[i].stats.solve;
                codegen += m[i].stats.codegen;
            }

            ModuleStat_print(lex,   "\n    lex ");
            ModuleStat_print(parse,   "  parse ");
            ModuleStat_print(solve,   "  solve ");
            ModuleStat_print(codegen, "codegen ", "\n");
        }

        println("        ", tt, "s\n");
    }

    return ::build(
        :ctx, :run, :bin, :scheme,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp,
        unity: fname, fulib: FULIB);
}


// Test running infra.

let NOTES = [
    "FN_recursion",
    "FN_resolve",
    "FN_reopen",
    "TYPE_recursion",
    "TYPE_resolve",
    "TYPE_reopen",
    "DEAD_code",
    "DEAD_call",
    "DEAD_let",
    "DEAD_if",
    "DEAD_if_cons",
    "NONTRIV_autocopy",
    "RELAX_respec",
];

pub fn compile_snippets(sources: string[], fnames?: string[], options?: Options[]): Context
{
    fn ensure_main(src: string)
        src.has("fn main(")
            ? src
            : "\n\nfn main(): i32 {\n" ~ src ~ "\n}\n";

    let implicit mut ctx = prelude::CTX_PRELUDE.clone();
    for (mut i = 0; i < sources.len; i++)
    {
        let snippet = sources[i];
        let src     = i == sources.len - 1
                    ? ensure_main(snippet)
                    : snippet;

        let fname   = fnames.len > i ? fnames[i] : PRJDIR ~ "__tests__/_" ~ i ~ ".fu";

        ctx.files[fname] = src;
        compile(:fname, options:
            options.len > i && options[i]);
    }

    for (mut i = 0; i < ctx.modules.len; i++)
    {
        ref module = ctx.modules[i];
        mut notes = module.out.solve.notes;
        for (mut bit = 0; bit < NOTES.len && notes; bit++)
        {
            let mask  = 1 << bit;
            let isset = notes & mask;
            notes &= ~mask;
            if (isset)
                module.out.cpp.src ~= "// " ~ NOTES[bit] ~ "\n";
        }
    }

    return ctx;
}

pub fn snippet2cpp(src: string): string
{
    let fname = "SNIPPET";

    let ctx = compile_snippets([ src ], [ fname ]);
    for (mut i = 0; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        if (module.fname == fname)
            return module.out.cpp.src;
    }

    return "";
}

pub fn ZERO(
    implicit ref testdiffs: testdiff::TestDiffs,
    mut sources: string[]): Context
{
    // Fuzzing module splits.
    for (mut i = 0; i < sources.len; i++)
    {
        ref src = sources[i];
        for (;;)
        {
            mut start0 = src.find("<split/>");
            if (start0 < 0)
                break;

            // Avoid trailing whitespace.
            let start00 = start0;
            let start1  = start0 + 8;
            while (start0 && src[start0 - 1] == ' ') start0--;

            // We'll test with and without a module split here.
            let moduleA = src.slice(0, start0);
            let moduleB = src[start0, start00] ~ "import _" ~ i ~ ";" ~ src[start1, src.len];
            let without = src[0, start0] ~ src[start1, src.len];

            sources[i]  = without;
            ZERO(:testdiffs, :sources);

            // Continue with the greater modules count here.
            sources[i]  = moduleA;
            sources.insert(i + 1, moduleB);
        }
    }

    // Test variations, very primitive fuzzing.
    for (mut i = 0; i < sources.len; i++)
    {
        ref src = sources[i];
        for (;;)
        {
            mut start0 = src.find("<alt>");
            if (start0 < 0)
                break;

            mut end0 = src.find("</alt>", start: start0);
            end0 >= 0 || throw("No closing `</alt>` for `<alt>`.");

            // Avoid trailing whitespace.
            let start1 = start0 + 5;
            let end1   = end0   + 6;
            while (start0 && src[start0 - 1] == ' ') start0--;
            while (          src[end0   - 1] == ' ') end0--;

            // We'll retry two times - with an without the alt.
            //  This allows us to fuzz different combinations with little effort.
            let with    = src[0, start0] ~ src[start1, end0] ~ src[end1, src.len];
            let without = src[0, start0]                     ~ src[end1, src.len];

            sources[i]  = without;
            ZERO(:testdiffs, :sources);

            // Continue with the more complex test here.
            sources[i]  = with;
        }
    }

    //
    mut expectations: string[][];
    mut options: Options[];
    for (mut i = 0; i < sources.len; i++)
    {
        ref src = sources[i];

        // Trim trailing spaces
        //  to help with manual testdiff edits.
        {
            mut end = src.len;
            for (mut r = src.len; r --> 0 && src[r] == ' '; )
                end = r;

            src.shrink(end);
        }

        // Collect ;; TODO and ;; EXPECTs.
        mut break_notes: i32;

        mut start = 0;
        while ((start = src.find(" ;; ", :start)) >= 0)
        {
            mut end = src.find('\n', start + 4);
            if (end < 0)
                end = src.len;

            let annot = src.slice(start + 4, end);
            if (annot[0] == '!')
            {
                let idx = NOTES.find(annot.slice(1, annot.len));
                idx >= 0 || throw("Bad break_note: `;; " ~ annot ~ "`.");
                break_notes |= 1 << idx;
            }
            else
            {
                expectations.grow_if_oob(i) ~= annot;
            }

            // Turn ;; commands into // comments and hop over.
            src[start + 1]  = '/';
            src[start + 2]  = '/';
            start           = end;
        }

        options ~= Options(:break_notes);
    }

    // We can now safely do the nowrites second -
    //  so that we can first test if the thing works,
    //   and only then allow you to persist it as an OK test output.
    //
    let ctx = compile_snippets(:sources, :options);

    // Deal with expectations first, nicer errors.
    for (mut i = 0; i < expectations.len; i++)
    {
        let arr = expectations[i];
        let src = sources[i];
        let cpp = ctx.modules[i + 1].out.cpp;

        for (shadow mut i = 0; i < arr.len; i++)
        {
            let x = arr[i];
            let idx = x.find(' ');
            let cmd = x.slice(0, idx);
            let rest = x.slice(idx + 1);

            let found = cpp.src.has(rest);

            if (cmd == "EXPECT")
                found || throw("EXPECT mismatch: `;; " ~ x ~ "` in:\n" ~ src ~ "\n\nOutput is:\n\n" ~ cpp.src);
            else if (cmd != "TODO")
                throw("Unknown ;; CHECK: `;; " ~ x ~ "` in:\n" ~ src);
            else if (found)
                throw("TODO test is actually passing: `;; " ~ x ~ "` in:\n" ~ src ~ "\n\nOutput is:\n\n" ~ cpp.src);
            else
                println("  TODO: `;; " ~ x ~ "` in:\n" ~ src);
        }
    }

    let run = true;
    let fulib = FULIB;
    let dir_wrk = DEFAULT_WORKSPACE;

    ::build(:ctx, :run, :fulib, :dir_wrk, scheme: "debug"   , onfail: "print-src");
    ::build(:ctx, :run, :fulib, :dir_wrk                    , onfail: "print-src");

    // OK so it works, let's see if test output actually matches -
    //  this also allows us to perhaps defer all nowrite fails till all tests clear.
    //
    {
        mut key = "";
        for (mut i = 0; i < sources.len; i++)
        {
            key ~= sources[i];
            let actual = ctx.modules
                [i + ctx.modules.len - sources.len]
                    .out.cpp;

            testdiffs.testdiff::set_next(key, actual);
        }
    }

    return ctx;
}

fn FAIL_replace(mut sources: string[]): string[]
{
    for (mut i = 0; i < sources.len; i++)
        sources[i] = sources[i]
            .replace(all: "//*F", with: "/*");

    return sources;
}

fn indent(src: string): string
    src.replace(all: "\n", with: "\n\t");

pub fn FAIL(sources: string[]): string
{
    let ctx = compile_snippets(sources)
        catch e
            return ZERO(FAIL_replace(sources)) && e;

    mut bad = "\nDID NOT THROW:\n";

    for (mut i = 1; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        bad ~= "\n#" ~ i ~ ": "         ~ module.fname ~ "\n";
        bad ~= "\nfu  [" ~ i ~ "]:\n\t" ~ module.in .src.indent
             ~ "\ncpp [" ~ i ~ "]:\n\t" ~ module.out.cpp.indent
             ~ "\n";
    }

    return throw(bad);
}

pub fn ZERO_SAME(alts: string[][])
{
    let expect = ZERO(alts[0]).modules;

    for (mut i = 1; i < alts.len; i++)
    {
        let actual = compile_snippets(sources: alts[i]).modules;
        if (expect.len != actual.len)
            throw("ZERO_SAME: expect/actual len mismatch.");

        for (mut m = 0; m < actual.len; m++)
        {
            let x = expect[m].out.cpp.src;
            let a = actual[m].out.cpp.src;

            if (x != a)
                throw(
                    "ZERO_SAME: alts[" ~ i ~ "] mismatch at:\n"
                        ~ "\nexpect[" ~ m ~ "]:\n\t" ~ x.indent
                        ~ "\nactual[" ~ m ~ "]:\n\t" ~ a.indent
                        ~ "\n");
        }
    }
}

pub fn ZERO(src: string) ZERO(sources: [ src ]);
pub fn FAIL(src: string) FAIL(sources: [ src ]);

pub fn ZERO_SAME(alts: string[])
{
    mut wrap: string[][];
    for (mut i = 0; i < alts.len; i++)
        wrap ~= [ alts[i] ];

    return ZERO_SAME(wrap);
}
