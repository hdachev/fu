#import 'helpers';
#import 'lexer';
#import 'parser';
#import 'types';
#import 'solver';
#import 'codegen';
#import 'prelude';


//

fn compile(fname: string, via: string = '')
{
    let implicit mut module = getModule(fname);

    // Inputs are only dependent on the one file in question.
    if (!module.in)
    {
        // Invalidate outputs.
        module.out = ModuleOutputs;

        let src = getFile(fname) || throw (
            '#import badfile: `' + via + fname + '`.');

        let t0 = now_hr();
        let lexer_result =
            lex(:fname, :src);

        let t1 = now_hr();
        module.in = ModuleInputs(
            :src, lex: lexer_result,
            :parse( :module.modid, :fname, :lexer_result.tokens ));

        let t2 = now_hr();

        // Stat.
        module.stats.s_lex   = t1 - t0;
        module.stats.s_parse = t2 - t1;

        // Prevent module circles.
        setModule(module);
    }
    else
    {
        // Having input stuff solved but no output stuff means circular #import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.out || throw (
            '#import circle: `' + via + fname + '`.');
    }

    // Compile dependencies -
    //  since we link in reverse, we reverse the deps here too,
    //   resulting in a link that's in the order of imports.
    let imports = module.in.parse.imports;
    for (mut i = imports.len; i --> 0; )
        compile(
            fname: imports[i],
              via: fname + ' <- ' + via);

    // We're good to go here.
    if (!module.out)
    {
        let t0 = now_hr();
        module.out.solve = solve(
            module.in.parse.root);

        let t1 = now_hr();
        module.out.cpp = cpp_codegen(
            module.out.solve.root,
            module.out.solve.scope);

        let t2 = now_hr();

        module.stats.s_solve = t1 - t0;
        module.stats.s_cpp   = t2 - t1;

        // Final repersist.
        setModule(module);
    }

    // --------------------------------------------- //
    // print('lex     ', module.stats.s_lex,   's'); //
    // print('parse   ', module.stats.s_parse, 's'); //
    // print('solve   ', module.stats.s_solve, 's'); //
    // print('codegen ', module.stats.s_cpp,   's'); //
    // --------------------------------------------- //
}

fn compile_snippet(mut src: string, fname: string): TEMP_Context
{
    // Some nonsense.
    if (!src.has('fn main('))
        src = '\n\nfn main(): i32 {\n' + src + '\n}\n';

    //
    let implicit mut ctx = CTX_PRELUDE;
        ctx.files[fname] = src;

    compile(:fname);

    return ctx;
}

fn compile_snippet(src: string): string
{
    let fname = 'testcase';
    let ctx = compile_snippet(src, fname);
    for (mut i = 1; i < ctx.modules.len; i++)
        if (ctx.modules[i].fname == fname)
            return ctx.modules[i].out.cpp;

    assert();
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Orchestration.

let GCC_CMD = 'g++ -std=c++1z -O3 '
            + '-pedantic-errors -Wall -Wextra -Werror ' // opt-in
            + '-Wno-parentheses-equality ' // opt-out
            ;

fn update_file(fname: string, data: string)
{
    if (file_read(fname) == data)
        return;

    file_write(fname, data);
    print('  WROTE ' + fname);
}

fn update_cpp(module: Module,
    dir_src: string = '',
    dir_cpp: string = '')
{
    mut fname = module.fname + '.cpp';

    if (dir_src && dir_cpp)
    {
        if (!fname.starts(with: dir_src))
        {
            print('NOWRITE ', fname, ': not within ', dir_src);
            return;
        }

        // TODO mkdirp
        fname = dir_cpp + fname.slice(dir_src.len);
    }

    update_file(:fname, module.out.cpp);
}

pub fn build(
    ctx: TEMP_Context,
    run: bool,

    mut dir_wrk: string,

    mut bin     = '',
    mut dir_obj = '',
    mut dir_src = '',
    mut dir_cpp = ''): void
{
    // Where we do our dirtywork.
    if (dir_wrk.last != '/')
    {
        dir_wrk || throw ('No workspace directory provided.');
        dir_wrk += '/';
    }

    //
    if (dir_obj && dir_obj.last != '/') dir_obj += '/';
    if (dir_src && dir_src.last != '/') dir_src += '/';
    if (dir_cpp && dir_cpp.last != '/') dir_cpp += '/';

    //
    mut code:   i32;
    mut stdout: string;

    //
    mut Fs: string[];
    mut len_all: i32;

    // Starting after prelude.
    for (mut i = 1; i < ctx.modules.len; i++)
    {
        let module  = ctx.modules[i];
        let cpp     = module.out.cpp;
        let F       = dir_wrk   + 'o-' + hash_tea(cpp)
                                + '-' + cpp.len;

        Fs.push(F);
        len_all += cpp.len;
    }

    //
    let F_exe = dir_wrk + 'b-' + hash_tea(Fs.join('/'))
                        +  '-' + len_all + '-' + Fs.len;

    //
    fn ERR(mut cpp: string = '')
    {
        if (!cpp)
            for (mut i = Fs.len; i --> 0; )
                cpp += '#include "' + Fs[i] + '.cpp"\n';

        let fname = dir_wrk + 'failing-testcase.cpp';
        print('  WRITE ' + fname);
        file_write(fname, cpp);

        //
        if (!stdout)
            stdout = '[ EXIT CODE ' + code + ' ]';

        return throw(stdout);
    }

    if (file_size(F_exe) < 1)
    {
        // Build.
        for (mut i = 0; i < Fs.len; i++)
        {
            let F     = Fs[i];
            let F_cpp = F + '.cpp';
            let F_tmp = F + '.o.tmp';
            let F_obj = F + '.o';

            if (file_size(F_obj) < 1)
            {
                // Prelude @ 0.
                let cpp = ctx.modules[i + 1].out.cpp;

                file_write(F_cpp, cpp);

                print('  BUILD ', F_cpp);
                let t0 = now_hr();

                code = shell_exec(GCC_CMD + '-c -o ' + F_tmp + ' ' + F_cpp + ' 2>&1', stdout)
                    || shell_exec('mv ' + F_tmp + ' ' + F_obj + ' 2>&1', stdout);

                if (code) return ERR(cpp);

                let t1 = now_hr();
                print('     OK ', t1 - t0, 's');
            }
        }

        // Link.
        let F_tmp = F_exe + '.tmp';

        mut cmd = GCC_CMD + '-o ' + F_tmp + ' ';
        for (mut i = Fs.len; i --> 0; )
            cmd += Fs[i] + '.o ';

        {
            print('   LINK ', F_exe);
            let t0 = now_hr();

            code = shell_exec(cmd + ' 2>&1', stdout)
                || shell_exec('chmod 755 ' + F_tmp + ' 2>&1', stdout)
                || shell_exec('mv ' + F_tmp + ' ' + F_exe + ' 2>&1', stdout);

            if (code)
            {
                print('   FAIL ' + Fs.join('\n        ' + '\n'));
                return ERR;
            }

            let t1 = now_hr();
            print('     OK ', t1 - t0, 's');
        }

        // Delete single object file.
        if (Fs.len == 1)
            code = shell_exec('rm ' + Fs[0] + '.o 2>&1', stdout);

        if (code) return ERR;
    }

    //
    if (run)
        code = shell_exec(F_exe, stdout);

    if (code) return ERR;

    // .cpp file output.
    if (dir_cpp && dir_src)
        for (mut i = 1; i < ctx.modules.len; i++)
            update_cpp(ctx.modules[i],
                :dir_cpp, :dir_src);

    // output binary.
    if (bin)
        code = shell_exec('mv ' + F_exe + ' ' + bin + ' 2>&1', stdout);

    if (code) return ERR;
}

pub fn build(
      fname: string,
        run: bool,

    dir_wrk: string,

    bin     = '',
    dir_obj = '',
    dir_src = '',
    dir_cpp = '')
{
    let implicit mut ctx = CTX_PRELUDE;

    {
        print('COMPILE ', fname);

        let t0 = now_hr();
        compile(:fname);
        let t1 = now_hr();
        let tt = t1 - t0;

        print('        ', tt, 's\n');
    }

    return build(ctx, :run, :bin,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp);
}




///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Test & rebuild self.

fn absdir(a: string)
    a.last == '/' ? a : a + '/';

let HOME = absdir(env_get('HOME'));

fn locate_PRJDIR(): string {
    let dir = HOME + 'fu/';
    let fn  = dir  + 'src/compiler.fu';
    let fs  = file_size(fn);
        fs  > 1000 || throw('Bad compiler.fu: ' + fn + ': ' + fs);

    print('PRJDIR: ' + dir);
    return dir;
}

    let PRJDIR              = locate_PRJDIR();
pub let DEFAULT_WORKSPACE   = PRJDIR + 'build.cpp/';

fn ZERO(src: string, mut fname = ''): TEMP_Context
{
    if (!fname)
        fname = 'testcase.ZERO';

    let ctx = compile_snippet(:src, :fname);
    build(:ctx, run: true, dir_wrk: DEFAULT_WORKSPACE);

    return ctx;
}

fn FAIL(src: string)
{
    let cpp = compile_snippet(src)
        catch e
            return e.len; // TODO validate

    throw("DID NOT THROW: " + cpp);
}
