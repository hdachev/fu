import helpers;
import context;
import stat;
import options;
import module;


//

fn compile_lexParseDeps(fname: string, via?: string)
{
    let module = getModule(fname);
    if (module.in)
    {
        // Having input stuff solved but no output stuff means circular import -
        //  module.out is currently being worked on the stack above us somewhere.
        module.order || throw(
            "import circle: `" ~ fname ~ "\n\t<- " ~ via ~ "`.");

        return module.order || throw("BUG: !!module.in but !module.order");
    }

    shadow let implicit mut module = module.clone();

    module.out && throw("BUG: !!module.out");

    //
    let src = getFile(fname) || throw(
        "import badfile: `" ~ via ~ fname ~ "`.");

    let stat0 = ModuleStat_now();
    let lexer_result = lexer::lex(:fname, :src);

    let stat1 = ModuleStat_now();
    let parser_result = parser::parse(
        :module.modid, :fname, :src, :lexer_result.tokens);

    let stat2 = ModuleStat_now();

    module.in = ModuleInputs(
        :src, lex: lexer_result,
        parse: parser_result);

    // Stat.
    module.stats.lex   = stat1 - stat0;
    module.stats.parse = stat2 - stat1;

    // Prevent module circles.
    setModule(module);

    // Process deps.
    if (!module.order || throw("BUG: !!module.order"))
    {
        module.order.dep_depth = 1;

        // Ensure dependencies.
        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
        {
            let order =
                compile_lexParseDeps(
                    fname: resolveFile(fuzimports[i]),
                      via: fname ~ (via && "\n\t<- " ~ via));

            if (module.order.dep_depth <= order.dep_depth)
                module.order.dep_depth  = order.dep_depth + 1;
        }

        //
        setModule(module);
    }

    return module.order || throw("BUG: !module.order after lexParseDeps.");
}

fn compile_solveCodegen(implicit ref module: Module, implicit options: Options)
{
    module.out && throw("compile_solveCodegen: !!module.out");

    //
    let stat0 = ModuleStat_now();
    module.out.solve = solver::solve();

    if (options.dev & DEV_PrintAST)
        println(::inspect(module));

    let stat1 = ModuleStat_now();
    module.out.cpp = codegen::cpp_codegen();

    let stat2 = ModuleStat_now();

    module.stats.solve   = stat1 - stat0;
    module.stats.codegen = stat2 - stat1;
}


//

pub fn compile(
    implicit ref ctx: Context,
    implicit options: Options,
    fname: string, via?: string)
{
    compile_lexParseDeps(:fname, :via);

    // Sort the dep order.
    mut dep_order: i32[][];
    for (mut i = 0; i < ctx.modules.len; i++)
    {
        let module = ctx.modules[i];
        dep_order.grow_if_oob(module.order.dep_depth) ~= module.modid;
    }

    ctx.dep_order = dep_order.join();

    //
    for (mut i = 0; i < dep_order.len; i++)
    {
        let modids = dep_order[i];

        //*
        if (options.dev & DEV_Parallel)
        {
            struct Result {
                module?:    Module;
                error?:     string;
            };

            let results: Result[] = modids.par::map(|modid|
            {
                try
                {
                    let module = ctx.modules[modid];
                    if (module.out)
                        continue Result();

                    shadow let implicit mut module = module.clone();
                    compile_solveCodegen();
                    continue Result(:module);
                }
                catch (error)
                {
                    continue Result(:error ||
                        "COMPILER BUG: Empty error string, modid=" ~ modid);
                }
            });

            results.each: |result|
            {
                if (result.error)
                    throw(result.error);
                else if (result.module.out)
                    setModule(result.module);
            }
        }
        else
        //*/
        {
            modids.each: |modid|
            {
                let module = ctx.modules[modid];
                if (!module.out)
                {
                    shadow let implicit mut module = module.clone();
                    compile_solveCodegen();
                    setModule(module);
                }
            }
        }
    }
}


//

fn absdir(a: string)
    a.if_last == '/' ? a : a ~ '/';

let HOME = absdir(env::get("HOME"));

pub fn locate_FUDIR(): string
{
    let dir = HOME ~ "fu/";
    let fn = dir  ~ "src/compiler.fu";
    let fs = file::size(fn);
    fs > 1000 || throw("Bad compiler.fu: " ~ fn ~ ": " ~ fs);
    return dir;
}

pub let FUDIR              = locate_FUDIR();
pub let DEFAULT_WORKSPACE   = FUDIR ~ "build-cpp/";


//

pub fn compile_and_build(

    fname!:     string,
    dir_wrk!:   string,

    //
    bin     !?: string,
    dir_obj !?: string,
    dir_src !?: string,
    dir_cpp !?: string,
    scheme  !?: string,

    // TODO clean these up, this makes NO SENSE //
    run     !?: bool,
    shared  !?: bool,
    hotswap !?: bool,
    nocache !?: bool,
    //////////////////////////////////////////////

    flags_cc!?: string[],
    flags_ld!?: string[],

    shuffle!?: u32)
{
    let implicit mut ctx = prelude::CTX_PRELUDE.clone();
    let implicit options = Options(:shuffle, dev: DEV_Parallel);

    {
        println("COMPILE ", fname);

        let t0 = now::hr();
        compile(:fname);
        let t1 = now::hr();
        let tt = t1 - t0;

        if (t1 - t0 > 0.025)
        {
            mut lex:        ModuleStat;
            mut parse:      ModuleStat;
            mut solve:      ModuleStat;
            mut codegen:    ModuleStat;

            ref m = ctx.modules;
            for (mut i = 0; i < m.len; i++)
            {
                lex     += m[i].stats.lex;
                parse   += m[i].stats.parse;
                solve   += m[i].stats.solve;
                codegen += m[i].stats.codegen;
            }

            ModuleStat_print(lex,   "\n    lex ");
            ModuleStat_print(parse,   "  parse ");
            ModuleStat_print(solve,   "  solve ");
            ModuleStat_print(codegen, "codegen ", "\n");
        }

        println("        ", tt, "s\n");
    }

    return ::build(
        :ctx, :run, :shared, :hotswap, :nocache, :bin, :scheme,
        :dir_wrk, :dir_obj, :dir_src, :dir_cpp,
        :flags_cc, :flags_ld,
        unity: fname,
        fudir: FUDIR);
}
