import helpers;
import module;

pub struct StructCanon { modid: i32; index: i32 };

let ONE_BASED = 1;

pub fn parseStructCanon(canon: string): StructCanon
{
    mut offset = 1;
    {
        let c = canon[0];
        if (c != '/')
            offset = quals::basePrimPrefixLen(canon);
    }

    let mi = parseMi(offset, canon);
    offset == canon.len || throw(
        "parseStructCanon: trailing garbage in `" ~ canon ~ "`: " ~ offset ~ "|" ~ canon.len);

    return StructCanon(:mi.modid, :mi.index - ONE_BASED);
}

pub fn createStructCanon(
    ::kind!, baseprim!: string,
    modid: i32, index: i32, lax name: string): string
{
    mut res = baseprim || "/";
    res.appendMi(:modid, :index + ONE_BASED);

    //
    if (baseprim)
    {
        ref c = res[0];
        if (c == 'e' || c == 'm')
            throw("createStructCanon: bad baseprim: " ~ baseprim);

        if (kind == "enum")
            c = 'e';
        else if (kind == "flags")
            c = 'm';
    }

    //
    let check = parseStructCanon(res);
    if !(check.modid == modid && check.index == index)
    {
        println("NOPE!!!!!");
        parseStructCanon(res);
        throw("Nope!");
    }

    // Name is redundant here, only useful for debug.
    return res;
}

pub fn isStruct(type: Type): bool
{
    return type.canon.starts(with: '/');
}

pub fn isStructOrUnion(type: Type): bool
{
    // TODO FIX createStructCanon gives both the '/' prefix.
    return type.isStruct;
}


//

pub fn modidOfOrigin(type: Type)
{
    if (type.canon[0] == '/')
    {
        let scp = parseStructCanon(type.canon);
        return scp.modid;
    }

    return 0;
}
