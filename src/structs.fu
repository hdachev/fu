import helpers;
import module;

pub struct StructCanon { modid: i32; index: i32 };

let ONE_BASED = 1;

pub fn parseStructCanon(canon: string): StructCanon
{
    mut offset = 1;
    {
        let c = canon[0];
        if (c != '/')
            offset = quals::basePrimPrefixLen(canon) + 1;
    }

    let modid   = canon.parseVarint(:offset).i32;
    let globid  = canon.parseVarint(:offset).i32;

    offset == canon.len
        || canon[offset] == '(' // TODO FIX SPECPATs
        || throw("parseStructCanon: trailing garbage in `" ~ canon ~ "`: " ~ offset ~ "|" ~ canon.len);

    return StructCanon(:modid, globid - ONE_BASED);
}

pub fn createStructCanon(
    ::kind!, basePrim!: string,
    modid: i32, index: i32, lax name: string): string
{
    mut res = basePrim ~ "/";

    modid >= 0 && index >= 0 || throw(
        "createStructCanon: bad modid/index");

    res.appendVarint(modid.u32);
    res.appendVarint((index + ONE_BASED).u32);

    //
    if (basePrim)
    {
        ref c = res[0];
        if (c == 'e' || c == 'm')
            throw("createStructCanon: bad basePrim: " ~ basePrim);

        if (kind == "enum")
            c = 'e';
        else if (kind == "flags")
            c = 'm';
    }

    // Name is redundant here, only useful for debug.
    return res;
}

pub fn isStruct(type: ValueType): bool
{
    return type.canon.starts(with: '/');
}

pub fn isStructOrUnion(type: ValueType): bool
{
    // TODO FIX createStructCanon gives both the '/' prefix.
    return type.isStruct;
}


//

pub fn modidOfOrigin(type: Type)
{
    if (type.canon[0] == '/')
    {
        let scp = parseStructCanon(type.canon);
        return scp.modid;
    }

    return 0;
}
