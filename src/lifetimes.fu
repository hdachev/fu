import helpers;


// A single lifetime is a union of:
//  - scope index: negative for current fn args (which are the lifetime parameters).
//  - relax depth: which is the count of ptr derefs within the referenced scope item.

pub struct Region {
    index:  i32;
    relax?: i32;
};

pub struct Lifetime {
    regions: Region[];
};


// Statics & locals.

pub fn isStatic(l: Lifetime)
    !l.regions;

pub fn isLocal(l: Lifetime)
    l.regions.if_only.index > 0;


// Arguments.

pub fn isArgument(r: Region)
    r.index < 0;

pub fn isArgumentUnion(l: Lifetime)
    l.regions.if_first.isArgument;

pub fn Region_fromArgIndex(argIdx: i32)
    Region( index: -1 - argIdx );

pub fn Region_toArgIndex(r: Region)
    -1 - r.index;


// Statics always lose -
//  Argument unions always lose to a local -
//   This is not actually correct currently, but will work
//    once we stop reasoning about closures as a special thing
//     and have them receive the stuff they close over as implicit arguments.

pub fn inter_locals(a: Lifetime, b: Lifetime)
{
    let ar = a.regions.only;
    let br = b.regions.only;

    return ar.index > br.index || ar.index == br.index
                               && ar.relax <= br.relax
                ? a
                : b;
}

pub fn inter_args(mut a: Lifetime, b: Lifetime)
{
    :OUTER
    for (mut i = 0; i < b.regions.len; i++)
    {
        let br = b.regions[i];
        for (shadow mut i = 0; i < a.regions.len; i++)
        {
            let ar = a.regions[i];
            if (ar.index == br.index)
            {
                if (ar.relax > br.relax)
                    a.regions[i] = br;

                continue :OUTER;
            }

            if (ar.index > br.index)
            {
                a.regions.insert(i, br);
                continue :OUTER;
            }
        }

        a.regions.push(br);
    }

    return a;
}

pub fn type_inter(a: Lifetime, b: Lifetime)
    a.isStatic ? b :
    b.isStatic ? a :

    a.isArgumentUnion
        ? b.isArgumentUnion ? inter_args(a, b)
                            : b // local
        : b.isArgumentUnion ? a // local
                            : inter_locals(a, b);


//

pub fn type_inter(a: Lifetime, b: Region)
    type_inter(a, Lifetime(regions: [ b ]));

pub fn Lifetime_static()
    Lifetime();

pub fn Lifetime_fromArgIndex(argIdx: i32)
    Lifetime( regions: [ Region_fromArgIndex( :argIdx ) ] );

pub fn Lifetime_fromScopeIdx(index: i32)
    Lifetime( regions: [ Region( :index ) ] );

pub fn killedBy(lifetime: Lifetime, returnIdx: i32)
    lifetime.isLocal &&
    lifetime.regions.only.index > returnIdx;



//

pub fn Lifetime_relaxCallArg(mut lifetime: Lifetime, relax: i32)
{
    if (relax > 0)
        for (mut i = 0; i < lifetime.regions.len; i++)
            lifetime.regions[i].relax += relax;

    return lifetime;
}
