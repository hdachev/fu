
pub fn only(s: [$T])
    s.len == 1 ? s[0] : throw (
        "len != 1: " ~ s.len);

pub fn first(s: $T[])
    s.len ? s[0] : throw("len == 0");

pub fn last(s: $T[])
    s.len ? s[s.len - 1] : throw("len == 0");

pub fn if_only(s: $T[])
    s.len == 1 && s[0];

pub fn if_first(s: $T[])
    s.len && s[0];

pub fn if_last(s: $T[])
    s.len && s[s.len - 1];

pub fn grow_if_oob(ref a: $T[], i: i32): &mut $T
{
    if (a.len <= i)
        a.grow(i + 1);

    return a[i];
}

pub fn grow_oob(ref a: $T[], i: i32): &mut $T
{
    a.grow(i + 1);
    return a[i];
}

pub fn grow_oob(ref a: $T[], i: i32, fill!: $T): &mut $T
{
    mut l0 = a.len;
    if (l0 <= i)
    {
        a.grow(i + 1);
        for (; l0 < i; l0++)
            a[l0] = fill;
    }

    return a[i];
}

pub fn unless_oob(a: [$T], i: i32)
    i < a.len && a[i];

pub fn try_steal(ref a: [$T], i: i32)
{
    if (i < a.len)
    {
        mut slot: $T;
        SWAP(slot, a[i]);
        return slot;
    }

    return [];
}

pub fn hasIdentifierChars(id: string)
{
    for (mut i = 0; i < id.len; i++)
    {
        let c = id[i];
        if (c == '_' || c >= 'a' && c <= 'z'
                     || c >= 'A' && c <= 'Z'
                     || c >= '0' && c <= '9')
        {
            return true;
        }
    }

    return false;
}

pub fn path_ext(path: string): string
{
    for (mut i = path.len; i --> 0; )
    {
        let c = path[i];
        if (c == '.') return path.slice(i);
        if (c == '/') break;
    }

    return "";
}

pub fn path_noext(path: string): string
{
    for (mut i = path.len; i --> 0; )
    {
        let c = path[i];
        if (c == '.') return path.slice(0, i);
        if (c == '/') break;
    }

    return "";
}

pub fn path_dirname(path: string): string
{
    for (mut i = path.len - 1; i --> 0; )
        if (path[i] == '/')
            return path.slice(0, i + 1);

    return "/";
}

pub fn path_filename(path: string): string
{
    for (mut i = path.len; i --> 0; )
        if (path[i] == '/')
            return path.slice(i + 1);

    return path;
}

pub fn path_normalize(p: string): string {
    mut path = p.split("/");

    for (mut i = path.len; i --> 0; ) {
        let part = path[i];
        if (part == "." || !part && i > 0 && i < path.len - 1)
            path.splice(i, 1);
    }

    for (mut i = 1; i < path.len; i++) {
        if (path[i] == "..")
            path.splice(--i, 2);
    }

    return path.join("/");
}

pub fn path_relative(from: string, to: string): string {
    let min = from.len < to.len ? from.len : to.len;

    mut same = 0;
    for (mut i = 0; i < min; i++) {
        let a = from[i];
        let b = to[i];

        if (b != a)
            break;

        if (b == '/')
            same = i + 1;
    }

    mut res: string;
    for (mut i = same; i < from.len; i++)
        if (from[i] == '/')
            res ~= "../";

    res ~= to.slice(same);
    return res;
}

pub fn path_join(a: string, b: string)
    b && b[0] == '/'    ? path_normalize(b)
                        : path_normalize(a ~ '/' ~ b);

pub fn ascii_lower(a: string): string
{
    let offset = 'a'.i32 - 'A'.i32;

    mut res = a;
    for (mut i = 0; i < res.len; i++)
    {
        let c = res[i];
        if (c >= 'A' && c <= 'Z')
            res[i] = byte(c.i32 + offset);
    }

    return res;
}

pub fn ascii_upper(c: byte): byte
{
    return c >= 'a' && c <= 'z'
         ? byte(c.i32 + ('A'.i32 - 'a'.i32))
         : c;
}


//

pub fn map(a: [$T], fn)
{
    mut res: fn($T)[];
    res.grow_junk(a.len);
    for (mut i = 0; i < a.len; i++)
        res[i] = fn(a[i]);

    return res;
}

pub fn each(a: [$T], fn)
{
    for (mut i = 0; i < a.len; i++)
        fn(a[i]);
}

pub fn clone(a: $T)
case ($T -> @copy) a;
case ($T -> [$U]) a.map(fn clone);
case ($T -> $T)
{
    mut res: $T;
    for (fieldname i: $T)
        res.i = a.i.clone();

    return res;
}

pub fn steal(a: $T[], start: i32, end: i32)
{
    let size = end - start;

    mut ret: $T[];
    ret.resize(size);

    for (mut i = 0; i < size; i++)
        SWAP(ret[i], a[i + start]);

    a.splice(start, count: size);
    return ret;
}

pub fn remove(ref a: $T[], predicate)
{
    let size = a.len;
    mut keep = 0;

    for (mut i = 0; i < size; i++) {
        if (!predicate(a[i])) {
            if (i > keep)
                SWAP(a[i], a[keep]);

            keep++;
        }
    }

    a.shrink(keep);
}


//

pub fn parse10i32(offset: &mut i32, str: string): i32
{
    mut result: i32;
    while (offset < str.len)
    {
        let c = str[offset];
        if (c < '0' || c > '9')
            break;

        offset++;
        result = result * 10 + (c.i32 - '0'.i32);
    }

    return result;
}
