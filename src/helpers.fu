
fn only(s: [$T])
    s.len == 1 ? s[0] : throw (
        "len != 1: " ~ s.len);

fn first(s: $T[])
    s.len ? s[0] : throw("len == 0");

fn last(s: $T[])
    s.len ? s[s.len - 1] : throw("len == 0");

fn if_only(s: $T[])
    s.len == 1 && s[0];

fn if_first(s: $T[])
    s.len && s[0];

fn if_last(s: $T[])
    s.len && s[s.len - 1];

fn grow_if_oob(ref a: $T[], i: i32): &mut $T
{
    if (a.len <= i)
        a.grow(i + 1);

    return a[i];
}

fn grow_oob(ref a: $T[], i: i32): &mut $T
{
    a.grow(i + 1);
    return a[i];
}

fn grow_oob(ref a: $T[], i: i32, fill!: $T): &mut $T
{
    mut l0 = a.len;
    if (l0 <= i)
    {
        a.grow(i + 1);
        for (; l0 < i; l0++)
            a[l0] = fill;
    }

    return a[i];
}

fn unless_oob(a: [$T], i: i32)
    i < a.len && a[i];

fn try_steal(ref a: [$T], i: i32)
{
    if (i < a.len)
    {
        mut slot: $T;
        swap(slot, a[i]);
        return slot;
    }

    return [];
}

fn hasIdentifierChars(id: string)
{
    for (mut i = 0; i < id.len; i++)
    {
        let c = id[i];
        if (c == '_' || c >= 'a' && c <= 'z'
                     || c >= 'A' && c <= 'Z'
                     || c >= '0' && c <= '9')
        {
            return true;
        }
    }

    return false;
}


//

fn all(a: [$T], pred)
{
    a.each: |item, i|
        if !(pred(item, i?: i))
            return false;

    return true;
}

fn some(a: [$T], pred)
{
    a.each: |item, i|
        if (pred(item, i?: i))
            return true;

    return false;
}


//

fn zip_each(a: [$T;], b: [$U;], fn)
{
    a.len == b.len || throw("a.len != b.len");
    for (mut i = 0; i < a.len; i++)
        fn(a[i], b[i], i?: i);
}

fn zip_all(a: [$T;], b: [$U;], pred)
{
    zip_each(a, b): |shadow a, shadow b, i|
        if !(pred(a, b, i?: i))
            return false;

    return true;
}


//

fn clone(a: $T)
case ($T.is::copy) a;
case ($T -> [$U]) a.map(fn clone);
case ($T -> $T)
{
    mut res: $T;
    for (fieldname i: $T)
        res.i = a.i.clone();

    return res;
}

fn steal(a: $T[], start: i32, end: i32)
{
    let size = end - start;

    mut ret: $T[];
    ret.resize(size);

    for (mut i = 0; i < size; i++)
        swap(ret[i], a[i + start]);

    a.splice(start, count: size);
    return ret;
}

fn remove(ref a: $T[], predicate)
{
    let size = a.len;
    mut keep = 0;

    // TODO OPTI no need to swap trivial
    // TODO OPTI inefficient if array is shared, spec for shared

    for (mut i = 0; i < size; i++) {
        if (!predicate(a[i])) {
            if (i > keep)
                a.swap(i, keep);

            keep++;
        }
    }

    a.shrink(keep);
}


//

fn parse10u32(ref offset: i32, str: string)
{
    mut result: u32;
    while (offset < str.len)
    {
        let c = str[offset];
        if (c < '0' || c > '9')
            break;

        offset++;
        result = result * 10 + (c.u32 - '0'.u32);
    }

    return result;
}

fn parse10s32(ref offset: i32, str: string)
{
    if (offset >= str.len)
        return 0;

    let mul = str[offset] == '-'
        ? { offset++; -1 }
        : +1;

    return parse10u32(offset, str).i32 * mul;
}


// The crazier MMMiiiMMMiii style hex packing.

struct Mi { modid: i32; index: i32 };

fn parseMi(ref offset: i32, str: string)
{
    if (offset >= str.len)
        return [];

    mut modid = 0;
    mut index = 0;

    mut c = str[offset++];

    :END_OF_STRING
    {
        // M
        if (c >= 'G' && c <= 'V')
        {
            // Negative modid!
            defer modid *= -1;
            modid = c.i32 - 'G'.i32;

            mut shift = 4;
            for (;;)
            {
                if (offset == str.len)
                    break :END_OF_STRING;

                c = str[offset++];
                if (c < 'G' || c > 'V')
                    break;

                modid |= (c.i32 - 'G'.i32) << shift;
                shift += 4;
            }
        }
        else if (c >= 'g' && c <= 'v')
        {
            modid = c.i32 - 'g'.i32;

            mut shift = 4;
            for (;;)
            {
                if (offset == str.len)
                    break :END_OF_STRING;

                c = str[offset++];
                if (c < 'g' || c > 'v')
                    break;

                modid |= (c.i32 - 'g'.i32) << shift;
                shift += 4;
            }
        }

        // i
        if (c >= '0' && c <= '9' || c >= 'a' && c <= 'f')
        {
            index = c >= 'a' ? c.i32 - 'a'.i32 + 10
                             : c.i32 - '0'.i32;
            mut shift = 4;
            for (;;)
            {
                if (offset == str.len)
                    break :END_OF_STRING;

                c = str[offset++];
                if (c >= '0' && c <= '9')
                    index |= (c.i32 - '0'.i32     ) << shift;
                else if (c >= 'a' && c <= 'f')
                    index |= (c.i32 - 'a'.i32 + 10) << shift;
                else
                    break;

                shift += 4;
            }
        }

        // Unless we ran out of chars
        //  we would have advanced the cursor
        //   one char too far.
        offset--;
    }

    return Mi(:modid, :index);
}

fn appendMi(ref str: string, mut modid!: i32, mut index!: i32)
{
    // M
    if (modid < 0)
    {
        modid *= -1;
        do
        {
            str ~= ((modid & 15) + 'G'.i32).byte;
            modid >>= 4;
        }
        while (modid);
    }
    else do
    {
        str ~= ((modid & 15) + 'g'.i32).byte;
        modid >>= 4;
    }
    while (modid);

    // i
    do
    {
        let c = index & 15;
        index >>= 4;

        str ~= c >= 10
             ? (c - 10 + 'a'.i32).byte
             : (c      + '0'.i32).byte;
    }
    while (index);
}


//

fn str(arr: [$T]) case ($T.is::arithmetic)
{
    mut result = "";
    for (mut i = 0; i < arr.len; i++)
    {
        if (i == 5 && arr.len > 16)
        {
            i = arr.len - 5;
            result ~= ", ... (" ~ arr.len - 10 ~ " more) ...";
        }

        result ~= (i ? ", " : "[ ");
        result ~= arr[i];
    }

    result ~= result ? " ]" : "[]";
    return result;
}

fn str(arr: [string]) {
    return arr ? "[ \"" ~ arr.join("\", \"") ~ "\" ]" : "[]";
}


//

fn trim(str: string)
{
    for (mut first = 0; first < str.len; first++)
        if (str[first] > ' ')
            for (mut last = str.len; last-- >= first; )
                if (str[last] > ' ')
                    return str.slice(first, last + 1);

    return "";
}


//

fn parse(v: [byte], lax as!: $T)
    case ($T.is::enum || $T.is::bitfield /*TODO .is::flags*/ )
{
    // now supported, there's a test for it, this parser is wrong though
    // if ($T.is::bitfield)
    //     for (mut i = 1; i < v.len; i++)
    //         if (v[i] == "|")
    //             return parse(v[0, i]) | parse(v[i + 1, v.len]);

    for (fieldname i: $T)
        if (v == "i")
            return i; // TODO "i", was only allowed for enums

    return [];
}

fn parseWild(v: [byte], lax as!: $T)
{
    mut result: $T;
    for (mut i = 0; i < v.len; i++)
    {
        if (v[i] == '*')
        {
            let prefix = v[0, i];
            let suffix = v[i + 1, v.len]

            for (fieldname i: $T)
            {
                let opt = "i";
                if (opt.starts(with: prefix) && opt.ends(with: suffix))
                    result |= i;
            }

            return result;
        }
    }

    return parse(:v, :as);
}

fn steal !T(ref v: T) {
    mut ret: T;
    swap(v, ret);
    return ret;
}
