
fn only(s: $T[]): $T
    s.len == 1 ? s[0] : throw (
        "LEN != 1: " + s.len);

fn if_only(s: $T[]): $T
    s.len == 1 && s[0];

fn if_first(s: $T[]): $T
    s.len && s[0];

fn if_last(s: $T[]): $T
    s.len && s[s.len - 1];

fn hasIdentifierChars(id: string) {
    for (mut i = 0; i < id.len; i++)
    {
        let c = id[i];
        if (c == '_' || c >= 'a' && c <= 'z'
                     || c >= 'A' && c <= 'Z'
                     || c >= '0' && c <= '9')
        {
            return true;
        }
    }

    return false;
}

fn path_ext(path: string): string
{
    for (mut i = path.len; i --> 0; )
    {
        let c = path[i];
        if (c == '.') return path.slice(i);
        if (c == '/') break;
    }

    return "";
}

fn path_noext(path: string): string
{
    for (mut i = path.len; i --> 0; )
    {
        let c = path[i];
        if (c == '.') return path.slice(0, i);
        if (c == '/') break;
    }

    return "";
}

fn path_dirname(path: string): string
{
    for (mut i = path.len; i --> 0; )
        if (path[i] == '/')
            return path.slice(0, i + 1);

    return "";
}

fn path_filename(path: string): string
{
    for (mut i = path.len; i --> 0; )
        if (path[i] == '/')
            return path.slice(i + 1);

    return path;
}

fn path_normalize(p: string): string {
    mut path = p.split("/");

    for (mut i = path.len; i --> 0; ) {
        let part = path[i];
        if (part == "." || !part && i > 0 && i < path.len - 1)
            path.splice(i, 1);
    }

    for (mut i = 1; i < path.len; i++) {
        if (path[i] == "..")
            path.splice(--i, 2);
    }

    return path.join("/");
}

fn path_relative(from: string, to: string): string {
    let min = from.len < to.len ? from.len : to.len;

    mut same = 0;
    for (mut i = 0; i < min; i++) {
        let a = from[i];
        let b = to[i];

        if (b != a)
            break;

        if (b == '/')
            same = i + 1;
    }

    mut res: string;
    for (mut i = same; i < from.len; i++)
        if (from[i] == '/')
            res += "../";

    res += to.slice(same);
    return res;
}

fn path_join(a: string, b: string)
    b && b[0] == '/'    ? path_normalize(b)
                        : path_normalize(a + '/' + b);

fn ascii_lower(a: string): string
{
    let lower = 'a'.i32 - 'A'.i32;

    for (mut i = 0; i < a.len; i++)
    {
        let c = a[i];
        if (c >= 'A' && c <= 'Z')
        {
            mut b = a.slice(0, i) + byte(c.i32 + lower);
            for (mut j = i + 1; j < a.len; i++)
            {
                mut c = a[j];
                if (c >= 'A' && c <= 'Z')
                    c = byte(c.i32 + lower);

                b += c;
            }

            return b;
        }
    }

    return a;
}
