#import "helpers";
#import "parser";
#import "types";
#import "scope";
#import "solver";

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_CLOSURE           = 1 << 5;
let M_FWDECL            = 1 << 6;


//

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    root: SolvedNode, scope: Scope): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);
    mut _ffwd: Map(string, string);
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string = "\n";
    mut _fnN: i32;
    mut _clsrN: i32;
    mut _faasN: i32;
    mut _hasMain: i32;
    mut _isModuleSpecs: i32;

    fn GET(
        implicit module: Module,
        implicit ctx: Context,
        target: Target): Overload
    {
        target.index > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn fail(reason = "") throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = "#include " + lib + "\n";
    }


    //

    fn typeAnnot(value: ValueType): string
        typeAnnot(Type(:value));

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        let fwd = typeAnnotBase(type);

        if (mode & M_RETVAL && type.canon == "never" && !(mode & M_CLOSURE))
            return "[[noreturn]] " + fwd;

        if (type.quals & q_ref)
        {
            if (fwd.starts(with: "fu::view"))
                return fwd;

            if (type.quals & q_mutref)
                return fwd + "&";

            // Pass primitives by value.
            if (type.quals & q_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " + fwd
                     : fwd;

            return "const " + fwd + "&";
        }

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return "const " + fwd;

        if ((mode & M_ARGUMENT) && !(type.quals & q_primitive))
            return fwd + "&&";

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (type.quals & q_primitive)
        {
            // Avoid #include noise when possible.
            if (c == "i32")     return "int";
            if (c == "i16")     return "short";

            if (c == "bool")    return "bool";

            if (c == "f32")     return "float";
            if (c == "f64")     return "double";

            // Tough luck.
            include("<cstdint>");

            if (c ==  "i8")     return "int8_t";
            if (c == "i64")     return "int64_t";

            if (c ==  "u8")     return "uint8_t";
            if (c == "u16")     return "uint16_t";
            if (c == "u32")     return "uint32_t";
            if (c == "u64")     return "uint64_t";

            if (c == "byte")    return "std::byte";

            fail("Unknown primitive.");
        }

        if (c == "void")   return "void";
        if (c == "never")  return annotateNever();

        // Arrays & strings.
        let arrayItem = tryClear_array(type);
        if (arrayItem)
        {
            if (arrayItem.value == t_byte.value)
                return annotateString();

            let itemAnnot = typeAnnot(arrayItem);

            include("<fu/vec.h>");
            return "fu_VEC<" + itemAnnot + ">";
        }

        let sliceItem = tryClear_slice(type);
        if (sliceItem)
        {
            let itemAnnot = typeAnnot(sliceItem);

            include("<fu/view.h>");
            if (type.quals & q_mutref)
                return "fu::view_mut<" + itemAnnot + ">";
            else
                return "fu::view<" + itemAnnot + ">";
        }

        let mapPair = tryClear_map(type);
        if (mapPair)
        {
            let k = typeAnnot(mapPair.key);
            let v = typeAnnot(mapPair.value);

            include("<fu/map.h>");
            return "fu_COW_MAP<" + k + ", " + v + ">";
        }

        //
        let tdef = lookupStruct(type) || fail("TODO: " + type.canon);
        let id   = structId(type);

        if (!_tfwd.has(c))
        {
            _tfwd[c] = "\nstruct " + id + ";";
            _tdef += declareStruct(type, tdef);
        }

        return id;
    }

    fn structId(t: Type): string
    {
        for (mut i = 0; i < t.canon.len; i++)
        {
            let x = t.canon[i];
            if (x >= 'a' && x <= 'z' ||
                x >= 'A' && x <= 'Z' ||
                x == '_')
            {
                return "s_" + t.canon.slice(i);
                break;
            }
        }

        fail("Bad structId: `" + t.canon + "`.");
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        let id = structId(t);

        mut def = "\n                                #ifndef DEF_" + id
                + "\n                                #define DEF_" + id
                + "\nstruct " + id + "\n{";

        mut indent = "\n    ";

        if (s.flags & F_DESTRUCTOR)
        {
            def += "\n    struct Data\n    {";
            indent += "    ";
        }

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def += indent + typeAnnot(field.type) + " " + ID(field.id) + ";";
        }

        if (s.flags & F_DESTRUCTOR)
        {
            def += "\n    };";
            def += "\n";
            def += "\n    Data data;";
            def += "\n    bool dtor = false;";
            def += "\n";
            def += "\n    ~" + id + "() noexcept;";
            def += "\n    inline " + id + "(Data data) noexcept : data(data) {};";
            def += "\n    " + id + "(const " + id + "&) = delete;";
            def += "\n    " + id + "& operator=(const " + id + "&) = delete;";
            def += "\n    " + id + "(" + id + "&&) noexcept;";
            def += "\n    " + id + "& operator=(" + id + "&&) noexcept;";
        }

        def += "\n    explicit operator bool() const noexcept";
        def += "\n    {";
        def += "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            def += "\n            || "
                + (s.flags & F_DESTRUCTOR ? "data." : "")
                + ID(fields[i].id);

        def += "\n        ;";
        def += "\n    }";

        return def + "\n};\n                                #endif\n";
    }


    //

    fn collectDedupes(
        dedupes: Map(string, string)): string
    {
        mut out = "";

        mut keys = dedupes.keys();
        keys.sort();

        for (mut i = 0; i < keys.len; i++)
            out += dedupes[keys[i]];

        return out;
    }

    fn cgSpecs(): void
    {
        /////////////////
        _isModuleSpecs++;
        /////////////////

        let specs = module.out.specs;
        let keys = specs.keys();
        for (mut i = 0; i < keys.len; i++)
        {
            // Prelude?
            let k = keys[i];
            if (k[0] == '0')
                continue;

            // Emit.
            let s = specs[k];
            if (s.target)
            {
                mut dedupe = "";
                for (mut i = 0; i < k.len; i++)
                {
                    let c = k[i];

                    if (c >= '0' && c <= '9' ||
                        c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')
                    {
                        dedupe += c;
                    }
                    else
                    {
                        dedupe += '_';
                    }
                }

                _fdef += "\n                                #ifndef DEFt_" + dedupe
                       + "\n                                #define DEFt_" + dedupe
                       + "\n" + cgNode(s)
                       + "\n                                #endif\n";
            }
        }

        /////////////////
        _isModuleSpecs--;
        /////////////////
    }

    fn cgRoot(root: SolvedNode): string
    {
        cgSpecs();
        let src    = cgStatements(root.items);
        let main   = cgMain();



        mut header = collectDedupes(_libs)
                   + collectDedupes(_tfwd)
                   + collectDedupes(_ffwd)
                   +               (_tdef)
                   + (_fdef && "\n#ifndef FU_NO_FDEFs\n"+ _fdef + "\n#endif\n")
                   ;

        return header + src + main;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        if (_hasMain != 2)
            return "\n\nint main() { return fu_MAIN(); }\n";

        // Main with cli args.
        annotateString();

        return "\n\nint main(int argc, char* argv[])"
            +  "\n{"
            +  "\n    fu_VEC<fu_STR> args;"
            +  "\n    args.reserve(argc);"
            +  "\n"
            +  "\n    for (int i = 0; i < argc; i++)"
            +  "\n        args.push(fu_TO_STR(argv[i]));"
            +  "\n"
            +  "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args));"
            +  "\n}\n";
    }


    //

    fn ID(id: string): string
    {
        if (id == "this")       return "tHis";
        if (id == "template")   return "tEmplate";
        if (id == "catch")      return "cAtch";
        if (id == "not")        return "nOt";
        if (id == "and")        return "aNd";
        if (id == "or")         return "oR";
        if (id == "int")        return "iNt";
        if (id == "char")       return "cHar";
        if (id == "short")      return "sHort";
        if (id == "long")       return "lOng";
        if (id == "signed")     return "sIgned";
        if (id == "unsigned")   return "uNsigned";
        if (id == "assert")     return "aSsert";

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = "";

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src += _indent + line + (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[], skipCurlies: bool = false): string
    {
        let indent0 = _indent;
        _indent += "    ";

        mut src = cgStatements(nodes);
        if (!skipCurlies || nodes.len != 1 || nodes[0].kind != "return" && nodes[0].kind != "call")
            src = indent0 + "{" + src + indent0 + "}";

        _indent = indent0;
        return src;
    }

    fn blockWrapSubstatement(node: SolvedNode): string
    {
        return node.kind != "block" ? blockWrap([ node ], true)
             : node.items.len == 1  ? blockWrapSubstatement(node.items[0])
                                    : cgBlock(node);
    }

    fn cgBlock(block: SolvedNode): string
    {
        return blockWrap(block.items);
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src += ", ";
            if (i < items.len - 1)
                src += "(void)";

            src += items[i];
        }

        return src + ")";
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let items   = fn.items;
        let ret     = items[items.len + FN_RET_BACK] || fail();
        let closure = !!_clsrN && (fn.flags & F_CLOSURE);

        let annot   = typeAnnot(
            ret.type || fail(),
            M_RETVAL | (closure ? M_CLOSURE : 0));

        mut id = fn.value;
        if (id == "main" && !closure)
        {
            _hasMain = fn.items.len + FN_ARGS_BACK ? 2 : 1;
            id = "fu_MAIN";
        }

        mut src = closure
                ? "const auto& " + id + " = [&]("
                : annot + " " + id + "(";

        if (!id.hasIdentifierChars)
            src = annot + " operator" + id + "(";

        if (_isModuleSpecs && !closure)
            src = "inline " + src;

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src += ", ";

            src += binding(items[i] || fail());
        }

        src += closure
             ? ") -> " + annot
             : ")";

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        let ffwdKey = target.modid + "#" + target.index;
        if (_ffwd.has(ffwdKey))
            return;

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let isOp    = !id.hasIdentifierChars;

        mut src = isOp
                ? "\n" + annot + " operator" + id + "("
                : "\n" + annot + " " + id + "(";

        let arg_t = overload.args;
        for (mut i = 0; i < arg_t.len; i++)
        {
            if (i)
                src += ", ";

            src += typeAnnot(arg_t[i], M_ARGUMENT | M_FWDECL);
        }

        src += ");";
        _ffwd[ffwdKey] = src;

        return;
    }


    // This barely works unless it doesn't.

    fn try_cgFnAsStruct(fn: SolvedNode): string
    {
        let body = fn.items[fn.items.len + FN_BODY_BACK];
        if (!body || body.kind != "block")
            return "";

        let items = body.items;

        // We need at least one closure
        //  in the function "header"
        //   for all of this to make sense.
        mut hasClosuresInHeader = false;
        mut end = 0;
        for (mut i = 0; i < items.len; i++)
        {
            end = i;

            let item = items[i];
            if (item.kind == "fn")
            {
                if (item.flags & F_CLOSURE)
                    hasClosuresInHeader = true;
            }
            else if (item.kind != "let" && item.kind != "struct")
            {
                break;
            }
        }

        if (!hasClosuresInHeader)
            return "";

        // Ok - refactor time.
        let evalName = fn.value + "_EVAL";

        let restFn = SolvedNode(

            kind: "fn", type: t_void,
            flags: fn.flags | F_CLOSURE,
            token: fn.token,
            value: evalName,

            items:
            [
                fn.items[fn.items.len - 2], // retval
                SolvedNode(
                    kind: "block", type: t_void,
                    token: fn.token,
                    items: items.slice(
                        end, items.len)),
            ]);

        let head: SolvedNode[] =
            fn.items.slice(0, fn.items.len + FN_ARGS_BACK)
                + items.slice(0, end)
                + [ restFn ];

        //////////////////////
        _clsrN == 0 || fail();
        _clsrN--; // -1, so root closures come up at 0.
        //////////////////////

        let structName = "sf_" + fn.value;
        mut src = "\nnamespace {\n\nstruct " + structName
                + blockWrap(head) + ";\n";

        //////////////////////
        {
            mut args: string[];

            for (mut i = 0; i < fn.items.len + FN_ARGS_BACK; i++)
            {
                let argNode = fn.items[i];
                let argType = argNode.type;
                let arg     = argNode.value;

                args.push(
                    argType.quals & q_ref
                        ? arg
                        : cgSteal(arg));
            }

            src += "\n} // namespace\n\n";
            src += cgFnSignature(fn);
            src += "\n{\n    return (" + structName + " { " + args.join(", ") + " })." + evalName + "();\n}\n\n";
        }

        if (_fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        //////////////////////
        _clsrN++;
        //////////////////////

        return src;
    }


    //

    fn cgFn(fn: SolvedNode): string
    {
        // Template? TODO FIX dunno why this is how we tell, looks terrible.
        if (!fn.items.len)
            return "";

        // Use like-struct output for top-level functions with closures -
        //  We'll try to "close over" a root-level struct.
        if (_faasN == 0 && (fn.flags & F_HAS_CLOSURE))
        {
            /////////
            _faasN++;
            /////////

            let src = try_cgFnAsStruct(fn);

            /////////
            _faasN--;
            /////////

            if (src)
            {
                _fdef += src;
                return "";
            }
        }

        ///////////////////////////
        let f0 = _fnN;
        let c0 = _clsrN;
        let indent0 = _indent;

        _fnN++;
        if (fn.flags & F_CLOSURE) _clsrN++;
        ///////////////////////////

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK] || fail();

        // Both closures and try_cgFnAsStruct
        if (!(fn.flags & F_CLOSURE))
            _indent = "\n";

        mut src = cgFnSignature(fn);
        if (!(fn.flags & F_CLOSURE) && _fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        if (body.kind == "block")
            src += cgBlock(body);
        else
            src += blockWrap([ body ]);

        //////////////
        _fnN    = f0;
        _clsrN  = c0;
        _indent = indent0;
        //////////////

        if (fn.flags & F_DESTRUCTOR)
        {
            let head = items[0] || fail();
            let id = structId(head.type);

            src += "\n\n" + id + "::~" + id + "() noexcept";
            src += "\n{";
            src += "\n    if (!dtor)";
            src += "\n    {";
            src += "\n        dtor = true;";
            src += "\n        free(*this);";
            src += "\n    }";
            src += "\n}";

            include("<cassert>");
            include("<utility>");

            src += "\n\n" + id + "::" + id + "(" + id + "&& src) noexcept";
            src += "\n    : data(std::move(src.data))";
            src += "\n{";
            src += "\n    assert(!src.dtor);";
            src += "\n    dtor = src.dtor;";
            src += "\n    src.dtor = true;";
            src += "\n}";

            include("<cstring>");

            src += "\n\n" + id + "& " + id + "::operator=(" + id + "&& src) noexcept";
            src += "\n{";
            src += "\n    char temp[sizeof(" + id + ")];";
            src += "\n    char* a = (char*) this;";
            src += "\n    char* b = (char*) &src;";
            src += "\n";
            src += "\n    std::memcpy (temp, a, sizeof(" + id + "));";
            src += "\n    std::memmove(a,    b, sizeof(" + id + "));";
            src += "\n    std::memcpy (b, temp, sizeof(" + id + "));";
            src += "\n";
            src += "\n    return *this;";
            src += "\n}";
        }

        // This covers both closures & try_cgTryFnAsStruct:
        if (fn.flags & F_CLOSURE || _isModuleSpecs)
            return src;

        _fdef += "\n" + src + "\n";
        return "";
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        let id    = node.value || fail();
        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        let head  = (annot || fail()) + " " + ID(id);
        let init  = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == "copy" && !(node.type.quals & q_ref))
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_primitive)
                    return head + " = " + expr;

                return head + " { " + expr + " }";
            }

            // Definit.
            if (init.kind == "definit"
                    && !(init.type.quals & q_ref)
                    && init.type.value == node.type.value)
            {
                return head + " {}";
            }

            return head + " = " + cgNode(init);
        }

        return head + " {}";
    }

    fn cgLet(node: SolvedNode): string
    {
        return binding(node, doInit: true);
    }

    fn cgGlobal(node: SolvedNode): string
    {
        mut src = cgLet(node);

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.replace(
            all: "([&](", with: "([](");

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        //
        _fdef  += "\n                                #ifndef DEF_" + node.value
                + "\n                                #define DEF_" + node.value
                + "\ninline const " + src + ";"
                + "\n                                #endif\n";

        return "";
    }

    fn cgForeignGlobal(target: Target): void
    {
        let key = target.modid + "#" + target.index;
        if (_ffwd.has(key))
            return;

        _ffwd[key] = "";
        let o = GET(target);
        cgGlobal(o.constant);
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type.is_never)
                return src;

            return "return " + src;
        }

        return "return";
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return "goto L_" + node.value + "_" + node.kind[0];

        return node.kind;
    }


    // TODO FIX BOTH

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc += "\\n";
            else if (c == '\r') esc += "\\r";
            else if (c == '\t') esc += "\\t";
            else if (c == '\v') esc += "\\v";
            else if (c == '\\') esc += "\\\\";
            else if (c == '"')  esc += "\\\"";

            else                esc += c;
        }

        return "\"" + esc + "\"_fu";
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc += "\\n";
            else if (c == '\r') esc += "\\r";
            else if (c == '\t') esc += "\\t";
            else if (c == '\v') esc += "\\v";
            else if (c == '\\') esc += "\\\\";
            else if (c == '\'') esc += "\\'";

            else                esc += c;
        }

        return "std::byte('" + esc + "')";
    }


    //

    fn cgArrayLiteral(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot + " { " + arrayAnnot
            + "::INIT<" + items.len + "> { "
                + items.join(", ") + " } }";
    }

    fn cgDefaultInit(node: SolvedNode): string
    {
        return cgArrayLiteral(node);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();
        mut items  = cgNodes(node.items);

        // Builtin specs.
        if (target.kind == "__native" && target.template.node.items)
        {
            mut id = target.template.node.items[0].value;
            if (id[0] == '<')
            {
                include(id);
                id = target.template.node.items[1].value;
            }

            if (id[0] == '.')
            {
                if (items.len > 1)
                    return items[0] + id + "(" + items.slice(1).join(", ") + ")";

                return items[0] + id;
            }

            if (items)
            {
                if (id.hasIdentifierChars)
                    return id + "(" + items.join(", ") + ")";

                return "(" + items[0] + " " + id + " " + items[1] + ")";
            }

            return id;
        }

        //
        if (target.kind == "defctor")
        {
            let head = (target.type || fail());
            let type = lookupStruct(head) || fail();
            let id = structId(head);

            //
            mut open = " { ";
            mut close = " }";
            if (type.flags & F_DESTRUCTOR)
            {
                open = " { " + id + "::Data { ";
                close = " }}";
            }

            return id + open + items.join(", ") + close;
        }

        let id = target.name || fail();

        if (target.kind == "global")
        {
            if (node.target.modid != module.modid)
                cgForeignGlobal(node.target);

            return ID(id); // TODO ensure const emit.
        }

        if (target.kind == "var" ||
            target.kind == "arg" ||
            target.kind == "ref")
        {
            return ID(id);
        }

        if (target.kind == "field")
        {
            mut sep = ".";
            let parent = lookupStruct(node.items[0].type);
            if (parent.flags & F_DESTRUCTOR)
                sep = ".data.";

            return items[0] + sep + ID(id);
        }

        if (node.target.modid && node.target.modid != module.modid)
            ensureFwdDecl(node.target);

        if (hasNonIdentifierChars(id))
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? items[0] + id
                     : id + items[0];
            }

            if (items.len == 2)
            {
                if (id == "[]")
                {
                    // The new cow_vec is here.
                    if (node.type.quals & q_mutref)
                        return items[0] + ".mutref(" + items[1] + ")";

                    return items[0] + "[" + items[1] + "]";
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == "=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return "(" + cgNode(head.items[0] || fail()) +
                                ".upsert(" + cgNode(head.items[1] || fail()) + ") = " +
                                    items[1] + ")";
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == "||=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            items[0] = cgNode(head.items[0] || fail()) +
                                ".upsert(" + cgNode(head.items[1] || fail()) + ")";
                    }

                    let annot = typeAnnot(head.type);

                    return "([&](" + annot + " _) -> " + annot
                         + " { if (!_) _ = " + items[1]
                         + "; return _; } (" + items[0] + "))";
                }

                // Collapse (a += b + c) into (a += b, a += c),
                //  totally surprised at how little if any impact this has.
                if (id == "+=")
                    if (type_isArray(head.type) && isFieldChain(node.items[0]))
                        if (node.items[1].value == "+" && node.items[1].type.canon == head.type.canon)
                            return cgAppend(node, items[0]);

                // Skip some of the ridiculous parens.
                if (mode & M_STMT)
                    return items[0] + " " + id + " " + items[1];
                else
                    return "(" + items[0] + " " + id + " " + items[1] + ")";
            }
        }

        if (id == "CLONE" && items.len == 1)
            return cgClone(node.type, items[0]);

        if (id == "STEAL" && items.len == 1)
            return cgSteal(items[0]);

        if (id == "SWAP" && items.len == 2)
            return cgSwap(items);

        if (id == "println")
            return cgPrint(items);

        id != "__native" || assert();

        return ID(id) + "(" + items.join(", ") + ")";
    }

    fn cgAppend(node: SolvedNode, into: string): string
    {
        mut src = "(";
        cgAppend_visit(node.type.canon, into, node.items[1], src);
        src += ")";

        return src;
    }

    fn cgAppend_visit(
        canon: string, into: string,
        stuff: SolvedNode, src: &mut string)
    {
        if (stuff.kind != "call" || stuff.value != "+" || stuff.type.canon != canon || stuff.items.len != 2)
        {
            let val = cgNode(stuff);
            if (src.len > 1)
                src += ", ";

            src += into + " += " + val;
        }
        else
        {
            cgAppend_visit(canon, into, stuff.items[0], src);
            cgAppend_visit(canon, into, stuff.items[1], src);
        }
    }

    fn cgPrint(items: string[]): string
    {
        include("<iostream>");

        mut src = "(std::cout";
        for (mut i = 0; i < items.len; i++)
            src += " << " + items[i];

        src += " << '\\n')";
        return src;
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn cgLiteral(node: SolvedNode): string
    {
        mut src = node.value;

        if (node.type.quals & q_unsigned)
            if (!src.has('u'))
                src += 'u';

        if (node.type.quals & q_floating_pt)
        {
            if (!src.has('.'))
                src += ".0";

            if (node.type.canon == "f32")
            {
                if (src.has('x'))
                    src = "float(" + src + ")";
                else
                    src += "f";
            }
            else if (node.type.canon != "f64")
            {
                assert();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        return src;
    }

    fn cgEmpty(): string
    {
        return "";
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(node: SolvedNode)
            node.kind == "if"
                ? " " + cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL);
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return "if (" + cond + ")" + cons + (alt ? _indent + "else" + alt : "");

        if (cons && alt)
            return "(" + cond + " ? " + cons + " : " + alt + ")";

        if (cons)
            return "(" + cond + " && " + cons + ")";

        if (alt)
            return "(" + cond + " || " + alt + ")";

        return fail("TODO");
    }


    //

    fn cgDefault(type: Type): string
    {
        type.quals & q_mutref && fail("Cannot definit mutrefs.");

        if (type.quals & q_ref)
        {
            include("<fu/default.h>");

            return "fu::Default<" + typeAnnot(clear_refs(type)) + ">::value";
        }

        return typeAnnot(type) + "{}";
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (!type.is_bool)
        {
            let items = node.items;

            let retSecondLast = items[items.len - 1].type.is_never;

            let condEnd = retSecondLast
                        ? items.len - 2
                        : items.len - 1;

            mut src = "";

            if (condEnd)
            {
                src += "if (";

                for (mut i = 0; i < condEnd; i++)
                {
                    let item = items[i];
                    if (i) src += " && ";
                    src += cgNode(item, M_RETBOOL);
                }

                src += ") ";
            }

            let tail = cgNode(items[condEnd]);

            if (retSecondLast)
            {
                src += "{ " + typeAnnot(type) + " _ = " + tail + "; ";
                src += "if (!_) return _; } ";
                src += cgNode(items[items.len - 1]) + ";"; //FAIL
            }
            else
            {
                src += "return " + tail + ";"; //TRUTHY
                src += " else return " + cgDefault(type) + ";";
            }

            src = "([&]() -> " + typeAnnot(type) + " { " + src + " }())";

            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];

            if (i) src += " && ";
            src += cgNode(item, M_RETBOOL);
        }

        return src + ")";
    }

    fn cgNot(node: SolvedNode): string
    {
        let item = node.items[0];
        return "!" + cgNode(item, M_RETBOOL);
    }

    fn cgOr(node: SolvedNode): string
    {
        let type = node.type;
        if (!type.is_bool)
        {
            // Try a ?: chain.
            mut ternary = true;
            for (mut i = 0; i < node.items.len - 1; i++)
            {
                if (!isFieldChain(node.items[i]))
                {
                    ternary = false;
                    break;
                }

                if (ternary)
                {
                    mut src = "(";
                    for (mut i = 0; i < node.items.len - 1; i++)
                    {
                        let n = node.items[i];
                        let item = cgNode(n);
                        src += item + " ? " + item + " : ";
                    }

                    src += cgNode(node.items[node.items.len - 1]) + ")";
                    return src;
                }
            }

            //
            let annot = typeAnnot(type);

            mut src = "([&]() -> " + annot + " {";

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src += " if (";
                    for (mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src += " && ";

                        let item = items[i] || fail();
                        src += cgNode(item, M_RETBOOL);
                    }

                    src += ")";
                }

                src += " { " + annot + " _ = " + cgNode(tail) + "; if (_) return _; }";
            }

            let tail = items[items.len - 1] || fail();
            if (!tail.type.is_never)
                src += " return";

            src += " " + cgNode(tail) + "; }())";
            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (i) src += " || ";
            src += cgNode(item, M_RETBOOL);
        }

        return src + ")";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var"     ||
            t.kind == "global"  ||
            t.kind == "arg"     ||
            t.kind == "ref")
        {
            return true;
        }

        return false;
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == '}' || fail();
        return src.slice(0, src.len - 1) + postfix + '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = n_init && cgNode(n_init);
        let cond = n_cond && cgNode(n_cond, M_RETBOOL);
        let post = n_post && cgNode(n_post);
        mut body = n_body && blockWrapSubstatement(n_body);
        let pcnd = n_pcnd && cgNode(n_pcnd, M_RETBOOL);
        mut breakLabel = "";

        if (body && node.value)
        {
            let brk = "L_" + node.value + "_b";
            let cnt = "L_" + node.value + "_c";

            if (body.has(cnt))
                body = "{" + postfixBlock(body, _indent +     "    }" + cnt + ":;");
            if (body.has(brk))
                breakLabel = _indent + "    " + brk + ":;";
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" + body + _indent + "while (" + pcnd + ")" + breakLabel;
        }

        if (init || post || !cond)
            return "for (" + init + "; " + cond + "; " + post + ")" + body + breakLabel;

        return "while (" + cond + ")" + body + breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let let_main    = items[0];
        let let_init    = cgNode(items[0].items[LET_INIT]);
        let err_id      = items[1].value;
        let catch_body  = blockWrapSubstatement(items[2]);

        mut src =        binding(let_main, forceMut: true) + ";";
        src += _indent + "try";
        src += _indent + "{";
        src += _indent + "    " + let_main.value + " = " + let_init + ";";
        src += _indent + "}";
        src += _indent + "catch (const std::exception& o_0)";
        src += _indent + "{";
        src += _indent + "    const " + annotateString() + "& " + err_id + " = fu_TO_STR(o_0.what());";
        src += _indent + catch_body;
        src += _indent + "}\n";

        return src;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node);
        if (k == "fn")          return cgFn(node);
        if (k == "return")      return cgReturn(node);
        if (k == "break")       return cgJump(node);
        if (k == "continue")    return cgJump(node);
        if (k == "call")        return cgCall(node, mode);
        if (k == "let")         return cgLet(node);
        if (k == "global")      return cgGlobal(node);
        if (k == "if")          return cgIf(node, mode);
        if (k == "!")           return cgNot(node);
        if (k == "or")          return cgOr(node);
        if (k == "and")         return cgAnd(node);
        if (k == "loop")        return cgLoop(node);
        if (k == "int")         return cgLiteral(node);
        if (k == "num")         return cgLiteral(node);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node);
        if (k == "definit")     return cgDefaultInit(node);
        if (k == "empty")       return cgEmpty();

        if (k == "comma")       return cgParens(node);
        if (k == "parens")      return cgParens(node);
        if (k == "label")       return cgParens(node);
        if (k == "struct")      return cgEmpty();

        if (k == "copy")        return cgCopyMove(node);
        if (k == "move")        return cgCopyMove(node);
        if (k == "nrvo")        return cgCopyMove(node);
        if (k == "catch")       return cgCatch(node);

        return fail("TODO: " + k);
    }


    //

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == "nrvo")
            return a;

        if (node.kind == "move")
            return cgSteal(a);

        return cgClone(node.type, a);
    }

    fn cgSteal(src: string): string
    {
        include("<utility>");
        return "std::move(" + src + ")";
    }

    fn cgSwap(items: string[]): string
    {
        include("<utility>");
        return "std::swap(" + items.join(", ") + ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) + "(" + src + ")";
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        for (mut i = 0; i < nodes.len; i++)
        {
            let node  = nodes[i];
            let src   = node ? cgNode(node, mode) : "";

            result.push(src);
        }

        return result;
    }


    //

    root.kind == "root" || fail();

    let src = cgNode(root);
    return src || "\n";
}
