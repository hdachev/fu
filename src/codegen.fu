import helpers;
import parser;
import types;
import scope;
import context;
import bitset;
import cpp;

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_RETURN            = 1 << 5;
let M_FWDECL            = 1 << 6;
let M_PARENS            = 1 << 7;
let M_OPT_CURLIES       = 1 << 8;
let M_LOOP_BODY         = 1 << 9;


//

type BitSet2D = bitset::BitSet[];

fn add_once(ref bs: BitSet2D, target: Target): bool
{
    return bs
        .grow_if_oob(target.modid)
        .add_once(target.index);
}

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    root: SolvedNode): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);

    mut _ffwd: BitSet2D;
    mut _ffwd_src: string[];

    mut _idef: bitset::BitSet;
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string = "\n";
    mut _hasMain: i32;

    struct cg_Blockval
    {
        index: i32;
        ptrflip: bool;
    };

    struct cg_CurrentFn // TODO FIX postfix/prefix non-pub symbols?
    {                   //  Or prefix structs with module name?
        using target:   Target;
        dupes?:         BitSet;

        numTEMPVARs?:   i32;
        TEMPVARs?:      string[];

        blockvals?:     cg_Blockval[];

        can_break?:     i32;
        can_cont?:      i32;
    };

    struct TEMPVAR { annot?: string; id?: string; ptrflip?: bool; };

    mut _current_fn: cg_CurrentFn;

    fn GET(target: Target): Overload
    {
        target.index > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn try_GET(target: Target): Overload
    {
        return target && GET(target);
    }

    fn fail(reason = "") throw(reason);

    fn left (target: Target) target.modid;
    fn right(target: Target) target.index;


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = "#include " ~ lib ~ "\n";
    }


    //

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        if (mode & M_ARGUMENT && type.addroffn::type_isZST)
            return "int";

        let fwd = typeAnnotBase(type);

        if (type.is_ref)
        {
            if (fwd.starts(with: "fu::view"))
                return fwd;

            if (type.is_mutref)
                return fwd ~ "&";

            // Pass primitives by value.
            if (type.quals & q_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " ~ fwd
                     : fwd;

            // Enable move from local.
            //
            //  let a = ...     // Some a = ...
            //  let b = a.b;    // B& b = a.b;      // const B& wouldn't allow move
            //  return b;       // return move(b);  // here
            //
            if (!(type.quals & q_trivial) && !(mode & M_ARGUMENT)
                && type.lifetime.Lifetime_compareToIndex(_current_fn.index) > 0
                && _current_fn.modid == module.modid)
            {
                // TODO only do this when strictly useful, weakens our validation.
                //
                // Only useful if current fn returns a nontriv value.
                //  We could notice current fn does a move-return.
                //   Ideally we would actually know the dependecy chain
                //    so we'll only do this if really needed for this variable.
                //
                // TODO Tracking ref use and 'moved-from'-ness.
                //
                let fnret = GET(Target(:module.modid, index: _current_fn.index)).type;
                if !(fnret.quals & q_trivial || fnret.is_ref)
                    return fwd ~ "&";
            }

            return "const " ~ fwd ~ "&";
        }

        if ((mode & M_ARGUMENT) && !(type.quals & q_primitive))
            return fwd ~ "&&";

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return "const " ~ fwd;

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (type.quals & q_primitive)
        {
            // Avoid #include noise when possible.
            if (c == "i32")     return "int";
            if (c == "i16")     return "short";

            if (c == "bool")    return "bool";

            if (c == "f32")     return "float";
            if (c == "f64")     return "double";

            // Tough luck.
            include("<cstdint>");

            if (c ==  "i8")     return "int8_t";
            if (c == "i64")     return "int64_t";

            if (c ==  "u8")     return "uint8_t";
            if (c == "u16")     return "uint16_t";
            if (c == "u32")     return "uint32_t";
            if (c == "u64")     return "uint64_t";

            if (c == "byte")    return "std::byte";

            fail("Unknown primitive.");
        }

        if (c == "void")   return "void";
        if (c == "never")  return annotateNever();

        // Arrays & strings.
        let arrayItem = tryClear_array(type);
        if (arrayItem)
        {
            if (arrayItem == t_byte)
                return annotateString();

            let itemAnnot = typeAnnot(arrayItem);

            include("<fu/vec.h>");
            return "fu_VEC<" ~ itemAnnot ~ ">";
        }

        // TODO FIX slice definit - (arg?: [byte]) somehow manages to drop ref on definit.
        let sliceItem = tryClear_sliceable(type);
        if (sliceItem)
        {
            let itemAnnot = typeAnnot(sliceItem);

            include("<fu/view.h>");
            if (type.is_mutref)
                return "fu::view_mut<" ~ itemAnnot ~ ">";
            else
                return "fu::view<" ~ itemAnnot ~ ">";
        }

        let mapPair = tryClear_map(type);
        if (mapPair)
        {
            let k = typeAnnot(mapPair.key);
            let v = typeAnnot(mapPair.value);

            include("<fu/map.h>");
            return "fu_MAP<" ~ k ~ ", " ~ v ~ ">";
        }

        //
        let tdef = lookupStruct(type) || fail("TODO: " ~ type.canon);
        let id   = structId(type);

        if (!_tfwd.has(c))
        {
            _tfwd[c] = "struct " ~ id ~ ";\n";
            _tdef ~= declareStruct(type, tdef);
        }

        return id;
    }

    fn structId(t: Type): string
    {
        for (mut i = 0; i < t.canon.len; i++)
        {
            let x = t.canon[i];
            if (x >= 'a' && x <= 'z' ||
                x >= 'A' && x <= 'Z' ||
                x == '_')
            {
                return "s_" ~ t.canon.slice(i);
                break;
            }
        }

        fail("Bad structId: `" ~ t.canon ~ "`.");
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        let id = structId(t);

        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id
                ~ "\nstruct " ~ id ~ "\n{";

        mut indent = "\n    ";

        let fields = s.items;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = GET(fields[i].target);
            field.kind == "field" || fail("Non-field struct item: " ~ field.name ~ " (" ~ field.kind ~ ") in " ~ t.canon);
            def ~= indent ~ typeAnnot(field.type) ~ " " ~ ID(field.name) ~ ";";
        }

        if !(t.quals & q_rx_copy)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
        }
        else if (try_GET(s.target).status & SS_TYPE_RECUR)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = default;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "& selfrec) { return *this = " ~ id ~ "(selfrec); }";
        }

        def ~= "\n    explicit operator bool() const noexcept";
        def ~= "\n    {";
        def ~= "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            def ~= "\n            || " ~ ID(fields[i].id);

        def ~= "\n        ;";
        def ~= "\n    }";

        return def ~ "\n};\n                                #endif\n";
    }


    //

    fn collectDedupes(dedupes: Map(string, string), leadingNewline?: bool): string
    {
        return collectDedupes(:dedupes.values, :leadingNewline);
    }

    fn collectDedupes(mut values: string[], leadingNewline?: bool): string
    {
        if (!values.len)
            return "";

        mut out = leadingNewline ? "\n" : "";

        values.sort();
        for (mut i = 0; i < values.len; i++)
            out ~= values[i];

        return out;
    }

    fn valid_operator(str: string): string
    {
        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_')
            {
                return str.slice(0, i);
            }
        }

        return str;
    }

    fn valid_identifier(mut str: string): string
    {
        for (mut i = str.len; i --> 0; )
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_') continue;

            shadow let c = c.u32;
            let b0 = (c >> 0) & 0xf;
            let b1 = (c >> 4) & 0xf;

            fn hex(x: u32)
                x < 10 ? ('0'.u32 + x).byte
                       : ('A'.u32 + x).byte;

            str = str[0, i]
                ~ 'b' ~ b0.hex ~ b1.hex
                ~ str[i + 1, str.len];
        }

        return str;
    }

    fn cgRoot(shadow root: SolvedNode): string
    {
        mut count: i32;
        let src    = cgStatements(root.items, :count);
        let main   = cgMain();

        let header = collectDedupes(_libs)
                   ~ collectDedupes(_tfwd, leadingNewline: true)
                   ~ collectDedupes(_ffwd_src, leadingNewline: true)
                   ~               (_tdef)
                   ~ (_fdef && "\n#ifndef FU_NO_FDEFs\n" ~ _fdef ~ "\n#endif\n")
                   ;

        return header ~ src ~ main;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        if (_hasMain != 2)
            return "\n\nint main() { return fu_MAIN(); }\n";

        // Main with cli args.
        annotateString();

        return "\n\nint main(int argc, char* argv[])"
            ~  "\n{"
            ~  "\n    fu_VEC<fu_STR> args;"
            ~  "\n    args.reserve(argc);"
            ~  "\n"
            ~  "\n    for (int i = 0; i < argc; i++)"
            ~  "\n        args.push(fu_TO_STR(argv[i]));"
            ~  "\n"
            ~  "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args));"
            ~  "\n}\n";
    }


    //

    fn localID(target: Target, overload: Overload)
    {
        let ok = ID(overload.name);
        if (target.modid == module.modid && overload.local_of == _current_fn.index)
            return ok;

        if (_current_fn.dupes.has(target.index))
            return ok ~ "_0" ~ target.index;

        return ok ~ "_0";
    }

    fn generateLocalID(target: Target, overload: Overload, ref seen: string[])
    {
        let ok = ID(overload.name);
        if (target.modid == module.modid && overload.local_of == _current_fn.index)
            return ok;

        if (!seen.set::add(ok))
        {
            _current_fn.dupes.add_once(target.index);
            return ok ~ "_0" ~ target.index;
        }

        return ok ~ "_0";
    }


    //

    fn cgStatements(nodes: SolvedNode[], ref count!: i32, trail?!: string): string
    {
        let lines = cgNodes(nodes, M_STMT, :trail);
        count = lines.len;

        mut src = "";
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src ~= (line.if_first == '\n' ? '\n' ~ line : _indent ~ line)
                     ~ (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn cgComma(nodes: SolvedNode[]): string
    {
        shadow let items = cgNodes(nodes);
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= ", ";
            if (i < items.len - 1)
                src ~= "(void)";

            src ~= items[i];
        }

        return src ~ ")";
    }


    //

    fn blockWrapSubstatement(node: SolvedNode, mode?: i32): string
        cgBlock(node, mode: M_STMT | M_OPT_CURLIES | mode);

    fn cgBlock(node: SolvedNode, mode: i32): string
    {
        let items = node.kind == "block"  ? node.items : [ node ];
        let label = node.kind == "block" && node.target;

        ///////////////////////////////////////////
        if (mode & M_LOOP_BODY)
            _current_fn.can_cont = label.index;
        ///////////////////////////////////////////

        // We'll try to avoid block expressions as much as we can.
        //  Instead of these loops it'd be nice if we knew all this stuff
        //   as node flags or something, or a jumpset or something:
        //      - if expressible as cpp expr (none of the below stuff),
        //      - if wrappable in a cpp lambda (no jumping up), etc.
        //
        fn exprOK(nodes: [SolvedNode])
        {
            for (mut i = 0; i < nodes.len; i++)
            {
                let n = nodes[i];
                let k = n.kind;
                if (k == "jump" || k == "loop" || k == "try" || k == "catch"
                    || k == "let" || k == "block") // TODO FIX we can handle both of these
                {
                    return false;
                }

                if (k == "and" || k == "or" || k == "if")
                    if (!n.items.exprOK)
                        return false;
            }

            return true;
        }

        mut expr = !(mode & M_STMT);
        if (expr && !label && items.exprOK)
            return cgComma(items);

        //
        return cgBlock(items, skipCurlies: !!(mode & M_OPT_CURLIES), gnuStmtExpr: expr, :label,
            type: expr && node.type);
    }

    fn cgBlock(nodes: SolvedNode[], skipCurlies!: bool, gnuStmtExpr!: bool, label!: Target, type: Type): string
    {
        let indent0 = _indent;
        _indent ~= "    ";

        let gnuOpen = gnuStmtExpr && "(__extension__ (";
        mut open    = "{";
        mut close   = gnuStmtExpr ? "}))" : "}";
        mut trail   = "";

        let lbl     = label && GET(label);
        let name    = lbl.name;

        // Blockvals! /////////////////////////////////
        let blockvals0  = _current_fn.blockvals.len;
        defer _current_fn.blockvals.shrink(blockvals0);
        ///////////////////////////////////////////////

        if (type && !type.is_void)
        {
            mut ptrflip = false;
            let annot   = typeAnnot(type);
            let id      = emitTEMPVAR(annot, :ptrflip, name && "L_" ~ name ~ "_v");

            // Blockvals! //////////////////////////////////////////////
            _current_fn.blockvals ~= cg_Blockval(:label.index, ptrflip);
            ////////////////////////////////////////////////////////////

            let out     = ptrflip ? "*" ~ id : cgMove(:type, id);
            close       = "}), " ~ out ~ ")";

            trail       = id ~ " = ";
            if (ptrflip)
                trail  ~= "&";
        }

        //
        mut count: i32;
        mut src = cgStatements(nodes, :count, :trail);

        // Block label & retval.
        if (lbl.name)
        {
            let prefixed_id = "L_" ~ name;
            if (src.has("goto " ~ prefixed_id ~ ";")) // TODO FIX track label usage
            {
                close = "  } " ~ prefixed_id ~ ":;" ~ indent0 ~ close;
                open  = "{ {";
            }
        }

        //
        if (!skipCurlies || nodes.len != 1 || count != 1 || nodes[0].kind != "jump" && nodes[0].kind != "call")
            src = gnuOpen ~ indent0 ~ open ~ src ~ indent0 ~ close;

        _indent = indent0;
        return src;
    }

    fn cgDefer(node: SolvedNode): string
    {
        include("<fu/defer.h>");

        let which = node.value == "err" ? "fu_DEFER_IF_ERR"
                  : node.value == "ok"  ? "fu_DEFER_IF_OK"
                                        : "fu_DEFER";

        return which ~ "(" ~ cgNode(node.items.only, M_STMT) ~ ")";
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let overload = GET(fn.target);

        let items = fn.items;
        let annot = typeAnnot(overload.type || fail(), M_RETVAL);

        mut id = overload.name;
        if (id == "main") {
            _hasMain = fn.items.len + FN_ARGS_BACK ? 2 : 1;
            id = "fu_MAIN";
        }
        else if (overload.flags & F_OPERATOR) {
            id = "operator" ~ id.valid_operator;
        }

        let linkage = (overload.type.is_never  && "[[noreturn]] ")
                    ~ (  fn.flags & F_TEMPLATE && "inline ")
                    ~ (!(fn.flags & F_PUB)     && "static ");

        mut src = linkage ~ annot ~ " " ~ id ~ "(";

        mut needComma = 0;

        // Ridiculous nonsense.
        {
            mut seen: string[] = [];

            for (mut i = 0; i < overload.closes_over.len; i++)
            {
                if (needComma++)
                    src ~= ", ";

                let t = Target(:module.modid, index: overload.closes_over[i]);
                let o = GET(t);
                src ~= typeAnnot(o.type) ~ " " ~ generateLocalID(t, o, seen);
            }
        }

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (needComma++)
                src ~= ", ";

            src ~= binding(items[i] || fail());
        }

        if (overload.flags & F_POSTFIX)
        {
            overload.flags & F_OPERATOR || assert();
            src ~= ", /*postfix*/int ";
        }

        src ~= ")";

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        if !(_ffwd.add_once(target))
            return;

        ////////////////////////////////////////////
        mut current_fn0 = cg_CurrentFn(target: target);

        defer SWAP(_current_fn, current_fn0);
        SWAP(_current_fn, current_fn0);
        ////////////////////////////////////////////

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let isOp    = overload.flags & F_OPERATOR;

        let name    = isOp ? "operator" ~ id.valid_operator : id;
        let linkage = (overload.type.is_never  && "[[noreturn]] ")
                    ~ (overload.flags & F_TEMPLATE && "inline ")
                  ~ (!(overload.flags & F_PUB)     && "static ");

        mut src = linkage ~ annot ~ " " ~ name ~ "(";

        mut needComma = 0;

        for (mut i = 0; i < overload.closes_over.len; i++)
        {
            if (needComma++)
                src ~= ", ";

            let o = GET(Target(
                modid: module.modid,
                index: overload.closes_over[i]));

            src ~= typeAnnot(o.type);
        }

        let args = overload.args;
        for (mut i = 0; i < args.len; i++)
        {
            if (needComma++)
                src ~= ", ";

            src ~= typeAnnot(args[i].type, M_ARGUMENT | M_FWDECL);
        }

        src ~= ");\n";

        _ffwd_src ~= src;

        return;
    }

    fn ensureFnDef(target: Target, overload: Overload)
    {
        target.modid == module.modid || fail(
            "ensureFnDef: fndef is needed outside of its original scope: "
                ~ target.modid ~ " vs " ~ module.modid ~ ": `"
                ~ overload.kind ~ " " ~ overload.name ~ "`.");

        if !(_idef.add_once(target.index))
            return;

        // Go!
        let node = overload.solved;
        node.kind == "fn" || fail("ensureFnDef non-fn");
        cgFn(node, M_STMT);
    }


    //

    fn cgFnDef(fndef: SolvedNode, mode: i32): string
    {
        let o = GET(fndef.target);
        let n = o.solved;
        if !(n.flags & F_PUB)
            return mode & M_STMT ? "" : "0";

        n.kind == "fn" || fail("cgFnDef non-fn");
        return cgFn(n, mode);
    }

    fn cgFn(fn: SolvedNode, mode: i32): string
    {
        //////////////////////
        let indent0 = _indent;
        //////////////////////

        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK];

        let overload = GET(fn.target);
        let id = overload.name;
        overload.status & SS_FINALIZED || fail("cgFn: fn not finalized: " ~ id);

        // Custom __natives.
        if (!body)
        {
            overload.kind == "__native" || fail("cgFn: no body on non-native: " ~ id);
            return mode & M_STMT ? "" : "0";
        }

        _indent = "\n";

        // TODO is this needed?
        //  Body should always be a block.
        mut src: string;
        {
            ////////////////////////////////////////////
            mut current_fn0 = cg_CurrentFn(target: fn.target);

            defer SWAP(_current_fn, current_fn0);
            SWAP(_current_fn, current_fn0);
            ////////////////////////////////////////////

            src ~= cgFnSignature(fn);
            src ~= cgBlock(body, M_STMT);
        }

        // Consider a fwdannot after outputting body,
        //  it could itself have written to _fdef.
        if (_fdef.has(id || fail()))
            ensureFwdDecl(fn.target);

        //////////////////
        _indent = indent0;
        //////////////////

        let dedupe = fn.flags & F_PUB
                  && fn.flags & F_TEMPLATE
                  && overload.name.valid_identifier;

        if (dedupe)
            _fdef ~= "\n                                #ifndef DEFt_" ~ dedupe
                   ~ "\n                                #define DEFt_" ~ dedupe;

        _fdef ~= "\n" ~ src ~ "\n";

        if (dedupe)
            _fdef ~= "                                #endif\n";

        return mode & M_STMT ? "" : "0";
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if !(_current_fn.index) SWAP(_tv0, _current_fn.TEMPVARs);
        defer {
            if !(_current_fn.index) SWAP(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        if (node.flags & F_ARG && node.type.addroffn::type_isZST)
            return annot;

        let overload = GET(node.target);
        let id = overload.name || fail();

        let head = (annot || fail()) ~ " " ~ ID(id);
        let init = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == "copy" && !node.type.is_ref)
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_primitive)
                    return head ~ " = " ~ expr;

                return head ~ " { " ~ expr ~ " }";
            }

            // Definit.
            if (init.kind == "definit" && !init.type.is_ref)
            {
                init.type == node.type || fail("what's this now");
                return head ~ " {}";
            }

            let expr = cgNode(init);

            // HACK - wrap in a lambda when we need temps here
            if (!_current_fn.index && _current_fn.TEMPVARs)
            {
                shadow let annot = annot.starts(with: "const ") ? annot.slice(6) : annot;
                shadow let init = " { []() -> " ~ annot ~ " {\n    " ~ _current_fn.TEMPVARs.join(";\n    ") ~ ";\n    return " ~ expr ~ ";\n}() }";
                _current_fn.TEMPVARs.clear();
                return head ~ init;
            }

            return head ~ " = " ~ expr;
        }

        return head ~ " {}";
    }

    fn cgLet(node: SolvedNode): string
    {
        if (node.type.addroffn::type_isZST)
            return "";

        mut src = binding(node, doInit: true);
        if !(node.flags & F_GLOBAL)
            return src;

        /////////////
        // Globals //
        /////////////

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        // Hide when possible.
        if (!(node.flags & F_PUB))
            _fdef  ~= "\nstatic const " ~ src ~ ";\n";
        else
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\ninline const " ~ src ~ ";"
                    ~ "\n                                #endif\n";

        return "";
    }

    fn cgForeignGlobal(target: Target): void
    {
        if !(_ffwd.add_once(target))
            return;

        let o = GET(target);
        cgLet(o.solved);
    }

    fn cgJump(node: SolvedNode): string
    {
        let dest_idx    = node.target.left;
        let expr_idx    = node.target.right;

        let use_return  = dest_idx == _current_fn.target.index;
        let dest        = GET(Target(:module.modid, dest_idx));

        if (expr_idx)
        {
            let o       = GET(Target(:module.modid, expr_idx));
            let head    = o.solved || fail();

            // This kinda does it for return non-expression.
            if (head.type.is_void && node.flags & F_SINGLE_STMT)
                return cgNode(head, M_STMT);

            // Break with value.
            if (!use_return)
            {
                mut hasval  = false;
                mut ptrflip = false;

                for (mut i = _current_fn.blockvals.len; i --> 0; )
                {
                    let bv = _current_fn.blockvals[i];
                    if (bv.index == dest_idx)
                    {
                        hasval = true;
                        ptrflip = bv.ptrflip;
                        break;
                    }
                }

                let assign = hasval && "L_" ~ dest.name ~ "_v = ";

                mut value = cgNode(head);
                if (ptrflip)
                    value = "&(" ~ value ~ ")";

                return "{ " ~ assign ~ value
                     ~ "; goto L_" ~ dest.name ~ "; }";
            }

            // [[noreturns]] shouldn't have return statements,
            //  but regular fns should return the output of [[noreturns]]
            //   for them to end on a return. It's a mess man.
            if (head.type.is_never)
            {
                if (dest.type.is_never)
                    return cgNode(head, M_STMT);

                if (dest.type.is_void)
                    return "return (void) " ~ cgNode(head, M_RETURN);
            }

            // I think the prefix keywords beat everything re: precedence.
            return "return " ~ cgNode(head, M_PARENS|M_RETURN);
        }

        //
        if (use_return)
            return "return";

        if (dest_idx == _current_fn.can_break)
            return "break";
        if (dest_idx == _current_fn.can_cont)
            return "continue";

        return "goto L_" ~ dest.name;
    }


    // TODO FIX BOTH

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

            if      (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";
            else if (c == '"')  esc ~= "\\\"";

            else                esc ~= c;
        }

        return "\"" ~ esc ~ "\"_fu";
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

            if      (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";
            else if (c == '\'') esc ~= "\\'";

            else                esc ~= c;
        }

        return "std::byte('" ~ esc ~ "')";
    }


    //

    fn cgArrayLiteral(node: SolvedNode, mode: i32): string
    {
        if (node.target)
            return cgCall(node, mode);

        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot ~ " { " ~ arrayAnnot
            ~ "::INIT<" ~ items.len ~ "> { "
                ~ items.join(", ") ~ " } }";
    }

    fn cgDefaultInit(node: SolvedNode, mode: i32): string
    {
        return cgArrayLiteral(node, mode);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn binSkipParens(id: string, mode: i32)
    {
        if (mode & M_STMT)
            return true;

        if (mode & M_PARENS)
        {
            if (id.last == '=')
            {
                // Clang errors on equality within parens in conditionals ...
                if (id == "==" || id == "!=")
                    return true;

                // ... and on naked equalities in conditionals.
                return false;
            }

            // Everything else is fine.
            return true;
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();

        mut _items: string[];
        let items = node.items;
        fn REST(start: i32 = 0)
        {
            mut src = "";
            for (mut i = start; i < items.len; i++)
            {
                if (i > start)
                    src ~= ", ";

                src ~= cgNode(items[i]);
            }

            return src;
        }

        fn ARG(i: i32) cgNode(items[i]);

        // Builtin specs.
        if (target.kind == "__native" && target.template.node.items)
        {
            mut id = target.template.node.items[0].value;
            if (target.template.node.items.len > 1)
            {
                include(id);
                id = target.template.node.items[1].value;
            }

            if (id[0] == '.')
            {
                if (items.len > 1)
                    return ARG(0) ~ id ~ "(" ~ REST(1) ~ ")";

                return ARG(0) ~ id;
            }

            if (items)
            {
                if (id.hasIdentifierChars)
                    return id ~ "(" ~ REST ~ ")";

                if (binSkipParens(id, mode))
                    return ARG(0) ~ " " ~ id ~ " " ~ ARG(1);

                return "(" ~ ARG(0) ~ " " ~ id ~ " " ~ ARG(1) ~ ")";
            }

            return id;
        }

        //
        if (target.kind == "type")
        {
            if (!items)
                return cgDefault(target.type);

            target.type.isStruct || fail(
                "cgCall: defctor/type not a struct.");

            // Watch the order of eval here, can break your testdiffs.
            //  We'll probably want to define it at some point,
            //   hunting down drama can be tricky.
            let args = REST;
            return typeAnnotBase(target.type) ~ " { " ~ args ~ " }";
        }

        let id = target.name || fail();

        if (target.kind == "var")
        {
            if (target.flags & F_GLOBAL)
            {
                if (node.target.modid != module.modid)
                    cgForeignGlobal(node.target);

                return ID(id); // TODO ensure const emit.
            }

            return localID(node.target, target);
        }

        if (target.kind == "field")
            return ARG(0) ~ "." ~ ID(id);

        if (node.target.modid && target.kind == "fn")
        {
            if (target.solved.flags & F_TEMPLATE || !(target.solved.flags & F_PUB))
                ensureFnDef(node.target, target);
            else if (node.target.modid != module.modid)
                ensureFwdDecl(node.target);
        }

        if (target.flags & F_OPERATOR)
        {
            let head = items[0] || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? ARG(0) ~ id.valid_operator
                     : id.valid_operator ~ ARG(0);
            }

            if (items.len == 2)
            {
                if (id == "[]")
                {
                    // The new cow_vec is here.
                    if (node.type.is_mutref)
                        return ARG(0) ~ ".mutref(" ~ ARG(1) ~ ")";

                    return ARG(0) ~ "[" ~ ARG(1) ~ "]";
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == "=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return "(" ~ cgNode(head.items[0] || fail())
                                 ~ ".upsert(" ~ cgNode(head.items[1] || fail()) ~ ") = "
                                 ~ ARG(1) ~ ")";
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == "||=")
                {
                    mut arg0: string;
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            arg0 = cgNode(head.items[0] || fail())
                                ~ ".upsert(" ~ cgNode(head.items[1] || fail()) ~ ")";
                    }
                    arg0 ||= ARG(0);

                    mut tv: TEMPVAR;
                    let condcons = via(:tv, :head.type, expr: arg0);
                    let alt = tv.ptrflip ? "*" ~ tv.id : tv.id || arg0;
                    return "(" ~ condcons ~ alt ~ " = " ~ ARG(1) ~ ")";
                }

                // Collapse (a ~= b + c) into (a ~= b, a ~= c),
                //  totally surprised at how little if any impact this has.
                if (id == "~=")
                    if (type_isArray(head.type) && isFieldChain(node.items[0]))
                        if (node.items[1].value == "~" && node.items[1].type.canon == head.type.canon)
                            return cgAppend(node, ARG(0));

                // Skip explicit copy on assignment, it's just overly verbose.
                {
                    let arg0 = ARG(0);
                    mut arg1: string;
                    if (id == "=" || id == "||=" || id == "&&=") // This is off, see ||= returns above
                        if (items[1].kind == "copy")
                            arg1 = cgNode(items[1].items.only);

                    // Skip some of the ridiculous parens.
                    mut op = id.valid_operator;
                    if (binSkipParens(op, mode))
                        return arg0 ~ " " ~ op ~ " " ~ (arg1 || ARG(1));
                    else
                        return "(" ~ arg0 ~ " " ~ op ~ " " ~ (arg1 || ARG(1)) ~ ")";
                }
            }
        }

        if (id == "CLONE" && items.len == 1)
            return cgClone(node.type, ARG(0));

        if (id == "STEAL" && items.len == 1)
            return cgMove(node.type, ARG(0));

        if (id == "println")
            return cgPrint(cgNodes(items));

        id != "__native" || assert();

        mut closure = "";
        if (target.closes_over)
        {
            for (mut i = 0; i < target.closes_over.len; i++)
            {
                if (i)
                    closure ~= ", ";

                let t = Target(modid: module.modid, index: target.closes_over[i]);
                let o = GET(t);
                closure ~= localID(t, o);
            }

            if (items)
                closure ~= ", ";
        }

        return ID(id) ~ "(" ~ closure ~ REST ~ ")";
    }

    fn cgAppend(node: SolvedNode, into: string): string
    {
        mut src = "(";
        cgAppend_visit(node.type.canon, into, node.items[1], src);
        src ~= ")";

        return src;
    }

    fn cgAppend_visit(
        canon: string, into: string,
        stuff: SolvedNode, src: &mut string)
    {
        if (stuff.kind != "call" || stuff.value != "~" || stuff.type.canon != canon || stuff.items.len != 2)
        {
            let val = cgNode(stuff);
            if (src.len > 1)
                src ~= ", ";

            src ~= into ~ " += " ~ val;
        }
        else
        {
            cgAppend_visit(canon, into, stuff.items[0], src);
            cgAppend_visit(canon, into, stuff.items[1], src);
        }
    }

    fn cgPrint(items: string[]): string
    {
        include("<iostream>");

        mut src = "(std::cout";
        for (mut i = 0; i < items.len; i++)
            src ~= " << " ~ items[i];

        src ~= " << '\\n')";
        return src;
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn cgLiteral(node: SolvedNode): string
    {
        mut src = node.value;

        if (node.type.quals & q_unsigned)
            if (!src.has('u'))
                src ~= 'u';

        if (node.type.quals & q_floating_pt)
        {
            if (!src.has('.'))
                src ~= ".0";

            if (node.type.canon == "f32")
            {
                if (src.has('x'))
                    src = "float(" ~ src ~ ")";
                else
                    src ~= "f";
            }
            else if (node.type.canon != "f64")
            {
                assert();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        // One of those paradoxes.
        if (src.len > 16)
        {
            let parse = intlit::Intlit(src);
            if (parse.negative && parse.absval == 0x8000000000000000)
                return "(-9223372036854775807-1)";
        }

        if (node.type.quals & q_integral &&
            node.type.canon != "u32" && node.type.canon != "i32")
        {
            if (node.type.canon == "u64" || node.type.canon == "i64") {
                if (!src.has('l'))
                    return src ~ "ll";
            }
            else {
                return typeAnnotBase(node.type) ~ "(" ~ src ~ ")";
            }
        }

        return src;
    }

    fn cgEmpty(mode: i32): string
    {
        return mode & M_STMT ? "" : "0";
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(shadow node: SolvedNode)
            node.kind == "if" || node.kind == "and"
                ? " " ~ cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL | (stmt && M_PARENS));
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return "if (" ~ cond ~ ")" ~ cons ~ (alt ? _indent ~ "else" ~ alt : "");

        return "(" ~ cond ~ " ? " ~ cons ~ " : " ~ alt ~ ")";
    }

    fn cgAnd(node: SolvedNode, mode: i32): string
    {
        return cgAnd(:node.items, :node.type, :mode);
    }

    fn cgAnd(items: [SolvedNode], type: Type, mode: i32): string
    {
        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (";
            cgAndOr_concat(src, " && ", items[0, items.len - 1], parens: true);
            src ~= ")";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.is_bool)
        {
            cgAndOr_concat(src, " && ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            if (type.is_mutref)
            {
                for (mut i = 0; i < items.len; i++)
                {
                    let item = items[i];
                    if (i < items.len - 1)
                        src ~= "!" ~ via(:tv, :type, item);
                    else
                        src ~= cgNode(item);
                }
            }
            else
            {
                let N = items.len;
                let retSecondLast = items[N - 1].type.is_never;

                let condEnd = retSecondLast ? N - 2 : N - 1;
                cgAndOr_concat(src, " && ", items[0, condEnd]);

                if (retSecondLast)
                {
                    if (condEnd) src ~= " && ";
                    src ~= "!" ~ via(:tv, :type, items[N - 2]);
                    src ~= cgNode(items[N - 1]); // FAIL
                }
                else
                {
                    src ~= " ? " ~ cgNode(items[N - 1]);
                    src ~= " : " ~ cgDefault(type);
                }
            }
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn cgOr(node: SolvedNode, mode: i32): string
    {
        let type  = node.type;
        let items = node.items;

        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (!(";
            cgAndOr_concat(src, " || ", items[0, items.len - 1], parens: true);
            src ~= "))";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.is_bool)
        {
            cgAndOr_concat(src, " || ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    shadow let items = item.items;
                    tail = items[items.len - 1] || fail();

                    cgAndOr_concat(src, " && ", items[0, items.len - 1]);
                    src ~= " && ";
                }

                //
                src ~= via(:tv, :type, tail);
            }

            let tail = items[items.len - 1] || fail();
            src ~= cgNode(tail);
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn via(ref tv: TEMPVAR, type: Type, expr: SolvedNode): string
    {
        if (expr.isFieldChain)
        {
            let trivial = cgNode(expr);
            return trivial ~ " ? " ~ trivial ~ " : ";
        }

        if (expr.kind == "copy" || expr.kind == "move")
        {
            let kind = expr.kind;
            shadow let expr = expr.items.only;
            if (expr.isFieldChain)
            {
                let trivial = cgNode(expr);
                return trivial ~ " ? " ~ cgMoveOrClone(:kind, :type, trivial) ~ " : ";
            }

            // TODO fix the copies -
            //  we can copy AFTER the test,
            //   will also result in shorter code.
            //
            // TODO this is true for any transformation that does not affect truthiness.
            //  For example a conversion from i8 to i32 cannot affect truthiness, but i32 to i8 can.
            //   Can we generalize this? This would be fantastic.
            //
            // But copies are the worst.
        }

        return via(:tv, :type, expr: cgNode(expr));
    }

    fn via(ref tv: TEMPVAR, type: Type, expr!: string): string
    {
        if (!tv.id)
            tv.id = emitTEMPVAR(
                tv.annot = typeAnnot(type), :tv.ptrflip);

        if (tv.ptrflip)
            return "*(" ~ tv.id ~ " = &(" ~ expr ~ ")) ? *" ~ tv.id ~ " : ";

        if (type.quals & q_trivial)
            return "(" ~ tv.id ~ " = " ~ expr ~ ") ? " ~ tv.id ~ " : ";

        return "(" ~ tv.id ~ " = " ~ expr ~ ") ? static_cast<" ~ tv.annot ~ "&&>(" ~ tv.id ~ ") : ";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var")
            return true;

        return false;
    }

    fn cgAndOr_concat(ref src: string, op: string, items: [SolvedNode], parens?!: bool)
    {
        let mode = M_RETBOOL | (parens && items.len == 1 && M_PARENS);
        for (mut i = 0; i < items.len; i++)
        {
            if (i) src ~= op;
            src ~= cgNode(items[i], :mode);
        }
    }

    fn cgDefault(type: Type): string
    {
        type.is_mutref && fail("Cannot definit mutrefs.");

        if (type.is_ref)
        {
            include("<fu/default.h>");

            return "fu::Default<" ~ typeAnnot(clear_refs(type)) ~ ">::value";
        }

        return typeAnnot(type) ~ "{}";
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        mut end = src.len - 1;

        // :(
        src[end] == '}' || fail();
        if (postfix.if_first == '\n')
            for (mut i = end; i --> 0 && src[i] == ' '; )
                end--;

        return src.slice(0, end) ~ postfix ~ '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let can_cont0 = _current_fn.can_cont;
        let can_break0 = _current_fn.can_break;

        defer {
            _current_fn.can_cont = can_cont0;
            _current_fn.can_break = can_break0;
        }

        _current_fn.can_cont = 0;
        _current_fn.can_break = 0;

        //
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];
        let n_post = items[LOOP_POST];

        let init = n_init && cgNode(n_init, M_STMT);
        let cond = n_cond && cgNode(n_cond, M_RETBOOL | M_PARENS);
        let pcnd = n_pcnd && cgNode(n_pcnd, M_RETBOOL);
        let post = n_post && cgNode(n_post, M_STMT);

        //
        let label = node.target;
        _current_fn.can_break = label.index;

        mut body = n_body && blockWrapSubstatement(n_body, M_LOOP_BODY);

        //
        mut breakLabel = "";

        let lbl     = label && GET(label);
        let name    = lbl.name;
        if (body && name)
        {
            let brk = "L_" ~ name;
            if (body.has("goto " ~ brk ~ ";")) // TODO FIX track label usage
                breakLabel = " " ~ brk ~ ":;";
        }

        //
        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" ~ body ~ _indent ~ "while (" ~ pcnd ~ ")" ~ breakLabel;
        }

        if (init || post || !cond)
            return "for (" ~ init ~ "; " ~ cond ~ "; " ~ post ~ ")" ~ body ~ breakLabel;

        return "while (" ~ cond ~ ")" ~ body ~ breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let var_name    = items[0];
        let try_init    = cgNode(items[0].items[LET_INIT]) ~ ";";
        let err         = GET(items[1].target).name;
        let catch       = blockWrapSubstatement(items[2]);

        mut vardecl     = !var_name.type.is_never &&
            binding(var_name, forceMut: true) ~ " = {};";

        return vardecl
             ~ cgTryCatch(
                var_name.type.is_never
                    ? _indent ~ "    " ~  try_init
                    : _indent ~ "    " ~  var_name.value ~ " = " ~ try_init,
                err,
                catch);
    }

    fn cgTryCatch(node: SolvedNode): string
    {
        let items = node.items;
        let try = blockWrapSubstatement(items[0]);

        let err = GET(items[1].target).name;
        let catch = blockWrapSubstatement(items[2]);

        return cgTryCatch(try, err, catch);
    }

    fn cgTryCatch(try: string, err: string, catch: string): string
    {
        return _indent ~ "try"
             ~ _indent ~ "{"
             ~  try
             ~ _indent ~ "}"
             ~ _indent ~ "catch (const std::exception& o_0)"
             ~ _indent ~ "{"
             ~ _indent ~ "    fu_STR " ~ ID(err) ~ " = fu_TO_STR(o_0.what());\n"
             ~  catch
             ~ _indent ~ "}\n";
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == "call")        return cgCall(node, mode);

        if (k == "int")         return cgLiteral(node);
        if (k == "real")        return cgLiteral(node);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node, mode);
        if (k == "definit")     return cgDefaultInit(node, mode);

        if (k == "copy")        return cgMoveOrClone(node, mode);
        if (k == "move")        return cgMoveOrClone(node, mode);
        if (k == "nrvo")        return cgMoveOrClone(node, mode);

        if (k == "if")          return cgIf(node, mode);
        if (k == "or")          return cgOr(node, mode);
        if (k == "and")         return cgAnd(node, mode);

        if (k == "let")         return cgLet(node);

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node, mode);
        if (k == "argid")       return cgComma(node.items);

        // Empties.
        if (k == "fndef")       return cgFnDef(node, mode);
        if (k == "struct")      return cgEmpty(mode);
        if (k == "empty")       return cgEmpty(mode);

        // Stuff that we can't cg as expressions.
        if !(mode & M_STMT)
            return cgBlock(node, :mode);

        if (k == "jump")        return cgJump(node);

        if (k == "loop")        return cgLoop(node);
        if (k == "try")         return cgTryCatch(node);
        if (k == "catch")       return cgCatch(node);
        if (k == "defer")       return cgDefer(node);

        return fail("TODO: " ~ k);
    }


    //

    fn cgMoveOrClone(node: SolvedNode, mode: i32): string
    {
        let expr = node.items.only;

        // NRVO now here, solver doesn't care.
        if (mode & M_RETURN && node.kind == "move")
        {
            fn supportsNRVO(o: Overload)
                o.kind == "var" && !(o.flags & F_ARG)
                    && o.local_of == _current_fn.target.index;

            let nrvo = expr.kind == "call"
                    && expr.items.len == 0
                    && expr.target.GET.supportsNRVO;

            if (nrvo)
                return cgNode(expr);
        }

        return cgMoveOrClone(node.kind, node.type, cgNode(expr));
    }

    fn cgMoveOrClone(kind: string, type: Type, src: string): string
    {
        if (kind == "move")
            return cgMove(type, src);

        return cgClone(type, src);
    }

    fn cgMove(type: Type, src: string): string
    {
        if (type.quals & q_trivial)
            return cgClone(type, src);

        return "static_cast<" ~ typeAnnotBase(type) ~ "&&>(" ~ src ~ ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) ~ "(" ~ src ~ ")";
    }


    //

    fn emitTEMPVAR(annot: string, ref ptrflip!: bool, id?: string): string
    {
        ptrflip = annot[annot.len - 1] == '&';

        shadow let id = id || "_" ~ _current_fn.numTEMPVARs++;
        _current_fn.TEMPVARs ~=
            ptrflip ? annot[0, annot.len - 1] ~ "* " ~ id
                    : annot ~ " " ~ id ~ " {}"; // TODO dont init trivial

        return id;
    }

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0, trail?!: string): string[]
    {
        mut result: string[] = [];

        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if (mode & M_STMT) SWAP(_tv0, _current_fn.TEMPVARs);
        defer {
            if (mode & M_STMT) SWAP(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        for (mut i = 0; i < nodes.len; i++)
        {
            let node    = nodes[i];
            let isTrail = trail && i == nodes.len - 1 && !node.type.maybe_nonzero;
            mut src     = node && cgNode(node, isTrail ? mode &~ M_STMT : mode);

            src || mode & M_STMT || fail("cgNodes: empty `" ~ node.kind ~ ".`");

            if (mode & M_STMT && _current_fn.TEMPVARs)
            {
                result ~= _current_fn.TEMPVARs;
                _current_fn.TEMPVARs.clear();
            }

            if (isTrail)
                src = trail ~ "(" ~ src ~ ")";

            result.push(src);
        }

        return result;
    }


    //

    root.kind == "root" || fail();

    let src = cgNode(root);
    return src;
}
