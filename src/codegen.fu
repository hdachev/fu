#import "helpers";
#import "parser";
#import "types";
#import "scope";
#import "solver";

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_CLOSURE           = 1 << 5;
let M_FWDECL            = 1 << 6;


//

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    root: SolvedNode, scope: Scope): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);
    mut _ffwd: Map(string, string);
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string = "\n";
    mut _fnN: i32;
    mut _clsrN: i32;
    mut _faasN: i32;
    mut _hasMain: i32;
    mut _isModuleSpecs: i32;

    fn GET(
        implicit module: Module,
        implicit ctx: Context,
        target: Target): Overload
    {
        target.index > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn fail(reason = "") throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = "#include " + lib + "\n";
    }


    //

    fn typeAnnot(value: ValueType): string
        typeAnnot(Type(:value));

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        let fwd = typeAnnotBase(type);

        if (mode & M_RETVAL && type.canon == "never" && !(mode & M_CLOSURE))
            return "[[noreturn]] " + fwd;

        if (type.quals & q_mutref)
            return fwd + "&";

        if (type.quals & q_ref)
        {
            // Pass primitives by value.
            if (type.quals & q_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " + fwd
                     : fwd;

            return "const " + fwd + "&";
        }

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return "const " + fwd;

        if ((mode & M_ARGUMENT) && !(type.quals & q_trivial))
            return fwd + "&&";

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (type.quals & q_primitive)
        {
            // Avoid #include noise when possible.
            if (c == "i32")     return "int";
            if (c == "i16")     return "short";

            if (c == "bool")    return "bool";

            if (c == "f32")     return "float";
            if (c == "f64")     return "double";

            // Tough luck.
            include("<cstdint>");

            if (c ==  "i8")     return "int8_t";
            if (c == "i64")     return "int64_t";

            if (c ==  "u8")     return "uint8_t";
            if (c == "u16")     return "uint16_t";
            if (c == "u32")     return "uint32_t";
            if (c == "u64")     return "uint64_t";

            if (c == "byte")    return "std::byte";

            fail("Unknown primitive.");
        }

        if (c == "void")   return "void";
        if (c == "string") return annotateString();
        if (c == "never")  return annotateNever();

        let tdef = lookupType(type) || fail("TODO: " + type.canon);
        let k = tdef.kind;

        if (k == "struct")
        {
            if (!_tfwd.has(type.canon))
            {
                _tfwd[type.canon] = "\nstruct " + type.canon + ";";

                _tdef += declareStruct(type, tdef);
            }

            return type.canon;
        }

        if (k == "array")
        {
            if (tdef.fields.only.type == t_byte.value)
                return annotateString();

            let item = typeAnnot(tdef.fields[0].type);

            include("<fu/vec.h>");
            return "fu_VEC<" + item + ">";
        }

        if (k == "map")
        {
            let k = typeAnnot(tdef.fields[0].type);
            let v = typeAnnot(tdef.fields[1].type);

            include("<fu/map.h>");
            return "fu_COW_MAP<" + k + ", " + v + ">";
        }

        return fail("TODO: " + tdef.kind);
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        mut def = "\n                                #ifndef DEF_" + t.canon
                + "\n                                #define DEF_" + t.canon
                + "\nstruct " + t.canon + "\n{";

        mut indent = "\n    ";

        if (s.flags & F_DESTRUCTOR)
        {
            def += "\n    struct Data\n    {";
            indent += "    ";
        }

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def += indent + typeAnnot(field.type) + " " + ID(field.id) + ";";
        }

        if (s.flags & F_DESTRUCTOR)
        {
            def += "\n    };";
            def += "\n";
            def += "\n    Data data;";
            def += "\n    bool dtor = false;";
            def += "\n";
            def += "\n    ~" + t.canon + "() noexcept;";
            def += "\n    inline " + t.canon + "(Data data) noexcept : data(data) {};";
            def += "\n    " + t.canon + "(const " + t.canon + "&) = delete;";
            def += "\n    " + t.canon + "& operator=(const " + t.canon + "&) = delete;";
            def += "\n    " + t.canon + "(" + t.canon + "&&) noexcept;";
            def += "\n    " + t.canon + "& operator=(" + t.canon + "&&) noexcept;";
        }

        def += "\n    explicit operator bool() const noexcept";
        def += "\n    {";
        def += "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            def += "\n            || "
                + boolWrap(fields[i].type,
                    (s.flags & F_DESTRUCTOR ? "data." : "")
                        + ID(fields[i].id));

        def += "\n        ;";
        def += "\n    }";

        return def + "\n};\n                                #endif\n";
    }


    //

    fn collectDedupes(
        dedupes: Map(string, string)): string
    {
        mut out = "";

        mut keys = dedupes.keys();
        keys.sort();

        for (mut i = 0; i < keys.len; i++)
            out += dedupes[keys[i]];

        return out;
    }

    fn cgSpecs(): string
    {
        mut src = "";

        /////////////////
        _isModuleSpecs++;
        /////////////////

        let specs = module.out.specs;
        let keys = specs.keys();
        for (mut i = 0; i < keys.len; i++)
        {
            // Prelude?
            let k = keys[i];
            if (k[0] == "0")
                continue;

            // Emit.
            let s = specs[k];
            if (s.target)
            {
                mut dedupe = "";
                for (mut i = 0; i < k.len; i++)
                {
                    let c = k[i];

                    if (c >= "0" && c <= "9" ||
                        c >= "a" && c <= "z" || c >= "A" && c <= "Z")
                    {
                        dedupe += c;
                    }
                    else
                    {
                        dedupe += "_";
                    }
                }

                src  += "\n                                #ifndef DEFt_" + dedupe
                      + "\n                                #define DEFt_" + dedupe
                      + "\n" + cgNode(s)
                      + "\n                                #endif\n";
            }
        }

        /////////////////
        _isModuleSpecs--;
        /////////////////

        return src;
    }

    fn cgRoot(root: SolvedNode): string
    {
        let specs  = cgSpecs();
        let src    = cgStatements(root.items);
        let main   = cgMain();

        mut header = collectDedupes(_libs)
                   + collectDedupes(_tfwd)
                   + collectDedupes(_ffwd)
                   +               (_tdef)
                   +               (specs)
                   +               (_fdef)
                   ;

        return header + src + main;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        if (_hasMain != 2)
            return "\n\nint main() { return fu_MAIN(); }\n";

        // Main with cli args.
        annotateString();

        return "\n\nint main(int argc, char* argv[])"
            +  "\n{"
            +  "\n    fu_VEC<fu_STR> args;"
            +  "\n    args.reserve(argc);"
            +  "\n"
            +  "\n    for (int i = 0; i < argc; i++)"
            +  "\n        args.push(fu_TO_STR(argv[i]));"
            +  "\n"
            +  "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args));"
            +  "\n}\n";
    }


    //

    fn ID(id: string): string
    {
        if (id == "this")       return "Q_this";
        if (id == "template")   return "Q_template";
        if (id == "catch")      return "Q_catch";
        if (id == "not")        return "Q_not";
        if (id == "and")        return "Q_and";
        if (id == "or")         return "Q_or";
        if (id == "int")        return "Q_int";
        if (id == "short")      return "Q_short";
        if (id == "long")       return "Q_long";

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = "";

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src += _indent + line + (line.if_last == ";" ? "\n" : ";");
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[], skipCurlies: bool = false): string
    {
        let indent0 = _indent;
        _indent += "    ";

        mut src = cgStatements(nodes);
        if (!skipCurlies || nodes.len != 1 || nodes[0].kind != "return" && nodes[0].kind != "call")
            src = indent0 + "{" + src + indent0 + "}";

        _indent = indent0;
        return src;
    }

    fn blockWrapSubstatement(node: SolvedNode): string
    {
        return node.kind != "block" ? blockWrap([ node ], true)
             : node.items.len == 1  ? blockWrapSubstatement(node.items[0])
                                    : cgBlock(node);
    }

    fn cgBlock(block: SolvedNode): string
    {
        return blockWrap(block.items);
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src += ", ";
            if (i < items.len - 1)
                src += "(void)";

            src += items[i];
        }

        return src + ")";
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let items   = fn.items;
        let ret     = items[items.len + FN_RET_BACK] || fail();
        let closure = !!_clsrN && (fn.flags & F_CLOSURE);

        let annot   = typeAnnot(
            ret.type || fail(),
            M_RETVAL | (closure ? M_CLOSURE : 0));

        mut id = fn.value;
        if (id == "main" && !closure)
        {
            _hasMain = fn.items.len + FN_ARGS_BACK ? 2 : 1;
            id = "fu_MAIN";
        }

        mut src = closure
                ? "const auto& " + id + " = [&]("
                : annot + " " + id + "(";

        if (!id.hasIdentifierChars)
            src = annot + " operator" + id + "(";

        if (_isModuleSpecs && !closure)
            src = "inline " + src;

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src += ", ";

            src += binding(items[i] || fail());
        }

        src += closure
             ? ") -> " + annot
             : ")";

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        let ffwdKey = target.modid + "#" + target.index;
        if (_ffwd.has(ffwdKey))
            return;

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let isOp    = !id.hasIdentifierChars;

        mut src = isOp
                ? "\n" + annot + " operator" + id + "("
                : "\n" + annot + " " + id + "(";

        let arg_t = overload.args;
        for (mut i = 0; i < arg_t.len; i++)
        {
            if (i)
                src += ", ";

            src += typeAnnot(arg_t[i], M_ARGUMENT | M_FWDECL);
        }

        src += ");";
        _ffwd[ffwdKey] = src;

        return;
    }


    // This barely works unless it doesn't.

    fn try_cgFnAsStruct(fn: SolvedNode): string
    {
        let body = fn.items[fn.items.len + FN_BODY_BACK];
        if (!body || body.kind != "block")
            return "";

        let items = body.items;

        // We need at least one closure
        //  in the function "header"
        //   for all of this to make sense.
        mut hasClosuresInHeader = false;
        mut end = 0;
        for (mut i = 0; i < items.len; i++)
        {
            end = i;

            let item = items[i];
            if (item.kind == "fn")
            {
                if (item.flags & F_CLOSURE)
                    hasClosuresInHeader = true;
            }
            else if (item.kind != "let" && item.kind != "struct")
            {
                break;
            }
        }

        if (!hasClosuresInHeader)
            return "";

        // Ok - refactor time.
        let evalName = fn.value + "_EVAL";

        let restFn = SolvedNode(

            kind: "fn", type: t_void,
            flags: fn.flags | F_CLOSURE,
            token: fn.token,
            value: evalName,

            items:
            [
                fn.items[fn.items.len - 2], // retval
                SolvedNode(
                    kind: "block", type: t_void,
                    token: fn.token,
                    items: items.slice(
                        end, items.len)),
            ]);

        let head: SolvedNode[] =
            fn.items.slice(0, fn.items.len + FN_ARGS_BACK)
                + items.slice(0, end)
                + [ restFn ];

        //////////////////////
        _clsrN == 0 || fail();
        _clsrN--; // -1, so root closures come up at 0.
        //////////////////////

        let structName = "sf_" + fn.value;
        mut src = "\nnamespace {\n\nstruct " + structName
                + blockWrap(head) + ";\n";

        //////////////////////
        {
            mut args: string[];

            for (mut i = 0; i < fn.items.len + FN_ARGS_BACK; i++)
            {
                let argNode = fn.items[i];
                let argType = argNode.type;
                let arg     = argNode.value;

                args.push(
                    argType.quals & q_ref
                        ? arg
                        : cgSteal(arg));
            }

            src += "\n} // namespace\n\n";
            src += cgFnSignature(fn);
            src += "\n{\n    return (" + structName + " { " + args.join(", ") + " })." + evalName + "();\n}\n\n";
        }

        if (_fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        //////////////////////
        _clsrN++;
        //////////////////////

        return src;
    }


    //

    fn cgFn(fn: SolvedNode): string
    {
        // Template? TODO FIX dunno why this is how we tell, looks terrible.
        if (!fn.items.len)
            return "";

        // Use like-struct output for top-level functions with closures -
        //  We'll try to "close over" a root-level struct.
        if (_faasN == 0 && (fn.flags & F_HAS_CLOSURE))
        {
            /////////
            _faasN++;
            /////////

            let src = try_cgFnAsStruct(fn);

            /////////
            _faasN--;
            /////////

            if (src)
            {
                _fdef += src;
                return "";
            }
        }

        ///////////////////////////
        let f0 = _fnN;
        let c0 = _clsrN;
        let indent0 = _indent;

        _fnN++;
        if (fn.flags & F_CLOSURE) _clsrN++;
        ///////////////////////////

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK] || fail();

        // Both closures and try_cgFnAsStruct
        if (!(fn.flags & F_CLOSURE))
            _indent = "\n";

        mut src = cgFnSignature(fn);
        if (!(fn.flags & F_CLOSURE) && _fdef.has(fn.value || fail()))
            ensureFwdDecl(fn.target);

        if (body.kind == "block")
            src += cgBlock(body);
        else
            src += blockWrap([ body ]);

        //////////////
        _fnN    = f0;
        _clsrN  = c0;
        _indent = indent0;
        //////////////

        if (fn.flags & F_DESTRUCTOR)
        {
            let head = items[0] || fail();
            let name = head.type.canon;

            src += "\n\n" + name + "::~" + name + "() noexcept";
            src += "\n{";
            src += "\n    if (!dtor)";
            src += "\n    {";
            src += "\n        dtor = true;";
            src += "\n        free(*this);";
            src += "\n    }";
            src += "\n}";

            include("<cassert>");
            include("<utility>");

            src += "\n\n" + name + "::" + name + "(" + name + "&& src) noexcept";
            src += "\n    : data(std::move(src.data))";
            src += "\n{";
            src += "\n    assert(!src.dtor);";
            src += "\n    dtor = src.dtor;";
            src += "\n    src.dtor = true;";
            src += "\n}";

            include("<cstring>");

            src += "\n\n" + name + "& " + name + "::operator=(" + name + "&& src) noexcept";
            src += "\n{";
            src += "\n    char temp[sizeof(" + name + ")];";
            src += "\n    char* a = (char*) this;";
            src += "\n    char* b = (char*) &src;";
            src += "\n";
            src += "\n    std::memcpy (temp, a, sizeof(" + name + "));";
            src += "\n    std::memmove(a,    b, sizeof(" + name + "));";
            src += "\n    std::memcpy (b, temp, sizeof(" + name + "));";
            src += "\n";
            src += "\n    return *this;";
            src += "\n}";
        }

        // This covers both closures & try_cgTryFnAsStruct:
        if (fn.flags & F_CLOSURE || _isModuleSpecs)
            return src;

        _fdef += "\n" + src + "\n";
        return "";
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        let id    = node.value || fail();
        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        let head  = (annot || fail()) + " " + ID(id);
        let init  = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == "copy" && !(node.type.quals & q_ref))
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_trivial)
                    return head + " = " + expr;

                return head + " { " + expr + " }";
            }

            // Definit.
            if (init.kind == "definit" && !(init.type.quals & q_ref) && init.type == node.type)
                return head + " {}";

            return head + " = " + cgNode(init);
        }

        return head + " {}";
    }

    fn cgLet(node: SolvedNode): string
    {
        return binding(node, doInit: true);
    }

    fn cgGlobal(node: SolvedNode): string
    {
        mut src = cgLet(node);

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.replace(
            all: "([&](", with: "([](");

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        //
        _fdef  += "\n                                #ifndef DEF_" + node.value
                + "\n                                #define DEF_" + node.value
                + "\ninline const " + src + ";"
                + "\n                                #endif\n";

        return "";
    }

    fn cgForeignGlobal(target: Target): void
    {
        let key = target.modid + "#" + target.index;
        if (_ffwd.has(key))
            return;

        _ffwd[key] = "";
        let o = GET(target);
        cgGlobal(o.constant);
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type == t_never)
                return src;

            return "return " + src;
        }

        return "return";
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return "goto L_" + node.value + "_" + node.kind[0];

        return node.kind;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == "\n") esc += "\\n";
            else if (c == "\r") esc += "\\r";
            else if (c == "\t") esc += "\\t";
            else if (c == "\v") esc += "\\v";
            else if (c == "\\") esc += "\\\\";
            else if (c == "\"") esc += "\\\"";

            else                esc += c;
        }

        return "\"" + esc + "\"_fu";
    }

    fn cgArrayLiteral(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot + " { " + arrayAnnot
            + "::INIT<" + items.len + "> { "
                + items.join(", ") + " } }";
    }

    fn cgDefaultInit(node: SolvedNode): string
    {
        return cgArrayLiteral(node);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == "_" || c >= "a" && c <= "z"
                         || c >= "A" && c <= "Z"
                         || c >= "0" && c <= "9")
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();
        mut items  = cgNodes(node.items);

        // Builtin specs.
        if (target.kind == "__native" && target.template.node.items)
        {
            mut id = target.template.node.items[0].value;
            if (id[0] == "<")
            {
                include(id);
                id = target.template.node.items[1].value;
            }

            if (id[0] == ".")
            {
                if (items.len > 1)
                    return items[0] + id + "(" + items.slice(1).join(", ") + ")";

                return items[0] + id;
            }

            if (items)
            {
                if (id.hasIdentifierChars)
                    return id + "(" + items.join(", ") + ")";

                return "(" + items[0] + " " + id + " " + items[1] + ")";
            }

            return id;
        }

        //
        if (target.kind == "defctor")
        {
            let head = (target.type || fail());
            let type = lookupType(head) || fail();

            //
            mut open = " { ";
            mut close = " }";
            if (type.flags & F_DESTRUCTOR)
            {
                open = " { " + head.canon + "::Data { ";
                close = " }}";
            }

            return head.canon + open + items.join(", ") + close;
        }

        let id = target.name || fail();

        if (target.kind == "global")
        {
            if (node.target.modid != module.modid)
                cgForeignGlobal(node.target);

            return ID(id); // TODO ensure const emit.
        }

        if (target.kind == "var" ||
            target.kind == "arg" ||
            target.kind == "ref")
        {
            return ID(id);
        }

        if (target.kind == "field")
        {
            mut sep = ".";
            let parent = lookupType(node.items[0].type);
            if (parent.flags & F_DESTRUCTOR)
                sep = ".data.";

            return items[0] + sep + ID(id);
        }

        if (node.target.modid && node.target.modid != module.modid)
            ensureFwdDecl(node.target);

        if (hasNonIdentifierChars(id))
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? items[0] + id
                     : id + items[0];
            }

            if (items.len == 2)
            {
                if (id == "[]")
                {
                    // The new cow_vec is here.
                    if (node.type.quals & q_mutref)
                        return items[0] + ".mutref(" + items[1] + ")";

                    return items[0] + "[" + items[1] + "]";
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == "=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return "(" + cgNode(head.items[0] || fail()) +
                                ".upsert(" + cgNode(head.items[1] || fail()) + ") = " +
                                    items[1] + ")";
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == "||=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            items[0] = cgNode(head.items[0] || fail()) +
                                ".upsert(" + cgNode(head.items[1] || fail()) + ")";
                    }

                    let annot = typeAnnot(head.type);

                    return "([&](" + annot + " _) -> " + annot + " { if (!" +
                        boolWrap(head.type, "_") + ") _ = " +
                            items[1] + "; return _; } (" + items[0] + "))";
                }

                // Collapse (a += b + c) into (a += b, a += c),
                //  totally surprised at how little if any impact this has.
                if (id == "+=")
                    if (type_isArray(head.type) && isFieldChain(node.items[0]))
                        if (node.items[1].value == "+" && node.items[1].type.canon == head.type.canon)
                            return cgAppend(node, items[0]);

                // Skip some of the ridiculous parens.
                if (mode & M_STMT)
                    return items[0] + " " + id + " " + items[1];
                else
                    return "(" + items[0] + " " + id + " " + items[1] + ")";
            }
        }

        if (id == "char" && items.len == 2)
        {
            // TODO FIX
            let head = node.items[0] || fail();
            if (type_isArray(head.type))
                return "int(" + items[0] + "[" + items[1] + "])";
        }

        if (id == "CLONE" && items.len == 1)
            return cgClone(node.type, items[0]);

        if (id == "STEAL" && items.len == 1)
            return cgSteal(items[0]);

        if (id == "SWAP" && items.len == 2)
            return cgSwap(items);

        if (id == "print")
            return cgPrint(items);

        id != "__native" || assert();

        return ID(id) + "(" + items.join(", ") + ")";
    }

    fn cgAppend(node: SolvedNode, into: string): string
    {
        mut src = "(";
        cgAppend_visit(node.type.canon, into, node.items[1], src);
        src += ")";

        return src;
    }

    fn cgAppend_visit(
        canon: string, into: string,
        stuff: SolvedNode, src: &mut string)
    {
        if (stuff.kind != "call" || stuff.value != "+" || stuff.type.canon != canon || stuff.items.len != 2)
        {
            let val = cgNode(stuff);
            if (src.len > 1)
                src += ", ";

            src += into + " += " + val;
        }
        else
        {
            cgAppend_visit(canon, into, stuff.items[0], src);
            cgAppend_visit(canon, into, stuff.items[1], src);
        }
    }

    fn cgPrint(items: string[]): string
    {
        include("<iostream>");

        mut src = "(std::cout";
        for (mut i = 0; i < items.len; i++)
            src += " << " + items[i];

        src += ' << "\\n")';
        return src;
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn cgLiteral(node: SolvedNode): string
    {
        return node.value || fail();
    }

    fn cgEmpty(): string
    {
        return "";
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(node: SolvedNode)
            node.kind == "if"
                ? " " + cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && boolWrap(n0.type, cgNode(n0, M_RETBOOL));
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return "if (" + cond + ")" + cons + (alt ? _indent + "else" + alt : "");

        if (cons && alt)
            return "(" + cond + " ? " + cons + " : " + alt + ")";

        if (cons)
            return "(" + cond + " && " + cons + ")";

        if (alt)
            return "(" + cond + " || " + alt + ")";

        return fail("TODO");
    }


    //

    fn boolWrap(value: ValueType, src: string): string
        boolWrap(Type(value), src);

    fn boolWrap(type: Type, src: string): string
    {
        if (type) {}
        // if (type_isString(type) || type_isArray(type))
        //     return src + ".size()";

        return src;
    }


    //

    fn cgDefault(type: Type): string
    {
        type.quals & q_mutref && fail("Cannot definit mutrefs.");

        if (type.quals & q_ref)
        {
            include("<fu/default.h>");

            return "fu::Default<" + typeAnnot(clear_refs(type)) + ">::value";
        }

        return typeAnnot(type) + "{}";
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            let items = node.items;

            let retSecondLast = items[items.len - 1].type == t_never;

            let condEnd = retSecondLast
                        ? items.len - 2
                        : items.len - 1;

            mut src = "";

            if (condEnd)
            {
                src += "if (";

                for (mut i = 0; i < condEnd; i++)
                {
                    let item = items[i];
                    if (i) src += " && ";
                    src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                }

                src += ") ";
            }

            let tail = cgNode(items[condEnd]);

            if (retSecondLast)
            {
                src += "{ " + typeAnnot(type) + " _ = " + tail + "; ";
                src += "if (!" + boolWrap(type, "_") + ") return _; } ";
                src += cgNode(items[items.len - 1]) + ";"; //FAIL
            }
            else
            {
                src += "return " + tail + ";"; //TRUTHY
                src += " else return " + cgDefault(type) + ";";
            }

            src = "([&]() -> " + typeAnnot(type) + " { " + src + " }())";

            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];

            if (i) src += " && ";
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ")";
    }

    fn cgNot(node: SolvedNode): string
    {
        let item = node.items[0];
        return "!" + boolWrap(
            item.type, cgNode(item, M_RETBOOL));
    }

    fn cgOr(node: SolvedNode): string
    {
        let type = node.type;
        if (!(type == t_bool))
        {
            // Try a ?: chain.
            mut ternary = true;
            for (mut i = 0; i < node.items.len - 1; i++)
            {
                if (!isFieldChain(node.items[i]))
                {
                    ternary = false;
                    break;
                }

                if (ternary)
                {
                    mut src = "(";
                    for (mut i = 0; i < node.items.len - 1; i++)
                    {
                        let n = node.items[i];
                        let item = cgNode(n);
                        src += boolWrap(n.type, item) + " ? " + item + " : ";
                    }

                    src += cgNode(node.items[node.items.len - 1]) + ")";
                    return src;
                }
            }

            //
            let annot = typeAnnot(type);

            mut src = "([&]() -> " + annot + " {";

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src += " if (";
                    for (mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src += " && ";

                        let item = items[i] || fail();
                        src += boolWrap(item.type, cgNode(item, M_RETBOOL));
                    }

                    src += ")";
                }

                src += " { " + annot + " _ = " + cgNode(tail) + "; if (" + boolWrap(tail.type, "_") + ") return _; }";
            }

            let tail = items[items.len - 1] || fail();
            if (!(tail.type == t_never))
                src += " return";

            src += " " + cgNode(tail) + "; }())";
            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (i) src += " || ";
            src += boolWrap(item.type, cgNode(item, M_RETBOOL));
        }

        return src + ")";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var"     ||
            t.kind == "global"  ||
            t.kind == "arg"     ||
            t.kind == "ref")
        {
            return true;
        }

        return false;
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == "}" || fail();
        return src.slice(0, src.len - 1) + postfix + "}";
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = n_init && cgNode(n_init);
        let cond = n_cond && boolWrap(n_cond.type, cgNode(n_cond, M_RETBOOL));
        let post = n_post && cgNode(n_post);
        mut body = n_body && blockWrapSubstatement(n_body);
        let pcnd = n_pcnd && boolWrap(n_pcnd.type, cgNode(n_pcnd, M_RETBOOL));
        mut breakLabel = "";

        if (body && node.value)
        {
            let brk = "L_" + node.value + "_b";
            let cnt = "L_" + node.value + "_c";

            if (body.has(cnt))
                body = "{" + postfixBlock(body, _indent +     "    }" + cnt + ":;");
            if (body.has(brk))
                breakLabel = _indent + "    " + brk + ":;";
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" + body + _indent + "while (" + pcnd + ")" + breakLabel;
        }

        if (init || post || !cond)
            return "for (" + init + "; " + cond + "; " + post + ")" + body + breakLabel;

        return "while (" + cond + ")" + body + breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let let_main    = items[0];
        let let_init    = cgNode(items[0].items[LET_INIT]);
        let err_id      = items[1].value;
        let catch_body  = blockWrapSubstatement(items[2]);

        mut src =        binding(let_main, forceMut: true) + ";";
        src += _indent + "try";
        src += _indent + "{";
        src += _indent + "    " + let_main.value + " = " + let_init + ";";
        src += _indent + "}";
        src += _indent + "catch (const std::exception& o_0)";
        src += _indent + "{";
        src += _indent + "    const " + annotateString() + "& " + err_id + " = fu_TO_STR(o_0.what());";
        src += _indent + catch_body;
        src += _indent + "}\n";

        return src;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node);
        if (k == "fn")          return cgFn(node);
        if (k == "return")      return cgReturn(node);
        if (k == "break")       return cgJump(node);
        if (k == "continue")    return cgJump(node);
        if (k == "call")        return cgCall(node, mode);
        if (k == "let")         return cgLet(node);
        if (k == "global")      return cgGlobal(node);
        if (k == "if")          return cgIf(node, mode);
        if (k == "!")           return cgNot(node);
        if (k == "or")          return cgOr(node);
        if (k == "and")         return cgAnd(node);
        if (k == "loop")        return cgLoop(node);
        if (k == "int")         return cgLiteral(node);
        if (k == "num")         return cgLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node);
        if (k == "definit")     return cgDefaultInit(node);
        if (k == "empty")       return cgEmpty();

        if (k == "comma")       return cgParens(node);
        if (k == "parens")      return cgParens(node);
        if (k == "label")       return cgParens(node);
        if (k == "struct")      return cgEmpty();

        if (k == "copy")        return cgCopyMove(node);
        if (k == "move")        return cgCopyMove(node);
        if (k == "nrvo")        return cgCopyMove(node);
        if (k == "catch")       return cgCatch(node);

        return fail("TODO: " + k);
    }


    //

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == "nrvo")
            return a;

        if (node.kind == "move")
            return cgSteal(a);

        return cgClone(node.type, a);
    }

    fn cgSteal(src: string): string
    {
        include("<utility>");
        return "std::move(" + src + ")";
    }

    fn cgSwap(items: string[]): string
    {
        include("<utility>");
        return "std::swap(" + items.join(", ") + ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) + "(" + src + ")";
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        for (mut i = 0; i < nodes.len; i++)
        {
            let node  = nodes[i];
            let src   = node ? cgNode(node, mode) : "";

            result.push(src);
        }

        return result;
    }


    //

    root.kind == "root" || fail();

    let src = cgNode(root);
    return src;
}
