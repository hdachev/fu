import helpers;
import parser;
import types;
import scope;
import context;
import bitset;

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_LAMBDA            = 1 << 5;
let M_FWDECL            = 1 << 6;


//

type BitSet2D = bitset::BitSet[];

fn add_once(ref bs: BitSet2D, target: Target): bool
{
    return bs
        .grow_if_oob(target.modid)
        .add_once(target.index)
}


//

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    root: SolvedNode): string
{
    mut _libs: Map(string, string);
    mut _tfwd: Map(string, string);

    mut _ffwd: BitSet2D;
    mut _ffwd_src: string[];

    mut _idef: bitset::BitSet;
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string = "\n";
    mut _hasMain: i32;

    mut _current_fn_index: i32;

    fn GET(target: Target): Overload
    {
        target.index > 0 || assert();

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn fail(reason = "") throw(reason);


    //

    fn include(lib: string)
    {
        if (!_libs.has(lib))
            _libs[lib] = "#include " ~ lib ~ "\n";
    }


    //

    fn typeAnnot(vtype: ValueType): string
        typeAnnot(Type(:vtype));

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        if (mode & M_ARGUMENT && type.addroffn::type_isZST)
            return "int";

        let fwd = typeAnnotBase(type);

        if (type.quals & q_ref)
        {
            if (fwd.starts(with: "fu::view"))
                return fwd;

            if (type.quals & q_mutref)
                return fwd ~ "&";

            // Pass primitives by value.
            if (type.quals & q_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " ~ fwd
                     : fwd;

            return "const " ~ fwd ~ "&";
        }

        if ((mode & M_ARGUMENT) && !(type.quals & q_primitive))
            return fwd ~ "&&";

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.quals & q_trivial))
            return "const " ~ fwd;

        return fwd;
    }

    fn typeAnnotBase(type: Type): string
    {
        let c = type.canon;

        if (type.quals & q_primitive)
        {
            // Avoid #include noise when possible.
            if (c == "i32")     return "int";
            if (c == "i16")     return "short";

            if (c == "bool")    return "bool";

            if (c == "f32")     return "float";
            if (c == "f64")     return "double";

            // Tough luck.
            include("<cstdint>");

            if (c ==  "i8")     return "int8_t";
            if (c == "i64")     return "int64_t";

            if (c ==  "u8")     return "uint8_t";
            if (c == "u16")     return "uint16_t";
            if (c == "u32")     return "uint32_t";
            if (c == "u64")     return "uint64_t";

            if (c == "byte")    return "std::byte";

            fail("Unknown primitive.");
        }

        if (c == "void")   return "void";
        if (c == "never")  return annotateNever();

        // Arrays & strings.
        let arrayItem = tryClear_array(type);
        if (arrayItem)
        {
            if (arrayItem.vtype == t_byte.vtype)
                return annotateString();

            let itemAnnot = typeAnnot(arrayItem);

            include("<fu/vec.h>");
            return "fu_VEC<" ~ itemAnnot ~ ">";
        }

        // TODO FIX slice definit - (arg?: [byte]) somehow manages to drop ref on definit.
        let sliceItem = tryClear_slice(add_ref(type, lifetimes::Lifetime));
        if (sliceItem)
        {
            let itemAnnot = typeAnnot(sliceItem);

            include("<fu/view.h>");
            if (type.quals & q_mutref)
                return "fu::view_mut<" ~ itemAnnot ~ ">";
            else
                return "fu::view<" ~ itemAnnot ~ ">";
        }

        let mapPair = tryClear_map(type);
        if (mapPair)
        {
            let k = typeAnnot(mapPair.key);
            let v = typeAnnot(mapPair.value);

            include("<fu/map.h>");
            return "fu_MAP<" ~ k ~ ", " ~ v ~ ">";
        }

        //
        let tdef = lookupStruct(type) || fail("TODO: " ~ type.canon);
        let id   = structId(type);

        if (!_tfwd.has(c))
        {
            _tfwd[c] = "struct " ~ id ~ ";\n";
            _tdef ~= declareStruct(type, tdef);
        }

        return id;
    }

    fn structId(t: Type): string
    {
        for (mut i = 0; i < t.canon.len; i++)
        {
            let x = t.canon[i];
            if (x >= 'a' && x <= 'z' ||
                x >= 'A' && x <= 'Z' ||
                x == '_')
            {
                return "s_" ~ t.canon.slice(i);
                break;
            }
        }

        fail("Bad structId: `" ~ t.canon ~ "`.");
    }

    fn declareStruct(t: Type, s: Struct): string
    {
        let id = structId(t);

        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id
                ~ "\nstruct " ~ id ~ "\n{";

        mut indent = "\n    ";

        let fields = s.fields;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            def ~= indent ~ typeAnnot(field.type) ~ " " ~ ID(field.id) ~ ";";
        }

        def ~= "\n    explicit operator bool() const noexcept";
        def ~= "\n    {";
        def ~= "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            def ~= "\n            || " ~ ID(fields[i].id);

        def ~= "\n        ;";
        def ~= "\n    }";

        return def ~ "\n};\n                                #endif\n";
    }


    //

    fn collectDedupes(dedupes: Map(string, string), leadingNewline?: bool): string
    {
        return collectDedupes(dedupes.values(), :leadingNewline);
    }

    fn collectDedupes(mut values: string[], leadingNewline?: bool): string
    {
        if (!values.len)
            return "";

        mut out = leadingNewline ? "\n" : "";

        values.sort();
        for (mut i = 0; i < values.len; i++)
            out ~= values[i];

        return out;
    }

    fn valid_operator(str: string): string
    {
        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_')
            {
                return str.slice(0, i);
            }
        }

        return str;
    }

    fn valid_identifier(mut str: string): string
    {
        for (mut i = str.len; i --> 0; )
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_') continue;

            shadow let c = c.u32;
            let b0 = (c >> 0) & 0xf;
            let b1 = (c >> 4) & 0xf;

            fn hex(x: u32)
                x < 10 ? ('0'.u32 + x).byte
                       : ('A'.u32 + x).byte;

            str = str[0, i]
                ~ 'b' ~ b0.hex ~ b1.hex
                ~ str[i + 1, str.len];
        }

        return str;
    }

    fn cgRoot(shadow root: SolvedNode): string
    {
        let src    = cgStatements(root.items);
        let main   = cgMain();

        let header = collectDedupes(_libs)
                   ~ collectDedupes(_tfwd, leadingNewline: true)
                   ~ collectDedupes(_ffwd_src, leadingNewline: true)
                   ~               (_tdef)
                   ~ (_fdef && "\n#ifndef FU_NO_FDEFs\n" ~ _fdef ~ "\n#endif\n")
                   ;

        return header ~ src ~ main;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        if (_hasMain != 2)
            return "\n\nint main() { return fu_MAIN(); }\n";

        // Main with cli args.
        annotateString();

        return "\n\nint main(int argc, char* argv[])"
            ~  "\n{"
            ~  "\n    fu_VEC<fu_STR> args;"
            ~  "\n    args.reserve(argc);"
            ~  "\n"
            ~  "\n    for (int i = 0; i < argc; i++)"
            ~  "\n        args.push(fu_TO_STR(argv[i]));"
            ~  "\n"
            ~  "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args));"
            ~  "\n}\n";
    }


    //

    fn localID(target: Target, overload: Overload)
    {
        let ok = ID(overload.name);
        if (target.modid == module.modid && overload.local_of == _current_fn_index)
            return ok;

        return ok ~ "_0";
    }

    fn ID(id: string): string
    {
        if (id == "this")       return "tHis";
        if (id == "struct")     return "sTruct";
        if (id == "default")    return "dEfault";
        if (id == "template")   return "tEmplate";
        if (id == "try")        return "tRy";
        if (id == "catch")      return "cAtch";
        if (id == "not")        return "nOt";
        if (id == "and")        return "aNd";
        if (id == "or")         return "oR";
        if (id == "int")        return "iNt";
        if (id == "char")       return "cHar";
        if (id == "short")      return "sHort";
        if (id == "long")       return "lOng";
        if (id == "signed")     return "sIgned";
        if (id == "unsigned")   return "uNsigned";
        if (id == "assert")     return "aSsert";

        return id;
    }

    fn cgStatements(nodes: SolvedNode[]): string
    {
        mut src = "";

        let lines = cgNodes(nodes, M_STMT);
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src ~= _indent ~ line ~ (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn blockWrap(nodes: SolvedNode[], skipCurlies?!: bool, gnuStmtExpr?!: bool): string
    {
        let indent0 = _indent;
        _indent ~= "    ";

        let open  = gnuStmtExpr ? "(__extension__ ({" : "{";
        let close = gnuStmtExpr ? "}))" : "}";

        mut src = cgStatements(nodes);
        if (!skipCurlies || nodes.len != 1 || nodes[0].kind != "return" && nodes[0].kind != "call")
            src = indent0 ~ open ~ src ~ indent0 ~ close;

        _indent = indent0;
        return src;
    }

    fn blockWrapSubstatement(node: SolvedNode): string
    {
        return node.kind != "block" ? blockWrap([ node ], skipCurlies: true)
             : node.items.len == 1  ? blockWrapSubstatement(node.items[0])
                                    : cgBlock(node, M_STMT);
    }

    fn cgBlock(block: SolvedNode, mode: i32): string
    {
        mut expr = !(mode & M_STMT);
        if (expr)
        {
            fn isExpr(node: SolvedNode)
                node.kind == "call";

            mut ok = true;
            for (mut i = 0; i < block.items.len; i++)
            {
                if (!block.items[i].isExpr)
                {
                    ok = false;
                    break;
                }
            }

            if (ok)
                return cgParens(block);
        }

        return blockWrap(block.items, gnuStmtExpr: !(mode & M_STMT));
    }

    fn cgParens(node: SolvedNode): string
    {
        let items = cgNodes(node.items);
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= ", ";
            if (i < items.len - 1)
                src ~= "(void)";

            src ~= items[i];
        }

        return src ~ ")";
    }

    fn cgDefer(node: SolvedNode): string
    {
        include("<fu/defer.h>");

        return "fu_DEFER(" ~ cgNode(node.items.only) ~ ")";
    }


    //

    fn cgFnSignature(fn: SolvedNode): string
    {
        let items   = fn.items;
        let ret     = items[items.len + FN_RET_BACK] || fail();

        let lambda  = false;

        let annot   = typeAnnot(
            ret.type || fail(),
            M_RETVAL | (lambda ? M_LAMBDA : 0));

        let overload = GET(fn.target);

        mut id = overload.name;
        if (id == "main" && !lambda)
        {
            _hasMain = fn.items.len + FN_ARGS_BACK ? 2 : 1;
            id = "fu_MAIN";
        }

        mut src = lambda
                ? "const auto& " ~ id ~ " = [&]("
                : annot ~ " " ~ id ~ "(";

        if (overload.flags & F_OPERATOR)
            src = annot ~ " operator" ~ id.valid_operator ~ "(";

        if (!lambda)
        {
            let linkage = (overload.type.is_never  && "[[noreturn]] ")
                        ~ (  fn.flags & F_TEMPLATE && "inline ")
                        ~ (!(fn.flags & F_PUB)     && "static ");

            src = linkage ~ src;
        }

        mut needComma = 0;

        for (mut i = 0; i < overload.closes_over.len; i++)
        {
            if (needComma++)
                src ~= ", ";

            let o = GET(Target(
                modid: module.modid,
                index: overload.closes_over[i]));

            src ~= typeAnnot(o.type) ~ " " ~ ID(o.name) ~ "_0";
        }

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (needComma++)
                src ~= ", ";

            src ~= binding(items[i] || fail());
        }

        if (overload.flags & F_POSTFIX)
        {
            overload.flags & F_OPERATOR || assert();
            src ~= ", /*postfix*/int ";
        }

        src ~= lambda
             ? ") -> " ~ annot
             : ")";

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        if !(_ffwd.add_once(target))
            return;

        let id      = overload.name || fail();
        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let isOp    = overload.flags & F_OPERATOR;

        let name    = isOp ? "operator" ~ id.valid_operator : id;
        let linkage = (overload.type.is_never  && "[[noreturn]] ")
                    ~ (overload.flags & F_TEMPLATE && "inline ")
                  ~ (!(overload.flags & F_PUB)     && "static ");

        mut src = linkage ~ annot ~ " " ~ name ~ "(";

        mut needComma = 0;

        for (mut i = 0; i < overload.closes_over.len; i++)
        {
            if (needComma++)
                src ~= ", ";

            let o = GET(Target(
                modid: module.modid,
                index: overload.closes_over[i]));

            src ~= typeAnnot(o.type);
        }

        let args = overload.args;
        for (mut i = 0; i < args.len; i++)
        {
            if (needComma++)
                src ~= ", ";

            src ~= typeAnnot(args[i].type, M_ARGUMENT | M_FWDECL);
        }

        src ~= ");\n";

        _ffwd_src ~= src;

        return;
    }

    fn ensureFnDef(target: Target, overload: Overload)
    {
        target.modid == module.modid || fail("BAD MODID");
        if !(_idef.add_once(target.index))
            return;

        // Go!
        let node = overload.solved;
        node.kind == "fn" || fail("ensureFnDef non-fn");
        cgFn(node, M_STMT);
    }


    //

    fn cgFnDef(fndef: SolvedNode, mode: i32): string
    {
        let o = GET(fndef.target);
        let n = o.solved;
        if !(n.flags & F_PUB)
            return "";

        n.kind == "fn" || fail("cgFnDef non-fn");
        return cgFn(n, mode);
    }

    fn cgFn(fn: SolvedNode, mode: i32): string
    {
        //////////////////////
        let indent0 = _indent;
        //////////////////////

        let lambda = false;
        if (!lambda)
            _indent = "\n";

        //
        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK];

        let overload = GET(fn.target);
        let id = overload.name;

        // Custom __natives.
        if (!body)
            return mode & M_STMT ? "\n// fn " ~ id ~ " has no body.\n" : "0";

        // TODO is this needed?
        //  Body should always be a block.
        mut src = cgFnSignature(fn);
        {
            ////////////////////////////////////////////
            let current_fn_index0 = _current_fn_index;
            defer _current_fn_index = current_fn_index0;

            _current_fn_index = fn.target.index;
            ////////////////////////////////////////////

            body.kind == "block" || fail("cgFn: body indeed not a block.");
            // if (body.kind == "block")
                src ~= cgBlock(body, M_STMT);
            // else
            //     src ~= blockWrap([ body ]);
        }

        // Consider a fwdannot after outputting body,
        //  it could itself have written to _fdef.
        if (!lambda && _fdef.has(id || fail()))
            ensureFwdDecl(fn.target);

        //////////////////
        _indent = indent0;
        //////////////////

        if (lambda)
            return src;

        let dedupe = fn.flags & F_PUB
                  && fn.flags & F_TEMPLATE
                  && overload.name.valid_identifier;

        if (dedupe)
            _fdef ~= "\n                                #ifndef DEFt_" ~ dedupe
                   ~ "\n                                #define DEFt_" ~ dedupe;

        _fdef ~= "\n" ~ src ~ "\n";

        if (dedupe)
            _fdef ~= "                                #endif\n";

        return mode & M_STMT ? "" : "0";
    }

    fn binding(node: SolvedNode, doInit = false, forceMut = false): string
    {
        let annot = typeAnnot(
            node.type, (node.flags & F_MUT == 0 && !forceMut ? M_CONST : 0)
                     | (node.flags & F_ARG == 0 ? 0 : M_ARGUMENT));

        if (node.flags & F_ARG && node.type.addroffn::type_isZST)
            return annot;

        let overload = GET(node.target);
        let id = overload.name || fail();

        let head = (annot || fail()) ~ " " ~ ID(id);
        let init = node.items ? node.items[LET_INIT] : SolvedNode;

        if (!doInit || (node.flags & F_ARG))
            return head;

        if (init)
        {
            // Cleaner copy-init setup,
            //  the default is super-verbose.
            if (init.kind == "copy" && !(node.type.quals & q_ref))
            {
                let expr = cgNode(init.items.only);
                if (node.type.quals & q_primitive)
                    return head ~ " = " ~ expr;

                return head ~ " { " ~ expr ~ " }";
            }

            // Definit.
            if (init.kind == "definit"
                    && !(init.type.quals & q_ref)
                    && init.type.vtype == node.type.vtype)
            {
                return head ~ " {}";
            }

            return head ~ " = " ~ cgNode(init);
        }

        return head ~ " {}";
    }

    fn cgLet(node: SolvedNode): string
    {
        return binding(node, doInit: true);
    }

    fn cgGlobal(node: SolvedNode): string
    {
        mut src = cgLet(node);

        // Nasty tempfix -
        //  can't have [&] in global space.
        src = src.replace(
            all: "([&](", with: "([](");

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        // Hide when possible.
        if (!(node.flags & F_PUB))
        {
            _fdef  ~= "\nstatic const " ~ src ~ ";\n";
        }
        else
        {
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\ninline const " ~ src ~ ";"
                    ~ "\n                                #endif\n";
        }

        //
        return "";
    }

    fn cgForeignGlobal(target: Target): void
    {
        if !(_ffwd.add_once(target))
            return;

        let o = GET(target);
        cgGlobal(o.solved);
    }

    fn cgReturn(node: SolvedNode): string
    {
        if (node.items)
        {
            let head = node.items[0] || fail();
            let src = cgNode(head);
            if (head.type.is_never)
                return src;

            return "return " ~ src;
        }

        return "return";
    }

    fn cgJump(node: SolvedNode): string
    {
        if (node.value)
            return "goto L_" ~ node.value ~ "_" ~ node.kind[0];

        return node.kind;
    }


    // TODO FIX BOTH

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";
            else if (c == '"')  esc ~= "\\\"";

            else                esc ~= c;
        }

        return "\"" ~ esc ~ "\"_fu";
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        // TODO FIX
        mut esc = "";
        for (mut i = 0; i < node.value.len; i++)
        {
            let c = node.value[i];

                 if (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";
            else if (c == '\'') esc ~= "\\'";

            else                esc ~= c;
        }

        return "std::byte('" ~ esc ~ "')";
    }


    //

    fn cgArrayLiteral(node: SolvedNode, mode: i32): string
    {
        if (node.target)
            return cgCall(node, mode);

        let items = cgNodes(node.items);
        if (!items.len)
            return cgDefault(node.type);

        let itemType = tryClear_array(node.type) || fail();
        let itemAnnot = typeAnnot(itemType);

        let arrayAnnot = typeAnnot(node.type);
        return arrayAnnot ~ " { " ~ arrayAnnot
            ~ "::INIT<" ~ items.len ~ "> { "
                ~ items.join(", ") ~ " } }";
    }

    fn cgDefaultInit(node: SolvedNode, mode: i32): string
    {
        return cgArrayLiteral(node, mode);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let target = GET(node.target) || fail();
        mut items  = cgNodes(node.items);

        // Builtin specs.
        if (target.kind == "__native" && target.template.node.items)
        {
            mut id = target.template.node.items[0].value;
            if (target.template.node.items.len > 1)
            {
                include(id);
                id = target.template.node.items[1].value;
            }

            if (id[0] == '.')
            {
                if (items.len > 1)
                    return items[0] ~ id ~ "(" ~ items.slice(1).join(", ") ~ ")";

                return items[0] ~ id;
            }

            if (items)
            {
                if (id.hasIdentifierChars)
                    return id ~ "(" ~ items.join(", ") ~ ")";

                return "(" ~ items[0] ~ " " ~ id ~ " " ~ items[1] ~ ")";
            }

            return id;
        }

        //
        if (target.kind == "defctor" || target.kind == "type")
        {
            if (!items)
                return cgDefault(target.type);

            target.type.isStruct || fail(
                "cgCall: defctor/type not a struct.");

            return typeAnnotBase(target.type) ~ " { " ~ items.join(", ") ~ " }";
        }

        let id = target.name || fail();

        if (target.kind == "global")
        {
            if (node.target.modid != module.modid)
                cgForeignGlobal(node.target);

            return ID(id); // TODO ensure const emit.
        }

        if (target.kind == "var" ||
            target.kind == "arg" ||
            target.kind == "ref")
        {
            return localID(node.target, target);
        }

        if (target.kind == "field")
        {
            return items[0] ~ "." ~ ID(id);
        }

        if (node.target.modid && target.kind == "fn")
        {
            if (target.solved.flags & F_TEMPLATE || !(target.solved.flags & F_PUB))
                ensureFnDef(node.target, target);
            else if (node.target.modid != module.modid)
                ensureFwdDecl(node.target);
        }

        if (target.flags & F_OPERATOR)
        {
            let nodes = node.items  || fail();
            let head  = nodes[0]    || fail();

            if (items.len == 1)
            {
                return node.flags & F_POSTFIX
                     ? items[0] ~ id.valid_operator
                     : id.valid_operator ~ items[0];
            }

            if (items.len == 2)
            {
                if (id == "[]")
                {
                    // The new cow_vec is here.
                    if (node.type.quals & q_mutref)
                        return items[0] ~ ".mutref(" ~ items[1] ~ ")";

                    return items[0] ~ "[" ~ items[1] ~ "]";
                }

                // This is hellish but should cover our asses for a little while -
                //  this is the `a[b]=c` instead of `a.at(b)=c` pattern.
                if (id == "=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                        {
                            return "(" ~ cgNode(head.items[0] || fail())
                                 ~ ".upsert(" ~ cgNode(head.items[1] || fail()) ~ ") = "
                                 ~ items[1] ~ ")";
                        }
                    }
                }

                // Conditional lazy assignment,
                //  notice again the special casing for std::maps.
                if (id == "||=")
                {
                    if (head.kind == "call" && head.value == "[]" && head.items.len == 2)
                    {
                        if (type_isMap((head.items[0] || fail()).type))
                            items[0] = cgNode(head.items[0] || fail())
                                     ~ ".upsert(" ~ cgNode(head.items[1] || fail()) ~ ")";
                    }

                    let annot = typeAnnot(head.type);

                    return "([&](" ~ annot ~ " _) -> " ~ annot
                         ~ " { if (!_) _ = " ~ items[1]
                         ~ "; return _; } (" ~ items[0] ~ "))";
                }

                // Collapse (a ~= b + c) into (a ~= b, a ~= c),
                //  totally surprised at how little if any impact this has.
                if (id == "~=")
                    if (type_isArray(head.type) && isFieldChain(node.items[0]))
                        if (node.items[1].value == "~" && node.items[1].type.canon == head.type.canon)
                            return cgAppend(node, items[0]);

                // Skip some of the ridiculous parens.
                if (mode & M_STMT)
                    return items[0] ~ " " ~ id.valid_operator ~ " " ~ items[1];
                else
                    return "(" ~ items[0] ~ " " ~ id.valid_operator ~ " " ~ items[1] ~ ")";
            }
        }

        if (id == "CLONE" && items.len == 1)
            return cgClone(node.type, items[0]);

        if (id == "STEAL" && items.len == 1)
            return cgSteal(items[0]);

        if (id == "SWAP" && items.len == 2)
            return cgSwap(items);

        if (id == "println")
            return cgPrint(items);

        id != "__native" || assert();

        mut closure = "";
        if (target.closes_over)
        {
            for (mut i = 0; i < target.closes_over.len; i++)
            {
                if (i)
                    closure ~= ", ";

                let t = Target(modid: module.modid, index: target.closes_over[i]);
                let o = GET(t);
                closure ~= localID(t, o);
            }

            if (items)
                closure ~= ", ";
        }

        return ID(id) ~ "(" ~ closure ~ items.join(", ") ~ ")";
    }

    fn cgAppend(node: SolvedNode, into: string): string
    {
        mut src = "(";
        cgAppend_visit(node.type.canon, into, node.items[1], src);
        src ~= ")";

        return src;
    }

    fn cgAppend_visit(
        canon: string, into: string,
        stuff: SolvedNode, src: &mut string)
    {
        if (stuff.kind != "call" || stuff.value != "~" || stuff.type.canon != canon || stuff.items.len != 2)
        {
            let val = cgNode(stuff);
            if (src.len > 1)
                src ~= ", ";

            src ~= into ~ " += " ~ val;
        }
        else
        {
            cgAppend_visit(canon, into, stuff.items[0], src);
            cgAppend_visit(canon, into, stuff.items[1], src);
        }
    }

    fn cgPrint(items: string[]): string
    {
        include("<iostream>");

        mut src = "(std::cout";
        for (mut i = 0; i < items.len; i++)
            src ~= " << " ~ items[i];

        src ~= " << '\\n')";
        return src;
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn cgLiteral(node: SolvedNode): string
    {
        mut src = node.value;

        if (node.type.quals & q_unsigned)
            if (!src.has('u'))
                src ~= 'u';

        if (node.type.quals & q_floating_pt)
        {
            if (!src.has('.'))
                src ~= ".0";

            if (node.type.canon == "f32")
            {
                if (src.has('x'))
                    src = "float(" ~ src ~ ")";
                else
                    src ~= "f";
            }
            else if (node.type.canon != "f64")
            {
                assert();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        // One of those paradoxes.
        if (src.len > 16)
        {
            let parse = intlit::Intlit(src);
            if (parse.negative && parse.absval == 0x8000000000000000)
                return "(-9223372036854775807-1)";
        }

        if (node.type.canon == "u64" || node.type.canon == "i64")
            if (!src.has('l'))
                src ~= "ll";

        return src;
    }

    fn cgEmpty(mode: i32): string
    {
        return mode & M_STMT ? "" : "0";
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(shadow node: SolvedNode)
            node.kind == "if"
                ? " " ~ cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL);
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return "if (" ~ cond ~ ")" ~ cons ~ (alt ? _indent ~ "else" ~ alt : "");

        if (cons && alt)
            return "(" ~ cond ~ " ? " ~ cons ~ " : " ~ alt ~ ")";

        if (cons)
            return "(" ~ cond ~ " && " ~ cons ~ ")";

        if (alt)
            return "(" ~ cond ~ " || " ~ alt ~ ")";

        return fail("TODO cgIf no const/alt");
    }


    //

    fn cgDefault(type: Type): string
    {
        type.quals & q_mutref && fail("Cannot definit mutrefs.");

        if (type.quals & q_ref)
        {
            include("<fu/default.h>");

            return "fu::Default<" ~ typeAnnot(clear_refs(type)) ~ ">::value";
        }

        return typeAnnot(type) ~ "{}";
    }

    fn cgAnd(node: SolvedNode): string
    {
        let type = node.type;
        if (!type.is_bool)
        {
            let items = node.items;

            let retSecondLast = items[items.len - 1].type.is_never;

            let condEnd = retSecondLast
                        ? items.len - 2
                        : items.len - 1;

            mut src = "";

            if (condEnd)
            {
                src ~= "if (";

                for (mut i = 0; i < condEnd; i++)
                {
                    let item = items[i];
                    if (i) src ~= " && ";
                    src ~= cgNode(item, M_RETBOOL);
                }

                src ~= ") ";
            }

            let tail = cgNode(items[condEnd]);

            if (retSecondLast)
            {
                src ~= "{ " ~ typeAnnot(type) ~ " _ = " ~ tail ~ "; ";
                src ~= "if (!_) return _; } ";
                src ~= cgNode(items[items.len - 1]) ~ ";"; //FAIL
            }
            else
            {
                src ~= "return " ~ tail ~ ";"; //TRUTHY
                src ~= " else return " ~ cgDefault(type) ~ ";";
            }

            src = "([&]() -> " ~ typeAnnot(type) ~ " { " ~ src ~ " }())";

            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];

            if (i) src ~= " && ";
            src ~= cgNode(item, M_RETBOOL);
        }

        return src ~ ")";
    }

    fn cgNot(node: SolvedNode): string
    {
        let item = node.items[0];
        return "!" ~ cgNode(item, M_RETBOOL);
    }

    fn cgOr(node: SolvedNode): string
    {
        // [gnu] Consider:
        //  (__extension__ (a ?: b))

        let type = node.type;
        if (!type.is_bool)
        {
            // Try a ?: chain.
            mut ternary = true;
            for (mut i = 0; i < node.items.len - 1; i++)
            {
                if (!isFieldChain(node.items[i]))
                {
                    ternary = false;
                    break;
                }

                if (ternary)
                {
                    mut src = "(";
                    for (shadow mut i = 0; i < node.items.len - 1; i++)
                    {
                        let n = node.items[i];
                        let item = cgNode(n);
                        src ~= item ~ " ? " ~ item ~ " : ";
                    }

                    src ~= cgNode(node.items[node.items.len - 1]) ~ ")";
                    return src;
                }
            }

            //
            let annot = typeAnnot(type);

            mut src = "([&]() -> " ~ annot ~ " {";

            let items = node.items;
            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    shadow let items = item.items;
                    tail = items[items.len - 1] || fail();

                    src ~= " if (";
                    for (shadow mut i = 0; i < items.len - 1; i++)
                    {
                        if (i)
                            src ~= " && ";

                        src ~= cgNode(items[i] || fail(), M_RETBOOL);
                    }

                    src ~= ")";
                }

                src ~= " { " ~ annot ~ " _ = " ~ cgNode(tail) ~ "; if (_) return _; }";
            }

            let tail = items[items.len - 1] || fail();
            if (!tail.type.is_never)
                src ~= " return";

            src ~= " " ~ cgNode(tail) ~ "; }())";
            return src;
        }

        mut src = "(";
        let items = node.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (i) src ~= " || ";
            src ~= cgNode(item, M_RETBOOL);
        }

        return src ~ ")";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var"     ||
            t.kind == "global"  ||
            t.kind == "arg"     ||
            t.kind == "ref")
        {
            return true;
        }

        return false;
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        src[src.len - 1] == '}' || fail();
        return src.slice(0, src.len - 1) ~ postfix ~ '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_post = items[LOOP_POST];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];

        let init = n_init && cgNode(n_init, M_STMT);
        let cond = n_cond && cgNode(n_cond, M_RETBOOL);
        let post = n_post && cgNode(n_post, M_STMT);
        mut body = n_body && blockWrapSubstatement(n_body);
        let pcnd = n_pcnd && cgNode(n_pcnd, M_RETBOOL);
        mut breakLabel = "";

        if (body && node.value)
        {
            let brk = "L_" ~ node.value ~ "_b";
            let cnt = "L_" ~ node.value ~ "_c";

            if (body.has(cnt))
                body = "{" ~ postfixBlock(body, _indent ~     "    }" ~ cnt ~ ":;");
            if (body.has(brk))
                breakLabel = _indent ~ "    " ~ brk ~ ":;";
        }

        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" ~ body ~ _indent ~ "while (" ~ pcnd ~ ")" ~ breakLabel;
        }

        if (init || post || !cond)
            return "for (" ~ init ~ "; " ~ cond ~ "; " ~ post ~ ")" ~ body ~ breakLabel;

        return "while (" ~ cond ~ ")" ~ body ~ breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;

        let let_main    = items[0];
        let let_init    = cgNode(items[0].items[LET_INIT]);
        let err_id      = items[1].value;
        let catch_body  = blockWrapSubstatement(items[2]);

        mut src =        binding(let_main, forceMut: true) ~ ";";
        src ~= _indent ~ "try";
        src ~= _indent ~ "{";
        src ~= _indent ~ "    " ~ let_main.value ~ " = " ~ let_init ~ ";";
        src ~= _indent ~ "}";
        src ~= _indent ~ "catch (const std::exception& o_0)";
        src ~= _indent ~ "{";
        src ~= _indent ~ "    const " ~ annotateString() ~ "& " ~ err_id ~ " = fu_TO_STR(o_0.what());";
        src ~= _indent ~ catch_body;
        src ~= _indent ~ "}\n";

        return src;
    }

    fn cgTryCatch(node: SolvedNode): string
    {
        let items = node.items;
        let try = blockWrapSubstatement(items[0]);

        let err = items[1];
        let catch = blockWrapSubstatement(items[2]);

        mut src: string;

        src ~= _indent ~ "try";
        src ~= _indent ~ "{";
        src ~= _indent ~ try;
        src ~= _indent ~ "}";
        src ~= _indent ~ "catch (const std::exception& o_0)";
        src ~= _indent ~ "{";
        src ~= _indent ~ "    const " ~ annotateString() ~ "& " ~ ID(GET(err.target).name) ~ " = fu_TO_STR(o_0.what());";
        src ~= _indent ~ catch;
        src ~= _indent ~ "}\n";

        return src;
    }


    //

    fn cgNode(node: SolvedNode, mode: i32 = 0): string
    {
        let k = node.kind;

        if (k == "call")        return cgCall(node, mode);
        if (k == "return")      return cgReturn(node);
        if (k == "break")       return cgJump(node);
        if (k == "continue")    return cgJump(node);
        if (k == "let")         return cgLet(node);
        if (k == "global")      return cgGlobal(node);
        if (k == "if")          return cgIf(node, mode);
        if (k == "!")           return cgNot(node);
        if (k == "or")          return cgOr(node);
        if (k == "and")         return cgAnd(node);
        if (k == "loop")        return cgLoop(node);
        if (k == "int")         return cgLiteral(node);
        if (k == "real")        return cgLiteral(node);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node, mode);
        if (k == "definit")     return cgDefaultInit(node, mode);

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node, mode);
        if (k == "parens")      return cgParens(node);
        if (k == "label")       return cgParens(node);

        if (k == "fndef")       return cgFnDef(node, mode);
        if (k == "fn")          return cgFn(node, mode);
        if (k == "struct")      return cgEmpty(mode);
        if (k == "empty")       return cgEmpty(mode);
        if (k == "defer")       return cgDefer(node);

        if (k == "copy")        return cgCopyMove(node);
        if (k == "move")        return cgCopyMove(node);
        if (k == "nrvo")        return cgCopyMove(node);
        if (k == "catch")       return cgCatch(node);
        if (k == "try")         return cgTryCatch(node);

        return fail("TODO: " ~ k);
    }


    //

    fn cgCopyMove(node: SolvedNode): string
    {
        let a = cgNode(node.items[0] || fail());

        if (node.kind == "nrvo")
            return a;

        if (node.kind == "move")
            return cgSteal(a);

        return cgClone(node.type, a);
    }

    fn cgSteal(src: string): string
    {
        include("<utility>");
        return "std::move(" ~ src ~ ")";
    }

    fn cgSwap(items: string[]): string
    {
        include("<utility>");
        return "std::swap(" ~ items.join(", ") ~ ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) ~ "(" ~ src ~ ")";
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0): string[]
    {
        mut result: string[] = [];

        for (mut i = 0; i < nodes.len; i++)
        {
            let node  = nodes[i];
            let src   = node ? cgNode(node, mode) : "";

            result.push(src);
        }

        return result;
    }


    //

    root.kind == "root" || fail();

    let src = cgNode(root);
    return src;
}
