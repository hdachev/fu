import helpers;
import parser;
import types;
import quals;
import scope;
import context;
import bitset;
import cpp;
import module;
import structs;
import fail;

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_RETURN            = 1 << 5;
let M_FWDECL            = 1 << 6;
let M_PARENS            = 1 << 7;
let M_OPT_CURLIES       = 1 << 8;
let M_LOOP_BODY         = 1 << 9;
let M_MUTVAR            = 1 << 10;
let M_MOVABLE           = 1 << 11;
let M_MOVE              = 1 << 12;


//

type BitSet2D = bitset::BitSet[];

fn add_once(ref bs: BitSet2D, i: i32, j: i32): bool
{
    return bs
        .grow_if_oob(i)
        .add_once(j);
}

fn add_once(ref bs: BitSet2D, target: Target): bool
{
    return bs.add_once(target.modid, target.index);
}

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    root: SolvedNode): CodegenOutput
{
    mut _libs: string[];

    mut _tfwd: BitSet2D;
    mut _tfwd_src: string[];

    mut _ffwd: BitSet2D;
    mut _ffwd_src: string[];

    mut _moveFromConstRefHelpers: BitSet2D;

    mut _idef: bitset::BitSet;
    mut _tdef: string;
    mut _fdef: string;

    mut _indent: string = "\n";
    mut _hasMain: i32;

    mut _unity:         i32[];
    mut _unity_because: i32[];

    let implicit mut _here: TokenIdx;


    //

    struct cg_Blockval
    {
        label: Target;
        ptrflip: bool;
    };

    struct cg_CurrentFn // TODO FIX postfix/prefix non-pub symbols?
    {                   //  Or prefix structs with module name?
        using target:   Target;

        numTEMPVARs?:   i32;
        TEMPVARs?:      string[];

        blockvals?:     cg_Blockval[];

        can_break?:     Target;
        can_cont?:      Target;

        _ids_used?:     string[];
        _ids_dedupe?:   i32[];
    };

    struct TEMPVAR { annot?: string; id?: string; ptrflip?: bool; };

    mut _current_fn: cg_CurrentFn;

    using fn GET(target: Target)
    {
        target.index > 0 || assert();

        if (target.modid < 0)
            return module.out.solve.scope.extended[-target.modid - 1].locals[target.index - 1];

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn try_GET(target: Target)
    {
        return target && GET(target);
    }

    using fn EXT(target: Target)
    {
        if (target.modid == module.modid)
            return module.out.solve.scope.extended.unless_oob(target.index - 1);

        if (target.modid < 0)
            return [];

        return ctx.modules[target.modid]
            .out.solve.scope.extended.unless_oob(target.index - 1);
    }

    using fn SolvedNodeData(nid: SolvedNode)
    {
        return nid.nodeown
            && nid.nodeown.EXT.nodes[nid.nodeidx];
    }


    //

    fn fail(mut reason = "")
    {
        FAIL("THIS IS A COMPILER BUG.\n\n\tCODEGEN FAIL:\n\n\t" ~ (reason || "Assertion failed."));
    }


    //

    fn include(lib: string)
    {
        _libs.set::add(lib);
    }


    //

    fn typeAnnot(type: Type, mode: i32 = 0): string
    {
        if (type.addroffn::type_isZST)
            return "int";

        let fwd = typeAnnotBase(type, :mode);

        if (type.is_ref)
        {
            if (fwd.starts(with: "fu::view"))
                return fwd;

            if (type.is_mutref)
                return fwd ~ "&";

            // Pass primitives by value.
            if (type.is_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " ~ fwd
                     : fwd;

            // Enable move from local.
            //
            //  let a = ...     // Some a = ...
            //  let b = a.b;    // B& b = a.b;      // const B& wouldn't allow move
            //  return b;       // return move(b);  // here
            //
            if (mode & M_MOVABLE)
            {
                // Only useful if current fn returns a nontriv value.
                //  We could notice current fn does a move-return.
                //   Ideally we would actually know the dependecy chain
                //    so we'll only do this if really needed for this variable.
                //
                let fnret = GET(Target(:module.modid, index: _current_fn.index)).type;
                if !(fnret.is_trivial || fnret.is_ref)
                    return fwd ~ "&";
            }

            return "const " ~ fwd ~ "&";
        }

        if ((mode & M_ARGUMENT) && !(type.is_primitive))
            return fwd ~ "&&";

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.is_trivial))
            return "const " ~ fwd;

        return fwd;
    }

    fn typeAnnotBase(type: Type, mode?: i32): string
    {
        let c = type.canon;

        if (type.is_primitive)
        {
            // Avoid #include noise when possible.
            if (c == "i32")     return "int";
            if (c == "i16")     return "short";
            if (c == "u32")     return "unsigned";

            if (c == "bool")    return "bool";

            if (c == "f32")     return "float";
            if (c == "f64")     return "double";

            // Narrow charascter types. TODO: byte!
            if (c == "i8" || c == "u8" || c == "byte")
            {
                include("<fu/int.h>");
                return "fu::" ~ c;
            }

            // Tough luck.
            include("<cstdint>");

            if (c == "i64")     return "int64_t";

            if (c == "u16")     return "uint16_t";
            if (c == "u32")     return "uint32_t";
            if (c == "u64")     return "uint64_t";

            fail("Unknown primitive.");
        }

        if (c == "void")   return "void";
        if (c == "never")  return annotateNever();

        // TODO FIX slice definit - (arg?: [byte]) somehow manages to drop ref on definit.
        let arrayItem = tryClear_sliceable(type);
        if (arrayItem)
        {
            // Arrays & strings.
            if (type.type_isArray || !type.is_ref)
            {
                if (arrayItem == t_byte)
                    return annotateString();

                let itemAnnot = typeAnnot(arrayItem);

                include("<fu/vec.h>");
                return "fu_VEC<" ~ itemAnnot ~ ">";
            }

            //
            let itemAnnot = typeAnnot(arrayItem);

            include("<fu/view.h>");
            if (type.is_mutref || mode & M_MUTVAR)
                return "fu::view_mut<" ~ itemAnnot ~ ">";
            else
                return "fu::view<" ~ itemAnnot ~ ">";
        }

        //
        let s   = lookupStruct(type) || fail("TODO: " ~ type.canon);
        let id  = "s_" ~ s.name;

        if (_tfwd.add_once(type.modid, type.canon.structIndex))
        {
            _tfwd_src ~= "struct " ~ id ~ ";\n";
            let decl = declareStruct(id, type, s);
            _tdef ~= decl;
        }

        return id;
    }

    fn declareStruct(id: string, t: Type, s: Struct): string
    {
        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id
                ~ "\nstruct " ~ id ~ "\n{";

        mut indent = "\n    ";

        let fields = s.items;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = GET(fields[i].target);
            field.kind == "field" || fail("Non-field struct item: " ~ field.name ~ " (" ~ field.kind ~ ") in " ~ t.canon);
            def ~= indent ~ typeAnnot(field.type) ~ " " ~ ID(field.name) ~ ";";
        }

        if !(t.is_rx_copy)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
        }
        else if (try_GET(s.target).status & SS_TYPE_RECUR)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = default;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "& selfrec) { return *this = " ~ id ~ "(selfrec); }";
        }

        def ~= "\n    explicit operator bool() const noexcept";
        def ~= "\n    {";
        def ~= "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            def ~= "\n            || " ~ ID(fields[i].id);

        def ~= "\n        ;";
        def ~= "\n    }";

        return def ~ "\n};\n                                #endif\n";
    }


    //

    fn collectDedupes(mut values: string[], prefix: string, suffix = "\n"): string
    {
        if (!values.len)
            return "";

        mut out = "\n";

        values.sort();
        for (mut i = 0; i < values.len; i++)
            out ~= prefix ~ values[i] ~ suffix;

        return out;
    }

    fn collectDedupes(mut values: string[]): string
    {
        if (!values.len)
            return "";

        mut out = "\n";

        values.sort();
        for (mut i = 0; i < values.len; i++)
            out ~= values[i];

        return out;
    }

    fn valid_operator(str: string): string
    {
        mut start = 0;
        mut some  = false;

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_')
            {
                if (!some)
                    start = i + 1;
                else
                    return str.slice(start, i);
            }
            else
            {
                some = true;
            }
        }

        return start ? str.slice(start) : str;
    }

    fn hex(x: u32)
        x < 10 ? ('0'.u32 +  x      ).byte
               : ('A'.u32 + (x - 10)).byte;

    fn xHH(c: u32) "x"
        ~ ((c >> 4) & 0xf).hex
        ~ ((c >> 0) & 0xf).hex;

    fn valid_identifier(mut str: string): string
    {
        for (mut i = str.len; i --> 0; )
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_') continue;

            str = str[0, i]
                ~ c.u32.xHH
                ~ str[i + 1, str.len];
        }

        return ID(str);
    }

    fn cgRoot(shadow root: SolvedNode): string
    {
        mut count: i32;
        let src    = cgStatements(root.items, :count);
        let main   = cgMain();

        let header = collectDedupes(_libs, prefix: "#include ")
                   ~ collectDedupes(_tfwd_src)
                   ~ collectDedupes(_ffwd_src)
                   ~               (_tdef)
                   ~ (_fdef && "\n#ifndef FU_NO_FDEFs\n" ~ _fdef ~ "\n#endif\n")
                   ;

        return header ~ src ~ main;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        if (_hasMain != 2)
            return "\n\nint main() { return fu_MAIN(); }\n";

        // Main with cli args.
        annotateString();

        return "\n\nint main(int argc, char* argv[])"
            ~  "\n{"
            ~  "\n    fu_VEC<fu_STR> args;"
            ~  "\n    args.reserve(argc);"
            ~  "\n"
            ~  "\n    for (int i = 0; i < argc; i++)"
            ~  "\n        args.push(fu_TO_STR(argv[i]));"
            ~  "\n"
            ~  "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args));"
            ~  "\n}\n";
    }


    //

    fn localID(target: Target, dedupe?: bool)
    {
        let o  = GET(target);
        mut id = o.name;

        // CLOSURE-ID-HACK
        let t = hacks::tryParseClosureID(:id, :MODID);
        if (t)
            id = GET(t).name;
        // CLOSURE-ID-HACK

        id = ID(id);

        if (o.local_of)
        {
            fn _ids_dedupe  = _current_fn._ids_dedupe;
            fn _ids_used    = _current_fn._ids_used;

            // Dedupe #1.
            if (dedupe)
            {
                mut dupes = 0;

                REPEAT:
                for (;;)
                {
                    let candidate = dupes
                        ? id ~ '_' ~ dupes
                        : id;

                    for (mut i = 0; i < _ids_used.len; i++)
                    {
                        if (_ids_used[i] == candidate)
                        {
                            dupes++;
                            continue :REPEAT;
                        }
                    }

                    _ids_used ~= candidate;
                    break;
                }

                if (dupes)
                    _ids_dedupe.grow_if_oob(target.index) = dupes;
            }

            // Dedupe #2.
            let dupes = _ids_dedupe.len > target.index && _ids_dedupe[target.index];
            if (dupes)
                return id ~ '_' ~ dupes;
        }

        return id;
    }


    //

    fn cgStatements(nodes: SolvedNode[], ref count!: i32, trail?!: string): string
    {
        let lines = cgNodes(nodes, M_STMT, :trail, debug: "cgStatements");
        count = lines.len;

        mut src = "";
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src ~= (line.if_first == '\n' ? '\n' ~ line : _indent ~ line)
                     ~ (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn cgComma(nodes: SolvedNode[], debug!: string): string
    {
        shadow let items = cgNodes(nodes, debug: debug ~ ".cgComma");
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= ", ";
            if (i < items.len - 1)
                src ~= "(void)";

            src ~= items[i];
        }

        return src ~ ")";
    }


    //

    fn blockWrapSubstatement(node: SolvedNode, mode?: i32): string
        cgBlock(node, mode: M_STMT | M_OPT_CURLIES | mode, debug: "blockWrapSubstatement");

    fn cgBlock(node: SolvedNode, mode: i32, debug!: string): string
    {
        let items = node.kind == "block"  ? node.items : [ node ];
        let label = node.kind == "block" && node.target;

        ///////////////////////////////////////////
        if (mode & M_LOOP_BODY)
            _current_fn.can_cont = label;
        ///////////////////////////////////////////

        // We'll try to avoid block expressions as much as we can.
        //  Instead of these loops it'd be nice if we knew all this stuff
        //   as node flags or something, or a jumpset or something:
        //      - if expressible as cpp expr (none of the below stuff),
        //      - if wrappable in a cpp lambda (no jumping up), etc.
        //
        fn exprOK(nodes: [SolvedNode])
        {
            for (mut i = 0; i < nodes.len; i++)
            {
                let n = nodes[i];
                let k = n.kind;
                if (k == "jump" || k == "loop" || k == "try" || k == "catch"
                    || k == "let" || k == "block") // TODO FIX we can handle both of these
                {
                    return false;
                }

                if (k == "and" || k == "or" || k == "if")
                    if (!n.items.exprOK)
                        return false;
            }

            return true;
        }

        let expr = !(mode & M_STMT);
        if (expr && !label && items.exprOK)
            return cgComma(items, debug: debug ~ ".cgBlock");

        //
        return cgBlock(items, skipCurlies: !!(mode & M_OPT_CURLIES), gnuStmtExpr: expr, :label,
            type: expr && node.type);
    }

    fn cgBlock(nodes: SolvedNode[], skipCurlies!: bool, gnuStmtExpr!: bool, label!: Target, type: Type): string
    {
        ///////////////////////////////////////////////
        let _ids_used0 = _current_fn._ids_used.len;
        defer _current_fn._ids_used.shrink(_ids_used0);
        ///////////////////////////////////////////////

        //////////////////////
        let indent0 = _indent;
        defer _indent = indent0;
        //////////////////////
        _indent ~= "    ";

        let gnuOpen = gnuStmtExpr && "(__extension__ (";
        mut open    = "{";
        mut close   = gnuStmtExpr ? "}))" : "}";
        mut trail   = "";

        let lbl     = label && GET(label);
        let name    = lbl.name;

        // Blockvals! /////////////////////////////////
        let blockvals0  = _current_fn.blockvals.len;
        defer _current_fn.blockvals.shrink(blockvals0);
        ///////////////////////////////////////////////

        if (type && !type.is_void)
        {
            mut ptrflip = false;
            let annot   = typeAnnot(type);
            let id      = emitTEMPVAR(annot, :ptrflip, name && "L_" ~ name ~ "_v");

            // Blockvals! //////////////////////////////////////////////
            _current_fn.blockvals ~= cg_Blockval(:label, ptrflip);
            ////////////////////////////////////////////////////////////

            let out     = ptrflip ? "*" ~ id : cgMove(:type, id);
            close       = "(void)0;}), " ~ out ~ ")";

            trail       = id ~ " = ";
            if (ptrflip)
                trail  ~= "&";
        }

        //
        mut count: i32;
        mut src = cgStatements(nodes, :count, :trail);

        // Block label & retval.
        if (lbl.name)
        {
            let prefixed_id = "L_" ~ name;
            if (src.has("goto " ~ prefixed_id ~ ";")) // TODO FIX track label usage
            {
                close = "  } " ~ prefixed_id ~ ":;" ~ indent0 ~ close;
                open  = "{ {";
            }
        }

        //
        if (!skipCurlies || nodes.len != 1 || count != 1 || nodes[0].kind != "jump" && nodes[0].kind != "call")
            src = gnuOpen ~ indent0 ~ open ~ src ~ indent0 ~ close;

        return src;
    }

    fn cgDefer(node: SolvedNode): string
    {
        include("<fu/defer.h>");

        let which = node.value == "err" ? "fu_DEFER_IF_ERR"
                  : node.value == "ok"  ? "fu_DEFER_IF_OK"
                                        : "fu_DEFER";

        return which ~ "(" ~ cgNode(node.items.only, M_STMT, debug: "defer") ~ ")";
    }


    //

    fn isOp(target: Target)
    {
        let flags = target.flags;

        // Deal with it!
        //  We don't want to have subtle mismatches between the two,
        //   only assignment operators in c++ have guaranteed ooe,
        //    so it HAS to be an operator for this to hold.
        //
        if (flags & F_OOE_RTL)
            return true;

        if !(flags & F_OPERATOR)
            return false;

        let args = target.args;
        if (args.len > 2)
            return false;

        if (target.kind == "__native")
            return true;

        let name = target.name;
        if (args.len > 1)
            return cpp::hasBinary(name);

        if (flags & F_POSTFIX)
            return cpp::hasPostfix(name);

        return cpp::hasUnary(name);
    }

    fn fnID(target: Target)
    {
        let overload    = GET(target);
        let id          = overload.name || fail();

        return target.isOp  ? "operator" ~ id.valid_operator
                            :              id.valid_identifier;
    }

    fn fnLinkage(overload: Overload)
    {
        return    (  overload.type.is_never      && "[[noreturn]] ")
                ~ (  overload.flags & F_TEMPLATE && "inline "      )
                ~ (!(overload.flags & F_PUB)     && "static "      );
    }

    fn cgFnSignature(fn: SolvedNode): string
    {
        let target      = fn.target;
        let overload    = GET(target);

        let items       = fn.items;
        let annot       = typeAnnot(overload.type || fail(), M_RETVAL);

        //
        mut id          = overload.name;
        if (id == "main")
        {
            _hasMain    = fn.items.len + FN_ARGS_BACK ? 2 : 1;
            id          = "fu_MAIN";
        }
        else
        {
            id          = fnID(fn.target);
        }

        //
        mut src         = overload.fnLinkage ~ annot ~ " " ~ id ~ "(";

        for (mut i = 0; i < items.len + FN_ARGS_BACK; i++)
        {
            if (i)
                src ~= ", ";

            src ~= binding(items[i] || fail());
        }

        if (overload.flags & F_POSTFIX)
        {
            overload.flags & F_OPERATOR || assert();
            src ~= ", /*postfix*/int ";
        }

        src ~= ")";

        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        if !(_ffwd.add_once(target))
            return;

        ////////////////////////////////////////////
        mut current_fn0 = cg_CurrentFn(target: target);

        defer SWAP(_current_fn, current_fn0);
        SWAP(_current_fn, current_fn0);
        ////////////////////////////////////////////

        let ret     = overload.type || fail();
        let annot   = typeAnnot(ret, M_RETVAL);

        let name    = fnID(target);
        mut src     = overload.fnLinkage ~ annot ~ " " ~ name ~ "(";

        let args    = target.args;
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                src ~= ", ";

            src ~= typeAnnot(args[i].type, M_ARGUMENT | M_FWDECL);
        }

        if (overload.flags & F_POSTFIX)
        {
            overload.flags & F_OPERATOR || assert();
            src ~= ", /*postfix*/int ";
        }

        src ~= ");\n";

        _ffwd_src ~= src;

        return;
    }

    fn ensureFnDef(target: Target, overload: Overload)
    {
        target.modid == module.modid || fail(
            "ensureFnDef: fndef is needed outside of its original scope: "
                ~ target.modid ~ " vs " ~ module.modid ~ ": `"
                ~ overload.kind ~ " " ~ overload.name ~ "`.");

        if !(_idef.add_once(target.index))
            return;

        // Go!
        let node = overload.solved;
        node.kind == "fn" || fail("ensureFnDef non-fn");
        cgFn(node, M_STMT);
    }

    fn ensureMoveFromConstRefHelper(target: Target)
    {
        if (!_moveFromConstRefHelpers.add_once(target))
            return;

        let name    = fnID(target);
        let args    = target.args;

        let annot   = typeAnnot(clear_refs(target.type));
        mut src     = "inline " ~ annot ~ " " ~ name ~ "(";

        let items   = target.solved.items;
        let retargs = target.type.lifetime.uni0n;

        mut body    = "return static_cast<" ~ annot ~ "&&>(const_cast<" ~ annot ~ "&>(" ~ name ~ "(";

        for (mut i = 0; i < args.len; i++)
        {
            let argNode     = items[i] || fail();
            let argTarget   = argNode.target;

            //
            let forceValue  = retargs.has(Region_fromArgIndex(argTarget.index));
            let binding     = binding(argNode, :forceValue);

            // Split annot from id.
            mut space = -1;
            for (shadow mut i = binding.len; i --> 0; )
            {
                if (binding[i] == ' ')
                {
                    space = i;
                    break;
                }
            }

            space > 0 || fail("ensureMoveFromConstRefHelper: cant split annot/id.");

            mut pass = binding.slice(space + 1);
            if (!argNode.type.is_ref)
                pass = "static_cast<" ~ binding.slice(0, space) ~ "&&>(" ~ pass ~ ")";

            // Append to signature and forwarder.
            if (i)
            {
                src  ~= ", ";
                body ~= ", ";
            }

            src     ~= binding;
            body    ~= pass;
        }

        // Done!
        src ~= ")\n{\n    " ~ body ~ ")));\n}\n";

        _fdef ~= "\n" ~ src ~ "\n";
    }


    //

    fn cgFnDef(fndef: SolvedNode, mode: i32): string
    {
        let o = GET(fndef.target);
        let n = o.solved;
        if !(n && o.flags & F_PUB)
            return mode & M_STMT ? "" : "0";

        n.kind == "fn" || fail("cgFnDef non-fn");
        return cgFn(n, mode);
    }

    fn cgFn(fn: SolvedNode, mode: i32): string
    {
        //////////////////////
        let indent0 = _indent;
        defer _indent = indent0;
        //////////////////////

        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK];

        let overload = GET(fn.target);
        let id = overload.name;
        overload.status & SS_FINALIZED || fail("cgFn: fn not finalized: " ~ id);

        // Custom __natives.
        if (!body)
        {
            overload.kind == "__native" || fail("cgFn: no body on non-native: " ~ overload.kind ~ " " ~ id);
            return mode & M_STMT ? "" : "0";
        }

        _indent = "\n";

        // TODO is this needed?
        //  Body should always be a block.
        mut src: string;
        {
            ////////////////////////////////////////////
            mut current_fn0 = cg_CurrentFn(target: fn.target);

            defer SWAP(_current_fn, current_fn0);
            SWAP(_current_fn, current_fn0);
            ////////////////////////////////////////////

            src ~= cgFnSignature(fn);
            src ~= cgBlock(body, M_STMT, debug: "cgFn(" ~ id ~ ")");
        }

        // Consider a fwdannot after outputting body,
        //  it could itself have written to _fdef.
        if (_fdef.has(id || fail()))
            ensureFwdDecl(fn.target);

        let dedupe = overload.flags & F_PUB
                  && overload.flags & F_TEMPLATE
                  && overload.name.valid_identifier;

        if (dedupe)
            _fdef ~= "\n                                #ifndef DEFt_" ~ dedupe
                   ~ "\n                                #define DEFt_" ~ dedupe;

        _fdef ~= "\n" ~ src ~ "\n";

        if (dedupe)
            _fdef ~= "                                #endif\n";

        return mode & M_STMT ? "" : "0";
    }

    fn binding(node: SolvedNode, doInit?!: bool, forceMut?!: bool, forceValue?!: bool): string
    {
        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if !(_current_fn.index) SWAP(_tv0, _current_fn.TEMPVARs);
        defer {
            if !(_current_fn.index) SWAP(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        let overload = node.target && GET(node.target);

        let isArg = overload.flags & F_ARG;

        let node_type = forceValue
            ? clear_refs(node.type)
            : node.type;

        let annot = typeAnnot(
            node_type, (!forceMut && !overload.type.is_mutref && M_CONST)
                     | (isArg && M_ARGUMENT)
                     | (overload.type.is_mutref && M_MUTVAR)
                     | (overload.flags & F_MOVED_FROM && M_MOVABLE));

        if (!node.target)
            return annot;

        let isUnused = overload.flags & F_UNUSED;
        if (isArg && isUnused)
            return annot;

        let id      = localID(:node.target, dedupe: true);
        mut head    = (annot || fail()) ~ " " ~ id;

        if (isUnused)
            head    = "[[maybe_unused]] " ~ head;
        if (node.target.flags & F_TODO_FIX_RRET)
            head    = "/*RRET*/ " ~ head;
        if (node.target.flags & F_MOVED_FROM)
            head    = "/*MOV*/ " ~ head;

        if (!doInit || isArg)
            return head;

        let init    = node.items ? node.items[LET_INIT] : SolvedNode;
        if (init)
        {
            // Definit.
            if (init.kind == "definit" && !init.type.is_ref)
            {
                init.type == node.type || fail("what's this now");
                return head ~ " {}";
            }

            let isCopy = init.kind == "copy" && !node.type.is_ref;

            // A less verbose copy init.
            let expr = cgNode(debug: "binding(" ~ id ~ ")",
                isCopy  ? init.items.only
                        : init);

            // HACK - wrap in a lambda when we need temps here
            if (!_current_fn.index && _current_fn.TEMPVARs)
            {
                shadow let annot = annot.starts(with: "const ") ? annot.slice(6) : annot;
                shadow let expr  = isCopy ? cgClone(init, expr) : expr;

                shadow let iife  = " { []() -> " ~ annot ~ " {\n    " ~ _current_fn.TEMPVARs.join(";\n    ") ~ ";\n    return " ~ expr ~ ";\n}() }";
                _current_fn.TEMPVARs.clear();
                return head ~ iife;
            }

            // I think we can use curlies everywhere,
            //  here we make an exception for copy inits,
            //   but we skip primitives which doesn't make sense -
            //    curly init is BETTER for primitives because it prevents narrowing.
            //*/
            if (isCopy && !node.type.is_primitive)
                return head ~ " { " ~ expr ~ " }";

            return head ~ " = " ~ expr;
            /*/
            return head ~ " { " ~ expr ~ " }";
            //*/
        }

        return head ~ " {}";
    }

    fn cgLet(node: SolvedNode, global!: bool, foreign?: bool): string
    {
        if (node.type.addroffn::type_isZST)
            return "";

        // GLOBALS ///////////////////////////////////////////////
        fn isIntegerConstant(expr)
        {
            if (expr.kind == "int")
                return true;

            if (expr.kind == "call")
            {
                let t = GET(expr.target);
                if (t.kind == "__native" && t.flags & F_OPERATOR)
                {
                    for (mut i = 0; i < expr.items.len; i++)
                        if (!expr.items[i].isIntegerConstant)
                            return true;

                    return true;
                }
            }

            return false;
        }

        let intconst = global
            && node.type.is_primitive && !node.type.is_floating_pt
            && node.items[LET_INIT].isIntegerConstant;
        // GLOBALS ///////////////////////////////////////////////

        mut src = binding(node, doInit: !foreign || intconst);
        if (!global)
            return src;

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        // Hide when possible.
        if (!(GET(node.target).flags & F_PUB))
        {
            // We can't "forward declare" foreign private globals.
            if (!foreign)
                _fdef  ~= "\nstatic const " ~ src ~ ";\n";

            // But we can unity-build ourselves with them.
            else
                _unity.set::add_once(node.target.modid || fail(),
                    _unity_because, node.target.index);
        }
        else if (!intconst)
            _fdef  ~= "\nextern const " ~ src ~ ";\n";
        else
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\ninline constexpr " ~ src ~ ";"
                    ~ "\n                                #endif\n";

        return "";
    }

    fn cgForeignGlobal(target: Target): void
    {
        if !(_ffwd.add_once(target))
            return;

        let o = GET(target);
        cgLet(o.solved, global: true, foreign: true);
    }

    fn cgJump(node: SolvedNode): string
    {
        let dest_idx    = node.target;

        let use_return  = dest_idx == _current_fn.target;
        let dest        = GET(dest_idx);

        if (node.items)
        {
            let head    = node.items.only;

            // Break with value.
            if (!use_return)
            {
                mut hasval  = false;
                mut ptrflip = false;

                for (mut i = _current_fn.blockvals.len; i --> 0; )
                {
                    let bv = _current_fn.blockvals[i];
                    if (bv.label == dest_idx)
                    {
                        hasval = true;
                        ptrflip = bv.ptrflip;
                        break;
                    }
                }

                let assign = hasval && "L_" ~ dest.name ~ "_v = ";

                mut value = cgNode(head, !assign && M_STMT, debug: "cgJump[val.break]");
                if (ptrflip)
                    value = "&(" ~ value ~ ")";

                return "{ " ~ assign ~ value
                     ~ "; goto L_" ~ dest.name ~ "; }";
            }

            // [[noreturns]] shouldn't have return statements,
            //  but regular fns should return the output of [[noreturns]]
            //   for them to end on a return. It's a mess man.
            if (head.type.is_never)
            {
                if (dest.type.is_never)
                    return cgNode(head, M_STMT, debug: "cgJump[val.return.never]");

                if (dest.type.is_void)
                    return "return (void) " ~ cgNode(head, M_RETURN, debug: "cgJump[val.return.void]");
            }

            // I think the prefix keywords beat everything re: precedence.
            return "return " ~ cgNode(head, M_PARENS|M_RETURN, debug: "cgJump[val.return]");
        }

        //
        if (use_return)
            return "return";

        if (dest_idx == _current_fn.can_break)
            return "break";
        if (dest_idx == _current_fn.can_cont)
            return "continue";

        return "goto L_" ~ dest.name;
    }


    //

    fn escapeStringLiteral(str: [byte], quot: byte)
    {
        mut esc = [ quot ];

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];

            if      (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";

            // Misc sub-whitespace.
            else if (c.i8 < 32) esc ~= "\\" ~ c.u32.xHH;

            // Rest & quot.
            else
            {
                if (c == quot)
                    esc ~= '\\';

                esc ~= c;
            }
        }

        esc ~= quot;

        return esc;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        annotateString();

        mut esc = escapeStringLiteral(node.value, '"');
        esc ~= "_fu";
        return esc;
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        //*
        include("<fu/int.h>");
        return "fu::byte(" ~ escapeStringLiteral(node.value, '\'') ~ ")";
        /*/
        return escapeStringLiteral(node.value, '\'');
        //*/
    }


    //

    fn cgArrayLiteral(node: SolvedNode, mode: i32, callarg: Type): string
    {
        if (node.target)
            return cgCall(node, mode);

        let items = cgNodes(node.items, debug: "cgArrayLiteral");
        if (!items.len)
            return cgDefault(node.type);

        let curly = "{ " ~ items.join(", ") ~ " }";
        let itemT = typeAnnotBase(clear_sliceable(node.type));
        let slate = "fu::slate<" ~ items.len ~ ", " ~ itemT ~ "> " ~ curly;

        // fu::slate literals
        if (callarg.is_ref && !callarg.type_isArray)
        {
            include("<fu/view.h>");

            // Putting a comma around,
            //  because the `,` misparses in places like argument lists.
            return "(" ~ slate ~ ")";
        }

        return typeAnnotBase(node.type) ~ " { " ~ slate ~ " }";
    }

    fn cgDefinit(node: SolvedNode, mode: i32, callarg: Type): string
    {
        return cgArrayLiteral(node, mode, callarg);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn binSkipParens(id: string, mode: i32)
    {
        if (mode & M_STMT)
            return true;

        if (mode & M_PARENS)
        {
            if (id.last == '=')
            {
                // Clang errors on equality within parens in conditionals ...
                if (id == "==" || id == "!=")
                    return true;

                // ... and on naked equalities in conditionals.
                return false;
            }

            // Everything else is fine.
            return true;
        }

        return false;
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let ext             = node.target.EXT;
        let target          = GET(node.target) || fail();
        let args            = node.items;

        let isNative        = target.kind == "__native";
        let isCpyMovAssign  = args.len == 2 && isNative && target.name == "=";


        //

        let MUSTSEQ_mask    = node.helpers;
        mut ooe_crosscheck  = 0;
        mut ooe_header      = "";

        mut item_src: string[];
        for (mut i = 0; i < args.len; i++)
        {
            let arg = args[i];

            // Skip explicit copies on assignment, pointless.
            shadow let arg = isCpyMovAssign && i == 1 && arg.kind == "copy"
                ? arg.items.only
                : arg;

            mut src = cgNode(
                arg, callarg: ext.args[i].type,
                debug: "cgCall(" ~ node.value ~ ").ARG(" ~ i ~ ")");

            // Explicit sequencing.
            let MUSTSEQ_bit = 1 << (i & 31);
            if (MUSTSEQ_mask & MUSTSEQ_bit)
            {
                ooe_crosscheck |= MUSTSEQ_bit;

                if !(arg.isFieldChain)
                {
                    if (ooe_header)
                        ooe_header ~= ", ";
                    else
                        ooe_header = "(";

                    //
                    mut ptrflip = false;
                    let annot   = typeAnnot(arg);
                    let id      = emitTEMPVAR(:annot, :ptrflip);

                    ooe_header ~= id;
                    ooe_header ~= " = ";
                    ooe_header ~= ptrflip   ? "&(" ~ src ~ ")"
                                            : src;

                    src         = ptrflip   ? "*" ~ id
                                            : cgMove(arg.type, id);
                }
            }

            item_src ~= src;
        }

        ooe_crosscheck == node.helpers || fail(
            "OOE crosscheck failed: codegen sequenced " ~ ooe_crosscheck
                                ~ ", but solver wants " ~ node.helpers ~ ": "
                                ~ args.map(|i| i.kind).join("|"));

        fn ooeWrap(src: string)
        {
            return ooe_header
                 ? ooe_header ~ ", " ~ src ~ ")"
                 : src;
        }


        //

        fn REST(start: i32 = 0)
        {
            mut src = "";
            for (mut i = start; i < item_src.len; i++)
            {
                if (i > start)
                    src ~= ", ";

                src ~= item_src[i];
            }

            return src;
        }

        fn ARG(i: i32) item_src[i];


        //

        fn emitPostfixOp(op: string)
        {
            return ARG(0) ~ op;
        }

        fn emitPrefixOp(op: string)
        {
            return op ~ ARG(0);
        }

        fn emitBinaryOp(op: string)
        {
            args.len == 2 || fail("args.len != 2");

            if (binSkipParens(op, mode) && !ooe_header)
                return ARG(0) ~ " " ~ op ~ " " ~ ARG(1);

            return ooeWrap("(" ~ ARG(0) ~ " " ~ op ~ " " ~ ARG(1) ~ ")");
        }

        fn emitMethodCall(id: string)
        {
            return ooeWrap(ARG(0) ~ id ~ "(" ~ REST(1) ~ ")");
        }

        fn emitFunctionCall(id: string, open = "(", close = ")")
        {
            return ooeWrap(id ~ open ~ REST ~ close);
        }


        // Builtin specs.

        if (isNative && target.name[0] == '\n')
        {
            mut id = target.name.slice(1);

            let idx = id.find('\n');
            if (idx > -1)
            {
                include(id.slice(0, idx));
                id = id.slice(idx + 1);
            }

            if (id[0] == '.')
            {
                if (args.len > 1)
                    return emitMethodCall(id);  // X`.id`(a, b)

                return emitPostfixOp(id);       // X`.a`
            }

            if (id[0] == '/')
                return ooeWrap(emitBuiltin(id, item_src, node));

            if (args)
            {
                if (id.hasIdentifierChars)
                    return emitFunctionCall(id);

                return emitBinaryOp(id);
            }

            return id;
        }

        //
        if (target.kind == "type")
        {
            if (!args)
                return cgDefault(target.type);

            target.type.isStruct || fail(
                "cgCall: defctor/type not a struct.");

            //
            return emitFunctionCall(
                typeAnnotBase(target.type), " { ", " }");
        }

        if (node.target.modid && target.kind == "fn")
        {
            if (target.solved.flags & F_TEMPLATE || !(target.solved.flags & F_PUB))
                ensureFnDef(node.target, target);
            else if (node.target.modid != module.modid)
                ensureFwdDecl(node.target);
        }

        let id = target.name || fail();

        if (args.len <= 2)
        {
            if (target.kind == "var")
            {
                if (!target.local_of)
                {
                    if (node.target.modid != module.modid)
                        cgForeignGlobal(node.target);

                    return ID(id); // TODO ensure const emit.
                }

                return localID(:node.target);
            }

            if (target.kind == "field")
                return ARG(0) ~ "." ~ ID(id);

            if (node.target.isOp)
            {
                let head = args[0] || fail();

                if (args.len == 1)
                    return target.flags & F_POSTFIX ? emitPostfixOp(id.valid_operator)
                                                    : emitPrefixOp (id.valid_operator);

                if (args.len == 2)
                {
                    if (id == "[]")
                    {
                        if (mode & M_MOVE)
                            return ARG(0) ~ ".try_steal(" ~ ARG(1) ~ ")";

                        if (node.type.is_mutref)
                            return ARG(0) ~ ".mutref(" ~ ARG(1) ~ ")";

                        return ARG(0) ~ "[" ~ ARG(1) ~ "]";
                    }

                    // Conditional lazy assignment.
                    if (id == "||=")
                    {
                        let arg0 = ARG(0);

                        mut tv: TEMPVAR;
                        let condcons = via(:tv, :head.type, expr: arg0);
                        let alt = tv.ptrflip ? "*" ~ tv.id : tv.id || arg0;
                        return ooeWrap("(" ~ condcons ~ alt ~ " = " ~ ARG(1) ~ ")");
                    }

                    // Skip some of the ridiculous parens.
                    return emitBinaryOp(id.valid_operator);
                }
            }

            if (id == "STEAL" && args.len == 1)
                return cgMove(node.type, ARG(0));
        }

        isNative && fail("Unknown __native: `" ~ id ~ "`.");

        return emitFunctionCall(id.valid_identifier);
    }

    fn emitBuiltin(id: string, args: string[], node: SolvedNode): string
    {
        if (id == "/prim/convert")
        {
            let output  = node.type;
            let input   = node.items.only.type;

            let cast    = typeAnnotBase(output);

            if (input.is_integral && output.is_integral &&
                input.is_unsigned != output.is_unsigned)
            {
                // When casting between signed and unsigned integers,
                //  we always go through an intermediate unsigned type
                //   that is as big as the signed type:
                //
                //  i8 -> u32 :=  i8 ->  u8 -> u32
                // u32 ->  i8 := u32 ->  u8 ->  i8
                //
                //  u8 -> i32 :=  u8 -> u32 -> i32
                // i32 ->  u8 := i32 -> u32 ->  u8
                //
                // This means that we only move the sign bit around
                //  when casting between signed types.
                //
                mut mid_t       = input.is_unsigned ? output : input;
                mid_t.canon[0] == 'i' || fail();
                mid_t.canon[0]  = 'u';

                if (mid_t.canon != output.canon &&
                    mid_t.canon != input.canon)
                {
                    let inner = typeAnnotBase(mid_t);

                    return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
                }
            }
            else if (input.is_byte && !output.is_byte)
            {
                // Go through unsigned char.
                let inner = typeAnnotBase(t_u8);

                return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
            }

            return cast ~ '(' ~ args.only ~ ')';
        }

        fail("Unknown builtin: " ~ id);
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn cgLiteral(node: SolvedNode): string
    {
        mut src = node.value;

        if (node.type.is_unsigned)
            if (!src.has('u'))
                src ~= 'u';

        if (node.type.is_floating_pt)
        {
            if (!src.has('.'))
                src ~= ".0";

            if (node.type.canon == "f32")
            {
                if (src.has('x'))
                    src = "float(" ~ src ~ ")";
                else
                    src ~= "f";
            }
            else if (node.type.canon != "f64")
            {
                assert();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        // One of those paradoxes.
        if (src.len > 16)
        {
            let parse = intlit::Intlit(src);
            if (parse.negative && parse.absval == 0x8000000000000000)
                return "(-9223372036854775807-1)";
        }

        if (node.type.is_integral &&
            node.type.canon != "u32" && node.type.canon != "i32")
        {
            if (node.type.canon == "u64" || node.type.canon == "i64") {
                if (!src.has('l'))
                    return src ~ "ll";
            }
            else {
                return typeAnnotBase(node.type) ~ "(" ~ src ~ ")";
            }
        }

        // Remove underscores, if any.
        mut idx: i32;
        while ((idx = src.find('_', start: idx)) >= 0)
            src.splice(idx, 1);

        //
        return src;
    }

    fn cgEmpty(mode: i32): string
    {
        return mode & M_STMT ? "" : "0";
    }


    //

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(shadow node: SolvedNode)
            node.kind == "if" || node.kind == "and"
                ? " " ~ cgNode(node, M_STMT, debug: "cgIf.blockWrap_unlessIf")
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL | (stmt && M_PARENS), debug: "cgIf[cond]");
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1, debug: "cgIf[cons]"));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2, debug: "cgIf[alt]"));

        if (stmt)
            return "if (" ~ cond ~ ")" ~ cons ~ (alt ? _indent ~ "else" ~ alt : "");

        return "(" ~ cond ~ " ? " ~ cons ~ " : " ~ alt ~ ")";
    }

    fn cgAnd(node: SolvedNode, mode: i32, debug!: string): string
    {
        return cgAnd(:node.items, :node.type, :mode, :debug);
    }

    fn cgAnd(items: [SolvedNode], type: Type, mode: i32, debug!: string): string
    {
        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (";
            cgAndOr_concat(src, " && ", items[0, items.len - 1], parens: true);
            src ~= ")";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.is_bool)
        {
            cgAndOr_concat(src, " && ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            if (type.is_mutref)
            {
                for (mut i = 0; i < items.len; i++)
                {
                    let item = items[i];
                    if (i < items.len - 1)
                        src ~= "!" ~ via(:tv, :type, item);
                    else
                        src ~= cgNode(item, debug: debug ~ ".cgAnd[mutref " ~ i ~ "]");
                }
            }
            else
            {
                let N = items.len;
                let retSecondLast = items[N - 1].type.is_never;

                let condEnd = retSecondLast ? N - 2 : N - 1;
                cgAndOr_concat(src, " && ", items[0, condEnd]);

                if (retSecondLast)
                {
                    if (condEnd) src ~= " && ";
                    src ~= "!" ~ via(:tv, :type, items[N - 2]);
                    src ~= cgNode(items[N - 1], debug: debug ~ ".cgAnd[retSecondLast]"); // FAIL
                }
                else
                {
                    src ~= " ? " ~ cgNode(items[N - 1], debug: debug ~ ".cgAnd[usual]");
                    src ~= " : " ~ cgDefault(type);
                }
            }
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn cgOr(node: SolvedNode, mode: i32): string
    {
        let type  = node.type;
        let items = node.items;

        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (!(";
            cgAndOr_concat(src, " || ", items[0, items.len - 1], parens: true);
            src ~= "))";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.is_bool)
        {
            cgAndOr_concat(src, " || ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    shadow let items = item.items;
                    tail = items[items.len - 1] || fail();

                    cgAndOr_concat(src, " && ", items[0, items.len - 1]);
                    src ~= " && ";
                }

                //
                src ~= via(:tv, :type, tail);
            }

            let tail = items[items.len - 1] || fail();
            src ~= cgNode(tail, debug: "cgOr");
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn via(ref tv: TEMPVAR, type: Type, expr: SolvedNode): string
    {
        if (expr.isFieldChain)
        {
            let trivial = cgNode(expr, debug: "TEMPVAR[fieldChain]");
            return trivial ~ " ? " ~ trivial ~ " : ";
        }

        if (expr.kind == "copy" || expr.kind == "move")
        {
            let kind = expr.kind;
            shadow let expr = expr.items.only;
            if (expr.isFieldChain)
            {
                let trivial = cgNode(expr, debug: "TEMPVAR[copymov/fieldChain]");
                return trivial ~ " ? " ~ cgMoveOrClone(:kind, :type, trivial) ~ " : ";
            }

            // TODO fix the copies -
            //  we can copy AFTER the test,
            //   will also result in shorter code.
            //
            // TODO this is true for any transformation that does not affect truthiness.
            //  For example a conversion from i8 to i32 cannot affect truthiness, but i32 to i8 can.
            //   Can we generalize this? This would be fantastic.
            //
            // But copies are the worst.
        }

        return via(:tv, :type, expr: cgNode(expr, debug: "TEMPVAR[usual]"));
    }

    fn via(ref tv: TEMPVAR, type: Type, expr!: string): string
    {
        if (!tv.id)
            tv.id = emitTEMPVAR(
                tv.annot = typeAnnot(type), :tv.ptrflip);

        if (tv.ptrflip)
            return "*(" ~ tv.id ~ " = &(" ~ expr ~ ")) ? *" ~ tv.id ~ " : ";

        if (type.is_trivial)
            return "(" ~ tv.id ~ " = " ~ expr ~ ") ? " ~ tv.id ~ " : ";

        return "(" ~ tv.id ~ " = " ~ expr ~ ") ? static_cast<" ~ tv.annot ~ "&&>(" ~ tv.id ~ ") : ";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var")
            return true;

        return false;
    }

    fn cgAndOr_concat(ref src: string, op: string, items: [SolvedNode], parens?!: bool)
    {
        let mode = M_RETBOOL | (parens && items.len == 1 && M_PARENS);
        for (mut i = 0; i < items.len; i++)
        {
            if (i) src ~= op;
            src ~= cgNode(items[i], :mode, debug: "cgAndOr_concat[" ~ i ~ "]");
        }
    }

    fn cgDefault(type: Type): string
    {
        type.is_mutref && fail("Cannot definit mutrefs.");

        if (type.is_ref)
        {
            let annot = typeAnnot(type);
            if (annot.starts(with: "fu::view"))
                return annot ~ "{}";

            include("<fu/default.h>");
            return "(*(const " ~ typeAnnot(clear_refs(type)) ~ "*)fu::NIL)";
        }

        return typeAnnot(type) ~ "{}";
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        mut end = src.len - 1;

        // :(
        src[end] == '}' || fail();
        if (postfix.if_first == '\n')
            for (mut i = end; i --> 0 && src[i] == ' '; )
                end--;

        return src.slice(0, end) ~ postfix ~ '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let can_cont0 = _current_fn.can_cont;
        let can_break0 = _current_fn.can_break;

        defer {
            _current_fn.can_cont = can_cont0;
            _current_fn.can_break = can_break0;
        }

        _current_fn.can_cont = Target();
        _current_fn.can_break = Target();

        //
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];
        let n_post = items[LOOP_POST];

        let init = n_init && cgNode(n_init, M_STMT, debug: "cgLoop[init]");
        let cond = n_cond && cgNode(n_cond, M_RETBOOL | M_PARENS, debug: "cgLoop[cond]");
        let pcnd = n_pcnd && cgNode(n_pcnd, M_RETBOOL, debug: "cgLoop[pcnd]");
        let post = n_post && cgNode(n_post, M_STMT, debug: "cgLoop[post]");

        //
        let label = node.target;
        _current_fn.can_break = label;

        mut body = n_body && blockWrapSubstatement(n_body, M_LOOP_BODY);

        //
        mut breakLabel = "";

        let lbl     = label && GET(label);
        let name    = lbl.name;
        if (body && name)
        {
            let brk = "L_" ~ name;
            if (body.has("goto " ~ brk ~ ";")) // TODO FIX track label usage
                breakLabel = " " ~ brk ~ ":;";
        }

        //
        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" ~ body ~ _indent ~ "while (" ~ pcnd ~ ")" ~ breakLabel;
        }

        if (init || post || !cond)
            return "for (" ~ init ~ "; " ~ cond ~ "; " ~ post ~ ")" ~ body ~ breakLabel;

        return "while (" ~ cond ~ ")" ~ body ~ breakLabel;
    }

    fn cgCatch(node: SolvedNode): string
    {
        let items       = node.items;
        let var_name    = items[0];
        if (var_name.kind != "let")
            return cgTryCatch(node);

        let try_init    = cgNode(items[0].items[LET_INIT], debug: "cgCatch") ~ ";";
        let err         = GET(items[1].target).name;
        let catch       = blockWrapSubstatement(items[2]);

        mut vardecl     = !var_name.type.is_never &&
            binding(var_name, forceMut: true) ~ " = {};";

        return vardecl
             ~ cgTryCatch(
                var_name.type.is_never
                    ? _indent ~ "    " ~  try_init
                    : _indent ~ "    " ~  var_name.value ~ " = " ~ try_init,
                err,
                catch);
    }

    fn cgTryCatch(node: SolvedNode): string
    {
        let items = node.items;
        let try = blockWrapSubstatement(items[0]);

        let err = GET(items[1].target).name;
        let catch = blockWrapSubstatement(items[2]);

        return cgTryCatch(try, err, catch);
    }

    fn cgTryCatch(try: string, err: string, catch: string): string
    {
        return _indent ~ "try"
             ~ _indent ~ "{"
             ~  try
             ~ _indent ~ "}"
             ~ _indent ~ "catch (const std::exception& o_0)"
             ~ _indent ~ "{"
             ~ _indent ~ "    fu_STR " ~ ID(err) ~ " = fu_TO_STR(o_0.what());\n"
             ~  catch
             ~ _indent ~ "}\n";
    }


    //

    fn cgNode(node: SolvedNode, debug!: string, mode: i32 = 0, callarg?: Type): string
    {
        let k = node.kind || fail("cgNode: No node.kind: " ~ debug);
        HERE(node);

        if (k == "call")        return cgCall(node, mode);

        if (k == "int")         return cgLiteral(node);
        if (k == "real")        return cgLiteral(node);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node, mode, :callarg);
        if (k == "definit")     return cgDefinit(node, mode, :callarg);

        if (k == "copy")        return cgMoveOrClone(node, mode);
        if (k == "move")        return cgMoveOrClone(node, mode);

        if (k == "if")          return cgIf(node, mode);
        if (k == "or")          return cgOr(node, mode);
        if (k == "and")         return cgAnd(node, mode, :debug);

        if (k == "let")         return cgLet(node, global: !_current_fn.index);

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node, mode, debug: "block");
        if (k == "argid")       return cgComma(node.items, debug: "argid");

        // Empties.
        if (k == "fndef")       return cgFnDef(node, mode); // TODO no point in this here
        if (k == "empty")       return cgEmpty(mode);

        // Stuff that we can't cg as expressions.
        if !(mode & M_STMT)
            return cgBlock(node, :mode, debug: k ~ "!M_STMT");

        if (k == "jump")        return cgJump(node);

        if (k == "loop")        return cgLoop(node);
        if (k == "try")         return cgTryCatch(node);
        if (k == "catch")       return cgCatch(node);
        if (k == "defer")       return cgDefer(node);

        return fail("TODO: " ~ k);
    }


    //

    fn cgMoveOrClone(node: SolvedNode, mode: i32): string
    {
        let expr = node.items.only;

        if (node.kind == "move")
        {
            // NRVO now here, solver doesn't care.
            if (mode & M_RETURN)
            {
                fn supportsNRVO(o: Overload)
                    o.kind == "var" && !(o.flags & F_ARG)
                        && o.local_of == _current_fn.target.index
                        && !o.solved.type.is_ref;

                let nrvo = expr.kind == "call"
                        && expr.items.len == 0
                        && expr.target.GET.supportsNRVO;

                if (nrvo)
                    return "/*NRVO*/ " ~ cgNode(expr, debug: "NRVO");
            }

            if (!node.type.is_trivial)
            {
                // Moving from a constref return,
                //  it's an expressiveness problem in cpp,
                //   easiest way to work around it is with a const_cast:
                //
                //   struct X;
                //
                //   const X& func(const X& val) {
                //       return val;
                //   }
                //
                //   X&& func(X&& val) {            // Alternatively:
                //       return (X&&)func(val);     //  return static_cast<X&&>(const_cast<X&>(func(val)))
                //   }
                //
                if (expr.kind == "call")
                {
                    fn Lifetime_hasArguments(lifetime: Lifetime)
                    {
                        for (mut i = 0; i < lifetime.uni0n.len; i++)
                            if (lifetime.uni0n[i].Region_isArg)
                                return true;

                        return false;
                    }

                    //
                    let o = GET(expr.target);

                    // Special handling for stealing form arrays.
                    if (o.kind == "__native" && o.name == "[]")
                        return cgNode(expr, debug: "cgMoveOperator[]", mode: M_MOVE);

                    //
                    if (!o.type.is_mutref && o.type.lifetime.Lifetime_hasArguments)
                    {
                        ensureMoveFromConstRefHelper(expr.target);
                        return cgNode(expr, debug: "cgMoveFromConstRefHelper");
                    }
                }
            }
        }

        return cgMoveOrClone(node.kind, node.type, cgNode(expr, debug: "cgMoveOrClone"));
    }

    fn cgMoveOrClone(kind: string, type: Type, src: string): string
    {
        if (kind == "move")
            return cgMove(type, src);

        return cgClone(type, src);
    }

    fn cgMove(type: Type, src: string): string
    {
        if (type.is_trivial && type.is_rx_copy)
            return cgClone(type, src);

        return "static_cast<" ~ typeAnnotBase(type) ~ "&&>(" ~ src ~ ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        return typeAnnotBase(type) ~ "(" ~ src ~ ")";
    }


    //

    fn emitTEMPVAR(annot: string, ref ptrflip!: bool, id?: string, expr?: string): string
    {
        ptrflip = annot[annot.len - 1] == '&';

        shadow let id = id || "_" ~ _current_fn.numTEMPVARs++;
        _current_fn.TEMPVARs ~=
            ptrflip ? annot[0, annot.len - 1] ~ "* " ~ id
                    : annot ~ " " ~ id ~ (expr ? " = " ~ expr : " {}"); // TODO dont init trivial

        return id;
    }

    fn cgNodes(nodes: SolvedNode[], mode: i32 = 0, trail?!: string, debug!?: string): string[]
    {
        mut result: string[] = [];

        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if (mode & M_STMT) SWAP(_tv0, _current_fn.TEMPVARs);
        defer {
            if (mode & M_STMT) SWAP(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        for (mut i = 0; i < nodes.len; i++)
        {
            let node    = nodes[i];
            let isTrail = trail && i == nodes.len - 1 && !node.type.maybe_nonzero;
            mut src     = node && cgNode(node, isTrail ? mode &~ M_STMT : mode, debug: debug ~ ".cgNodes");

            src || mode & M_STMT || fail("cgNodes: empty output for Node(kind=`" ~ node.kind ~ "` value=`" ~ node.value ~ "`).");

            if (mode & M_STMT && _current_fn.TEMPVARs)
            {
                result ~= _current_fn.TEMPVARs;
                _current_fn.TEMPVARs.clear();
            }

            if (isTrail)
                src = trail ~ "(" ~ src ~ ")";

            result.push(src);
        }

        return result;
    }


    //

    root.kind == "root" || fail();

    let src = cgNode(root, debug: "cgRoot");

    return CodegenOutput(
        :src,
        unity:          _unity,
        unity_because:  _unity_because);
}
