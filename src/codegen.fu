import helpers;
import flags;
import types;
import quals;
import scope;
import context;
import bitset;
import cpp;
import module;
import structs;
import fail;

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_RETURN            = 1 << 5;
let M_FWDECL            = 1 << 6;
let M_PARENS            = 1 << 7;
let M_OPT_CURLIES       = 1 << 8;
let M_LOOP_BODY         = 1 << 9;
let M_MUTVAR            = 1 << 10;
let M_MOVABLE           = 1 << 11;
let M_MOVE              = 1 << 12;
let M_ARG_TO_NATIVE     = 1 << 13;
let M_ENUM_DECL         = 1 << 14;

let MAIN_needed         = 1 << 0;
let MAIN_argv           = 1 << 1;
let MAIN_zst            = 1 << 2;


//

let RESOLVE_report      = false;


//

type BitSet2D = bitset::BitSet[];

fn add_once(ref bs: BitSet2D, i: int, j: int): bool
{
    return bs
        .grow_if_oob(i)
        .add_once(j);
}

fn add_once(ref bs: BitSet2D, target: Target): bool
{
    return bs.add_once(target.modid, target.index);
}

pub fn cpp_codegen(implicit module: Module, implicit ctx: Context): CodegenOutput
{

    //

    let implicit mut _here: TokenIdx;

    nocopy struct Outputs
    {
        // #include ...
        _libs:              string[];

        // diagnostics
        _gcc_ignore:        string[];

        // static pragma emit
        _top_emits:         string;

        // struct fwd decls
        _tfwd:              BitSet2D;
        _tfwd_src:          string;

        // fn fwd decls
        _ffwd:              BitSet2D;
        _ffwd_src:          string;

        _ffwd_live_client:  string;
        _ffwd_live_nclient: string;

        // type definitions
        // TODO track separately, we dont need all types defined
        _tdef:              string;

        // fn definitions
        _idef:              bitset::BitSet;
        _fdef:              string;

        // misc garbage
        _indent:            string;
        _hasMain:           i32;

        // experimentals
        HACK_link:          string[];
        HACK_include_dirs:  string[];
        HACK_extra_sources: string[];

        // live
        _live_targets:      i32[];

        // testing
        _defects:           CGDefects;
    };

    let using mut outputs: Outputs;


    //

    outputs._indent = "\n";


    //

    struct cg_Block
    {
        name: string;
        helpers: Helpers;
        has_val: bool;
        ptrflip: bool;
    };

    struct cg_CurrentFn // TODO FIX postfix/prefix non-pub symbols?
    {                   //  Or prefix structs with module name?
        using target:   Target;

        numTEMPVARs?:   i32;
        TEMPVARs?:      string[];

        blocks?:        cg_Block[];
        num_labels?:    i32;

        can_return?:    Helpers;
        can_break?:     Helpers;
        can_cont?:      Helpers;

        _ids_used?:     string[];
        _ids_dedupe?:   i32[];

        // We'll start with the silliest thing here.
        _hoist?:        string[];
    };

    struct TEMPVAR { annot?: string; id?: string; ptrflip?: bool; };

    mut _current_fn: cg_CurrentFn;

    fn isLocal(target: Target)
    {
        return target.modid < 0;
    }

    fn nested(index: i32)
    {
        return index
            && Target(modid: -_current_fn.index, :index);
    }

    using fn GET(target: Target)
    {
        target.index > 0 || assert();

        if (target.isLocal)
            return module.out.solve.scope.extended[-target.modid].locals[target.index - 1];

        let m = target.modid == module.modid
            ? module
            : ctx.modules[target.modid];

        return m.out.solve.scope.overloads[target.index - 1];
    }

    fn try_GET(target: Target)
    {
        return target && GET(target);
    }

    using fn EXT(target: Target)
    {
        if (target.modid == module.modid)
            return module.out.solve.scope.extended.unless_oob(target.index);

        if (target.modid < 0)
            return [];

        return ctx.modules[target.modid]
            .out.solve.scope.extended.unless_oob(target.index);
    }


    //

    fn fail(mut reason = "")
    {
        FAIL("THIS IS A COMPILER BUG.\n\n\tCODEGEN FAIL:\n\n\t" ~ (reason || "Assertion failed."));
    }


    //

    fn include(lib: string)
    {
        _libs.set::add(lib);
    }

    fn localPath(path: string)
    {
        return path.starts(with: '.')
             ? path::join(path::dirname(module.fname), path)
             : path;
    }


    //

    fn type_isZST(type: Type): bool
    {
        return type.is_void  || type.is_zeroes || type.isAddrOfFn;
    }

    fn typeAnnot(type: Type, mode?: i32): string
    {
        let fwd = typeAnnotBase(type, :mode);

        if (type.is_ref)
        {
            if (fwd.starts(with: "fu::view") || fwd == "void")
                return fwd;

            if (type.is_mutref)
                return fwd ~ "&";

            // Pass primitives by value.
            if (type.is_primitive)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " ~ fwd
                     : fwd;

            // Enable move from local.
            //
            //  let a = ...     // Some a = ...
            //  let b = a.b;    // B& b = a.b;      // const B& wouldn't allow move
            //  return b;       // return move(b);  // here
            //
            if (mode & M_MOVABLE && !type.is_trivial)
                return fwd ~ "&";

            return "const " ~ fwd ~ "&";
        }

        if ((mode & M_ARGUMENT) && !(type.is_primitive))
            return fwd ~ "&&";

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.is_trivial))
            return "const " ~ fwd;

        return fwd;
    }

    fn primAnnotBase(c: string)
    {
        // Avoid #include noise when possible.
        if (c == "i32")     return "int";
        if (c == "i16")     return "short";
        if (c == "u32")     return "unsigned";

        if (c == "b8")      return "bool";
        if (c == "c8")      return "char";

        if (c == "f32")     return "float";
        if (c == "f64")     return "double";

        // char vs signed char vs unsigned char.
        if (c == "i8" || c == "u8")
        {
            include("<fu/int.h>");
            return "fu::" ~ c;
        }

        // Tough luck.
        include("<cstdint>");

        if (c == "i64")     return "int64_t";
        if (c == "i128")    return "__int128_t";

        if (c == "u16")     return "uint16_t";
        if (c == "u32")     return "uint32_t";
        if (c == "u64")     return "uint64_t";
        if (c == "u128")    return "__uint128_t";

        // Custom primitives.
        fail("Unknown primitive: `" ~ c ~ "`.");
    }

    fn typeAnnotBase(type: Type, mode?: i32): string
    {
        let c = type.canon;

        if (type.is_primitive && (c.len < 4 || c.len == 4 && c[1, 4] == "128"))
            return primAnnotBase(c);

        if (type.type_isZST)    return annotateZST();
        if (c == "never")       return annotateNever();

        // TODO FIX slice definit - (arg?: [byte]) somehow manages to drop ref on definit.
        let arrayItem = tryClear_sliceable(type);
        if (arrayItem)
        {
            // Arrays & strings.
            if (type.TODO_FIX_isArray || !type.is_ref)
            {
                if (arrayItem == t_byte)
                    return annotateString();

                let itemAnnot = typeAnnot(arrayItem);

                include("<fu/vec.h>");
                return "fu_VEC<" ~ itemAnnot ~ ">";
            }

            //
            let itemAnnot = typeAnnot(arrayItem);

            include("<fu/view.h>");
            if (type.is_mutref || mode & M_MUTVAR)
                return "fu::view_mut<" ~ itemAnnot ~ ">";
            else
                return "fu::view<" ~ itemAnnot ~ ">";
        }

        //
        let s   = lookupUserType(type) || fail("TODO: " ~ type.canon);
        let id  = "s_" ~ s.name;

        let scp = parseStructCanon(type.canon);
        if (_tfwd.add_once(scp.modid, scp.index))
        {
            let decl = declareStruct(id, s);
            _tdef ~= decl;
        }

        return id;
    }

    fn declareStruct(id: string, s: Struct): string
    {
        if (s.base)
            return declarePrimitive(id, s);

        let header  = s.kind ~ " " ~ id;
        _tfwd_src  ~= header ~ ";\n";

        let t = GET(s.target).type;

        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id
                ~ "\n" ~ header ~ "\n{";

        mut indent = "\n    ";

        let fields = s.items;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = GET(fields[i].target);
            field.kind == "field" || fail("Non-field struct item: " ~ field.name ~ " (" ~ field.kind ~ ") in " ~ t.canon);
            def ~= indent ~ typeAnnot(field.type) ~ " " ~ ID(field.name) ~ ";";
        }

        if !(t.is_rx_copy)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
        }
        else if (try_GET(s.target).status & SS_TYPE_RECUR)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = default;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "& selfrec) { return *this = " ~ id ~ "(selfrec); }";
        }

        def ~= "\n    explicit operator bool() const noexcept";
        def ~= "\n    {";
        def ~= "\n        return false";

        for (mut i = 0; i < fields.len; i++)
            if (fields[i].target.flags & F_PREDICATE)
                def ~= "\n            || " ~ ID(fields[i].id);

        def ~= "\n        ;";
        def ~= "\n    }";

        return def ~ "\n};\n                                #endif\n";
    }

    fn declarePrimitive(id: string, s: Struct): string
    {
        let baseprim    = primAnnotBase(s.base);
        let members     = s.items;

        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id;

        if (s.kind != "enum" || !members)
        {
            // Non-enum primitives, do simple typedefs,
            //  the whole point of using enums is for debuggers to provide nice feedback,
            //   which can't happen for arithmetic primitives,
            //    unfortunately also true for flags.
            //
            _tfwd_src ~= "typedef " ~ baseprim ~ " " ~ id ~ ";\n";

            if (!members)
                return "";

            members.each: |member.target|
                def ~= "\ninline constexpr " ~ id ~ " " ~ id ~ "_" ~ member.name
                        ~ " = " ~ cgNode(member.solved, debug: "declarePrimitive") ~ ";";

            // Flags cast.
            if (s.kind == "flags")
            {
                mut mask = "";
                members.each: |member.target, i|
                {
                    if (!mask)
                        mask = "\n\ninline constexpr " ~ id ~ " MASK_" ~ id ~ "\n    = ";
                    else
                        mask ~= "\n    | ";

                    mask ~= id ~ "_" ~ member.name;
                }

                if (mask)
                {
                    mask ~= ";";
                    def ~= mask;
                }
            }
        }
        else
        {
            // We won't be using scoped enums (enum class) for now -
            //  a] They don't work for flags enums & co,
            //  b] Importantly, they can't have an explicit operator bool,
            //      so they need verbose boolchecks, not great.
            //
            let header      = "enum " ~ id ~ ": " ~ baseprim;

            _tfwd_src  ~= header ~ ";\n";
            def ~= "\n" ~ header ~ "\n{";

            members.each: |member.target|
                def ~= "\n    " ~ id ~ "_" ~ member.name
                        ~ " = " ~ cgNode(member.solved, debug: "declarePrimitive", mode: M_ENUM_DECL) ~ ",";

            def ~= "\n};";
        }

        return def ~ "\n                                #endif\n";
    }


    //

    fn collectDedupes(
        mut values: string[],
        prefix?: string, suffix = "\n",
        header?: string, footer = "\n"): string
    {
        mut out = "";

        if (values)
            out ~= header;

        for (mut i = 0; i < values.len; i++)
            out ~= prefix ~ values[i] ~ suffix;

        if (out)
            out ~= footer;

        return out;
    }

    fn valid_operator(str: string): string
    {
        mut start = 0;
        mut some  = false;

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_')
            {
                if (!some)
                    start = i + 1;
                else
                    return str.slice(start, i);
            }
            else
            {
                some = true;
            }
        }

        return start ? str.slice(start) : str;
    }

    fn hex(x: u32)
        x < 10 ? ('0'.u32 +  x      ).byte
               : ('A'.u32 + (x - 10)).byte;

    fn xHH(c: u32) "x"
        ~ ((c >> 4) & 0xf).hex
        ~ ((c >> 0) & 0xf).hex;

    fn valid_identifier(mut str: string): string
    {
        for (mut i = str.len; i --> 0; )
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_') continue;

            str = str[0, i]
                ~ c.u32.xHH
                ~ str[i + 1, str.len];
        }

        return ID(str);
    }

    fn cgRoot(shadow root: SolvedNode): string
    {
        mut count: i32;
        let src    = cgStatements(root.items, :count);
        let main   = cgMain();

        return collectDedupes(_libs, prefix: "#include ")

            // Fwd-declared structs & enums.
            ~ _tfwd_src

            // Fwd-declared functions.
            ~ _ffwd_src

            // Hotswap fwd-decls grouped up in two ifdef branches.
            ~ (_ffwd_live_client && "\n                                #ifdef fu_HOTSWAP\n")
            ~ (_ffwd_live_client)
            ~ (_ffwd_live_client && "                                #else\n")
            ~ (_ffwd_live_nclient)
            ~ (_ffwd_live_client && "                                #endif\n")

            // Type definitions.
            ~ _tdef

            ~ collectDedupes(_gcc_ignore,
                header: "#pragma GCC diagnostic push\n#ifdef __clang__\n#pragma GCC diagnostic warning \"-Wunknown-warning-option\"\n#endif\n",
                prefix: "#pragma GCC diagnostic ignored \"",
                suffix: "\"\n")

            ~ _top_emits

            // Function definitions.
            ~ (_fdef && "\n#ifndef fu_NO_fdefs\n")
            ~ (_fdef)
            ~ (_fdef && "\n#endif\n")

            // Rest.
            ~ src
            ~ main

            //
            ~ (_gcc_ignore && "\n#pragma GCC diagnostic pop\n")
        ;
    }

    fn cgMain(): string
    {
        if (!_hasMain)
            return "";

        mut zst = "";
        if (_hasMain & MAIN_zst)
            zst = ", 0";

        mut src = "\nint main() { return fu_MAIN()" ~ zst ~ "; }";

        if (_hasMain & MAIN_argv)
        {
            // Main with cli args.
            annotateString();

            src = "\nint main(int argc, char* argv[])"
                ~ "\n{"
                ~ "\n    fu_VEC<fu_STR> args;"
                ~ "\n    args.reserve(argc);"
                ~ "\n"
                ~ "\n    for (int i = 0; i < argc; i++)"
                ~ "\n        args.push(fu_TO_STR(argv[i]));"
                ~ "\n"
                ~ "\n    return fu_MAIN(static_cast<fu_VEC<fu_STR>&&>(args))" ~ zst ~ ";"
                ~ "\n}";
        }

        src ~= "\n";
        return src;
    }


    //

    fn localID(target: Target, dedupe?: bool)
    {
        let o  = GET(target);
        mut id = o.name;

        // CLOSURE-ID-HACK
        let cid = hacks::tryParseClosureID(:id);
        if (cid.target)
            id = GET(cid.target).name;
        // CLOSURE-ID-HACK

        id = ID(id);

        if (target.isLocal)
        {
            fn _ids_dedupe  = _current_fn._ids_dedupe;
            fn _ids_used    = _current_fn._ids_used;

            // Dedupe #1.
            if (dedupe)
            {
                mut dupes = 0;

                :REPEAT
                for (;;)
                {
                    let candidate = dupes
                        ? id ~ '_' ~ dupes
                        : id;

                    for (mut i = 0; i < _ids_used.len; i++)
                    {
                        if (_ids_used[i] == candidate)
                        {
                            dupes++;
                            continue :REPEAT;
                        }
                    }

                    _ids_used ~= candidate;
                    break;
                }

                if (dupes)
                    _ids_dedupe.grow_if_oob(target.index) = dupes;
            }

            // Dedupe #2.
            let dupes = _ids_dedupe.len > target.index && _ids_dedupe[target.index];
            if (dupes)
                return id ~ '_' ~ dupes;
        }

        return id;
    }


    //

    fn cgStatements(nodes: SolvedNode[], ref count!: int, trail!?: string): string
    {
        let lines = cgNodes(nodes, M_STMT, :trail, debug: "cgStatements");
        count = lines.len;

        mut src = "";
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src ~= (line.if_first == '\n' ? '\n' ~ line : _indent ~ line)
                     ~ (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn cgComma(nodes: SolvedNode[], debug!: string): string
    {
        shadow let items = cgNodes(nodes, debug: debug ~ ".cgComma");
        if (!items.len)
            return "(false /*empty parens*/)";

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= ", ";
            if (i < items.len - 1)
                src ~= "(void)";

            src ~= items[i];
        }

        return src ~ ")";
    }


    //

    fn blockWrapSubstatement(node: SolvedNode, mode?: i32): string
        cgBlock(node, mode: M_STMT | M_OPT_CURLIES | mode, debug: "blockWrapSubstatement");

    fn cgBlock(node: SolvedNode, mode: i32, debug!: string): string
    {
        let items   = node.kind == "block"  ? node.items : [ node ];
        let helpers = node.kind == "block" && node.helpers;

        ///////////////////////////////////////////
        if (mode & M_LOOP_BODY)
            _current_fn.can_cont = helpers;
        ///////////////////////////////////////////

        // We'll try to avoid block expressions as much as we can.
        //  Instead of these loops it'd be nice if we knew all this stuff
        //   as node flags or something, or a jumpset or something:
        //      - if expressible as cpp expr (none of the below stuff),
        //      - if wrappable in a cpp lambda (no jumping up), etc.
        //
        fn exprOK(nodes: [SolvedNode])
        {
            for (mut i = 0; i < nodes.len; i++)
            {
                let n = nodes[i];
                let k = n.kind;

                // TODO FIX doing this with a blacklist is mega stupid
                if (k == "jump" || k == "loop" || k == "try" || k == "defer" ||
                    k == "letdef" || k == "pragma")
                {
                    return false;
                }

                if (!n.items.exprOK)
                    return false;
            }

            return true;
        }

        let expr = !(mode & M_STMT);
        if (expr && items.exprOK)
            return cgComma(items, debug: debug ~ ".cgBlock");

        //
        return cgBlock(items, skipCurlies: !!(mode & M_OPT_CURLIES), gnuStmtExpr: expr,
            :helpers, type: expr && node.type);
    }

    fn cgBlock(
        nodes: SolvedNode[], skipCurlies!: bool, gnuStmtExpr!: bool,
        helpers!: Helpers, type: Type): string
    {
        ///////////////////////////////////////////////
        let _ids_used0 = _current_fn._ids_used.len;
        defer {
            if (!_current_fn._hoist)
                _current_fn._ids_used.shrink(_ids_used0);
        }
        ///////////////////////////////////////////////

        //////////////////////
        let indent0 = _indent;
        defer _indent = indent0;
        //////////////////////
        _indent ~= "    ";

        mut open    = "{";
        mut close   = gnuStmtExpr ? "}))" : "}";
        mut trail   = "";

        let name    = "BL_" ~ _current_fn.num_labels++;

        mut has_val     = type && !type.is_void;
        mut ptrflip     = false;

        if (has_val)
        {
            mut force_mut = type.is_ref;
            type.lifetime.uni0n.each: |r|
            {
                let local = Region_asLocal(r);
                if (!local || !(nested(local).flags & F_MOVED_FROM))
                {
                    force_mut = false;
                    break;
                }
            }

            //
            let annot   = typeAnnot(type, force_mut && M_MOVABLE);
            let id      = emitTEMPVAR(annot, :ptrflip, name && name ~ "_v");

            let out     = ptrflip ? "*" ~ id : cgMove(:type, id);
            close       = "(void)0;}), " ~ out ~ ")";

            trail       = id ~ " = ";
            if (ptrflip)
                trail  ~= "&";
        }

        // Blockvals! //////////////////////////////////////////////////////////////////////////////
        let blocks0  = _current_fn.blocks.len;
        defer _current_fn.blocks.shrink(blocks0);
        _current_fn.blocks ~= cg_Block(:name, :helpers, ptrflip, :has_val);
        ////////////////////////////////////////////////////////////////////////////////////////////

        //
        mut count: int;
        mut src = cgStatements(nodes, :count, :trail);

        // Block label & retval.
        let labelUsed = src.has("goto " ~ name ~ ";");
        if (labelUsed) // TODO FIX track label usage
        {
            close = "  } " ~ name ~ ":;" ~ indent0 ~ close;
            open  = "{ {";
        }

        //
        if (!skipCurlies || nodes.len != 1 || count != 1 || labelUsed || src.has('{') || src.has("if"))
        {
            mut gnuOpen = "";
            if (gnuStmtExpr)
            {
                _defects |= GNUStmtExpr;
                gnuOpen = "(__extension__ (";
            }

            src = gnuOpen ~ indent0 ~ open ~ src ~ indent0 ~ close;
        }

        return src;
    }

    fn cgDefer(node: SolvedNode): string
    {
        include("<fu/defer.h>");

        let which = node.value == "err" ? "fu_DEFER_IF_ERR"
                  : node.value == "ok"  ? "fu_DEFER_IF_OK"
                                        : "fu_DEFER";

        return which ~ "(" ~ cgNode(node.items.only, M_STMT, debug: "defer") ~ ")";
    }


    //

    fn isOp(target: Target)
    {
        let flags = target.flags;

        // Deal with it!
        //  We don't want to have subtle mismatches between the two,
        //   only assignment operators in c++ have guaranteed ooe,
        //    so it HAS to be an operator for this to hold.
        //
        if (flags & F_OOE_RTL)
            return true;

        if !(flags & F_OPERATOR)
            return false;

        let args = target.args;
        if (args.len > 2)
            return false;

        if (target.kind == "__native")
            return true;

        let name = target.name;
        if (args.len > 1)
            return cpp::hasBinary(name);

        return cpp::hasUnary(name);
    }

    fn fnID(target: Target)
    {
        let overload    = GET(target);
        let id          = overload.name || fail();

        if (target.isOp)
            return "operator" ~ id.valid_operator;

        mut ret = id.valid_identifier;
        if (target.sighash && !(target.flags & F_EXTERN))
            ret ~= "_" ~ target.sighash[0, 8];

        return ret;
    }

    fn isExtLinked(overload: Overload)
    {
        return overload.flags & (F_PUB | F_EXTERN);
    }

    fn fnLinkage(overload: Overload)
    {
        return    (  overload.type.is_never         && "[[noreturn]] ")
                ~ (  overload.flags & F_TEMPLATE    && "inline "      )
                ~ (!(overload.isExtLinked)          && "static "      );
    }

    fn cgFnSignature(fn: SolvedNode): string
    {
        let target      = fn.target;
        let overload    = GET(target);

        let host_args   = target.args;
        let annot       = typeAnnot(overload.type || fail(), M_RETVAL);

        //
        mut id          = overload.name;
        if (id == "main")
        {
            _hasMain    = MAIN_needed;
            id          = "fu_MAIN";

            if (host_args)
                _hasMain |= MAIN_argv;
            if (overload.type.type_isZST)
                _hasMain |= MAIN_zst;
        }
        else
        {
            id          = fnID(fn.target);
        }

        //
        mut src         = overload.fnLinkage ~ annot ~ " " ~ id ~ "(";

        mut some        = false;

        for (mut i = 0; i < host_args.len; i++)
        {
            if (host_args[i].type_isZST)
                continue;

            if (some)
                src ~= ", ";

            some = true;
            src ~= binding(host_args[i]);
        }

        if (overload.flags & F_OPERATOR && cpp::hasPostfix(overload.name))
            src ~= ", /*postfix*/int";

        src ~= ")";

        return src;
    }

    fn cgFnPrototype(target: Target, fnptr!?: bool)
    {
        ///////////////////////////////////////////
        mut current_fn0 = cg_CurrentFn(target: target);
        defer swap(_current_fn, current_fn0);
        swap(_current_fn, current_fn0);
        ////////////////////////////////////////////

        mut src         = "";
        let overload    = GET(target);

        // Linkage.
        if (!fnptr)
        {
            let linkage = overload.fnLinkage;

            src ~= linkage;
        }

        // Retval.
        {
            let ret     = overload.type || fail();
            let annot   = typeAnnot(ret, M_RETVAL);

            src ~= annot ~ " ";
        }

        // Name, (*Name), etc.
        {
            let name    = fnID(target);

            src ~= fnptr    ? "(*" ~ name ~ ")"
                            :        name;
        }

        // Arglist.
        {
            src ~= "(";

            let args    = target.args;
            mut first   = true;
            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i].type;
                if (arg.type_isZST)
                    continue;

                if (first)
                    first = false;
                else
                    src ~= ", ";

                src ~= typeAnnot(arg, M_ARGUMENT | M_FWDECL);
            }

            if (overload.flags & F_OPERATOR && cpp::hasPostfix(overload.name))
                src ~= ", /*postfix*/int";

            src ~= ")";
        }

        //
        return src;
    }

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        if !(_ffwd.add_once(target))
            return;

        let fwdDecl = target.cgFnPrototype() ~ ";\n";

        if (overload.flags & F_HOTSWAP)
        {
            let fnPtr = "extern " ~ target.cgFnPrototype(fnptr: true) ~ ";\n";

            _ffwd_live_client  ~= fnPtr;
            _ffwd_live_nclient ~= fwdDecl;
        }
        else
        {
            _ffwd_src ~= fwdDecl;
        }
    }

    fn ensureFnUsable(target: Target)
    {
        if (target.modid != module.modid)
            ensureFwdDecl(target);
        else
            ensureFnDef(target);
    }

    fn ensureFnDef(target: Target)
    {
        target.modid == module.modid || fail(
            "ensureFnDef: fndef is needed outside of its original scope: "
                ~ target.modid ~ " vs " ~ module.modid ~ ": `"
                ~ target.kind ~ " " ~ target.name ~ "`.");

        if !(_idef.add_once(target.index))
            return;

        // Go!
        let node = target.solved;
        node.kind == "fn" || fail("ensureFnDef non-fn");
        cgFn(node, M_STMT);
    }


    //

    fn cgFnDef(fndef: SolvedNode, mode: i32): string
    {
        let target = fndef.target;

        let o = GET(target);
        let n = target.solved;
        if (n && o.isExtLinked)
            ensureFnDef(target);

        return cgEmpty(n, mode);
    }

    fn cgFn(fn: SolvedNode, mode: i32): string
    {
        //////////////////////
        let indent0 = _indent;
        defer _indent = indent0;
        //////////////////////

        let items = fn.items;
        let body  = items[items.len + FN_BODY_BACK];

        let target = fn.target;
        let overload = GET(target);
        let id = overload.name;
        overload.status & SS_FINALIZED || fail("cgFn: fn not finalized: " ~ id);

        // Custom __natives.
        if (!body)
        {
            overload.kind == "__native" || fail("cgFn: no body on non-native: " ~ overload.kind ~ " " ~ id);
            return mode & M_STMT ? "" : "0";
        }

        _indent = "\n";

        // TODO is this needed?
        //  Body should always be a block.
        mut src: string;
        {
            ////////////////////////////////////////////
            mut current_fn0 = cg_CurrentFn(target: fn.target);

            defer swap(_current_fn, current_fn0);
            swap(_current_fn, current_fn0);
            ////////////////////////////////////////////

            _current_fn.can_return = body.helpers;

            src ~= cgFnSignature(fn);

            mut body_src = cgBlock(body, M_STMT, debug: "cgFn(" ~ id ~ ")");

            if (_current_fn._hoist)
            {
                mut hoist = "\n    // Hoisted:";
                for (mut i = 0; i < _current_fn._hoist.len; i++)
                    hoist ~= "\n    " ~ _current_fn._hoist[i] ~ ";";

                let idx = body_src.find("{") + 1;
                if (idx > 0)
                    body_src.splice(idx, 0, hoist ~ "\n");
            }

            src ~= body_src;
        }

        // Consider a fwdannot after outputting body,
        //  it could itself have written to _fdef.
        if (overload.status & SS_FN_RECUR)
            ensureFwdDecl(fn.target);

        let dedupe = overload.flags & F_PUB
                  && overload.flags & F_TEMPLATE
                  && overload.name.valid_identifier;

        let sighash = target.sighash;

        shadow let dedupe = dedupe && sighash
            ? dedupe ~ '_' ~ sighash
            : dedupe;

        // LIVE ////////////////////////
        if (overload.flags & F_HOTSWAP)
        {
            target.modid == module.modid || assert();
            _live_targets ~= target.index;

            //
            let fnID        = target.fnID;
            let fnID_local  = fnID ~ "_local";
            let fnPtrAnnot  = target.cgFnPrototype(fnptr: true);

            //
            include("<dl/hotswap.hpp>");
            ensureFwdDecl(target);

            //
            src = "                                #ifdef fu_HOTSWAP\n"
                ~ "                                #define " ~ fnID ~ " " ~ fnID_local ~ "\n"
                ~ "extern \"C\" fu_EXPORT\n"
                ~ "                                #endif\n"
                ~ src

                ~ "\n"
                ~ "                                #ifdef fu_HOTSWAP\n"
                ~ "                                #undef " ~ fnID ~ "\n"
                ~ fnPtrAnnot ~ " =\n    fu::hotswap(\"" ~ fnID_local ~ "\",\n                 " ~ fnID ~ ",\n                &" ~ fnID_local ~ ");\n"
                ~ "                                #endif";
        }
        ////////////////////////////////

        if (dedupe)
            _fdef ~= "\n                                #ifndef DEF_" ~ dedupe
                   ~ "\n                                #define DEF_" ~ dedupe;

        _fdef ~= "\n" ~ src ~ "\n";

        if (dedupe)
            _fdef ~= "                                #endif\n";

        if (RESOLVE_report)
        {
            let REV = target.revision.i32;
            if (REV > 5)
            {
                fn Indent()
                {
                    mut str = "";
                    for (mut i = 0; i < REV; i++) str ~= " ";
                    return str;
                }

                println("RESOLVE "
                    ~ Indent
                    ~ overload.name ~ " :: "
                    ~ target.revision);
            }
        }

        //
        return cgEmpty(fn, mode);
    }


    //

    fn F_HOIST_asPtr(target: Target)
    {
        if !(target.status & SS_HOIST)
            return false;

        let t = target.solved.type;
        return t.is_ref && (!t.type_isSliceable || t.TODO_FIX_isArray);
    }

    fn binding(target!: Target, forceValue!?: bool)
    {
        let overload    = GET(target);
        let place_type  = overload.solved.type;
        let isArg       = overload.flags & F_ARG;

        shadow let place_type  = forceValue
            ? clear_refs(place_type)
            : place_type;

        let annot = typeAnnot(
            place_type, (!overload.type.is_mutref && M_CONST)
                      | (isArg && M_ARGUMENT)
                      | (overload.type.is_mutref && M_MUTVAR)
                      | (overload.flags & F_MOVED_FROM && M_MOVABLE));

        let isUnused = overload.status & SS_UNUSED;
        if (isArg && isUnused)
            return annot;

        let id      = localID(:target, dedupe: true);

        // The new hoisting stuff, obviously comes as a complete afterthought.
        if (target.status & SS_HOIST)
        {
            _current_fn.target || BUG("TODO: hoisting for global variables.");

            // This is such crap.
            mut hoistDecl = annot.starts(with: "const ")
                ? annot.slice(6)
                : annot;

            if (target.F_HOIST_asPtr)
            {
                hoistDecl[hoistDecl.len - 1] == '&' || BUG("F_HOIST_asPtr: Decl not a ref: " ~ hoistDecl);
                hoistDecl[hoistDecl.len - 1] = '*';
            }

            _current_fn._hoist ~= hoistDecl ~ " " ~ id;

            //
            return id;
        }

        //
        mut head    = annot || fail();
        head       ~= " " ~ id;
        if (isUnused)
            head    = "[[maybe_unused]] " ~ head;
        if (target.flags & F_MOVED_FROM)
            head    = "/*MOV*/ " ~ head;

        return head;
    }

    fn binding(target!: Target, init: SolvedNode, doInit!: bool)
    {
        mut head = binding(:target);
        if (!doInit)
            return head;

        // Hoisted vars: the declaration is elsewhere,
        //  this is an assignment here.
        if (target.status & SS_HOIST)
            head ~= " = ";

        // Definit.
        if (!init || init.kind == "definit" && !init.type.is_ref)
            return head ~ " {}";

        // A less verbose copy init.
        let isCopy = init.kind == "copy" && !target.solved.is_ref;

        shadow let init = isCopy
            ? init.items.only
            : init;

        /////////////////////////////////////////////
        /////////////////////////////////////////////
        /////////////////////////////////////////////
        let use_initTEMPVARs = !_current_fn.index;
        mut initTEMPVARs: string[];

        if (use_initTEMPVARs)
            swap(initTEMPVARs, _current_fn.TEMPVARs);
        /////////////////////////////////////////////
        ///
        mut expr = cgNode(debug: "binding", init);
        ///
        /////////////////////////////////////////////
        if (use_initTEMPVARs)
            swap(initTEMPVARs, _current_fn.TEMPVARs);

        // HACK - wrap in a lambda when we need temps here
        if (initTEMPVARs)
            expr    = "[]() -> " ~ typeAnnot(init.type)
                    ~ " {\n    " ~ initTEMPVARs.join(";\n    ")
                    ~  ";\n    return " ~ expr ~ ";\n}()";
        /////////////////////////////////////////////
        /////////////////////////////////////////////
        /////////////////////////////////////////////

        // I think we can use curlies everywhere,
        //  here we make an exception for copy inits,
        //   but we skip primitives which doesn't make sense -
        //    curly init is BETTER for primitives because it prevents narrowing.
        //*/
        if (isCopy && !init.is_primitive)
            return head ~ " { " ~ expr ~ " }";

        // Hoisting.
        if (target.status & SS_HOIST)
        {
            if (target.F_HOIST_asPtr)
                return head ~ "&(" ~ expr ~ ")";

            return head ~ expr;
        }

        return head ~ " = " ~ expr;
        /*/
        return head ~ " { " ~ expr ~ " }";
        //*/
    }

    fn binding(node: SolvedNode, doInit!?: bool): string
    {
        let target  = node.target;
        let init    = doInit && node.items && node.items[LET_INIT];

        return binding(:target, :init, :doInit);
    }

    fn binding(arg: Argument, forceValue!?: bool)
    {
        let target = nested(arg.local);

        return binding(:target, :forceValue);
    }


    //

    fn cgLet(node: SolvedNode, global!: bool, foreign?: bool): string
    {
        if (node.type.type_isZST)
            return "";

        // GLOBALS ///////////////////////////////////////////////
        fn isIntegerConstant(expr)
        {
            if (expr.kind == "int")
                return true;

            if (expr.kind == "call")
            {
                let t = GET(expr.target);
                if (t.kind == "__native" && t.flags & F_OPERATOR)
                {
                    for (mut i = 0; i < expr.items.len; i++)
                        if (!expr.items[i].isIntegerConstant)
                            return false;

                    return true;
                }
            }

            return false;
        }

        let intconst = global
            && node.type.is_primitive && !node.type.is_floating_pt
            && node.items[LET_INIT].isIntegerConstant;
        // GLOBALS ///////////////////////////////////////////////

        mut src = binding(node, doInit: !foreign || intconst);
        if (!global)
            return src;

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        if (intconst)
        {
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\ninline constexpr " ~ src ~ ";"
                    ~ "\n                                #endif\n";

            return "";
        }

        // Static init prio.
        let prio    = node.type.is_primitive                ? 0
                    : node.target.modid == module.modid     ? module.order.dep_depth
                                                            : ctx.modules[node.target.modid].order.dep_depth;
        if (prio)
        {
            include("<fu/init_priority.h>");

            let attr = "fu_INIT_PRIORITY(" ~ (1000 + prio) ~ ")";
            let eq = src.find('=');
            if (eq > 0)
                src = src[0, eq] ~ attr ~ " " ~ src[eq, src.len];
        }

        // Hide when possible.
        if !(GET(node.target).isExtLinked)
        {
            // We can't "forward declare" foreign private globals.
            if (!foreign)
                _fdef  ~= "\nstatic const " ~ src ~ ";\n";

            // But we can unity-build ourselves with them.
            else
                fail("Cannot codegen, relies on an external static: " ~ node.target.name);
        }
        else
        {
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\nextern const " ~ src ~ ";"
                    ~ "\n                                #endif\n";
        }

        return "";
    }

    fn cgGlobal(target: Target)
    {
        if !(_ffwd.add_once(target))
            return "";

        return cgLet(target.solved,
            global: true,
            foreign: target.modid != module.modid);
    }

    fn cgLetDef(node: SolvedNode)
    {
        if (!_current_fn.index)
            return node.target.isExtLinked
                && cgGlobal(node.target);

        return cgLet(node.target.solved, global: false);
    }


    //

    fn cgGoto(block: cg_Block)
    {
        _defects |= Goto;
        return "goto " ~ block.name;
    }

    fn cgJump(node: SolvedNode): string
    {
        let helpers     = node.helpers;
        let use_return  = helpers == _current_fn.can_return;

        fn findBlock()
        {
            for (mut i = _current_fn.blocks.len; i --> 0; )
            {
                let block = _current_fn.blocks[i];
                if (block.helpers == helpers)
                    return block;
            }

            fail("No such block in scope: " ~ helpers.index);
        }

        let block       = !use_return && findBlock();
        let expr        = node.items.only;

        if (expr.kind != "empty" || !expr.type.is_void)
        {
            // Break with value.
            if (!use_return)
            {
                let assign  = block.has_val && block.name ~ "_v = ";
                mut value   = cgNode(expr, !assign && M_STMT, debug: "cgJump[val.break]");
                if (block.ptrflip)
                    value   = "&(" ~ value ~ ")";

                // TODO FIX: this is a lame way to deal with -Werror=unused-value,
                //  we need some kind of dead code elim so we don't need crap like this
                if !(assign || value.hasNonIdentifierChars)
                    value   = "/* TODO FIX UNUSED VAL " ~ value ~ " */";

                return "{ " ~ assign ~ value
                     ~ "; " ~ cgGoto(block) ~ "; }";
            }

            // I think the prefix keywords beat everything re: precedence.
            return "return " ~ cgNode(expr, M_PARENS|M_RETURN, debug: "cgJump[val.return]");
        }

        //
        if (use_return)
            return "return";

        if (helpers == _current_fn.can_break)
            return "break";
        if (helpers == _current_fn.can_cont)
            return "continue";

        return cgGoto(block);
    }


    //

    fn escapeStringLiteral(str: [byte], quot: byte)
    {
        mut esc = [ quot ];

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];

            if      (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";

            // Misc sub-whitespace.
            else if (c.i8 < 32) esc ~= "\\" ~ c.u32.xHH;

            // Rest & quot.
            else
            {
                if (c == quot)
                    esc ~= '\\';

                esc ~= c;
            }
        }

        esc ~= quot;

        return esc;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        //////////////////////////////////////////////
        // HACK - Retyping string literals to enums //
        if (node.type.is_enum || node.type.is_flags)
            return cgEnumv(node.type, node.value);
        //////////////////////////////////////////////

        annotateString();

        mut esc = escapeStringLiteral(node.value, '"');
        esc ~= "_fu";
        return esc;
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        /*
        include("<fu/int.h>");
        return "fu::byte(" ~ escapeStringLiteral(node.value, '\'') ~ ")";
        /*/
        return escapeStringLiteral(node.value, '\'');
        //*/
    }


    //

    fn cgArrayLiteral(node: SolvedNode, mode: i32, callarg: Type): string
    {
        if (node.target)
            return cgCall(node, mode);

        let items = cgNodes(node.items, debug: "cgArrayLiteral");
        if (!items.len)
            return cgDefault(node.type);

        let curly = "{ " ~ items.join(", ") ~ " }";
        let itemT = typeAnnotBase(clear_sliceable(node.type));
        let slate = "fu::slate<" ~ items.len ~ ", " ~ itemT ~ "> " ~ curly;

        // fu::slate literals
        if (callarg.is_ref && !callarg.TODO_FIX_isArray)
        {
            include("<fu/view.h>");

            // Putting a comma around,
            //  because the `,` misparses in places like argument lists.
            return "(" ~ slate ~ ")";
        }

        return typeAnnotBase(node.type) ~ " { " ~ slate ~ " }";
    }

    fn cgDefinit(node: SolvedNode, mode: i32, callarg: Type): string
    {
        return cgArrayLiteral(node, mode, callarg);
    }

    fn hasNonIdentifierChars(id: string)
    {
        for (mut i = 0; i < id.len; i++)
        {
            let c = id[i];
            if (c == '_' || c >= 'a' && c <= 'z'
                         || c >= 'A' && c <= 'Z'
                         || c >= '0' && c <= '9')
            {
                //
            }
            else
            {
                return true;
            }
        }

        return false;
    }

    fn binSkipParens(id: string, mode: i32)
    {
        if (mode & M_STMT)
            return true;

        if (mode & M_PARENS)
        {
            if (id.last == '=')
            {
                // Clang errors on equality within parens in conditionals ...
                if (id == "==" || id == "!=")
                    return true;

                // ... and on naked equalities in conditionals.
                return false;
            }

            // Everything else is fine.
            return true;
        }

        return false;
    }

    fn cgNot(node: SolvedNode): string
    {
        return "!" ~ cgNode(node.items.only, debug: "not");
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let ext             = node.target.EXT;
        let target          = GET(node.target) || fail();
        let args            = node.items;

        let isNative        = target.kind == "__native";

        // So this originally skipped all left-hand side copies
        //  which obviously led to a bug, see the EXT_insert testcase,
        //   which just shows how stupid this is -
        //    not sure what the ideal way to do this,
        //     should it be done in solver? Should we check lifetimes here?
        //      Obviously cg-ing redundant copies is pointless and harmful.
        //
        let isSimpleCpyMovAssign =
            args.len == 2 && isNative && target.name == "="
                && args[0].isFieldChain;


        //

        let MUSTSEQ_mask    = node.helpers.index;
        mut ooe_crosscheck  = 0;
        mut ooe_header      = "";

        mut item_src: string[];
        for (mut i = 0; i < args.len; i++)
        {
            let arg = args[i];

            // Skip explicit copies on assignment, pointless.
            shadow let arg = isSimpleCpyMovAssign && i == 1 && arg.kind == "copy"
                ? arg.items.only
                : arg;

            mut junk = false;

            if (arg.type_isZST)
            {
                // Thinking is - solver can move non-discardable expressions out of the way,
                //  so we're left with these stubs we can trivially throw away here.
                junk = arg.kind == "empty"
                    || arg.kind == "definit"
                    || arg.kind == "fndef"
                    || arg.kind == "call" && (arg.target.kind == "var" || arg.target.kind == "type" && !arg.items || arg.target.kind == "enumv");

                if (!junk)
                    fail("Cannot discard ZST arg, kind is `" ~ arg.kind ~ "`.");
            }

            mut src = junk ? "" : cgNode(
                arg, callarg: ext.args[i].type,
                debug: "cgCall(" ~ node.value ~ ").ARG(" ~ i ~ ")",
                mode: isNative && M_ARG_TO_NATIVE) || fail("Empty arg src.");

            // Explicit sequencing.
            let MUSTSEQ_bit = 1 << (i & 31);
            if (MUSTSEQ_mask & MUSTSEQ_bit)
            {
                junk && fail("Trying to MUSTSEQ a discarded argument, shouldnt happen.");

                ooe_crosscheck |= MUSTSEQ_bit;

                if !(arg.isFieldChain)
                {
                    if (ooe_header)
                        ooe_header ~= ", ";
                    else
                        ooe_header = "(";

                    //
                    mut ptrflip = false;
                    let annot   = typeAnnot(arg);
                    let id      = emitTEMPVAR(:annot, :ptrflip);

                    ooe_header ~= id;
                    ooe_header ~= " = ";
                    ooe_header ~= ptrflip   ? "&(" ~ src ~ ")"
                                            : src;

                    src         = ptrflip   ? "*" ~ id
                                            : cgMove(arg.type, id);
                }
            }

            item_src ~= src;
        }

        ooe_crosscheck == MUSTSEQ_mask || fail(
            "OOE crosscheck failed: codegen sequenced " ~ ooe_crosscheck
                                ~ ", but solver wants " ~ MUSTSEQ_mask ~ ": "
                                ~ args.map(|x| x.kind.str).join("|"));

        fn ooeWrap(src: string)
        {
            return ooe_header
                 ? ooe_header ~ ", " ~ src ~ ")"
                 : src;
        }


        //

        fn REST(start?: int)
        {
            mut src = "";
            for (mut i = start; i < item_src.len; i++)
            {
                let item = item_src[i];
                if (!item)
                    continue;

                if (src)
                    src ~= ", ";

                src ~= item_src[i];
            }

            return src;
        }

        fn ARG(i: int) item_src[i];


        //

        fn affectedByIntegerPromotions(type: Type)
        {
            if (type.is_ref || /* is int or flags: */ !type.is_bitfield)
                return false;

            let c = type.canon;
            return c.len >= 2 && c[1] == '8'
                || c.len >= 3 && c[1, 3] == "16";
        }

        fn unpromote(expr: string)
        {
            if (isNative && node.type.affectedByIntegerPromotions)
                return typeAnnotBase(node.type) ~ "(" ~ expr ~ ")";

            return expr;
        }

        fn emitPostfixOp(op: string)
        {
            return unpromote(ARG(0) ~ op);
        }

        fn emitPrefixOp(op: string)
        {
            return unpromote(op ~ ARG(0));
        }

        fn emitBinaryOp(op: string)
        {
            args.len == 2 || fail("args.len != 2");

            if (binSkipParens(op, mode) && !ooe_header)
                return ARG(0) ~ " " ~ op ~ " " ~ ARG(1);

            return ooeWrap(unpromote("(" ~ ARG(0) ~ " " ~ op ~ " " ~ ARG(1) ~ ")"));
        }

        fn emitMethodCall(id: string)
        {
            return ooeWrap(ARG(0) ~ id ~ "(" ~ REST(1) ~ ")");
        }

        fn emitFunctionCall(id: string, open = "(", close = ")")
        {
            return ooeWrap(id ~ open ~ REST ~ close);
        }


        // Builtin specs.

        if (isNative && target.name[0] == '\n')
        {
            mut id = target.name.slice(
                hacks::NativeHacks(target.name)
                    .name_start_idx + 1);

            let idx = id.find('\n');
            if (idx > -1)
            {
                include(id.slice(0, idx));
                id = id.slice(idx + 1);
            }

            if (id[0] == '.')
            {
                if (args.len > 1)
                    return emitMethodCall(id);  // X`.id`(a, b)

                return emitPostfixOp(id);       // X`.a`
            }

            if (id[0] == '/')
                return ooeWrap(emitBuiltin(id, item_src, node));

            if (args)
            {
                if (id.hasIdentifierChars)
                    return emitFunctionCall(id);

                return emitBinaryOp(id);
            }

            return id;
        }

        //
        if (target.kind == "type")
        {
            if (!args)
                return cgDefault(target.type);

            let t = tryLookupUserType(target.type) || fail(
                "cgCall: defctor/type not a struct nor a user primitive.");

            let base = typeAnnotBase(target.type);

            if (t.kind == "flags")
                return emitFunctionCall(base, "((", ") & MASK_" ~ base ~ ")");

            if (t.kind == "primitive" || t.kind == "enum")
                return emitFunctionCall(base, "(", ")");

            if (t.kind == "struct" || t.kind == "union")
                return emitFunctionCall(base, " { ", " }");

            BUG("Unknown usertype kind: " ~ t.kind);
        }

        if (node.target.modid && target.kind == "fn")
            ensureFnUsable(node.target);

        let id = target.name || fail();

        if (args.len <= 2)
        {
            if (target.kind == "var")
            {
                // So we don't look for variables that aren't there.
                if (target.type.type_isZST)
                    return cgDefault(target.type);

                if (!node.target.isLocal)
                {
                    cgGlobal(node.target);

                    return rootNS(ID(id)); // TODO ensure const emit.
                }

                // Derefing ptrs.
                shadow let id = localID(:node.target);
                if (node.target.F_HOIST_asPtr)
                    return "(*" ~ id ~ ")";

                return id;
            }

            if (target.kind == "field")
                return ARG(0) ~ "." ~ ID(id);

            if (target.kind == "enumv")
                return cgEnumv(target.type, id);

            if (node.target.isOp)
            {
                if (args.len == 1)
                    return cpp::hasPostfix(id)  ? emitPostfixOp(id.valid_operator)
                                                : emitPrefixOp (id.valid_operator);

                if (args.len == 2)
                {
                    if (id == "[]")
                    {
                        if (mode & M_MOVE)
                            return ARG(0) ~ ".try_steal(" ~ ARG(1) ~ ")";

                        return ARG(0) ~ "[" ~ ARG(1) ~ "]";
                    }

                    // Skip some of the ridiculous parens.
                    return emitBinaryOp(id.valid_operator);
                }
            }

            if (id == "STEAL" && args.len == 1)
                return cgMove(node.type, ARG(0));
        }

        isNative && fail("Unknown __native: `" ~ id ~ "`.");

        return emitFunctionCall(rootNS(node.target.fnID));
    }

    fn cgEnumv(type: Type, id: string)
    {
        let base = typeAnnotBase(type);
        return base ~ "_" ~ id;
    }

    fn rootNS(id: string)
    {
        if (_current_fn._ids_used.has(id))
            return "::" ~ id;

        return id;
    }

    fn emitBuiltin(id: string, args: string[], node: SolvedNode): string
    {
        if (id == "/prim/convert")
        {
            let output  = node.type;
            let input   = node.items.only.type;

            let cast    = typeAnnotBase(output);

            if (input.is_integral && output.is_integral &&
                input.is_unsigned != output.is_unsigned)
            {
                // When casting between signed and unsigned integers,
                //  we always go through an intermediate unsigned type
                //   that is as big as the signed type:
                //
                //  i8 -> u32 :=  i8 ->  u8 -> u32
                // u32 ->  i8 := u32 ->  u8 ->  i8
                //
                //  u8 -> i32 :=  u8 -> u32 -> i32
                // i32 ->  u8 := i32 -> u32 ->  u8
                //
                // This means that we only move the sign bit around
                //  when casting between signed types.
                //
                mut mid_t       = input.is_unsigned ? output : input;
                mid_t.canon[0] == 'i' || fail();
                mid_t.canon[0]  = 'u';

                if (mid_t.canon != output.canon &&
                    mid_t.canon != input.canon)
                {
                    let inner = typeAnnotBase(mid_t);

                    return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
                }
            }
            else if (input.canon == t_byte.canon &&
                    output.canon != t_byte.canon)
            {
                // Go through unsigned char.
                let inner = typeAnnotBase(t_u8);

                return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
            }

            return cast ~ '(' ~ args.only ~ ')';
        }

        fail("Unknown builtin: " ~ id);
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu_STR";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn annotateZST()
    {
        return "void";
    }

    fn cgLiteral(node: SolvedNode, mode: i32): string
    {
        mut src = node.value;

        // Remove underscores, if any.
        mut idx: int;
        while ((idx = src.find('_', start: idx)) >= 0)
            src.splice(idx, 1);

        let base = tryLookupUserType(node.type).base || node.type.canon;

        if (base.starts(with: 'u'))
            if (!src.has('u'))
                src ~= 'u';

        if (base.starts(with: 'f'))
        {
            if (!src.has('.') && !src.has(src.has('x') ? 'p' : 'e'))
                src ~= ".0";

            if (base == "f32")
            {
                if (src.has('x'))
                    src = "float(" ~ src ~ ")";
                else
                    src ~= "f";
            }
            else if (base != "f64")
            {
                assert();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        if (base.starts(with: 'i') || base.starts(with: 'u'))
        {
            // One of those paradoxes.
            if (src.len > 16)
            {
                let parse = intlit::Intlit(src);
                if (parse.negative && parse.absval == 0x8000000000000000)
                    return "(-9223372036854775807-1)";
            }

            if (base == "u64" || base == "i64") {
                if (!src.has('l'))
                    return src ~ "ll";
            }
            else if (base != "u32" && base != "i32")
            {
                // Don't do this for enums,
                //  the type declaration ends up with casts to itself.
                if !(mode & M_ENUM_DECL)
                    return typeAnnotBase(node.type) ~ "(" ~ src ~ ")";
            }
        }

        //
        return src;
    }

    fn cgEmpty(node: SolvedNode, mode: i32): string
    {
        if (mode & M_STMT)
            return "";

        if (mode & M_ARG_TO_NATIVE && node.type.isAddrOfFn)
        {
            mut last: Target;
            unpackAddrOfFn(node.type.canon, |target|
            {
                last && fail("Codegen cannot decine which fn to pass as a c++ lambda at __native callsite: " ~ last.name ~ " vs " ~ target.name);
                last = target;

                target.kind == "fn" || fail("Cannot codegen a non-fn: " ~ target.kind ~ " " ~ target.name);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    if (args[i].flags & F_IMPLICIT)
                        fail("How do we codegen F_IMPLICIT arguments through lambdas?");

                ensureFnUsable(target);
            });

            return "&" ~ fnID(last);
        }

        if (!node.type)
            return "0";

        return cgDefault(node.type);
    }


    //

    fn acceptsBool(type: Type)
    {
        // Basically, will a bool do, e.g. -
        //  do you need a ternary or do || and && do the job, etc.
        //
        return isAssignable(host: type, t_bool);
    }

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(shadow node: SolvedNode)
            node.kind == "if" || node.kind == "and"
                ? " " ~ cgNode(node, M_STMT, debug: "cgIf.blockWrap_unlessIf")
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL | (stmt && M_PARENS), debug: "cgIf[cond]");
        let cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1, debug: "cgIf[cons]"));
        let alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2, debug: "cgIf[alt]"));

        if (stmt)
            return "if (" ~ cond ~ ")" ~ cons ~ (alt ? _indent ~ "else" ~ alt : "");

        return "(" ~ cond ~ " ? " ~ cons ~ " : " ~ alt ~ ")";
    }

    fn cgAnd(node: SolvedNode, mode: i32, debug!: string): string
    {
        return cgAnd(:node.items, :node.type, :mode, :debug);
    }

    fn cgAnd(items: [SolvedNode], type: Type, mode: i32, debug!: string): string
    {
        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (";
            cgAndOr_concat(src, " && ", items[0, items.len - 1], parens: true);
            src ~= ")";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.acceptsBool)
        {
            cgAndOr_concat(src, " && ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            if (type.is_mutref)
            {
                for (mut i = 0; i < items.len; i++)
                {
                    let item = items[i];
                    if (i < items.len - 1)
                        src ~= "!" ~ via(:tv, :type, item);
                    else
                        src ~= cgNode(item, debug: debug ~ ".cgAnd[mutref " ~ i ~ "]");
                }
            }
            else
            {
                let N = items.len;
                let retSecondLast = items[N - 1].type.is_never;

                let condEnd = retSecondLast ? N - 2 : N - 1;
                cgAndOr_concat(src, " && ", items[0, condEnd]);

                if (retSecondLast)
                {
                    if (condEnd) src ~= " && ";
                    src ~= "!" ~ via(:tv, :type, items[N - 2]);
                    src ~= cgNode(items[N - 1], debug: debug ~ ".cgAnd[retSecondLast]"); // FAIL
                }
                else
                {
                    src ~= " ? " ~ cgNode(items[N - 1], debug: debug ~ ".cgAnd[usual]");
                    src ~= " : " ~ cgDefault(type);
                }
            }
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn cgOr(node: SolvedNode, mode: i32): string
    {
        let type  = node.type;
        let items = node.items;

        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (!(";
            cgAndOr_concat(src, " || ", items[0, items.len - 1], parens: true);
            src ~= "))";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.acceptsBool)
        {
            cgAndOr_concat(src, " || ", items, parens: true);
        }
        else
        {
            mut tv: TEMPVAR;

            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || fail();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    shadow let items = item.items;
                    tail = items[items.len - 1] || fail();

                    cgAndOr_concat(src, " && ", items[0, items.len - 1]);
                    src ~= " && ";
                }

                //
                src ~= via(:tv, :type, tail);
            }

            let tail = items[items.len - 1] || fail();
            src ~= cgNode(tail, debug: "cgOr");
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn via(ref tv: TEMPVAR, type: Type, expr: SolvedNode): string
    {
        if (expr.isFieldChain)
        {
            let trivial = cgNode(expr, debug: "TEMPVAR[fieldChain]");
            return trivial ~ " ? " ~ trivial ~ " : ";
        }

        if (expr.kind == "copy" || expr.kind == "move")
        {
            let kind = expr.kind;
            shadow let expr = expr.items.only;
            if (expr.isFieldChain)
            {
                let trivial = cgNode(expr, debug: "TEMPVAR[copymov/fieldChain]");
                return trivial ~ " ? " ~ cgMoveOrClone(:kind, :type, trivial) ~ " : ";
            }

            // TODO fix the copies -
            //  we can copy AFTER the test,
            //   will also result in shorter code.
            //
            // TODO this is true for any transformation that does not affect truthiness.
            //  For example a conversion from i8 to i32 cannot affect truthiness, but i32 to i8 can.
            //   Can we generalize this? This would be fantastic.
            //
            // But copies are the worst.
        }

        return via(:tv, :type, expr: cgNode(expr, debug: "TEMPVAR[usual]"));
    }

    fn via(ref tv: TEMPVAR, type: Type, expr!: string): string
    {
        if (!tv.id)
            tv.id = emitTEMPVAR(
                tv.annot = typeAnnot(type), :tv.ptrflip);

        if (tv.ptrflip)
            return "*(" ~ tv.id ~ " = &(" ~ expr ~ ")) ? *" ~ tv.id ~ " : ";

        if (type.is_trivial)
            return "(" ~ tv.id ~ " = " ~ expr ~ ") ? " ~ tv.id ~ " : ";

        return "(" ~ tv.id ~ " = " ~ expr ~ ") ? static_cast<" ~ tv.annot ~ "&&>(" ~ tv.id ~ ") : ";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var")
            return true;

        return false;
    }

    fn cgAndOr_concat(ref src: string, op: string, items: [SolvedNode], parens!?: bool)
    {
        let mode = M_RETBOOL | (parens && items.len == 1 && M_PARENS);
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= op;

            let item = items[i];
            let term = cgNode(item, :mode, debug: "cgAndOr_concat[" ~ i ~ "]");

            if (item.is_void)
                src ~= "(" ~ term ~ ", 0)";
            else
                src ~= term;
        }
    }

    fn cgDefault(type: Type): string
    {
        type.is_mutref && fail("Cannot definit mutrefs.");

        if (type.type_isZST)
            return "void()";

        if (type.is_ref)
        {
            let annot = typeAnnot(type);
            if (annot.starts(with: "fu::view"))
                return annot ~ "{}";

            include("<fu/default.h>");
            return "(*(const " ~ typeAnnot(clear_refs(type)) ~ "*)fu::NIL)";
        }

        return typeAnnot(type) ~ "{}";
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        mut end = src.len - 1;

        // :(
        src[end] == '}' || fail();
        if (postfix.if_first == '\n')
            for (mut i = end; i --> 0 && src[i] == ' '; )
                end--;

        return src.slice(0, end) ~ postfix ~ '}';
    }

    fn cgLoop(node: SolvedNode): string
    {
        let can_cont0 = _current_fn.can_cont;
        let can_break0 = _current_fn.can_break;

        defer {
            _current_fn.can_cont = can_cont0;
            _current_fn.can_break = can_break0;
        }

        _current_fn.can_cont = [];
        _current_fn.can_break = [];

        //
        let items = node.items;

        let n_init = items[LOOP_INIT];
        let n_cond = items[LOOP_COND];
        let n_body = items[LOOP_BODY];
        let n_pcnd = items[LOOP_POST_COND];
        let n_post = items[LOOP_POST];

        let init = n_init && cgNode(n_init, M_STMT, debug: "cgLoop[init]");
        let cond = n_cond && cgNode(n_cond, M_RETBOOL | M_PARENS, debug: "cgLoop[cond]");
        let pcnd = n_pcnd && cgNode(n_pcnd, M_RETBOOL, debug: "cgLoop[pcnd]");
        let post = n_post && cgNode(n_post, debug: "cgLoop[post]");

        //
        let name = "LL_" ~ _current_fn.num_labels++;
        let helpers = node.helpers;
        _current_fn.can_break = helpers;

        // Blockvals! /////////////////////////////////////////////////////////////////////////////
        // TODO FIX duplication with blocks, loop labels should just be a block around the loop.
        let blocks0  = _current_fn.blocks.len;
        defer _current_fn.blocks.shrink(blocks0);

        _current_fn.blocks ~= cg_Block(:name, :helpers, false, false);
        ///////////////////////////////////////////////////////////////////////////////////////////

        mut body = n_body && blockWrapSubstatement(n_body, M_LOOP_BODY);

        //
        let labelUsed  = body.has("goto " ~ name ~ ";"); // TODO FIX track label usage
        let breakLabel = labelUsed && " " ~ name ~ ":;";

        //
        if (pcnd)
        {
            if (init || post || cond)
                fail("TODO extended loop.");

            return "do" ~ body ~ _indent ~ "while (" ~ pcnd ~ ")" ~ breakLabel;
        }

        if (init || post || !cond)
            return "for (" ~ init ~ "; " ~ cond ~ "; " ~ post ~ ")" ~ body ~ breakLabel;

        return "while (" ~ cond ~ ")" ~ body ~ breakLabel;
    }

    fn cgTryCatch(node: SolvedNode): string
    {
        let items   = node.items;
        let try     = blockWrapSubstatement(items[0]);
        let err     = localID(items[1].target, dedupe: true);
        let catch   = blockWrapSubstatement(items[2]);

        return _indent ~ "try"
             ~ _indent ~ "{"
             ~  try
             ~ _indent ~ "}"
             ~ _indent ~ "catch (const std::exception& o_0)"
             ~ _indent ~ "{"
             ~ _indent ~ "    fu_STR " ~ err ~ " = fu_TO_STR(o_0.what());\n"
             ~  catch
             ~ _indent ~ "}\n";
    }

    fn cgCompilerPragma(node: SolvedNode): string
    {
        let cmd = node.value;

        // Verbatim cpp nonsense.
        if (cmd == "emit"  ||
            cmd == "input" || cmd == "output" || cmd == "clock")
        {
            mut result = "";

            for (mut i = 0; i < node.items.len; i++)
            {
                shadow let node = node.items[i];
                if (node.kind == "str")
                    result ~= node.value;
                else if !(node.type_isZST)
                    result ~= cgNode(:node, debug: "compiler:emit");
            }

            // TODO FIX the arbitrary indentation of emit blocks gets flagged by gcc.
            //  I guess the legit fix here would be to reindent the snippet.
            //
            _gcc_ignore.set::add("-Wmisleading-indentation");

            if (_current_fn)
                return result;

            _top_emits ~= result;
            return "";
        }

        // Misc hacks.
        let eachStringLiteral = |visit|
        {
            for (mut i = 0; i < node.items.len; i++)
            {
                let item = node.items[i];
                if (item.kind != "str")
                    fail("compiler link: All arguments must be string literals, got a `" ~ item.kind ~ "`.");

                visit(item.value);
            }

            return "";
        };

        if (cmd == "link")
            eachStringLiteral: |i|
                HACK_link.set::add(i);

        if (cmd == "include_dirs")
            eachStringLiteral: |i|
                HACK_include_dirs.set::add(i);

        if (cmd == "sources")
            eachStringLiteral: |i|
                HACK_extra_sources.set::add(i);

        if (cmd == "include")
            eachStringLiteral: |i|
                include(i.starts(with: '<') ? i : '"' ~ i ~ '"');

        BUG("Unknown compiler pragma: " ~ cmd);
    }


    //

    fn cgNode(node: SolvedNode, debug!: string, mode?: i32, callarg?: Type): string
    {
        let k = node.kind || fail("cgNode: No node.kind: " ~ debug);
        HERE(node);

        if (k == "not")         return cgNot(node);
        if (k == "call")        return cgCall(node, mode);

        if (k == "int")         return cgLiteral(node, mode);
        if (k == "real")        return cgLiteral(node, mode);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node, mode, :callarg);
        if (k == "definit")     return cgDefinit(node, mode, :callarg);
        if (k == "bool")        return node.value;

        if (k == "copy")        return cgMoveOrClone(node, mode);
        if (k == "move")        return cgMoveOrClone(node, mode);

        if (k == "if")          return cgIf(node, mode);
        if (k == "or")          return cgOr(node, mode);
        if (k == "and")         return cgAnd(node, mode, :debug);

        if (k == "letdef")      return cgLetDef(node);

        if (k == "root")        return cgRoot(node);
        if (k == "block")       return cgBlock(node, mode, debug: "block");
        if (k == "argid")       return cgComma(node.items, debug: "argid");

        // Empties.
        if (k == "fndef")       return cgFnDef(node, mode); // TODO no point in this here
        if (k == "empty")       return cgEmpty(node, mode);

        // Stuff that we can't cg as expressions.
        if !(mode & M_STMT)
            return cgBlock(node, :mode, debug: k ~ "!M_STMT");

        if (k == "jump")        return cgJump(node);

        if (k == "loop")        return cgLoop(node);
        if (k == "try")         return cgTryCatch(node);
        if (k == "defer")       return cgDefer(node);

        if (k == "pragma")      return cgCompilerPragma(node);

        return fail("TODO: " ~ k);
    }


    //

    fn cgMoveOrClone(node: SolvedNode, mode: i32): string
    {
        let expr = node.items.only;

        // Less verbose trivial value returns.
        if (mode & M_RETURN && node.type.is_trivial)
            return cgNode(expr, debug: "retTrivCpy");

        if (node.kind == "move")
        {
            // NRVO now here, solver doesn't care.
            if (mode & M_RETURN)
            {
                fn supportsNRVO(t: Target)
                    t.kind == "var" && !(t.flags & F_ARG)
                        // && o.local_of == _current_fn.target.index
                        && !t.solved.type.is_ref;

                let nrvo = expr.kind == "call"
                        && expr.items.len == 0
                        && expr.target.supportsNRVO;

                if (nrvo)
                    return "/*NRVO*/ " ~ cgNode(expr, debug: "NRVO");
            }

            if (!node.type.is_trivial)
            {
                // Moving from a constref return,
                //  it's an expressiveness problem in cpp,
                //   easiest way to work around it is with a const_cast:
                //
                //   struct X;
                //
                //   const X& func(const X& val) {
                //       return val;
                //   }
                //
                //   X&& func(X&& val) {            // Alternatively:
                //       return (X&&)func(val);     //  return static_cast<X&&>(const_cast<X&>(func(val)))
                //   }
                //
                if (expr.kind == "call")
                {
                    fn Lifetime_hasArgPositions(lifetime: Lifetime)
                    {
                        for (mut i = 0; i < lifetime.uni0n.len; i++)
                            if (lifetime.uni0n[i].Region_isArgPosition)
                                return true;

                        return false;
                    }

                    //
                    let o = GET(expr.target);

                    // Special handling for stealing form arrays.
                    if (o.kind == "__native" && o.name == "[]")
                        return cgNode(expr, debug: "cgMoveOperator[]", mode: M_MOVE);

                    //
                    if (!o.type.is_mutref && o.type.lifetime.Lifetime_hasArgPositions)
                        return "/* MOVE_FROM_CONST_REF */static_cast<"
                             ~ typeAnnotBase(o.type) ~ "&&>(const_cast<"
                             ~ typeAnnotBase(o.type)  ~ "&>("
                             ~ cgNode(expr, debug: "cgMoveFromConstRefHelper") ~ "))";
                }
            }
        }

        return cgMoveOrClone(node.kind, node.type, cgNode(expr, debug: "cgMoveOrClone"));
    }

    fn cgMoveOrClone(::kind, type: Type, src: string): string
    {
        if (kind == "move")
            return cgMove(type, src);

        return cgClone(type, src);
    }

    fn cgMove(type: Type, src: string): string
    {
        if (type.is_primitive)
            return cgClone(type, src);

        return "static_cast<" ~ typeAnnotBase(type) ~ "&&>(" ~ src ~ ")";
    }

    fn cgClone(type: Type, src: string): string
    {
        if (type.is_primitive)
            return src;

        return typeAnnotBase(type) ~ "(" ~ src ~ ")";
    }


    //

    fn emitTEMPVAR(annot: string, ref ptrflip!: bool, id?: string, expr?: string): string
    {
        ptrflip = annot[annot.len - 1] == '&';

        shadow let id = id || "_" ~ _current_fn.numTEMPVARs++;
        _current_fn.TEMPVARs ~=
            ptrflip ? annot[0, annot.len - 1] ~ "* " ~ id
                    : annot ~ " " ~ id ~ (expr ? " = " ~ expr : " {}"); // TODO dont init trivial

        return id;
    }

    fn cgNodes(nodes: SolvedNode[], mode?: i32, trail!?: string, debug!?: string): string[]
    {
        mut result: string[];

        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if (mode & M_STMT) swap(_tv0, _current_fn.TEMPVARs);
        defer {
            if (mode & M_STMT) swap(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        for (mut i = 0; i < nodes.len; i++)
        {
            let node    = nodes[i];
            let isTrail = trail && i == nodes.len - 1 && !node.is_never && !node.is_void;

            mut src     = node && cgNode(node, isTrail ? mode &~ M_STMT : mode, debug: debug ~ ".cgNodes");

            src || mode & M_STMT || fail("cgNodes: empty output for Node(kind=`" ~ node.kind ~ "` value=`" ~ node.value ~ "`).");

            if (mode & M_STMT && _current_fn.TEMPVARs)
            {
                result ~= _current_fn.TEMPVARs;
                _current_fn.TEMPVARs.clear();
            }

            if (isTrail)
                src = trail ~ "(" ~ src ~ ")";

            result.push(src);
        }

        return result;
    }


    //

    let root = module.out.solve.root;
    root.kind == "root" || fail();

    mut src = cgNode(root, debug: "cgRoot");


    // TODO FIX just add these as translation units,
    //  need proper hashing and everything, so they should just skip over compile & cg
    //   but otherwise work like our own generated sources.

    for (mut i = 0; i < HACK_extra_sources.len; i++)
    {
        let orig = HACK_extra_sources[i];
        let file = localPath(orig);
        src ~= "\n// " ~ orig ~ "\n";
        src ~= file::read(file);
    }


    //

    return CodegenOutput(:src,
        link:           HACK_link,
        include_dirs:   HACK_include_dirs,
        extra_sources:  HACK_extra_sources,
        defects:        _defects);
}
