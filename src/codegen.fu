import helpers;
import flags;
import types;
import quals;
import scope;
import context;
import bitset;
import cpp;
import module;
import structs;
import lifetime;
import usage;
import fail;

let SMALL_STRING_OPTI   = 15;
let SIGHASH_CHARS       = 4;

let M_STMT              = 1 << 0;
let M_RETBOOL           = 1 << 1;
let M_CONST             = 1 << 2;
let M_RETVAL            = 1 << 3;
let M_ARGUMENT          = 1 << 4;
let M_RETURN            = 1 << 5;
let M_FWDECL            = 1 << 6;
let M_PARENS            = 1 << 7;
let M_OPT_CURLIES       = 1 << 8;
let M_LOOP_BODY         = 1 << 9;
let M_MUTVAR            = 1 << 10;
let M_MOVABLE           = 1 << 11;
let M_ARG_TO_NATIVE     = 1 << 12;
let M_ENUM_DECL         = 1 << 13;
let M_CHECK_NEVER_LTR   = 1 << 14;
let M_STATIC_REF        = 1 << 15;
let M_VOID_EXPR         = 1 << 16;
let M_FN_BODY           = 1 << 17;

let MAIN_needed         = 1 << 0;
let MAIN_argv           = 1 << 1;
let MAIN_zst            = 1 << 2;


//

let use_INIT_PRIOIRTY   = true;
let use_STATIC_REF      = true;


//

struct StructDecl
{
    def:        string;
    declDepth:  i32;
}


//

pub fn cpp_codegen(
    implicit module: Module,
    implicit ctx: Context,
    implicit options: options::Options): CodegenOutput
{

    //

    let implicit mut _here: TokenIdx;

    nocopy struct Outputs
    {
        // #include ...
        _libs:              flat::Set(string);

        // diagnostics
        _gcc_ignore:        flat::Set(string);

        // static pragma emit
        _top_emits:         string[];

        // struct fwd decls
        _tfwd:              flat::Set(StructCanon);
        _tfwd_src:          string;

        // fn fwd decls
        _ffwd:              flat::Set(Target);
        _ffwd_src:          string;

        _ffwd_live_client:  string;
        _ffwd_live_nclient: string;

        // type definitions
        // TODO track separately, we dont need all types defined
        _tdef:              string;

        _tdef_stack:        StructDecl[];

        // fn definitions
        _fdef_started:      flat::Set(Target);
        _fdef_complete:     flat::Set(Target);
        _fdef:              string;

        // misc garbage
        _indent:            string;
        _hasMain:           i32;
        _test_cases:        string;

        _static_strings:    flat::Set(u64);
        _static_string_src: string;

        // experimentals
        HACK_link:          flat::Set(string);
        HACK_include_dirs:  flat::Set(string);
        HACK_extra_sources: flat::Set(string);

        // live
        _live_targets:      i32[];

        // testing
        _defects:           CGDefects;

        //
        _TODO_FIX_seenFns:  flat::Set(string);
    };

    let using mut outputs: Outputs;


    //

    outputs._indent = "\n";


    //

    enum PointerFlip {
        None = 0;
        VecRangeOrView;
        RawPointer;
    };


    //

    struct TEMPVAR {
        annot?:             string;
        id?:                string;
        ptr_flip?:          PointerFlip;
    };

    struct cg_Block
    {
        name:               string;
        helpers:            Helpers;
        has_val:            bool;
        ptr_flip:           PointerFlip;

        surviving_locals?:  i32[];
    };

    struct cg_CurrentFn // TODO FIX postfix/prefix non-pub symbols?
    {                   //  Or prefix structs with module name?
        using target:   Target;

        numTEMPVARs?:   i32;
        TEMPVARs?:      string[];

        blocks?:        cg_Block[];
        num_labels?:    i32;

        can_return?:    Helpers;
        can_break?:     Helpers;
        can_cont?:      Helpers;

        _ids_used?:     string[];
        _ids_dedupe_p?: i32[];
        _ids_dedupe_n?: i32[];

        // Hoisting now a little more robust.
        _hoisted?:      bitset::BitSet;
        _declared?:     bitset::BitSet;

        // Sanity check.
        _live_locals?:  i32[];
    };

    mut _current_fn: cg_CurrentFn;

    fn nested(index: i32)
    {
        return index && Target(
            :_current_fn.modid,
            :_current_fn.globid,
            locid: index);
    }

    using fn GET(target: Target)
    {
        let modid   = target.modid;
        let globid  = target.globid;
        let locid   = target.locid;

        let m = modid == module.modid
            ? module
            : ctx.modules[modid];

        if (locid)
        {
            let ext = m.out.solve.scope.extended[globid];
            return ext.args_n_locals[ext.indexOfLocal(:locid)];
        }

        return m.out.solve.scope.overloads[globid - 1];
    }

    using fn EXT(target: Target)
    {
        let locid   = target.locid;
        if (locid)
            return [];

        let modid   = target.modid;
        let globid  = target.globid;

        let m = modid == module.modid
            ? module
            : ctx.modules[modid];

        return m.out.solve.scope.extended.unless_oob(globid);
    }


    //

    shadow fn BUG(reason?: string)
    {
        FAIL("THIS IS A COMPILER BUG.\n\n\tCODEGEN FAIL:\n\n\t" ~ (reason || "Assertion failed."));
    }

    fn noteDefect(defects: CGDefects)
    {
        if (defects & options.break_defects)
            BUG("CGDefect break: " ~ defects.str.ansi::qBAD);

        _defects |= defects;
    }


    //

    fn include(lib: string)
    {
        _libs.add(lib);
    }

    fn localPath(path: string)
    {
        return path.starts(with: '.')
             ? path::join(path::dirname(module.fname), path)
             : path;
    }


    //

    fn ifArrayRef_annotateAsSlice(type: Type)
    {
        // !copy && !resize
        return !(type.quals & (q_rx_resize | q_rx_copy));
    }

    fn ifArrayRef_annotateAsVec(lax type: Type)
    {
        return !type.ifArrayRef_annotateAsSlice()
            &&  type.vfacts & LeftAligned
            &&  type.vfacts & RightAligned;
    }

    fn ifArrayRef_annotateAsVecRange(type: Type)
    {
        return !type.ifArrayRef_annotateAsSlice()
            && !type.ifArrayRef_annotateAsVec();
    }

    fn ifArray_annotateAsVec(type: Type)
    {
        return !type.is_ref
            ||  type.ifArrayRef_annotateAsVec();
    }


    //

    fn typeAnnot(type: Type, mode?: i32): string
    {
        let fwd = typeAnnotBase(type, :mode);

        if (type.is_ref)
        {
            if (mode & M_STATIC_REF)
            {
                include("<fu/static_ref.h>");
                return "fu::static_ref<" ~ fwd ~ ">";
            }

            if (type.is_sliceable && !type.ifArrayRef_annotateAsVec
                    || fwd == "void")
            {
                return fwd;
            }

            if (type.is_mutref)
                return fwd ~ "&";

            // Pass primitives by value.
            if (type.isPassByValue)
                return (mode & M_ARGUMENT | mode & M_CONST) && !(mode & M_FWDECL)
                     ? "const " ~ fwd
                     : fwd;

            // Enable move from local.
            //
            //  let a = ...     // Some a = ...
            //  let b = a.b;    // B& b = a.b;      // const B& wouldn't allow move
            //  return b;       // return move(b);  // here
            //
            if (mode & M_MOVABLE && !type.is_trivial)
                return fwd ~ "&";

            return "const " ~ fwd ~ "&";
        }

        if ((mode & M_ARGUMENT) && !(type.isPassByValue))
            return fwd ~ "&&";

        // Const members cannot be moved from -
        //  So let's only do this for trivial types -
        //   Currently this is more of a way to validate the codegen.
        if ((mode & M_CONST) && (type.is_trivial))
            return "const " ~ fwd;

        return fwd;
    }

    fn primAnnotBase(c: string)
    {
        // Avoid #include noise when possible.
        if (c == "i32")     return "int";
        if (c == "i16")     return "short";
        if (c == "u32")     return "unsigned";

        if (c == "b8")      return "bool";
        if (c == "c8")      return "char";

        if (c == "f32")     return "float";
        if (c == "f64")     return "double";

        // char vs signed char vs unsigned char.
        if (c == "i8" || c == "u8")
        {
            include("<fu/int.h>");
            return "fu::" ~ c;
        }

        // Tough luck.
        include("<cstdint>");

        if (c == "i64")     return "int64_t";
        if (c == "i128")    return "__int128_t";

        if (c == "u16")     return "uint16_t";
        if (c == "u32")     return "uint32_t";
        if (c == "u64")     return "uint64_t";
        if (c == "u128")    return "__uint128_t";

        // Custom primitives.
        BUG("Unknown primitive: `" ~ c ~ "`.");
    }

    fn typeAnnotBase(type: Type, mode?: i32): string
    {
        let c = type.canon;

        if (type.is_primitive && (c.len < 4 || c.len == 4 && c[1 .. 4] == "128"))
            return primAnnotBase(c);

        if (c == "never")       return annotateNever();
        if (type.isIrrelevant)  return annotateZST();

        let arrayItem = tryClear_sliceable(type);
        if (arrayItem)
        {
            if (arrayItem.isIrrelevant)
                BUG("cg: We generate invalid c++ for void[]");

            // Arrays & strings.
            if (type.ifArray_annotateAsVec)
            {
                if (arrayItem == t_byte)
                    return annotateString();

                let itemAnnot = typeAnnot(arrayItem);

                include("<fu/vec.h>");
                return "fu::vec<" ~ itemAnnot ~ ">";
            }

            // vec_range - mutref to a window into an array/string,
            //              unfortunately slower than a vec& currently.
            //
            // Not sure how to optimize these out yet.
            //
            // We're going for vec_ranges to remove the distinction
            //  between arrays & slices, they make everything Just Work,
            //   TBD how we can get rid of them where they're never needed,
            //    which should be almost everywhere.
            //
            // Arguments to public non-template fns will be hardest to fix,
            //  unclear what to do short of:
            //
            //  A] global program optimisation [fragile],
            //  B] emitting multiple overloads [bloat].
            //
            let itemAnnot = typeAnnot(arrayItem);

            if (SELF_TEST)
                type.is_ref || BUG("!type.ifArray_annotateAsVec but !ref");

            if (type.ifArrayRef_annotateAsVecRange)
            {
                include("<fu/vec_range.h>");
                if (type.is_mutref || mode & M_MUTVAR)
                    return "fu::vec_range_mut<" ~ itemAnnot ~ ">";
                else
                    return "fu::vec_range<" ~ itemAnnot ~ ">";
            }

            // Slices - non-resizable/non-copiable windows into an array/string,
            //          the most efficient thing.
            if (SELF_TEST)
                type.ifArrayRef_annotateAsSlice || BUG("!ifArrayRef_annotateAsSlice")

            include("<fu/view.h>");
            if (type.is_mutref || mode & M_MUTVAR)
                return "fu::view_mut<" ~ itemAnnot ~ ">";
            else
                return "fu::view<" ~ itemAnnot ~ ">";
        }

        //
        let s   = lookupUserType(type) || BUG("TODO: " ~ type.canon);
        let id  = structID(s);

        let scp = parseStructCanon(type.canon);
        if (_tfwd.add(scp))
            declareStruct(id, s);

        return id;
    }

    fn structID(s: Struct)
    {
        // TODO extern struct (no shape hashing)
        if (s.shape.hash)
            return s.name ~ "_" ~ s.shape.hash.tea::digest62(chars: SIGHASH_CHARS);

        return s.name;
    }

    fn declareStruct(id: string, s: Struct)
    {
        if (s.basePrim)
            return declarePrimitive(id, s);

        //
        let tdef_stack0 = _tdef_stack.len;

        _tdef_stack ~= StructDecl();

        //
        let header  = s.kind ~ " " ~ id;
        _tfwd_src  ~= header ~ ";\n";

        let t = GET(s.target).type;

        let dedupe = s.name ~ "_" ~ s.shape.hash.tea::digest62();

        mut def = "\n                                #ifndef DEF_" ~ dedupe
                ~ "\n                                #define DEF_" ~ dedupe
                ~ "\n" ~ header ~ "\n{";

        if (options.dev & options::DEV_CG_LifetimeAnnots)
            def ~= "\n                                // shape_hash:    " ~ s.hash.hex64_lower
                 ~ "\n                                // non_triv_mask: " ~ s.non_triv_mask.hex64_lower;

        mut indent = "\n    ";
        mut xOpBool = "";

        let fields = s.items;
        for (mut i = 0; i < fields.len; i++)
        {
            let field = GET(fields[i].target);
            field.kind == "field" || BUG("Non-field struct item: " ~ field.name ~ " (" ~ field.kind ~ ") in " ~ t.canon);
            let annot = typeAnnot(field.type);
            if (annot != "void")
            {
                shadow let id = ID(field.name);
                def ~= indent ~ annot ~ " " ~ id ~ ";";
                if (field.flags & F_PREDICATE)
                    xOpBool ~= "\n            || " ~ id;
            }
        }

        if !(t.is_rx_copy)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "&) = delete;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
        }
        else if (s.target.status & SS_TYPE_RECUR)
        {
            def ~= "\n    " ~ id ~ "(const " ~ id ~ "&) = default;";
            def ~= "\n    " ~ id ~ "(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(" ~ id ~ "&&) = default;";
            def ~= "\n    " ~ id ~ "& operator=(const " ~ id ~ "& selfrec) { return *this = " ~ id ~ "(selfrec); }";
        }

        def ~= "\n    explicit operator bool() const noexcept";
        def ~= "\n    {";
        def ~= "\n        return false";
        def ~= xOpBool;
        def ~= "\n        ;";
        def ~= "\n    }";

        def ~= "\n};\n                                #endif\n";

        // Sort and output all struct decls ordered by dep depth.
        _tdef_stack[tdef_stack0] =
            StructDecl(:def, :s.declDepth);

        if (!tdef_stack0)
        {
            _tdef_stack.sort(|a, b|
                a.declDepth < b.declDepth
                    || a.declDepth == b.declDepth && a.def <> b.def < 0);

            for (mut i = 0; i < _tdef_stack.len; i++)
                _tdef ~= _tdef_stack[i].def;

            _tdef_stack.clear();
        }
    }

    fn declarePrimitive(id: string, s: Struct)
    {
        let basePrim    = primAnnotBase(s.basePrim);
        let members     = s.items;

        mut def = "\n                                #ifndef DEF_" ~ id
                ~ "\n                                #define DEF_" ~ id;

        if (s.kind != "enum" || !members)
        {
            // Non-enum primitives, do simple typedefs,
            //  the whole point of using enums is for debuggers to provide nice feedback,
            //   which can't happen for arithmetic primitives,
            //    unfortunately also true for flags.
            //
            _tfwd_src ~= "typedef " ~ basePrim ~ " " ~ id ~ ";\n";

            members.each: |member.target|
                def ~= "\ninline constexpr " ~ id ~ " " ~ id ~ "_" ~ member.name
                        ~ " = " ~ cgNode(member.solved) ~ ";";

            // Flags cast.
            if (s.kind == "flags")
            {
                mut mask = "";
                members.each: |member.target|
                {
                    if (!mask)
                        mask = "\n\ninline constexpr " ~ id ~ " MASK_" ~ id ~ "\n    = ";
                    else
                        mask ~= "\n    | ";

                    mask ~= id ~ "_" ~ member.name;
                }

                if (mask)
                {
                    mask ~= ";";
                    def ~= mask;
                }
            }
        }
        else
        {
            // We won't be using scoped enums (enum class) for now -
            //  a] They don't work for flags enums & co,
            //  b] Importantly, they can't have an explicit operator bool,
            //      so they need verbose boolchecks, not great.
            //
            let header      = "enum " ~ id ~ ": " ~ basePrim;

            _tfwd_src  ~= header ~ ";\n";
            def ~= "\n" ~ header ~ "\n{";

            members.each: |member.target|
                def ~= "\n    " ~ id ~ "_" ~ member.name
                        ~ " = " ~ cgNode(member.solved, mode: M_ENUM_DECL) ~ ",";

            def ~= "\n};";
        }

        def ~= "\n                                #endif\n";

        //
        _tdef ~= def;
    }


    //

    fn collectDedupes(
        mut values: flat::Set(string),
        prefix?: string, suffix = "\n",
        header?: string, footer = "\n"): string
    {
        mut out = "";

        if (values)
            out ~= header;

        for (mut i = 0; i < values.len; i++)
            out ~= prefix ~ values[i] ~ suffix;

        if (out)
            out ~= footer;

        return out;
    }

    fn valid_operator(str: string): string
    {
        mut start = 0;
        mut some  = false;

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_')
            {
                if (!some)
                    start = i + 1;
                else
                    return str.slice(start, i);
            }
            else
            {
                some = true;
            }
        }

        return start ? str.slice(start) : str;
    }

    fn hex(x: u32)
        x < 10 ? ('0'.u32 +  x      ).byte
               : ('A'.u32 + (x - 10)).byte;

    fn xHH(c: u32)
        "x" ~ ((c >> 4) & 0xf).hex
            ~ ((c >> 0) & 0xf).hex;

    fn hex64_lower(v: u64)
    {
        mut str = "";
        for (mut i = 0; i < 16; i++)
        {
            let c = (v >> (i.u64 * 4)) & 0xf;
            str ~= byte(
                c < 10 ? '0'.u64 + c
                       : 'a'.u64 + c - 10);
        }

        return str;
    }

    fn valid_identifier(mut str: string): string
    {
        for (mut i = str.len; i --> 0; )
        {
            let c = str[i];
            if (c >= 'a' && c <= 'z' ||
                c >= 'A' && c <= 'Z' ||
                c >= '0' && c <= '9' ||
                c == '_') continue;

            str = str[.. i]
                ~ c.u32.xHH
                ~ str[i + 1 ..];
        }

        return ID(str);
    }

    fn cgRoot(shadow root: SolvedNode, scope: ScopeItem[..]): string
    {
        mut count: i32;
        let src    = cgStatements(root.items, :count);

        //
        for (mut i = 0; i < scope.len; i++)
        {
            let t = scope[i].target;
            if (t.modid == module.modid && t.kind == "fn" && t.isExtLinked)
                ensureFnDef(t);
        }

        //
        let main   = cgMain();

        return collectDedupes(_libs, prefix: "#include ")

            // Fwd-declared structs & enums.
            ~ _tfwd_src

            // Fwd-declared functions.
            ~ _ffwd_src

            // Hotswap fwd-decls grouped up in two ifdef branches.
            ~ (_ffwd_live_client && "\n                                #ifdef fu_HOTSWAP\n")
            ~ (_ffwd_live_client)
            ~ (_ffwd_live_client && "                                #else\n")
            ~ (_ffwd_live_nclient)
            ~ (_ffwd_live_client && "                                #endif\n")

            // Type definitions.
            ~ _tdef

            // String literals.
            ~ _static_string_src

            ~ collectDedupes(_gcc_ignore,
                header: "#pragma GCC diagnostic push\n",
                prefix: "#pragma GCC diagnostic ignored \"",
                suffix: "\"\n")

            ~ _top_emits.join()

            // Function definitions.
            ~ (_fdef && "\n#ifndef fu_NO_fdefs\n")
            ~ (_fdef)
            ~ (_fdef && "\n#endif\n")

            // Rest.
            ~ src
            ~ main

            //
            ~ (_gcc_ignore && "\n#pragma GCC diagnostic pop\n")
        ;
    }

    fn cgMain(): string
    {
        mut src = "";

        // So ideally everything test-related should be ifdefed.
        //  This means everything that's only used by test fns too,
        //   template specializations, etc.
        //
        // This basically implies we want to layer an entire cg scope,
        //  and run & ifdef everything it emits under an ifdef TESTSUITE
        //   or smth.
        //
        if (_test_cases)
        {
            src ~= "\n#define TESTSUITE TESTSUITE ## __COUNTER__\n"
            src ~= "\nstatic int TESTSUITE = (" ~ _test_cases ~ "\n    0);\n"
            src ~= "\n#undef TESTSUITE\n"
        }

        //
        if (_hasMain)
        {
            mut zst = "";
            if (_hasMain & MAIN_zst)
                zst = ", 0";

            src ~= "\nint main() { return fu_MAIN()" ~ zst ~ "; }";

            if (_hasMain & MAIN_argv)
            {
                // Main with cli args.
                annotateString();

                src = "\nint main(int argc, char* argv[])"
                    ~ "\n{"
                    ~ "\n    fu::vec<fu::str> args;"
                    ~ "\n    args.reserve(argc);"
                    ~ "\n"
                    ~ "\n    for (int i = 0; i < argc; i++)"
                    ~ "\n        args.push(fu::to_str(argv[i]));"
                    ~ "\n"
                    ~ "\n    return fu_MAIN(static_cast<fu::vec<fu::str>&&>(args))" ~ zst ~ ";"
                    ~ "\n}";
            }

            src ~= "\n";
        }

        return src;
    }


    //

    fn localID(target: Target, dedupe?: bool)
    {
        let o  = GET(target);
        mut id = o.name;

        // CLOSURE-ID-HACK
        let cid = hacks::tryParseClosureID(:id);
        if (cid.target)
            id = GET(cid.target).name;
        // CLOSURE-ID-HACK

        id = ID(id).valid_identifier;

        let locid = target.locid;
        if (locid)
        {
            fn _ids_used    = _current_fn._ids_used;

            // Dedupe #1.
            if (dedupe)
            {
                mut dupes = 0;

                :REPEAT
                for (;;)
                {
                    let candidate = dupes
                        ? id ~ '_' ~ dupes
                        : id;

                    for (mut i = 0; i < _ids_used.len; i++)
                    {
                        if (_ids_used[i] == candidate)
                        {
                            dupes++;
                            continue :REPEAT;
                        }
                    }

                    _ids_used ~= candidate;
                    break;
                }

                if (dupes)
                    (locid < 0
                        ? _current_fn._ids_dedupe_n.grow_if_oob(-locid)
                        : _current_fn._ids_dedupe_p.grow_if_oob(+locid)) = dupes;
            }

            // Dedupe #2.
            let dupes = locid < 0
                ? _current_fn._ids_dedupe_n.unless_oob(-locid)
                : _current_fn._ids_dedupe_p.unless_oob(+locid);

            if (dupes)
                return id ~ '_' ~ dupes;
        }

        return id;
    }


    //

    fn cgStatements(nodes: SolvedNode[], ref count!: int, trail!?: string): string
    {
        let lines = cgNodes(nodes, M_STMT | M_CHECK_NEVER_LTR, :trail);
        count = lines.len;

        mut src = "";
        for (mut i = 0; i < lines.len; i++)
        {
            let line = lines[i];
            if (line)
                src ~= (line.if_first == '\n' ? '\n' ~ line : _indent ~ line)
                     ~ (line.if_last == ';' ? '\n' : ';');
        }

        return src;
    }

    fn cgComma(nodes: SolvedNode[]): string
    {
        shadow let items = cgNodes(nodes, mode: M_CHECK_NEVER_LTR);
        if (!items.len)
        {
            noteDefect(IrrelevantLiteral);
            return "void()";
        }

        if (items.len == 1)
            return items[0];

        mut src = "(";
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= ", ";

            src ~= items[i];
        }

        return src ~ ")";
    }


    //

    fn blockWrapSubstatement(node: SolvedNode, mode?: i32): string
        cgBlock(node, mode: M_STMT | M_OPT_CURLIES | mode);

    fn isHoistable(locid: i32)
        locid > 0;

    fn cgBlock(node: SolvedNode, mode: i32): string
    {
        let items   = node.kind == "block"  ? node.items : [ node ];
        let helpers = node.kind == "block" && node.helpers;

        // We now hoist here.
        if !(mode & M_FN_BODY) {
            node.lifetime.Lifetime_each: |locid|
            {
                if (isHoistable(:locid) && !_current_fn._declared.has(locid))
                {
                    set_isHoisted(:locid);

                    // TODO FIX declaring here to emit the tempvars
                    //  before the block captures tv0.
                    binding(target: locid.nested);
                }
            }
        }

        ///////////////////////////////////////////
        if (mode & M_LOOP_BODY)
            _current_fn.can_cont = helpers;
        ///////////////////////////////////////////

        {
            let tail = items.if_last;
            if (tail.kind == "let"    || tail.kind == "letdef" ||
                tail.kind == "struct" || tail.kind == "fn"     ||
                tail.kind == "defer")
            {
                // Ran into bad cg alla:
                //
                //  if (x)
                //      let x = ...;
                //
                //  do stuff with x;
                //
                BUG("cgBlock: tailing " ~ tail.kind);
            }
        }

        if !(mode & M_STMT)
        {
            // Report instances of immediately returned local variables:
            //
            //      { let x = ...; x }
            //
            if (items.len >= 2)
            {
                let last = items[items.len - 1];
                let expr = last.kind == "return" && last.items
                    ? last.items[0]
                    : last;

                if (expr.kind == "call")
                {
                    let target = expr.target;
                    let prev = items[items.len - 2];
                    if (prev.kind == "letdef" && prev.target == target)
                        noteDefect(PointlessLocal);
                }
            }
        }

        // We'll try to avoid block expressions as much as we can.
        //  Instead of these loops it'd be nice if we knew all this stuff
        //   as node flags or something, or a jumpset or something:
        //      - if expressible as cpp expr (none of the below stuff),
        //      - if wrappable in a cpp lambda (no jumping up), etc.
        //
        fn exprOK(nodes: SolvedNode[..])
        {
            for (mut i = 0; i < nodes.len; i++)
            {
                let n = nodes[i];
                let k = n.kind;

                // TODO FIX doing this with a blacklist is mega stupid
                if (k == "jump" || k == "loop" || k == "try" || k == "defer" || k == "pragma")
                    return false;

                if (!n.items.exprOK)
                    return false;
            }

            return true;
        }

        let expr = !(mode & M_STMT);
        if (expr && items.exprOK)
            return cgComma(items);

        return cgBlock(items, skipCurlies: !!(mode & M_OPT_CURLIES), gnuStmtExpr: expr,
            :helpers, type: expr && node.type);
    }

    fn cgBlock(
        nodes: SolvedNode[], skipCurlies!: bool, gnuStmtExpr!: bool,
        helpers!: Helpers, type: Type): string
    {
        ///////////////////////////////////////////////
        let indent0         = _indent;
        let ids_used0       = _current_fn._ids_used.len;
        let live_locals0    = _current_fn._live_locals.len;

        defer
        {
            _indent         = indent0;

            _current_fn._ids_used.shrink(ids_used0);
            defer _current_fn._live_locals.shrink(live_locals0);
        }
        ///////////////////////////////////////////////

        _indent ~= "    ";

        mut open    = "{";
        mut close   = gnuStmtExpr ? "}))" : "}";
        mut trail   = "";

        let name    = "BL_" ~ _current_fn.num_labels++;

        mut has_val = !type.isIrrelevant;
        mut ptr_flip: PointerFlip;

        if (type.is_never)
        {
            has_val = false;

            if (gnuStmtExpr)
            {
                annotateNever();

                close   = "    (void)0;"
                        ~ indent0 ~ "}), fu::unreachable)";
            }
        }
        else if (has_val)
        {
            mut isMovedFrom = type.is_ref;
            type.lifetime.Lifetime_each: |locid|
            {
                if (!locid || !(nested(locid).status & SS_MOVED_FROM))
                {
                    isMovedFrom = false;
                    break;
                }
            }

            //
            mut annot: string;
            let id      = TEMPVAR_declare(
                :type, mode: isMovedFrom && M_MOVABLE,
                :annot, :ptr_flip, name && name ~ "_v");

            let outval  = TEMPVAR_consume(:ptr_flip, :id, :type);

            close       = "    (void)0;"
                        ~ indent0 ~ "}), " ~ outval ~ ")";

            trail       = TEMPVAR_init(:id, :ptr_flip);
        }

        // Blockvals! //////////////////////////////////////////////////////////////////////////////
        let blocks0  = _current_fn.blocks.len;
        defer _current_fn.blocks.shrink(blocks0);

        let surviving_locals = _current_fn._live_locals;
        _current_fn.blocks ~= cg_Block(
            :name, :helpers, :ptr_flip, :has_val,
            :surviving_locals);
        ////////////////////////////////////////////////////////////////////////////////////////////

        if (has_val)
            nodes.last.TEST_noDanglingRefs(:surviving_locals);

        //
        mut count: int;
        mut src = cgStatements(nodes, :count, :trail);

        // Block label & retval.
        let labelUsed = src.has("goto " ~ name ~ ";");
        if (labelUsed) // TODO FIX track label usage
        {
            close = "  } " ~ name ~ ":;" ~ indent0 ~ close;
            open  = "{ {";
        }

        //
        if (!skipCurlies || nodes.len != 1 || count != 1 || labelUsed || src.has('{') || src.has("if"))
        {
            mut gnuOpen = "";
            if (gnuStmtExpr)
            {
                noteDefect(GNUStmtExpr);
                gnuOpen = "(__extension__ (";
            }

            src = gnuOpen ~ indent0 ~ open ~ src ~ indent0 ~ close;
        }

        return src;
    }

    fn cgDefer(node: SolvedNode): string
    {
        include("<fu/defer.h>");

        let which = node.value == "err" ? "fu_DEFER_IF_ERR"
                  : node.value == "ok"  ? "fu_DEFER_IF_OK"
                                        : "fu_DEFER";

        return which ~ "(" ~ cgNode(node.items.only, M_STMT) ~ ")";
    }


    //

    fn isOp(target: Target)
    {
        let flags = target.flags;

        // Deal with it!
        //  We don't want to have subtle mismatches between the two,
        //   only assignment operators in c++ have guaranteed ooe,
        //    so it HAS to be an operator for this to hold.
        //
        // if (flags & F_OOE_RTL)
        //     return true;
        //
        // TODO FIX Well of course it doesn't just work,
        //  the primitive/relevant stuff below
        //   is not taken into account.
        //
        if !(flags & F_OPERATOR)
            return false;

        if (target.kind == "__native")
            return true;

        mut numArgs: int;
        mut primsOnly = true;

        let args = target.args;
        for (mut i = 0; i < args.len; i++)
        {
            let argType = args[i].type;
            if (!argType.isIrrelevant)
            {
                numArgs++;
                if (!argType.is_primitive)
                    primsOnly = false;
            }
        }

        if (!numArgs || numArgs > 2 || primsOnly)
            return false;

        let name = target.name;
        if (numArgs > 1)
            return cpp::hasBinary(name);

        return cpp::hasUnary(name);
    }

    fn fnID(target: Target)
    {
        let overload    = GET(target);
        let id          = overload.name || BUG();

        if (target.isOp)
            return "operator" ~ id.valid_operator;

        mut ret = id.valid_identifier;
        if (target.sighash && !(target.flags & F_EXTERN))
            (ret == "_" ? ret : ret ~= "_") ~=
                target.sighash.digest62(chars: SIGHASH_CHARS);

        return ret;
    }

    fn isExtLinked(overload: Overload)
    {
        return overload.flags & (F_PUB | F_EXTERN)
            && overload.kind != "inline";
    }

    fn isInlLinked(overload: Overload)
    {
        return !!(overload.flags & F_TEMPLATE);
    }

    fn fnLinkage(overload: Overload)
    {
        return    (  overload.type.is_never  && "[[noreturn]] ")
                ~ (  overload.isInlLinked    && "inline "      )
                ~ (!(overload.isExtLinked)   && "static "      );
    }

    fn cgFnSignature(target: Target): string
    {
        let overload    = GET(target);

        let host_args   = target.args;
        let annot       = typeAnnot(overload.type || BUG(), M_RETVAL);

        //
        mut id          = overload.name;
        if (id == "main")
        {
            _hasMain    = MAIN_needed;
            id          = "fu_MAIN";

            if (host_args)
                _hasMain |= MAIN_argv;
            if (overload.type.isIrrelevant)
                _hasMain |= MAIN_zst;
        }
        else
        {
            id          = fnID(target);
        }

        //
        mut src         = overload.fnLinkage ~ annot ~ " " ~ id ~ "(";

        mut some        = false;

        for (mut i = 0; i < host_args.len; i++)
        {
            if (host_args[i].isIrrelevant)
                continue;

            if (some)
                src ~= ", ";

            some = true;
            src ~= binding(host_args[i]);
        }

        if (overload.flags & F_OPERATOR && cpp::hasPostfix(overload.name))
            src ~= ", /*postfix*/int";

        src ~= ")";

        return src;
    }

    fn cgFnPrototype(target: Target, fnptr!?: bool)
    {
        ///////////////////////////////////////////
        mut current_fn0 = cg_CurrentFn(target: target);
        defer swap(_current_fn, current_fn0);
        swap(_current_fn, current_fn0);
        ////////////////////////////////////////////

        mut src         = "";
        let overload    = GET(target);

        // Linkage.
        if (!fnptr)
        {
            let linkage = overload.fnLinkage;

            src ~= linkage;

            if (SELF_TEST && target.modid != module.modid && !overload.isExtLinked && !overload.isInlLinked)
                BUG("cgFnPrototype: !isExtLinked but off-module");
        }

        // Retval.
        {
            let ret     = overload.type || BUG();
            let annot   = typeAnnot(ret, M_RETVAL);

            src ~= annot ~ " ";
        }

        // Name, (*Name), etc.
        {
            let name    = fnID(target);

            src ~= fnptr    ? "(*" ~ name ~ ")"
                            :        name;
        }

        // Arglist.
        {
            src ~= "(";

            let args    = target.args;
            mut first   = true;
            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i].type;
                if (arg.isIrrelevant)
                    continue;

                if (first)
                    first = false;
                else
                    src ~= ", ";

                src ~= typeAnnot(arg, M_ARGUMENT | M_FWDECL);
            }

            if (overload.flags & F_OPERATOR && cpp::hasPostfix(overload.name))
                src ~= ", /*postfix*/int";

            src ~= ")";
        }

        //
        return src;
    }


    //

    fn ensureFwdDecl(target: Target)
    {
        let overload = GET(target);
        if (overload.kind != "fn" || overload.name == "main")
            return;

        if !(_ffwd.add(target))
            return;

        let fwdDecl = target.cgFnPrototype() ~ ";\n";

        if (overload.flags & F_HOTSWAP)
        {
            let fnPtr = "extern " ~ target.cgFnPrototype(fnptr: true) ~ ";\n";

            _ffwd_live_client  ~= fnPtr;
            _ffwd_live_nclient ~= fwdDecl;
        }
        else
        {
            _ffwd_src ~= fwdDecl;
        }
    }

    fn ensureFnUsable(target: Target)
    {
        let here0 = _here;
        defer _here = here0;

        let offtarget = target.modid != module.modid;

        if (offtarget && !target.isInlLinked)
            ensureFwdDecl(target);
        else
            ensureFnDef(target, :offtarget);
    }

    fn ensureFnDef(target: Target, offtarget!?: bool)
    {
        target.modid == module.modid || offtarget || BUG(
            "ensureFnDef: fndef is needed outside of its original scope: "
                ~ target.modid ~ " vs " ~ module.modid ~ ": `"
                ~ target.kind ~ " " ~ target.name ~ "`.");

        // Do this just once.
        if (!_fdef_started.add(target))
        {
            // Add a fwd decl if recursive.
            if (!_fdef_complete.has(target))
            {
                if !(target.status & SS_FN_RECUR)
                    BUG("ensureFnDef: Function without SS_FN_RECUR appears to be recursive.");

                ensureFwdDecl(target);
            }

            return;
        }

        // Go!
        cgFn(target);

        _fdef_complete.add(target) || BUG(
            "ensureFnDef: _fdef_complete twice: " ~ target.name);
    }


    //

    fn cgFn(target: Target)
    {
        let node = target.solved;
        node.kind == "fn" || BUG("cgFn: target.solved.kind != 'fn'");

        //////////////////////
        let indent0 = _indent;
        defer _indent = indent0;
        //////////////////////

        let items = node.items;
        let body  = items[items.len + FN_BODY_BACK];

        let overload = GET(target);
        let id = overload.name;

        overload.status & SS_FINALIZED || BUG(
            "cgFn: SS_FINALIZED not set: " ~ id);

        // Custom __natives.
        if (!body)
        {
            overload.kind == "__native" || overload.kind == "inline" || BUG(
                "cgFn: no body on non-native: " ~ overload.kind ~ " " ~ id);

            return;
        }

        overload.status & SS_Debug_AllPassesComplete || BUG(
            "cgFn: SS_Debug_AllPassesComplete not set: " ~ id)

        _indent = "\n";

        //
        let dedupe = overload.flags & F_TEMPLATE
                  && overload.name.valid_identifier;

        let sighash = target.sighash;

        shadow let dedupe = dedupe && sighash
            ? dedupe ~ '_' ~ sighash.digest62
            : dedupe;

        // Turns out we've had this all along for templates & the like.
        //  Doing this here prevents any fns called inside from emitting code too.
        //
        if (dedupe && !_TODO_FIX_seenFns.add(dedupe))
        {
            noteDefect(DuplicateFunctions);
            return;
        }

        // TODO is this needed?
        //  Body should always be a block.
        mut src: string;
        {
            ////////////////////////////////////////////
            mut current_fn0 = cg_CurrentFn(target: target);

            defer swap(_current_fn, current_fn0);
            swap(_current_fn, current_fn0);
            ////////////////////////////////////////////

            _current_fn.can_return = body.helpers;

            src ~= cgFnSignature(target);

            mut body_src = cgBlock(body, M_STMT | M_FN_BODY);

            src ~= body_src;

            _current_fn.TEMPVARs && BUG("Leftover tempvars.");
        }

        // So, the new reverse-specializer can totally emit
        //  duplicates of normal forward-specializations of templates.
        //
        // We gotta figure this out -
        //  A] it's stupid we now waste time specializing the same thing twice;
        //  B] overall it'd be cool if we could identify duplicate fns
        //      outside of the scope of some template,
        //       e.g. just globally eliminate duplicate code somehow.
        //
        if (!dedupe && !_TODO_FIX_seenFns.add(src))
        {
            noteDefect(DuplicateFunctions);
            return;
        }

        // LIVE ////////////////////////
        if (overload.flags & F_HOTSWAP)
        {
            target.modid == module.modid || BUG();
            _live_targets ~= target.globid;

            //
            let fnID        = target.fnID;
            let fnID_local  = fnID ~ "_local";
            let fnPtrAnnot  = target.cgFnPrototype(fnptr: true);

            //
            include("<dl/hotswap.hpp>");
            ensureFwdDecl(target);

            //
            src = "                                #ifdef fu_HOTSWAP\n"
                ~ "                                #define " ~ fnID ~ " " ~ fnID_local ~ "\n"
                ~ "extern \"C\" fu_EXPORT\n"
                ~ "                                #endif\n"
                ~ src

                ~ "\n"
                ~ "                                #ifdef fu_HOTSWAP\n"
                ~ "                                #undef " ~ fnID ~ "\n"
                ~ fnPtrAnnot ~ " =\n    fu::hotswap(\"" ~ fnID_local ~ "\",\n                 " ~ fnID ~ ",\n                &" ~ fnID_local ~ ");\n"
                ~ "                                #endif";
        }
        ////////////////////////////////

        // TESTS ///////////////////////
        if (overload.flags & F_TESTCASE)
        {
            target.modid == module.modid || BUG();
            _test_cases ~= "\n    " ~ id ~ "(),";
        }
        ////////////////////////////////

        if (dedupe)
            _fdef ~= "\n                                #ifndef DEF_" ~ dedupe
                   ~ "\n                                #define DEF_" ~ dedupe;

        _fdef ~= "\n" ~ src ~ "\n";

        if (dedupe)
            _fdef ~= "                                #endif\n";
    }


    //

    fn globalVar_isConstexpr(o: Overload)
    {
        fn isConstexpr(expr: SolvedNode)
        {
            if (expr.kind == "int" || expr.kind == "char" || expr.kind == "real" || expr.kind == "bool")
                return true;

            if (expr.kind == "call")
            {
                shadow let o = GET(expr.target);
                if (o.kind == "__native" && o.flags & F_OPERATOR)
                {
                    for (mut i = 0; i < expr.items.len; i++)
                        if (!expr.items[i].isConstexpr)
                            return false;

                    return true;
                }
                else if (o.kind == "var")
                {
                    return o.globalVar_isConstexpr;
                }
            }

            return false;
        }

        return o.solved.items[LET_INIT].isConstexpr;
    }

    fn TODO_FIX_useStaticRef(target: Target)
    {
        if (target.locid || !use_STATIC_REF)
            return false;

        // Several things break with extern const refs,
        //  clang complains about init_priority,
        //   there's some error about extern variables with initializers,
        //    gotta investigate further but this works,
        //     honestly really disappointing stuff.
        //
        // Return false here to reproduce.
        //
        let place_type = target.solved.type;
        return  place_type.is_ref
            && !place_type.isPassByValue
            && (!place_type.is_sliceable || place_type.ifArray_annotateAsVec)
            && !target.globalVar_isConstexpr;
    }

    fn binding(target!: Target, forceValue!?: bool)
    {
        let o           = GET(target);
        let place_type  = o.solved.type;
        let isArg       = o.status & SS_ARGUMENT;

        shadow let place_type  = forceValue
            ? clear_refs(place_type)
            : place_type;

        // TODO FIX re: hoising - we emit the declarations before entering blocks,
        //  we we hit a double-declare here, not great.
        let alreadyDeclared =
            isHoistable(:target.locid) &&
                !_current_fn._declared.add_once(target.locid);

        let id          = localID(:target, dedupe: !alreadyDeclared);
        let isHoisted   = isHoisted(:target.locid);

        let mode    = (o.type.is_mutref && M_MUTVAR)
                    | (o.status & SS_MOVED_FROM && M_MOVABLE)
                    | (target.TODO_FIX_useStaticRef && M_STATIC_REF);

        if (isHoisted)
        {
            if (!alreadyDeclared)
            {
                mut annot: string;
                mut ptr_flip: PointerFlip;
                TEMPVAR_declare(
                    type: place_type, :ptr_flip, :annot, :id, :mode);
            }

            return id;
        }

        let annot = typeAnnot(place_type,
            :mode   | (!o.type.is_mutref && M_CONST)
                    | (isArg && M_ARGUMENT));

        let isUnused = o.status & SS_UNUSED;
        if (isArg && isUnused)
            return annot;

        if (!isHoisted)
            _current_fn._live_locals ~= target.locid;

        //
        mut head    = annot || BUG();

        if (!isArg && place_type.is_ref &&
            options.dev & options::DEV_CG_LifetimeAnnots)
        {
            mut lt = "";

            place_type.lifetime.lifetime::Lifetime_each:
                |locid, isTemp, isStatic, isArgIdx|
            {
                if (lt)
                    lt ~= "|";

                if (isTemp)
                    lt ~= "temp";
                else if (isStatic)
                    lt ~= "static";
                else if (isArgIdx)
                    BUG("WTF");
                else
                    lt ~= localID(nested(locid));
            }

            head ~= " /*" ~ lt ~ "*/";
        }

        head       ~= " " ~ id;
        if (isUnused)
            head    = "[[maybe_unused]] " ~ head;
        if (target.status & SS_MOVED_FROM)
            head    = "/*MOV*/ " ~ head;

        return head;
    }

    fn isAbbreviatedCopy(n: SolvedNode, sliceOK!?: bool)
    {
        return n.kind == "copy" && (!n.is_sliceable || sliceOK);
    }

    fn binding(target!: Target, init: SolvedNode, doInit!: bool, mode!: i32)
    {
        mut head = binding(:target);
        if (!doInit)
            return head;

        // Definit.
        let isHoisted = isHoisted(:target.locid);

        fn HOIST_init(shadow init: string)
            return TEMPVAR_init(
                id: head, :init,
                ptr_flip: PointerFlip(target),
                immediate: !(mode & (M_STMT | M_VOID_EXPR)));

        if (!init || init.kind == "empty" && !init.type.is_ref)
        {
            if (isHoisted)
                return HOIST_init(init: "{}");

            return head ~ " {}";
        }

        // A less verbose copy init.
        let isAbbreviatedCopy =
            init.isAbbreviatedCopy();

        shadow let init = isAbbreviatedCopy
            ? init.items.only
            : init;

        if (init.kind == "bool" && !(target.flags & F_PUB) && !target.type.is_mutref)
            noteDefect(LocalConstBool);

        /////////////////////////////////////////////
        /////////////////////////////////////////////
        /////////////////////////////////////////////
        let use_initTEMPVARs = !_current_fn.globid;
        mut initTEMPVARs: string[];

        if (use_initTEMPVARs)
            swap(initTEMPVARs, _current_fn.TEMPVARs);
        /////////////////////////////////////////////
        ///
        mut expr = cgNode(init);
        ///
        /////////////////////////////////////////////
        if (use_initTEMPVARs)
            swap(initTEMPVARs, _current_fn.TEMPVARs);

        // HACK - wrap in a lambda when we need temps here
        if (initTEMPVARs)
            expr    = "[]() -> " ~ typeAnnot(init.type)
                    ~ " {\n    " ~ initTEMPVARs.join(";\n    ")
                    ~  ";\n    return " ~ expr ~ ";\n}()";
        /////////////////////////////////////////////
        /////////////////////////////////////////////
        /////////////////////////////////////////////

        // I think we can use curlies everywhere,
        //  here we make an exception for copy inits,
        //   but we skip primitives which doesn't make sense -
        //    curly init is BETTER for primitives because it prevents narrowing.
        //*/
        // if (isAbbreviatedCopy && !init.is_primitive)
        //     return head ~ " { " ~ expr ~ " }";

        // Hoisting.
        if (isHoisted)
            return HOIST_init(expr);

        return head ~ " = " ~ expr;
        /*/
        return head ~ " { " ~ expr ~ " }";
        //*/
    }

    fn binding(node: SolvedNode, doInit!?: bool, mode!: i32): string
    {
        let target  = node.target;
        let init    = doInit && node.items && node.items[LET_INIT];

        return binding(:target, :init, :doInit, :mode);
    }

    fn binding(arg: Argument, forceValue!?: bool)
    {
        mut prefix = "";

        if (options.dev & options::DEV_CG_LifetimeAnnots
            && arg.is_ref && (arg.may_alias || arg.may_invalidate))
        {
            prefix ~= "/*";

            fn prefix(bitset: bitset::BitSet)
            {
                for (mut i = 0; i < bitset._data.len; i++)
                {
                    mut v = bitset._data[i].u32;
                    prefix ~= hex(v & 0xf);
                    if (v >>= 4)
                        prefix ~= hex(v);
                }
            }

            prefix(arg.may_alias);
            prefix ~= ":";
            prefix(arg.may_invalidate);

            prefix ~= "*/ ";
        }

        return prefix ~ binding(:arg.target, :forceValue);
    }


    //

    fn cgInitPrio(modid: i32)
    {
        if (!use_INIT_PRIOIRTY)
            return "";

        let prio = ctx.modules[modid].order.dep_depth;
        include("<fu/init_priority.h>");
        return "fu_INIT_PRIORITY(" ~ (1000 + prio) ~ ") ";
    }

    fn set_isHoisted(locid!: i32)
    {
        if (SELF_TEST)
        {
            locid || BUG("set_isHoisted: Not a local.");
            locid.nested.status & SS_ARGUMENT && BUG("Hoisted an argument.");
        }

        _current_fn._hoisted.add(locid);
    }

    fn isHoisted(locid!: i32)
    {
        return isHoistable(:locid)
            && _current_fn._hoisted.has(locid);
    }

    fn cgLet(node: SolvedNode, global!: bool, foreign?: bool, mode!: i32): string
    {
        if (node.type.isIrrelevant)
            return "";

        // Hoist let-expressions.
        if !(mode & M_STMT)
            set_isHoisted(:node.target.locid);

        // GLOBALS ///////////////////////////////////////////////
        let constexpr = global
            && node.target.globalVar_isConstexpr;
        // GLOBALS ///////////////////////////////////////////////

        mut src = binding(node, doInit: !foreign || constexpr, :mode);
        if (!global)
            return src;

        // cpp17 inline const syntax sugars.
        if (src.starts(with: "const "))
            src = src.slice(6);

        if (constexpr)
        {
            _fdef  ~= "\n                                #ifndef DEF_" ~ node.value
                    ~ "\n                                #define DEF_" ~ node.value
                    ~ "\ninline constexpr " ~ src ~ ";"
                    ~ "\n                                #endif\n";

            return "";
        }

        // Static init prio.
        let prio = !foreign && !node.type.is_primitive && cgInitPrio(:node.target.modid);
        if (prio)
        {
            let eq = src.find('=');
            shadow let eq = eq >= 0 ? eq : src.find('{');
            eq >= 0 || BUG("Needs init priority but can't find first = in `" ~ src ~ "`");
            src = src[.. eq] ~ prio ~ src[eq ..];
        }

        // Hide when possible.
        if !(GET(node.target).isExtLinked)
        {
            // We can't "forward declare" foreign private globals.
            if (!foreign)
                _fdef  ~= "\nstatic const " ~ src ~ ";\n";

            // But we can unity-build ourselves with them.
            else
                BUG("Cannot codegen, relies on an external static: " ~ node.target.name);
        }
        else
        {
            _fdef  ~= "\nextern const " ~ src ~ ";";
        }

        return "";
    }

    fn cgGlobal(target: Target)
    {
        if !(_ffwd.add(target))
            return "";

        return cgLet(target.solved,
            global: true,
            foreign: target.modid != module.modid,
            mode: M_STMT);
    }

    fn cgLetDef(node: SolvedNode, mode!: i32)
    {
        if (!_current_fn.globid)
            return node.target.isExtLinked
                && cgGlobal(node.target);

        shadow let mode = mode
            | (node.isIrrelevant && !(mode & M_STMT) && M_VOID_EXPR);

        return cgLet(node.target.solved, global: false, :mode);
    }


    //

    fn cgGoto(block: cg_Block)
    {
        noteDefect(Goto);
        return "goto " ~ block.name;
    }

    fn TEST_noDanglingRefs(surviving_locals: i32[], node: SolvedNode)
    {
        if !(node.is_ref)
            return;

        if (node.kind == "if" || node.kind == "and" || node.kind == "or")
            node.items[node.kind == "if" ? 1 : 0 ..].each: |item|
                item.TEST_noDanglingRefs(:surviving_locals);

        node.lifetime.TEST_noDanglingRefs(:surviving_locals);
    }

    fn TEST_noDanglingRefs(surviving_locals: i32[], lifetime: Lifetime)
    {
        lifetime.Lifetime_each: |locid|
        {
            if (!locid || surviving_locals.has(locid))
                continue;

            let o = GET(nested(locid));
            if (o.status & SS_ARGUMENT || isHoisted(:locid))
                continue;

            if (o.solved.lifetime)
                TEST_noDanglingRefs(o.solved.lifetime, :surviving_locals);
            else
                BUG("TEST_noDanglingRefs: returning a dangling reference to " ~ o.name.ansi::qBAD);
        };
    }

    fn cgJump(node: SolvedNode): string
    {
        let helpers     = node.helpers;
        let use_return  = helpers == _current_fn.can_return;
        let expr        = node.items.only;

        fn findBlock()
        {
            for (mut i = _current_fn.blocks.len; i --> 0; )
            {
                let block = _current_fn.blocks[i];
                if (block.helpers == helpers)
                {
                    expr.TEST_noDanglingRefs(:block.surviving_locals);

                    return block;
                }
            }

            BUG("No such block in scope: " ~ helpers.index);
        }

        let block       = !use_return && findBlock();

        if (expr.kind != "empty" || !expr.type.isIrrelevant)
        {
            // Break with value.
            if (!use_return)
            {
                mut value   = cgNode(expr, !(block.has_val) && M_STMT);

                if (block.has_val)
                {
                    let id  = block.name ~ "_v";
                    value   = TEMPVAR_init(:block.ptr_flip, :id, init: value);
                }

                return "{ " ~ value
                     ~ "; " ~ cgGoto(block) ~ "; }";
            }

            // I think the prefix keywords beat everything re: precedence.
            return "return " ~ cgNode(expr, M_PARENS|M_RETURN);
        }

        //
        if (use_return)
            return "return";

        if (helpers == _current_fn.can_break)
            return "break";
        if (helpers == _current_fn.can_cont)
            return "continue";

        return cgGoto(block);
    }


    //

    fn escapeStringLiteral(str: byte[..], quot: byte)
    {
        mut esc = [ quot ];

        for (mut i = 0; i < str.len; i++)
        {
            let c = str[i];

            if      (c == '\n') esc ~= "\\n";
            else if (c == '\r') esc ~= "\\r";
            else if (c == '\t') esc ~= "\\t";
            else if (c == '\v') esc ~= "\\v";
            else if (c == '\\') esc ~= "\\\\";

            // Misc sub-whitespace.
            else if (c.i8 < 32) esc ~= "\\" ~ c.u32.xHH;

            // Rest & quot.
            else
            {
                if (c == quot)
                    esc ~= '\\';

                esc ~= c;
            }
        }

        esc ~= quot;

        return esc;
    }

    fn cgStringLiteral(node: SolvedNode): string
    {
        if (node.isIrrelevant)
            noteDefect(IrrelevantLiteral);

        //////////////////////////////////////////////
        // HACK - Retyping string literals to enums //
        if (node.type.is_enum || node.type.is_flags)
            return cgEnumv(node.type, node.value);
        //////////////////////////////////////////////

        // Include ""_fu, fu::str & co.
        lax let stringAnnot = annotateString();

        // fu::strlit from a const char*
        mut esc = escapeStringLiteral(node.value, '"');

        // Implicitly converts to fu::view if that's all we need.
        if (node.type.is_ref &&
            node.type.ifArrayRef_annotateAsSlice)
        {
            return esc ~ "_view";
        }

        esc ~= "_fu";

        // If we need a static ref ...
        if (node.type.lifetime.hasStatic ||

            // ... or if the string literal will allocate memory,
            //  and this could get evaluated more than once (we're within a fn),
            //   we'll emit a reference to a static variable.
            //
            node.value.len > SMALL_STRING_OPTI && _current_fn.target)
        {
            mut hash: tea::TEA;
            hash.hash(node.value);

            let dedupe = hash.digest62;
            let id = "str_" ~ dedupe;

            if (_static_strings.add(hash.u64))
            {
                let prio = cgInitPrio(:module.modid);
                {
                    ref src = _static_string_src;
                    src ~= "\n                                #ifndef STR_" ~ dedupe
                    src ~= "\n                                #define STR_" ~ dedupe
                    src ~= "\nstatic const " ~ stringAnnot ~ " " ~ id ~ " " ~ prio ~ "{ " ~ esc ~ " };";
                    src ~= "\n                                #endif\n";
                }
            }

            esc = id;
        }

        if (!node.type.is_ref)
            return stringAnnot ~ "(" ~ esc ~ ")";

        return esc;
    }

    fn cgCharLiteral(node: SolvedNode): string
    {
        if (node.isIrrelevant)
            noteDefect(IrrelevantLiteral);

        /*
        include("<fu/int.h>");
        return "fu::byte(" ~ escapeStringLiteral(node.value, '\'') ~ ")";
        /*/
        return escapeStringLiteral(node.value, '\'');
        //*/
    }


    //

    fn cgArrayLiteral(node: SolvedNode, mode: i32, callarg: Type): string
    {
        if (node.isIrrelevant)
            noteDefect(IrrelevantLiteral);

        if (node.target)
            return cgCall(node, mode);

        let items = cgNodes(node.items, mode: M_CHECK_NEVER_LTR);
        if (!items.len)
            return cgDefault(node.type);

        let src = items.join(", ");
        let T = typeAnnotBase(clear_sliceable(node.type));

        // fu::slate literals
        if (callarg.is_ref &&
            callarg.ifArrayRef_annotateAsSlice)
        {
            include("<fu/view.h>");

            return "fu::view<" ~ T ~ "> {{ " ~ src ~ " }}";
        }

        return "fu::vec<" ~ T ~ "> {{ " ~ src ~ " }}";
    }

    fn binSkipParens(id: string, mode: i32)
    {
        if (mode & M_STMT)
            return true;

        if (mode & M_PARENS)
        {
            if (id.last == '=')
            {
                // Clang errors on equality within parens in conditionals ...
                if (id == "==" || id == "!=")
                    return true;

                // ... and on naked equalities in conditionals.
                return false;
            }

            // Everything else is fine.
            return true;
        }

        return false;
    }

    fn cgNot(node: SolvedNode): string
    {
        return "!" ~ cgNode(node.items.only);
    }

    fn cgCall(node: SolvedNode, mode: i32): string
    {
        let ext             = node.target.EXT;
        let target          = GET(node.target) || BUG();
        let args            = node.items;

        let isNative        = target.kind == "__native";

        // So this originally skipped all left-hand side copies
        //  which obviously led to a bug, see the EXT_insert testcase,
        //   which just shows how stupid this is -
        //    not sure what the ideal way to do this,
        //     should it be done in solver? Should we check lifetimes here?
        //      Obviously cg-ing redundant copies is pointless and harmful.
        //
        let isSimpleCpyMovAssign =
            args.len == 2 && isNative && target.name == "="
                && args[0].isFieldChain;


        //
        let MUSTSEQ_mask    = node.helpers.index;
        mut ooe_crosscheck  = 0;
        mut ooe_header      = "";

        //
        mut item_src: string[];
        item_src.resize(args.len);

        // We'll CG these in OOE,
        //  so that the ooe_header comes out in the right order.
        let RTL             = target.isRTL;
        let host_args       = ext.args;
        if (args) argsForward(:RTL, :host_args, |i, host_arg, seqIdx|
        {
            let arg = args[i];

            // Skip explicit copies on assignment, pointless.
            shadow let arg = isSimpleCpyMovAssign && i == 1
                    && arg.isAbbreviatedCopy(sliceOK: true)
                ? arg.items.only
                : arg;

            mut junk = false;
            mut mustDiscard = arg.isIrrelevant;
            if (mustDiscard)
            {
                // TODO cleanup, the call / fndef / definit & co shouldn't be needed here,
                //  the only thing we should probably handle is the empty,
                //   or we can leave it to cg a `0` and discard that.
                //
                junk = arg.kind == "empty"
                    || arg.kind == "call" && (arg.target.kind == "var" || arg.target.kind == "type" && !arg.items || arg.target.kind == "enumv");
            }
            else if (arg.is_never)
            {
                BUG("cgCall: arg.is_never");
            }

            //
            let MUSTSEQ_bit = 1 << (i & 31);
            let mustSeq_useTemporary = MUSTSEQ_mask & MUSTSEQ_bit;

            mut src = junk ? "" : cgNode(
                arg,
                callarg: !mustSeq_useTemporary && host_arg.type,
                mode: isNative && M_ARG_TO_NATIVE) || BUG("Empty arg src.");

            //
            if (mustDiscard && src)
            {
                ooe_crosscheck |= MUSTSEQ_bit;

                if (ooe_header)
                    ooe_header ~= ", ";

                ooe_header ~= "(void) ";
                ooe_header ~= src;
                src = "";
            }

            if (mustDiscard && target.kind == "type" && !arg.is_zst)
            {
                // TODO FIX - unused struct members,
                //  we cant skip args in struct initializers
                src = "{/*unused non-zst*/}";
            }

            // Explicit sequencing.
            if (mustSeq_useTemporary)
            {
                junk && BUG("Trying to MUSTSEQ a discarded argument, shouldnt happen.");

                ooe_crosscheck |= MUSTSEQ_bit;

                fn rest_isPointlessMustSeq()
                {
                    argsForward(
                        :RTL, :host_args,
                        seqIdx_start: seqIdx + 1,
                        |shadow i, shadow host_arg|
                        {
                            shadow let arg = args[i];
                            if (!arg.isPointlessMustSeq(host_arg))
                                return false;
                        });

                    return true;
                }

                if (arg.isPointlessMustSeq(ext.args[i])
                        || MUSTSEQ_mask &~ MUSTSEQ_bit < MUSTSEQ_mask
                            && rest_isPointlessMustSeq)
                {
                    noteDefect(PointlessMustSeq);

                    // These are worth investigating:
                    //  - Found a MOLU bug where the just_used mask wasn't cleared
                    //     after the first argument traversed (last arg in eval order).
                    //  - AAR currently sequences stuff that's already in the hard/soft mask,
                    //     ideally the sequencing should go just once after BCK and AAR have finished.
                    //  - There's probably more coming, this shit is impenetrable.
                }
                else
                {
                    if (ooe_header)
                        ooe_header ~= ", ";

                    //
                    mut ptr_flip: PointerFlip;
                    mut annot: string;

                    let id      = TEMPVAR_declare(type: arg, :ptr_flip, :annot);
                    ooe_header ~= TEMPVAR_init(:id, :ptr_flip, init: src);
                    src         = TEMPVAR_consume(:id, :arg.type, :ptr_flip);
                }
            }

            item_src[i] = src;
        });

        (ooe_crosscheck & MUSTSEQ_mask) == MUSTSEQ_mask || BUG(
            "OOE crosscheck failed: codegen sequenced " ~ ooe_crosscheck
                                ~ ", but solver wants " ~ MUSTSEQ_mask ~ ": "
                                ~ args.map(|x| x.kind.str).join("|"));

        fn ooeWrap(src: string)
        {
            return ooe_header
                 ? "(" ~ ooe_header ~ ", " ~ src ~ ")"
                 : src;
        }


        //

        fn REST(start?: int)
        {
            mut src = "";
            for (mut i = start; i < item_src.len; i++)
            {
                let item = item_src[i];
                if (!item)
                    continue;

                if (src)
                    src ~= ", ";

                src ~= item_src[i];
            }

            return src;
        }

        fn ARG(i: int) item_src[i];


        //

        fn affectedByIntegerPromotions(type: Type)
        {
            if (type.is_ref || /* is int or flags: */ !type.is_bitfield)
                return false;

            let c = type.canon;
            return c.len >= 2 && c[1] == '8'
                || c.len >= 3 && c[1 .. 3] == "16";
        }

        fn unpromote(expr: string)
        {
            if (isNative && node.type.affectedByIntegerPromotions)
                return typeAnnotBase(node.type) ~ "(" ~ expr ~ ")";

            return expr;
        }

        fn emitPostfixOp(op: string)
        {
            return unpromote(ARG(0) ~ op);
        }

        fn emitPrefixOp(op: string)
        {
            return unpromote(op ~ ARG(0));
        }

        fn emitBinaryOp(op: string)
        {
            args.len == 2 || BUG("args.len != 2");

            if (binSkipParens(op, mode) && !ooe_header)
                return ARG(0) ~ " " ~ op ~ " " ~ ARG(1);

            return ooeWrap(unpromote("(" ~ ARG(0) ~ " " ~ op ~ " " ~ ARG(1) ~ ")"));
        }

        fn emitMethodCall(id: string)
        {
            return ooeWrap(ARG(0) ~ id ~ "(" ~ REST(1) ~ ")");
        }

        fn emitFunctionCall(mut id: string, open = "(", close = ")")
        {
            // Passing type parameters into cpp templates,
            //  added this for prelude view<U>(a: T[..], type U),
            //   which becomes a fu::view_of<U>(a).
            //
            let template = id.find("<>");
            if (template > 0)
            {
                mut angle_brackets = "";
                argsForward(:RTL, :host_args): |lax i, host_arg|
                {
                    if (host_arg.type.isIrrelevant)
                    {
                        if (angle_brackets)
                            angle_brackets ~= ", ";

                        mut slot = host_args[i].type;
                        slot.quals |= q_USAGE;
                        angle_brackets ~= typeAnnotBase(slot);
                    }
                };

                id  = id[.. template]
                    ~ '<' ~ angle_brackets ~ '>'
                    ~ id[template + 2 ..];
            }

            shadow let args = open ~ REST ~ close;
            if (args == "()" && id.ends(with: ')'))
                return id;

            return ooeWrap(id ~ args);
        }


        // Builtin specs.

        if (isNative && target.name[0] == '\n')
        {
            mut id = target.name.slice(
                hacks::NativeQualities(target.name)
                    .name_start_idx + 1);

            let idx = id.find('\n');
            if (idx > -1)
            {
                include(id.slice(0, idx));
                id = id.slice(idx + 1);
            }

            if (id[0] == '.')
            {
                if (args.len > 1)
                    return emitMethodCall(id);  // X`.id`(a, b)

                return emitPostfixOp(id);       // X`.a`
            }

            if (id[0] == '/')
                return ooeWrap(emitBuiltin(id, item_src, node));

            if (args)
            {
                if (id.hasIdentifierChars)
                    return emitFunctionCall(id);

                return emitBinaryOp(id);
            }

            return id;
        }

        //
        let kind = target.kind;
        if (kind == "type")
        {
            if (!args)
                return cgDefault(target.type);

            let t = tryLookupUserType(target.type) || BUG(
                "cgCall: defctor/type not a struct nor a user primitive.");

            let base = typeAnnotBase(target.type);

            if (t.kind == "flags")
                return emitFunctionCall(base, "((", ") & MASK_" ~ base ~ ")");

            if (t.kind == "primitive" || t.kind == "enum")
                return emitFunctionCall(base, "(", ")");

            if (t.kind == "struct" || t.kind == "union")
                return emitFunctionCall(base, " { ", " }");

            BUG("Unknown usertype kind: " ~ t.kind);
        }
        else if (kind == "fn" && node.target.modid)
        {
            ensureFnUsable(node.target);
        }
        else if (kind == "inline")
        {
            BUG("cgCall: found a call to an inline fn: " ~ node.target.name);
        }

        let id = target.name || BUG();

        if (args.len <= 2)
        {
            if (target.kind == "var")
            {
                // So we don't look for variables that aren't there.
                if (target.type.isIrrelevant)
                    return cgDefault(target.type);

                if (!node.target.locid)
                {
                    cgGlobal(node.target);

                    mut ret = rootNS(ID(id)); // TODO ensure const emit.

                    if (node.target.TODO_FIX_useStaticRef)
                        ret ~= ".ref";

                    return ret;
                }

                // Derefing ptrs.
                shadow let id = localID(:node.target);
                if (isHoisted(:node.target.locid))
                    return TEMPVAR_peek(PointerFlip(target), id, parens: true);

                return id;
            }

            if (target.kind == "field")
            {
                let head = ARG(0) || BUG("cgField: about to emit a [nothing].field sequence.");
                return head ~ "." ~ ID(id);
            }

            if (target.kind == "enumv")
                return cgEnumv(target.type, id);

            if (node.target.isOp)
            {
                if (args.len == 1)
                    return cpp::hasPostfix(id)  ? emitPostfixOp(id.valid_operator)
                                                : emitPrefixOp (id.valid_operator);

                if (args.len == 2)
                {
                    if (id == "[]")
                        return ooeWrap(ARG(0) ~ "[" ~ ARG(1) ~ "]");

                    // Skip some of the ridiculous parens.
                    return emitBinaryOp(id.valid_operator);
                }
            }

            if (id == "STEAL" && args.len == 1)
                return cgMove(node.type, ARG(0));
        }

        isNative && BUG("Unknown __native: `" ~ id ~ "`.");

        return emitFunctionCall(rootNS(node.target.fnID));
    }

    fn cgEnumv(type: Type, id: string)
    {
        let base = typeAnnotBase(type);
        return base ~ "_" ~ id;
    }

    fn rootNS(id: string)
    {
        if (_current_fn._ids_used.has(id))
            return "::" ~ id;

        return id;
    }

    fn emitBuiltin(id: string, args: string[], node: SolvedNode): string
    {
        if (id == "/prim/convert")
        {
            let output  = node.type;
            let input   = node.items.only.type;

            let cast    = typeAnnotBase(output);

            if (input.is_integral && output.is_integral &&
                input.is_unsigned != output.is_unsigned)
            {
                // When casting between signed and unsigned integers,
                //  we always go through an intermediate unsigned type
                //   that is as big as the signed type:
                //
                //  i8 -> u32 :=  i8 ->  u8 -> u32
                // u32 ->  i8 := u32 ->  u8 ->  i8
                //
                //  u8 -> i32 :=  u8 -> u32 -> i32
                // i32 ->  u8 := i32 -> u32 ->  u8
                //
                // This means that we only move the sign bit around
                //  when casting between signed types.
                //
                mut mid_t       = input.is_unsigned ? output : input;
                mid_t.canon[0] == 'i' || BUG();
                mid_t.canon[0]  = 'u';

                if (mid_t.canon != output.canon &&
                    mid_t.canon != input.canon)
                {
                    let inner = typeAnnotBase(mid_t);

                    return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
                }
            }
            else if (input.canon == t_byte.canon &&
                    output.canon != t_byte.canon)
            {
                // Go through unsigned char.
                let inner = typeAnnotBase(t_u8);

                return cast ~ '(' ~ inner ~ '(' ~ args.only ~ "))";
            }

            return cast ~ '(' ~ args.only ~ ')';
        }

        BUG("Unknown builtin: " ~ id);
    }

    fn annotateString(): string
    {
        include("<fu/str.h>");

        return "fu::str";
    }

    fn annotateNever(): string
    {
        include("<fu/never.h>");

        return "fu::never";
    }

    fn annotateZST()
    {
        return "void";
    }

    fn cgLiteral(node: SolvedNode, mode: i32): string
    {
        if (node.isIrrelevant)
            noteDefect(IrrelevantLiteral);

        mut src = node.value;

        // Remove underscores, if any.
        mut idx: int;
        while ((idx = src.find('_', start: idx)) >= 0)
            src.splice(idx, 1);

        let base = tryLookupUserType(node.type).basePrim || node.type.canon;

        if (base.starts(with: 'u'))
            if (!src.has('u'))
                src ~= 'u';

        if (base.starts(with: 'f'))
        {
            if (!src.has('.') && !src.has(src.has('x') ? 'p' : 'e'))
                src ~= ".0";

            if (base == "f32")
            {
                if (src.has('x'))
                    src = "float(" ~ src ~ ")";
                else
                    src ~= "f";
            }
            else if (base != "f64")
            {
                BUG();
            }
        }

        if (src.starts(with: "0o"))
            src.splice(1, 1);

        if (base.starts(with: 'i') || base.starts(with: 'u'))
        {
            // One of those paradoxes.
            if (src.len > 16)
            {
                let parse = intlit::Intlit(src);
                if (parse.negative && parse.absval == 0x8000000000000000)
                    return "(-9223372036854775807-1)";
            }

            if (base == "u64" || base == "i64") {
                if (!src.has('l'))
                    return src ~ "ll";
            }
            else if (base != "u32" && base != "i32")
            {
                // Don't do this for enums,
                //  the type declaration ends up with casts to itself.
                if !(mode & M_ENUM_DECL)
                    return typeAnnotBase(node.type) ~ "(" ~ src ~ ")";
            }
        }

        //
        return src;
    }

    fn cgEmpty(node: SolvedNode, mode: i32): string
    {
        if (SELF_TEST)
            node.type || BUG("cgEmpty: !node.type");

        if (mode & M_STMT)
            return "";

        if (mode & M_ARG_TO_NATIVE && node.type.isAddrOfFn)
        {
            mut last: Target;
            unpackAddrOfFn(node.type.canon, |target|
            {
                last && BUG("Codegen cannot decine which fn to pass as a c++ lambda at __native callsite: " ~ last.name ~ " vs " ~ target.name);
                last = target;

                target.kind == "fn" || BUG("Cannot codegen a non-fn: " ~ target.kind ~ " " ~ target.name);

                let args = target.args;
                for (mut i = 0; i < args.len; i++)
                    if (args[i].flags & F_IMPLICIT)
                        BUG("How do we codegen F_IMPLICIT arguments through lambdas?");

                ensureFnUsable(target);
            });

            return "&" ~ fnID(last);
        }

        return cgDefault(node.type);
    }


    //

    fn acceptsBools_fromAndOr(type: Type)
    {
        // Basically, will a bool do, e.g. -
        //  do you need a ternary or do || and && do the job, etc.
        //
        return !type.is_ref
            && type.canon == t_bool.canon;
    }

    fn cgIf(node: SolvedNode, mode: i32): string
    {
        let n0 = node.items[0];
        if (n0.is_never)
            BUG("cgIf: cond.is_never");

        let n1 = node.items[1];
        let n2 = node.items[2];

        let stmt = !!(mode & M_STMT);

        fn blockWrap_unlessIf(shadow node: SolvedNode)
            node.kind == "if" || node.kind == "and"
                ? " " ~ cgNode(node, M_STMT)
                : blockWrapSubstatement(node);

        let cond = n0 && cgNode(n0, M_RETBOOL | (stmt && M_PARENS));
        mut cons = n1 && (stmt ? blockWrapSubstatement(n1) : cgNode(n1));
        mut alt  = n2 && (stmt ? blockWrap_unlessIf   (n2) : cgNode(n2));

        if (stmt)
            return "if (" ~ cond ~ ")" ~ cons ~ (alt ? _indent ~ "else" ~ alt : "");

        return "(" ~ cond ~ " ? " ~ cons ~ " : " ~ alt ~ ")";
    }

    fn cgAnd(node: SolvedNode, mode: i32): string
    {
        return cgAnd(:node.items, :node.type, :mode);
    }

    fn cgAnd(items: SolvedNode[..], type: Type, mode: i32): string
    {
        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (";
            cgAndOr_concat(src, " && ", items[.. items.len - 1], parens: true);
            src ~= ")";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.acceptsBools_fromAndOr)
        {
            cgAndOr_concat(src, " && ", items, parens: true, last_never_ok: true);
        }
        else
        {
            mut tv: TEMPVAR;

            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (i < items.len - 1)
                    src ~= "!" ~ via(:tv, :type, item);
                else
                    src ~= cgNode(item);
            }
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn cgOr(node: SolvedNode, mode: i32): string
    {
        let type  = node.type;
        let items = node.items;

        let stmt = !!(mode & M_STMT);
        if (stmt)
        {
            mut src = "if (!(";
            cgAndOr_concat(src, " || ", items[.. items.len - 1], parens: true);
            src ~= "))";
            src ~= blockWrapSubstatement(items[items.len - 1]);
            return src;
        }

        mut src = !(mode & M_PARENS) && "(";
        if (type.acceptsBools_fromAndOr)
        {
            cgAndOr_concat(src, " || ", items, parens: true, last_never_ok: true);
        }
        else
        {
            mut tv: TEMPVAR;

            for (mut i = 0; i < items.len - 1; i++)
            {
                let item = items[i] || BUG();
                mut tail = item;

                // Here's the `a && b || c` pattern,
                //  actually works quite well.
                if (item.kind == "and")
                {
                    shadow let items = item.items;
                    tail = items[items.len - 1] || BUG();

                    cgAndOr_concat(src, " && ", items[.. items.len - 1]);
                    src ~= " && ";
                }

                //
                src ~= via(:tv, :type, tail);
            }

            let tail = items[items.len - 1] || BUG();
            src ~= cgNode(tail);
        }

        if !(mode & M_PARENS) src ~= ")";
        return src;
    }

    fn via(ref tv: TEMPVAR, type: Type, expr: SolvedNode): string
    {
        if (expr.isFieldChain)
        {
            let trivial = cgNode(expr);
            return trivial ~ " ? " ~ trivial ~ " : ";
        }

        if (expr.kind == "copy" || expr.kind == "move")
        {
            let kind = expr.kind;
            shadow let expr = expr.items.only;
            if (expr.isFieldChain)
            {
                let trivial = cgNode(expr);
                return trivial ~ " ? " ~ cgCopyOrMove(:kind, :type, trivial) ~ " : ";
            }

            // TODO fix the copies -
            //  we can copy AFTER the test,
            //   will also result in shorter code.
            //
            // TODO this is true for any transformation that does not affect truthiness.
            //  For example a conversion from i8 to i32 cannot affect truthiness, but i32 to i8 can.
            //   Can we generalize this? This would be fantastic.
            //
            // But copies are the worst.
        }

        return via(:tv, :type, expr: cgNode(expr));
    }

    fn via(ref tv: TEMPVAR, type: Type, expr!: string): string
    {
        if (!tv.id)
            tv.id = TEMPVAR_declare(:tv.annot, :type, :tv.ptr_flip);

        let cond = TEMPVAR_peek(:tv.ptr_flip, parens: false,
            "(" ~ TEMPVAR_init(:tv.id, init: expr, :tv.ptr_flip) ~ ")");

        let cons = TEMPVAR_consume(
            :tv.id, :tv.ptr_flip, :type);

        return cond ~ " ? " ~ cons ~ " : ";
    }

    fn isFieldChain(node: SolvedNode): bool
    {
        if (node.kind != "call")
            return false;

        let t = GET(node.target);
        if (t.kind == "field")
            return isFieldChain(node.items.only);

        if (t.kind == "var")
            return true;

        return false;
    }

    fn isPointlessMustSeq(arg: SolvedNode, host_arg: Argument): bool
    {
        ////////////////////////////////////////////////////////////////
        // TODO FIX the implicit conversion from vec to view we do in c++
        //  is not visible in the AST but is seq-sensitive
        if (host_arg.is_sliceable && !host_arg.ifArray_annotateAsVec)
            return false;
        ////////////////////////////////////////////////////////////////

        return isFieldChain(arg);
    }

    fn cgAndOr_concat(ref src: string, op: string, items: SolvedNode[..], parens!?: bool, last_never_ok!?: bool)
    {
        let mode = M_RETBOOL | (parens && items.len == 1 && M_PARENS);
        for (mut i = 0; i < items.len; i++)
        {
            if (i)
                src ~= op;

            let item = items[i];
            if (item.is_never && !(last_never_ok && i == items.len - 1))
                BUG("cgAndOr_concat: item.is_never");

            let term = cgNode(item, :mode);

            if (item.isIrrelevant)
                src ~= "(" ~ term ~ ", 0)";
            else
                src ~= term;
        }
    }

    fn cgDefault(type: Type): string
    {
        type.is_mutref && BUG("Cannot definit mutrefs.");

        if (type.isIrrelevant)
        {
            noteDefect(IrrelevantLiteral);
            return "void()";
        }

        if (type.is_ref && !type.isPassByValue)
        {
            if (!type.is_sliceable || type.ifArray_annotateAsVec)
            {
                include("<fu/default.h>");
                type.is_primitive && BUG("cgDefault: Genering NIL refs to primitives.");
                return "(*(const " ~ typeAnnot(clear_refs(type)) ~ "*)fu::NIL)";
            }
        }

        return typeAnnot(type) ~ "{}";
    }


    //

    fn postfixBlock(src: string, postfix: string): string
    {
        mut end = src.len - 1;

        // :(
        src[end] == '}' || BUG();
        if (postfix.if_first == '\n')
            for (mut i = end; i --> 0 && src[i] == ' '; )
                end--;

        return src.slice(0, end) ~ postfix ~ '}';
    }

    fn cgLoop(node: SolvedNode): string
    {

        // Preheaders don't map cleanly to anything.

        let n_pre = node.items[LOOP_PRE];
        if (n_pre)
        {
            // Convert preheader into block.
            mut pre = n_pre;
            if (pre.kind != "block")
            {
                pre.kind        = "block";
                pre.items       = [ n_pre ];
            }

            // Ok, so this will get nasty.
            mut loop = node;

            // We'll prepend the init at the end.
            loop.items[LOOP_INIT] = [];

            // Flip the loop precondition,
            //  and append it to the preheader block.
            loop.items[LOOP_PRE] = [];

            let n_pre_cond = loop.items[LOOP_PRE_COND];
            if (n_pre_cond)
            {
                if (loop.items[LOOP_POST_COND])
                    BUG("TODO: cgLoop with pre, pre_cond & post_cond.");

                loop.items[LOOP_POST_COND]  = n_pre_cond;
                loop.items[LOOP_PRE_COND]   = [];
            }

            pre.items      ~= loop;

            if (n_pre_cond)
            {
                mut guard       = n_pre;
                guard.kind      = "and";
                guard.items     = [
                    n_pre_cond,
                    pre,
                ];

                pre             = n_pre;
                pre.kind        = "block";
                pre.items       = [ guard ];
            }

            // Move the init bit of the loop to the top of the pre.
            let n_init = node.items[LOOP_INIT];
            if (n_init)
                pre.items.unshift(n_init);

            return cgNode(pre, mode: M_STMT);
        }


        //

        let can_cont0 = _current_fn.can_cont;
        let can_break0 = _current_fn.can_break;

        defer {
            _current_fn.can_cont = can_cont0;
            _current_fn.can_break = can_break0;
        }

        _current_fn.can_cont = [];
        _current_fn.can_break = [];

        //
        let items       = node.items;

        let n_init      = items[LOOP_INIT];
        let n_pre_cond  = items[LOOP_PRE_COND];
        let n_body      = items[LOOP_BODY];
        let n_post      = items[LOOP_POST];
        let n_post_cond = items[LOOP_POST_COND];

        let init        = n_init        && cgNode(n_init, M_STMT);
        let pre_cond    = n_pre_cond    && cgNode(n_pre_cond,  M_RETBOOL | M_PARENS);
        let post        = n_post        && cgNode(n_post);
        let post_cond   = n_post_cond   && cgNode(n_post_cond, M_RETBOOL);

        //
        let name = "LL_" ~ _current_fn.num_labels++;
        let helpers = node.helpers;
        _current_fn.can_break = helpers;

        // Blockvals! /////////////////////////////////////////////////////////////////////////////
        // TODO FIX duplication with blocks, loop labels should just be a block around the loop.
        let blocks0  = _current_fn.blocks.len;
        defer _current_fn.blocks.shrink(blocks0);

        _current_fn.blocks ~= cg_Block(:name, :helpers, false, PointerFlip.None);
        ///////////////////////////////////////////////////////////////////////////////////////////

        mut body = n_body && blockWrapSubstatement(n_body, M_LOOP_BODY);

        //
        let labelUsed  = body.has("goto " ~ name ~ ";"); // TODO FIX track label usage
        let breakLabel = labelUsed && " " ~ name ~ ":;";

        //
        if (post_cond)
        {
            if (init || pre_cond)
                BUG("TODO: cgLoop with post_cond & init/pre_cond.");

            shadow let post_cond = post
                ? post ~ ", " ~ post_cond
                : post_cond;

            return "do" ~ body ~ _indent ~ "while (" ~ post_cond ~ ")" ~ breakLabel;
        }

        if (init || post || !pre_cond)
            return "for (" ~ init ~ "; " ~ pre_cond ~ "; " ~ post ~ ")" ~ body ~ breakLabel;

        return "while (" ~ pre_cond ~ ")" ~ body ~ breakLabel;
    }

    fn cgTryCatch(node: SolvedNode): string
    {
        let items   = node.items;
        let try     = blockWrapSubstatement(items[TRY_TRY]);
        let err_let = items[TRY_ERR];

        err_let.kind == "letdef" || err_let.kind == "empty" || BUG(
            "TRY_ERR not a letdef/empty");

        let err_trg = err_let.target;
        let err     = err_trg && localID(err_trg, dedupe: true);

        let catch   = blockWrapSubstatement(items[TRY_CATCH]);

        //
        mut res: string;
        res ~= _indent ~ "try"
        res ~= _indent ~ "{"
        res ~=  try
        res ~= _indent ~ "}"
        res ~= _indent ~ "catch (const std::exception& o_0)"
        res ~= _indent ~ "{"

        if (err)
            res ~= _indent ~ "    fu::str " ~ err ~ " = fu::to_str(o_0.what());\n"

        res ~=  catch
        res ~= _indent ~ "}\n";

        return res;
    }

    fn inferIndentation(v: string)
    {
        if (v.if_first == '\n')
        {
            for (mut i = 1; i < v.len; i++)
            {
                let c = v[i];
                if (c != ' ' && c != '\t')
                    return v.slice(0, i);
            }
        }

        return "";
    }

    fn cgCompilerPragma(node: SolvedNode): string
    {
        let cmd = node.value;

        // Verbatim cpp nonsense.
        if (cmd == "emit" || cmd == "emit_top" ||
            cmd == "input" || cmd == "output" || cmd == "clock")
        {
            mut result = "";
            mut indent = "";

            // Determine source indentation.
            if (node.items)
            {
                shadow let node = node.items[0];
                if (node.kind == "str")
                    indent = inferIndentation(node.value);
            }

            for (mut i = 0; i < node.items.len; i++)
            {
                shadow let node = node.items[i];
                if (node.kind == "str")
                    result ~= node.value
                        .slice(i == 0 ? indent.len : 0)
                        .replace(all: indent, with: _indent);
                else
                    result ~= cgNode(:node);
            }

            for (mut i = result.len; i --> 0; )
            {
                let c = result[i];
                if (c > ' ')
                {
                    result.shrink(i + 1);
                    break;
                }
            }

            // No longer needed, leaving it as an example,
            //  it was the only thing using the _gcc_ignore thing.
            //
            // _gcc_ignore.add("-Wmisleading-indentation");

            if (_current_fn && cmd != "emit_top")
                return result;

            result ~= "\n";
            if (!_top_emits.has(result))
                _top_emits ~= result;

            return "";
        }

        // Misc hacks.
        let eachStringLiteral = |visit|
        {
            for (mut i = 0; i < node.items.len; i++)
            {
                let item = node.items[i];
                if (item.kind != "str")
                    BUG("compiler link: All arguments must be string literals, got a `" ~ item.kind ~ "`.");

                visit(item.value);
            }

            return "";
        };

        if (cmd == "link")
            eachStringLiteral: |i|
                HACK_link.add(i);

        if (cmd == "include_dirs")
            eachStringLiteral: |i|
                HACK_include_dirs.add(i);

        if (cmd == "sources")
            eachStringLiteral: |i|
                HACK_extra_sources.add(i);

        if (cmd == "include")
            eachStringLiteral: |i|
                include(i.starts(with: '<') ? i : '"' ~ i ~ '"');

        BUG("Unknown compiler pragma: " ~ cmd);
    }


    //

    fn cgNode(node: SolvedNode, mode?: i32, callarg?: Type): string
    {
        let k = node.kind || BUG("cgNode: No node.kind.");
        HERE(node);

        if (k == "not")         return cgNot(node);
        if (k == "call")        return cgCall(node, :mode);

        if (k == "int")         return cgLiteral(node, :mode);
        if (k == "real")        return cgLiteral(node, :mode);
        if (k == "char")        return cgCharLiteral(node);
        if (k == "str")         return cgStringLiteral(node);
        if (k == "arrlit")      return cgArrayLiteral(node, :mode, :callarg);
        if (k == "bool")        return node.value;

        if (k == "copy")        return cgCopyOrMove(node, :mode);
        if (k == "move")        return cgCopyOrMove(node, :mode);

        if (k == "if")          return cgIf(node, :mode);
        if (k == "or")          return cgOr(node, :mode);
        if (k == "and")         return cgAnd(node, :mode);

        if (k == "letdef")      return cgLetDef(node, :mode);

        if (k == "block")       return cgBlock(node, :mode);

        // Empties.
        if (k == "empty")       return cgEmpty(node, :mode);

        // Stuff that we can't cg as expressions.
        if !(mode & M_STMT)
            return cgBlock(node, :mode);

        if (k == "jump")        return cgJump(node);

        if (k == "loop")        return cgLoop(node);
        if (k == "try")         return cgTryCatch(node);
        if (k == "defer")       return cgDefer(node);

        if (k == "pragma")      return cgCompilerPragma(node);

        return BUG("cg: Unexpected " ~ k);
    }


    //

    fn cgCopyOrMove(node: SolvedNode, mode: i32): string
    {
        let expr = node.items.only;

        // Sanity check.
        expr.is_ref || BUG("cgCopyOrMove: !expr.is_ref");

        // Less verbose trivial value returns.
        mut src = cgNode(expr);
        if (mode & M_RETURN && node.type.is_trivial)
            return src;

        if (node.kind == "move")
        {
            fn sanityCheck(lt: Lifetime)
            {
                lt || BUG("cgCopyOrMove: Considering a move from an empty lifetime.");

                lt.Lifetime_each: |locid, isTemp|
                    locid || isTemp || BUG(
                        "cgCopyOrMove: Considering a move from non-local lifetime.");
            }

            sanityCheck(expr.type.lifetime);

            // NRVO now here, solver doesn't care.
            if (mode & M_RETURN)
            {
                fn supportsNRVO(t: Target)
                    t.kind == "var" && !(t.status & SS_ARGUMENT)
                        // && o.local_of == _current_fn.target.index
                        && !t.solved.type.is_ref;

                let nrvo = expr.kind == "call"
                        && expr.items.len == 0
                        && expr.target.supportsNRVO;

                if (nrvo)
                    return "/*NRVO*/ " ~ src;
            }

            if (!node.type.is_trivial)
            {
                fn mayNeedConstCast(shadow expr: SolvedNode)
                {
                    if (expr.is_mutref || !expr.is_ref)
                        return false;

                    fn mayNeedConstCast(items: SolvedNode[..])
                    {
                        for (mut i = 0; i < items.len; i++)
                            if (items[i].mayNeedConstCast)
                                return true;

                        return false;
                    }

                    if (expr.kind == "and" || expr.kind == "or")
                        return expr.items.mayNeedConstCast;

                    if (expr.kind == "if")
                        return expr.items[1 .. 3].mayNeedConstCast;

                    // TODO FIX: checking just the tail expr doesn't look right
                    // if (expr.kind == "block")
                    //     return expr.items.len > 0
                    //         && expr.items[expr.items.len - 1].mayNeedConstCast
                    //
                    //         // TODO FIX re: move-from-vec-range, see call(var) comment below
                    //         || expr.is_sliceable
                    //             && expr.is_ref && !expr.is_mutref
                    //             && expr.ifArrayRef_annotateAsVecRange;

                    if (expr.kind == "call")
                    {
                        let k = expr.target.kind;
                        if (k == "field")
                            return expr.items.mayNeedConstCast;

                        if (k == "var")
                        {
                            // TODO FIX With vec-ranges we're generating different dereference code
                            //  for const & mutrefs, and the const-correct cg is more trouble than it's worth,
                            //   and given that it's not always possible, we're just going to double down on const-casts here.
                            //
                            let place = expr.target.solved.type;
                            if (place.is_sliceable &&
                                place.is_ref && !place.is_mutref &&
                                place.ifArrayRef_annotateAsVecRange)
                            {
                                return true;
                            }

                            // Currently -
                            return false;

                        }

                        let t = expr.target.type;
                        let mayNeedConstCast = t.is_ref && !t.is_mutref;
                        if (mayNeedConstCast)
                        {
                            // Sanity check expr types.
                            sanityCheck(expr.type.lifetime);

                            // Sanity check signature, can't return e.g. statics or whatever.
                            t.lifetime.Lifetime_each: |isArgIdx|
                                isArgIdx || BUG("About to return mayNeedConstCast, but fn returns non-arg refs.");
                        }

                        return mayNeedConstCast;
                    }

                    // Dunno what this is.
                    return true;
                }

                let mayNeedConstCast = mayNeedConstCast(expr);

                if (node.type.is_sliceable && !node.ifArrayRef_annotateAsVec)
                {
                    if (mayNeedConstCast)
                    {
                        // See below.
                        noteDefect(ConstCast);

                        return src ~ ".const_cast_mut().destructive_move()";
                    }
                    else
                    {
                        return src ~ ".destructive_move()";
                    }
                }
                else if (mayNeedConstCast)
                {
                    // Moving from a constref return,
                    //  it's an expressiveness problem in cpp,
                    //   easiest way to work around it is with a const_cast:
                    //
                    //   struct X;
                    //
                    //   const X& func(const X& val) {
                    //       return val;
                    //   }
                    //
                    //   X&& func(X&& val) {            // Alternatively:
                    //       return (X&&)func(val);     //  return static_cast<X&&>(const_cast<X&>(func(val)))
                    //   }
                    //
                    noteDefect(ConstCast);

                    let annot = typeAnnotBase(node.type);

                    return "static_cast<" ~ annot ~ "&&>(const_cast<" ~ annot ~ "&>("
                                ~ src
                                ~ "))";
                }
            }
        }

        if (node.value &&
            options.dev & options::DEV_CG_LifetimeAnnots)
        {
            src = "/*" ~ node.value ~ "*/ " ~ src;
        }

        return cgCopyOrMove(node.kind, node.type, src);
    }

    fn cgCopyOrMove(kind: Kind, type: Type, src: string): string
    {
        if (kind == "move")
            return cgMove(type, src);

        return cgCopy(type, src);
    }

    fn cgMove(type: Type, src: string): string
    {
        if (type.isPassByValue)
            return cgCopy(type, src);

        return "static_cast<" ~ typeAnnotBase(type) ~ "&&>(" ~ src ~ ")";
    }

    fn cgCopy(type: Type, src: string): string
    {
        if (type.isPassByValue)
            return src;

        return typeAnnotBase(type) ~ "(" ~ src ~ ")";
    }


    //

    fn PointerFlip(o: Overload)
    {
        return PointerFlip(o.solved.type);
    }

    fn PointerFlip(type: Type)
    {
        return !type.is_ref || type.isPassByValue && !type.is_mutref
            ? PointerFlip.None
            : !type.is_sliceable || type.ifArrayRef_annotateAsVec
                ? PointerFlip.RawPointer
                : PointerFlip.VecRangeOrView;
    }

    fn TEMPVAR_declare(
        type: Type,
        ref ptr_flip!: PointerFlip, ref annot!: string,
        mode!?: i32, id?: string): string
    {
        annot = typeAnnot(:type, :mode);
        ptr_flip = PointerFlip(type);

        shadow let id = id || "_" ~ _current_fn.numTEMPVARs++;

        _current_fn.TEMPVARs ~=
            ptr_flip == PointerFlip.RawPointer
                ? annot[.. annot.len - 1] ~ "* " ~ id
                : type.is_trivial
                    ? annot ~ " " ~ id
                    : annot ~ " " ~ id ~ " {}";

        if (annot == "int")
            ptr_flip == PointerFlip.None || BUG(
                "TEMPVAR_declare: int." ~ ptr_flip);

        return id;
    }

    fn TEMPVAR_init(id: string, ptr_flip: PointerFlip, init?: string, immediate!?: bool)
    {
        if (immediate && ptr_flip != PointerFlip.VecRangeOrView)
            return (ptr_flip == PointerFlip.RawPointer ? "(*(" : "(")
                 ~ TEMPVAR_init(:id, :ptr_flip, :init)
                 ~ (ptr_flip == PointerFlip.RawPointer ? "))" : ")");

        // fu::vec_range and fu::view have a pointer-assignment
        //  operator=(fu::vec*) that basically reassigns them,
        //   as if they were pointers, for late init & such.
        //
        if (ptr_flip == PointerFlip.RawPointer)
            return id ~ " = &" ~ (init && "(" ~ init ~ ")");

        if (ptr_flip == PointerFlip.VecRangeOrView)
            return id ~ ".ptr_reassign" ~ (init && "(" ~ init ~ ")");

        return id ~ " = " ~ init;
    }

    fn TEMPVAR_consume(id: string, type: Type, ptr_flip: PointerFlip)
    {
        if (ptr_flip == PointerFlip.None)
            return cgMove(:type, id);

        if (ptr_flip == PointerFlip.RawPointer)
            return "*" ~ id;

        return id;
    }

    fn TEMPVAR_peek(ptr_flip: PointerFlip, expr: string, parens!: bool)
    {
        if (ptr_flip == PointerFlip.RawPointer)
        {
            if (parens)
                return "(*" ~ expr ~ ")";

            return "*" ~ expr;
        }

        return expr;
    }


    //

    fn cgNodes(nodes: SolvedNode[], mode?: i32, trail!?: string): string[]
    {
        mut result: string[];

        //////////////////////////////////////////////////////////
        mut _tv0: string[];
        if (mode & M_STMT) swap(_tv0, _current_fn.TEMPVARs);
        defer {
            if (mode & M_STMT) swap(_tv0, _current_fn.TEMPVARs);
        }
        //////////////////////////////////////////////////////////

        for (mut i = 0; i < nodes.len; i++)
        {
            let node    = nodes[i];

            if (mode & M_CHECK_NEVER_LTR)
                if (node.type.is_never && i < nodes.len - 1)
                    BUG("M_CHECK_NEVER_LTR: non-trailing node.is_never");

            let isTrail = trail && i == nodes.len - 1 && !node.is_never && !node.isIrrelevant;

            mut src     = node && cgNode(node, isTrail ? mode &~ M_STMT : mode);

            src || mode & M_STMT || BUG("cgNodes: empty output for Node(kind=`" ~ node.kind ~ "` value=`" ~ node.value ~ "`).");

            if (mode & M_STMT && _current_fn.TEMPVARs)
            {
                result ~= _current_fn.TEMPVARs;
                _current_fn.TEMPVARs.clear();
            }

            if (isTrail)
                src = trail ~ "(" ~ src ~ ")";

            result.push(src);
        }

        return result;
    }


    //

    let root = module.out.solve.root;
    root.kind == "root" || BUG();

    mut src = cgRoot(root, module.out.solve.scope.items);


    // TODO FIX just add these as translation units,
    //  need proper hashing and everything, so they should just skip over compile & cg
    //   but otherwise work like our own generated sources.

    for (mut i = 0; i < HACK_extra_sources.len; i++)
    {
        let orig = HACK_extra_sources[i];
        let file = localPath(orig);
        src ~= "\n// " ~ orig ~ "\n";
        src ~= file::read(file);
    }


    //

    return CodegenOutput(:src,
        link:               HACK_link,
        extra_sources:      HACK_extra_sources,
        include_dirs:       HACK_include_dirs,
        includes_headers:   _libs,
        defects:            _defects);
}
