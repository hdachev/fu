

// Overload flags.

using flags SolverStatus: u16
{
    SS_LAZY
    SS_DID_START
    SS_DIRTY
    SS_FINALIZED

    SS_UPDATED
    SS_TYPE_RECUR
    SS_FN_RECUR
    SS_FN_OOE_RTL

    SS_HOIST
    SS_UNUSED
    SS_MATCHED
    SS_MOVED_FROM

    SS_Debug_AllPassesComplete
    // ...
    // ...
    // ...
}


// Solver helpers.

using flags HelpersMask
{
    HM_CanBreak
    HM_CanReturn
    HM_Anon
    HM_Function

    HM_Lambda
    HM_Struct
    HM_LabelUsed
    // ...

    HM_LoopPreheader
    // ...
    // ...
    // ...
}


//

using flags DeclAsserts: u16
{
    A_NOCOPY
    A_NOVEC
    A_TRIVIAL
    // ...

    A_PURE
    A_PURE_CTX
    A_PURE_FX
    // ...

    A_NOFLOW
    A_NOTHROW
    A_NOCRASH
    // ...

    A_NOIO
    // ...
    A_FAST
    // ...

    A_NOINLINE
    // ...
    // ...
    // ...
};


//

using flags ParseSyntax
{
    PS_ID

    PS_PARENS
    PS_SEMI

    PS_DISCARD_IF_BLOCK_TAIL
    PS_ALWAYS_DISCARD
    PS_NOT_AN_EXPRESSION
};


// TODO clean up the fncall flags, it's historic bs.

using flags Flags: u32
{
    F_METHOD
    // ...
    // ...
    F_OPERATOR

    F_ACCESS
    F_TYPENAME
    F_COMPOUND_ID
    F_WRITTEN_TO


    F_LAX
    F_ARG
    F_COW_INSIDE
    // ...

    F_CONVERSION
    F_OPT_ARG
    F_MUT
    F_REF


    F_IMPLICIT
    F_USING
    F_MUSTNAME
    F_SHADOW

    F_PUB           // TODO group these three up
    F_EXTERN        //  in enum Linkage
    F_HOTSWAP       //   or enum Visibility or smth
    F_PREDICATE


    F_NAMED_ARGS    // TODO FIX do we need this really? the ast is self-explanatory
    F_REST_ARG
    F_RELAXABLE_REF
    F_INJECTED

    F_TEMPLATE
    F_INLINE
    F_LAMBDA
    // ...
};


//

using flags ExitPaths {
    XP_NonEmptyReturn
    XP_EmptyReturn
    XP_NoReturn
};


// Commons.

let LET_TYPE        = 0;
let LET_INIT        = 1;

let FN_RET_BACK     = -2;
let FN_BODY_BACK    = -1;
let FN_ARGS_BACK    = FN_RET_BACK;

let TYPECTOR_BACK   = -1;

let LOOP_INIT       = 0;
let LOOP_PRE_COND   = 1;
let LOOP_PRE        = 2;
let LOOP_BODY       = 3;
let LOOP_POST       = 4;
let LOOP_POST_COND  = 5;

let STRUCT_BASE     = 0;
let STRUCT_MEMBERS  = 1;

let TRY_TRY         = 0;
let TRY_ERR         = 1;
let TRY_CATCH       = 2;


// Solver notes.

using flags SolverNotes: i32
{
    N_FnRecursion
    N_FnResolve
    N_FnReopen

    N_TypeRecursion
    N_TypeResolve
    N_TypeReopen

    N_DeadCode
    N_DeadCall
    N_DeadLet
    N_DeadArrlit
    N_DeadLoopInit
    N_DeadConv

    N_NonTrivAutoCopy

    N_RelaxRespec

    N_UnusedImplicit
    N_UnusedCall
    N_UnusedDefer
    N_UnusedTry
    N_UnusedAndOr
    N_UnusedIfElse
    N_UnusedArrlit
    N_UnusedLet

    N_BckMustSeq

    N_AARMustSeq
    N_AARSoftRisk

    N_MoveMustSeq

    N_SD_HasStaticInit
    N_SD_ExternPrivates

    N_COWRestrict
}


//

using flags CGDefects
{
    GNUStmtExpr;
    Goto;
    PointlessMustSeq;
    LocalConstBool;
    ConstCast;
    PointlessLocal;
    IrrelevantLiteral;
    DuplicateFunctions;
};
