import helpers;
import module;

fn ensure_local_fname(fname: string, dir_src: string): string
{
    if (fname.starts(with: dir_src))
        return fname;

    let foreign = dir_src ~ ".foreign/";
    fs::mkdir_p(foreign);

    let rel = path::relative(from: dir_src, to: fname)
        .replace(all: "../", with: "up__")
        .replace(all:   "/", with:   "__");

    return foreign ~ rel;
}

fn update_file(
    fname   !: string,
    data    !: string,
    dir_src !: string,
    dir_out !: string)
{
    shadow let fname = ensure_local_fname(:fname, :dir_src);
    fname.starts(with: dir_src) || throw("ensure_local_fname broken");

    shadow let fname = dir_out ~ fname.slice(dir_src.len);
    if (file::read(fname) != data)
    {
        let err = file::write(fname, data);
        if (err)
            throw("Failed to write `" ~ fname ~ "`, error: #" ~ err);

        println("  WROTE " ~ fname);
    }

    return fname;
}


//

pub fn build(
    implicit ctx: Context,

    mut dir_wrk  !: string,

        fudir    !: string,
    mut fulib   !?: string,

    mut bin     !?: string,
    mut dir_obj !?: string,
    mut dir_src !?: string,
    mut dir_cpp !?: string,
        unity   !?: string,
        scheme  !?: string,
        onfail  !?: string,

        // TODO clean these up, this makes NO SENSE //
        run     !?: bool,
        shared  !?: bool,
        hotswap !?: bool,
        //////////////////////////////////////////////

        flags_cc!?: string[],
        flags_ld!?: string[]): void
{
    // Where we do our dirtywork.
    if (dir_wrk.if_last != '/')
    {
        dir_wrk || throw ("No workspace directory provided.");
        dir_wrk ~= '/';
    }

    //
    if (dir_obj && dir_obj.if_last != '/') dir_obj ~= '/';
    if (dir_src && dir_src.if_last != '/') dir_src ~= '/';
    if (dir_cpp && dir_cpp.if_last != '/') dir_cpp ~= '/';

    // Optimization level.
    mut O_lvl   = scheme != "debug"
                ? "-O3 -DNDEBUG -fno-math-errno "
                : "-Og "
                ;

    // Debug symbols.
    if (scheme == "debug" || scheme == "reldeb")
        O_lvl ~= "-g ";

    if (scheme == "retail")
        O_lvl ~= "-Dfu_RETAIL ";

    if (shared)
        O_lvl ~= "-fPIC ";
    if (hotswap)
        O_lvl ~= "-Dfu_HOTSWAP ";

    let GCChash = "g++ -std=c++1z " ~ O_lvl;

    // Not considering warnings when hashing files.
    let GCC_CMD = GCChash
                ~ "-pedantic-errors -Wall -Wextra -Werror " // opt-in
                ~ "-Wdouble-promotion " // opt-in
                ~ "-Wconversion -Wsign-conversion " // opt-in

                // clang issue with float->bool,
                //  if we have an explicit !! codegen this can be fixed,
                //   an x != 0 works, this can be also used non-zero non-nan check.
                //
                ~ "-Wno-float-conversion " // opt-out

                // Clang warns extern "C" hotswap fns are incompatible with c
                ~ (hotswap && process::APPLE && "-Wno-return-type-c-linkage ")

                // TODO request this from within the lib
                ~ (process::LINUX && "-pthread -ldl ")
                ;

    //
    fulib ||= path::join(fudir, hotswap ? "include/fu/_sharedlib.cpp"
                                        : "include/fu/_fulib.cpp");

    let fulib_cpp = CodegenOutput(src: file::read(fulib));

    // Map modules into translation units,
    //  this is the partial unity build thing,
    //   we could use this to guarantee static init order,
    //    access to private values & optimize build time.
    mut unit_mapping: i32[];
    mut unit_fnames: string[];

    //
    let modules = ctx.modules;


    // Depedency sort.

    struct ModuleSortHelper { compile_index: i32; };

    using fn GET(using _: ModuleSortHelper) modules[compile_index];

    shadow let modules =
    {
        mut buckets: ModuleSortHelper[][];
        for (mut i = 0; i < modules.len; i++)
        {
            let module = modules[i];
            buckets.grow_if_oob(module.out.init_prio) ~= ModuleSortHelper(i);
        }

        //
        mut result: ModuleSortHelper[];
        for (mut i = 0; i < buckets.len; i++)
            result ~= buckets[i];

        result
    };


    //

    for (mut i = 0; i < modules.len; i++)
    {
        let module  = modules[i];
        let cpp     = i ? module.out.cpp
                        : fulib_cpp;
        if (!cpp.src)
        {
            unit_mapping ~= -1;
            continue;
        }

        mut unit = i;
/*
        for (shadow mut i = 0; i < cpp.unity.len; i++)
        {
            let u = unit_mapping[cpp.unity[i]];
            if (unit > u)
                unit = u;
        }

        for (shadow mut i = 0; i < cpp.unity.len; i++)
        {
            let m = cpp.unity[i];
            let u = unit_mapping[m];
            if (u != unit)
                for (shadow mut i = u; i < unit_mapping.len; i++)
                    if (unit_mapping[i] == u)
                        unit_mapping[i] = unit;
        }
*/
        unit_mapping ~= unit;
        unit_fnames.grow_if_oob(unit) = i ? module.fname : "fulib runtime";
    }

    // Concat unit sources.
    mut units: string[];

    for (mut i = 0; i < modules.len; i++)
    {
        let module  = modules[i];
        let cpp     = i ? module.out.cpp
                        : fulib_cpp;
        if (cpp.src)
            units.grow_if_oob(unit_mapping[i]) ~= cpp.src;
    }

    //
    mut Fs: string[];
    mut len_all: i32;

    for (mut i = 0; i < units.len; i++)
    {
        let cpp = units[i];
        if (!cpp)
            continue;

        let F = dir_wrk ~ "o-" ~ tea::hash16(GCChash ~ cpp)
                        ~  "-" ~ cpp.len;

        Fs.grow_if_oob(i) = F;
        len_all += cpp.len;
    }

    //
    fs::mkdir_p(dir_wrk);

    //
    mut code:   i32;
    mut stdout: string;

    fn ERR(mut cpp: string = "")
    {
        if (!cpp)
            for (mut i = Fs.len; i --> 0; )
                if (Fs[i])
                    cpp ~= "#include \"" ~ Fs[i] ~ ".cpp\"\n";

        let fname = dir_wrk ~ "failing-testcase.cpp";
        println("  WRITE " ~ fname);
        file::write(fname, cpp);

        //
        if (!stdout)
            stdout = "Exit code: " ~ code;

        mut explain = "";
        if (onfail)
        {
            explain = "\nFailing testcase:\n\n";
            for (mut i = 1; i < modules.len; i++)
                explain ~= onfail == "print-src"
                    ? modules[i].in.src
                    : modules[i].fname ~ "\n";

            if (onfail == "print-src")
            {
                explain ~= "\nSources:\n";
                for (mut i = 1; i < modules.len; i++)
                    explain ~= modules[i].out.cpp.src;
            }
        }

        return throw(stdout ~ explain);
    }

    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////
    ////  Total nonsense, tbd how we're gonna do this,
    ////   but I'd like us to have something that
    ////    just-works for the simplest things like your local glfw.
    ////
    mut HACK_linkFlags:         string[];
    mut HACK_pkgConfig_libs:    string[];
    mut HACK_pkgConfig_cflags:  string[];

    mut HACK_include_dirs:      string[];

    for (mut i = 0; i < modules.len; i++)
    {
        let module = modules[i];

        //
        let include_dirs = module.out.cpp.include_dirs;
        if (include_dirs)
        {
            let dir = path::dirname(module.fname);
            include_dirs.each: |incl|
                HACK_include_dirs.set::add(
                    incl.starts(with: '.')
                        ? path::join(dir, incl)
                        : incl);
        }

        //
        mut cflags = "";

        mut libs = module.out.cpp.link;
        for (shadow mut i = 0; i < libs.len; i++)
        {
            mut lib = libs[i];

            if (lib.starts(with: "-")) {
                HACK_linkFlags.set::add(lib);
            }
            else {
                cflags ~= lib;
                HACK_pkgConfig_libs.set::add(lib);
            }
        }

        if (cflags)
            HACK_pkgConfig_cflags.grow_if_oob(i) = " $(pkg-config --cflags " ~ cflags ~ ")";
    }

    let INCLUDE = (flags_cc && " " ~ flags_cc.join(' ')) ~ " -I " ~ fudir ~ "include"
                ~ (HACK_include_dirs && " -I " ~ HACK_include_dirs.join(" -I "));

    let LIBS = (flags_ld && " " ~ flags_ld.join(' '))
             ~ (HACK_linkFlags      && " "                     ~ HACK_linkFlags.join(" "))
             ~ (HACK_pkgConfig_libs && " $(pkg-config --libs " ~ HACK_pkgConfig_libs.join(" ") ~ ")");
    ////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////

    //
    let F_exe = dir_wrk ~ "b-" ~ tea::hash16(Fs.join("/") ~ LIBS)
                        ~  "-" ~ len_all ~ "-" ~ Fs.len;

    let old_size = file::size(F_exe);
    if (old_size < 1 && (bin || run))
    {
        struct BuildError {
            code: i32;
            cpp: string;
            stdout: string;
        };

        fn buildFile(F: string, i: int): BuildError
        {
            if (!F)
                return [];

            let F_cpp = F ~ ".cpp";
            let F_tmp = F ~ ".o.tmp";
            let F_obj = F ~ ".o";

            fn CACHE_objFileAvailable()
                file::size(F_obj) > 0;

            if (CACHE_objFileAvailable())
                return [];

            let original_fname = i && modules[i].fname;

            // Prelude @ 0.
            let human = original_fname
                      ? original_fname.path::filename
                      : "fulib runtime";

            let cpp = units[i];
            file::write(F_cpp, cpp);

            println("  BUILD ", human, " ", F_cpp);

            let t0 = now::hr();

            ///////////////////////////////////////////////////////////////////
            shadow let INCLUDE = INCLUDE ~ HACK_pkgConfig_cflags.unless_oob(i);
            ///////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////////////////////////
            shadow let INCLUDE = INCLUDE ~ (original_fname && " -iquote " ~ original_fname.path::dirname);
            ////////////////////////////////////////////////////////////////////////////////////////////////

            let CMD = GCC_CMD ~ "-c" ~ INCLUDE ~ " -o " ~ F_tmp ~ " " ~ F_cpp;

            // println("      > ", CMD);
            shadow mut stdout: string;

            mut status: i32;
            shadow let code = ::spawn(CMD.split(' '), :status, :stdout, stderr: stdout) || status
                           || file::rename(F_tmp, F_obj);

            if (code)
            {
                if (CACHE_objFileAvailable())
                {
                    // We can race with a parallel build here,
                    //  so long as the obj is now present in its final location
                    //   we're fine to go forward.
                    //
                    println("RACE OK ", human);
                    return [];
                }

                return BuildError(:code, :cpp, :stdout);
            }

            let t1 = now::hr();
            println("     OK ", human, " ", t1 - t0, "s");
            return [];
        }

        // Build.
        let buildErrors = Fs.par::map(fn buildFile);

        for (mut i = 0; i < buildErrors.len; i++)
        {
            let err = buildErrors[i];
            if ((code = err.code))
            {
                stdout = err.stdout;
                return ERR(err.cpp);
            }
        }

        // Link.
        let F_tmp = F_exe ~ ".tmp";

        mut cmd = GCC_CMD ~ "-o " ~ F_tmp;

        if (shared)
        {
            cmd ~= " -shared";

            // Linker -soname
            let soname = path::filename(bin);
            if (process::APPLE)
                cmd ~= " -Wl,-install_name," ~ soname;
            else
                cmd ~= " -Wl,-soname," ~ soname;
        }

        for (mut i = 0; i < Fs.len; i++)
        {
            let F = Fs[i];
            if (F)
                cmd ~= " " ~ F ~ ".o";
        }

        //
        {
            println("   LINK ", F_exe, LIBS);

            let t0 = now::hr();

            let CMD = cmd ~ LIBS;

            // println("      > ", CMD);

            mut status: i32;
            code = ::spawn(CMD.split(' '), :status, :stdout, stderr: stdout) || status
                || file::chmod(F_tmp, file::RWX_RX_RX)
                || file::rename(F_tmp, F_exe);

            if (code)
            {
                println("   FAIL " ~ CMD ~ " EXIT=" ~ code ~ "\n" ~ stdout);
                return ERR;
            }

            let t1 = now::hr();
            println("     OK ", t1 - t0, "s");
        }

        if (code) return ERR;
    }

    //
    if (run)
    {
        // TODO FIX
        //
        // The intent is that if this only reports a status code,
        //  and does not depend on anything from the environment,
        //   there's no point in ever rerunning it.
        //
        let OPTI_StatusCode = true;

        fn READ_StatusCode()
            file::read(F_exe).view(i32).only;

        fn WRITE_StatusCode(shadow code: i32)
            file::write(F_exe, [ code ].view(byte));

        //
        if (OPTI_StatusCode && old_size == 4)
        {
            code = READ_StatusCode();
        }
        else
        {
            println("    RUN " F_exe);

            let t0 = now::hr();
            mut status: i32;
            code = ::spawn([ F_exe ], :status, :stdout, stderr: stdout) || status;
            let t1 = now::hr();

            println("     OK ", t1 - t0, "s");

            //
            if (OPTI_StatusCode)
            {
                // However, when tests run in parallel this can totally brick itself -
                //  if for some reason we already did this and tried to run the 4-byte exe,
                //   it obviously breaks and here we'd persist the broken result forever.
                //
                // We can notice the exe has shrunk to 4 bytes though,
                //  and discard the result of our run with the one
                //   that was just cached by a parallel run.
                //
                let new_size = file::size(F_exe);
                if (new_size > 4)
                    WRITE_StatusCode(code);
                else if (new_size == 4)
                    code = READ_StatusCode();
            }
        }
    }

    if (code) return ERR;

    // .cpp file output.
    if (dir_cpp && dir_src)
    {
        fs::mkdir_p(dir_cpp);

        mut cpp_files: string[];

        for (mut i = 1; i < units.len; i++)
        {
            let data            = units[i];
            let fname           = data  && unit_fnames[i] ~ ".cpp";
            shadow let fname    = fname && update_file(
                :fname, :data,
                :dir_src, dir_out: dir_cpp);

            cpp_files.push(fname);
        }

        // TODO FIX
        let cmake       = false;
        let CMakeLists  = cmake && path::join(path::dirname(unity), "CMakeLists.txt");

        if (unity || CMakeLists)
        {
            // .unity.cpp
            if (unity)
            {
                mut data = "#ifdef fu_UNITY_FULIB\n"
                         ~ "#include <fu/_fulib.cpp>\n"
                         ~ "#endif\n\n";

                for (mut i = 0; i < cpp_files.len; i++)
                {
                    let incl = cpp_files[i];
                    if (incl)
                        data ~= "#include \"" ~ path::relative(unity, incl) ~ "\"\n";
                }

                update_file(
                    fname: unity ~ ".unity.cpp", :data,
                    :dir_src, dir_out: dir_cpp);
            }

            // CMakeLists.txt
            if (CMakeLists)
            {
                mut data = "cmake_minimum_required(VERSION 3.6)\n\n";

                mut inputs:  string[];
                mut outputs: string[];

                mut main: string;
                mut includes: string;

                for (mut i = 1; i < modules.len; i++)
                {
                    let module = modules[i];
                    let input = path::relative(CMakeLists, module.fname);
                    if (module.compile_index == 1)
                        main = input;

                    inputs.push(input);

                    // Check for custom cmake files.
                    let custom = module.fname ~ ".cmake";
                    if (file::size(custom) > 0)
                        includes ~= "include(" ~ path::relative(CMakeLists, custom) ~ ")\n";
                }

                for (mut i = 0; i < cpp_files.len; i++)
                {
                    let cpp_file = cpp_files[i];
                    if (cpp_file)
                        outputs.push("${CMAKE_CURRENT_SOURCE_DIR}/" ~ path::relative(CMakeLists, cpp_file));
                }

                let libname = path::noext(path::filename(main));

                data ~= "set(FU_TARGET " ~ libname ~ ")\n\n";

                data ~= "set(FU_MAIN " ~ main ~ ")\n\n";
                data ~= "set(FU_INPUTS\n    " ~ inputs.join("\n    ") ~ ")\n\n";

                if (unity)
                    data ~= "set(FU_OUTPUTS\n    " ~ "${CMAKE_CURRENT_SOURCE_DIR}/" ~ path::relative(CMakeLists, unity) ~ ".unity.cpp)\n\n";
                else
                    data ~= "set(FU_OUTPUTS\n    " ~ outputs.join("\n    ") ~ ")\n\n";

                data ~= "add_custom_command(\n"
                      ~ "    OUTPUT ${FU_OUTPUTS}\n"
                      ~ "    COMMAND $ENV{HOME}/fu/bin/fu\n"
                      ~ "    ARGS -c ${FU_MAIN}\n"
                      ~ "    DEPENDS ${FU_INPUTS}\n"
                      ~ "    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n"
                      ~ "    VERBATIM)\n\n";

                data ~= "add_library(${FU_TARGET} ${FU_OUTPUTS})\n\n";

                data ~= "add_library(fulib SHARED $ENV{HOME}/fu/include/fu/_fulib.cpp)\n"
                      ~ "target_include_directories(fulib PUBLIC $ENV{HOME}/fu/include/)\n"
                      ~ "target_link_libraries(${FU_TARGET} PUBLIC fulib)\n\n";

                if (includes)
                    data ~= includes ~ "\n";

                update_file(
                    fname: CMakeLists, :data,
                    :dir_src, dir_out: dir_cpp);
            }
        }
    }

    // output binary.
    if (bin)
    {
        fs::mkdir_p( path::dirname(bin) );

        code = file::rename(F_exe, bin);
    }

    if (code) return ERR;
}
