import helpers;
import module;
import ansi;


// TODO re: rewrite -
//
// We need a principled fn fail() here,
//  something that can relate most problems to a token somewhere in your sources,
//   so we can raise error messages with the usual formatting.


// TODO FAILCASE - doesn't parse here, weird
// fn fail = fn throw;

// TODO FAILCASE - doesn't work either
// fn fail = .throw;

fn fail(reason: string) throw(reason);


//

let TODO_FIX_ignoredWarnings = ""

    // clang issue with float->bool,
    //  if we have an explicit !! codegen this can be fixed,
    //   an x != 0 works, this can be also used for a non-zero non-nan check.
    //
    ~ "-Wno-float-conversion " // opt-out

    // gcc & clang complain about unused-but-set variables
    //  that we fail to eliminate in templated iterators,
    //   gotta figure out something, but for the time being we gotta opt out.
    //
    ~ "-Wno-unused-but-set-variable " // opt-out

    // Not every clang has unused-but-set-variable
    //
    ~ "-Wno-unknown-warning-option " // opt-out

    // Running into a bunch of weird warnings on gcc12.
    //
    // Array bounds errors after size is checked,
    //  sequence-points for assignments (RTL by standard), etc.
    //   Can't have false positives break builds.
    //
    ~ "-Wno-maybe-uninitialized -Wno-stringop-overflow -Wno-array-bounds -Wno-sequence-point "

    ;



//

fn ensure_local_fname(fname: string, dir_src: string): string
{
    if (fname.starts(with: dir_src))
        return fname;

    let foreign = dir_src ~ ".foreign/";
    fs::mkdir_p(foreign);

    let rel = path::relative(from: dir_src, to: fname)
        .replace(all: "../", with: "up__")
        .replace(all:   "/", with:   "__");

    return foreign ~ rel;
}

fn tmpfile(mut fname: string)
{
    fname ~= '-';

    mut r = rand::next_u64();
    for (mut i = 0; i < 8; i++)
    {
        let v = r & 0x1f;
        fname ~= byte(
            v < 10  ? '0'.i32 + v.i32
                    : 'a'.i32 + v.i32 - 10);
        r >>= 5;
    }

    return fname;
}

fn atomic_write(fname!: string, data: string)
{
    let tmp = tmpfile(fname);

    let err = file::write(tmp, data) || file::rename(tmp, fname);
    if (err)
        file::unlink(tmp);

    return err;
}

fn update_file(
    fname   !: string,
    data    !: string,
    dir_src !: string,
    dir_out !: string)
{
    shadow let fname = ensure_local_fname(:fname, :dir_src);
    fname.starts(with: dir_src) || fail("ensure_local_fname broken");

    shadow let fname = dir_out ~ fname.slice(dir_src.len);
    if (file::read(fname) != data)
    {
        let err = atomic_write(:fname, data);
        if (err)
            fail("Failed to write `" ~ fname ~ "`, error: #" ~ err);

        println("  WROTE " ~ fname);
    }

    return fname;
}


// TODO FIX

fn exec(cmd: string, ref stdout: string)
{
    mut status = 0;
    mut err: i32;

    if (cmd.has("$("))
        err = ::exec(cmd, :status, stdout);
    else
        err = ::spawn(cmd.split(' '), :status, :stdout, stderr: stdout);

    return err || status;
}


//

using flags DEV_OnFail
{
    OnFail_PrintInput
    OnFail_PrintOutput
    OnFail_WriteRepro
};

pub fn build(
    implicit ctx: Context,

    mut dir_wrk  !: string,

        fudir    !: string,
    mut fulib   !?: string,

    mut bin     !?: string,
    mut dir_obj !?: string,
    mut dir_src !?: string,
    mut dir_cpp !?: string,
        unity   !?: string,
        scheme  !?: string,
        onfail  !?: DEV_OnFail,

        // TODO clean these up, this makes NO SENSE //
        run     !?: bool,
        shared  !?: bool,
        hotswap !?: bool,
        nocache !?: bool,
        //////////////////////////////////////////////

        flags_cc!?: string[],
        flags_ld!?: string[]): test_output::TestOutput
{
    // Where we do our dirtywork.
    if (dir_wrk.if_last != '/')
    {
        dir_wrk || fail("No workspace directory provided.");
        dir_wrk ~= '/';
    }

    //
    if (dir_obj && dir_obj.if_last != '/') dir_obj ~= '/';
    if (dir_src && dir_src.if_last != '/') dir_src ~= '/';
    if (dir_cpp && dir_cpp.if_last != '/') dir_cpp ~= '/';

    // Optimization level.
    mut O_lvl   = scheme != "debug"
                ? "-O3 -DNDEBUG -fno-math-errno "
                : "-Og "
                ;

    // Debug symbols.
    if (scheme == "debug" || scheme == "reldeb")
        O_lvl ~= "-g ";

    if (scheme == "retail")
        O_lvl ~= "-Dfu_RETAIL ";

    if (shared)
        O_lvl ~= "-fPIC ";

    // TODO FIX should be just if (hotswap), currently:
    //  - hotswap builds need a shared fulib;
    //  - the fulib is shared=true, hotswap=false, but needs to include the fu_HOTSWAP stuff.
    if (hotswap || shared)
        O_lvl ~= "-Dfu_HOTSWAP ";

    let GCChash = "g++ -std=c++1z " ~ O_lvl;

    // Not considering warnings when hashing files.
    let GCC_CMD = GCChash
                ~ "-pedantic-errors -Wall -Wextra -Werror " // opt-in
                ~ "-Wdouble-promotion " // opt-in
                ~ "-Wconversion -Wsign-conversion " // opt-in

                // Opt-outs, stuff we fail to clean up right now.
                ~ TODO_FIX_ignoredWarnings

                // Clang warns extern "C" hotswap fns are incompatible with c
                ~ (hotswap && process::APPLE && "-Wno-return-type-c-linkage ")

                // TODO request this from within the lib
                ~ (process::LINUX && "-pthread -ldl ")
                ;

    shadow let GCChash = tea::hash(GCChash);

    //
    fulib ||= path::join(fudir, hotswap ? "include/fu/_sharedlib.cpp"
                                        : "include/fu/_fulib.cpp");

    let fulib_cpp = CodegenOutput(src: file::read(fulib));

    // Map modules into translation units,
    //  this is the partial unity build thing,
    //   we could use this to guarantee static init order,
    //    access to private values & optimize build time.
    mut unit_mapping: i32[];

    struct TranslationUnit
    {
        // Original filename or whatever describes what this is,
        //  we'll print it out in case of error.
        human?:             string;

        // Zero/one/many modules' codegen output.
        src?:               string;

        // Dirname to resolve #includes "with quotes" relative to.
        iquote?:            string;

        // Hash of all mutable headers this unit #includes in the src.
        includes_hash?:     tea::TEA;

        // Where this goes to if cpp-source output is requested.
        src_output_file?:   string;

        // .fu-cache cpp file, what we feed to gcc/clang & co - ideally temp,
        //  but there's some benefit to leaving these around
        //   when investigating failing tests.
        //
        // The ideal generated filename is a shallow hash
        //  of just the text contents of the file itself.
        //
        cpp_cache_file?:    string;

        // .fu-cache obj file, ideal filename is -
        //  .fu-cache/cache_cpp_file-[hash includes + build options]
        //
        // We want a clean mapping from one single source file
        //  to multiple object files, and we want new object files
        //   when we fiddle with e.g. the builtin headers or whatever.
        //
        obj_cache_file?:    string;

        //
        HACK_pkgConfig_cflags?: string;
    };

    mut units: TranslationUnit[];

    //
    let modules = ctx.modules;


    // Depedency sort.

    struct ModuleSortHelper { compile_index: i32; };

    using fn GET(using _: ModuleSortHelper) modules[compile_index];

    shadow let modules =
    {
        mut result: ModuleSortHelper[];
        for (mut i = 0; i < ctx.dep_order.len; i++)
            result ~= ModuleSortHelper(ctx.dep_order[i]);

        result
    };


    //

    for (mut i = 0; i < modules.len; i++)
    {
        let module  = modules[i];
        let cpp     = i ? module.out.cpp
                        : fulib_cpp;
        if (!cpp.src)
        {
            unit_mapping ~= -1;
            continue;
        }

        let fname   = i ? module.fname
                        : "fulib runtime";

        let human   = i ? module.fname.path::filename
                        : "fulib runtime";

        let iquote  = i ? module.fname.path::dirname
                        : "";

        mut unit_index = i;
/*
        for (shadow mut i = 0; i < cpp.unity.len; i++)
        {
            let u = unit_mapping[cpp.unity[i]];
            if (unit_index > u)
                unit_index = u;
        }

        for (shadow mut i = 0; i < cpp.unity.len; i++)
        {
            let m = cpp.unity[i];
            let u = unit_mapping[m];
            if (u != unit_index)
                for (shadow mut i = u; i < unit_mapping.len; i++)
                    if (unit_mapping[i] == u)
                        unit_mapping[i] = unit_index;
        }
*/
        unit_mapping ~= unit_index;
        units.grow_if_oob(unit_index) =
            TranslationUnit(
                src_output_file: fname ~ ".cpp",
                :human, :iquote);
    }

    // Concat unit sources.
    {
        mut content_hashes: flat::Map(string, u64);

        fn getContentHash(
            include: string,
            start_fname: string,
            include_dirs: string[])
        {
            fn tryFollow(dir: string, file: string): u64
            {
                let path = path::join(dir, file);

                ref hash = content_hashes.ref(path);
                if (hash)
                    return hash;

                let src = file::read(:path);
                if (!src)
                    fail("Could not resolve include " ~ include.qBAD ~ " relative to " ~ dir.qID);

                shadow let hash = (hash = tea::hash(src).u64);

                // Traverse #includes recursively.
                mut hash_deep = parseIncludes(:path, :src);
                if (hash_deep)
                {
                    shadow ref hash = content_hashes.ref(path);

                    hash_deep.hash(hash);
                    return hash = hash_deep.u64;
                }

                // TODO FIX parse & follow #includes inside
                return hash;
            }

            fn parseIncludes(path: string, src: string): tea::TEA
            {
                mut hash_all: tea::TEA;

                :NEXT_INCLUDE
                src.split("#include", each: |match, first|
                {
                    if (first)
                        continue :NEXT_INCLUDE;

                    fn matchFail(lax reason: string)
                    {
                        let firstNewline = match.find('\n');
                        shadow let match = firstNewline > 0
                                 ? match.slice(start: 0, end: firstNewline)
                                 : match;

                        shadow let match = match.len > 90
                                 ? match.slice(start: 0, end: 80)
                                 : match;

                        println("  FISHY #include in " ~ path ~ " (" ~ reason ~ "):\n\n" ~ match.qBAD);

                        continue :NEXT_INCLUDE;
                    }

                    // Trim leading whitespace.
                    mut trimLeft = 0;
                    for (mut i = 0; i < match.len; i++)
                    {
                        if (match[i] > ' ') {
                            trimLeft = i;
                            break;
                        }
                    }

                    shadow let match = match.slice(start: trimLeft);

                    //
                    let lead = match.len > 2 && match[0];

                    let endChar = lead == '"' ? '"'
                                : lead == '<' ? '>'
                                : matchFail("no leading " ~ "\"".qCODE ~ " or " ~ "<".qCODE);

                    //
                    for (mut i = 1; i < match.len; i++)
                    {
                        let c = match[i];
                        if (c <= ' ')
                            matchFail("contains whitespace");

                        if (c == endChar)
                        {
                            shadow let include = match.slice(0, i + 1);
                            hash_all.hash(visitInclude(:include, start_fname: path));
                            continue :NEXT_INCLUDE;
                        }
                    }

                    matchFail("no trailing " ~ (endChar ~ "").qCODE);
                });

                return hash_all;
            }

            fn visitInclude(shadow include: string, shadow start_fname: string): u64
            {
                let f = include.slice(1, include.len - 1);

                if (include.starts(with: '"'))
                    return tryFollow(path::dirname(start_fname), f);

                // TODO FIX not all of our headers start with fu/,
                //  there's the par/ and dl/ nonsense,
                //   gotta move those back in.
                //
                if (include.starts(with: "<fu/"))
                    return tryFollow(fudir::FU_INCLUDE, f);

                if (include_dirs)
                {
                    // TODO FIX the include_dirs stuff doesn't make amazing sense,
                    //  we need to skope them somehow so we know
                    //   which headers need to be looked up where.
                }

                // TODO FIX we need to tell the system headers from
                //  whatever custom stuff people add to their include_dirs
                //
                // Maybe we want to introduce an extra #include convension,
                //  e.g. <<sys/time.h>>, to explicitly opt-out of content hashing.
                //
                // Alternatively, we'd have to locate the std headers on disk
                //  and just treat them like any other header.
                //   Here's one way to do it (see https://stackoverflow.com/a/33485647):
                //
                //  LC_ALL=C gcc -v -E -xc - < /dev/null 2>&1 |
                //  LC_ALL=C sed -ne '/starts here/,/End of/p'
                //
                // Basically, we'd ignore includes without an extension (std cpp),
                //  and check the ones with an extension & treat them as usual,
                //   or ignore when found / error when not found?
                //    What's the point i wonder.
                //
                // println("  CACHE TODO FIX Assuming " ~ include.qID ~ " is immutable, TODO resolve + hash + follow.");

                return 0;
            }

            return visitInclude(:include, :start_fname);
        }

        for (mut i = 0; i < modules.len; i++)
        {
            let module  = modules[i];
            let cpp     = i ? module.out.cpp
                            : fulib_cpp;
            if (cpp.src)
            {
                ref unit = units[unit_mapping[i]];
                unit.src ~= cpp.src;

                //
                ref includes_hash = unit.includes_hash;
                for (shadow mut i = 0; i < cpp.includes_headers.len; i++)
                {
                    let hash = getContentHash(
                        include:        cpp.includes_headers[i],
                        start_fname:    module.fname,
                        include_dirs:   cpp.include_dirs.keys_asc);

                    if (hash)
                        includes_hash.hash(hash);
                }
            }
        }
    }

    //
    let dir_wrk_cpp = dir_wrk ~ "cpp/";     fs::mkdir_p(dir_wrk_cpp);
    let dir_wrk_obj = dir_wrk ~ "obj/";     fs::mkdir_p(dir_wrk_obj);
    let dir_wrk_bin = dir_wrk ~ "bin/";     fs::mkdir_p(dir_wrk_bin);

    mut len_all: i32;
    mut hash_all: tea::TEA;
    for (mut i = 0; i < units.len; i++)
    {
        ref unit = units[i];

        let cpp = unit.src;
        if (!cpp)
            continue;

        mut hash: tea::TEA;

        // Cpp cache file -
        //  we only care about the immediate content hash here,
        //   no includes, no dependencies, no gcc flags, nothing.
        //
        hash.hash(cpp);

        unit.cpp_cache_file = hash.digest16 ~ "-" ~ cpp.len;

        // Obj cache file -
        //  we care about the contents of everything that's
        //   included by this source file:
        //
        hash.hash(unit.includes_hash);
        //
        //  and we care about compiler/linker flags:
        //
        hash.hash(GCChash);
        //
        // TODO FIX we should probably care about compiler version too,
        //  we could resolve it once on boot by gcc --version and hash its output.

        len_all += cpp.len;
        hash_all.hash(hash);

        unit.obj_cache_file = dir_wrk_obj ~ unit.cpp_cache_file ~ "-" ~ hash.digest16 ~ ".o";
        unit.cpp_cache_file = dir_wrk_cpp ~ unit.cpp_cache_file ~ ".cpp";
    }

    //
    mut code:   i32;
    mut stdout: string;

    fn ERR(mut cpp?: string)
    {
        if (onfail & OnFail_WriteRepro)
        {
            if (!cpp) for (mut i = units.len; i --> 0; )
            {
                let unit = units[i];
                if (unit.cpp_cache_file)
                    cpp ~= "#include \"" ~ unit.cpp_cache_file ~ "\"\n";
            }

            let fname = dir_wrk ~ "failing-testcase.cpp";
            println("  WRITE " ~ fname);
            atomic_write(:fname, cpp);
        }

        // Print exit code.
        if (stdout)
            stdout ~= "\n\n";

        stdout ~= "   EXIT code: " ~ code;

        //
        mut explain = "";
        if (onfail)
        {
            explain = "\n\n\tCOMPILER BUG or INCORRECT TESTCASE:\n\n";

            for (mut i = 1; i < modules.len; i++)
                explain ~= onfail & OnFail_PrintInput
                    ? modules[i].in.src
                    : modules[i].fname ~ "\n";

            if (onfail & OnFail_PrintOutput)
            {
                explain ~= "\n\n\tGenerated code:\n\n";
                for (mut i = 1; i < modules.len; i++)
                    explain ~= modules[i].out.cpp.src;
            }
        }

        return fail(stdout ~ explain);
    }

    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////
    ////  Total nonsense, tbd how we're gonna do this,
    ////   but I'd like us to have something that
    ////    just-works for the simplest things like your local glfw.
    ////
    mut HACK_linkFlags:         flat::Set(string);
    mut HACK_pkgConfig_libs:    flat::Set(string);

    mut HACK_include_dirs:      flat::Set(string);

    for (mut i = 0; i < modules.len; i++)
    {
        let module = modules[i];

        //
        let include_dirs = module.out.cpp.include_dirs;
        if (include_dirs)
        {
            let dir = path::dirname(module.fname);
            include_dirs.each: |incl|
                HACK_include_dirs.add(
                    incl.starts(with: '.')
                        ? path::join(dir, incl)
                        : incl);
        }

        //
        mut cflags = "";

        mut libs = module.out.cpp.link;
        for (shadow mut i = 0; i < libs.len; i++)
        {
            mut lib = libs[i];

            if (lib.starts(with: "-")) {
                HACK_linkFlags.add(lib);
            }
            else {
                cflags ~= lib;
                HACK_pkgConfig_libs.add(lib);
            }
        }

        if (cflags)
            units[unit_mapping[i]].HACK_pkgConfig_cflags =
                " $(pkg-config --cflags " ~ cflags ~ ")";
    }

    let INCLUDE = (flags_cc && " " ~ flags_cc.join(' ')) ~ " -I " ~ fudir ~ "include"
                ~ (HACK_include_dirs && " -I " ~ HACK_include_dirs.keys_asc.join(" -I "));

    let LIBS = (flags_ld && " " ~ flags_ld.join(' '))
             ~ (HACK_linkFlags      && " "                     ~ HACK_linkFlags.keys_asc.join(" "))
             ~ (HACK_pkgConfig_libs && " $(pkg-config --libs " ~ HACK_pkgConfig_libs.keys_asc.join(" ") ~ ")");
    ////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////

    //
    len_all += LIBS.len;
    hash_all.hash(LIBS);

    let F_exe = dir_wrk_bin ~ hash_all.digest16 ~ "-" ~ len_all;

    //
    let old_size = file::size(F_exe);

    ////////////////////////////////////////////////
    // TEMP re-run tests without allocation stats //
    shadow let old_size = old_size != 4 && old_size;
    // TEMP re-run tests without allocation stats //
    ////////////////////////////////////////////////

    if (old_size < 1 && (bin || run))
    {
        struct BuildError {
            code: i32;
            cpp: string;
            stdout: string;
        };

        fn buildUnit(unit: TranslationUnit): BuildError
        {
            let F_cpp = unit.cpp_cache_file;
            let F_obj = unit.obj_cache_file;
            if (!F_cpp || !F_obj)
                return [];

            let F_tmp = tmpfile(F_obj);

            fn CACHE_objFileAvailable()
                file::size(F_obj) > 0;

            if (CACHE_objFileAvailable() && !nocache)
                return [];

            let cpp = unit.src;
            atomic_write(fname: F_cpp, cpp);

            println("  BUILD ", unit.human, " ", F_cpp);

            let t0 = now::hr();

            ///////////////////////////////////////////////////////////////////
            shadow let INCLUDE = INCLUDE ~ unit.HACK_pkgConfig_cflags;
            ///////////////////////////////////////////////////////////////////

            ////////////////////////////////////////////////////////////////////////////////////////////////
            shadow let INCLUDE = INCLUDE ~ (unit.iquote && " -iquote " ~ unit.iquote);
            ////////////////////////////////////////////////////////////////////////////////////////////////

            let CMD = GCC_CMD ~ "-c" ~ INCLUDE ~ " -o " ~ F_tmp ~ " " ~ F_cpp;

            // println("      > ", CMD);
            shadow mut stdout: string;

            shadow let code = exec(CMD, :stdout)
                           || file::rename(F_tmp, F_obj);

            if (code)
            {
                if (CACHE_objFileAvailable())
                {
                    // We can race with a parallel build here,
                    //  so long as the obj is now present in its final location
                    //   we're fine to go forward.
                    //
                    println("RACE OK ", unit.human);
                    return [];
                }

                return BuildError(:code, :cpp, :stdout);
            }

            let t1 = now::hr();
            println("     OK ", unit.human, " ", t1 - t0, "s");
            return [];
        }

        // Build.
        let buildErrors = units.par::map(fn buildUnit);

        for (mut i = 0; i < buildErrors.len; i++)
        {
            let err = buildErrors[i];
            if ((code = err.code))
            {
                stdout = err.stdout;
                return ERR(err.cpp);
            }
        }

        // Link.
        let F_tmp = tmpfile(F_exe);

        mut cmd = GCC_CMD ~ "-o " ~ F_tmp;

        if (shared)
        {
            cmd ~= " -shared";

            // Linker -soname
            let soname = path::filename(bin);
            if (process::APPLE)
                cmd ~= " -Wl,-install_name," ~ soname;
            else
                cmd ~= " -Wl,-soname," ~ soname;
        }

        for (mut i = 0; i < units.len; i++)
        {
            let unit = units[i];
            if (unit.obj_cache_file)
                cmd ~= " " ~ unit.obj_cache_file;
        }

        //
        {
            println("   LINK ", F_exe, LIBS);

            let t0 = now::hr();

            let CMD = cmd ~ LIBS;

            // println("      > ", CMD);

            code = exec(CMD, :stdout)
                || file::chmod(F_tmp, file::RWX_RX_RX)
                || file::rename(F_tmp, F_exe);

            if (code)
            {
                println("   FAIL " ~ CMD ~ " EXIT=" ~ code ~ "\n" ~ stdout);
                return ERR;
            }

            let t1 = now::hr();
            println("     OK ", t1 - t0, "s");
        }

        if (code) return ERR;
    }

    //
    mut output: test_output::TestOutput;

    if (run)
    {
        // TODO FIX This needs to get out of here,
        //  but brief this is the compiler test suite runner,
        //   includes caching for test results so we don't have to
        //    constantly rerun them.
        //
        let OPTI_StatusCode = true;

        //
        fn READ_cachedTestOutput()
        {
            output  = test_output::parse(file::read(F_exe));
            code    = output.code;
        }

        fn WRITE_cachedTestOutput()
        {
            let out = test_output::serialize(output);
            out.len == 20 || fail("TestOutput.len != 20");
            atomic_write(fname: F_exe, out);
        }

        //
        if (OPTI_StatusCode
            && old_size.test_output::looks_legit)
        {
            READ_cachedTestOutput();
        }
        else
        {
            println("    RUN " F_exe);

            let t0 = now::hr();
            {
                shadow mut stdout: string;
                code    = exec(F_exe, :stdout);
                output  = test_output::from(:stdout, :code);
            }
            let t1 = now::hr();

            println("     OK ", t1 - t0, "s");

            //
            if (OPTI_StatusCode)
            {
                // However, when tests run in parallel this can totally brick itself -
                //  if for some reason we already did this and tried to run the 4-byte exe,
                //   it obviously breaks and here we'd persist the broken result forever.
                //
                let new_size = file::size(F_exe);
                if (new_size.test_output::looks_legit)
                {
                    // We can notice the exe has shrunk to 4 bytes though,
                    //  and discard the result of our run with the one
                    //   that was just cached by a parallel run.
                    //
                    READ_cachedTestOutput();
                }
                else
                {
                    // Don't cache spurious failure codes.
                    //
                    if (code != 32512 && code != 35584)
                        WRITE_cachedTestOutput();
                }
            }
        }
    }

    if (code) return ERR;

    // .cpp file output.
    if (dir_cpp && dir_src)
    {
        fs::mkdir_p(dir_cpp);

        mut cpp_files: string[];

        for (mut i = 1; i < units.len; i++)
        {
            let unit            = units[i];

            // TODO NEXT BOOTSTRAP failcase exits + fixed
            // TODO let data    = unit.src; + replace unit.src below with data

            let fname           = unit.src && unit.src_output_file;
            shadow let fname    = fname && update_file(
                :fname, data: unit.src,
                :dir_src, dir_out: dir_cpp);

            cpp_files.push(fname);
        }

        // TODO FIX
        let cmake       = false;
        let CMakeLists  = cmake && path::join(path::dirname(unity), "CMakeLists.txt");

        if (unity || CMakeLists)
        {
            // .unity.cpp
            if (unity)
            {
                mut data = "#ifdef fu_UNITY_FULIB\n"
                         ~ "#include <fu/_fulib.cpp>\n"
                         ~ "#endif\n\n";

                for (mut i = 0; i < cpp_files.len; i++)
                {
                    let incl = cpp_files[i];
                    if (incl)
                        data ~= "#include \"" ~ path::relative(unity, incl) ~ "\"\n";
                }

                update_file(
                    fname: unity ~ ".unity.cpp", :data,
                    :dir_src, dir_out: dir_cpp);
            }

            // CMakeLists.txt
            if (CMakeLists)
            {
                mut data = "cmake_minimum_required(VERSION 3.6)\n\n";

                mut inputs:  string[];
                mut outputs: string[];

                mut main: string;
                mut includes: string;

                for (mut i = 1; i < modules.len; i++)
                {
                    let module = modules[i];
                    let input = path::relative(CMakeLists, module.fname);
                    if (module.compile_index == 1)
                        main = input;

                    inputs.push(input);

                    // Check for custom cmake files.
                    let custom = module.fname ~ ".cmake";
                    if (file::size(custom) > 0)
                        includes ~= "include(" ~ path::relative(CMakeLists, custom) ~ ")\n";
                }

                for (mut i = 0; i < cpp_files.len; i++)
                {
                    let cpp_file = cpp_files[i];
                    if (cpp_file)
                        outputs.push("${CMAKE_CURRENT_SOURCE_DIR}/" ~ path::relative(CMakeLists, cpp_file));
                }

                let libname = path::noext(path::filename(main));

                data ~= "set(FU_TARGET " ~ libname ~ ")\n\n";

                data ~= "set(FU_MAIN " ~ main ~ ")\n\n";
                data ~= "set(FU_INPUTS\n    " ~ inputs.join("\n    ") ~ ")\n\n";

                if (unity)
                    data ~= "set(FU_OUTPUTS\n    " ~ "${CMAKE_CURRENT_SOURCE_DIR}/" ~ path::relative(CMakeLists, unity) ~ ".unity.cpp)\n\n";
                else
                    data ~= "set(FU_OUTPUTS\n    " ~ outputs.join("\n    ") ~ ")\n\n";

                data ~= "add_custom_command(\n"
                      ~ "    OUTPUT ${FU_OUTPUTS}\n"
                      ~ "    COMMAND $ENV{HOME}/fu/bin/fu\n"
                      ~ "    ARGS -c ${FU_MAIN}\n"
                      ~ "    DEPENDS ${FU_INPUTS}\n"
                      ~ "    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n"
                      ~ "    VERBATIM)\n\n";

                data ~= "add_library(${FU_TARGET} ${FU_OUTPUTS})\n\n";

                data ~= "add_library(fulib SHARED $ENV{HOME}/fu/include/fu/_fulib.cpp)\n"
                      ~ "target_include_directories(fulib PUBLIC $ENV{HOME}/fu/include/)\n"
                      ~ "target_link_libraries(${FU_TARGET} PUBLIC fulib)\n\n";

                if (includes)
                    data ~= includes ~ "\n";

                update_file(
                    fname: CMakeLists, :data,
                    :dir_src, dir_out: dir_cpp);
            }
        }
    }

    // output binary.
    if (bin)
    {
        fs::mkdir_p( path::dirname(bin) );

        code = file::rename(F_exe, bin);
    }

    if (code) return ERR;

    //
    return output;
}
