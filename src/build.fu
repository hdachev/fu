import helpers;
import context;
import scope;

fn ensure_local_fname(fname: string, dir_src: string): string
{
    if (fname.starts(with: dir_src))
        return fname;

    let foreign = dir_src ~ ".foreign/";
    fs::mkdir_p(foreign);

    let rel = path_relative(from: dir_src, to: fname)
        .replace(all: "../", with: "up__")
        .replace(all:   "/", with:   "__");

    return foreign ~ rel;
}

fn update_file(
    fname   !: string,
    data    !: string,
    dir_src !: string,
    dir_out !: string,
    nowrite !: bool)
{
    shadow let fname = ensure_local_fname(:fname, :dir_src);
        fname.starts(with: dir_src) || throw("ensure_local_fname broken");

    shadow let fname = dir_out ~ fname.slice(dir_src.len);
    if (file::read(fname) != data)
    {
        if (nowrite)
            throw("NOWRITE: About to write `" ~ fname ~ "`:\n\n" ~ data ~ "\n");

        let err = file::write(fname, data);
        if (err)
            throw("Failed to write `" ~ fname ~ "`, error: #" ~ err);

        println("  WROTE " ~ fname);
    }

    return fname;
}

fn getLinkOrder(modules: Module[]): i32[]
{
    mut link_order: i32[] = [ 0 ];

    fn visit(module: Module): void
    {
        let link_id = module.modid;
        if (link_order.has(link_id))
            return;

        let fuzimports = module.in.parse.fuzimports;
        for (mut i = 0; i < fuzimports.len; i++)
        {
            let fname = resolveFile_x(fuzimports[i]);
            for (shadow mut i = 1; i < modules.len; i++)
            {
                let m = modules[i];
                if (m.fname == fname)
                {
                    visit(m);
                    break;
                }
            }
        }

        link_order.has(link_id) && throw("link order broken");
        link_order.push(link_id);
    }

    for (mut i = 1; i < modules.len; i++)
        visit(modules[i]);

    return link_order;
}


//

pub fn build(
    implicit ctx: Context,
    run: bool,

    mut dir_wrk !: string,
        fulib   !: string,

    mut bin     ! = "",
    mut dir_obj ! = "",
    mut dir_src ! = "",
    mut dir_cpp ! = "",
        unity   ! = "",
        scheme  ! = "",

    nowrite?!: bool): void
{
    // Where we do our dirtywork.
    if (dir_wrk.if_last != '/')
    {
        dir_wrk || throw ("No workspace directory provided.");
        dir_wrk ~= '/';
    }

    //
    if (dir_obj && dir_obj.if_last != '/') dir_obj ~= '/';
    if (dir_src && dir_src.if_last != '/') dir_src ~= '/';
    if (dir_cpp && dir_cpp.if_last != '/') dir_cpp ~= '/';

    // Optimization level.
    mut O_lvl   = scheme != "debug"
                ? "-O3 -DNDEBUG -fno-math-errno "
                : "-Og "
                ;

    // Debug symbols.
    if (scheme == "debug" || scheme == "reldeb")
        O_lvl ~= "-g ";

    if (scheme == "retail")
        O_lvl ~= "-Dfu_RETAIL ";

    let INCLUDE = "-I ~/fu/include ";

    let GCChash = "g++ -std=c++1z " ~ O_lvl;

    // Not considering warnings when hashing files.
    let GCC_CMD = GCChash
                ~ "-pedantic-errors -Wall -Wextra -Werror " // opt-in
                ;

    //
    mut Fs: string[];
    mut len_all: i32;

    let fulib_cpp = file::read(fulib);

    for (mut i = 0; i < ctx.modules.len; i++)
    {
        let module  = ctx.modules[i];
        let cpp     = i ? module.out.cpp
                        : fulib_cpp;

        let F       = cpp &&    dir_wrk ~ "o-" ~ tea::hash16(GCChash ~ cpp)
                                        ~  "-" ~ cpp.len;

        Fs.push(F);
        len_all += cpp.len;
    }

    //
    fs::mkdir_p(dir_wrk);

    let F_exe = dir_wrk ~ "b-" ~ tea::hash16(Fs.join("/"))
                        ~  "-" ~ len_all ~ "-" ~ Fs.len;

    //
    mut code:   i32;
    mut stdout: string;

    fn ERR(mut cpp: string = "")
    {
        if (!cpp)
            for (mut i = Fs.len; i --> 0; )
                if (Fs[i])
                    cpp ~= "#include \"" ~ Fs[i] ~ ".cpp\"\n";

        let fname = dir_wrk ~ "failing-testcase.cpp";
        println("  WRITE " ~ fname);
        file::write(fname, cpp);

        //
        if (!stdout)
            stdout = "[ EXIT CODE " ~ code ~ " ]";

        return throw("Smth broke: " ~ stdout);
    }

    //
    let link_order = getLinkOrder(ctx.modules);
    let exe_size = file::size(F_exe);
    if (exe_size < 1 && (bin || run))
    {
        // Build.
        for (mut i = 0; i < Fs.len; i++)
        {
            let F = Fs[i];
            if (!F)
                continue;

            let F_cpp = F ~ ".cpp";
            let F_tmp = F ~ ".o.tmp";
            let F_obj = F ~ ".o";

            if (file::size(F_obj) < 1)
            {
                // Prelude @ 0.
                let human = i
                    ? ctx.modules[i].fname.path_filename
                    : "fulib runtime";

                let cpp = i ? ctx.modules[i].out.cpp
                            : fulib_cpp;

                if (nowrite)
                    throw("NOWRITE: About to write `" ~ F_cpp ~ "`:\n\n" ~ cpp ~ "\n");
                else
                    file::write(F_cpp, cpp);

                println("  BUILD ", human, " ", F_cpp);

                let t0 = now::hr();

                code = shell::exec(GCC_CMD ~ INCLUDE ~ "-c -o " ~ F_tmp ~ " " ~ F_cpp ~ " 2>&1", stdout)
                    || shell::exec("mv " ~ F_tmp ~ " " ~ F_obj ~ " 2>&1", stdout);

                if (code) return ERR(cpp);

                let t1 = now::hr();
                println("     OK ", t1 - t0, "s");
            }
        }

        // Link.
        let F_tmp = F_exe ~ ".tmp";

        mut cmd = GCC_CMD ~ "-o " ~ F_tmp ~ " ";
        for (mut i = 0; i < link_order.len; i++)
        {
            let F = Fs[link_order[i]];
            if (F)
                cmd ~= F ~ ".o ";
        }

        {
            println("   LINK ", F_exe);
            let t0 = now::hr();

            code = shell::exec(cmd ~ " 2>&1", stdout)
                || shell::exec("chmod 755 " ~ F_tmp ~ " 2>&1", stdout)
                || shell::exec("mv " ~ F_tmp ~ " " ~ F_exe ~ " 2>&1", stdout);

            if (code)
            {
                println("   FAIL " ~ Fs.join("\n        " ~ "\n"));
                return ERR;
            }

            let t1 = now::hr();
            println("     OK ", t1 - t0, "s");
        }

        // Delete single object file.
        if (Fs.len == 2 && Fs[1])
            code = shell::exec("rm " ~ Fs[1] ~ ".o 2>&1", stdout);

        if (code) return ERR;
    }

    //
    if (run)
    {
        // TODO FIX: this is a small testsuite runtime opti
        if (exe_size == 4)
        {
            code = file::read(F_exe).view(i32).only;
        }
        else
        {
            code = shell::exec(F_exe, stdout);

            // TODO FIX ////////////////////////////
            let pure = true; ///////////////////////
            ////////////////////////////////////////

            if (pure)
                file::write(F_exe, [ code ].view(byte));
        }
    }

    if (code) return ERR;

    // .cpp file output.
    if (dir_cpp && dir_src)
    {
        fs::mkdir_p(dir_cpp);

        mut cpp_files: string[];

        for (mut i = 0; i < ctx.modules.len; i++)
        {
            let module  = ctx.modules[i];
            let data    = i && module.out.cpp;

            let fname           = data && module.fname ~ ".cpp";
            shadow let fname    = fname && update_file(
                :fname, :data,
                :dir_src, dir_out: dir_cpp, :nowrite);

            cpp_files.push(fname);
        }

        // TODO FIX
        let CMakeLists = unity && path_join(path_dirname(unity), "CMakeLists.txt");

        if (unity || CMakeLists)
        {
            // .unity.cpp
            if (unity)
            {
                mut data = "#pragma once\n\n";

                data ~= "#ifdef fu_UNITY_FULIB\n"
                      ~ "#include <fu/_fulib.cpp>\n"
                      ~ "#endif\n\n";

                link_order.len == cpp_files.len || throw("lo.len != cf.len");
                for (mut i = 0; i < link_order.len; i++)
                {
                    let incl = cpp_files[link_order[i]];
                    if (incl)
                        data ~= "#include \"" ~ path_relative(unity, incl) ~ "\"\n";
                }

                update_file(
                    fname: unity ~ ".unity.cpp", :data,
                    :dir_src, dir_out: dir_cpp, :nowrite);
            }

            // CMakeLists.txt
            if (CMakeLists)
            {
                mut data = "cmake_minimum_required(VERSION 3.6)\n\n";

                mut inputs:  string[];
                mut outputs: string[];

                link_order.len == cpp_files.len || throw("lo.len != cf.len (2)");

                mut main: string;
                mut includes: string;

                for (mut i = 1; i < link_order.len; i++)
                {
                    let moduleIdx = link_order[i];
                    let module = ctx.modules[moduleIdx];

                    let input = path_relative(CMakeLists, module.fname);
                    if (moduleIdx == 1)
                        main = input;

                    inputs.push(input);

                    // Check for custom cmake files.
                    let custom = module.fname ~ ".cmake";
                    if (file::size(custom) > 0)
                        includes ~= "include(" ~ path_relative(CMakeLists, custom) ~ ")\n";

                    let cpp_file = cpp_files[moduleIdx];
                    if (cpp_file)
                        outputs.push("${CMAKE_CURRENT_SOURCE_DIR}/" ~ path_relative(CMakeLists, cpp_file));
                }

                let libname = path_noext(path_filename(main));

                data ~= "set(FU_TARGET " ~ libname ~ ")\n\n";

                data ~= "set(FU_MAIN " ~ main ~ ")\n\n";
                data ~= "set(FU_INPUTS\n    " ~ inputs.join("\n    ") ~ ")\n\n";

                if (unity)
                    data ~= "set(FU_OUTPUTS\n    " ~ "${CMAKE_CURRENT_SOURCE_DIR}/" ~ path_relative(CMakeLists, unity) ~ ".unity.cpp)\n\n";
                else
                    data ~= "set(FU_OUTPUTS\n    " ~ outputs.join("\n    ") ~ ")\n\n";

                data ~= "add_custom_command(\n"
                      ~ "    OUTPUT ${FU_OUTPUTS}\n"
                      ~ "    COMMAND $ENV{HOME}/fu/bin/fu\n"
                      ~ "    ARGS -c ${FU_MAIN}\n"
                      ~ "    DEPENDS ${FU_INPUTS}\n"
                      ~ "    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n"
                      ~ "    VERBATIM)\n\n";

                data ~= "add_library(${FU_TARGET} ${FU_OUTPUTS})\n\n";

                data ~= "add_library(fulib SHARED $ENV{HOME}/fu/include/fu/_fulib.cpp)\n"
                      ~ "target_include_directories(fulib PUBLIC $ENV{HOME}/fu/include/)\n"
                      ~ "target_link_libraries(${FU_TARGET} PUBLIC fulib)\n\n";

                if (includes)
                    data ~= includes ~ "\n";

                update_file(
                    fname: CMakeLists, :data,
                    :dir_src, dir_out: dir_cpp, :nowrite);
            }
        }
    }

    // output binary.
    if (bin)
    {
        fs::mkdir_p( path_dirname(bin) );

        code = shell::exec("mv " ~ F_exe ~ " " ~ bin ~ " 2>&1", stdout);
    }

    if (code) return ERR;
}
