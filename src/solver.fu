import helpers;
import parser;
import scope;
import context;
import types;
import lifetimes;

let WARN_ON_IMPLICIT_COPY = false;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub fn solve(
    implicit ctx: Context,
    implicit module: &mut Module,
    parse: Node): SolverOutput
{
    mut _here:          TokenIdx;
    mut _scope:         Scope;

    mut _root_scope:    ScopeMemo;
    mut _return_idx:    ScopeMemo;
    mut _scope_skip:    ScopeSkip;
    mut _current_fn:    SolvedNode;


    //

    let t_string = createArray(t_byte);


    //

    fn _Scope_import__forceCopy(modid: i32): void
    {
        _scope.items ~= ctx.modules[modid].out.solve.scope.items;
    }

    fn Scope_import(modid: i32): void
    {
        if (_scope.imports.has(modid)) return;

        modid || fail("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
    }

    fn GET(
        implicit module: Module,
        implicit ctx: Context,
        target: Target): Overload
    {
        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }


    //

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let fname = _here._fname;
        let l0 = here.line;
        let c0 = here.col;

        let addr = "@" ~ l0 ~ ":" ~ c0;

        return throw(fname ~ " " ~ addr ~ ":\n\t" ~ reason);
    }


    //

    fn Lifetime_next(): Lifetime
        Lifetime_fromScopeIdx( _scope.items.len + 1 );

    fn Binding(id: string, type: Type, flags!: i32, kind = "var")
    {
        return Scope_add(
            _scope, :kind,
            :id || fail(), :type || fail(), :flags);
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope, "field",
            :id || fail(), fieldType || fail(),
            1, 1, [ Argument(name: "this", type: structType) ],
            flags: F_PUB);
    }

    fn TemplateDecl(node: Node)
    {
        let id = node.value;

        node.kind == "fn" || fail("TODO TemplateDecl non-fn");

        // TODO FIX What is this nonsense.
        //  This is wrong on so many levels.
        let max = node.items.len + FN_ARGS_BACK;
        mut min = 0;
        for (mut i = 0; i < max; i++)
            if (!node.items[i].items[LET_INIT])
                min++;

        //
        let template = Template(node, imports: _scope.imports);

        mut args: Argument[];
        if (node.kind == "fn")
        {
            let items = node.items;
            let numArgs = items.len + FN_ARGS_BACK;
            for (mut i = 0; i < numArgs; i++)
            {
                let arg = items[i] || fail();
                arg.kind == "let" || fail();
                let name = arg.value || fail();
                args.push(Argument(:name));
            }
        }

        return Scope_add(
            _scope,
            "template", :id, Type,
            :min, :max, :args, :template,
            :node.flags);
    }

    fn FnDecl(kind: string, id: string, node: &mut SolvedNode, native: Node): Target
    {
        let items = node.items;
        let rnode = items[items.len + FN_RET_BACK];
        let ret   = rnode && rnode.type || fail();

        mut min         = 0;
        let max         = items.len + FN_RET_BACK;
        let argNodes    = items.slice(0, max);

        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let node = argNodes[i];
            node.kind == "let" || fail();

            let isImplicit = !!(node.flags & F_IMPLICIT);
            let arg = Argument(
                type:       node.type  || fail(),
                name:       node.value || fail(),
                default:    !isImplicit && node.items[LET_INIT],
                flags:      node.flags);

            if (!arg.default && !isImplicit)
                min++;

            args.push(arg);
        }

        let NO_IMPORTS: i32[];
        let template = Template(node: native, imports: NO_IMPORTS);

        let overload = Scope_add(
            _scope,
            :kind, :id, ret,
            :min, :max, :args,
            :template,
            :node.flags);

        node.target = overload;

        return overload;
    }

    fn DefCtor(id: string, type: Type, members: SolvedNode[]): Target
    {
        let max = members.len;
        mut min = 0;
        mut args: Argument[];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            let arg = Argument(
                name:       member.value || fail(),
                type:       member.type  || fail(),
                default:    member.items[LET_INIT],
                flags:      member.flags & F_MUSTNAME);

            if (!arg.default)
                min++;

            args.push(arg);
        }

        return Scope_add(
            _scope,
            "defctor", :id, :type,
            :min, :max, :args,
            flags: F_PUB);
    }

    fn tryCreateDefinit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (type.quals & q_mutref)
            return SolvedNode();

        return createDefinit(type);
    }

    fn createDefinit(type: Type): SolvedNode
    {
        let token = _here || fail();

        if (type.quals & q_integral)
            return SolvedNode(
                kind: "int", :token, :type,
                value: "0");

        if (type.quals & q_floating_pt)
            return SolvedNode(
                kind: "real", :token, :type,
                value: "0");

        return SolvedNode(
            kind: "definit", :token, :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryCreateDefinit(type)
            || fail("Cannot definit: " ~ serializeType(type));
    }

    fn solveTypeAssert(node: Node): SolvedNode
    {
        let left   = node.items[0];
        let right  = node.items[1];

        // left -> right.
        let expect = evalTypeAnnot(right).type;
        let actual = solveNode(left, expect);

        checkAssignable(host: expect, actual.type,
            "Type assertion failed");

        return actual;
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = "p-unshift";
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut args = overload.args.slice(1);
        mut flags = 0;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != "var" &&
            via.kind != "global" &&
            via.kind != "arg" &&
            via.kind != "ref")
        {
            kind = "p-wrap";
            min++;
            max++;

            flags |= F_PUB;

            mut arg = Argument(
                type: via.args[0].type,
                name: "using");

            args.unshift(arg);
        }

        return Scope_add(
            _scope,
            :kind, :id, :overload.type, :flags,
            :min, :max, :args,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();

        fn visit(item: ScopeItem)
        {
            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                return;

            let overloadIdx = item.target;
            let overload = GET(overloadIdx);

            // Needs at least one argument.
            if (overload.min < 1)
                return;

            // TODO using + templates, the fuck do we do?
            if (overload.isTemplate)
                return;

            // Skip over defctors -
            //  we really only want this for fields & properties,
            //   but there's no way to tell a property from a fn,
            //    this at least is easy to disambiguate.
            if (overload.kind == "defctor")
                return;

            // See if we fit.
            let expect = overload.args[0] || fail();
            if (!isAssignableAsArgument(expect.type, actual))
                return;

            // Enforce no-collide.
            if (overload.min < 2)
            {
                // Scan through -
                //  no other arity-0 entries are allowable.
                for (mut i = 0; i < _scope.items.len; i++)
                {
                    if (i == _scope_skip.start.items_len)
                    {
                        i = _scope_skip.end.items_len;
                        if (i >= _scope.items.len)
                            break;
                    }

                    let o = _scope.items[i];
                    if (o.id == item.id)
                    {
                        let other = GET(o.target);
                        if (other.min < 1)
                            fail("`using` ambiguity: `" ~ item.id ~ "`.");
                    }
                }
            }

            //
            Partial(item.id, viaIdx, overloadIdx);
        }

        // Visit stuff currently in scope.
        for (mut i = 0; i < _scope.items.len; i++)
            visit(_scope.items[i]);

        // Also bring in stuff from the module of origin.
        let extra_modid = actual.modid;
        if (!_scope.imports.has(extra_modid))
        {
            let items = ctx.modules[extra_modid].out.solve.scope.items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }
    }


    //

    fn getNamedArgReorder(
        result: &mut i32[],
        names: string[],
        host_args: Argument[]): bool
    {
        result.clear();

        //
        mut used   = 0;
        mut offset = 0;
        for (mut i = 0; i < host_args.len; i++)
        {
            mut idx = names.find(host_args[i].name);
            if (idx < 0)
            {
                for (mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                used++;
            }

            result.push(idx);
        }

        // Fail if some name ended up unused.
        //  TODO FIX THIS MESS
        if (used != names.len)
        {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used != names.len)
                return false;
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        // Return nothing if not needed.
        for (mut i = 0; i < result.len; i++)
            if (result[i] != i)
                return true;

        result.clear();
        return true;
    }

    fn tryMatch__mutargs(
        scope: Scope,
        id: string, args: &mut SolvedNode[],
        flags: i32 = 0, retType: Type = [],
        target: Target = []): Target
    {
        mut matchIdx: Target;

        let arity = args.len;

        // Prep labelled args for remap.
        mut names: string[];
        if (flags & F_NAMED_ARGS)
        {
            mut some = false;

            for (mut i = 0; i < arity; i++)
            {
                let arg = args[i];
                names.push(arg.kind == "label"
                    ? (some = true, arg.value) || fail()
                    : "");
            }

            some || fail();
        }

        //
        let extra_modid = flags & F_ACCESS && args.if_first.type.modid;
        let extra_items = extra_modid
                        && !_scope.imports.has(extra_modid)
                        && ctx.modules[extra_modid].out.solve.scope.items;

        //
        mut reorder: i32[];
        mut args_mangled: string;

        //
        mut scope_iterator: i32;
        mut overloadIdx: Target;

        :NEXT
        while (overloadIdx =
            scope.search(id, scope_iterator,
                scope_skip: _scope_skip, :target,
                :extra_items))
        {
            mut overload = GET(overloadIdx);

            :TEST_AGAIN
            while (true)
            {
                if (overload.min > arity || overload.max < arity)
                    continue :NEXT;

                // Match by return.
                if (retType && !isAssignable(retType, overload.type || fail()))
                    continue :NEXT;

                // Match by argnames.
                if (names && !getNamedArgReorder(reorder, names, overload.args))
                    continue :NEXT;

                // Specialize.
                if (overload.isTemplate)
                {
                    if (reorder)
                        fail("TODO handle argument reorder in template specialization.");

                    let o = GET(overloadIdx);
                    let specIdx = trySpecialize(
                        overloadIdx, :o.template, :args,
                        :args_mangled ||= mangleArguments(args));

                    if (!specIdx)
                        continue :NEXT;

                    overloadIdx = specIdx;
                    overload = GET(specIdx);

                    // Repeat arity checks and such.
                    continue :TEST_AGAIN;
                }

                // Done here.
                break :TEST_AGAIN;
            }

            if (args)
            {
                // Type check args.
                let host_args = overload.args;

                let N = reorder ? reorder.len
                                : args.len;

                /////////////////
                // Literal fixup.
                let undo_literal_fixup = args;
                //        /LITFIX
                /////////////////

                for (mut i = 0; i < N; i++)
                {
                    let host_arg = host_args[i];

                    let callsiteIndex = reorder ? reorder[i]
                                                : i;
                    if (callsiteIndex < 0)
                    {
                        // Argument may not be defaulted -
                        //  we might be supplying defaults via names
                        //   before we've actually exhausted
                        //    all the non-defaulted stuff.
                        if (!host_arg.default && !(host_arg.flags & F_IMPLICIT))
                            continue :NEXT;

                        continue;
                    }

                    // Explicit argname requirements.
                    else if (host_arg.flags & F_MUSTNAME)
                    {
                        if (names.len <= callsiteIndex || !names[callsiteIndex])
                            continue :NEXT;
                    }

                    let expect = host_arg.type;
                    let actual = args[callsiteIndex].type;

                    mut ok = isAssignableAsArgument(expect, actual);

                    /////////////////
                    // Literal fixup.
                    if (!ok && considerRetyping(expect, actual))
                    {
                        let arg: &mut SolvedNode = args[callsiteIndex];

                        if (arg.kind == "label")
                        {
                            // SEGV fix -
                            //  how do we deal with this in general?
                            //   might as well discontinue copy assignment
                            //    in favor of cpy->mov.
                            let inner = arg.items.only;
                            arg = inner;
                        }

                        let retype  = tryRetyping(arg, expect);
                            ok      = isAssignableAsArgument(expect, retype);

                        if (ok)
                            arg.type = retype;
                    }
                    //        /LITFIX
                    /////////////////

                    if (!ok)
                    {
                        args = undo_literal_fixup;
                        continue :NEXT;
                    }
                }

                // Forbid ambiguity.
                if (matchIdx)
                    fail("Ambiguous callsite, matches multiple functions in scope: `" ~ id ~ "`.");

                // Do reorder.
                if (reorder)
                {
                    // TODO:
                    // I shouldn't need this pass, just swaps must do.
                    mut new_args: SolvedNode[];
                    new_args.resize(reorder.len);

                    for (mut i = 0; i < reorder.len; i++)
                    {
                        let idx = reorder[i];
                        if (idx >= 0)
                            new_args[i] = args[idx];
                    }

                    args = new_args;
                }
            }

            // Done!
            matchIdx = overloadIdx;

            // Arity 0 auto-shadows.
            if (!arity)
                break;
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let host_args = matched.args;
            if (host_args.len > args.len)
                args.resize(host_args.len);

            // Defaults & implicit argument injection.
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default || bindImplicitArg(
                        :host_arg.name,
                        :host_arg.type);
                }
            }
        }

        return matchIdx;
    }


    //

    fn considerRetyping(expect: Type, actual: Type): bool
    {
        return expect.quals & actual.quals & q_arithmetic != 0;
    }

    fn couldRetype(node: SolvedNode): bool
    {
        return node.kind == "int"
            || node.kind == "real";
    }

    fn tryRetyping(node: SolvedNode, expect: Type): Type
    {
        return node.kind == "int"  ? solveInt(node.value, expect)
             : node.kind == "real" ? solveNum(node.value, expect)
             : [];
    }


    //

    fn match__mutargs(
        scope: Scope,
        id: string, args: &mut SolvedNode[],
        flags: i32, target: Target): Target
    {
        let ret = scope.tryMatch__mutargs(:id, :args, :flags, :target);
        if (ret)
            return ret;

        let debug = scope.tryMatch__mutargs(:id, :args, :flags, :target);
        if (debug)
            return debug;

        return scope.NICERR_mismatch(:id, :args);
    }

    fn NICERR_mismatch(
        scope: Scope,
        id: string, args: SolvedNode[]): never
    {
        // TODO instead of this -
        //  run tryMatch__mutargs again with an error output attached,
        //   this way we don't need the second pass for debugging,
        //    we can #bake alla jblow the if (explain) parts,
        //     and we can rid ourselves of Scope_lookup altogether.

        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = DEPREC_lookup(scope, id);

        mut min = 0x7fffffff.i32;
        mut max = 0;
        for (mut i = 0; i < overloads.len; i++)
        {
            let o = GET(overloads[i]);
            if (min > o.min) min = o.min;
            if (max < o.max) max = o.max;
        }

        fn expectedArgs(targets: Target[]): string
        {
            mut result = "";

            for (mut i = 0; i < targets.len; i++)
            {
                if (result)
                    result ~= "\n\t\t";
                else if (targets.len > 1)
                    result ~= ", available overloads:\n\t\t";
                else
                    result ~= ", expects: ";

                let overload = GET(targets[i]);

                result ~= overload.name ~ "(";

                for (mut i = 0; i < overload.args.len; i++)
                {
                    let arg = overload.args[i];
                    if (i)
                        result ~= ", ";

                    result ~=  arg.name
                            ~ (arg.flags & F_MUSTNAME ? "!" : "")
                            ~ (arg.default ? "?: " : ": ")
                            ~ (arg.type ? humanizeType(arg.type) : "$");
                }

                result ~= ")";
            }

            return result || ".";
        }

        fn actualArgs(args: SolvedNode[]): string
        {
            mut result = "\nActual: (";

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                if (i)
                    result ~= ",";

                result ~= "\n\t";
                if (arg.kind == "label")
                    result ~= arg.value ~ ": ";

                result ~= humanizeType(arg.type);
            }

            return result ~ ").";
        }

        return overloads
                ? args.len < min ? fail("`" ~ id ~ "` expects at least " ~ min ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : args.len > max ? fail("`" ~ id ~ "` expects at most " ~ max ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : fail("`" ~ id ~ "` bad args" ~ expectedArgs(overloads) ~ actualArgs(args))
             : fail("`" ~ id ~ "` is not defined in this scope.");
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node);
        if (k == "label")       return solveComma(node);
        if (k == "comma")       return solveComma(node);

        if (k == "let")         return solveLet(node, Lifetime_static);
        if (k == "call")        return solveCall(node);
        if (k == "arrlit")      return solveArrayLiteral(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "!")           return solveNot(node);
        if (k == "and")         return solveAnd(node, type);

        if (k == "return")      return solveReturn(node);
        if (k == "loop")        return solveBlock(node);
        if (k == "break")       return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);
        if (k == "empty")       return createEmpty();

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);

        if (k == "typeassert")  return solveTypeAssert(node);

        return fail("TODO: " ~ k);
    }

    fn isUnordered(kind: string)
    {
        return kind == "fn"
            || kind == "struct"
            || kind == "typedef";
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == "fn")          return uPrepFn(node);
        if (k == "struct")      return uPrepStruct(node);
        if (k == "typedef")     return solveTypedef(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == "fn")          return uSolveFn(node, prep);
        if (k == "struct")      return uSolveStruct(node, prep);
        if (k == "typedef")     return prep || fail();

        return fail("TODO: " ~ k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        return solved(node, t_void, solveNodes(node.items, t_void));
    }

    fn solveBlock(node: Node): SolvedNode
    {
        let scope0 = Scope_push(_scope);
        let out = solved(node, t_void, solveNodes(node.items, t_void));
        Scope_pop(_scope, scope0);
        return out;
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(v: string, type: Type): Type
    {
        let parse = intlit::Intlit(v);
        parse.error && fail(parse.error);

        if (type)
        {
            fn want(t: Type)
                type.canon == t.canon;

            if (!parse.unsigned)
            {
                if (want(t_f32) && parse.minsize_f <= 32) return t_f32;
                if (want(t_f64) && parse.minsize_f <= 64) return t_f64;

                if (want(t_i32) && parse.minsize_i <= 32) return t_i32;
                if (want(t_i64) && parse.minsize_i <= 64) return t_i64;
                if (want(t_i16) && parse.minsize_i <= 16) return t_i16;
                if (want(t_i8 ) && parse.minsize_i <= 8 ) return t_i8 ;
            }

            if (!parse.signed)
            {
                if (want(t_u32) && parse.minsize_u <= 32) return t_u32;
                if (want(t_u64) && parse.minsize_u <= 64) return t_u64;
                if (want(t_u16) && parse.minsize_u <= 16) return t_u16;
                if (want(t_u8 ) && parse.minsize_u <= 8 ) return t_u8 ;
            }
        }

        if (parse.unsigned)
        {
            if (parse.minsize_u <= 32) return t_u32;
            if (parse.minsize_u <= 64) return t_u64;
        }
        else
        {
            if (parse.minsize_i <= 32) return t_i32;
            if (parse.minsize_i <= 64) return t_i64;
        }

        return fail("Bad int literal.");
    }

    fn solveNum(v: string, type: Type): Type
    {
        // TODO `f` suffix
        if (v) {}

        fn want(t: Type) type.canon == t.canon;
        if (want(t_f32)) return t_f32;

        return t_f64;
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
        solved(node,
             solveInt(node.value, type));

    fn solveNum(node: Node, type: Type): SolvedNode
        solved(node,
             solveNum(node.value, type));


    //

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefinit(
                add_ref(t_string, Lifetime_static));

        return solved(node, t_string);
    }

    fn createEmpty(): SolvedNode
    {
        return SolvedNode(
            kind: "empty", type: t_void,
            token: (_here || fail()));
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }


    //

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(node, SolvedNode,
            solve: false, spec: false, caseIdx: -1);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(node, prep,
            solve: true, spec: false, caseIdx: -1);
    }

    fn __solveFn(solve!: bool, spec!: bool, n_fn: Node, prep: SolvedNode, caseIdx!: i32): SolvedNode
    {
        let id = n_fn.value || fail("TODO anonymous fns");

        // Template early exit.
        if (spec)
        {
            solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl   = TemplateDecl(n_fn);
            mut out     = solved(n_fn, t_void);
            out.target  = tDecl;
            return out;
        }

        // Prep reject.
        if (!solve && !(n_fn.flags & F_FULLY_TYPED))
            return SolvedNode();

        let inItems = n_fn.items;
        inItems.len >= FN_RET_BACK || fail();

        mut out = prep || solved(n_fn, t_void);

        out.items.resize(inItems.len);

        //
        if (_current_fn)
        {
            _current_fn.flags |= F_HAS_CLOSURE;
            out.flags |= F_CLOSURE;
        }

        //////////////////////////
        mut native = false;
        mut n_body: Node;

        {
            let return_idx0 = _return_idx;
            let scope0      = Scope_push(_scope);
            _return_idx     = scope0;

            let root_scope0 = _root_scope;
            if (!root_scope0)
                _root_scope = _return_idx;

            SWAP(_current_fn, out);
            let outItems: &mut SolvedNode[] = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == "let" || fail();

                let lifetime = Lifetime_fromArgIndex(i);

                // If spec and unless argument explicitly wants a value -
                if (spec && !(n_arg.flags & F_MUT)
                         && !(n_arg.items[LET_INIT]))
                {
                    // Specialize with actuals.
                    mut mut_arg = n_arg;
                    mut_arg.items[LET_TYPE] = createTypeParam(mut_arg.value);

                    // Emit value-taking specializations.
                    let type = typeParam_get(mut_arg.value);
                    if !(type.quals & q_ref)
                        mut_arg.flags |= F_MUT;

                    outItems[i] = solveLet(mut_arg, :lifetime);
                }
                else
                {
                    outItems[i] = solveLet(n_arg, :lifetime);
                }
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
                n_body  = inItems[inItems.len + FN_BODY_BACK] || fail();

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == "pattern" || fail();
                let branch = n_body.items[caseIdx] || fail();
                let items = branch.items;

                n_ret   = items[items.len + FN_RET_BACK]  || n_ret;
                n_body  = items[items.len + FN_BODY_BACK];
            }

            // Builtin?
            if (n_body.kind == "block" && n_body.items.len == 1)
            {
                let ret = n_body.items[0];
                if (ret.kind == "return" && ret.items.len == 1)
                {
                    let expr = ret.items[0];
                    if (expr.kind == "call" && expr.value == "__native")
                    {
                        native = true;

                        n_body = expr;
                    }
                }
            }

            // Return type annot.
            {
                let s_ret = n_ret
                    ? evalTypeAnnot(n_ret)
                    : SolvedNode();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_RET_BACK] = s_ret;
            }

            // Only if actually solving the fn, the fn body.
            if (solve && !native)
            {
                let s_body = solveNode(n_body);
                s_body || fail();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body;
            }

            //
            /////////////////////////////////////////////////////

            SWAP(_current_fn, out);

            Scope_pop(_scope, scope0);
            _return_idx = return_idx0;
            _root_scope = root_scope0;
        }
        //////////////////////////

        if (!prep)
        {
            mut kind = native ? "__native" : "fn";

            // TODO FIX currently we only hash template names.
            mut name = id;
            if (spec && !native)
            {
                let sig = mangleArguments(out.items[0, out.items.len + FN_BODY_BACK]) || fail();
                let hash = tea::hash62(sig, chars: 4);
                name ~= "_" ~ hash;
            }

            //
            FnDecl(:kind, id: name, out, native && n_body);
        }

        if (solve && !native)
            out.items[out.items.len + FN_BODY_BACK] || fail();

        return out;
    }


    //

    fn mangleArguments(args: [SolvedNode]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle ~= ",";

            mangle ~= serializeType((args[i] || fail()).type);
        }

        return mangle;
    }


    //

    fn trySpecialize(
        target: Target, template: Template, args: SolvedNode[],
        args_mangled: string)
            : Target
    {
        // TODO memoize the whole mangle.
        mut mangle = target.modid ~ "#" ~ target.index ~ " ";
            mangle ~= args_mangled;

        // TODO FIX THIS MESS -
        //  A. Not recursion capable: use the general prep-vs-solve approach here too.
        //  B. The multiple map taps here are because stuff
        //      moves around while doTrySpecialize does its work -
        //      if maps values didn"t move around we"d be good.
        let spec = module.out.specs[mangle] ||= SolvedNode;
        if (!spec)
        {
            let spec = doTrySpecialize(template, args, mangle);
            module.out.specs[mangle] = spec;
            return spec.target;
        }

        return spec.target;
    }

    fn doTrySpecialize(
        template: Template, args: SolvedNode[], mangle: &mut string)
            : SolvedNode
    {
        template.node.kind == "fn" || fail("TODO: non-fn templates");

        mut result = trySpecializeFn(:template, args, mangle);
        if (result)
        {
            let o = GET(result.target);
            if (o.min > args.len || o.max < args.len)
                result = SolvedNode;
        }

        if (!result)
            result.kind = "spec-fail";

        return result;
    }


    //

    fn trySpecializeFn(
        template: Template, mut args: SolvedNode[], mangle: &mut string)
            : SolvedNode
    {
        mut ok = true;
        mut typeParams0: Map(string, Type);

        ////////////////////////////////
        mut current_fn0: SolvedNode;

        SWAP(_current_fn, current_fn0);

        let scope0 = Scope_push(_scope);
        let scope_skip0 = _scope_skip;
        let root_scope0 = _root_scope;
        ////////////////////////////////

        //
        mut typeParams: Map(string, Type);

        //
        _scope_skip = _root_scope && ScopeSkip(
            start: _root_scope,
              end: scope0);

        _root_scope = scope0;

        for (mut i = 0; i < template.imports.len; i++)
            Scope_import(template.imports[i]);

        //
        let items   = template.node.items;
        let numArgs = items.len + FN_ARGS_BACK;

        /////////////////
        // Literal fixup.
        mut retypeIndices: i32[];
        mut remangle = false;

        // First off, solve type params.
        for (   mut pass_retype  = 0;
                    pass_retype == 0 || pass_retype == 1 && retypeIndices;
                    pass_retype++)
        {
        //        /LITFIX
        /////////////////

            for (mut i = 0; i < numArgs; i++)
            {
                if (pass_retype)
                {
                    // TODO fix, .try_shift instead.
                    if (!retypeIndices.has(i))
                        continue;
                }

                let inValue = args.len > i && args[i];
                mut inType  = inValue.type;

                let argNode = items[i] || fail();
                let annot   = argNode.items[LET_TYPE];

                /////////////////
                // Literal fixup.
                if (couldRetype(inValue))
                {
                    let paramType =
                        annot.kind == "typeparam"
                            ? typeParams[annot.value] ||= Type
                            : annot.kind == "call" && !annot.items
                                && Scope_lookupType(annot);

                    // Ignore literals if possible.
                    if (paramType)
                    {
                        let retype = tryRetyping(inValue, paramType);
                        if (retype && retype.canon != inType.canon)
                        {
                            inType   = args[i].type = retype;
                            remangle = true;
                        }
                    }

                    // Defer for second pass.
                    else if (!pass_retype)
                    {
                        retypeIndices.push(i);
                        continue;
                    }
                }
                //        /LITFIX
                /////////////////

                argNode.kind == "let"  || fail();

                if (inType)
                {
                    // All fnargs are referable.
                    inType.lifetime = Lifetime_fromArgIndex(i);

                    //
                    let argName = argNode.value || fail();

                    // Same pattern - grabs a mutref.
                    let argName_typeParam: &mut Type =
                        typeParams[argName] ||= Type;

                    argName_typeParam && fail(
                        "Type param name collision with argument: `" ~ argName ~ "`.")
                            = inType;

                    //
                    inType.quals |= q_ref;
                }

                // Type check.
                if (annot)
                {
                    let argOk = inType && trySolveTypeParams(
                        annot, inType, typeParams);

                    ok = ok && argOk;
                    if (!ok && !remangle)
                        break;
                }
            }
        }

        /////////////////
        // Literal fixup.
        if (remangle)
        {
            let start   = mangle.find(' ') + 1 || fail();
                mangle  = mangle.slice(0, start) ~ mangleArguments(args);
        }
        //        /LITFIX
        /////////////////

        // Match pattern arm here.
        mut caseIdx = -1;

        if (ok)
        {
            // Unpack type params in scope.
            {
                mut keys = typeParams.keys;
                for (mut i = 0; i < keys.len; i++)
                {
                    let key = keys[i];
                    Scope_Typedef(_scope, "$" ~ key, typeParams[key], flags: 0);
                }
            }

            //
            let pattern = items[items.len + FN_BODY_BACK] || fail();
            if (pattern.kind == "pattern")
            {
                let branches = pattern.items;
                for (mut i = 0; i < branches.len; i++)
                {
                    let branch = branches[i];
                    let items = (branch || fail()).items;
                    let cond = items[0] || fail();

                    if (evalTypePattern(cond))
                    {
                        caseIdx = i;
                        break;
                    }
                }

                // All branches mismatch?
                //  Can't return, faking RAII here.
                if (caseIdx < 0)
                    ok = false;
            }
        }

        let specialized = ok && (__solveFn(
            template.node, SolvedNode,
            solve: true, spec: true, :caseIdx) || fail(
                "__solveFn spec:true is not expected to fail."));

        ////////////////////////////////
        SWAP(_current_fn, current_fn0);

        Scope_pop(_scope, scope0);
        _scope_skip = scope_skip0;
        _root_scope = root_scope0;
        ////////////////////////////////

        return specialized;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(false, node, SolvedNode());
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(true, node, prep);
    }

    fn __solveStruct(solve: bool, node: Node, prep: SolvedNode): SolvedNode
    {
        mut out         = prep || solved(node, t_void);

        let id          = node.value || fail("TODO anonymous structs");
        mut structType  = initStruct(id, node.flags);

        // Add the arity-0 type entry.
        if (!prep)
            out.target = Scope_Typedef(_scope, id, structType, node.flags);

        if (!solve)
            return out;

        // Struct fields only.
        out.items = solveStructMembers(
            node.items, :structType);

        // Add a default constructor.
        {
            mut members: SolvedNode[];
            let items = out.items;

            mut fields: StructField[];

            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == "let" && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value        || fail(),
                            type: item.type.value   || fail()));
                }
            }

            //
            structType.quals |= finalizeStruct(structType.canon, fields);
            GET_mut(out.target).type.quals = structType.quals;

            // Link up the constructor.
            let ctor = DefCtor(id, structType, members);
            lookupStruct_mut(structType.canon).ctor = ctor;
        }

        return out;
    }

    fn solveStructMembers(members: Node[], structType: Type): SolvedNode[]
    {
        mut out: SolvedNode[];

        for (mut i = 0; i < members.len; i++)
        {
            let node = members[i];
            if (node.kind == "let")
                out.push(solveField(:node, :structType));
            else
                fail("TODO: " ~ node.kind);
        }

        return out;
    }


    //

    fn solveReturn(node: Node): SolvedNode
    {
        // Solving the stuff below might inject implicit args -
        //  which would shift the retidx back.
        fn retIdx()
            _current_fn.items.len + FN_RET_BACK;

        let prevType = _current_fn.items[retIdx].type;

        node.items.len <= 1 || fail();
        mut out = solved(node, t_void,
            solveNodes(node.items, prevType));

        let next: &mut SolvedNode =
            out.items   ? out.items[0]
                        : out;

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if (next.type.lifetime.killedBy(_return_idx.items_len) &&     //
            next.type.quals & q_ref)                        //
        {                                                   //
            let nrvo = next.kind == "call"                  //
                    && next.items.len == 0                  //
                    && next.target.GET.kind == "var";       //
                                                            //
            next = createMove(next, nrvo);                  //
        }                                                   //
        //////////////////////////////////////////////////////

        if (prevType)
            checkAssignable(host: prevType, next.type,
                "Non-assignable return types");
        else
            _current_fn.items[retIdx] = next || fail();

        if (out.items)
            maybeCopyOrMove(out.items[0],
                prevType || next.type);

        return out;
    }

    fn checkAssignable(
        host: Type, guest: Type, err: string,
        id?: string, sep?: string)
    {
        isAssignable(
            :host   || fail("Bad host type."),
            :guest  || fail("Bad guest type."))
                    || fail(err ~ (id && " `" ~ id ~ "`") ~ ": "
                                ~ host .humanizeType() ~ (sep || " <- ")
                                ~ guest.humanizeType());
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveBinding(node: Node, lifetime: Lifetime): SolvedNode
    {
        let n_annot     = node.items[LET_TYPE];
        let n_init      = node.items[LET_INIT];

        mut annot       = n_annot && evalTypeAnnot(n_annot);
        mut init        = n_init && solveNode(n_init, annot.type);

        annot.type || init.type || fail(
            "Variable declarations without type annotations must be initialized.");

        let t_let       = annot.type
                            ? node.flags & F_ARG && !(node.flags & F_MUT)
                              ? add_ref(annot.type, lifetime)
                              : annot.type
                        : init.type.quals & q_mutref || node.flags & F_MUT
                            ? clear_refs(init.type)
                            : node.flags & F_ARG && !(node.flags & F_MUT)
                              ? add_ref(init.type, lifetime)
                              : init.type;

        if (annot.type && init.type)
            checkAssignable(host: annot.type, init.type,
                "Type annotation does not match init expression",
                    node.value, "=");

        if (init)
            maybeCopyOrMove(init, t_let);

        //
        mut out = solved(node, t_let, [annot || init, init]);

        if !(_current_fn || node.flags & F_FIELD)
        {
            if (out.flags & F_MUT || out.type.quals & q_mutref)
                fail("Mutable statics are not currently allowed.");

            out.kind = "global";
        }

        return out;
    }

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);
        Scope_Typedef(_scope, node.value, annot.type, node.flags);
        return createEmpty();
    }

    fn solveLet(node: Node, mut lifetime: Lifetime): SolvedNode
    {
        mut out         = solveBinding(node, lifetime);
        let global      = out.kind == "global";

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if !(out.type.quals & q_ref)                        //
            lifetime = Lifetime_next();                     //
                                                            //
        //////////////////////////////////////////////////////

        let kind = global                   ? "global"
                 : node.flags & F_ARG       ? "arg"
                 : out.type.quals & q_ref   ? "ref"
                                            : "var";

        let id = out.value;
        let overload = out.target = Binding(
            :id, :kind, :node.flags,

            node.flags & F_MUT
                ? add_mutref(out.type, lifetime)
                : add_ref(out.type, lifetime));

        if (_root_scope)
        {
            mut same = 0;
            for (mut i = _root_scope.items_len; i < _scope.items.len - 1; i++)
                if (_scope.items[i].id == id)
                    same++;

            if (same)
                GET_mut(overload).name ~= "_" ~ same;
        }

        if (global)
            GET_mut(overload).constant = out;

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveField(structType: Type, node: Node): SolvedNode
    {
        node.items[LET_INIT] &&
        node.items[LET_INIT].kind != "definit" &&
            fail("All structs must be zerofilled by default."
                ~ " Please remove the initializer of struct member `" ~ node.value ~ "`.");

        let out = solveBinding(node, Lifetime_fromArgIndex(0));
        let overload = Field(
            id: out.value,
            :structType, fieldType: out.type);

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok  = solveNode(node.items[0]);

        ////////////////////////////////
        let scope0  = Scope_push(_scope);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, var_ok.type,
            [ var_ok, var_err, catch ]);
    }

    fn findModule(fuzimport: string): &Module
    {
        let fname = resolveFile_x(fuzimport);

        let modules = ctx.modules;
        for (mut i = 1; i < modules.len; i++)
        {
            let module = modules[i];
            if (module.fname == fname)
                return module;
        }

        fail("Cannot locate: " ~ fname);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let module = findModule(fuzimport: node.value);
        Scope_import(module.modid);

        //
        return createEmpty();
    }


    //

    fn Scope_lookupType(mut id: string, flags: i32 = 0): Type
    {
        mut scope_iterator: i32;
        mut overloadIdx: Target;

        let scope = flags & F_QUALIFIED
            ? dequalify_andGetScope(id)
            : _scope;

        while (overloadIdx =
            scope.search(id, scope_iterator,
                scope_skip: _scope_skip))
        {
            let maybe = GET(overloadIdx);
            if (maybe.kind == "type")
                return maybe.type || fail();
        }

        return fail("No type `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupType(annot: Node): Type
    {
        return Scope_lookupType(annot.value, :annot.flags);
    }

    fn typeParam_get(id: string): Type
    {
        return Scope_lookupType("$" ~ id);
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t = evalTypeAnnot(items[0]).type;
                    t || fail();

                    if (node.value == "&")
                        return solved(node, add_ref(t, Lifetime_static));

                    if (node.value == "&mut")
                        return solved(node, add_mutref(t, Lifetime_static));

                    if (node.value == "[]")
                        return solved(node, createArray(t));
                }
                else if (items.len == 2)
                {
                    let a = evalTypeAnnot(items[0]).type;
                    let b = evalTypeAnnot(items[1]).type;
                    a && b || fail();

                    if (node.value == "Map")
                        return solved(node, createMap(a, b));
                }
            }
            else
            {
                return solved(node,
                    Scope_lookupType(node));
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();
            let type = typeParam_get(id) || fail(
                "No type param `$" ~ id ~ "` in scope.");

            return solved(node, type);
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = evalTypeAnnot(node.items[0]).type;
            return solved(node, createSlice(t));
        }

        return fail("TODO evalTypeAnnot");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, typeParams: &mut Map(string, Type)): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    mut t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : (fail("TODO trySolveTypeParams unary call"), Type);

                    if (!t)
                        return false;

                    // HACK TODO FIX!
                    //  keep the ref around for clear-slice to work.
                    if (node.value == "&mut" && items[0].kind == "arrlit" && items[0].items.len == 1)
                        t.quals |= q_ref;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                return isAssignable(
                    Scope_lookupType(node),
                        type);
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            let _param: &mut Type =
                (typeParams[id] ||= Type);

            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = tryClear_slice(type);
            return t && trySolveTypeParams(
                node.items[0] || fail(), t, typeParams);
        }

        return fail("TODO trySolveTypeParams fallthrough");
    }

    fn evalTypePattern(node: Node): bool
    {
        if (node.kind == "and")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i]))
                    return false;

            return true;
        }
        else if (node.kind == "or")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (evalTypePattern(node.items[i]))
                    return true;

            return false;
        }
        else if (node.kind == "typeassert")
        {
            let left  = node.items[0] || fail();
            let right = node.items[1] || fail();

            if (left.kind  == "typeparam" &&
                right.kind == "typetag")
            {
                let tag   = right.value || fail();
                let type  = typeParam_get(left.value) || fail(
                    "No type param `$" ~ left.value ~ "` in scope.");

                return type_has(type, tag);
            }
            else
            {
                //               is                //
                // (actual) left -> right (expect) //
                let expect = evalTypeAnnot(right).type;
                let actual = evalTypeAnnot(left ).type;

                return isAssignable(expect, actual);
            }
        }

        return fail("TODO evalTypePattern fallthrough: "
                    ~ node.kind ~ "(" ~ node.items.len ~ ")");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            flags:  F_ID,
            value:  id,
            token:  (_here || fail()));
    }

    fn dequalify_andGetScope(id: &mut string): &Scope
    {
        let split = id.find('\t');
            split >= 0 || fail();

        let fname = id.slice(0, split);
            id    = id.slice(split + 1);

        let other = findModule(fuzimport: fname);
        if (other.modid != module.modid)
            return other.out.solve.scope;

        return _scope;
    }

    fn solveCall(node: Node, target: Target = []): SolvedNode
    {
        mut id = node.value;
        if (!id) target || fail();

        // Qualified?
        let scope = node.flags & F_QUALIFIED
            ? dequalify_andGetScope(id)
            : _scope;

        mut args = solveNodes(node.items);

        //
        mut callTargIdx = scope.match__mutargs(id, args, node.flags, :target);
        mut callTarg    = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == "p-unshift";

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead("__partial"),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        mut itemType = type && tryClear_array(type);

        // Default constructor calls.
        if (!itemType && type.isStruct)
            return solveCall(node,
                target: lookupStruct(type).ctor);

        // Nope, it's an array literal.
        let items   = solveNodes(node.items, itemType);
        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail("Cannot infer empty arraylit.");

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                "[array literal] No common supertype.");
        }

        return solved(node, createArray(itemType), items);
    }


    //

    fn createLet(target: Target, flags: i32 = 0): SolvedNode
    {
        let overload = GET(target);

        return SolvedNode(
            kind: "let", :flags, token: _here || fail(),
            value: overload.name, :overload.type, :target);
    }

    fn injectImplicitArg__mutfn(
        fnNode: &mut SolvedNode,
        id: string, type: Type): Target
    {
        ///////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0  = Scope_push(_scope);
        let ret     = Binding(id, type, flags: F_IMPLICIT);
        Scope_pop(_scope, scope0);
        ///////////////////////////////////////////

        // Reuse existing or add new argnode.
        {
            let n = fnNode.items.len;
            for (mut i = 0; i < n; i++)
            {
                let arg: &mut SolvedNode = fnNode.items[i];
                if (arg.value == id)
                {
                    checkAssignable(host: type, arg.type,
                        "Implicit arg collision", id);

                    return ret;
                }
            }

            let newArgIdx   = fnNode.items.len + FN_RET_BACK;
            let newArgNode  = createLet(ret, F_IMPLICIT);

            fnNode.items.insert(newArgIdx, newArgNode);
        }

        // If we dont have the overload yet,
        //  there's nothing else to do here.
        if (fnNode.target)
        {
            let o: &mut Overload = GET_mut(fnNode.target);

            // We'll be mutating the overload.
            o.kind == "fn" || fail();
            o.args.push(
                Argument(
                    name: id, :type,
                    flags: F_IMPLICIT));
        }

        return ret;
    }

    fn bindImplicitArg(name: string, type: Type): SolvedNode
    {
        return CallerNode(
            createRead(name), :type,
            target: getImplicit(name, type));
    }

    fn getImplicit(id: string, type: Type): Target
    {
        mut args: SolvedNode[];
        mut matched = _scope.tryMatch__mutargs(
            :id, :args, retType: type);

        if (!matched)
        {
            if (!_current_fn)
                return fail("No implicit `" ~ id ~ "` in scope.");

            matched = injectImplicitArg__mutfn(
                _current_fn, id, type);

            matched || fail();
        }

        return matched;
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let n0      = node.items[0];
        let n1      = node.items[1];
        let n2      = node.items[2];

        let cond    = solveNode(n0, t_bool);
        mut cons    = n1 && solveNode(n1, type);
        mut alt     = n2 && solveNode(n2, cons.type || type);

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt || cons;

        let priType = priExpr.type;
        let secType = secExpr.type;

        if (!type.is_void && !type.is_bool)
        {
            type = !secType ? priType
                            : type_tryInter(priType, secType);

            type || fail("[if] No common supertype: `" ~ serializeType(priType) ~ " : " ~ serializeType(secType) ~ "`.");

            if (cons)
                maybeCopyOrMove(cons, type);
            if (alt)
                maybeCopyOrMove(alt, type);
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !andLast.type.is_never
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [])
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        if (overload.kind == "field")
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs(from: headType, to: type);
        }

        // Tag copies and moves.
        else if (args.len)
        {
            let host_args = overload.args || fail();
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), host_args[i].type,
                    isArgument: true);

            type.lifetime = Lifetime_fromCallArgs(
                type.lifetime, args);
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(node: &mut SolvedNode, slot: Type,
        isArgument = false): void
    {
        let q = slot.quals;

        // Clear mutrefs unless needed.
        if !(q & q_mutref)
            node.type.quals &= ~q_mutref;

        // No copy needed when the slot is a reference.
        if (q & q_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type.quals &= ~q_ref;

            return;
        }

        // Also, no copy needed when the expression is a value.
        if !(node.type.quals & q_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type.quals &= ~q_ref;
            return;
        }

        if !(q & q_rx_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (WARN_ON_IMPLICIT_COPY)
        {
            // if !(node.type.quals & q_trivial)
            //     println("WARN ", _here.line, ":", _here.col, ":\timplicit copy ", node.type.canon);
        }

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode, nrvo = false): SolvedNode
        SolvedNode(
            kind:   nrvo ? "nrvo" : "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(nodes: Node[], type: Type = []): SolvedNode[]
    {
        mut result: SolvedNode[];

        let here0 = _here;

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            if (!isUnordered(node.kind))
            {
                _here       = node.token || _here;
                result[i]   = solveNode(node, type);
                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (mut i = i0; i < nodes.len; i++)
            {
                let node = nodes[i];
                if (!node)
                    continue;

                if (!isUnordered(node.kind))
                {
                    i1 = i;
                    break;
                }

                _here       = node.token || _here;

                if (node.kind != "fn")
                    result[i] = unorderedPrep(node);
            }

            // TODO fix this shit
            {
                // Second pass - solve types.
                for (mut i = i0; i < i1; i++)
                {
                    let node = nodes[i];
                    if (node && node.kind != "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedSolve(node, result[i]);
                    }
                }

                // Third pass - prep fns.
                for (mut i = i0; i < i1; i++)
                {
                    let node = nodes[i];
                    if (node.kind == "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedPrep(node);
                    }
                }

                // Finally - prep fns.
                for (mut i = i0; i < i1; i++)
                {
                    let node = nodes[i];
                    if (node.kind == "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedSolve(node, result[i]);
                    }
                }
            }

            // Continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++
        }

        result.len == nodes.len || fail();

        _here = here0;

        return result;
    }


    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
    {
        // Ensure can't reimport self.
        _scope.imports ~= module.modid;

        // Load prelude.
        _Scope_import__forceCopy(0);
    }
    else
    {
        // Pre-populate prelude with primitive types and such.
        _scope = listGlobals();
    }

    // Solve.
    {
        let root = solveNode(parse);
        let scope = Scope_exports(_scope, :module.modid);

        // Run the thing.
        return SolverOutput(:root, :scope);
    }
}
