#import "helpers";
#import "lexer";
#import "parser";
#import "scope";
#import "types";
#import "lifetimes";

let WARN_ON_IMPLICIT_COPY = false;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

fn solve(
    implicit ctx: Context,
    implicit module: &mut Module,
    parse: Node): SolverOutput
{
    // TODO FIX next
    mut _scope: Scope;
    mut _here:  TokenIdx;

    // Needs template reset.
    mut _return_idx:    i32;
    mut _current_fn:    SolvedNode;
    mut _typeParams:    Map(string, Type);

    //
    mut TEST_expectImplicits: bool = false;


    //

    mut _array_cache: Map(Type, Type);
    fn fast_createArray(type: Type)
        _array_cache[type] ||= createArray(type);

    mut _t_string: Type;
    fn t_string(): Type
        _t_string ||= fast_createArray(t_byte);


    //

    fn Scope_import(modid: i32): void
    {
        let items = ctx.modules[modid].out.solve.scope.items;
        for (mut i = 0; i < items.len; i++)
        {
            let item = items[i];
            if (item.target.modid == modid)
                _scope.items.push(items[i]);
        }
    }

    fn GET(
        implicit module: Module,
        implicit ctx: Context,
        target: Target): Overload
    {
        target.index > 0 || assert();

        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }


    //

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;

        if (!reason)
            reason = "Unexpected `" + here.value + "`.";

        let fname = _here._fname;
        let l0 = here.line;
        let c0 = here.col;

        let addr = "@" + l0 + ":" + c0;

        return throw(fname + " " + addr + ":\n\t" + reason);
    }


    //

    fn Lifetime_next(): Lifetime
        Lifetime_fromScopeIdx( _scope.items.len + 1 );

    fn Binding(id: string, type: Type, kind = "var", constant: SolvedNode = [])
    {
        return Scope_add(
            _scope, :kind,
            :id || fail(), :type || fail(), :constant);
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope, "field",
            :id || fail(), fieldType || fail(),
            1, 1, [ "this" ], [ structType || fail() ]);
    }

    fn TemplateDecl(node: Node)
    {
        let id = node.value;

        node.kind == "fn" || fail("TODO");
        let min = node.items.len + FN_ARGS_BACK;

        let max = node.kind == "fn"
            ? 0xffffff // implicit args etc, dunno whats happening, allow it all
            : min;

        let template = Template(node);

        mut arg_n: string[];
        if (node.kind == "fn")
        {
            let items = node.items;
            let numArgs = items.len + FN_ARGS_BACK;
            for (mut i = 0; i < numArgs; i++)
            {
                let arg = items[i] || fail();
                arg.kind == "let" || fail();
                let name = arg.value || fail();
                arg_n.push(name);
            }
        }

        return Scope_add(
            _scope,
            "template", :id, t_template,
            :min, :max, arg_n, :template);
    }

    fn FnDecl(kind: string, id: string, node: &mut SolvedNode, native: Node): Target
    {
        let items = node.items;
        let rnode = items[items.len + FN_RET_BACK];
        let ret   = rnode && rnode.type || fail();

        let max   = items.len + FN_RET_BACK;
        let args  = items.slice(0, max);

        mut arg_t: Type[]       = [];
        mut arg_n: string[]     = [];
        mut arg_d: SolvedNode[] = [];

        mut min = 0;
        for (mut i = 0; i < max; i++)
        {
            let arg = args[i]    || fail();
            arg.kind == "let"    || fail();
            arg_t.push(arg.type  || fail());
            arg_n.push(arg.value || fail());

            //
            let isImplicit = !!(arg.flags & F_IMPLICIT);

            // Non-implicit, non-defaulted argument?
            if (!isImplicit)
            {
                arg_d.len >= i || fail();

                let def = arg.items[LET_INIT];
                arg_d.push(def);
                if (!def)
                    min++;
            }
        }

        let template = Template(node: native);

        let overload = Scope_add(
            _scope,
            :kind, :id, ret,
            :min, :max, arg_n, arg_t, arg_d,
            :template);

        node.target = overload;

        return overload;
    }

    fn DefaultCtor(id: string, type: Type, members: SolvedNode[])
    {
        mut arg_t:   Type[] = [];
        mut arg_n: string[] = [];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            arg_t.push(member.type  || fail());
            arg_n.push(member.value || fail());
        }

        //
        let max   = members.len;
        mut min   = 0;
        mut arg_d: SolvedNode[];

        {
            for (mut i = 0; i < members.len; i++)
            {
                let member = members[i];

                let init = member.items[LET_INIT]
                        || tryDefaultInit(member.type);

                // Disable defaulting if any member is non-defaulted.
                if (!init)
                {
                    min = max;
                    arg_d.clear();
                    break;
                }

                arg_d.push(init);
            }
        }

        return Scope_add(
            _scope,
            "defctor", :id, :type,
            :min, :max, arg_n, arg_t, arg_d);
    }

    fn tryDefaultInit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (type.quals & q_mutref)
            return SolvedNode();

        return createDefaultInit(type);
    }

    fn createDefaultInit(type: Type): SolvedNode
    {
        return SolvedNode(
            kind: "definit",
            token: _here || fail(),
            :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryDefaultInit(type)
            || fail("Cannot definit: " + serializeType(type));
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = "p-unshift";
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut arg_t = overload.args     ? overload.args    .slice(1) : overload.args;
        mut arg_n = overload.names    ? overload.names   .slice(1) : overload.names;
        mut arg_d = overload.defaults ? overload.defaults.slice(1) : overload.defaults;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != "var" &&
            via.kind != "global" &&
            via.kind != "arg" &&
            via.kind != "ref")
        {
            kind = "p-wrap";
            min++;
            max++;

            let via_t = via.args && via.args[0] || fail();

            //
            arg_t.unshift(via_t);
            if (arg_n)
                arg_n.unshift("using");
            if (arg_d)
                arg_d.unshift(SolvedNode());
        }

        return Scope_add(
            _scope,
            :kind, :id, :overload.type,
            :min, :max, arg_n, arg_t, arg_d,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();

        for (mut i = 0; i < _scope.items.len; i++)
        {
            let item = _scope.items[i];

            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                continue;

            let overloadIdx = item.target;
            let overload = GET(overloadIdx);

            // Needs at least one argument.
            if (overload.min < 1)
                continue;

            // TODO using + templates, the fuck do we do?
            if (overload.isTemplate)
                continue;

            // See if we fit.
            let expect = overload.args[0] || fail();
            if (!isAssignableAsArgument(expect, actual))
                continue;

            // Enforce no-collide.
            if (overload.min < 2)
            {
                // Scan through -
                //  no other arity-0 entries are allowable.
                for (mut i = 0; i < _scope.items.len; i++)
                {
                    let o = _scope.items[i];
                    if (o.id == item.id)
                    {
                        let other = GET(o.target);
                        if (other.min < 1)
                            fail("`using` ambiguity: `" + item.id + "`.");
                    }
                }
            }

            //
            Partial(item.id, viaIdx, overloadIdx);
        }
    }


    //

    fn getNamedArgReorder(
        names: string[],
        arg_n: string[]): i32[]
    {
        mut result: i32[] = [];

        mut offset = 0;
        for (mut i = 0; i < arg_n.len; i++)
        {
            mut idx = names.find(arg_n[i]);
            if (idx < 0)
            {
                for (mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }

            result.push(idx);
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        // Return nothing if not needed.
        for (mut i = 0; i < result.len; i++)
            if (result[i] != i)
                return result;

        result.clear();
        return result;
    }

    fn tryMatch__mutargs(
        scope: Scope,
        id: string, args: &mut SolvedNode[],
        flags: i32 = 0, retType: Type = []): Target
    {
        mut matchIdx: Target;

        // Arity 0 - blind head match.
        // Allows simple shadowing of variables and such, latest wins.
        if (!args)
        {
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            while (overloadIdx =
                scope.search(id, scope_iterator))
            {
                if (GET(overloadIdx).min == 0)
                {
                    matchIdx = overloadIdx;
                    break;
                }
            }
        }
        else
        {
            let arity = args.len;

            // Prep labelled args for remap.
            mut names: string[];
            if (flags & F_NAMED_ARGS)
            {
                mut some = false;

                for (mut i = 0; i < arity; i++)
                {
                    let arg = args[i];
                    names.push(arg.kind == "label"
                        ? (some = true, arg.value) || fail()
                        : "");
                }

                some || fail();
            }

            //
            mut reorder: i32[];
            mut args_mangled: string;

            //
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            :NEXT
            while (overloadIdx =
                scope.search(id, scope_iterator))
            {
                mut overload = GET(overloadIdx);

                :TEST_AGAIN
                while (true)
                {
                    if (overload.min > arity || overload.max < arity)
                        continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    //
                    if (names && overload.names)
                        reorder = getNamedArgReorder(
                            names, overload.names);
                    else
                        reorder.clear();

                    // Specialize.
                    if (overload.isTemplate)
                    {
                        if (reorder)
                            fail("TODO handle argument reorder in template specialization.");

                        let o = GET(overloadIdx);
                        let specIdx = trySpecialize(
                            overloadIdx, :o.template, :args,
                            :args_mangled ||= mangleArguments(args));

                        if (!specIdx)
                            continue :NEXT;

                        overloadIdx = specIdx;
                        overload = GET(specIdx);

                        // Repeat arity checks and such.
                        continue :TEST_AGAIN;
                    }

                    // Done here.
                    break :TEST_AGAIN;
                }

                // Type check args.
                let arg_t = overload.args || fail();
                let arg_d = overload.defaults;

                let N = reorder ? reorder.len
                                : args.len;

                for (mut i = 0; i < N; i++)
                {
                    let callsiteIndex = reorder ? reorder[i]
                                                : i;
                    if (callsiteIndex < 0)
                    {
                        // Argument may not be defaulted -
                        //  we might be supplying defaults via names
                        //   before we've actually exhausted
                        //    all the non-defaulted stuff.
                        if !(arg_d && arg_d[i])
                            continue :NEXT;

                        continue;
                    }

                    if (!isAssignableAsArgument(arg_t[i], args[callsiteIndex].type || fail()))
                        continue :NEXT;
                }

                // Forbid ambiguity.
                if (matchIdx)
                    fail("Ambiguous callsite, matches multiple functions in scope: `" + id + "`.");

                // Done!
                matchIdx = overloadIdx;

                // Do reorder.
                if (reorder)
                {
                    // TODO:
                    // I shouldn't need this pass, just swaps must do.
                    mut new_args: SolvedNode[];
                    new_args.resize(reorder.len);

                    for (mut i = 0; i < reorder.len; i++)
                    {
                        let idx = reorder[i];
                        if (idx >= 0)
                            new_args[i] = args[idx];
                    }

                    args = new_args;
                }
            }
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let arg_d = matched.defaults;
            if (arg_d)
            {
                if (args.len < arg_d.len)
                    args.resize(arg_d.len);

                for (mut i = 0; i < arg_d.len; i++)
                    args[i] = args[i] || arg_d && arg_d[i] || fail();
            }

            // Implicit argument injection.
            let arg_t = matched.args;

            if (arg_t && args.len < arg_t.len)
            {
                let arg_n = matched.names || fail();
                for (mut i = args.len; i < arg_t.len; i++)
                {
                    let id   = arg_n[i];
                    let type = arg_t[i];

                    // Propagate implicit.
                    bindImplicitArg(args, i, id, type);
                }
            }
        }

        return matchIdx;
    }


    //

    fn match__mutargs(
        scope: Scope,
        id: string, args: &mut SolvedNode[], flags: i32): Target
    {
        let ret = scope.tryMatch__mutargs(:id, :args, :flags);
        if (ret)
            return ret;

        let debug = scope.tryMatch__mutargs(:id, :args, :flags);
        if (debug)
            return debug;

        return scope.NICERR_mismatch(:id, :args);
    }

    fn NICERR_mismatch(
        scope: Scope,
        id: string, args: SolvedNode[]): never
    {
        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = Scope_lookup(scope, id);

        mut min = 0xffffff;
        for (mut i = 0; i < overloads.len; i++)
        {
            let arity = GET(overloads[i]).min;
            if (min > arity)
                min = arity;
        }

        return overloads
             ? args.len < min
                ? fail("`" + id + "` expects " + min + " arguments, " + args.len + " provided.")
                : fail("`" + id + "` bad args, provided: " + mangleArguments(args))
             : fail("`" + id + "` is not defined.");
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node);
        if (k == "label")       return solveComma(node);
        if (k == "comma")       return solveComma(node);

        if (k == "let")         return solveLet(node, Lifetime_static);
        if (k == "call")        return solveCall(node);
        if (k == "arrlit")      return solveArrayLiteral(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "!")           return solveNot(node);
        if (k == "and")         return solveAnd(node, type);

        if (k == "return")      return solveReturn(node);
        if (k == "loop")        return solveBlock(node);
        if (k == "break")       return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "num")         return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);
        if (k == "empty")       return createEmpty();

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);

        return fail("TODO: " + k);
    }

    fn isUnordered(kind: string)
    {
        return kind == "fn"
            || kind == "struct"
            || kind == "typedef";
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == "fn")          return uPrepFn(node);
        if (k == "struct")      return uPrepStruct(node);
        if (k == "typedef")     return solveTypedef(node);

        return fail("TODO: " + k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == "fn")          return uSolveFn(node, prep);
        if (k == "struct")      return uSolveStruct(node, prep);
        if (k == "typedef")     return prep || fail();

        return fail("TODO: " + k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        TEST_expectImplicits = !!(node.flags & F_IMPLICIT);

        return solved(node, t_void, solveNodes(node.items, t_void));
    }

    fn solveBlock(node: Node): SolvedNode
    {
        let scope0 = Scope_push(_scope);
        let out = solved(node, t_void, solveNodes(node.items, t_void));
        Scope_pop(_scope, scope0);
        return out;
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
    {
        if (type)
        {
            if (type == t_f32 || type == t_f64)
                return solved(node, type);

            // TODO FIX these need to check ranges and such.
            if (type == t_i64 || type == t_i16 || type == t_i8)
                return solved(node, type);

            if (node.value[0] != '-')
                if (type == t_u32 || type == t_u64 || type == t_u16 || type == t_u8)
                    return solved(node, type);
        }

        return solved(node, t_i32);
    }

    fn solveNum(node: Node, type: Type): SolvedNode
    {
        if (type == t_f32)
            return solved(node, t_f32);

        return solved(node, t_f64);
    }

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefaultInit(
                add_ref(t_string, Lifetime_static));

        return solved(node, t_string);
    }

    fn createEmpty(): SolvedNode
    {
        return SolvedNode(
            kind: "empty", type: t_void);
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(false, false, node, SolvedNode, -1);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(true, false, node, prep, -1);
    }

    fn __solveFn(solve: bool, spec: bool, n_fn: Node, prep: SolvedNode, caseIdx: i32): SolvedNode
    {
        let id = n_fn.value || fail("TODO anonymous fns");

        // Template early exit.
        if (spec)
        {
            solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl   = TemplateDecl(n_fn);
            mut out     = solved(n_fn, t_void);
            out.target  = tDecl;
            return out;
        }

        // Prep reject.
        if (!solve && !(n_fn.flags & F_FULLY_TYPED))
            return SolvedNode();

        let inItems = n_fn.items;
        inItems.len >= FN_RET_BACK || fail();

        mut out = prep || solved(n_fn, t_void);

        out.items.resize(inItems.len);

        //
        if (_current_fn && id != "free")
        {
            _current_fn.flags |= F_HAS_CLOSURE;
            out.flags |= F_CLOSURE;
        }

        //////////////////////////
        mut native = false;
        mut n_body: Node;

        {
            let return_idx0 = _return_idx;
            _return_idx = Scope_push(_scope);

            SWAP(_current_fn, out);
            let outItems: &mut SolvedNode[] = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == "let" || fail();

                let lifetime = Lifetime_fromArgIndex(i);

                if (spec)
                {
                    // Specialize with actuals.
                    mut mut_arg = n_arg;
                    mut_arg.items[LET_TYPE] = createTypeParam(mut_arg.value);

                    // Emit value-taking specializations.
                    let type = _typeParams[mut_arg.value];
                    if !(type.quals & q_ref)
                        mut_arg.flags |= F_MUT;

                    outItems[i] = solveLet(mut_arg, :lifetime);
                }
                else
                {
                    outItems[i] = solveLet(n_arg, :lifetime);
                }
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
                n_body  = inItems[inItems.len + FN_BODY_BACK] || fail();

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == "pattern" || fail();
                let branch = n_body.items[caseIdx] || fail();
                let items = branch.items;

                n_ret   = items[items.len + FN_RET_BACK]  || n_ret;
                n_body  = items[items.len + FN_BODY_BACK];
            }

            // Builtin?
            if (n_body.kind == "block" && n_body.items.len == 1)
            {
                let ret = n_body.items[0];
                if (ret.kind == "return" && ret.items.len == 1)
                {
                    let expr = ret.items[0];
                    if (expr.kind == "call" && expr.value == "__native")
                    {
                        native = true;

                        n_body = expr;
                    }
                }
            }

            // Return type annot.
            {
                let s_ret = n_ret
                    ? evalTypeAnnot(n_ret)
                    : SolvedNode();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_RET_BACK] = s_ret;
            }

            // Only if actually solving the fn, the fn body.
            if (solve && !native)
            {
                let s_body = solveNode(n_body);
                s_body || fail();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body;
            }

            //
            /////////////////////////////////////////////////////

            SWAP(_current_fn, out);

            Scope_pop(_scope, _return_idx);
            _return_idx = return_idx0;
        }
        //////////////////////////

        if (!prep)
        {
            mut kind = native ? "__native" : "fn";

            //
            FnDecl(:kind, :id, out, native && n_body);
        }

        if (solve && !native)
            out.items[out.items.len + FN_BODY_BACK] || fail();

        return out;
    }


    //

    fn mangleArguments(args: SolvedNode[]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle += ",";

            mangle += serializeType((args[i] || fail()).type);
        }

        return mangle;
    }


    //

    fn trySpecialize(
        target: Target, template: Template, args: SolvedNode[],
        mangled_args: string)
            : Target
    {
        // TODO memoize the whole mangle.
        mut mangle = target.modid + "#" + target.index;
            mangle += mangled_args;

        // TODO FIX THIS MESS -
        //  A. Not recursion capable: use the general prep-vs-solve approach here too.
        //  B. The multiple map taps here are because stuff
        //      moves around while doTrySpecialize does its work -
        //      if maps values didn"t move around we"d be good.
        let spec = module.out.specs[mangle] ||= SolvedNode;
        if (!spec)
        {
            let spec = doTrySpecialize(template, args);
            module.out.specs[mangle] = spec;
            return spec.target;
        }

        return spec.target;
    }

    fn doTrySpecialize(
        template: Template, args: SolvedNode[])
            : SolvedNode
    {
        let node = template.node;

        node.kind == "fn" || fail("TODO");
        mut result = trySpecializeFn(node, args);
        if (!result)
            result.kind = "spec-fail";

        return result;
    }


    //

    fn trySpecializeFn(
        node: Node, args: SolvedNode[])
            : SolvedNode
    {
        let items = node.items;
        mut typeParams: Map(string, Type);

        // First off, solve type params.
        let numArgs = items.len + FN_ARGS_BACK;
        for (mut i = 0; i < numArgs; i++)
        {
            let argNode = items[i] || fail();
            argNode.kind == "let"  || fail();

            mut inType = args.len > i && args[i].type;

            if (inType)
            {
                // All fnargs are referable.
                inType.lifetime = Lifetime_fromArgIndex(i);

                //
                let argName = argNode.value || fail();

                // Same pattern - grabs a mutref.
                let argName_typeParam: &mut Type =
                    typeParams[argName] ||= Type;

                argName_typeParam && fail(
                    "Type param name collision with argument: `" + argName + "`.")
                        = inType;

                //
                inType.quals |= q_ref;
            }

            // Type check.
            let annot = argNode.items[LET_TYPE];
            if (annot)
            {
                let ok = inType && trySolveTypeParams(
                    annot, inType, typeParams);

                if (!ok)
                    return SolvedNode();
            }
        }

        // Match pattern arm here.
        mut caseIdx = -1;

        let pattern = items[items.len + FN_BODY_BACK] || fail();
        if (pattern.kind == "pattern")
        {
            let branches = pattern.items;
            for (mut i = 0; i < branches.len; i++)
            {
                let branch = branches[i];
                let items = (branch || fail()).items;
                let cond = items[0] || fail();

                if (evalTypePattern(cond, typeParams))
                {
                    caseIdx = i;
                    break;
                }
            }

            // All branches mismatch?
            if (caseIdx < 0)
                return SolvedNode();
        }

        ////////////////////////////////
        mut current_fn0: SolvedNode;

        SWAP(_current_fn, current_fn0);
        SWAP(_typeParams, typeParams);

        let scope0 = Scope_push(_scope);
        ////////////////////////////////

        let specialized = __solveFn(true, true, node, SolvedNode(), caseIdx);
        specialized || fail();

        ////////////////////////////////
        SWAP(_current_fn, current_fn0);
        SWAP(_typeParams, typeParams);

        Scope_pop(_scope, scope0);
        ////////////////////////////////

        return specialized;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(false, node, SolvedNode());
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(true, node, prep);
    }

    fn __solveStruct(solve: bool, node: Node, prep: SolvedNode): SolvedNode
    {
        mut out         = prep || solved(node, t_void);

        let id          = node.value || fail("TODO anonymous structs");
        let structType  = initStruct(id, node.flags);

        // Add the arity-0 type entry.
        if (!prep)
            out.target  = Scope_Typedef(_scope, id, structType);

        if (!solve)
            return out;

        // Struct fields only.
        out.items = solveStructMembers(
            node.items, :structType);

        // Add a default constructor.
        {
            mut members: SolvedNode[];
            let items = out.items;

            mut fields: StructField[];

            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == "let" && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value        || fail(),
                            type: item.type.value   || fail()));
                }
            }

            finalizeStruct(id, fields);

            DefaultCtor(id, structType, members);
        }

        return out;
    }

    fn solveStructMembers(members: Node[], structType: Type): SolvedNode[]
    {
        mut out: SolvedNode[];

        for (mut i = 0; i < members.len; i++)
        {
            let node = members[i];
            if (node.kind == "let")
                out.push(solveField(:node, :structType));
            else
                fail("TODO: " + node.kind);
        }

        return out;
    }


    //

    fn solveReturn(node: Node): SolvedNode
    {
        mut out = solved(
            node, t_void, solveNodes(node.items));

        let next: &mut SolvedNode =
            out.items   ? out.items[0]
                        : out;

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if (next.type.lifetime.killedBy(_return_idx) &&     //
            next.type.quals & q_ref)                        //
        {                                                   //
            let nrvo = next.kind == "call"                  //
                    && next.items.len == 0                  //
                    && next.target.GET.kind == "var";       //
                                                            //
            next = createMove(next, nrvo);                  //
        }                                                   //
        //////////////////////////////////////////////////////

        let retIdx = _current_fn.items.len + FN_RET_BACK;
        let prev   = _current_fn.items[retIdx];

        if (prev.type)
            isAssignable(prev.type, next.type)
                || fail("Non-assignable return types: " + serializeType(prev.type) + " <- " + serializeType(next.type));
        else
            _current_fn.items[retIdx] = next || fail();

        if (out.items)
            maybeCopyOrMove(out.items[0],
                prev.type || next.type,
                isReturn: true);

        return out;
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveBinding(node: Node, lifetime: Lifetime): SolvedNode
    {
        let n_annot     = node.items[LET_TYPE];
        let n_init      = node.items[LET_INIT];

        mut annot       = n_annot && evalTypeAnnot(n_annot);
        mut init        = n_init && solveNode(n_init, annot.type);

        annot.type || init.type || fail(
            "Variable declarations without type annotations must be initialized.");

        let t_let       = annot.type
                            ? node.flags & F_ARG && !(node.flags & F_MUT)
                              ? add_ref(annot.type, lifetime)
                              : annot.type
                        : init.type.quals & q_mutref || node.flags & F_MUT
                            ? clear_refs(init.type)
                            : init.type;

        if (annot.type && init.type)
            isAssignable(annot.type, init.type) || fail(
                "Type annotation does not match init expression: `"
                    + node.value + ": " + serializeType(annot.type) + " = " + serializeType(init.type) + "`.");

        if (init)
            maybeCopyOrMove(init, t_let);

        //
        mut out = solved(node, t_let, [annot || init, init]);

        if !(_current_fn || node.flags & F_FIELD)
        {
            if (out.flags & F_MUT || out.type.quals & q_mutref)
                fail("Mutable statics are not currently allowed.");

            out.kind = "global";
        }

        return out;
    }

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);
        Scope_Typedef(_scope, node.value, annot.type);
        return createEmpty();
    }

    fn solveLet(node: Node, mut lifetime: Lifetime): SolvedNode
    {
        let out         = solveBinding(node, lifetime);
        let global      = out.kind == "global";

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if !(out.type.quals & q_ref)                        //
            lifetime = Lifetime_next();                     //
                                                            //
        //////////////////////////////////////////////////////

        let kind = global                   ? "global"
                 : node.flags & F_ARG       ? "arg"
                 : out.type.quals & q_ref   ? "ref"
                                            : "var";

        let overload    = Binding(
            id: out.value, :kind,
            constant: global && out,

            node.flags & F_MUT
                ? add_mutref(out.type, lifetime)
                : add_ref(out.type, lifetime));

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveField(structType: Type, node: Node): SolvedNode
    {
        let out = solveBinding(node, Lifetime_fromArgIndex(0));
        let overload = Field(
            id: out.value,
            :structType, fieldType: out.type);

        if (out.flags & F_USING)
            scope_using(overload);

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok  = solveNode(node.items[0]);

        ////////////////////////////////
        let scope0  = Scope_push(_scope);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    + " consider dropping the annotation.");

        return solved(node, var_ok.type,
            [ var_ok, var_err, catch ]);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let fname = node.value;
        let modules = ctx.modules;

        for (mut i = 1; i < modules.len; i++)
        {
            if (modules[i].fname == fname)
            {
                Scope_import(i);
                return createEmpty();
            }
        }

        assert();
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t = evalTypeAnnot(items[0]).type;
                    t || fail();

                    if (node.value == "&")
                        return solved(node, add_ref(t, Lifetime_static));

                    if (node.value == "&mut")
                        return solved(node, add_mutref(t, Lifetime_static));

                    if (node.value == "[]")
                        return solved(node, fast_createArray(t));
                }
                else if (items.len == 2)
                {
                    let a = evalTypeAnnot(items[0]).type;
                    let b = evalTypeAnnot(items[1]).type;
                    a && b || fail();

                    if (node.value == "Map")
                        return solved(node, createMap(a, b));
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == "type")
                            return solved(node, maybe.type || fail());
                    }
                }

                fail("No type `" + id + "` in scope.");
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();
            _typeParams || fail(
                "Unexpected type param: `$" + id + "`.");

            let type = _typeParams && _typeParams[id] || fail(
                "No type param `$" + id + "` in scope.");

            return solved(node, type);
        }

        return fail("TODO");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, typeParams: &mut Map(string, Type)): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    let t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : (fail("TODO"), Type);

                    if (!t)
                        return false;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                let id        = node.value || fail();
                let overloads = Scope_lookup(_scope, id);

                if (overloads)
                {
                    for (mut i = 0; i < overloads.len; i++)
                    {
                        let maybe = GET(overloads[i]);
                        if (maybe.kind == "type")
                            return isAssignable(maybe.type || fail(), type);
                    }
                }

                fail("No type `" + id + "` in scope.");
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            let _param: &mut Type =
                (typeParams[id] ||= Type);

            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }

        return fail("TODO");
    }

    fn evalTypePattern(node: Node, typeParams: Map(string, Type)): bool
    {
        let items = node.items;
        if (items.len == 2)
        {
            let left  = items[0] || fail();
            let right = items[1] || fail();

            if (node.kind == "call" && node.value == "->")
            {
                if (left.kind  == "typeparam" &&
                    right.kind == "typetag")
                {
                    let tag   = right.value || fail();
                    let type  = left.value && typeParams[left.value] || fail(
                        "No type param `$" + left.value + "` in scope.");

                    return type_has(type, tag);
                }
                else
                {
                    ////////////////////////////////
                    let typeParams0 = _typeParams;
                    _typeParams       = typeParams;
                    ////////////////////////////////

                    //               is                //
                    // (actual) left -> right (expect) //
                    let expect = evalTypeAnnot(right).type;
                    let actual = evalTypeAnnot(left ).type;

                    ////////////////////////////////
                    _typeParams = typeParams0;
                    ////////////////////////////////

                    return isAssignable(expect, actual);
                }
            }
            else if (node.kind == "and")
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
            else if (node.kind == "or")
            {
                return evalTypePattern(left,  typeParams)
                    && evalTypePattern(right, typeParams);
            }
        }

        return fail("TODO");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            flags:  F_ID,
            value:  id,
            token:  (_here || fail()));
    }

    fn solveCall(node: Node): SolvedNode
    {
        let id          = node.value; id || fail();
        mut args        = solveNodes(node.items);

        mut callTargIdx = _scope.match__mutargs(id, args, node.flags);
        mut callTarg    = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == "p-unshift";

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead("__partial"),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        let items       = solveNodes(node.items);
        mut itemType    = type && tryClear_array(type);
        mut startAt     = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail("Cannot infer empty arraylit.");

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                "[array literal] No common supertype.");
        }

        return solved(node, fast_createArray(itemType), items);
    }


    //

    fn createLet(id: string, type: Type, flags: i32 = 0): SolvedNode
    {
        return SolvedNode(
            kind:   "let",
            flags:  flags,
            value:  id,
            token:  _here || fail(), :type);
    }

    fn injectImplicitArg__mutfn(
        fnNode: &mut SolvedNode,
        id: string, type: Type): Target
    {
        ///////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0  = Scope_push(_scope);
        let ret     = Binding(id, type);
        Scope_pop(_scope, scope0);
        ///////////////////////////////////////////

        // Reuse existing or add new argnode.
        {
            let n = fnNode.items.len;
            for (mut i = 0; i < n; i++)
            {
                let arg: &mut SolvedNode = fnNode.items[i];
                if (arg.value == id)
                {
                    isAssignable(type, arg.type)
                        || fail("Implicit arg collision: `" + id + "`.");

                    return ret;
                }
            }

            let newArgIdx   = fnNode.items.len + FN_RET_BACK;
            let newArgNode  = createLet(id, type, F_IMPLICIT);

            fnNode.items.insert(newArgIdx, newArgNode);
        }

        // If we dont have the overload yet,
        //  there's nothing else to do here.
        if (fnNode.target)
        {
            let o: &mut Overload = GET_mut(fnNode.target);

            // We'll be mutating the overload.
            o.kind == "fn" || fail();

            o.names.len == o.args.len || fail();

            o.args .push(type);
            o.names.push(id);
        }

        return ret;
    }

    fn bindImplicitArg(
        mut args: &mut SolvedNode[],
        argIdx: i32, id: string, type: Type)
    {
        TEST_expectImplicits || fail(
            "Attempting to propagate implicit arguments.");

        args.len >= argIdx || fail();

        args.insert(argIdx, CallerNode(
            createRead(id), :type,
            target: getImplicit(id, type)));
    }

    fn getImplicit(id: string, type: Type): Target
    {
        mut args: SolvedNode[];
        mut matched = _scope.tryMatch__mutargs(
            :id, :args, retType: type);

        if (!matched)
        {
            if (!_current_fn)
                return fail("No implicit `" + id + "` in scope.");

            matched = injectImplicitArg__mutfn(
                _current_fn, id, type);

            matched || fail();
        }

        return matched;
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let n0      = node.items[0];
        let n1      = node.items[1];
        let n2      = node.items[2];

        let cond    = solveNode(n0, t_bool);
        mut cons    = n1 ? solveNode(n1)            : SolvedNode;
        mut alt     = n2 ? solveNode(n2, cons.type) : SolvedNode;

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt || cons;

        let priType = priExpr.type;
        let secType = secExpr.type;

        if !(type == t_void || type == t_bool)
        {
            type = !secType ? priType
                            : type_tryInter(priType, secType);

            type || fail("[if] No common supertype: `" + serializeType(priType) + " : " + serializeType(secType) + "`.");

            if (cons)
                maybeCopyOrMove(cons, type);
            if (alt)
                maybeCopyOrMove(alt, type);
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type);

        // Statement mode.
        if (type == t_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if !(type == t_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type == t_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !(andLast.type == t_never)
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items);

        // Statement mode.
        if (type == t_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if !(type == t_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type == t_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [])
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        if (overload.kind == "field")
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs(from: headType, to: type);
        }

        // Tag copies and moves.
        else if (args.len)
        {
            let arg_t = overload.args || fail();
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), arg_t[i],
                    isArgument: true);

            type.lifetime = Lifetime_fromCallArgs(
                type.lifetime, args);
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(node: &mut SolvedNode, slot: Type,
        isReturn = false,
        isArgument = false): void
    {
        let q = slot.quals;

        // Clear mutrefs unless needed.
        if !(q & q_mutref)
            node.type.quals &= ~q_mutref;

        // No copy needed when the slot is a reference.
        if (q & q_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type.quals &= ~q_ref;

            return;
        }

        // Also, no copy needed when the expression is a value.
        if !(node.type.quals & q_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type.quals &= ~q_ref;
            return;
        }

        if !(q & q_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (WARN_ON_IMPLICIT_COPY)
        {
            // if !(node.type.quals & q_trivial)
            //     print("WARN ", _here.line, ":", _here.col, ":\timplicit copy ", node.type.canon);
        }

        //
        if (isReturn)
            return;

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode, nrvo = false): SolvedNode
        SolvedNode(
            kind:   nrvo ? "nrvo" : "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(nodes: Node[], type: Type = []): SolvedNode[]
    {
        mut result: SolvedNode[];

        let here0 = _here;

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            if (!isUnordered(node.kind))
            {
                _here       = node.token || _here;
                result[i]   = solveNode(node, type);
                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (mut i = i0; i < nodes.len; i++)
            {
                let node = nodes[i];
                if (!node)
                    continue;

                if (!isUnordered(node.kind))
                {
                    i1 = i;
                    break;
                }

                _here       = node.token || _here;
                result[i]   = unorderedPrep(node);
            }

            // Second pass, do the remaining work.
            for (mut i = i0; i < i1; i++)
            {
                let node = nodes[i];
                if (node)
                {
                    _here       = node.token || _here;
                    result[i]   = unorderedSolve(node, result[i]);
                }
            }

            // Continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++
        }

        result.len == nodes.len || fail();

        _here = here0;

        return result;
    }


    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
        Scope_import(0);
    else
        _scope = listGlobals();

    // Run the thing.
    return SolverOutput(
        root: solveNode(parse),
        scope: _scope);
}
