import helpers;
import parser;
import scope;
import context;
import types;


// Solver notes.

pub let N_FnRecursion       = 1 << 0;
pub let N_FnResolve         = 1 << 1;
pub let N_FnReopen          = 1 << 2;

pub let N_TypeRecursion     = 1 << 3;
pub let N_TypeResolve       = 1 << 4;
pub let N_TypeReopen        = 1 << 5;

pub let N_DeadCode          = 1 << 6;
pub let N_DeadCall          = 1 << 7;
pub let N_DeadLet           = 1 << 8;
pub let N_DeadIf            = 1 << 9;


//

let OPTI_autoshadow         = true;
let OPTI_dedupe_vars        = true;
let OPTI_flatten_blocks     = true;

let USE_nontriv_autocopy    = true;
let USE_retval_narrowing    = false; // TODO not safe without borrowck
let USE_ref_to_mutref       = false;

let SELF_TEST               = true;

let CANNOT_definit_mutrefs  = true;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub fn solve(
    implicit ctx: Context,
    implicit ref module: Module,
    parse: Node): SolverOutput
{
    struct Info
    {
        here: TokenIdx;
        text: string;
    };

    mut _info:          Info[];
    mut _here:          TokenIdx;

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;
        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let fname = _here._fname;
        let addr = "@" ~ here.line ~ ":" ~ here.col;
        for (mut i = _info.len; i --> 0; )
        {
            let info = _info[i];
            shadow let here = info.here._token;
            reason ~= here
                ? "\n\t@" ~ here.line ~ ":" ~ here.col ~ ": " ~ info.text
                : "\n\t" ~ info.text;
        }

        return throw(fname ~ " " ~ addr ~ ":\n\t" ~ reason);
    }


    //

    mut _scope:         Scope;
    mut _root_scope:    ScopeMemo;
    mut _ss:            ScopeSkipMemos;
    mut _field_items:   ScopeItem[];
    mut _notes:         i32;

    struct CurrentFn
    {
        using out:      SolvedNode;
        locals_used?:   i32[];
    };

    mut _current_fn:    CurrentFn;
    let implicit mut
        _helpers:       Helpers[];

    mut _anons:         i32;
    fn ANON(): string = "0" ~ _anons++;


    // Can't we just list them all and scan through?
    //  Do we need the mangling nonsense?
    //   We can bucket however many times we want here,
    //    its append only and trivial to maintain.

    mut _specs:         Map(string, Target); // mangle -> spec


    //

    let t_string = createArray(t_byte);

    type TypeParams = Map(string, Type);


    //

    fn _Scope_import__forceCopy(modid: i32): void
    {
        _scope.items ~= ctx.modules[modid].out.solve.scope.items;
    }

    fn Scope_import(modid: i32): void
    {
        _scope.imports.each(_ss.imports, |import|
        {
            if (import == modid)
                return;
        });

        modid || fail("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
    }

    fn GET(target: Target): Overload
    {
        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }

    fn GET_local(index: i32): Overload
    {
        return GET(Target(modid: module.modid, :index));
    }


    // Hacking a pair of local indices into a target.

    fn left (ref target: Target) target.modid;
    fn right(ref target: Target) target.index;


    //

    fn Lifetime_fromNative(sig: [Node], args: [SolvedNode], actual: Type): Lifetime
    {
        sig.len + FN_ARGS_BACK == args.len || fail("sig.len != args.len");

        let ret = sig[sig.len + FN_RET_BACK];
        mut mutref = ret.kind == "call" && ret.items.len == 1 && ret.value == "&mut";

        mut res: Type;
        for (;;)
        {
            for (mut i = 0; i < args.len; i++)
            {
                let inArg = sig[i];
                let annot = inArg.items[LET_TYPE];
                if (annot.items.len == 1 && ((annot.kind == "call"
                    && (!mutref && annot.value == "&" || annot.value == "&mut"))
                     || !mutref && annot.kind == "arrlit"))
                {
                    res && fail("Ambiguous __native lifetime.");

                    let arg = args[i];
                    let o = GET(arg.target);
                    res = o.type;
                    res.lifetime || fail("Missing arg lifetime.");
                }
            }

            // Try again without the mutref,
            //  currently we have a bunch of drama related to case-patterns,
            //   the mutref annots actually come in the branches, not the arg annots.
            if (!mutref || res.lifetime)
                break;

            mutref = false;
        }

        res.lifetime.uni0n.only.Region_isArg || fail("Non-single-arg __native lifetime.");

        // TODO FIX UNIQUENESS adding a static lifetime to constref results
        //  that are not assignable from the source argument,
        //   this coincides with container derefs currently -
        //
        // We only want to avoid attempts to move from there for now.
        //
        if (!actual.is_mutref && !isAssignable(host: actual, res))
            return Lifetime_makeShared(res.lifetime);

        return res.lifetime;
    }

    fn Lifetime_test(lifetime: Lifetime, tempsOK?!: bool): Lifetime
    {
        if (SELF_TEST)
        {
            let current_fn  = _current_fn.target;
            let debug_2     = current_fn && GET(current_fn);
            if (debug_2) {}

            if !(lifetime.uni0n.len)
                fail("Lifetime_test: no region set.");

            mut _last: Region;
            for (mut i = 0; i < lifetime.uni0n.len; i++)
            {
                let region  = lifetime.uni0n[i];
                {
                    !i || region > _last || fail("Lifetime_test: not a sorted set");
                    _last = region;
                }

                if (Region_isArg(region))
                    continue;

                if (region.Region_isTemp)
                {
                    i == lifetime.uni0n.len - 1 && tempsOK || fail("Lifetime_test: unexpected temporary.");
                    continue;
                }

                fn fnd(index: i32)
                    GET(Target(:module.modid, :index));

                let index = region.Region_toLocalIndex;
                let local = index && fnd(index);
                let local_of = local.local_of; // zero for globals
                if (local_of)
                {
                    mut frame = current_fn.index;
                    while (local_of != frame)
                    {
                        local_of <= frame || fail("Lifetime_test: `" ~ local.name ~ "` is not a local: `"
                            ~ fnd(local_of).name ~ "` does not contain "
                            ~ (frame    ? "`" ~ fnd(frame).name ~ "`"
                                        : "global scope")
                            ~ (current_fn.index != frame ? ", testing from `" ~ fnd(current_fn.index).name ~ "`." : "."));

                        frame || fail("Lifetime_test: climbed up to root");
                        frame = fnd(frame).local_of;
                    }
                }
            }
        }

        return lifetime;
    }

    fn Lifetime_fromBinding(target: Target, local_of!: i32, flags!: i32, type: Type): Lifetime
    {
        target.modid == module.modid || fail("not from this module");

        // Globals?
        if (!local_of)
            return Lifetime_static();

        // Alias?
        let isArg = flags & F_ARG;
        if (!isArg && type.is_ref)
            return Lifetime_test(type.lifetime);

        // Argument?
        let index       = target.index;
        let region      = isArg && type.is_ref
            ? Region_fromArgIndex(index)
            : Region_fromLocalIndex(index);

        return Lifetime_test(Lifetime(uni0n: [ region ]));
    }

    fn Lifetime_replaceArgsAtCallsite(overload: Overload, argNodes: [SolvedNode]): Lifetime
    {
        let returned    = overload.type.lifetime.uni0n;
        let items       = overload.solved.items;

        // Nothing to do if empty/non-arg.
        if (!Region_isArg(returned.if_first))
            return Lifetime(uni0n: returned);

        let head = items[0].target.index;
        let tail = items[items.len + FN_ARGS_BACK - 1].target.index;

        mut keep:       Lifetime;
        mut replace:    Lifetime;

        mut offset = items.len + FN_ARGS_BACK;

        for (mut i = 0; i < returned.len; i++)
        {
            let region      = returned[i];
            let index       = region.Region_toArgIndex;

            // We're only filtering here, no need to run the full thing.
            if (index < head || index > tail) {
                keep.uni0n ~= region;
                continue;
            }

            // Full union here, otherwise we risk messing things up.
            while (offset--)
            {
                let here = items[offset].target.index;
                if (here == index)
                {
                    let argNode = argNodes[offset];

                    let argLt = argNode.type.is_ref
                        ? argNode.type.lifetime || fail("refarg without lifetime")
                        : Lifetime_temporary();

                    replace = Lifetime_union(replace, argLt);
                    break;
                }

                here > index || fail("nope, going backwards");
            }
        }

        return Lifetime_union(keep, replace);
    }


    //

    fn Binding(id: string, mut type: Type, ref flags!: i32, ref shadows!: bool, reuse?: Target)
    {
        mut name = id;

        //
        let local_of = _current_fn.target.index;

        // Unique identifiers.
        if (_root_scope)
        {
            mut autoshadow  = 0;
            mut id_clashes  = 0;

            _scope.items.each(_ss.declash, |item, index|
            {
                let root = index <= _root_scope.items_len;

                if (item.id == id)
                {
                    if (!root)
                        autoshadow++;

                    id_clashes++;
                }
            });

            if (id_clashes)
                name ~= "_" ~ id_clashes;

            // LEAKY TEMPLATES, part 1:
            //  All locals are F_SHADOW - this is a usability thing really,
            //   otherwise you'd simply have to `shadow` everything manually.
            //
            // Actually turning this on for everything -
            //  it might optimize scope lookups all over the place.
            //
            if (OPTI_autoshadow && local_of && !autoshadow)
            {
                shadows = true;
                flags |= F_SHADOW;
            }
        }

        // Reserve the slot.
        let target = reuse || Scope_create(_scope, kind: "var", :name, :flags, :local_of);

        // Double check.
        if (SELF_TEST && reuse)
        {
            let preexisting = GET(reuse);
            preexisting.name == name && preexisting.kind == "var" && preexisting.flags == flags && preexisting.local_of == local_of
                || fail("Binding reuse mismatch.");
        }

        // Setup the lifetime for references to this binding.
        ref overload = GET_mut(target);
        {
            let lifetime = Lifetime_fromBinding(target, :local_of, :flags, type);

            ///////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////
            ///////////////////////////////////////////////////////////////
            // Throw away argument lifetime, union below will fix it up. //
            if (flags & F_ARG) ////////////////////////////////////////////
                type.lifetime = Lifetime(); ///////////////////////////////
            ///////////////////////////////////////////////////////////////

            overload.type = flags & F_MUT
                ? add_mutref(type, lifetime)
                : add_ref   (type, lifetime);
        }

        return target;
    }

    fn createTemplate(node: Node): Template
    {
        return Template(
            node,
            imports:   !_current_fn && _scope.imports,
            scope_memo: _current_fn && Scope_snap(_scope),
            scope_skip: _current_fn && _ss);
    }

    fn tryCreateDefinit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (CANNOT_definit_mutrefs)
            if (type.is_mutref)
                return SolvedNode();

        return createDefinit(type);
    }

    fn createDefinit(mut type: Type): SolvedNode
    {
        let token = _here || fail();

        if (type.is_ref)
            type.lifetime = Lifetime_static();

        if (type.quals & q_integral)
            return SolvedNode(
                kind: "int", :token, :type,
                value: "0");

        if (type.quals & q_floating_pt)
            return SolvedNode(
                kind: "real", :token, :type,
                value: "0");

        return SolvedNode(
            kind: "definit", :token, :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryCreateDefinit(type)
            || fail("Cannot definit: " ~ serializeType(type));
    }

    fn solveTypeAssert(node: Node): SolvedNode
    {
        let left   = node.items[0];
        let right  = node.items[1];

        // left -> right.
        let expect = evalTypeAnnot(right).type;
        let actual = solveNode(left, expect);

        checkAssignable(host: expect, actual.type,
            "Type assertion failed");

        return actual;
    }


    //

    fn reorderByNumUsings(
        ref use_reorder: bool, ref reorder: i32[],
        host_args: Argument[], num_args: i32, num_usings!: i32)
    {
        reorder.clear();

        if (num_usings)
        {
            for (mut i = 0; i < host_args.len; i++)
            {
                let x = i - num_usings;
                reorder.push(x >= 0 && x < num_args ? x : -1);
            }
        }

        use_reorder = !!reorder;
    }

    fn reorderByArgIDs(
        ref use_reorder: bool, ref reorder: i32[],
        names: string[], mut optional: bitset::BitSet,
        host_args: Argument[], num_usings!: i32): bool
    {
        use_reorder = true;
        reorder.clear();

        //
        mut used   = 0;
        mut offset = num_usings;
        for (mut i = 0; i < host_args.len; i++)
        {
            mut idx = names.find(host_args[i].name);
            if (idx < 0)
            {
                for (shadow mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                used++;
                optional.rem(i);
            }

            reorder.push(idx);
        }

        // Fail if some name ended up unused.
        //  TODO FIX THIS MESS
        if (used != names.len)
        {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used + optional.popcount != names.len)
                return false;
        }

        // Drop trailing misses.
        while (reorder && reorder[reorder.len - 1] < 0)
            reorder.pop();

        // See if needed.
        if (reorder.len != names.len)
            return true;

        for (mut i = 0; i < reorder.len; i++)
            if (reorder[i] != i)
                return true;

        // Matches but no need for the reorder stuff.
        reorder.clear();
        use_reorder = false;

        return true;
    }

    fn findRestStart(overload: Overload)
    {
        for (mut i = overload.args.len; i --> 0; )
        {
            let arg = overload.args[i];
            if  (arg.flags & F_REST_ARG) return i;
            if !(arg.flags & F_IMPLICIT) break;
        }

        return overload.args.len;
    }

    fn tryMatch__mutargs(
        scope: Scope, local_scope: bool,
        mut id: string, ref args: SolvedNode[],
        ref conversions: Target[][],
        flags?!: i32, target?!: Target): Target
    {
        mut matchIdx: Target;
        mut DEBUG_assertMatch: Target;

        mut minArity        = args.len;
        let numUsings       = scope.usings && countUsings(:scope, :local_scope);
        let explicitArity   = minArity;
        let maxArity        = explicitArity + numUsings;

        // Prep labelled args for remap.
        mut names: string[];
        mut optional: bitset::BitSet;
        if (flags & F_NAMED_ARGS)
        {
            mut some = false;

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                names.push(arg.kind == "argid"
                    ? { some = true; arg.value } || fail()
                    : "");

                if (arg.flags & F_OPT_ARG)
                {
                    minArity--;
                    optional.add(i);
                }
            }

            some || fail();
        }

        mut reorder: i32[];
        mut reusable_mangle: string;

        // Argument & `using` dependent lookup,
        //  basically we do everything we can to get rid of imports.
        mut extra_items: Target[];
        if (local_scope && !target)
        {
            mut seen: bitset::BitSet;

            fn visitTypeImports(type: Type)
            {
                let visit = type.lookupTypeImports();
                for (mut i = -1; i < visit.len; i++)
                {
                    let modid = i >= 0 ? visit[i] : type.modid;
                    if (seen.has(modid))
                        continue;

                    // Lazy init -
                    //  we want to ignore self and all imports,
                    //   and everything we've already traversed.
                    if (!seen)
                    {
                        seen.add(0);
                        seen.add(module.modid);
                        scope.imports.each(
                            local_scope && _ss.imports,
                                |shadow modid| seen.add(modid));
                    }

                    if (!seen.add_once(modid))
                        continue;

                    //
                    let items = ctx.modules[modid].out.solve.scope.items;
                    for (shadow mut i = 0; i < items.len; i++)
                        if (items[i].id == id)
                            extra_items.push(items[i].target);
                }
            }

            // Usings.
            if (numUsings)
                scope.usings.each(
                    local_scope && _ss.usings,
                        |u| visitTypeImports(GET(u).type));

            // Field access, method calls & operator calls.
            //  TODO no way to opt-out of this for operators currently,
            //   consider regular id-names for all ops, so we can freefn call them.
            if (flags & (F_ACCESS | F_METHOD | F_INFIX | F_PREFIX | F_POSTFIX))
                for (mut i = 0; i < args.len; i++)
                    visitTypeImports(args[i].type);
        }

        // TODO the whole field_items thing is a mess,
        //  we really need a cleaner way to put these things up.
        let field_items = local_scope && (flags & F_ACCESS || !minArity)
            && minArity <= 1 && maxArity
            && _field_items;

        //
        mut alternate_ids: string[];

        ///////////////////////////
        mut args_out: SolvedNode[];
        ///////////////////////////

        for (;;)
        {
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            //
            mut shadows: bool;
            NEXT: while (overloadIdx =
                scope.items.search(id, scope_iterator,
                    scope_skip: local_scope && (flags & F_IMPLICIT ? _ss.declash : _ss.items),
                    dont_search_just_return: target, :extra_items, :field_items, :shadows))
            {
                ///////////////////////////////////
                ref conversions_out = conversions;
                shadow mut conversions: Target[][];

                ref args_in = args;
                shadow mut args = args;

                mut TODO_FIX_skip_autocalls = false;
                ///////////////////////////////////

                TEST_AGAIN: while (true)
                {
                    let overload = GET(overloadIdx);

                    // Make sure we know what this is.
                    if (lazySolveStart(overloadIdx, overload))
                        continue :TEST_AGAIN;

                    ////////////////////////////////////////////
                    // Conversions / typename aliases.
                    let isType = overload.kind == "type";
                    if (minArity && isType && !target)
                    {
                        let alt = overload.type.canon;
                        if (alt != id) // e.g. i32
                            alternate_ids.push(alt);
                    }
                    ////////////////////////////////////////////

                    // Arity check.
                    let isZeroInit = isType && !explicitArity;
                    if (!isZeroInit)
                        if (overload.max < minArity || overload.min > maxArity)
                            continue :NEXT;

                    // Reorder by argument names or number of implicit `using` args.
                    let host_args   = overload.args;
                    let num_usings  = !isZeroInit && overload.min > explicitArity
                                    && overload.min - explicitArity;

                    mut use_reorder = false;
                    if (!names)
                        reorderByNumUsings(:use_reorder, :reorder, host_args, args.len, :num_usings);
                    else if (!reorderByArgIDs(:use_reorder, :reorder, names, optional, host_args, :num_usings))
                        continue :NEXT;

                    // Forbid optional argument ambiguities -
                    //  We should either have all optional args satisfied at the receiver or sender part,
                    //   we shouldn't allow dangling cables on both ends because that's super typo-prone.
                    if (optional && reorder)
                        if (reorder.len < args.len && reorder.len < overload.max)
                            continue :NEXT; // TODO NICE ERROR HERE

                    fn disambig()
                    {
                        if (matchIdx)
                        {
                            fn GETfn(idx: i32) GET(Target(modid: module.modid, index: idx));

                            fn fnName(idx: i32) idx
                                ? "`" ~ GETfn(idx).name ~ "`"
                                : "global scope";

                            let inner = GET(matchIdx)   .local_of;      // first to match is innermost scope
                            let outer = GET(overloadIdx).local_of;      // what we're currently looking is upscope
                            let callsite = _current_fn.target.index;    // as seen from where we currently are

                            if (SELF_TEST)
                            {
                                mut _c = callsite;
                                while (_c > inner) _c = GETfn(_c).local_of;
                                _c == inner || fail(
                                    "BUG! Leaking `" ~ id ~ "` between functions [inner/callsite]: "
                                        ~ inner.fnName ~ " is seen from " ~ callsite.fnName);

                                mut _i = inner;
                                while (_i > outer) _i = GETfn(_i).local_of;
                                _i == outer || fail(
                                    "BUG! Leaking `" ~ id ~ "` between functions [inner/outer]: "
                                        ~ inner.fnName ~ " and " ~ outer.fnName
                                        ~ " as seen from " ~ callsite.fnName);
                            }

                            fail("Ambiguous callsite, matches multiple items in scope: `" ~ id
                                ~ "` from " ~ inner.fnName ~ " and " ~ outer.fnName
                                ~ ", as seen from " ~ callsite.fnName ~ ".");
                        }
                    }

                    mut REST_TYPE: Type;
                    let REST_START = overload.findRestStart();

                    let N = (use_reorder ? reorder.len : args.len)
                        .max(!isZeroInit && overload.min);

                    if (N)
                    {
                        reorder.len >= args.len || !reorder || optional || fail("reorder < args.");

                        ARG_OK:
                        for (mut i = 0; i < N; i++)
                        {
                            let rest        = i >= REST_START;
                            let host_arg    = host_args[rest ? REST_START : i];
                            let expect      = host_arg.type;

                            // TODO FIX!
                            if (TODO_FIX_skip_autocalls && rest)
                                continue :ARG_OK;

                            // Its either reorder or args, asserted above [^].
                            let callsiteIndex   = use_reorder   ? reorder[i]
                                                : i < args.len  ? i
                                                : /*using*/ -1;

                            if (callsiteIndex < 0)
                            {
                                // Argument may not be defaulted -
                                //  we might be supplying defaults via names
                                //   before we've actually exhausted
                                //    all the non-defaulted stuff.
                                if (host_arg.default || host_arg.flags & F_IMPLICIT)
                                    continue :ARG_OK;

                                // Usings - can't match on explicitly named arguments.
                                if !(host_arg.flags & F_MUSTNAME || flags & F_CONVERSION)
                                {
                                    // Can't proceed if we don't know what we're looking for.
                                    //  If we decide to not support more than a single using,
                                    //   we could simply assume it's a match here.
                                    //
                                    shadow let expect = expect || host_arg.default.type;
                                    if (expect)
                                    {
                                        let conversion = tryConvert(:scope, :local_scope, :expect);
                                        if (conversion)
                                        {
                                            conversions.grow_if_oob(i) = conversion;
                                            continue :ARG_OK;
                                        }
                                    }
                                }

                                continue :NEXT;
                            }

                            // Explicit argname requirements.
                            if (host_arg.flags & F_MUSTNAME)
                            {
                                if (names.len <= callsiteIndex || !names[callsiteIndex])
                                    continue :NEXT;
                            }

                            // Autocall.
                            if (host_arg.autocall && !TODO_FIX_skip_autocalls)
                            {
                                mut autocall_args:          SolvedNode[];
                                mut autocall_conversions:   Target[][];

                                autocall_args.resize(1);
                                SWAP(args[callsiteIndex], autocall_args.only);

                                let t = tryMatch__mutargs(:scope, :local_scope, id: host_arg.autocall, args: autocall_args, conversions: autocall_conversions);
                                if (!t)
                                    continue :NEXT;

                                SWAP(args[callsiteIndex], autocall_args.only);

                                if (autocall_conversions)
                                    conversions.grow_if_oob(i) ~= autocall_conversions.only;

                                conversions.grow_if_oob(i) ~= t;
                            }

                            // Templates.
                            if (!expect)
                                continue :ARG_OK;

                            let hasConv = conversions.len > i && conversions[i].len;
                            let actual = hasConv
                                ? GET(conversions[i].last).type
                                : args[callsiteIndex].type;

                            if (isAssignableAsArgument(expect, actual))
                                continue :ARG_OK;

                            /////////////////
                            // Literal fixup.
                            if (!hasConv && considerRetyping(:expect, :actual))
                            {
                                ref        arg = args[callsiteIndex];
                                shadow ref arg = arg.kind == "argid"
                                    ? arg.items.only
                                    : arg;

                                let retype = tryRetyping(arg, expect);
                                if (isAssignableAsArgument(expect, retype))
                                {
                                    arg.type = retype;
                                    continue :ARG_OK;
                                }
                            }
                            //        /LITFIX
                            /////////////////

                            // Go through conversions here.
                            if !(flags & F_CONVERSION)
                            {
                                let conversion = tryConvert(:scope, :local_scope, :expect, :actual);
                                if (conversion)
                                {
                                    conversions.grow_if_oob(i) ~= conversion;
                                    continue :ARG_OK;
                                }
                            }

                            // Nope, args fail.
                            continue :NEXT;
                        }
                    }

                    if (REST_START < N)
                    {
                        for (mut i = REST_START; i < N; i++)
                        {
                            let hasConv         = conversions.len > i && conversions[i].len;
                            let callsiteIndex   = use_reorder ? reorder[i] : i;
                            let actual          = hasConv
                                ? GET(conversions[i].last).type
                                : args[callsiteIndex].type;

                            REST_TYPE = i == REST_START
                                ? solveArrlit_itemType_init(head: actual)
                                : type_trySuper(REST_TYPE, actual);

                            if (!REST_TYPE)
                                continue :NEXT;
                        }

                        REST_TYPE = solveArrlit_done(itemType: REST_TYPE);
                    }

                    // Specialize.
                    if (overload.kind == "template")
                    {
                        mut cant_reuse: string;

                        shadow ref args_mangled =
                            (use_reorder || conversions
                                ? cant_reuse : reusable_mangle)
                            ||= mangleArguments(
                                :args, :reorder, :use_reorder, :conversions,
                                :REST_START, :REST_TYPE);

                        let specIdx = trySpecialize(
                            :overloadIdx, :args, :reorder, :use_reorder,
                            :conversions, :args_mangled,
                            :REST_START, :REST_TYPE);

                        if (!specIdx)
                            continue :NEXT;

                        // Repeat arity checks and such.
                        //
                        // TODO doesn't seem necessary anymore.
                        //  It's crazy to think that we'd specialize an inline
                        //   and end up not using it.
                        //
                        overloadIdx         = specIdx;
                        DEBUG_assertMatch   = specIdx;

                        TODO_FIX_skip_autocalls = true;

                        continue :TEST_AGAIN;
                    }

                    // Forbid ambiguity.
                    disambig();

                    // Do reorder.
                    if (use_reorder)
                    {
                        args_out.resize(reorder.len);
                        for (mut i = 0; i < reorder.len; i++)
                        {
                            let idx = reorder[i];
                            if (idx >= 0)
                                args_out[i] = args[idx];
                        }
                    }
                    else
                    {
                        SWAP(args, args_out);
                    }

                    // Output conversions /////////////
                    SWAP(conversions, conversions_out);
                    ///////////////////////////////////

                    // Done!
                    matchIdx = overloadIdx;

                    // Arity 0 auto-shadows.
                    if (shadows)
                        break :NEXT;

                    // Done here.
                    break :TEST_AGAIN;
                }
            }

            //////////////////////////////////
            // Conversions / typename aliases.
            if (!alternate_ids)
                break;

            id = alternate_ids.last;
            alternate_ids.pop();
            //////////////////////////////////
        }

        if (matchIdx)
            SWAP(args, args_out);

        if (DEBUG_assertMatch)
            DEBUG_assertMatch == matchIdx || fail(
                "Did specialize something but ended up not using it.");

        return matchIdx;
    }


    //

    fn considerRetyping(expect: Type, actual: Type): bool
    {
        return expect.quals & actual.quals & q_arithmetic != 0;
    }

    fn couldRetype(node: SolvedNode): bool
    {
        return node.kind == "int"
            || node.kind == "real";
    }

    fn tryRetyping(node: SolvedNode, expect: Type): Type
    {
        return node.kind == "int"  ? solveInt(node.value, expect)
             : node.kind == "real" ? solveNum(node.value, expect)
             : [];
    }


    //

    fn countUsings(scope: Scope, local_scope: bool): i32
    {
        let scope_skip = local_scope && _ss.usings;
        mut count = 0;
        scope.usings.each(scope_skip, |u| u ? count++ : fail());
        return count;
    }

    fn tryConvert(
        scope: Scope, local_scope: bool,
        expect: Type, actual?: Type): Target[]
    {
        mut match:  Target[];
        mut path:   Target[];

        let has_converts = scope.converts.len;
        let ss_converts = local_scope && _ss.converts;

        // TODO FIX ////////////
        mut _args: SolvedNode[];
        mut _conversions: Target[][];
        ////////////////////////

        fn descend(from: Type, nullary!: bool, isStruct!: bool)
        {
            fn foreach(t: Target)
            {
                if (!nullary) {
                    _args.resize(1);
                    _args[0].type = from;
                }

                mut candidate: Target;
                if (nullary || (candidate = tryMatch__mutargs(
                    target: t,
                    scope: Scope, local_scope: false, id: "",
                    args: _args, conversions: _conversions,
                    flags: F_CONVERSION)))
                {
                    shadow let t = nullary ? t : candidate;

                    let convert = GET(t);
                    let convertType = convert.kind == "field"
                        ? add_refs(from: from || fail(), to: convert.type)
                        : convert.type;

                    shadow let isStruct = convertType.isStruct;

                    if (isAssignableAsArgument(convertType, /*into*/host: expect))
                    {
                        // Actual is assignable to current `from` type,
                        //  this means we've got a conversion edge that works.
                        if (match)
                        {
                            fn explain(shadow path: [Target])
                            {
                                mut res = "`";
                                for (mut i = 0; i < path.len; i++)
                                {
                                    if (i) res ~= "` -> `";

                                    let o = GET(path[i]);
                                    res ~= o.kind ~ " " ~ o.name;

                                    if (i < path.len) res ~= ": " ~ serializeType(o.type);
                                }

                                res ~= "`";
                                return res;
                            }

                            mut suffix  = "\n\t" ~ explain(match) ~ "\n\tand:"
                                        ~ "\n\t" ~ explain(path ~ t);

                            if (actual)
                                fail("Conversion ambiguity, multiple ways to convert `"
                                    ~ serializeType(actual) ~ "` into `"
                                    ~ serializeType(expect) ~ "`: " ~ suffix);
                            else
                                fail("`using` ambiguity, multiple ways to obtain a `"
                                    ~ serializeType(expect) ~ "` in this scope: " ~ suffix);
                        }

                        match = path ~ t;
                    }
                    else
                    {
                        let mightHaveConversion = isStruct || scope.converts;
                        if (mightHaveConversion)
                        {
                            // Forbid cyclic conversions.
                            //  Delaying the error check to speed up the general case.
                            if (path.len > 10)
                            {
                                for (mut i = path.len; i --> 0; )
                                {
                                    if (path[i] == t)
                                    {
                                        mut err = "Conversion loop:";

                                        for (shadow mut i = i; i < path.len; i++)
                                        {
                                            if (!i) err ~= "\n\t`";
                                            else    err ~= " `";

                                            shadow let convert = GET(path[i]);
                                            err ~= convert.kind ~ " " ~ convert.name ~ ": " ~ serializeType(convertType) ~ "` ->";
                                        }

                                        err ~= "\n\t\t`" ~ convert.kind ~ " " ~ convert.name ~ "`.";
                                        fail(err);
                                    }
                                }
                            }

                            ///////////////////////////////
                            path.push(t); defer path.pop();
                            ///////////////////////////////
                            descend(convertType, nullary: false, :isStruct);
                            ///////////////////////////////
                        }
                    }
                }
            }

            // Usings.
            if (nullary)
            {
                scope.usings.each(local_scope && _ss.usings,
                    |u| foreach(u));
            }

            // On-struct stuff.
            else
            {
                if (isStruct)
                {
                    let inner = lookupStruct(from).converts;

                    // TODO no need to for the outer isAssignableAsArgument check.
                    // TODO can we split these into incoming and outgoing converts,
                    //       so we don't have to check anything at all?
                    //
                    for (mut i = 0; i < inner.len; i++)
                        foreach(inner[i]);
                }

                // Conversions.
                if (has_converts)
                    scope.converts.each(ss_converts, fn foreach);
            }
        }

        // Go.
        descend(actual, nullary: !actual, :actual.isStruct);

        // We're done here.
        return match;
    }


    //

    fn match__mutargs(
        scope: Scope, local_scope: bool,
        id: string, ref args: SolvedNode[],
        ref conversions: Target[][],
        flags: i32, target: Target): Target
    {
        let ret = tryMatch__mutargs(:scope, :local_scope, :id, :args, :conversions, :flags, :target);
        if (ret)
            return ret;

        let debug = tryMatch__mutargs(:scope, :local_scope, :id, :args, :conversions, :flags, :target);
        if (debug)
            return debug;

        return NICERR_mismatch(:scope, :local_scope, :id, :args);
    }

    fn NICERR_mismatch(
        scope: Scope, local_scope: bool,
        id: string, args: SolvedNode[]): never
    {
        // TODO instead of this -
        //  run tryMatch__mutargs again with an error output attached,
        //   this way we don't need the second pass for debugging,
        //    we can #bake alla jblow the if (explain) parts,
        //     and we can rid ourselves of Scope_lookup altogether.

        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.

        mut overloads: Target[] = [];

        mut scope_iterator: i32;
        mut target: Target;
        mut shadows: bool;
        while (target = scope.items.search(:id, :scope_iterator,
            scope_skip:  local_scope && _ss.items,
            field_items: local_scope && _field_items, :shadows))
        {
            overloads.push(target);
        }

        mut min = 0x7fffffff.i32;
        mut max = 0;
        for (mut i = 0; i < overloads.len; i++)
        {
            let o = GET(overloads[i]);
            if (min > o.min) min = o.min;
            if (max < o.max) max = o.max;
        }

        fn expectedArgs(shadow targets: Target[]): string
        {
            mut result = "";

            for (mut i = 0; i < targets.len; i++)
            {
                if (result)
                    result ~= "\n\t\t";
                else if (targets.len > 1)
                    result ~= ", available overloads:\n\t\t";
                else
                    result ~= ", expects: ";

                let overload = GET(targets[i]);

                result ~= overload.name ~ "(";

                for (shadow mut i = 0; i < overload.args.len; i++)
                {
                    let arg = overload.args[i];
                    if (i)
                        result ~= ", ";

                    result ~=  arg.name
                            ~ (arg.flags & F_MUSTNAME ? "!" : "")
                            ~ (arg.default ? "?: " : ": ")
                            ~ (arg.type ? humanizeType(arg.type) : "$");
                }

                result ~= ")";
            }

            return result || ".";
        }

        fn actualArgs(shadow args: SolvedNode[]): string
        {
            mut result = "\nActual: (";

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                if (i)
                    result ~= ",";

                result ~= "\n\t";
                if (arg.kind == "argid")
                    result ~= arg.value ~ ": ";

                result ~= humanizeType(arg.type);
            }

            return result ~ ").";
        }

        return overloads
                ? args.len < min ? fail("`" ~ id ~ "` expects at least " ~ min ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : args.len > max ? fail("`" ~ id ~ "` expects at most " ~ max ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : fail("`" ~ id ~ "` bad args" ~ expectedArgs(overloads) ~ actualArgs(args))
             : fail("`" ~ id ~ "` is not defined in this scope: " ~ ("`" ~ _current_fn.value ~ "`." || "root scope."));
    }


    //

    fn solveNode(node: Node, type: Type = [], deadcode_on_never?!: bool, kills?!: i32): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type, :kills);
        if (k == "argid")       return solveArgID(node, :type);

        if (k == "let")         return solveLet(node, :deadcode_on_never);
        if (k == "call")        return solveCall(node, :kills);
        if (k == "arrlit")      return solveArrlit(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "and")         return solveAnd(node, type);

        if (k == "loop")        return solveLoop(node);
        if (k == "break")       return solveJump(node, kills);
        if (k == "return")      return solveJump(node, kills);
        if (k == "continue")    return solveJump(node, kills);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typedef")     return solveTypedef(node);
        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "typeparam")   return solveTypeParam(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        if (k == "fn")          return solveDeclExpr(node);
        if (k == "struct")      return solveDeclExpr(node);

        // Exotics
        if (k == "forfieldsof") return solveForFieldsOf(node);

        //
        return fail("TODO: " ~ k);
    }

    fn solveDeclExpr(node: Node): SolvedNode
    {
        return solveNodes([ node ]).only;
    }

    fn unorderedClassify(kind: string): i32
    {
        if (kind == "fn")       return 1;
        if (kind == "struct")   return 10;

        return 0;
    }

    fn unorderedPrep_A(node: Node): SolvedNode
    {
        let k = node.kind;
        if (k == "fn")          return uPrepFn_A(node);
        if (k == "struct")      return uPrepStruct(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedPrep_B(node: Node, into: Target)
    {
        let k = node.kind;
        if (k == "fn")
            uPrepFn_B(into);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        // TODO if deadcode_on_never here and if last is never,
        //  the program will crash during static init.
        //   Could we use this mechanism for static asserts?
        //
        return solved(node, t_void,
            solveNodes(node.items, t_void));
    }

    fn solveBlock(node: Node, type!: Type, fnbody_of?!: i32, mask! = HM_CanBreak, kills?!: i32): SolvedNode
    {
        let token = node.token;
        let nodes = node.kind == "block"  ? node.items : [ node ];
        let id    = node.kind == "block" && node.value;

        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let helpers_idx = _helpers.len;
        _helpers       ~= Helpers(:id, :mask,
            ret_expect: type,
            target:     fnbody_of,
            local_of:   fnbody_of ? -1 : _current_fn.target.index,
            :kills);

        let expr        = !fnbody_of && !type.is_void;
        mut items       = solveNodes(
            nodes,
            type_all:           t_void,
            type_last:          type,
            use_type_last:      expr,
            deadcode_on_never:  true,

            // Kills is +1 so that kills=0 means noone.
            kills: helpers_idx + 1);

        ///////////////////////////////////////////////////////////////
        // finalizeReturns (helpers_idx: i32, bodyType: Type)
        ref h = _helpers[helpers_idx];

        // TODO FIX these apply to regular blocks as well,
        //  decide if you want fns to be like blocks or the other way round,
        //   but these ifs gotta go.
        if (fnbody_of)
        {
            if (items.if_last.type.is_never)
            {
                if (!h.ret_actual)
                    h.ret_actual = t_never;
            }
            else
            {
                if (h.ret_actual)
                    isAssignable(host: t_void, h.ret_actual) || fail(
                        "Non-void returning fn missing a final return.");

                h.ret_actual = t_void;
            }

            // TODO FIX disable return value narrowing,
            //  we're getting some aliasing somewhere.
            if (!USE_retval_narrowing && h.ret_expect)
            {
                let lt0         = h.ret_actual.lifetime;
                h.ret_actual    = h.ret_expect;

                if (h.ret_actual.is_ref)
                    h.ret_actual.lifetime = lt0 || fail("expected ref, got no lt0");
            }
        }

        if (!fnbody_of && items && !h.ret_actual.is_void)
            reportReturnType(:helpers_idx, items.last.type);

        // cpy/move.
        if (!h.ret_actual.is_ref)
        {
            for (mut i = 0; i < h.returns.len; i++)
            {
                ref ret = GET_mut(Target(:module.modid, index: h.returns[i]));
                maybeCopyOrMove(ret.solved, h.ret_actual);
            }

            if (!fnbody_of && items && !h.ret_actual.is_void)
                maybeCopyOrMove(items.last, h.ret_actual);
        }
        // end finalizeReturns
        ///////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////
        if (OPTI_flatten_blocks && items.len) for (;;)
        {
            let tail = items.last;
            if (tail.kind != "block" || tail.target)
                break;

            mut unwrap = tail.items;
            items.pop();
            items ~= unwrap;
        }
        //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////

        // Control flow.
        return createBlock(:token, :items,
            type: h.ret_actual || t_void,
            label: h.mask & HM_LabelUsed && Target(:module.modid, h.target));
    }

    fn createBlock(token: TokenIdx, type: Type, items: SolvedNode[], label?: Target): SolvedNode
    {
        // Compact + stress test.
        if (!label && items.len)
        {
            mut ok = true;
            for (mut i = 0; i < items.len - 1; i++)
            {
                if (items[i].kind != "empty")
                {
                    ok = false;
                    break;
                }
            }

            if (ok)
                return items.last;
        }

        return SolvedNode(kind: "block", :type, :items, :token, target: label);
    }


    //

    fn solveInt(v: string, type: Type): Type
    {
        shadow let parse = intlit::Intlit(v);
        parse.error && fail(parse.error);

        if (type)
        {
            fn want(t: Type)
                type.canon == t.canon;

            if (!parse.unsigned)
            {
                if (want(t_f32) && parse.minsize_f <= 32) return t_f32;
                if (want(t_f64) && parse.minsize_f <= 64) return t_f64;

                if (want(t_i32) && parse.minsize_i <= 32) return t_i32;
                if (want(t_i64) && parse.minsize_i <= 64) return t_i64;
                if (want(t_i16) && parse.minsize_i <= 16) return t_i16;
                if (want(t_i8 ) && parse.minsize_i <= 8 ) return t_i8 ;
            }

            if (!parse.signed)
            {
                if (want(t_u32) && parse.minsize_u <= 32) return t_u32;
                if (want(t_u64) && parse.minsize_u <= 64) return t_u64;
                if (want(t_u16) && parse.minsize_u <= 16) return t_u16;
                if (want(t_u8 ) && parse.minsize_u <= 8 ) return t_u8 ;
            }
        }

        if (parse.unsigned)
        {
            if (parse.minsize_u <= 32) return t_u32;
            if (parse.minsize_u <= 64) return t_u64;
        }
        else
        {
            if (parse.minsize_i <= 32) return t_i32;
            if (parse.minsize_i <= 64) return t_i64;
        }

        return fail("Bad int literal.");
    }

    fn solveNum(v: string, type: Type): Type
    {
        // TODO `f` suffix
        if (v) {}

        if (type.canon == t_f32.canon) return t_f32;

        return t_f64;
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
        solved(node,
             solveInt(node.value, type));

    fn solveNum(node: Node, type: Type): SolvedNode
        solved(node,
             solveNum(node.value, type));


    //

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefinit(
                add_ref(t_string, Lifetime_temporary));

        return solved(node, t_string);
    }

    fn createEmpty(kind = "empty", type = t_void, target?: Target): SolvedNode
    {
        return SolvedNode(
            :kind, :type, :target,
            token: _here || fail());
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }


    //

    fn Autocall_splice(ref name: string): string
    {
        for (mut i = 0; i < name.len; i++)
        {
            if (name[i] == '.')
            {
                let ret = name.slice(i + 1);
                name.shrink(i);
                return ret;
            }
        }

        fail("Autocall: no `.` in id `" ~ name ~ "`.");
    }

    fn uPrepFn_A(node: Node): SolvedNode
    {
        let id          = node.value;
        let local_of    = _current_fn.target.index;
        let isTemplate  = !!(node.flags & F_TEMPLATE);
        let status      = !isTemplate && SS_LAZY; // Actual template fns are eager.

        let N           = node.items.len + FN_ARGS_BACK;
        mut min         = 0;
        mut max         = N;

        mut args: Argument[];
        for (mut i = 0; i < N; i++)
        {
            let arg         = node.items[i];
            mut name        = arg.value || fail("TemplateDecl: no argname.");

            let autocall    = arg.flags & F_COMPOUND_ID && Autocall_splice(name);
            let annot       = arg.items[LET_TYPE];
            let init        = arg.items[LET_INIT];

            // Pre-typing template annots
            //  Perhaps do this lazily?
            let typed       = !(arg.flags & F_TEMPLATE);
            let type        = typed && annot && evalTypeAnnot(annot).type;
            let default     = typed && init  && solveNode(init, :type);
            args.push(Argument(:name, :autocall, :arg.flags, :type, :default));

            if (!arg.items[LET_INIT] && !(arg.flags & F_IMPLICIT))
                min++;

            if (arg.flags & F_REST_ARG)
                max = 0x7fffffff.i32;
        }

        //
        let template = createTemplate(node);

        let tDecl = Scope_add(_scope,
            kind: "template", :id, Type,
            :min, :max, :args, :template,
            :node.flags, :local_of, :status);

        // Experimental conversion functions.
        if (node.flags & F_CONVERSION)
            _scope.converts.push(tDecl);

        return createFnDef(
            token: node.token,
            target: tDecl,
            type: addroffn::X_addrofTarget(tDecl));
    }

    fn uPrepFn_B(target: Target)
    {
        ref template = GET_mut(target).template;
        if (template.scope_memo)
            template.scope_memo = Scope_snap(_scope);
    }

    fn createFnDef(token: TokenIdx, type: Type, target: Target): SolvedNode
    {
        return SolvedNode(kind: "fndef", :type, :target, :token);
    }


    //

    fn mangleArguments(args: [$T]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle ~= ",";

            mangle ~= serializeType(args[i].type);
        }

        return mangle;
    }

    fn mangleArguments(
        args: [SolvedNode], reorder: [i32],
        use_reorder: bool, conversions: Target[][],
        REST_START: i32, REST_TYPE: Type): string
    {
        mut mangle = "";

        let REST_END = use_reorder ? reorder.len : args.len;
        let N = REST_END.min(REST_START);
        for (mut i = 0; i < N; i++)
        {
            if (i)
                mangle ~= ",";

            let callsiteIndex = use_reorder ? reorder[i] : i;

            if (conversions.len > i && conversions[i].len)
                mangle ~= serializeType(
                    GET(conversions[i].last).type);

            else if (callsiteIndex >= 0 && callsiteIndex <= args.len)
                mangle ~= serializeType(
                    args[callsiteIndex].type);
        }

        if (REST_START < REST_END)
        {
            if (REST_START)
                mangle ~= ",";

            mangle ~= serializeType(REST_TYPE);
        }

        return mangle;
    }


    //

    fn is_SPECFAIL(target: Target): bool
    {
        return target.modid == -1;
    }

    fn trySpecialize(
        overloadIdx: Target, args: SolvedNode[], args_mangled: string,
        reorder: [i32], use_reorder: bool, conversions: Target[][],
        REST_START: i32, REST_TYPE: Type)
            : Target
    {
        // TODO memoize the whole mangle.
        //  Or use a hash here, perhaps nest them per template or smth.
        //   Also this prefix is nasty, unless we can reuse between modules.
        //
        // TODO perhaps reuse between modules?
        //  Would make the prefix stuff more meaningful.
        //
        let mangle = overloadIdx.modid ~ "#" ~ overloadIdx.index ~ " " ~ args_mangled;
        let spec = _specs[mangle] || doTrySpecialize(
            :overloadIdx, :args, :mangle,
            :reorder, :use_reorder, :conversions,
            :REST_START, :REST_TYPE);

        return !spec.is_SPECFAIL && spec;
    }


    //

    fn ScopeSkip_push(ref scope_skip: ScopeSkip[], start: i32, end: i32)
    {
        start <= end || fail("ScopeSkip_push: bad args.");
        if (end == start)
            return;

        let last = scope_skip.if_last;
        last.end <= start || fail("ScopeSkip_push: last.end > start.");

        // Opti - don't grow if possible, so we stay in small storage.
        if (scope_skip && last.end == start)
            scope_skip.last.end = end;
        else
            scope_skip ~= ScopeSkip(:start, :end);
    }

    fn ScopeSkip_setup(template: Template, scope0: ScopeMemo, isInline!: bool)
    {
        if (_root_scope)
        {
            let start = template.scope_memo || _root_scope;
            _ss = template.scope_skip;

            ScopeSkip_push(_ss.items,    start: start.items_len,    end: scope0.items_len);

            // The declash thing is for ease of codegen - not technically needed by the solver.
            //  This is what postfixes variable names with numbers to disambiguate them,
            //   and not pushing here means we'll declash against things we don't see in items above.
            if (!isInline)
                ScopeSkip_push(_ss.declash,  start: start.items_len,    end: scope0.items_len);

            ScopeSkip_push(_ss.imports,  start: start.imports_len,  end: scope0.imports_len);
            ScopeSkip_push(_ss.usings,   start: start.usings_len,   end: scope0.usings_len);
            ScopeSkip_push(_ss.converts, start: start.converts_len, end: scope0.converts_len);

            ScopeSkip_push(_ss.helpers,  start: start.helpers_len,  end: scope0.helpers_len);
        }

        // We'll need the original imports in scope
        //  in order to solve type params & pattern match below.
        for (mut i = 0; i < template.imports.len; i++)
            Scope_import(template.imports[i]);
    }


    //

    fn doTrySpecialize(
        into?: Target,
        overloadIdx?: Target, mut args?: SolvedNode[],
        mut mangle?: string, reorder?: [i32], use_reorder?: bool, conversions?: Target[][],
        REST_START?: i32, REST_TYPE?: Type)
            : Target
    {
        // TODO FIX reorder with gaps
        if (use_reorder)
        {
            mut reordered: SolvedNode[];
            for (mut i = 0; i < reorder.len; i++)
            {
                let callsiteIndex = reorder[i];
                reordered.push(
                    callsiteIndex >= 0 && callsiteIndex < args.len
                        && args[callsiteIndex]);
            }

            SWAP(args, reordered);
        }

        for (mut i = 0; i < conversions.len; i++)
        {
            let c = conversions[i];
            if (c)
            {
                ref a  = args[i];
                a.kind = "__conv";
                a.type = GET(c.last).type;
            }
        }

        if (REST_TYPE)
        {
            ref a  = args[REST_START];
            a.kind = "__rest";
            a.type = REST_TYPE;
        }

        //
        let args00 = args;
        let mangle00 = mangle;
        let SPECFAIL = Target(modid: -1, index: 0);

        //
        let original = GET(overloadIdx || into || fail());
        mut template = original.template;

        mut parent_idx = original.local_of;
        {
            // If we're taking a closure as an argument,
            //  we're becoming a closure ourselves of whatever that closure is closing over -
            //   so that e.g. lifetime reasoning can have an easier time etc.
            //
            // TODO all of these must form up a common shadowing group -
            //  So nothing by the same name should come in from outer scope,
            //   and yet none of these things shadow each other.
            //
            for (mut i = 0; i < args.len; i++)
            {
                let arg_t = args[i].type;
                if (addroffn::type_isAddrOfFn(arg_t))
                {
                    addroffn::unpackAddrOfFn(arg_t.canon, |target|
                    {
                        if (target.modid == module.modid)
                        {
                            let overload = GET(target);
                            if (overload.flags & F_SPREAD_INLINE)
                                template.node.flags |= F_INLINE;

                            let local_of = overload.local_of;
                            if (parent_idx < local_of)
                                parent_idx = local_of;
                        }
                    });
                }
            }
        }

        //
        let isInline = !!(template.node.flags & F_INLINE);

        fn setSpec(shadow mangle: string, target: Target, nx?: bool)
        {
            isInline && fail("inline.setSpec");

            ref t = _specs[mangle] ||= Target;

            fn id(shadow target)
                target.modid != -1  ? `"` ~ GET(target).name ~ `"`
                                    : "SPEC_FAIL";

            !t && nx || t.is_SPECFAIL && !nx || fail(
                "About to screw up royally, replacing spec: "
                    ~ t.index ~ " with " ~ target.index
                        ~ ", mangle: " ~ mangle ~ ", that's: "
                        ~ t.id ~ " becoming " ~ target.id);

            t = target;
        }

        if (!into && !isInline)
            setSpec(mangle, SPECFAIL, nx: true);

        // Scopes & scope skips.
        mut target: Target;

        {
            let scope0 = Scope_snap(_scope);
            let ss0 = _ss;

            defer {
                Scope_pop(_scope, scope0);
                _ss = ss0;
            }

            ScopeSkip_setup(:template, :scope0, :isInline);

            //
            let items = template.node.items;
            ref n_fn = template.node;
            n_fn.kind == "fn" || fail("n_fn not a `fn`.");

            //
            mut ok = true;
            mut typeParams: TypeParams;

            if (!into)
            {
                let kind    = template.node.kind;
                let numArgs = kind == "fn" ? items.len + FN_ARGS_BACK
                            : fail("TODO numArgs for template:" ~ kind);

                /////////////////
                // Literal fixup.
                mut retypeIndices: i32[];
                mut remangle = false;

                // First off, solve type params.
                for (   mut pass_retype  = 0;
                            pass_retype == 0 || pass_retype == 1 && retypeIndices;
                            pass_retype++)
                {
                //        /LITFIX
                /////////////////

                    for (mut i = 0; i < numArgs; i++)
                    {
                        if (pass_retype)
                        {
                            // TODO fix, .try_shift instead.
                            if (!retypeIndices.has(i))
                                continue;
                        }

                        let inValue = args.len > i && args[i];
                        mut inType  = inValue.type;

                        let argNode = items[i] || fail();
                        let annot   = argNode.items[LET_TYPE];

                        // We can lose mutrefs here if arguments are defaulted.
                        if (CANNOT_definit_mutrefs)
                            if (inType.is_mutref && argNode.items[LET_INIT])
                                inType = clear_mutref(inType);

                        /////////////////
                        // Literal fixup.
                        if (couldRetype(inValue))
                        {
                            let paramType =
                                annot.kind == "typeparam"
                                    ? typeParams[annot.value] ||= Type
                                    : annot.kind == "call" && !annot.items
                                        && Scope_lookupType(annot);

                            // Ignore literals if possible.
                            if (paramType)
                            {
                                let retype = tryRetyping(inValue, paramType);
                                if (retype && retype.canon != inType.canon)
                                {
                                    inType   = args[i].type = retype;
                                    remangle = true;
                                }
                            }

                            // Defer for second pass.
                            else if (!pass_retype)
                            {
                                retypeIndices.push(i);
                                continue;
                            }
                        }
                        //        /LITFIX
                        /////////////////

                        argNode.kind == "let"  || fail();

                        //
                        if (inType)
                        {
                            // Enable conversions on fully typed arguments.
                            let exactType = original.args[i].type;
                            if (exactType)
                            {
                                args[i].type = exactType;
                                continue;
                            }

                            //
                            let argName = argNode.value || fail();

                            // Same pattern - grabs a mutref.
                            ref argName_typeParam =
                                typeParams[argName] ||= Type;

                            // Values vs refs.
                            //  TODO actually this is rather stupid, isn't it,
                            //   what if it were all just refs and we did the copy internally,
                            //    only if necessary, and as late as possible.
                            if (argNode.flags & F_MUT)
                                inType = clear_refs(inType);
                            else
                                inType = add_ref(inType, Lifetime_temporary);

                            //
                            (argName_typeParam && fail(
                                "Type param name collision with argument: `" ~ argName ~ "`."))
                                    = inType;

                            // Type check.
                            if (annot)
                            {
                                let argOk = inType && trySolveTypeParams(
                                    annot, inType, typeParams);

                                ok = ok && argOk;
                                if (!ok && !remangle)
                                    break;
                            }
                        }
                    }
                }

                /////////////////
                // Literal fixup.
                if (remangle && !isInline)
                {
                    // TODO FIX
                    let start = mangle.find(' ') + 1 || fail();
                    mangle = mangle.slice(0, start) ~ mangleArguments(args);

                    if (mangle00 != mangle)
                    {
                        let preexisting = _specs[mangle] || Target();
                        if (preexisting)
                        {
                            setSpec(mangle00, preexisting);
                            return preexisting;
                        }

                        if (!into)
                            setSpec(mangle, SPECFAIL, nx: true);
                    }
                }
                //        /LITFIX
                /////////////////

                // Match pattern arm here.
                if (!ok)
                    return SPECFAIL;

                // Pattern matching.
                let body = items[items.len + FN_BODY_BACK] || fail();
                if (body.kind == "pattern")
                {
                    let undo = typeParams;
                    let branches = body.items;

                    mut did_match = false;
                    for (mut i = 0; i < branches.len; i++)
                    {
                        // Fails cond if any?
                        let cond = branches[i].items[0];
                        if (cond && !evalTypePattern(cond, typeParams))
                        {
                            typeParams = undo;
                            continue;
                        }

                        // Pass.
                        let cons = branches[i].items;
                        ref sig = n_fn.items;
                        {
                            let n_ret = cons[cons.len + FN_RET_BACK];
                            if (n_ret) sig[sig.len + FN_RET_BACK] = n_ret;

                            let n_body = cons[cons.len + FN_BODY_BACK];
                            sig[sig.len + FN_BODY_BACK] = n_body || fail("doTrySpec: no case/body.");
                        }

                        did_match = true;
                        break;
                    }

                    // All branches mismatch?
                    //  Can't return, faking RAII here.
                    if (!did_match)
                        return SPECFAIL;
                }
            }

            // Populate scope.
            let mangle0 = mangle;

            let extra_items = into
                ? original.extra_items
                : typeParams.intoScopeItems();

            // Prep reject.
            target = into || Scope_create(_scope, local_of: parent_idx,
                status: SS_DID_START | SS_LAZY, :extra_items);

            ////////////////////////////////////
            // Reset anon counters /////////////
            if (!_current_fn.target) _anons = 0;
            ////////////////////////////////////

            // Go!
            mut out = CurrentFn(
                solved(n_fn,
                    :target, type: addroffn::X_addrofTarget(target)));

            let root_scope0 = _root_scope;
            if (!root_scope0)
                _root_scope = scope0;

            SWAP(_current_fn, out);

            defer {
                SWAP(_current_fn, out);
                _root_scope = root_scope0;
            }

            /////////////////////////////////
            shadow ref outItems = _current_fn.items;
            if (into)
                outItems = GET(into).solved.items;

            let inItems = n_fn.items;
            outItems.resize(inItems.len);

            // Arg decls.
            _scope.items ~= extra_items;

            let spec = template.node.flags & F_TEMPLATE;
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                fn tryGetArgSpecType(id: string): Type
                {
                    mut param = "$" ~ id;
                    for (shadow mut i = 0; i < extra_items.len; i++)
                    {
                        let m = extra_items[i];
                        if (m.id == param)
                        {
                            let o = GET(m.target);
                            o.kind == "type"/* && o.max == 0*/ || fail(
                                "tryGetArgSpecType: Not a typeparam: `"
                                    ~ o.kind ~ ":" ~ param ~ "(" ~ o.max ~ ")`.");

                            return o.type;
                        }
                    }

                    return Type;
                }

                // Arg target reuse, because of the resolve loop:
                //  the strict retType equality checks lifetimes,
                //   and they are expressed in terms of scope positions:
                //    if we don't reuse arg targets, resolve loops forever.
                //
                ref preexisting = outItems[i];
                let reuse       = preexisting.target;
                if (reuse)
                    preexisting.kind == "let" && preexisting.flags & F_ARG || fail(
                        "__solveFn: arg target reuse: something is looking off.");

                let n_arg       = inItems[i];
                let specType    = spec && tryGetArgSpecType(n_arg.value);
                outItems[i]     = solveLet(n_arg, :specType, :reuse);
            }

            /////////////////////////////////////////////////////
            let n_ret   = inItems[inItems.len + FN_RET_BACK];
            let n_body  = inItems[inItems.len + FN_BODY_BACK];

            // Builtin?
            n_body || fail("solveFn: no body.");

            let native = n_body.kind == "call" && n_body.value == "__native";
            if (!native)
                n_body.kind == "block" || fail("solveFn: Body not a block: `" ~ n_body.kind ~ "`.");

            // Return type annot.
            let ret_expect = n_ret && evalTypeAnnot(n_ret).type;

            // Seed return value.
            mut ret_seed = n_ret    ? ret_expect || fail("falsy ret_expect: " ~ n_fn.value)
                                    : t_never;

            if (ret_seed.lifetime)
            {
                ret_seed.lifetime = native
                    ? Lifetime_fromNative(inItems, _current_fn.items[0, _current_fn.items.len + FN_ARGS_BACK], ret_seed)
                    : Lifetime_static(); // we'll overpromise during prep
            }
            else if (ret_seed.is_ref)
            {
                fail("fn.ret_actual is a ref without a lifetime.");
            }

            // Used twice, once to enable recursion before body, and once when done.
            fn updateScope(shadow out: CurrentFn, retval: Type)
            {
                shadow let items = out.items;

                let N = items.len + FN_ARGS_BACK;
                mut min = 0;
                mut max = N;
                shadow mut args: Argument[];

                for (mut i = 0; i < N; i++)
                {
                    let argNode = items[i];
                    argNode.kind == "let" || fail();

                    mut name        = argNode.value;
                    let autocall    = argNode.flags & F_COMPOUND_ID && Autocall_splice(name);
                    let isImplicit  = !!(argNode.flags & F_IMPLICIT);

                    let arg = Argument(
                        :name,
                        :autocall,
                        :argNode.flags,
                        :argNode.type || fail(),
                        default: !isImplicit && argNode.items[LET_INIT]);

                    if (!arg.default && !isImplicit)
                        min++;

                    if (arg.flags & F_REST_ARG)
                        max = 0x7fffffff.i32;

                    args.push(arg);
                }

                // Unconditionally replacing the stuff.
                ref overload    = GET_mut(target);

                let retval0     = overload.type;
                let args_len0   = overload.args.len;
                let closure0    = overload.closes_over.len;

                overload.min    = min;
                overload.max    = max;
                overload.args   = args;

                overload.type   = retval;
                if (isInline)
                    return;

                retval || fail("FnDecl_update: no return type.");
                if (retval.is_ref)
                    Lifetime_test(retval.lifetime);

                overload.flags  = out.flags;
                overload.solved = out.out;

                // See which one of the locals we've used are not our own.
                {
                    mut closes_over: i32[];

                    for (mut i = 0; i < out.locals_used.len; i++)
                    {
                        let o = GET_local(out.locals_used[i]);
                        if (o.local_of != target.index)
                            closes_over ~= out.locals_used[i];
                    }

                    overload.closes_over = closes_over;
                }

                if (overload.used_by)
                {
                    // TODO FIX starting the diff with just number of arguments,
                    //  which is fine for implicit cycling,
                    //   then we gotta move on to bigger and better things.
                    if (args_len0 != overload.args.len          ||
                        closure0  != overload.closes_over.len   ||
                        !(retval0 == overload.type))
                    {
                        overload.status |= SS_UPDATED;
                    }
                }
            }

            // Enable recursion.
            let firstIteration = !GET(target).solved;
            if (firstIteration)
            {
                // Previously initScope:
                {
                    // TODO FIX currently we only hash template names.
                    mut name = n_fn.value || fail("TODO anonymous fns");
                    if (spec && !native && !isInline)
                    {
                        let sig = mangleArguments(outItems[0, outItems.len + FN_ARGS_BACK]);
                        if (sig)
                        {
                            let hash = tea::hash62(sig, chars: 4) || fail();
                            name ~= "_" ~ hash;
                        }
                    }

                    ref overload        = GET_mut(target);
                    overload.name       = isInline ? ANON() : name;
                    overload.kind       = native ? "__native" : isInline ? "inline" : "fn";
                    overload.template   = native ? createTemplate(n_body) : template;
                }

                updateScope(_current_fn, retval: isInline ? ret_expect : ret_seed);

                // setSpecs & co.
                if (!into && !isInline)
                {
                    let start   = mangle0.find(' ') + 1 || fail();
                    mangle      = mangle0.slice(0, start)
                                ~ mangleArguments(GET(target).args);

                    mut preexisting: Target;
                    if (mangle0 != mangle)
                    {
                        preexisting = _specs[mangle] || Target();
                        setSpec(mangle0, preexisting || target);
                    }

                    let nx = mangle00 != mangle;
                    if (nx && mangle00 != mangle0)
                        setSpec(mangle00, preexisting || target);

                    if (preexisting)
                        return preexisting;

                    setSpec(mangle, target, :nx);
                }
            }

            // Regular fns again.
            if (!isInline)
            {
                // The usual.
                mut retval = ret_seed;
                if (!native)
                {
                    let s_body = solveBlock(
                        n_body, type: ret_expect,
                        fnbody_of: target.index,
                        mask: i16(HM_Function | HM_CanReturn | HM_LabelUsed | (n_fn.flags & F_LAMBDA && HM_Lambda)));

                    retval = s_body.type;

                    // MUT DURING SOLVE,
                    //  implicit args splice in
                    outItems[outItems.len + FN_BODY_BACK] = s_body || fail("falsy body");
                }

                // TODO THIS APPEARS TO BE USELESS, sighash not computed in update.
                //  Sighashes include return value.
                outItems[outItems.len + FN_RET_BACK] =
                    createEmpty(type: retval);

                //
                updateScope(_current_fn, :retval);
            }
        }

        // Go!
        ref o = GET_mut(target);
        lazySolveEnd(o);
        return target;
    }


    //

    fn intoScopeItems(typeParams: TypeParams): ScopeItem[]
    {
        mut res: ScopeItem[];

        typeParams.pairs(|id, type|
        {
            let name = "$" ~ id;

            fn checkStruct(shadow type: Type)
            {
                // TODO FIX The thing is the type param might not be the naked value type,
                //  but e.g. a reference or something. It's muddy what we have right now.
                //   Consider getting rid of the $argname params, should obsolete this.
                //
                let t = lookupStruct(type).target;
                return GET(t).type == type && t;
            }

            let target = type.isStruct
                && checkStruct(type)
                || Scope_Typedef(_scope,
                    id: "", // dont Scope_add
                    name: "$" ~ id, :type, flags: 0);

            Scope_set(res, name, :target, shadows: false);
        });

        return res;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(solve: false, :node);
    }

    fn __solveStruct(solve!: bool, /*TODO BORROWCK danglefix*/mut node: Node, into?!: Target): SolvedNode
    {
        mut out     = solved(node, target: into, type: into && GET(into).type);

        let origId  = node.value;
        let name    = origId || _current_fn.target && GET(_current_fn.target).name || "Anon";

        if (!out.target)
        {
            let template = createTemplate(:node);

            out.type && assert();
            out.type = initStruct(:name, :node.flags, :SELF_TEST);

            out.target = Scope_Typedef(_scope, id: origId, :name,
                :out.type, :node.flags, :template,
                status: SS_LAZY);
        }

        if (!solve)
            return out;

        GET_mut(out.target).status |= SS_DID_START;

        ///////////////////////////////////////////////
        let    helpers0 = _helpers.len;
        defer _helpers.shrink(helpers0);

        _helpers ~= Helpers(mask: HM_Struct, target: out.target.index || fail(
            "solveStruct: no out.target: `" ~ origId ~ "`."));
        ///////////////////////////////////////////////

        // Struct fields only.
        mut structConverts: Target[];
        mut structImports:  i32[];

        // Struct members, pass 0.
        fn solveMember(shadow node: Node)
        {
            node.kind == "let" || fail("solveStructMembers_1: " ~ node.kind);

            node.items[LET_INIT] &&
            node.items[LET_INIT].kind != "definit" &&
                fail("All structs must be zerofilled by default."
                    ~ " Please remove the initializer of struct member `" ~ node.value ~ "`.");

            // Can't continue/return back/fwd compat.
            return solveLetLike_dontTouchScope(node);
        }

        let members = node.items.map(fn solveMember);

        // (Re)poplate fields.
        {
            ref innerScope = lookupStruct_mut(out.type.canon).items;
            if (!innerScope && members)
            {
                // Dereferencing a struct does not require it
                //  to have any particular qualities.
                let args = [ Argument(name: "this",
                    type: despeculateStruct(out.type)) ];

                for (mut i = 0; i < members.len; i++)
                {
                    let id = node.items[i].value;
                    let target = Scope_create(
                        _scope, "field", name: id || fail(),
                        min: 1, max: 1, flags: F_PUB, :args);

                    Scope_set(innerScope, :id, :target, shadows: false);
                }

                _field_items ~= innerScope;
            }

            // Update field types.
            innerScope.len == members.len || fail(
                "solveStructMembers_3: field lens mismatch: " ~ innerScope.len ~ " vs " ~ members.len ~ "/" ~ node.items.len ~ ": `struct " ~ name ~ "`.");

            for (mut i = 0; i < innerScope.len; i++)
            {
                let item = innerScope[i];
                shadow let member = members[i];
                item.id == member.value || fail("solveStructMembers_4: field id mismatch.");

                ref field = GET_mut(item.target);
                field.type = member.type;

                if (member.flags & F_USING)
                {
                    structConverts.push(item.target);

                    if (field.type.modid != module.modid)
                        structImports.set::add(field.type.modid);

                    structImports.set::add(field.type.lookupTypeImports());
                }
            }
        }

        // Add a default constructor.
        {
            mut commonQuals = -1;
            for (mut i = 0; i < members.len; i++)
                commonQuals &= members[i].type.quals;

            let quals0 = out.type.quals;
            let quals1 = out.type.quals &= commonQuals;

            //
            {
                ref s       = lookupStruct_mut(out.type.canon);
                s.target    = out.target || fail("No struct/out.target.");
                s.converts  = structConverts;
                s.imports   = structImports;

                GET(s.target).status & SS_DID_START || fail(
                    "Setting stuff but missing SS_DID_START.");
            }

            //
            let max = members.len;
            mut min = 0;
            mut args: Argument[];

            for (mut i = 0; i < members.len; i++)
            {
                let member = members[i];

                let arg = Argument(
                    name:       member.value || fail(),
                    type:       member.type  || fail(),
                    default:    member.items[LET_INIT],
                    flags:      member.flags & F_MUSTNAME);

                if (!arg.default)
                    min++;

                args.push(arg);
            }

            if (max && !min) min++;

            ref overload    = GET_mut(out.target);
            overload.min    = min;
            overload.max    = max;
            overload.args   = args;
            overload.type   = out.type;

            if (overload.used_by)
                if (quals0 != quals1)
                    overload.status |= SS_UPDATED;
        }

        //
        lazySolveEnd(GET_mut(out.target));

        // We're done here, return nothing.
        return SolvedNode();
    }


    //

    fn lazySolveStart(target: Target, overload: Overload): bool
    {
        // Isn't lazy-started?
        if (overload.status & (SS_DID_START | SS_LAZY) != SS_LAZY)
            return false;

        {
            ref o = GET_mut(target);
            o.status & (SS_FINALIZED | SS_DID_START | SS_DIRTY) && fail("SS_DID_START: non-zero solver status: " ~ overload.status);
            o.status |= SS_DID_START;

            if (o.kind == "template" || o.kind == "fn")
                doTrySpecialize(into: target);
            else if (o.kind == "type")
                __solveStruct(solve: true, :o.template.node, into: target);
            else
                fail("lazySolveStart: kind is `" ~ o.kind ~ "`.");
        }

        // Expect changes.
        return true;
    }

    fn lazySolveEnd(ref o: Overload): void
    {
        mut reopen: i32[];

        let parent = o.local_of;
        if (o.status & SS_UPDATED)
        {
            o.status &= ~SS_UPDATED;

            NEXT_USER:
            for (mut i = 0; i < o.used_by.len; i++)
            {
                mut index = o.used_by[i];

                GO_UP:
                for (;;)
                {
                    shadow ref o = GET_mut(
                        Target(:module.modid, :index));

                    // If not started or dirty, means someone else will take care of us here.
                    if (o.status & (SS_DID_START | SS_DIRTY) != SS_DID_START)
                        continue :NEXT_USER;

                    // If still solving somewhere up our callstack, just flag as dirty.
                    if !(o.status & SS_FINALIZED)
                    {
                        o.status |= SS_DIRTY;
                        continue :NEXT_USER;
                    }

                    // Climb up until sibling (or self) -
                    //  this is A->B->C being invalidated by A->D:
                    //   can't just reopen C here, because we don't have B in scope,
                    //    so we have to invalidate B.
                    let up = o.local_of;
                    if (up != parent) // !sibling
                    {
                        up > parent || fail("lazySolveEnd: about to climb up the wrong tree.");
                        index = up;
                        continue :GO_UP;
                    }

                    // Finally, a finalized, non-local of self,
                    //  gotta reopen & resolve now.
                    _notes |= o.kind == "type" ? N_TypeReopen : N_FnReopen;

                    o.status &= ~(SS_DID_START | SS_DIRTY | SS_FINALIZED);
                    reopen ~= index;

                    continue :NEXT_USER;
                }
            }
        }

        //
        if !(o.status & SS_DIRTY)
        {
            o.status |= SS_FINALIZED;
        }
        else
        {
            o.status & SS_FINALIZED && fail("Stray SS_FINALIZED.");
            o.status &= ~(SS_DID_START | SS_DIRTY);
            _notes |= o.kind == "type" ? N_TypeResolve : N_FnResolve;
        }

        //
        for (mut i = 0; i < reopen.len; i++)
        {
            let t = Target(:module.modid, index: reopen[i]);
            lazySolveStart(t, GET(t));
        }
    }

    fn isFnOrType(h: Helpers): bool
        !!(h.mask & (HM_Function | HM_Struct));

    fn detectRecursion(target: Target, overload: Overload): void
    {
        if (overload.status & (SS_FINALIZED | SS_LAZY) != SS_LAZY)
            return;

        // TODO FIX Incorrect: fns can use other fns as type annots.
        //  We need to somehow track who depends on others for type info,
        //   and who depends on others for actual compute.
        let note    = overload.kind == "type" ? N_TypeRecursion : N_FnRecursion;
        let status  = overload.kind == "type" ? SS_TYPE_RECUR   : SS_FN_RECUR;

        for (mut i = _helpers.len; i --> 0; )
        {
            let h = _helpers[i];
            if !(h.isFnOrType)
                continue;

            h.mask & HM_Lambda && fail("Recursive lambda, what happened here?");
            GET_mut(Target(:module.modid, index: h.target)).status |= status;
            _notes |= note;

            if (h.target == target.index)
                return;
        }

        fail("detectRecursion: no _helpers entry for `" ~ overload.name ~ " (" ~ overload.status ~ ")`.");
    }


    //////////////////////////////////////////////////////////
    //
    // Note - as soon as we re-assign the return value,
    //  we want to re-iterate all the return statements,
    //   because that can change our copy/move decision.

    fn superType(reason: string, a: Type, b: Type)
    {
        return type_trySuper(a, b) || fail(reason
            ~ "No common supertype: `"
            ~ serializeType(a) ~ "` <-> `" ~ serializeType(b) ~ "`.");
    }

    fn solveJump(node: Node, kills: i32): SolvedNode
    {
        mut helpers_idx = node.kind == "return"
            ? Scope_lookupReturn(node.value, lambdaOK: !!(node.flags & F_SINGLE_STMT))
            : Scope_lookupLabel (node.value, cont: node.kind == "continue");

        /////////////////////////////
        fn h() _helpers[helpers_idx];
        /////////////////////////////

        // Deal with expression first, might noop the jump.
        mut expr = node.items && solveNode(
            node.items.only,
            type: h.ret_actual || h.ret_expect,

            // Kills is +1 so that kills=0 means noone.
            kills: helpers_idx + 1);

        // Dead code elim.
        if (expr.type.is_never)
            return expr;

        // This kinda does it for return non-expression.
        let redundant = kills == helpers_idx + 1;
        if (redundant && expr.type.is_void)
            return expr;

        // In { a { b { c }}}, c kills b kills a.
        while (h.kills)
            helpers_idx = h.kills - 1;

        // TODO FIX see how functions are special,
        //  if we could get rid of the compulsory returns this would clean up nicely.
        if (redundant && !(h.mask & HM_Function))
            return expr;

        // Lazy labels.
        mut target: Target(-1, -1);

        target.left = h.target ||=
            Scope_addLabel(h.id, :h.local_of).index;

        h.mask |= HM_LabelUsed;

        if (!node.items)
        {
            reportReturnType(:helpers_idx, t_void);
            return createJump(:node.token, :target);
        }

        if (expr.type.is_ref)
        {
            let ltCompare = expr.type.lifetime.Lifetime_compareToIndex(target.left);
            if (ltCompare >= 0)
            {
                if (ltCompare > 0)
                {
                    expr = createMove(expr);
                }
                else
                {
                    // Might survive, so we cant move,
                    //  might not survive, so we can't return reference,
                    //   so we have to copy.
                    //
                    // We'll try to prevent this from happening by hinting control flow
                    //  primitives such as and/or/ifs to copy preemptively
                    //   but this can happen after lt replace on callsite,
                    //    when return might point to a temporary argument.
                    //
                    expr = createCopy(expr);
                }
            }
        }

        reportReturnType(:helpers_idx, expr.type);

        target.right = Scope_create(_scope, "jump",
            local_of: target.left || fail(),
            solved: expr).index;

        h.returns ~= target.right;

        return createJump(:node.token, :target);
    }

    fn createJump(token: TokenIdx, target: Target)
    {
        return SolvedNode(:token, "jump", type: t_never, :target);
    }

    fn resetReturns(helpers_idx: i32, ret_actual?!: Type, ret_expect?!: Type)
    {
        ref h = _helpers[helpers_idx];

        h.ret_actual = ret_actual;
        h.ret_expect = ret_expect;
    }

    fn reportReturnType(helpers_idx: i32, type: Type)
    {
        ref h = _helpers[helpers_idx];

        // Regular block expects are best-effort type inference hints,
        //  whereas fn expects are explicit type annotations that must be enforced.
        if (h.ret_expect && h.mask & HM_Function)
            checkAssignable(host: h.ret_expect, type,
                "Expression not assignable to return annotation");

        h.ret_actual = h.ret_actual
            ? superType("Subsequent return: ", h.ret_actual, type)
            : type;

        h.ret_actual || fail("Can't be null past this point.");
    }


    //////////////////////////////////////////////////////////

    fn checkAssignable(
        host: Type, guest: Type, err: string,
        id?: string, sep?: string)
    {
        isAssignable(
            :host   || fail("Bad host type."),
            :guest  || fail("Bad guest type."))
                    || fail(err ~ (id && " `" ~ id ~ "`") ~ ": "
                                ~ host .humanizeType() ~ (sep || " <- ")
                                ~ guest.humanizeType());
    }


    // Loops.

    fn Scope_addLabel(id: string, local_of!: i32): Target
    {
        return Scope_create(_scope, "label",
            name: id || ANON(),
            type: Type, flags: F_SHADOW, :local_of);
    }

    fn Scope_lookupReturn(id: string, lambdaOK: bool): i32
    {
        _helpers.reveach(_ss.helpers, |item, i|
        {
            if !(item.mask & HM_CanReturn)
                continue;
            if (item.mask & HM_Lambda && !lambdaOK)
                continue;
            if (id && item.id != id)
                continue;

            return i;
        });

        fail("No return `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupLabel(id: string, cont!: bool): i32
    {
        mut CONTINUE_BELOW: i32;

        _helpers.reveach(_ss.helpers, |item, ref i|
        {
            // Continue into first return when possible,
            //  this comparison works because of the scope skips.
            if (i < CONTINUE_BELOW - 1)
                i++;

            if !(item.mask & HM_CanBreak)
            {
                if (!CONTINUE_BELOW)
                {
                    if (id || !(item.mask & HM_Lambda))
                        continue;

                    // Lambda break & continue.
                    if !(cont)
                    {
                        CONTINUE_BELOW = i;
                        continue;
                    }
                }

                return i;
            }

            if (!CONTINUE_BELOW)
            {
                if !(id ? item.id == id : item.mask & HM_Anon != 0)
                    continue;

                if (cont)
                {
                    i++;
                    i < _helpers.len || fail("Cannot continue to label `" ~ id ~ "` from here, did you mean to `break`?");
                }
            }

            return i;
        });

        fail("No label `" ~ id ~ "` in scope.");
    }

    fn solveArgID(node: Node, type: Type): SolvedNode
    {
        let expr = solveNode(node.items.only, :type);
        return solved(node, [ expr ], :expr.type);
    }

    fn solveLoop(node: Node): SolvedNode
    {
        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        // TODO really consider getting rid of this,
        //  ideally we'll only have labels on blocks -
        //   the continues-map-to-inner-block thing.
        let brk_idx     = _helpers.len;
        _helpers       ~= Helpers(id: node.value, mask: HM_Anon|HM_CanBreak, local_of: _current_fn.target.index);

        let n_init      = node.items[LOOP_INIT];
        let n_pre_cond  = node.items[LOOP_COND];
        let n_body      = node.items[LOOP_BODY];
        let n_post_cond = node.items[LOOP_POST_COND];
        let n_post      = node.items[LOOP_POST];

        let init        = n_init      && solveLetStatement(n_init);
        let pre_cond    = n_pre_cond  && solveNode(n_pre_cond,  t_bool);
        let body        = n_body      && solveBlock(n_body, type: t_void);
        let post_cond   = n_post_cond && solveNode(n_post_cond, t_bool);
        let post        = n_post      && solveNode(n_post,      t_void);

        // Control flow.
        let h           = _helpers[brk_idx];
        let label_used  = h.mask & HM_LabelUsed;
        let type        = !pre_cond && !post_cond && !label_used
                            ? t_never
                            : t_void;

        return solved(node, type,
            [ init, pre_cond, body, post_cond, post ],
                target: label_used && Target(:module.modid, h.target));
    }


    // Exotic loops.

    fn solveForFieldsOf(node: Node): SolvedNode
    {
        fn astReplace(shadow node: Node, mutate): Node
        {
            fn walk(shadow ref node: Node)
            {
                for (mut i = 0; i < node.items.len; i++)
                    walk(node.items[i]);

                mutate(node);
            }

            shadow mut node = node;
            walk(node);
            return node;
        }

        let placeholder     = node.value;
        let body_template   = node.items[1];
        let fields_of       = evalTypeAnnot(node.items[0]).type;
        fields_of.isStruct || fail("[for fieldname]: This is not a struct: `" ~ serializeType(fields_of) ~ "`.");

        let fields          = lookupStruct(fields_of).items;

        mut items_ast: Node[];
        for (mut i = 0; i < fields.len; i++)
        {
            let field = fields[i];
            if (GET(field.target).kind == "field")
            {
                items_ast ~= astReplace(body_template, |ref item: Node|
                {
                    if (item.value == placeholder)
                    {
                        if (item.items.len == 1 && item.kind == "call")
                        {
                            // TODO field access syntax disables any kind of scope lookup but fields,
                            //  otherwise we risk miscellaneous stuff randomly breaking templates for no good reason.
                            //
                            // if (item.flags & F_ACCESS)
                            //     item.flags |= F_NOSCOPE;
                            //
                            item.value = field.id;
                        }
                        else if (item.kind == "str")
                        {
                            // String literals, potentially useful for serialization.
                            item.value = field.id;
                        }
                    }
                });
            }
        }

        // Control flow & deadcode elim.
        //  TODO break & continue.
        let items = solveNodes(items_ast, deadcode_on_never: true);
        let type  = items.last.type.is_never ? t_never : t_void;

        return createBlock(node.token, type, items);
    }


    //

    fn solveLetLike_dontTouchScope(
        node: Node, specType?!: Type,
        deadcode_on_never?!: bool): SolvedNode
    {
        let n_annot = node.items[LET_TYPE];
        mut annot   = specType || n_annot && evalTypeAnnot(n_annot).type;

        if (annot && node.flags & F_REF)
            annot   = add_mutref(annot, Lifetime_temporary);

        let n_init  = node.items[LET_INIT];
        let init    = n_init && solveNode(n_init, annot);

        return solveLetLike_dontTouchScope(
            :node.token, node.value, :node.flags,
            :annot, :init,
            :specType, :deadcode_on_never);
    }

    fn solveLetLike_dontTouchScope(
        token: TokenIdx, id: string, mut flags: i32,
        mut init!: SolvedNode,
        mut annot?!: Type, specType?!: Type,
        deadcode_on_never?!: bool): SolvedNode
    {
        annot || init.type || fail(
            "Variable declarations without type annotations must be initialized: `" ~ id ~ "`.");

        if (annot && init.type)
        {
            if (specType)
            {
                // Kinda arbitrary -
                //  if init expr doesn't resolve to a mutref,
                //   infer we want no mutref under any circumstance,
                //    this should help herd the specs a little.
                if (specType.is_mutref && !init.type.is_mutref)
                    annot = clear_mutref(annot);

                // Drop defaults that don't match current spec types,
                //  this will effectively make the args non-defaulted.
                if (!isAssignable(host: annot, init.type))
                    init = SolvedNode();
            }               // ^
                            // |
            if (init.type)  // | Might be dropped here.
            {
                checkAssignable(host: annot, init.type,
                    "Type annotation does not match init expression",
                        id, "=");

                annot.lifetime = init.type.lifetime;
            }
        }

        let killref = init.type.is_ref2temp();

        // Dead code elim.
        if (deadcode_on_never && init.type.is_never)
        {
            _notes |= N_DeadLet;
            return init;
        }

        if (flags & F_REF)
        {
            init.type.is_mutref || init.type.is_never && annot
                                || !init && flags & F_ARG || fail(
                "`ref` variables must be initialized to a mutable reference: `" ~ id ~ "`"
                    ~ (init.type ? " = " ~ humanizeType(init.type) : "."));

            killref && fail(
                "`ref` varibles cannot bind to temporaries.");
        }

        //
        let t_let   = annot
                        ? flags & F_ARG && !(flags & F_MUT)
                            ? add_ref(annot, Lifetime_temporary)
                            : annot
                    : init.type.is_mutref || flags & F_MUT || killref
                        ? flags & F_REF && !killref
                            ? init.type
                            : USE_ref_to_mutref && !(flags & F_MUT) && !killref
                                ? clear_mutref(init.type)
                                : clear_refs(init.type)
                        : flags & F_ARG && !(flags & F_MUT)
                            ? add_ref(init.type, Lifetime_temporary)
                            : init.type;

        // TODO clean this up: inliner broke for `v: &mut T` arg annots,
        //  which don't have the F_REF flag, which drops the mutrefness here on createLet.
        //
        // Best way to fix is to use the original argument type on createLet,
        //  search for TODO__ORIGINAL_ANNOT_OR_TYPE
        if (t_let.is_mutref)
            flags |= F_REF;

        if (init)
            maybeCopyOrMove(init, t_let);

        // TODO clean this up, annots not needed.
        //  We could move init out of here?
        //   So we can edit out of order maybe?
        return SolvedNode(
            kind: "let", value: id, :flags, :token,
            type: t_let, items: [ SolvedNode, init ]);
    }

    fn solveLet(node: Node, specType?!: Type, reuse?!: Target, deadcode_on_never?!: bool): SolvedNode
    {
        let out = solveLetLike_dontTouchScope(node, :specType, :deadcode_on_never);
        let id  = out.value;

        return solveLet(:out, :id, :reuse, :deadcode_on_never);
    }

    fn solveLet(mut out!: SolvedNode, id!: string, reuse?!: Target, deadcode_on_never?!: bool): SolvedNode
    {
        // Dead code elim.
        if (out.kind != "let")
        {
            if (SELF_TEST)
                deadcode_on_never && out.type.is_never || fail(
                    "solveLet: results in a `" ~ out.kind ~ ": " ~ id ~ "`.");

            return out;
        }

        !out.type.is_ref || out.type.lifetime || fail(
            "solveLet: ref without lifetime: `" ~ id ~ "`.");

        mut shadows = !!(out.flags & F_SHADOW);

        // TODO FIX: AUTOCALL ////////
        let cleanID = out.flags & F_COMPOUND_ID && id.slice(0, id.find('.'));
        shadow let id = cleanID || id;
        //////////////////////////////

        if (!addroffn::X_unpackAddrOfFnBinding(_scope.items, id, out.type, :shadows))
        {
            ////////////////////////////////////////////////////////////////
            if (OPTI_dedupe_vars && !(out.flags & F_ARG))
            {
                let init = out.items[LET_INIT];
                if (init.kind == "call" && !init.items)
                {
                    let target  = init.target;
                    let other   = GET(target);

                    if (other.kind == "var")
                    {
                        if (isAssignable(host: other.type, out.type))
                        {
                            // println("VARFOLD " ~ id ~ ": " ~ humanizeType(out.type)
                            //                    ~ " := " ~ other.name ~ ": " ~ humanizeType(other.type));

                            Scope_set(_scope, :id, :target, :shadows);
                            if (out.flags & F_USING)
                                _scope.usings.push(target);

                            return createEmpty();
                        }
                    }
                }
            }
            ////////////////////////////////////////////////////////////////

            let target = out.target = Binding(:id, :out.flags, :out.type, :reuse, :shadows);

            // TODO FIX global inits, why the whole thing? Get rid of this.
            //  Currently need init for out-of-module cg, but this here is lame.
            ref overload = GET_mut(target);
            if (!overload.local_of)
                overload.solved = out;

            Scope_set(_scope, :id, :target, :shadows);
            if (out.flags & F_USING)
                _scope.usings.push(target);
        }

        return out;
    }

    fn createLet(id: string, flags: i32, init: SolvedNode)
    {
        let out = solveLetLike_dontTouchScope(:init.token, :flags, :id, :init);
        return solveLet(:out, :id);
    }


    //

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);

        // TODO FIX see the typeparams stuff, its the same mess.
        if (annot.type.isStruct)
            Scope_set(_scope, node.value, lookupStruct(annot.type).target, shadows: false);
        else
            Scope_Typedef(_scope, node.value, annot.type, node.flags);

        return createEmpty();
    }

    fn solveLetStatement(node: Node): SolvedNode
    {
        node.kind == "let" || fail("Expected a `let` statement, got: `" ~ node.kind ~ "`.");
        return solveNode(node, t_void);
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok = solveLetStatement(node.items[0]);

        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let var_err = solveLetStatement(node.items[1]);
        let catch   = solveNode(node.items[2]);

        let type = var_ok.type;
        catch.type.is_never || fail(
            "[let catch]: catch clause must exit local scope.");

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, type,
            [ var_ok, var_err, catch ]);
    }

    fn solveTryCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        /////////////////////////////////
        let scope0  = Scope_snap(_scope);
        /////////////////////////////////

        let try     = solveNode(node.items[0]);

        ///////////////////////////////////////
        Scope_pop(_scope, scope0);
        shadow let scope0 = Scope_snap(_scope);
        ///////////////////////////////////////

        let err     = solveLetStatement(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        err.kind == "let" && isAssignableAsArgument(
            host: err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        let type    = try.type.is_never && catch.type.is_never
                        ? t_never
                        : t_void;

        return solved(node, type, [ try, err, catch ]);
    }

    fn findModule(fuzimport: string): &Module
    {
        let fname = resolveFile_x(fuzimport);

        let modules = ctx.modules;
        for (mut i = 1; i < modules.len; i++)
        {
            let m = modules[i];
            if (m.fname == fname)
                return m;
        }

        fail("Cannot locate: " ~ fname);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let m = findModule(fuzimport: node.value);
        Scope_import(m.modid);

        //
        return createEmpty();
    }

    fn solveDefer(node: Node): SolvedNode
    {
        // TODO unless defer:ok, must be noexcept
        let item = solveNode(node.items.only);
        return solved(node, t_void, [ item ]);
    }


    // TODO we have to get rid of this.

    fn Scope_lookupType(mut id: string, flags: i32 = 0): Type
    {
        mut scope_iterator: i32;
        mut overloadIdx: Target;
        mut shadows: bool;

        let qualified = flags & F_COMPOUND_ID;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        while (overloadIdx =
            scope.items.search(id, scope_iterator,
                scope_skip: !qualified && _ss.items, :shadows))
        {
            let maybe = GET(overloadIdx);
            if (maybe.kind == "type")
                return maybe.type || fail();
        }

        return fail("No type `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupType(annot: Node): Type
    {
        return Scope_lookupType(annot.value, :annot.flags);
    }


    //

    fn evalTypeParam(id: string, typeParams?: TypeParams): Type
    {
        return typeParams[id] || Scope_lookupType(
                    "$" ~ (id || fail("Falsy type param id.")))
                              || fail("No type param `$" ~ id ~ "` in scope.");
    }

    fn solveTypeParam(node: Node): SolvedNode
    {
        return solved(node, evalTypeParam(node.value));
    }

    fn solveAddrOfFn(node: Node): SolvedNode
    {
        let id = node.value;

        mut shadow = false;
        mut result: Target[];

        // Visit local scope.
        fn visitScope(items: [ScopeItem])
        {
            mut scope_iterator: i32;
            mut target: Target;
            mut shadows: bool;
            while (!shadow && (target = items.search(
                :id, :scope_iterator, scope_skip: _ss.items, :shadows)))
            {
                // Can't shadow here -
                //  shadowing works per signature,
                //   we can't just shadow everything by the same name in scope.
                result.push(target);
            }
        }

        visitScope(_scope.items);

        // TODO FIX:
        //  emit a regular lambda instead.
        if (node.flags & F_ACCESS)
        {
            // Iterate all visible types, this is slow.
            //  Alternatively we could just unwrap all of these things in
            //   module root scope but that'd slow everything else down.
            fn visitTypes(shadow module: Module)
                module.out.types.each(
                    |struct| visitScope(struct.items));

            // From this module ...
            visitTypes(module);

            // ... and all visible imports.
            _scope.imports.each(_ss.imports,
                |import| visitTypes(ctx.modules[import]));
        }

        //
        result || fail("No `fn " ~ id ~ "` in scope.");

        let type = Type(ValueType(quals: 0, modid: 0, canon: addroffn::packAddrOfFn(result)));
        return createEmpty(:type);
    }


    //

    fn evalTypeAnnot(node: Node, typeParams?: TypeParams): SolvedNode
    {
        fn T(i: i32 = 0) evalTypeAnnot(node.items[i], typeParams).type;

        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len == 1)
            {
                if (node.value == "&")
                    return solved(node, add_ref(T, Lifetime_temporary));

                if (node.value == "&mut")
                    return solved(node, add_mutref(T, Lifetime_temporary));

                if (node.value == "[]")
                    return solved(node, createArray(T));
            }
            else if (items.len == 2)
            {
                if (node.value == "Map")
                    return solved(node, createMap(T(0), T(1)));
            }

            return solveCall(node);
        }
        else if (node.kind == "typeparam")
        {
            return solved(node, evalTypeParam(node.value, typeParams));
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            return solved(node, createSlice(T, Lifetime_temporary));
        }

        return fail("TODO evalTypeAnnot: " ~ node.kind ~ "[" ~ node.items.len ~ "]");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, ref typeParams: TypeParams): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    mut t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : fail("TODO trySolveTypeParams unary call");

                    if (!t)
                        return false;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                return isAssignable(
                    Scope_lookupType(node),
                        type);
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            ref _param = (typeParams[id] ||= Type);
            if (_param)
            {
                let inter = type_trySuper(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = tryClear_sliceable(type);
            return t && trySolveTypeParams(
                node.items[0] || fail(), t, typeParams);
        }

        return fail("TODO trySolveTypeParams fallthrough");
    }

    fn evalTypePattern(node: Node, ref typeParams: Map(string, Type)): bool
    {
        if (node.kind == "and")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i], typeParams))
                    return false;

            return true;
        }
        else if (node.kind == "or")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (evalTypePattern(node.items[i], typeParams))
                    return true;

            return false;
        }
        else if (node.kind == "typeassert")
        {
            let left  = node.items[0] || fail();
            let right = node.items[1] || fail();

            // We'll have to figure out the type tag nonsense at some point.
            //  Perhaps when we have an `any` type,
            //   we could subtype it with the desired quals.
            if (left.kind  == "typeparam" && right.kind == "typetag")
                return type_has(
                    evalTypeParam(left.value, typeParams),
                    right.value || fail("Falsy type tag."));
            else
            {
                let actual = evalTypeAnnot(left, typeParams).type;

                return trySolveTypeParams(
                    type: actual, node: right,
                        :typeParams);
            }
        }

        return fail("TODO evalTypePattern fallthrough: "
                    ~ node.kind ~ "(" ~ node.items.len ~ ")");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            value:  id,
            token:  (_here || fail()));
    }

    fn dequalify_andGetScope(ref id: string): &Scope
    {
        let split = id.find('\t');
        split >= 0 || fail();

        let fname = id.slice(0, split);
        id        = id.slice(split + 1);

        let other = findModule(fuzimport: fname);
        if (other.modid != module.modid)
            return other.out.solve.scope;

        return _scope;
    }

    fn solveCall(node: Node, target?!: Target, kills?!: i32): SolvedNode
    {
        mut id = node.value;
        if (!id) target || fail();

        // Qualified?
        let qualified = node.flags & F_COMPOUND_ID;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        // Dead code elim.
        mut args = solveNodes(node.items, deadcode_on_never: true);
        if (args.if_last.type.is_never)
        {
            _notes |= N_DeadCall;
            return createBlock(node.token, t_never, args);
        }

        //
        mut conversions: Target[][];
        let callTargIdx = match__mutargs(
            :scope, local_scope: !qualified,
            :id, :args, :conversions, :node.flags, :target);

        // `using` codegen.
        for (mut argIdx = 0; argIdx < conversions.len; argIdx++)
        {
            let conversion = conversions[argIdx];
            let convRead = conversion && createRead("__using");

            for (mut i = 0; i < conversion.len; i++)
            {
                let t = conversion[i];
                let o = GET(t);
                if (o.min || o.max && args[argIdx])
                {
                    args[argIdx] = CallerNode(convRead, t, [ args[argIdx] ]);
                    continue;
                }

                i && fail("Bad conversion chain, non-leading nullary: `" ~ o.name ~ "`.");
                args[argIdx] && fail("Bad conversion chain, about to throw away an argnode.");
                args[argIdx] = CallerNode(convRead, t);
            }
        }

        //
        return CallerNode(node, callTargIdx, args, :kills);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrlit(node: Node, type: Type): SolvedNode
    {
        mut itemType = type && tryClear_array(type);

        // Default constructor calls.
        if (!itemType && type.isStruct)
            return solveCall(node,
                target: lookupStruct(type).target);

        // Nope, it's an array literal.
        return createArrlit(:node.token,
            solveNodes(node.items, itemType),
                itemType);
    }

    fn solveArrlit_itemType_init(head!: Type)
    {
        // Super trivial, just don't want to hardcode this here.
        return clear_refs(head) || fail();
    }

    fn solveArrlit_itemType(items: [SolvedNode], mut itemType?: Type, mut start = 0)
    {
        // Init.
        if (!itemType)
        {
            if (start == items.len)
                return fail("Cannot infer empty arraylit.");

            itemType = solveArrlit_itemType_init(head: items[start++].type);
        }
        else if (itemType.is_ref)
        {
            fail("Array items cannot be refs. TODO Why an error? Should this not just clear_refs?");
        }

        // Rest is simple inter.
        for (mut i = start; i < items.len; i++)
            itemType = superType("Array literal: ", itemType, items[i].type);

        return itemType;
    }

    fn solveArrlit_done(itemType!: Type)
    {
        return createArray(itemType);
    }

    fn createArrlit(token: TokenIdx, mut items: SolvedNode[], itemType?: Type)
    {
        shadow let itemType = solveArrlit_itemType(items, itemType);

        for (mut i = 0; i < items.len; i++)
            maybeCopyOrMove(items[i], itemType);

        return SolvedNode("arrlit", :token, :items, type: solveArrlit_done(:itemType));
    }


    //

    fn createLet(target: Target, flags: i32 = 0): SolvedNode
    {
        let overload = GET(target);

        return SolvedNode(
            kind: "let", :flags, token: _here || fail(),
            value: overload.name, :overload.type, :target);
    }

    fn injectImplicitArg(id: string, type: Type, becauseOf!: Target): Target
    {
        _current_fn.items || fail(
            "No implicit `" ~ id ~ "` in scope, needed to call `" ~ GET(becauseOf).name ~ "`.");

        // Reuse existing or add new argnode.
        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++)
        {
            let arg = _current_fn.items[i];
            if (arg.value == id)
            {
                checkAssignable(host: type, arg.type,
                    "Implicit arg collision", id);

                return arg.target || fail();
            }
        }

        // We'll be adding a new thing here.
        mut shadows: bool;
        mut flags = F_IMPLICIT | F_ARG;

        let ret         = Binding(id, type, :flags, :shadows);
        let newArgNode  = createLet(ret, F_IMPLICIT);
        let newArgIdx   = _current_fn.items.len + FN_ARGS_BACK;
        _current_fn.items.insert(newArgIdx, newArgNode);

        return ret;
    }

    fn bindImplicitArg(name: string, type: Type, becauseOf!: Target): SolvedNode
    {
        let id = name;
        mut args: SolvedNode[];
        mut conversions: Target[][];

        let target = tryMatch__mutargs(_scope, local_scope: true, :id, :args, :conversions, flags: F_IMPLICIT)
            || injectImplicitArg(:id, :type, :becauseOf)
            || fail();

        if (args.len != 0 || conversions.len != 0)
            fail("dunno what happened here");

        let o = GET(target);
        o.flags & F_IMPLICIT || fail(
            "Matching a non-implicit item in scope: `" ~ name ~ "`, binds to call to `" ~ GET(becauseOf).name ~ "`.");

        checkAssignable(host: type, o.type, "Implicit `" ~ name ~ "` type mismatch");

        return CallerNode(
            createRead("__implicit"), :target);
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let cond    = solveNode(node.items[0], t_bool);

        // Dead code elim.
        if (cond.type.is_never)
        {
            _notes |= N_DeadIf;
            return cond;
        }

        mut cons    = solveBlock(node.items[1], :type);
        mut alt     = solveBlock(node.items[2], type: type || cons.type);

        if (!type.is_void)
        {
            type = superType("if/else: ", cons.type, alt.type);

            type.is_ref || !type.lifetime || fail("[if] stray lifetime");
            maybeCopyOrMove(cons, type);
            maybeCopyOrMove(alt,  type);
        }

        // Control flow.
        if (cons.type.is_never && alt.type.is_never)
            type = t_never;

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, deadcode_on_never: true, as_blocks_after: 1,
            type_last: type,
            use_type_last: true,
            type_all: type.is_void ? t_bool : type);

        if (items.len < 2)
            return items.only;

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !andLast.type.is_never
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_trySuper(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (!sumType)
            {
                type = t_bool;
            }
            else
            {
                type = sumType;
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(items[i], sumType);
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items, deadcode_on_never: true, as_blocks_after: 1,
            type_last: type,
            use_type_last: true,
            type_all: type.is_void ? t_bool : type);

        if (items.len < 2)
            return items.only;

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                    continue;

                if (sumType)
                {
                    sumType = type_trySuper(sumType, item.type);
                    if (!sumType.is_ref)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (!sumType.is_ref)
            {
                // We'll use the type of the last operand,
                //  and generate a falsy default for the rest.
                if (type.is_ref)
                {
                    // We can generate falsy values and refs,
                    //  but not mutrefs - can't allocate
                    //   a static mut and expect it to remain falsy.
                    type = clear_mutref(type);

                    // Default zerofills are static.
                    type.lifetime = Lifetime_makeShared(type.lifetime);
                }
            }
            else
            {
                type = sumType;
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [], target = Target)
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type, :target);
    }

    fn CallerNode(
        node: Node, target: Target, mut args: SolvedNode[] = [], kills?!: i32)
            : SolvedNode
    {
        let overload = GET(target);

        // Rest params.
        let REST_START = overload.findRestStart();
        if (REST_START < args.len)
        {
            mut rest: SolvedNode[];
            rest.resize(args.len - REST_START);

            for (mut i = args.len; i --> REST_START; )
            {
                SWAP(rest[i - REST_START], args[i]);
                if (i > REST_START)
                    args.splice(i, 1);
                else
                    args[i] = createArrlit(:rest.first.token, rest);
            }
        }

        // This was previously part of tryMatch,
        //  but we can just as easily do it here.
        let isZeroInit = overload.kind == "type" && !args.len;
        if (!isZeroInit)
        {
            // Defaults & implicit argument injection.
            let host_args = overload.args;
            args.resize(host_args.len);
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];

                    args[i] = host_arg.default ||
                    {
                        host_arg.flags & F_IMPLICIT || fail(
                            "tryMatch: about to implicit-bind a non-implicit argument: `"
                                ~ host_arg.name ~ ": " ~ serializeType(host_arg.type) ~ "`.");

                        bindImplicitArg(:host_arg.name,
                                        :host_arg.type, becauseOf: target)
                    };
                }
            }
        }

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        mut type = overload.type;
        if (overload.kind == "field")
        {
            type = add_refs(from: args.only.type || fail(), to: overload.type)
        }

        // Tag copies and moves.
        else if (args)
        {
            let host_args = overload.args || fail("CallerNode: no host args.");
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), host_args[i].type,
                    isArgument: true);

            if (type.is_ref)
                type.lifetime = Lifetime_test(
                    Lifetime_replaceArgsAtCallsite(overload, args),
                    tempsOK: true);
        }

        // Track deps.
        if (target.modid == module.modid)
        {
            // Tracking call graph & type annotations.
            if (overload.kind == "fn" || overload.kind == "type")
            {
                // Locate immediate caller, fn or type.
                for (mut i = _helpers.len; i --> 0; )
                {
                    ref h = _helpers[i];
                    if (h.isFnOrType)
                    {
                        ref o = GET_mut(target);
                        o.used_by.set::add(h.target);
                        detectRecursion(target, o);
                        break;
                    }
                }
            }

            // Robust closure tracking.
            if (_current_fn)
            {
                let o = GET(target);
                if (o.kind == "var" && o.local_of)
                    _current_fn.locals_used.set::add(target.index);

                _current_fn.locals_used.set::add(o.closes_over);
            }
        }

        // Inliner.
        if (overload.kind == "inline")
        {
            let scope0 = Scope_snap(_scope);
            let ss0 = _ss;

            defer {
                Scope_pop(_scope, scope0);
                _ss = ss0;
            }

            ScopeSkip_setup(:overload.template, :scope0, isInline: true);
            _scope.items ~= overload.extra_items;

            //
            let n_fn        = overload.template.node;
            let n_body      = n_fn.items.last;
            let ret_expect  = overload.type;

            mut result: SolvedNode[];
            overload.args.len == args.len || fail("inline: arglen mismatch");
            result.resize(args.len + 1);

            for (mut i = 0; i < args.len; i++)
            {
                let slot = overload.args[i];
                result[i] = createLet(id: slot.name, init: args[i], // TODO__ORIGINAL_ANNOT_OR_TYPE
                    :slot.flags &~ F_ARG); // As if not an arg.
            }

            let s_body = solveBlock(
                n_body, type: ret_expect,
                mask: i16(HM_CanReturn | (n_fn.flags & F_LAMBDA && HM_Lambda)),
                :kills);

            result.last = s_body;

            return createBlock(:node.token, result, :s_body.type);
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type,
        isArgument = false): void
    {
        // Clear mutrefs unless needed.
        if !(slot.is_mutref)
            node.type = clear_mutref(node.type);

        // No copy needed when the slot is a reference.
        if (slot.is_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type = clear_refs(node.type);

            return;
        }

        // Also, no copy needed when the expression is a value.
        if (!node.type.is_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type = clear_refs(node.type);
            return;
        }

        if !(slot.quals & q_rx_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (!USE_nontriv_autocopy && !(node.type.quals & q_trivial))
            fail("Non-trivial implicit copy.");

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(
        nodes: Node[],
        type_all?: Type,
        type_last?!: Type,
        use_type_last?!: bool,
        deadcode_on_never?!: bool,
        as_blocks_after! = -1,
        kills?!: i32): SolvedNode[]
    {
        mut result: SolvedNode[];

        ////////////////////////////////////////////////////////
        let here0   = _here;
        defer _here = here0;
        ////////////////////////////////////////////////////////

        //
        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            mut unorderedClass = unorderedClassify(node.kind);
            if (!unorderedClass)
            {
                _here = node.token || _here;

                let type = i == nodes.len - 1 && use_type_last
                    ? type_last
                    : type_all;

                let solved = as_blocks_after >= 0 && as_blocks_after <= i
                    ? solveBlock(:node, :type)
                    : solveNode(:node, :deadcode_on_never, :type,
                        kills: i == nodes.len - 1 && kills);

                //
                result ~= solved;

                // Dead code elim.
                if (deadcode_on_never && solved.type.is_never)
                {
                    if (i < nodes.len - 1)
                        _notes |= N_DeadCode;

                    break;
                }

                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            let offset = result.len - i0;

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (shadow mut i = i0; i < nodes.len; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, prep-a: falsy node");
                if (unorderedClassify(node.kind) != unorderedClass)
                {
                    i1 = i;
                    break;
                }

                _here = node.token || _here;
                result ~= unorderedPrep_A(node);
            }

            // Later we'll continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++

            // Second prep pass, limit access to scope
            //  of all newly generated entries to what we have right now.
            //
            for (shadow mut i = i0; i < i1; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, prep-b: falsy node");
                _here = node.token || _here;
                unorderedPrep_B(:node, result[i + offset].target);
            }

            // TODO REMOVE, solve all.
            mut repeat = true;
            while (repeat)
            {
                repeat = false;

                for (shadow mut i = i0; i < i1; i++)
                {
                    shadow let node = nodes[i] || fail("solveNodes, solve: falsy node");
                    _here = node.token || _here;
                    let into = result[i + offset].target;

                    // TODO do this while listing exports instead, expect trouble with prelude.
                    if (lazySolveStart(into, GET(into)))
                        repeat = true;
                }
            }
        }

        //
        return result;
    }

    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
    {
        // Ensure can't reimport self.
        _scope.imports ~= module.modid;

        // Load prelude.
        _Scope_import__forceCopy(0);
    }
    else
    {
        // Pre-populate prelude with primitive types and such.
        _scope = listGlobals();
    }

    // Solve.
    {
        let root = solveNode(parse);

        _current_fn && fail("non-empty _current_fn.");

        // Run the thing.
        return SolverOutput(:root,
            scope: Scope_exports(_scope, :module.modid, _field_items),
            notes: _notes);
    }
}
