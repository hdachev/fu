

struct SolvedNode
{}

struct Lifetime { uni0n!: byte[] };

/*
*/

inline fn unpackLocid(r) return [];

pub fn Lifetime_each(lifetime, each) each(locid?: [], paths?: []);

pub fn solve() {
    struct Flow
    {
        rg_invalidates:     [];
    };

    struct CurrentFn
    {
        using flow?:        Flow;
    };

    lax mut _current_fn:        CurrentFn;

    fn PASS_borrowCheck() {
        fn flow = _current_fn.flow;
        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime)
            lifetime.Lifetime_each: |locid!write, paths!write_paths|
                lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
