

struct SolvedNode
{}

struct Lifetime { uni0n!: byte[] };

/*
*/

inline fn unpackLocid(r) return [];

pub fn Lifetime_each(lifetime, each) each(locid?: [], paths?: []);

pub fn solve() {
    struct Flow { rg_invalidates: [] };

    mut flow: Flow;

    fn PASS_borrowCheck() {
        fn bck_trackWrites(callOrPragma: SolvedNode, lifetime: Lifetime)
            lifetime.Lifetime_each: |locid!write, paths!write_paths|
                lax let invalidates = flow.rg_invalidates.if(exists: write);
    }
}
