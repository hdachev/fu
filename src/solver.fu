import helpers;
import parser;
import scope;
import context;
import types;

let TEST = true;

let WARN_ON_IMPLICIT_COPY = false;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub fn solve(
    implicit ctx: Context,
    implicit ref module: Module,
    parse: Node): SolverOutput
{
    mut _here:          TokenIdx;
    mut _scope:         Scope;
    mut _root_scope:    ScopeMemo;
    mut _scope_skip:    ScopeSkip;

    struct CurrentFn
    {
        using out:      SolvedNode;
        return_idx:     ScopeMemo; // <- truth from here
        parent_idx:     i32;
        locals_used?:   i32[];

        ret_expect?:    Type;
        ret_actual?:    Type;
        ret_count?:     i32;

        returns?:       Target[];
    };

    mut _current_fn:    CurrentFn;


    //

    mut SLOW_resolve:   i32;
    mut resolve_done:   i32;

    struct OpenTemplate
    {
        overloadIdx:    Target;
        spec:           Target;
        args:           SolvedNode[];
        mangle:         string;
    };

    mut _open_templates: OpenTemplate[];
    mut _current_struct: Target;


    //

    let t_string = createArray(t_byte);


    //

    fn _Scope_import__forceCopy(modid: i32): void
    {
        _scope.items ~= ctx.modules[modid].out.solve.scope.items;
    }

    fn Scope_import(modid: i32): void
    {
        if (_scope.imports.has(modid)) return;

        modid || fail("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
    }

    fn GET(target: Target): Overload
    {
        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }

    fn GET_local(index: i32): Overload
    {
        return GET(Target(modid: module.modid, :index));
    }


    //

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let fname = _here._fname;
        let l0 = here.line;
        let c0 = here.col;

        let addr = "@" ~ l0 ~ ":" ~ c0;

        return throw(fname ~ " " ~ addr ~ ":\n\t" ~ reason);
    }


    //

    fn Lifetime_DISABLE_BORROW_CHECKER(): Lifetime =
        Lifetime();

    fn Lifetime_FN_unorderedPrep(): Lifetime =
        Lifetime();

    fn Lifetime_fromNative(sig: [Node], args: [SolvedNode]): Lifetime
    {
        sig.len + FN_ARGS_BACK == args.len || fail("sig.len != args.len");

        let ret = sig[sig.len + FN_RET_BACK];
        let mutref = ret.kind == "call" && ret.items.len == 1 && ret.value == "&mut";

        mut res: Lifetime;
        for (mut i = 0; i < args.len; i++)
        {
            let inArg = sig[i];
            let annot = inArg.items[LET_TYPE];
            if (annot.items.len == 1 && ((annot.kind == "call"
                && (!mutref && annot.value == "&" || annot.value == "&mut"))
                 || !mutref && annot.kind == "arrlit"))
            {
                res && fail("Ambiguous __native lifetime.");

                let arg = args[i];
                let o = GET(arg.target);
                res = o.type.lifetime || fail("Missing arg lifetime.");
            }
        }

        let only = res.uni0n.only;
        only < 0 || fail("Non-single-arg __native lifetime.");

        return res;
    }

    fn Lifetime_test(lifetime: Lifetime, current_fn: Target): Lifetime
    {
        mut _last = 0x80000000.i32;

        let debug_2 = current_fn && GET(current_fn);
        if (debug_2) {}

        for (mut i = 0; i < lifetime.uni0n.len; i++)
        {
            let packed = lifetime.uni0n[i];
            {
                packed > _last || fail("Lifetime_test: not a sorted set");
                _last = packed;
            }

            if (packed >= 0)
            {
                i == lifetime.uni0n.len - 1 || fail("Lifetime_test: local not last");

                let local = GET(Target(:module.modid, index: packed));
                let local_of = local.flags & F_LOCAL && local.local_of || fail("Lifetime_test: not a local");

                let debug = GET(Target(:module.modid, index: local_of));
                if (debug) {}

                mut frame = current_fn.index;
                while (local_of != frame)
                {
                    local_of <= frame || fail("Lifetime_test: local_of chain took us elsewhere");
                    frame || fail("Lifetime_test: climbed up to root");
                    frame = GET(Target(modid: module.modid, index: frame)).local_of;
                }
            }
        }

        return lifetime;
    }

    fn Lifetime_fromBinding(target: Target, kind: string, type: Type): Lifetime
    {
        if (TEST)
            target.modid == module.modid || fail("not from this module");

        // Static?
        if (kind == "global")
            return Lifetime_DISABLE_BORROW_CHECKER();

        // Argument?
        let parametric  = kind == "arg" && type.is_ref;
        let index       = target.index;
        let packed      = parametric ? -1 - index : index;

        return Lifetime_test(
            Lifetime(uni0n: [ packed ]),
            _current_fn.target);
    }

    fn Lifetime_replaceArgsAtCallsite(overload: Overload, argNodes: [SolvedNode]): Lifetime
    {
        let returned    = overload.type.lifetime.uni0n;
        let items       = overload.solved.items;

        // Nothing to do if empty/non-arg.
        if !(returned.if_first < 0)
            return Lifetime(uni0n: returned);

        let head = items[0].target.index;
        let tail = items[items.len + FN_ARGS_BACK - 1].target.index;
        head + (overload.args.len - 1) == tail || fail("simplest thing wont work");

        mut keep:       Lifetime;
        mut replace:    Lifetime;

        for (mut i = 0; i < returned.len; i++)
        {
            let packed  = returned[i];
            let index   = -1 - packed;

            // We're only filtering here, no need to run the full thing.
            if (index < head || index > tail) {
                keep.uni0n ~= packed;
                continue;
            }

            // Full union here, otherwise we risk messing things up.
            let offset  = index - head;
            let argNode = argNodes[offset];
            replace     = Lifetime_union(replace, argNode.type.lifetime);
        }

        return Lifetime_test(
            Lifetime_union(keep, replace),
            _current_fn.target);
    }

    fn Lifetime_killedByReturnOf(lifetime: Lifetime, target: Target)
    {
        // Any local will suffice.
        for (mut i = 0; i < lifetime.uni0n.len; i++)
        {
            let item = lifetime.uni0n[i];
            if (item >= target.index)
                return true;
        }

        return false;
    }


    //

    fn Binding(id: string, mut type: Type, mut flags!: i32, kind = "var")
    {
        mut name = id;

        // Unique identifiers.
        if (_root_scope)
        {
            mut any     = 0;
            mut same    = 0;

            let start = _scope_skip.end.items_len || _root_scope.items_len;
            for (mut i = start; i < _scope.items.len; i++)
            {
                if (_scope.items[i].id == id)
                {
                    any++;
                    let o = GET(_scope.items[i].target);
                    if (o.kind == "arg" || o.kind == "ref" || o.kind == "var")
                        same++;
                }
            }

            if (same)
                name ~= "_" ~ same;

            // LEAKY TEMPLATES, part 1:
            //  All locals are F_SHADOW - this is a usability thing really,
            //   otherwise you'd simply have to `shadow` everything manually.
            //
            // Actually turning this on for everything -
            //  it might optimize scope lookups all over the place.
            //
            if (kind != "global" && !any) // && _current_fn.flags & F_INLINE
                flags |= F_SHADOW;
        }

        //
        let local_of = !(flags & F_FIELD) && _current_fn.target.index;
        if (local_of)
        {
            kind == "var" || kind == "arg" || kind == "ref" || fail("Nope, getting it wrong.");
            flags |= F_LOCAL;
        }

        // Reserve the slot.
        let target = Scope_create(_scope, :kind, :name, :flags, :local_of);
        Scope_set(_scope, :id, :target);

        // Setup the lifetime for references to this binding.
        ref overload = GET_mut(target);
        {
            let lifetime = Lifetime_fromBinding(target, kind, type);

            // Throw away argument lifetime, union below will fix it up.
            if (flags & F_ARG)
                type.lifetime = Lifetime_DISABLE_BORROW_CHECKER();

            overload.type = flags & F_MUT
                ? add_mutref(type, lifetime)
                : add_ref   (type, lifetime);
        }

        return target;
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope, "field",
            :id || fail(), fieldType || fail(),
            1, 1, [ Argument(name: "this", type: structType) ],
            flags: F_PUB);
    }

    fn TemplateDecl(node: Node)
    {
        let id      = node.value;
        let items   = node.items;

        mut min     = 0;
        let max     = node.kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TemplateDecl: non-fn node.");

        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let arg = items[i];
            arg.kind == "let" || fail();
            let name = arg.value || fail();
            args.push(Argument(:name));

            if (!arg.items[LET_INIT])
                min++;
        }

        //
        let template = Template(
            node,
            imports: !_current_fn && _scope.imports,
            locals:   _current_fn && Scope_snap(_scope),
            parent_idx: _current_fn.target.index);

        return Scope_add(
            _scope,
            kind: "template", :id, Type,
            :min, :max, :args, :template,
            :node.flags);
    }

    fn FnDecl_init(target: Target, kind: string, id: string, template: Template)
    {
        ref overload = GET_mut(target);

        overload.name = id;
        overload.kind = kind;
        overload.template = template;

        Scope_set(_scope, :id, :target);
    }

    fn FnDecl_update(solved: SolvedNode, locals_used: i32[], ret_actual: Type)
    {
        let items = solved.items;

        mut min = 0;
        let max = items.len + FN_ARGS_BACK;
        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let argNode = items[i];
            argNode.kind == "let" || fail();

            let isImplicit = !!(argNode.flags & F_IMPLICIT);
            let arg = Argument(
                type:       argNode.type  || fail(),
                name:       argNode.value || fail(),
                default:    !isImplicit && argNode.items[LET_INIT],
                flags:      argNode.flags);

            if (!arg.default && !isImplicit)
                min++;

            args.push(arg);
        }

        // Unconditionally replacing the stuff.
        ref overload    = GET_mut(solved.target);

        let args_len0   = overload.args.len;
        let closure0    = overload.closes_over.len;

        overload.type   = ret_actual || fail("FnDecl_update: no return type.");
        overload.min    = min;
        overload.max    = max;
        overload.args   = args;
        overload.flags  = solved.flags;

        overload.solved = solved;

        // See which one of the locals we've used are not our own.
        {
            mut closes_over: i32[];

            for (mut i = 0; i < locals_used.len; i++)
            {
                let o = GET_local(locals_used[i]);
                if (o.local_of != solved.target.index)
                    closes_over ~= locals_used[i];
            }

            overload.closes_over = closes_over;
        }

        // Test.
        Lifetime_test(ret_actual.lifetime, solved.target);

        // TODO FIX starting the diff with just number of arguments,
        //  which is fine for implicit cycling,
        //   then we gotta move on to bigger and better things.
        if (args_len0 != overload.args.len ||
            closure0  != overload.closes_over.len)
        {
            invalidateUsers(overload);
        }
    }

    fn invalidateUsers(overload: Overload): void
    {
        let parent_idx = overload.local_of;
        for (mut i = 0; i < overload.used_by.len; i++)
            makeDirty(overload.used_by[i], :parent_idx, becauseOf: overload);
    }

    fn makeDirty(index: i32, parent_idx: i32, becauseOf!: Overload): void
    {
        index || fail(
            "makeDirty: climbed up to global scope.");

        let userIdx = Target(modid: module.modid, :index);

        ref user = GET_mut(userIdx);
        if !(user.status & SS_DIRTY)
        {
            let their_parent = user.local_of;
            index >= parent_idx || fail(
                "makeDirty: climbed too far up.");

            if (user.status & SS_FINALIZED)
            {
                if (their_parent)
                    return makeDirty(their_parent, :parent_idx, :becauseOf);

                fail("Overload finalized, cannot make dirty: `" ~ user.name ~ "`, because of `" ~ becauseOf.name ~ "`.");
            }

            user.status |= SS_DIRTY;
            SLOW_resolve++;
        }
    }

    fn DefCtor(id: string, type: Type, members: SolvedNode[], mut into: Target): Target
    {
        // TODO ideally defctors have to go,
        //  they're just an extra function we have to deal with here.
        //   plus they depend on the struct itself,
        //    and so require all the extra care there.
        //
        // Basically we want to have one less thing.
        //
        // Alternatively, we drop the Struct fields stuff in `types`,
        //  and use the argument list here to describe the struct members,
        //   which servers us just as well, we have just one thing.
        //
        let max = members.len;
        mut min = 0;
        mut args: Argument[];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            // There's duplication here <-> and in the typedef.
            //  Perhaps we do the opposite, drop the members there,
            //   and just refer to this argument list.
            //
            let arg = Argument(
                name:       member.value || fail(),
                type:       member.type  || fail(),
                default:    member.items[LET_INIT],
                flags:      member.flags & F_MUSTNAME);

            if (!arg.default)
                min++;

            args.push(arg);
        }

        if (!max) return Target();
        if (!min) min++;

        //
        if (!into)
        {
            into = Scope_create(_scope);

            // TODO don't Scope_set when templated.
            Scope_set(_scope, :id, target: into);
        }

        ref overload    = GET_mut(into);

        overload.kind   = "defctor";
        overload.name   = id;
        overload.type   = type;
        overload.min    = min;
        overload.max    = max;
        overload.args   = args;
        overload.flags  = F_PUB;

        return into;
    }

    fn tryCreateDefinit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (type.is_mutref)
            return SolvedNode();

        return createDefinit(type);
    }

    fn createDefinit(mut type: Type): SolvedNode
    {
        let token = _here || fail();

        if (type.is_ref)
            type.lifetime = Lifetime_DISABLE_BORROW_CHECKER();

        if (type.quals & q_integral)
            return SolvedNode(
                kind: "int", :token, :type,
                value: "0");

        if (type.quals & q_floating_pt)
            return SolvedNode(
                kind: "real", :token, :type,
                value: "0");

        return SolvedNode(
            kind: "definit", :token, :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryCreateDefinit(type)
            || fail("Cannot definit: " ~ serializeType(type));
    }

    fn solveTypeAssert(node: Node): SolvedNode
    {
        let left   = node.items[0];
        let right  = node.items[1];

        // left -> right.
        let expect = evalTypeAnnot(right).type;
        let actual = solveNode(left, expect);

        checkAssignable(host: expect, actual.type,
            "Type assertion failed");

        return actual;
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = "p-unshift";
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut args = overload.args.slice(1);
        mut flags = 0;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != "var" &&
            via.kind != "global" &&
            via.kind != "arg" &&
            via.kind != "ref")
        {
            kind = "p-wrap";
            min++;
            max++;

            flags |= F_PUB;

            mut arg = Argument(
                type: via.args[0].type,
                name: "using");

            args.unshift(arg);
        }

        return Scope_add(
            _scope,
            :kind, :id, :overload.type, :flags,
            :min, :max, :args,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();

        fn visit(item: ScopeItem)
        {
            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                return;

            let overloadIdx = item.target;
            let overload = GET(overloadIdx);

            // Needs at least one argument.
            if (overload.min < 1)
                return;

            // TODO using + templates, the fuck do we do?
            if (overload.kind == "template")
                return;

            // Skip over defctors -
            //  we really only want this for fields & properties,
            //   but there's no way to tell a property from a fn,
            //    this at least is easy to disambiguate.
            if (overload.kind == "defctor")
                return;

            // See if we fit.
            let expect = overload.args[0] || fail();
            if (!isAssignableAsArgument(expect.type, actual))
                return;

            //
            Partial(item.id, viaIdx, overloadIdx);
        }

        // Visit stuff currently in scope.
        for (mut i = 0; i < _scope.items.len; i++)
        {
            if (i == _scope_skip.start.items_len)
                i  = _scope_skip.end  .items_len;

            visit(_scope.items[i]);
        }

        // Also bring in stuff from the module of origin.
        let extra_modid = actual.modid;
        if (!_scope.imports.has(extra_modid))
        {
            let items = ctx.modules[extra_modid].out.solve.scope.items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }

        // Struct members.
        if (actual.isStruct)
        {
            let items = lookupStruct(actual).items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }
    }


    //

    fn getNamedArgReorder(
        ref result: i32[],
        names: string[],
        host_args: Argument[]): bool
    {
        result.clear();

        //
        mut used   = 0;
        mut offset = 0;
        for (mut i = 0; i < host_args.len; i++)
        {
            mut idx = names.find(host_args[i].name);
            if (idx < 0)
            {
                for (shadow mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                used++;
            }

            result.push(idx);
        }

        // Fail if some name ended up unused.
        //  TODO FIX THIS MESS
        if (used != names.len)
        {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used != names.len)
                return false;
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        // Return nothing if not needed.
        for (mut i = 0; i < result.len; i++)
            if (result[i] != i)
                return true;

        result.clear();
        return true;
    }

    fn tryMatch__mutargs(
        scope: Scope, scope_skip: ScopeSkip,
        mut id: string, ref args: SolvedNode[],
        flags?!: i32, retType?!: Type, target?!: Target): Target
    {
        mut matchIdx: Target;

        let arity = args.len;

        // Prep labelled args for remap.
        mut names: string[];
        if (flags & F_NAMED_ARGS)
        {
            mut some = false;

            for (mut i = 0; i < arity; i++)
            {
                let arg = args[i];
                names.push(arg.kind == "label"
                    ? { some = true; arg.value } || fail()
                    : "");
            }

            some || fail();
        }

        mut reorder: i32[];
        mut args_mangled: string;

        //
        let extra_modid = flags & F_ACCESS && args.if_first.type.modid;
        let extra_items = extra_modid
                        && !_scope.imports.has(extra_modid)
                        && ctx.modules[extra_modid].out.solve.scope.items;

        //
        let unary_arg_t = arity == 1 && args[0].type;
        let field_items = unary_arg_t.isStruct && lookupStruct(unary_arg_t).items;

        //
        mut alternate_ids: string[];

        for (;;)
        {
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            :NEXT
            while (overloadIdx =
                scope.search(id, scope_iterator,
                    :scope_skip, :target,
                    :extra_items, :field_items))
            {
                :TEST_AGAIN
                while (true)
                {
                    let overload = GET(overloadIdx);

                    ////////////////////////////////////////////
                    // Conversions / typename aliases.
                    if (arity && overload.kind == "type")
                    {
                        let alt = overload.type.canon;
                        if (alt != id) // e.g. i32
                            alternate_ids.push(alt);
                    }
                    ////////////////////////////////////////////

                    //
                    if (overload.min > arity || overload.max < arity)
                        continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    // Match by argnames.
                    if (names && !getNamedArgReorder(reorder, names, overload.args))
                        continue :NEXT;

                    // Specialize.
                    if (overload.kind == "template")
                    {
                        if (reorder)
                            fail("TODO handle argument reorder in template specialization.");

                        let specIdx = trySpecialize(
                            :overloadIdx, :args,
                            :args_mangled ||= mangleArguments(args));

                        if (!specIdx)
                            continue :NEXT;

                        // Repeat arity checks and such.
                        overloadIdx = specIdx;
                        continue :TEST_AGAIN;
                    }

                    if (args)
                    {
                        // Type check args.
                        let host_args = overload.args;

                        let N = reorder ? reorder.len
                                        : args.len;

                        /////////////////
                        // Literal fixup.
                        let undo_literal_fixup = args;
                        //        /LITFIX
                        /////////////////

                        for (mut i = 0; i < N; i++)
                        {
                            let host_arg = host_args[i];

                            let callsiteIndex = reorder ? reorder[i]
                                                        : i;
                            if (callsiteIndex < 0)
                            {
                                // Argument may not be defaulted -
                                //  we might be supplying defaults via names
                                //   before we've actually exhausted
                                //    all the non-defaulted stuff.
                                if (!host_arg.default && !(host_arg.flags & F_IMPLICIT))
                                    continue :NEXT;

                                continue;
                            }

                            // Explicit argname requirements.
                            else if (host_arg.flags & F_MUSTNAME)
                            {
                                if (names.len <= callsiteIndex || !names[callsiteIndex])
                                    continue :NEXT;
                            }

                            let expect = host_arg.type;
                            let actual = args[callsiteIndex].type;

                            mut ok = isAssignableAsArgument(expect, actual);

                            /////////////////
                            // Literal fixup.
                            if (!ok && considerRetyping(expect, actual))
                            {
                                ref arg = args[callsiteIndex];
                                if (arg.kind == "label")
                                {
                                    // SEGV fix -
                                    //  how do we deal with this in general?
                                    //   might as well discontinue copy assignment
                                    //    in favor of cpy->mov.
                                    let inner = arg.items.only;
                                    arg = inner;
                                }

                                let retype  = tryRetyping(arg, expect);
                                    ok      = isAssignableAsArgument(expect, retype);

                                if (ok)
                                    arg.type = retype;
                            }
                            //        /LITFIX
                            /////////////////

                            if (!ok)
                            {
                                args = undo_literal_fixup;
                                continue :NEXT;
                            }
                        }

                        // Forbid ambiguity.
                        if (matchIdx)
                        {
                            let debug = GET(matchIdx);
                            if (debug) {}
                            fail("Ambiguous callsite, matches multiple functions in scope: `" ~ id ~ "`.");
                        }

                        // Do reorder.
                        if (reorder)
                        {
                            // TODO:
                            // I shouldn't need this pass, just swaps must do.
                            mut new_args: SolvedNode[];
                            new_args.resize(reorder.len);

                            for (mut i = 0; i < reorder.len; i++)
                            {
                                let idx = reorder[i];
                                if (idx >= 0)
                                    new_args[i] = args[idx];
                            }

                            args = new_args;
                        }
                    }

                    // Forbid ambiguity.
                    else if (matchIdx)
                    {
                        let debug = GET(matchIdx);
                        if (debug) {}
                        fail("Ambiguous callsite, matches multiple items in scope: `" ~ id ~ "`.");
                    }

                    // Done!
                    matchIdx = overloadIdx;

                    // Arity 0 auto-shadows.
                    if (overload.flags & F_SHADOW)
                        break :NEXT;

                    // Done here.
                    break :TEST_AGAIN;
                }
            }

            //////////////////////////////////
            // Conversions / typename aliases.
            if (!alternate_ids)
                break;

            id = alternate_ids.last;
            alternate_ids.pop();
            //////////////////////////////////
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let host_args = matched.args;
            if (host_args.len > args.len)
                args.resize(host_args.len);

            // Defaults & implicit argument injection.
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default || bindImplicitArg(
                        :host_arg.name,
                        :host_arg.type,

                        becauseOf: matchIdx);
                }
            }
        }

        return matchIdx;
    }


    //

    fn considerRetyping(expect: Type, actual: Type): bool
    {
        return expect.quals & actual.quals & q_arithmetic != 0;
    }

    fn couldRetype(node: SolvedNode): bool
    {
        return node.kind == "int"
            || node.kind == "real";
    }

    fn tryRetyping(node: SolvedNode, expect: Type): Type
    {
        return node.kind == "int"  ? solveInt(node.value, expect)
             : node.kind == "real" ? solveNum(node.value, expect)
             : [];
    }


    //

    fn match__mutargs(
        scope: Scope, scope_skip: ScopeSkip,
        id: string, ref args: SolvedNode[],
        flags: i32, target: Target): Target
    {
        let ret = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (ret)
            return ret;

        let debug = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (debug)
            return debug;

        return scope.NICERR_mismatch(:id, :args);
    }

    fn NICERR_mismatch(
        scope: Scope,
        id: string, args: SolvedNode[]): never
    {
        // TODO instead of this -
        //  run tryMatch__mutargs again with an error output attached,
        //   this way we don't need the second pass for debugging,
        //    we can #bake alla jblow the if (explain) parts,
        //     and we can rid ourselves of Scope_lookup altogether.

        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = DEPREC_lookup(scope, id);

        mut min = 0x7fffffff.i32;
        mut max = 0;
        for (mut i = 0; i < overloads.len; i++)
        {
            let o = GET(overloads[i]);
            if (min > o.min) min = o.min;
            if (max < o.max) max = o.max;
        }

        fn expectedArgs(shadow targets: Target[]): string
        {
            mut result = "";

            for (mut i = 0; i < targets.len; i++)
            {
                if (result)
                    result ~= "\n\t\t";
                else if (targets.len > 1)
                    result ~= ", available overloads:\n\t\t";
                else
                    result ~= ", expects: ";

                let overload = GET(targets[i]);

                result ~= overload.name ~ "(";

                for (shadow mut i = 0; i < overload.args.len; i++)
                {
                    let arg = overload.args[i];
                    if (i)
                        result ~= ", ";

                    result ~=  arg.name
                            ~ (arg.flags & F_MUSTNAME ? "!" : "")
                            ~ (arg.default ? "?: " : ": ")
                            ~ (arg.type ? humanizeType(arg.type) : "$");
                }

                result ~= ")";
            }

            return result || ".";
        }

        fn actualArgs(shadow args: SolvedNode[]): string
        {
            mut result = "\nActual: (";

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                if (i)
                    result ~= ",";

                result ~= "\n\t";
                if (arg.kind == "label")
                    result ~= arg.value ~ ": ";

                result ~= humanizeType(arg.type);
            }

            return result ~ ").";
        }

        return overloads
                ? args.len < min ? fail("`" ~ id ~ "` expects at least " ~ min ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : args.len > max ? fail("`" ~ id ~ "` expects at most " ~ max ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : fail("`" ~ id ~ "` bad args" ~ expectedArgs(overloads) ~ actualArgs(args))
             : fail("`" ~ id ~ "` is not defined in this scope.");
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "label")       return solveComma(node);

        if (k == "let")         return solveLet(node);
        if (k == "call")        return solveCall(node);
        if (k == "arrlit")      return solveArrayLiteral(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "!")           return solveNot(node);
        if (k == "and")         return solveAnd(node, type);

        if (k == "return")      return solveReturn(node);
        if (k == "loop")        return solveBlock(node);
        if (k == "break")       return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);
        if (k == "empty")       return createEmpty();

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "typeparam")   return solveTypeParam(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedClassify(kind: string): i32
    {
        if (kind == "fn")       return 1;
        if (kind == "struct")   return 10;
        if (kind == "typedef")  return 10;

        return 0;
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == "fn")          return uPrepFn(node);
        if (k == "struct")      return uPrepStruct(node);
        if (k == "typedef")     return solveTypedef(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == "fn")          return uSolveFn(node, prep);
        if (k == "struct")      return uSolveStruct(node, prep);
        if (k == "typedef")     return prep || fail();

        return fail("TODO: " ~ k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        return solved(node, t_void,
            solveNodes(node.items, t_void,
                TEMP_open_templates: true));
    }

    fn solveBlock(node: Node, type?: Type): SolvedNode
    {
        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let expr = !!(node.items.if_last.flags & F_NODISCARD);

        let items = solveNodes(
            node.items,
            type_all:       t_void,
            type_last:      type,
            use_type_last:  expr,
            TEMP_open_templates: true,
            TEMP_template_scope: scope0);

        shadow let type = expr && items.len
            ? items.last.type : t_void;

        ////////////////////////////////
        for (mut i = 0; i < _open_templates.len; i++)
        {
            let o = GET(_open_templates[i].overloadIdx);
            if (o.template.locals > scope0)
                fail("Exiting the scope of an open template: `" ~ o.name ~ "`.");
        }
        ////////////////////////////////

        return solved(:node, :type, :items);
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(v: string, type: Type): Type
    {
        shadow let parse = intlit::Intlit(v);
        parse.error && fail(parse.error);

        if (type)
        {
            fn want(t: Type)
                type.canon == t.canon;

            if (!parse.unsigned)
            {
                if (want(t_f32) && parse.minsize_f <= 32) return t_f32;
                if (want(t_f64) && parse.minsize_f <= 64) return t_f64;

                if (want(t_i32) && parse.minsize_i <= 32) return t_i32;
                if (want(t_i64) && parse.minsize_i <= 64) return t_i64;
                if (want(t_i16) && parse.minsize_i <= 16) return t_i16;
                if (want(t_i8 ) && parse.minsize_i <= 8 ) return t_i8 ;
            }

            if (!parse.signed)
            {
                if (want(t_u32) && parse.minsize_u <= 32) return t_u32;
                if (want(t_u64) && parse.minsize_u <= 64) return t_u64;
                if (want(t_u16) && parse.minsize_u <= 16) return t_u16;
                if (want(t_u8 ) && parse.minsize_u <= 8 ) return t_u8 ;
            }
        }

        if (parse.unsigned)
        {
            if (parse.minsize_u <= 32) return t_u32;
            if (parse.minsize_u <= 64) return t_u64;
        }
        else
        {
            if (parse.minsize_i <= 32) return t_i32;
            if (parse.minsize_i <= 64) return t_i64;
        }

        return fail("Bad int literal.");
    }

    fn solveNum(v: string, type: Type): Type
    {
        // TODO `f` suffix
        if (v) {}

        if (type.canon == t_f32.canon) return t_f32;

        return t_f64;
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
        solved(node,
             solveInt(node.value, type));

    fn solveNum(node: Node, type: Type): SolvedNode
        solved(node,
             solveNum(node.value, type));


    //

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefinit(
                add_ref(t_string, Lifetime_temporary));

        return solved(node, t_string);
    }

    fn createEmpty(kind = "empty", type = t_void, target?: Target): SolvedNode
    {
        return SolvedNode(
            :kind, :type, :target,
            token: _here || fail());
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }


    //

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(node, solve: false);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(node, :prep, solve: true);
    }

    fn __solveFn(n_fn: Node, solve!: bool, prep?!: SolvedNode, spec?!: bool, caseIdx! = -1, into?: Target): SolvedNode
    {
        // Template early exit.
        if (spec)
        {
            // Now we try to prep these too.
            // solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl = TemplateDecl(n_fn);
            return createEmpty(
                type: addroffn::X_addrofTarget(tDecl));
        }

        // Prep reject.
        let inItems = n_fn.items;
        if (!solve && !inItems[inItems.len + FN_RET_BACK])
            return SolvedNode();

        mut out = CurrentFn(
            prep || solved(n_fn, t_void),
            return_idx: ScopeMemo(),
            parent_idx: _current_fn.target.index);

        out.items.resize(inItems.len);

        if (!prep)
        {
            out.target = into || Scope_create(_scope, local_of: out.parent_idx);
            out.type = addroffn::X_addrofTarget(out.target);
        }

        //
        if (_current_fn)
        {
            // Propagate "inlined"-ness to non-templates within templates,
            //  see the `traverse` testcase.
            if (_current_fn.flags & F_TEMPLATE)
                out.flags |= F_TEMPLATE;
        }

        //////////////////////////
        mut native = false;
        mut n_body: Node;

        {
            let scope0      = Scope_snap(_scope);
            out.return_idx  = scope0;

            let root_scope0 = _root_scope;
            if (!root_scope0)
                _root_scope = out.return_idx;

            SWAP(_current_fn, out);

            defer {
                SWAP(_current_fn, out);
                Scope_pop(_scope, scope0);
                _root_scope = root_scope0;
            }

            /////////////////////////////////
            ref outItems = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == "let" || fail();

                // If spec and unless argument explicitly wants a value -
                if (spec && !(n_arg.flags & F_MUT)
                         && !(n_arg.items[LET_INIT]))
                {
                    // Specialize with actuals.
                    mut mut_arg = n_arg;
                    mut_arg.items[LET_TYPE] = createTypeParam(mut_arg.value);

                    outItems[i] = solveLet(mut_arg);
                }
                else
                {
                    outItems[i] = solveLet(n_arg);
                }
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
                n_body  = inItems[inItems.len + FN_BODY_BACK];

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == "pattern" || fail();
                let branch = n_body.items[caseIdx] || fail();

                shadow let inItems = branch.items;

                n_ret   = inItems[inItems.len + FN_RET_BACK] || n_ret;
                n_body  = inItems[inItems.len + FN_BODY_BACK];
            }

            // Builtin?
            n_body || fail("solveFn: no body.");
            if (n_body.kind == "call" && n_body.value == "__native")
                native = true;

            // Return type annot.
            _current_fn.ret_expect = n_ret && evalTypeAnnot(n_ret).type;

            // Only if actually solving the fn, the fn body.
            if (solve && !native)
            {
                let s_body = solveNode(n_body);

                // Fixup returns.
                _current_fn.ret_actual ||= _current_fn.ret_count
                    ? fail("falsy ret_actual when ret_count != 0.")
                    : t_void;

                finalizeReturns();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body || fail("falsy body");
            }
            else
            {
                _current_fn.ret_actual = _current_fn.ret_expect || fail("falsy ret_expect");

                //////////////////////////////////////////////////////////
                // Lifetimes.
                //
                if (_current_fn.ret_actual.lifetime)
                    _current_fn.ret_actual.lifetime = native
                        ? Lifetime_fromNative(inItems, _current_fn.items[0, _current_fn.items.len + FN_ARGS_BACK])
                        : solve ? fail() : Lifetime_FN_unorderedPrep();
                //
                else if (_current_fn.ret_actual.is_ref)
                    fail("fn.ret_actual is a ref without a lifetime.");
                //
                //////////////////////////////////////////////////////////
            }

            // Sighashes include return value.
            outItems[outItems.len + FN_RET_BACK] =
                createEmpty(type: _current_fn.ret_actual);
        }
        //////////////////////////

        if (!prep)
        {
            // TODO FIX currently we only hash template names.
            mut name = n_fn.value || fail("TODO anonymous fns");
            if (spec && !native)
            {
                let sig = mangleArguments(out.items[0, out.items.len + FN_BODY_BACK]) || fail();
                let hash = tea::hash62(sig, chars: 4);
                name ~= "_" ~ hash;
            }

            //
            let kind = native ? "__native" : "fn";

            // TODO this no longer seems to make sense
            let NO_IMPORTS: i32[];
            let NO_LOCALS: ScopeMemo;
            let template = Template(node: native ? n_body : n_fn, imports: NO_IMPORTS, locals: NO_LOCALS, parent_idx: 0);

            FnDecl_init(out.target, :kind, id: name, :template);
        }

        FnDecl_update(out.out, out.locals_used, out.ret_actual);

        if (solve)
            return createFnDef(out.out);

        return out.out;
    }

    fn createFnDef(fn: SolvedNode): SolvedNode
    {
        return SolvedNode(
            kind:   "fndef",
            type:   fn.type,
            target: fn.target,
            token:  fn.token);
    }


    //

    fn mangleArguments(args: [$T]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle ~= ",";

            mangle ~= serializeType(args[i].type);
        }

        return mangle;
    }


    //

    fn setSpec(mangle: string, target: Target)
    {
        ref t = module.out.specs[mangle] ||= Target;

        fn name(shadow target)
            target.modid != -1  ? GET(target).name
                                : "SPEC_FAIL";

        !t ||
        t.modid == target.modid &&
        t.index == target.index ||
        t.modid == -1 || fail(
            "About to screw up royally, replacing spec: "
                ~ t.index ~ " with " ~ target.index
                    ~ ", mangle: " ~ mangle ~ ", that's: "
                    ~ t.name ~ " becoming " ~ target.name);

        t = target;
    }

    fn trySpecialize(
        overloadIdx: Target, args: SolvedNode[],
        args_mangled: string)
            : Target
    {
        // TODO memoize the whole mangle.
        mut mangle = overloadIdx.modid ~ "#" ~ overloadIdx.index ~ " ";
            mangle ~= args_mangled;

        // TODO FIX THIS MESS -
        //  A. Not recursion capable: use the general prep-vs-solve approach here too.
        //  B. The multiple map taps here are because stuff
        //      moves around while doTrySpecialize does its work -
        //      if maps values didn"t move around we"d be good.
        mut spec = module.out.specs[mangle];

        let SPEC_FAILED = -1;
        if (!spec)
        {
            let SPEC_FAIL = Target(modid: SPEC_FAILED, index: 0);

            ////////////////////////////////////
            let m0 = mangle;
            setSpec(m0, SPEC_FAIL);
            ////////////////////////////////////

            spec = doTrySpecialize(:overloadIdx, :args, :mangle) || SPEC_FAIL;

            /////////////////////////////////////////
            // TODO FIX THIS MESS
            let spec0 = spec;

            {
                ref preexisting = module.out.specs[mangle] ||= spec;
                if (preexisting.modid == SPEC_FAILED)
                    preexisting = spec;
                else
                    spec = preexisting;
            }

            if (m0 != mangle)
            {
                ref preexisting = module.out.specs[m0] ||= spec;
                if (preexisting.modid == spec0.modid &&
                    preexisting.index == spec0.index)
                {
                    preexisting = spec;
                }
                else
                {
                    setSpec(m0, spec);
                }
            }
            /////////////////////////////////////////

            // The resolver entry.
            if (spec.modid != SPEC_FAILED)
                _open_templates.push(
                    OpenTemplate(
                        :overloadIdx, :spec, :args, :mangle));
        }

        return spec.modid != SPEC_FAILED && spec;
    }


    // Let's try to run all specs through here for starters.

    fn doTrySpecialize(
        overloadIdx: Target, mut args: SolvedNode[], ref mangle: string, into?: Target)
            : Target
    {
        mut ok = true;
        mut typeParams0: Map(string, Type);

        ////////////////////////////////
        mut current_fn0: CurrentFn;

        SWAP(_current_fn, current_fn0);

        let scope0 = Scope_snap(_scope);
        let scope_skip0 = _scope_skip;
        ////////////////////////////////

        //
        mut typeParams: Map(string, Type);

        //
        let template = GET(overloadIdx).template;

        if (template.parent_idx)
            _current_fn.target = Target(
                modid: module.modid,
                index: template.parent_idx);

        _scope_skip = _root_scope && ScopeSkip(
            start: template.locals || _root_scope,
              end: scope0);

        _scope_skip.end.items_len >= _scope_skip.start.items_len || fail(
            "doTrySpecialize: will scope_skip backwards.");

        for (mut i = 0; i < template.imports.len; i++)
            Scope_import(template.imports[i]);

        //
        let kind    = template.node.kind;
        let items   = template.node.items;
        let numArgs = kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TODO numArgs for template:" ~ kind);

        /////////////////
        // Literal fixup.
        mut retypeIndices: i32[];
        mut remangle = false;

        // First off, solve type params.
        for (   mut pass_retype  = 0;
                    pass_retype == 0 || pass_retype == 1 && retypeIndices;
                    pass_retype++)
        {
        //        /LITFIX
        /////////////////

            for (mut i = 0; i < numArgs; i++)
            {
                if (pass_retype)
                {
                    // TODO fix, .try_shift instead.
                    if (!retypeIndices.has(i))
                        continue;
                }

                let inValue = args.len > i && args[i];
                mut inType  = inValue.type;

                let argNode = items[i] || fail();
                let annot   = argNode.items[LET_TYPE];

                /////////////////
                // Literal fixup.
                if (couldRetype(inValue))
                {
                    let paramType =
                        annot.kind == "typeparam"
                            ? typeParams[annot.value] ||= Type
                            : annot.kind == "call" && !annot.items
                                && Scope_lookupType(annot);

                    // Ignore literals if possible.
                    if (paramType)
                    {
                        let retype = tryRetyping(inValue, paramType);
                        if (retype && retype.canon != inType.canon)
                        {
                            inType   = args[i].type = retype;
                            remangle = true;
                        }
                    }

                    // Defer for second pass.
                    else if (!pass_retype)
                    {
                        retypeIndices.push(i);
                        continue;
                    }
                }
                //        /LITFIX
                /////////////////

                argNode.kind == "let"  || fail();

                if (inType)
                {
                    let argName = argNode.value || fail();

                    // Same pattern - grabs a mutref.
                    ref argName_typeParam =
                        typeParams[argName] ||= Type;

                    argName_typeParam && fail(
                        "Type param name collision with argument: `" ~ argName ~ "`.")
                            = inType;

                    //
                    inType = add_ref(inType, Lifetime_temporary);

                    // Type check.
                    if (annot)
                    {
                        let argOk = inType && trySolveTypeParams(
                            annot, inType, typeParams);

                        ok = ok && argOk;
                        if (!ok && !remangle)
                            break;
                    }
                }
            }
        }

        /////////////////
        // Literal fixup.
        if (remangle)
        {
            // TODO FIX
            let start   = mangle.find(' ') + 1 || fail();
                mangle  = mangle.slice(0, start) ~ mangleArguments(args);
        }
        //        /LITFIX
        /////////////////

        // Match pattern arm here.
        mut caseIdx = -1;

        if (ok)
        {
            // Unpack type params in scope.
            {
                mut keys = typeParams.keys;
                for (mut i = 0; i < keys.len; i++)
                {
                    let key = keys[i];
                    Scope_Typedef(_scope, "$" ~ key, typeParams[key], flags: 0);
                }
            }

            //
            let pattern = items[items.len + FN_BODY_BACK] || fail();
            if (pattern.kind == "pattern")
            {
                let branches = pattern.items;
                for (mut i = 0; i < branches.len; i++)
                {
                    let cond = branches[i].items[0] || fail();
                    if (evalTypePattern(cond))
                    {
                        caseIdx = i;
                        break;
                    }
                }

                // All branches mismatch?
                //  Can't return, faking RAII here.
                if (caseIdx < 0)
                    ok = false;
            }
        }

        kind == "fn" || fail("__solveFn spec:true is not expected to fail.");

        let prep = ok && !into && __solveFn(
            template.node, solve: false, spec: true, :caseIdx,
            :into);

        ///////////////////////////////////////////
        // Re-enable recursion.
        if (prep.target)
            setSpec(mangle, prep.target);
        ///////////////////////////////////////////

        let specialized = ok && __solveFn(
            template.node, :prep, solve: true, spec: true, :caseIdx,
            :into).target;

        // A final remangle.
        if (specialized)
        {
            // TODO FIX
            let start   = mangle.find(' ') + 1 || fail();
                mangle  = mangle.slice(0, start) ~ mangleArguments(
                    GET(specialized).args);
        }

        ////////////////////////////////
        SWAP(_current_fn, current_fn0);

        Scope_pop(_scope, scope0);
        _scope_skip = scope_skip0;
        ////////////////////////////////

        return specialized;
    }


    //

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(solve: false, :node);
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(solve: true, :node, :prep);
    }

    fn __solveStruct(solve!: bool, node: Node, prep?!: SolvedNode): SolvedNode
    {
        mut out = prep || solved(node, Type());
        ref structType = out.type;

        mut id = node.value;
        let origId = id;
        if (!origId)
            id = _current_fn.value || "Anon";

        fn ensureTypedef()
        {
            if (out.target || !origId)
                return;

            let NO_IMPORTS: i32[];
            let NO_LOCALS: ScopeMemo;
            let template = Template(:node, imports: NO_IMPORTS, locals: NO_LOCALS, parent_idx: 0);

            out.target = Scope_Typedef(_scope, origId, structType, node.flags, :template);
        }

        // Add the arity-0 type entry.
        if (!(_current_fn.flags & F_TEMPLATE) && !out.target)
        {
            structType = initStruct(id, node.flags);
            ensureTypedef();
        }

        if (!solve)
            return out;

        /////////////////////////////////////////////////
        _current_struct && fail("struct-within-struct");
        defer _current_struct = Target();
        _current_struct = out.target;
        /////////////////////////////////////////////////

        // Struct fields only.
        let members = node.items;
        mut innerScope: ScopeItem[];
        let items = solveStructMembers(:id, :node.flags, :structType, :members, :innerScope);
        out.items = items;

        ensureTypedef();

        // Add a default constructor.
        {
            shadow mut members: SolvedNode[];
            mut fields: StructField[];

            shadow let items = out.items;
            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == "let" && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value        || fail(),
                            type: item.type.vtype   || fail()));
                }
            }

            //
            let quals0 = structType.quals;
            let quals1 = structType.quals &= finalizeStruct(structType.canon, fields, innerScope);

            if (out.target)
                GET_mut(out.target).type.quals = structType.quals;

            // Link up the constructor.
            // TODO don't Scope_add when templated.
            //
            // TODO drop DefCtors, we have too many things already,
            //  ideally the typedef should suffice.
            //
            let ctor = DefCtor(id, structType, members, into: lookupStruct(structType).ctor);
            lookupStruct_mut(structType.canon).ctor = ctor;

            //
            if (quals0 != quals1 && out.target)
                invalidateUsers(GET(out.target));
        }

        // So we can type x = struct { what };
        out.type = structType;

        if (out.target)
            GET_mut(out.target).solved = out;

        return out;
    }

    fn solveStructMembers(
        ref id: string, flags: i32,
        members: Node[], ref structType: Type, ref innerScope: ScopeItem[]): SolvedNode[]
    {
        mut out: SolvedNode[];

        // Pass 0.
        for (mut i = 0; i < members.len; i++)
        {
            let node = members[i];
            if (node.kind == "let")
                out.push(solveField(:node));
            else
                fail("solveStructMembers_1: " ~ node.kind);
        }

        if (!structType)
        {
            let sig     = mangleArguments(out);
            let hash    = tea::hash62(sig, chars: 4);
            id         ~= "_" ~ hash;

            structType  = initStruct(:id, :flags);
        }

        // Dereferencing a struct does not require it
        //  to have any particular qualities.
        shadow let structType = despeculateStruct(structType);

        // Pass 1.
        for (mut i = 0; i < out.len; i++)
        {
            let node = out[i];
            if (node.kind == "let")
                solveField(:node, :structType, :innerScope);
            else
                fail("solveStructMembers_2: " ~ node.kind);
        }

        return out;
    }

    fn solveField(node: Node): SolvedNode
    {
        node.items[LET_INIT] &&
        node.items[LET_INIT].kind != "definit" &&
            fail("All structs must be zerofilled by default."
                ~ " Please remove the initializer of struct member `" ~ node.value ~ "`.");

        return solveLetLike_dontTouchScope(node);
    }

    fn solveField(structType: Type, node: SolvedNode, ref innerScope: ScopeItem[])
    {
        let id = node.value;
        let target = Field(:id, :structType, fieldType: node.type);

        innerScope.push(ScopeItem(:id, :target));

        if (node.flags & F_USING)
            scope_using(target);
    }


    //////////////////////////////////////////////////////////
    //
    // Note - as soon as we re-assign the return value,
    //  we want to re-iterate all the return statements,
    //   because that can change our copy/move decision.

    fn reportReturnType(type: Type)
    {
        // Check annot.
        if (_current_fn.ret_expect)
            checkAssignable(host: _current_fn.ret_expect, type, "Expression non-assignable to return annotation");

        // Check multiple returns.
        if (_current_fn.ret_actual)
            checkAssignable(host: _current_fn.ret_actual, type, "Non-assignable return types");
        else
            _current_fn.ret_actual = type || fail();

        // Counter.
        _current_fn.ret_count++;
    }

    fn stashReturn(solved: SolvedNode): Target
    {
        let target = Scope_create(_scope, "return",
            local_of: _current_fn.target.index || fail(), :solved);

        _current_fn.returns ~= target;

        return target;
    }

    fn finalizeReturns()
    {
        // cpy/move.
        if (!_current_fn.ret_actual.is_ref)
        {
            for (mut i = 0; i < _current_fn.returns.len; i++)
            {
                ref ret = GET_mut(_current_fn.returns[i]);
                maybeCopyOrMove(ret.solved, _current_fn.ret_actual);
            }
        }
    }

    fn solveReturn(node: Node): SolvedNode
    {
        if (!node.items)
        {
            reportReturnType(t_void);
            return solved(node, t_never);
        }


        // We'll detach the return expression for further fiddling elsewhere.

        mut expr = solveNode(
            node.items.only,
            type: _current_fn.ret_actual || _current_fn.ret_expect);

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if (expr.type.lifetime.Lifetime_killedByReturnOf(_current_fn.target) &&
            expr.type.is_ref)                               //
        {                                                   //
            let nrvo = expr.kind == "call"                  //
                    && expr.items.len == 0                  //
                    && expr.target.GET.kind == "var";       //
                                                            //
            expr = createMove(expr, nrvo);                  //
        }                                                   //
                                                            //
        //////////////////////////////////////////////////////

        reportReturnType(expr.type);
        return solved(node, t_never, target: stashReturn(expr));
    }


    //////////////////////////////////////////////////////////

    fn checkAssignable(
        host: Type, guest: Type, err: string,
        id?: string, sep?: string)
    {
        isAssignable(
            :host   || fail("Bad host type."),
            :guest  || fail("Bad guest type."))
                    || fail(err ~ (id && " `" ~ id ~ "`") ~ ": "
                                ~ host .humanizeType() ~ (sep || " <- ")
                                ~ guest.humanizeType());
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveLetLike_dontTouchScope(node: Node): SolvedNode
    {
        let n_annot     = node.items[LET_TYPE];
        let n_init      = node.items[LET_INIT];

        mut annot       = n_annot && evalTypeAnnot(n_annot);
        if (annot.type && node.flags & F_REF)
            annot.type  = add_mutref(annot.type, Lifetime_temporary);

        mut init        = n_init && solveNode(n_init, annot.type);

        annot.type || init.type || fail(
            "Variable declarations without type annotations must be initialized.");

        if (annot.type && init.type)
        {
            checkAssignable(host: annot.type, init.type,
                "Type annotation does not match init expression",
                    node.value, "=");

            annot.type.lifetime = init.type.lifetime;
        }

        if (node.flags & F_REF)
            init.type.is_mutref || !init && node.flags & F_ARG || fail(
                "`ref` variables must be initialized to a mutable reference.");

        //
        let t_let   = annot.type
                        ? node.flags & F_ARG && !(node.flags & F_MUT)
                            ? add_ref(annot.type, Lifetime_temporary)
                            : annot.type
                    : init.type.is_mutref || node.flags & F_MUT
                        ? node.flags & F_REF
                            ? init.type
                            : clear_refs(init.type)
                        : node.flags & F_ARG && !(node.flags & F_MUT)
                            ? add_ref(init.type, Lifetime_temporary)
                            : init.type;

        if (init)
            maybeCopyOrMove(init, t_let);

        //
        mut out = solved(node, t_let, [annot || init, init]);

        if !(_current_fn || node.flags & F_FIELD)
        {
            if (out.flags & F_MUT || out.type.is_mutref)
                fail("Mutable statics are not currently allowed.");

            out.kind = "global";
        }

        return out;
    }

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);
        Scope_Typedef(_scope, node.value, annot.type, node.flags);
        return createEmpty();
    }

    fn solveLet(node: Node): SolvedNode
    {
        mut out         = solveLetLike_dontTouchScope(node);
        let global      = out.kind == "global";

        let kind = global               ? "global"
                 : node.flags & F_ARG   ? "arg"
                 : out.type.is_ref      ? "ref"
                                        : "var";

        let id = out.value;

        //
        if (!addroffn::X_unpackAddrOfFnBinding(_scope.items, id, out.type))
        {
            let target = out.target = Binding(:id, :kind, :node.flags, :out.type);

            if (global)
                GET_mut(target).solved = out;

            if (out.flags & F_USING)
                scope_using(target);
        }

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok = solveNode(node.items[0]);

        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, var_ok.type,
            [ var_ok, var_err, catch ]);
    }

    fn solveTryCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        /////////////////////////////////
        let scope0  = Scope_snap(_scope);
        /////////////////////////////////

        let try     = solveNode(node.items[0]);

        ///////////////////////////////////////
        Scope_pop(_scope, scope0);
        shadow let scope0 = Scope_snap(_scope);
        ///////////////////////////////////////

        let err     = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        err.kind == "let" && isAssignableAsArgument(
            host: err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, t_void, [ try, err, catch ]);
    }

    fn findModule(fuzimport: string): &Module
    {
        let fname = resolveFile_x(fuzimport);

        let modules = ctx.modules;
        for (mut i = 1; i < modules.len; i++)
        {
            let m = modules[i];
            if (m.fname == fname)
                return m;
        }

        fail("Cannot locate: " ~ fname);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let m = findModule(fuzimport: node.value);
        Scope_import(m.modid);

        //
        return createEmpty();
    }

    fn solveDefer(node: Node): SolvedNode
    {
        let item = solveNode(node.items.only);
        return solved(node, t_void, [ item ]);
    }


    //

    fn Scope_lookupType(mut id: string, flags: i32 = 0): Type
    {
        mut scope_iterator: i32;
        mut overloadIdx: Target;

        let qualified = flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        while (overloadIdx =
            scope.search(id, scope_iterator,
                scope_skip: !qualified && _scope_skip))
        {
            let maybe = GET(overloadIdx);
            if (maybe.kind == "type")
                return maybe.type || fail();
        }

        return fail("No type `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupType(annot: Node): Type
    {
        return Scope_lookupType(annot.value, :annot.flags);
    }


    //

    fn evalTypeParam(id: string): Type
    {
        return Scope_lookupType(
            "$" ~ (id   || fail("Falsy type param id.")))
                        || fail("No type param `$" ~ id ~ "` in scope.");
    }

    fn solveTypeParam(node: Node): SolvedNode
    {
        return solved(node, evalTypeParam(node.value));
    }

    fn solveAddrOfFn(node: Node): SolvedNode
    {
        let id = node.value;
        let type = addroffn::X_solveAddrOfFn(_scope, :id, _scope_skip);
        return createEmpty(:type);
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        fn T(i: i32 = 0) evalTypeAnnot(node.items[i]).type;

        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len == 1)
            {
                if (node.value == "&")
                    return solved(node, add_ref(T, Lifetime_temporary));

                if (node.value == "&mut")
                    return solved(node, add_mutref(T, Lifetime_temporary));

                if (node.value == "[]")
                    return solved(node, createArray(T));
            }
            else if (items.len == 2)
            {
                if (node.value == "Map")
                    return solved(node, createMap(T(0), T(1)));
            }

            return solveCall(node);
        }
        else if (node.kind == "typeparam")
        {
            return solved(node, evalTypeParam(node.value));
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            return solved(node, createSlice(T, Lifetime_temporary));
        }

        return fail("TODO evalTypeAnnot");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, ref typeParams: Map(string, Type)): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    mut t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : fail("TODO trySolveTypeParams unary call");

                    if (!t)
                        return false;

                    // HACK TODO FIX!
                    //  keep the ref around for clear-slice to work.
                    if (node.value == "&mut" && items[0].kind == "arrlit" && items[0].items.len == 1)
                        t = add_ref(t, Lifetime_temporary);

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                return isAssignable(
                    Scope_lookupType(node),
                        type);
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            ref _param = (typeParams[id] ||= Type);
            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = tryClear_slice(type);
            return t && trySolveTypeParams(
                node.items[0] || fail(), t, typeParams);
        }

        return fail("TODO trySolveTypeParams fallthrough");
    }

    fn evalTypePattern(node: Node): bool
    {
        if (node.kind == "and")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i]))
                    return false;

            return true;
        }
        else if (node.kind == "or")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (evalTypePattern(node.items[i]))
                    return true;

            return false;
        }
        else if (node.kind == "typeassert")
        {
            let left  = node.items[0] || fail();
            let right = node.items[1] || fail();

            // We'll have to figure out the type tag nonsense at some point.
            //  Perhaps when we have an `any` type,
            //   we could subtype it with the desired quals.
            if (left.kind  == "typeparam" && right.kind == "typetag")
                return type_has(
                    evalTypeParam(left.value),
                    right.value || fail("Falsy type tag."));
            else
                return isAssignable(
                    host: evalTypeAnnot(right).type,
                          evalTypeAnnot(left ).type);
        }

        return fail("TODO evalTypePattern fallthrough: "
                    ~ node.kind ~ "(" ~ node.items.len ~ ")");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            value:  id,
            token:  (_here || fail()));
    }

    fn dequalify_andGetScope(ref id: string): &Scope
    {
        let split = id.find('\t');
            split >= 0 || fail();

        let fname = id.slice(0, split);
            id    = id.slice(split + 1);

        let other = findModule(fuzimport: fname);
        if (other.modid != module.modid)
            return other.out.solve.scope;

        return _scope;
    }

    fn solveCall(node: Node, target?!: Target): SolvedNode
    {
        mut id = node.value;
        if (!id) target || fail();

        // Qualified?
        let qualified = node.flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        mut args = solveNodes(node.items);

        //
        mut callTargIdx = match__mutargs(
            scope, !qualified && _scope_skip,
            id, args, node.flags, :target);

        mut callTarg = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == "p-unshift";

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead("__partial"),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        mut itemType = type && tryClear_array(type);

        // Default constructor calls.
        if (!itemType && type.isStruct)
            return solveCall(node,
                target: lookupStruct(type).ctor);

        // Nope, it's an array literal.
        mut items   = solveNodes(node.items, itemType);
        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail("Cannot infer empty arraylit.");

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                "[array literal] No common supertype.");
        }

        //
        if (itemType.is_ref || itemType.lifetime)
            fail("Array items cannot be refs.");

        for (mut i = 0; i < items.len; i++)
            maybeCopyOrMove(items[i], itemType);

        return solved(node, createArray(itemType), items);
    }


    //

    fn createLet(target: Target, flags: i32 = 0): SolvedNode
    {
        let overload = GET(target);

        return SolvedNode(
            kind: "let", :flags, token: _here || fail(),
            value: overload.name, :overload.type, :target);
    }

    fn injectImplicitArg(id: string, type: Type, becauseOf!: Target): Target
    {
        _current_fn.items || fail(
            "No implicit `" ~ id ~ "` in scope, needed to call `" ~ GET(becauseOf).name ~ "`.");

        // Reuse existing or add new argnode.
        for (mut i = 0; i < _current_fn.items.len + FN_ARGS_BACK; i++)
        {
            let arg = _current_fn.items[i];
            if (arg.value == id)
            {
                checkAssignable(host: type, arg.type,
                    "Implicit arg collision", id);

                return arg.target || fail();
            }
        }

        // We'll be adding a new thing here.
        let newArgIdx   = _current_fn.items.len + FN_ARGS_BACK;

        /////////////////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0      = Scope_snap(_scope);
        let ret         = Binding(id, type, flags: F_IMPLICIT | F_ARG);
        Scope_pop(_scope, scope0);
        /////////////////////////////////////////////////////

        let newArgNode  = createLet(ret, F_IMPLICIT);
        _current_fn.items.insert(newArgIdx, newArgNode);

        return ret;
    }

    fn bindImplicitArg(name: string, type: Type, becauseOf!: Target): SolvedNode
    {
        let id = name;
        mut args: SolvedNode[];

        let target = tryMatch__mutargs(_scope, _scope_skip, :id, :args, retType: type)
            || injectImplicitArg(:id, :type, :becauseOf)
            || fail();

        let o = GET(target);
        o.flags & F_IMPLICIT || fail(
            "Matching a non-implicit item in scope: `" ~ name ~ "`, binds to call to `" ~ GET(becauseOf).name ~ "`.");

        return CallerNode(
            createRead("__implicit"), :o.type, :target);
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let n0      = node.items[0];
        let n1      = node.items[1];
        let n2      = node.items[2];

        let cond    = solveNode(n0, t_bool);
        mut cons    = n1 && solveNode(n1, type);
        mut alt     = n2 && solveNode(n2, cons.type || type);

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt || cons;

        let priType = priExpr.type;
        let secType = secExpr.type;

        if (!type.is_void && !type.is_bool)
        {
            type = !secType ? priType
                            : type_tryInter(priType, secType);

            type || fail("[if] No common supertype: `" ~ serializeType(priType) ~ " : " ~ serializeType(secType) ~ "`.");
            type.is_ref || !type.lifetime || fail("[if] stray lifetime");

            if (cons)
                maybeCopyOrMove(cons, type);
            if (alt)
                maybeCopyOrMove(alt, type);
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !andLast.type.is_never
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [], target = Target)
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type, :target);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        if (overload.kind == "field")
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs(from: headType, to: type);
        }

        // Tag copies and moves.
        else if (args)
        {
            let host_args = overload.args || fail("CallerNode: no host args.");
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), host_args[i].type,
                    isArgument: true);

            type.lifetime = Lifetime_replaceArgsAtCallsite(overload, args);
        }

        // Track deps.
        if (target.modid == module.modid)
        {
            // Tracking call graph & type annotations.
            if (overload.kind == "fn" || overload.kind == "type")
            {
                ref t = GET_mut(target);

                if (_current_struct)
                    GET_mut(target).used_by.set::add(
                        _current_struct.index);
                else
                    t.used_by.set::add(
                        _current_fn.target.index);
            }

            // Robust closure tracking.
            if (_current_fn)
            {
                let o = GET(target);
                if (o.flags & F_LOCAL)
                    _current_fn.locals_used.set::add(target.index);

                _current_fn.locals_used.set::add_set(o.closes_over);
            }
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type,
        isArgument = false): void
    {
        // Clear mutrefs unless needed.
        if !(slot.is_mutref)
            node.type = clear_mutref(node.type);

        // No copy needed when the slot is a reference.
        if (slot.is_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type = clear_refs(node.type);

            return;
        }

        // Also, no copy needed when the expression is a value.
        if (!node.type.is_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type = clear_refs(node.type);
            return;
        }

        if !(slot.quals & q_rx_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (WARN_ON_IMPLICIT_COPY)
        {
            // if !(node.type.quals & q_trivial)
            //     println("WARN ", _here.line, ":", _here.col, ":\timplicit copy ", node.type.canon);
        }

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode, nrvo = false): SolvedNode
        SolvedNode(
            kind:   nrvo ? "nrvo" : "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(
        nodes: Node[],
        type_all?: Type, type_last?!: Type,
        use_type_last?!: bool,
        TEMP_open_templates?!: bool,
        TEMP_template_scope?!: ScopeMemo): SolvedNode[]
    {
        mut result: SolvedNode[];

        ////////////////////////////////////////////////////////
        let here0   = _here;
        defer _here = here0;
        ////////////////////////////////////////////////////////

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            mut unorderedClass = unorderedClassify(node.kind);
            if (!unorderedClass)
            {
                _here       = node.token || _here;
                result[i]   = solveNode(:node, type:
                    i == nodes.len - 1 && use_type_last
                        ? type_last : type_all);

                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            ////////////////////////////
            mut resolve0 = SLOW_resolve;
            ////////////////////////////

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (shadow mut i = i0; i < nodes.len; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, prep: falsy node");
                if (unorderedClassify(node.kind) != unorderedClass)
                {
                    i1 = i;
                    break;
                }

                _here = node.token || _here;
                result[i] = unorderedPrep(node);
            }

            // Later we'll continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++

            // Second pass, solve all.
            for (shadow mut i = i0; i < i1; i++)
            {
                shadow let node = nodes[i] || fail("solveNodes, solve: falsy node");
                _here = node.token || _here;
                result[i] = unorderedSolve(node, result[i]);
            }

            // Exhaust the resolve queue here.
            {
                mut some = SLOW_resolve != resolve0
                        && SLOW_resolve != resolve_done;

                while (some)
                {
                    some = false;

                    ////////////////////////
                    resolve0 = SLOW_resolve;
                    ////////////////////////

                    for (shadow mut i = i0; i < i1; i++)
                    {
                        let r = result[i];
                        if (r.kind != "fndef" && r.kind != "struct" || !resolveIfNeeded_nonTemplateFn(r.target))
                            continue;

                        some = SLOW_resolve != resolve0
                            && SLOW_resolve != resolve_done;
                    }

                    if (TEMP_open_templates)
                    {
                        for (shadow mut i = 0; i < _open_templates.len; i++)
                        {
                            let r = _open_templates[i];
                            if (!resolveIfNeeded_templateSpec(r))
                                continue;

                            some = SLOW_resolve != resolve0
                                && SLOW_resolve != resolve_done;
                        }
                    }
                }
            }

            // Lock things down.
            for (shadow mut i = i0; i < i1; i++)
            {
                let r = result[i];
                if (r.kind == "fndef")
                {
                    ref o = GET_mut(r.target);
                    o.status |= SS_FINALIZED;
                }
            }

            // Also freeze templates.
            if (i != nodes.len - 1 && TEMP_open_templates)
                freezeTemplates(TEMP_template_scope);
        }

        // Also freeze templates.
        if (TEMP_open_templates)
            freezeTemplates(TEMP_template_scope);

        result.len == nodes.len || fail("solveNodes: result.len != nodes.len");

        return result;
    }

    fn freezeTemplates(scope0: ScopeMemo)
    {
        for (shadow mut i = _open_templates.len; i --> 0; )
        {
            let r = _open_templates[i];
            if (scope0)
            {
                let p = GET(r.overloadIdx);
                if !(p.template.locals > scope0)
                    continue;
            }

            ref o = GET_mut(r.spec);
            {
                o.status & SS_DIRTY && fail(
                    "freezeTemplates: attempting to freeze a dirty template.");

                o.status |= SS_FINALIZED;
                _open_templates.splice(i, 1);
            }
        }
    }

    fn resolveIfNeeded_nonTemplateFn(target: Target): bool
    {
        let overload = GET(target);
        if !(overload.status & SS_DIRTY)
            return false;

        GET_mut(target).status &= ~SS_DIRTY;
        resolve_done++;

        //////////////////
        let here0 = _here;
        _here = overload.template.node.token;
        //////////////////

        unorderedSolve(
            overload.template.node,
            overload.solved);

        //////////////
        _here = here0;
        //////////////

        return true;
    }

    fn resolveIfNeeded_templateSpec(ot: OpenTemplate): bool
    {
        let overload = GET(ot.spec);
        if !(overload.status & SS_DIRTY)
            return false;

        GET_mut(ot.spec).status &= ~SS_DIRTY;
        resolve_done++;

        //////////////////
        let here0 = _here;
        _here = overload.template.node.token;
        //////////////////

        mut mangle = ot.mangle;

        doTrySpecialize(
            :ot.overloadIdx, :ot.args, :mangle,
            into: ot.spec);

        //////////////
        _here = here0;
        //////////////

        return true;
    }


    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
    {
        // Ensure can't reimport self.
        _scope.imports ~= module.modid;

        // Load prelude.
        _Scope_import__forceCopy(0);
    }
    else
    {
        // Pre-populate prelude with primitive types and such.
        _scope = listGlobals();
    }

    // Solve.
    {
        let root  = solveNode(parse);
        let scope = Scope_exports(_scope, :module.modid);

        _current_fn && fail("non-empty _current_fn.");
        SLOW_resolve == resolve_done || fail("Some overload was left dirty.");
        _open_templates && fail("Some template was left open.");

        // Run the thing.
        return SolverOutput(:root, :scope,
            :SLOW_resolve);
    }
}
