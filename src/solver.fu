import helpers;
import parser;
import scope;
import context;
import types;
import lifetimes;

let WARN_ON_IMPLICIT_COPY = false;



///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////
////////
////////
////////
////////     Solver.

pub fn solve(
    implicit ctx: Context,
    implicit ref module: Module,
    parse: Node): SolverOutput
{
    mut _here:          TokenIdx;
    mut _scope:         Scope;
    mut _root_scope:    ScopeMemo;
    mut _scope_skip:    ScopeSkip;

    struct CurrentFn
    {
        using out: SolvedNode;
        return_idx: ScopeMemo; // <- truth from here
        parent_idx: i32;
        locals_used?: i32[];
    };

    mut _current_fn:    CurrentFn;


    //

    mut SLOW_resolve:   i32;
    mut resolve_done:   i32;

    struct OpenTemplate
    {
        overloadIdx:    Target;
        spec:           Target;
        args:           SolvedNode[];
        mangle:         string;
    };

    mut _open_templates: OpenTemplate[];


    //

    let t_string = createArray(t_byte);


    //

    fn _Scope_import__forceCopy(modid: i32): void
    {
        _scope.items ~= ctx.modules[modid].out.solve.scope.items;
    }

    fn Scope_import(modid: i32): void
    {
        if (_scope.imports.has(modid)) return;

        modid || fail("Attempting to import modid-0.");
        _scope.imports ~= modid;
        _Scope_import__forceCopy(modid);
    }

    fn GET(target: Target): Overload
    {
        if (target.modid == module.modid)
            return _scope.overloads[target.index - 1];

        return ctx.modules[target.modid]
            .out.solve.scope.overloads[target.index - 1];
    }

    fn GET_mut(target: Target)
    {
        target.index > 0 && target.modid == MODID || assert();
        return _scope.overloads[target.index - 1];
    }

    fn GET_local(index: i32): Overload
    {
        return GET(Target(modid: module.modid, :index));
    }


    //

    fn fail(mut reason: string = ""): never
    {
        let here = _here._token;

        if (!reason)
            reason = "Unexpected `" ~ here.value ~ "`.";

        let fname = _here._fname;
        let l0 = here.line;
        let c0 = here.col;

        let addr = "@" ~ l0 ~ ":" ~ c0;

        return throw(fname ~ " " ~ addr ~ ":\n\t" ~ reason);
    }


    //

    fn Lifetime_next(): Lifetime
        Lifetime_fromScopeIdx( _scope.items.len + 1 );

    fn Binding(id: string, type: Type, mut flags!: i32, kind = "var")
    {
        let local_of = !(flags & F_FIELD) && _current_fn.target.index;
        if (local_of)
        {
            kind == "var" || kind == "arg" || kind == "ref" || fail(
                "Nope, getting it wrong.");

            flags |= F_LOCAL;
        }

        return Scope_add(
            _scope, :kind,
            :id || fail(), :type || fail(), :flags, :local_of);
    }

    fn Field(id: string, structType: Type, fieldType: Type)
    {
        return Scope_add(
            _scope, "field",
            :id || fail(), fieldType || fail(),
            1, 1, [ Argument(name: "this", type: structType) ],
            flags: F_PUB);
    }

    fn TemplateDecl(node: Node)
    {
        let id      = node.value;
        let items   = node.items;

        mut min     = 0;
        let max     = node.kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TemplateDecl: non-fn node.");

        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let arg = items[i];
            arg.kind == "let" || fail();
            let name = arg.value || fail();
            args.push(Argument(:name));

            if (!arg.items[LET_INIT])
                min++;
        }

        //
        let template = Template(
            node,
            imports: !_current_fn && _scope.imports,
            locals:   _current_fn && Scope_snap(_scope));

        return Scope_add(
            _scope,
            kind: "template", :id, Type,
            :min, :max, :args, :template,
            :node.flags);
    }

    fn FnDecl_init(target: Target, kind: string, id: string, template: Template)
    {
        ref overload = GET_mut(target);

        overload.name = id;
        overload.kind = kind;
        overload.template = template;

        Scope_set(_scope, :id, :target);
    }

    fn FnDecl_update(solved: SolvedNode, locals_used: i32[], parent_idx: i32)
    {
        let items = solved.items;

        mut min = 0;
        let max = items.len + FN_RET_BACK;
        mut args: Argument[];
        for (mut i = 0; i < max; i++)
        {
            let argNode = items[i];
            argNode.kind == "let" || fail();

            let isImplicit = !!(argNode.flags & F_IMPLICIT);
            let arg = Argument(
                type:       argNode.type  || fail(),
                name:       argNode.value || fail(),
                default:    !isImplicit && argNode.items[LET_INIT],
                flags:      argNode.flags);

            if (!arg.default && !isImplicit)
                min++;

            args.push(arg);
        }

        // Unconditionally replacing the stuff.
        ref overload    = GET_mut(solved.target);

        let args_len0   = overload.args.len;
        let closure0    = overload.closes_over.len;

        overload.type   = items[items.len + FN_RET_BACK].type || fail("FnDecl_update: no return type.");
        overload.min    = min;
        overload.max    = max;
        overload.args   = args;
        overload.flags  = solved.flags;

        overload.solved = solved;

        // See which one of the locals we've used are not our own.
        {
            mut closes_over: i32[];

            for (mut i = 0; i < locals_used.len; i++)
            {
                let o = GET_local(locals_used[i]);
                if (o.local_of != solved.target.index)
                    closes_over ~= locals_used[i];
            }

            overload.closes_over = closes_over;
            overload.local_of = parent_idx;
        }

        // TODO FIX starting the diff with just number of arguments,
        //  which is fine for implicit cycling,
        //   then we gotta move on to bigger and better things.
        if (args_len0 != overload.args.len ||
            closure0  != overload.closes_over.len)
        {
            for (mut i = 0; i < overload.used_by.len; i++)
                makeDirty(overload.used_by[i], :parent_idx);
        }
    }

    fn makeDirty(index: i32, parent_idx: i32): void
    {
        let userIdx = Target(modid: module.modid, :index);

        ref user = GET_mut(userIdx);
        if !(user.status & SS_DIRTY)
        {
            let their_parent = user.local_of;
            index >= parent_idx || fail(
                "makeDirty: climbed too far up.");

            if (user.status & SS_FINALIZED)
            {
                if (their_parent)
                    return makeDirty(their_parent, :parent_idx);

                fail("Overload finalized, cannot make dirty.");
            }

            user.status |= SS_DIRTY;
            SLOW_resolve++;
        }
    }

    fn DefCtor(id: string, type: Type, members: SolvedNode[]): Target
    {
        let max = members.len;
        mut min = 0;
        mut args: Argument[];

        for (mut i = 0; i < members.len; i++)
        {
            let member = members[i];

            let arg = Argument(
                name:       member.value || fail(),
                type:       member.type  || fail(),
                default:    member.items[LET_INIT],
                flags:      member.flags & F_MUSTNAME);

            if (!arg.default)
                min++;

            args.push(arg);
        }

        if (!max) return Target();
        if (!min) min++;

        // TODO don't Scope_add when templated.
        return Scope_add(
            _scope,
            "defctor", :id, :type,
            :min, :max, :args,
            flags: F_PUB);
    }

    fn tryCreateDefinit(type: Type): SolvedNode
    {
        // Cannot definit mutrefs.
        if (type.quals & q_mutref)
            return SolvedNode();

        return createDefinit(type);
    }

    fn createDefinit(type: Type): SolvedNode
    {
        let token = _here || fail();

        if (type.quals & q_integral)
            return SolvedNode(
                kind: "int", :token, :type,
                value: "0");

        if (type.quals & q_floating_pt)
            return SolvedNode(
                kind: "real", :token, :type,
                value: "0");

        return SolvedNode(
            kind: "definit", :token, :type);
    }

    fn solveDefinit(type: Type): SolvedNode
    {
        if (!type)
            return fail(
                "Cannot solve definit, no inferred type.");

        return tryCreateDefinit(type)
            || fail("Cannot definit: " ~ serializeType(type));
    }

    fn solveTypeAssert(node: Node): SolvedNode
    {
        let left   = node.items[0];
        let right  = node.items[1];

        // left -> right.
        let expect = evalTypeAnnot(right).type;
        let actual = solveNode(left, expect);

        checkAssignable(host: expect, actual.type,
            "Type assertion failed");

        return actual;
    }


    //

    fn Partial(id: string, viaIdx: Target, overloadIdx: Target)
    {
        let via      = GET(viaIdx);
        let overload = GET(overloadIdx);

        mut kind = "p-unshift";
        mut min = overload.min - 1;
        mut max = overload.max - 1;
        min >= 0 && max >= min || fail();

        mut args = overload.args.slice(1);
        mut flags = 0;

        // Everything that's not a local/namespace/static/constant
        //  needs a value through which to activate.
        if (via.kind != "var" &&
            via.kind != "global" &&
            via.kind != "arg" &&
            via.kind != "ref")
        {
            kind = "p-wrap";
            min++;
            max++;

            flags |= F_PUB;

            mut arg = Argument(
                type: via.args[0].type,
                name: "using");

            args.unshift(arg);
        }

        return Scope_add(
            _scope,
            :kind, :id, :overload.type, :flags,
            :min, :max, :args,
            partial: Partial(viaIdx, overloadIdx));
    }


    // We need a smarter way of doing this.

    fn scope_using(viaIdx: Target)
    {
        let via     = GET(viaIdx);
        let actual  = via.type || fail();

        fn visit(item: ScopeItem)
        {
            // Skip over operators.
            if (!item.id.hasIdentifierChars)
                return;

            let overloadIdx = item.target;
            let overload = GET(overloadIdx);

            // Needs at least one argument.
            if (overload.min < 1)
                return;

            // TODO using + templates, the fuck do we do?
            if (overload.kind == "template")
                return;

            // Skip over defctors -
            //  we really only want this for fields & properties,
            //   but there's no way to tell a property from a fn,
            //    this at least is easy to disambiguate.
            if (overload.kind == "defctor")
                return;

            // See if we fit.
            let expect = overload.args[0] || fail();
            if (!isAssignableAsArgument(expect.type, actual))
                return;

            //
            Partial(item.id, viaIdx, overloadIdx);
        }

        // Visit stuff currently in scope.
        for (mut i = 0; i < _scope.items.len; i++)
        {
            if (i == _scope_skip.start.items_len)
                i  = _scope_skip.end  .items_len;

            visit(_scope.items[i]);
        }

        // Also bring in stuff from the module of origin.
        let extra_modid = actual.modid;
        if (!_scope.imports.has(extra_modid))
        {
            let items = ctx.modules[extra_modid].out.solve.scope.items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }

        // Struct members.
        if (actual.isStruct)
        {
            let items = lookupStruct(actual).items;
            for (mut i = 0; i < items.len; i++)
                visit(items[i]);
        }
    }


    //

    fn getNamedArgReorder(
        ref result: i32[],
        names: string[],
        host_args: Argument[]): bool
    {
        result.clear();

        //
        mut used   = 0;
        mut offset = 0;
        for (mut i = 0; i < host_args.len; i++)
        {
            mut idx = names.find(host_args[i].name);
            if (idx < 0)
            {
                for (shadow mut i = offset; i < names.len; i++)
                {
                    offset++;
                    if (!names[i])
                    {
                        idx = i;
                        break;
                    }
                }
            }
            else
            {
                used++;
            }

            result.push(idx);
        }

        // Fail if some name ended up unused.
        //  TODO FIX THIS MESS
        if (used != names.len)
        {
            for (mut i = 0; i < names.len; i++)
                if (!names[i])
                    used++;

            if (used != names.len)
                return false;
        }

        // Drop trailing misses.
        while (result && result[result.len - 1] < 0)
            result.pop();

        // Return nothing if not needed.
        for (mut i = 0; i < result.len; i++)
            if (result[i] != i)
                return true;

        result.clear();
        return true;
    }

    fn tryMatch__mutargs(
        scope: Scope, scope_skip: ScopeSkip,
        mut id: string, ref args: SolvedNode[],
        flags?!: i32, retType?!: Type, target?!: Target): Target
    {
        mut matchIdx: Target;

        let arity = args.len;

        // Prep labelled args for remap.
        mut names: string[];
        if (flags & F_NAMED_ARGS)
        {
            mut some = false;

            for (mut i = 0; i < arity; i++)
            {
                let arg = args[i];
                names.push(arg.kind == "label"
                    ? { some = true; arg.value } || fail()
                    : "");
            }

            some || fail();
        }

        mut reorder: i32[];
        mut args_mangled: string;

        //
        let extra_modid = flags & F_ACCESS && args.if_first.type.modid;
        let extra_items = extra_modid
                        && !_scope.imports.has(extra_modid)
                        && ctx.modules[extra_modid].out.solve.scope.items;

        //
        let unary_arg_t = arity == 1 && args[0].type;
        let field_items = unary_arg_t.isStruct && lookupStruct(unary_arg_t).items;

        //
        mut alternate_ids: string[];

        for (;;)
        {
            mut scope_iterator: i32;
            mut overloadIdx: Target;

            :NEXT
            while (overloadIdx =
                scope.search(id, scope_iterator,
                    :scope_skip, :target,
                    :extra_items, :field_items))
            {
                :TEST_AGAIN
                while (true)
                {
                    let overload = GET(overloadIdx);

                    ////////////////////////////////////////////
                    // Conversions / typename aliases.
                    if (arity && overload.kind == "type")
                    {
                        let alt = overload.type.canon;
                        if (alt != id) // e.g. i32
                            alternate_ids.push(alt);
                    }
                    ////////////////////////////////////////////

                    //
                    if (overload.min > arity || overload.max < arity)
                        continue :NEXT;

                    // Match by return.
                    if (retType && !isAssignable(retType, overload.type || fail()))
                        continue :NEXT;

                    // Match by argnames.
                    if (names && !getNamedArgReorder(reorder, names, overload.args))
                        continue :NEXT;

                    // Specialize.
                    if (overload.kind == "template")
                    {
                        if (reorder)
                            fail("TODO handle argument reorder in template specialization.");

                        let specIdx = trySpecialize(
                            :overloadIdx, :args,
                            :args_mangled ||= mangleArguments(args));

                        if (!specIdx)
                            continue :NEXT;

                        // Repeat arity checks and such.
                        overloadIdx = specIdx;
                        continue :TEST_AGAIN;
                    }

                    if (args)
                    {
                        // Type check args.
                        let host_args = overload.args;

                        let N = reorder ? reorder.len
                                        : args.len;

                        /////////////////
                        // Literal fixup.
                        let undo_literal_fixup = args;
                        //        /LITFIX
                        /////////////////

                        for (mut i = 0; i < N; i++)
                        {
                            let host_arg = host_args[i];

                            let callsiteIndex = reorder ? reorder[i]
                                                        : i;
                            if (callsiteIndex < 0)
                            {
                                // Argument may not be defaulted -
                                //  we might be supplying defaults via names
                                //   before we've actually exhausted
                                //    all the non-defaulted stuff.
                                if (!host_arg.default && !(host_arg.flags & F_IMPLICIT))
                                    continue :NEXT;

                                continue;
                            }

                            // Explicit argname requirements.
                            else if (host_arg.flags & F_MUSTNAME)
                            {
                                if (names.len <= callsiteIndex || !names[callsiteIndex])
                                    continue :NEXT;
                            }

                            let expect = host_arg.type;
                            let actual = args[callsiteIndex].type;

                            mut ok = isAssignableAsArgument(expect, actual);

                            /////////////////
                            // Literal fixup.
                            if (!ok && considerRetyping(expect, actual))
                            {
                                ref arg = args[callsiteIndex];
                                if (arg.kind == "label")
                                {
                                    // SEGV fix -
                                    //  how do we deal with this in general?
                                    //   might as well discontinue copy assignment
                                    //    in favor of cpy->mov.
                                    let inner = arg.items.only;
                                    arg = inner;
                                }

                                let retype  = tryRetyping(arg, expect);
                                    ok      = isAssignableAsArgument(expect, retype);

                                if (ok)
                                    arg.type = retype;
                            }
                            //        /LITFIX
                            /////////////////

                            if (!ok)
                            {
                                args = undo_literal_fixup;
                                continue :NEXT;
                            }
                        }

                        // Forbid ambiguity.
                        if (matchIdx)
                            fail("Ambiguous callsite, matches multiple functions in scope: `" ~ id ~ "`.");

                        // Do reorder.
                        if (reorder)
                        {
                            // TODO:
                            // I shouldn't need this pass, just swaps must do.
                            mut new_args: SolvedNode[];
                            new_args.resize(reorder.len);

                            for (mut i = 0; i < reorder.len; i++)
                            {
                                let idx = reorder[i];
                                if (idx >= 0)
                                    new_args[i] = args[idx];
                            }

                            args = new_args;
                        }
                    }

                    // Forbid ambiguity.
                    else if (matchIdx)
                    {
                        fail("Ambiguous callsite, matches multiple items in scope: `" ~ id ~ "`.");
                    }

                    // Done!
                    matchIdx = overloadIdx;

                    // Arity 0 auto-shadows.
                    if (overload.flags & F_SHADOW)
                        break :NEXT;

                    // Done here.
                    break :TEST_AGAIN;
                }
            }

            //////////////////////////////////
            // Conversions / typename aliases.
            if (!alternate_ids)
                break;

            id = alternate_ids.last;
            alternate_ids.pop();
            //////////////////////////////////
        }

        if (matchIdx)
        {
            let matched = GET(matchIdx);

            // Mutate call args last thing.
            let host_args = matched.args;
            if (host_args.len > args.len)
                args.resize(host_args.len);

            // Defaults & implicit argument injection.
            for (mut i = 0; i < args.len; i++)
            {
                if (!args[i])
                {
                    let host_arg = host_args[i];
                    args[i] = host_arg.default || bindImplicitArg(
                        :host_arg.name,
                        :host_arg.type,

                        becauseOf: matchIdx);
                }
            }
        }

        return matchIdx;
    }


    //

    fn considerRetyping(expect: Type, actual: Type): bool
    {
        return expect.quals & actual.quals & q_arithmetic != 0;
    }

    fn couldRetype(node: SolvedNode): bool
    {
        return node.kind == "int"
            || node.kind == "real";
    }

    fn tryRetyping(node: SolvedNode, expect: Type): Type
    {
        return node.kind == "int"  ? solveInt(node.value, expect)
             : node.kind == "real" ? solveNum(node.value, expect)
             : [];
    }


    //

    fn match__mutargs(
        scope: Scope, scope_skip: ScopeSkip,
        id: string, ref args: SolvedNode[],
        flags: i32, target: Target): Target
    {
        let ret = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (ret)
            return ret;

        let debug = tryMatch__mutargs(scope, scope_skip, :id, :args, :flags, :target);
        if (debug)
            return debug;

        return scope.NICERR_mismatch(:id, :args);
    }

    fn NICERR_mismatch(
        scope: Scope,
        id: string, args: SolvedNode[]): never
    {
        // TODO instead of this -
        //  run tryMatch__mutargs again with an error output attached,
        //   this way we don't need the second pass for debugging,
        //    we can #bake alla jblow the if (explain) parts,
        //     and we can rid ourselves of Scope_lookup altogether.

        // We should do everything possible to be helpful here,
        //  do whatever you need, this is compile-fail path.
        let overloads = DEPREC_lookup(scope, id);

        mut min = 0x7fffffff.i32;
        mut max = 0;
        for (mut i = 0; i < overloads.len; i++)
        {
            let o = GET(overloads[i]);
            if (min > o.min) min = o.min;
            if (max < o.max) max = o.max;
        }

        fn expectedArgs(shadow targets: Target[]): string
        {
            mut result = "";

            for (mut i = 0; i < targets.len; i++)
            {
                if (result)
                    result ~= "\n\t\t";
                else if (targets.len > 1)
                    result ~= ", available overloads:\n\t\t";
                else
                    result ~= ", expects: ";

                let overload = GET(targets[i]);

                result ~= overload.name ~ "(";

                for (shadow mut i = 0; i < overload.args.len; i++)
                {
                    let arg = overload.args[i];
                    if (i)
                        result ~= ", ";

                    result ~=  arg.name
                            ~ (arg.flags & F_MUSTNAME ? "!" : "")
                            ~ (arg.default ? "?: " : ": ")
                            ~ (arg.type ? humanizeType(arg.type) : "$");
                }

                result ~= ")";
            }

            return result || ".";
        }

        fn actualArgs(shadow args: SolvedNode[]): string
        {
            mut result = "\nActual: (";

            for (mut i = 0; i < args.len; i++)
            {
                let arg = args[i];
                if (i)
                    result ~= ",";

                result ~= "\n\t";
                if (arg.kind == "label")
                    result ~= arg.value ~ ": ";

                result ~= humanizeType(arg.type);
            }

            return result ~ ").";
        }

        return overloads
                ? args.len < min ? fail("`" ~ id ~ "` expects at least " ~ min ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : args.len > max ? fail("`" ~ id ~ "` expects at most " ~ max ~ " arguments, " ~ args.len ~ " provided" ~ expectedArgs(overloads))
                : fail("`" ~ id ~ "` bad args" ~ expectedArgs(overloads) ~ actualArgs(args))
             : fail("`" ~ id ~ "` is not defined in this scope.");
    }


    //

    fn solveNode(node: Node, type: Type = []): SolvedNode
    {
        let k = node.kind;

        if (k == "root")        return solveRoot(node);
        if (k == "block")       return solveBlock(node, :type);
        if (k == "label")       return solveComma(node);

        if (k == "let")         return solveLet(node, Lifetime_static);
        if (k == "call")        return solveCall(node);
        if (k == "arrlit")      return solveArrayLiteral(node, type);

        if (k == "if")          return solveIf(node, type);
        if (k == "or")          return solveOr(node, type);
        if (k == "!")           return solveNot(node);
        if (k == "and")         return solveAnd(node, type);

        if (k == "return")      return solveReturn(node);
        if (k == "loop")        return solveBlock(node);
        if (k == "break")       return solveJump(node);
        if (k == "continue")    return solveJump(node);

        if (k == "int")         return solveInt(node, type);
        if (k == "real")        return solveNum(node, type);
        if (k == "str")         return solveStr(node);
        if (k == "char")        return solveChar(node);
        if (k == "empty")       return createEmpty();

        if (k == "definit")     return solveDefinit(type);

        if (k == "catch")       return solveCatch(node);
        if (k == "import")      return solveImport(node);
        if (k == "defer")       return solveDefer(node);
        if (k == "try")         return solveTryCatch(node);

        if (k == "typeassert")  return solveTypeAssert(node);
        if (k == "typeparam")   return solveTypeParam(node);
        if (k == "addroffn")    return solveAddrOfFn(node);

        return fail("TODO: " ~ k);
    }

    fn isUnordered(kind: string)
    {
        return kind == "fn"
            || kind == "struct"
            || kind == "typedef";
    }

    fn unorderedPrep(node: Node): SolvedNode
    {
        let k = node.kind;

        if (k == "fn")          return uPrepFn(node);
        if (k == "struct")      return uPrepStruct(node);
        if (k == "typedef")     return solveTypedef(node);

        return fail("TODO: " ~ k);
    }

    fn unorderedSolve(node: Node, prep: SolvedNode)
    {
        let k = node.kind;

        if (k == "fn")          return uSolveFn(node, prep);
        if (k == "struct")      return uSolveStruct(node, prep);
        if (k == "typedef")     return prep || fail();

        return fail("TODO: " ~ k);
    }


    //

    fn solveRoot(node: Node): SolvedNode
    {
        return solved(node, t_void,
            solveNodes(node.items, t_void,
                TEMP_open_templates: true));
    }

    fn solveBlock(node: Node, type?: Type): SolvedNode
    {
        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let expr = !!(node.items.if_last.flags & F_NODISCARD);

        let items = solveNodes(
            node.items,
            type_all:       t_void,
            type_last:      type,
            use_type_last:  expr,
            TEMP_open_templates: true);

        shadow let type = expr && items.len
            ? items.last.type : t_void;

        ////////////////////////////////
        //
        // for (mut i = 0; i < _open_templates.len; i++)
        // {
        //     let o = GET(_open_templates[i].overloadIdx);
        //     if (o.template.locals > scope0)
        //         fail("Exiting the scope of an open template: `" ~ o.name ~ "`.");
        // }
        //
        ////////////////////////////////

        return solved(:node, :type, :items);
    }

    fn solveComma(node: Node): SolvedNode
    {
        let items = solveNodes(node.items);
        let last = items[items.len - 1] || fail();

        return solved(node, last.type || fail(), items);
    }


    //

    fn solveInt(v: string, type: Type): Type
    {
        shadow let parse = intlit::Intlit(v);
        parse.error && fail(parse.error);

        if (type)
        {
            fn want(t: Type)
                type.canon == t.canon;

            if (!parse.unsigned)
            {
                if (want(t_f32) && parse.minsize_f <= 32) return t_f32;
                if (want(t_f64) && parse.minsize_f <= 64) return t_f64;

                if (want(t_i32) && parse.minsize_i <= 32) return t_i32;
                if (want(t_i64) && parse.minsize_i <= 64) return t_i64;
                if (want(t_i16) && parse.minsize_i <= 16) return t_i16;
                if (want(t_i8 ) && parse.minsize_i <= 8 ) return t_i8 ;
            }

            if (!parse.signed)
            {
                if (want(t_u32) && parse.minsize_u <= 32) return t_u32;
                if (want(t_u64) && parse.minsize_u <= 64) return t_u64;
                if (want(t_u16) && parse.minsize_u <= 16) return t_u16;
                if (want(t_u8 ) && parse.minsize_u <= 8 ) return t_u8 ;
            }
        }

        if (parse.unsigned)
        {
            if (parse.minsize_u <= 32) return t_u32;
            if (parse.minsize_u <= 64) return t_u64;
        }
        else
        {
            if (parse.minsize_i <= 32) return t_i32;
            if (parse.minsize_i <= 64) return t_i64;
        }

        return fail("Bad int literal.");
    }

    fn solveNum(v: string, type: Type): Type
    {
        // TODO `f` suffix
        if (v) {}

        if (type.canon == t_f32.canon) return t_f32;

        return t_f64;
    }


    //

    fn solveInt(node: Node, type: Type): SolvedNode
        solved(node,
             solveInt(node.value, type));

    fn solveNum(node: Node, type: Type): SolvedNode
        solved(node,
             solveNum(node.value, type));


    //

    fn solveChar(node: Node): SolvedNode
    {
        return solved(node, t_byte);
    }

    fn solveStr(node: Node): SolvedNode
    {
        if (!node.value)
            return createDefinit(
                add_ref(t_string, Lifetime_static));

        return solved(node, t_string);
    }

    fn createEmpty(kind = "empty", type = t_void, target?: Target): SolvedNode
    {
        return SolvedNode(
            :kind, :type, :target,
            token: _here || fail());
    }


    //

    fn createTypeParam(value: string): Node
    {
        return Node(kind: "typeparam",
            :value, token: _here || fail());
    }


    //

    fn uPrepFn(node: Node): SolvedNode
    {
        return __solveFn(node, solve: false);
    }

    fn uSolveFn(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveFn(node, :prep, solve: true);
    }

    fn __solveFn(n_fn: Node, solve!: bool, prep?!: SolvedNode, spec?!: bool, caseIdx! = -1, into?: Target): SolvedNode
    {
        // Template early exit.
        if (spec)
        {
            // Now we try to prep these too.
            // solve || fail();
        }
        else if (n_fn.flags & F_TEMPLATE)
        {
            if (solve)
                return prep || fail();

            let tDecl = TemplateDecl(n_fn);
            return createEmpty(
                type: addroffn::X_addrofTarget(tDecl));
        }

        // Prep reject.
        let inItems = n_fn.items;
        if (!solve && !inItems[inItems.len + FN_RET_BACK])
            return SolvedNode();

        mut out = CurrentFn(
            prep || solved(n_fn, t_void),
            return_idx: ScopeMemo(),
            parent_idx: _current_fn.target.index);

        out.items.resize(inItems.len);

        if (!prep)
        {
            out.target = into || Scope_create(_scope);
            out.type = addroffn::X_addrofTarget(out.target);
        }

        //
        if (_current_fn)
        {
            // Propagate "inlined"-ness to non-templates within templates,
            //  see the `traverse` testcase.
            if (_current_fn.flags & F_TEMPLATE)
                out.flags |= F_TEMPLATE;
        }

        //////////////////////////
        mut native = false;
        mut n_body: Node;

        {
            let scope0      = Scope_snap(_scope);
            out.return_idx  = scope0;

            let root_scope0 = _root_scope;
            if (!root_scope0)
                _root_scope = out.return_idx;

            SWAP(_current_fn, out);

            defer {
                SWAP(_current_fn, out);
                Scope_pop(_scope, scope0);
                _root_scope = root_scope0;
            }

            /////////////////////////////////
            ref outItems = _current_fn.items;

            // Arg decls.
            for (mut i = 0; i < inItems.len + FN_ARGS_BACK; i++)
            {
                let n_arg = inItems[i] || fail();
                n_arg.kind == "let" || fail();

                let lifetime = Lifetime_fromArgIndex(i);

                // If spec and unless argument explicitly wants a value -
                if (spec && !(n_arg.flags & F_MUT)
                         && !(n_arg.items[LET_INIT]))
                {
                    // Specialize with actuals.
                    mut mut_arg = n_arg;
                    mut_arg.items[LET_TYPE] = createTypeParam(mut_arg.value);

                    // Emit value-taking specializations.
                    let type = evalTypeParam(mut_arg.value);
                    if !(type.quals & q_ref)
                        mut_arg.flags |= F_MUT;

                    outItems[i] = solveLet(mut_arg, :lifetime);
                }
                else
                {
                    outItems[i] = solveLet(n_arg, :lifetime);
                }
            }

            /////////////////////////////////////////////////////
            mut n_ret   = inItems[inItems.len + FN_RET_BACK];
                n_body  = inItems[inItems.len + FN_BODY_BACK] || fail();

            // Pattern descent.
            if (caseIdx >= 0)
            {
                n_body.kind == "pattern" || fail();
                let branch = n_body.items[caseIdx] || fail();
                let items = branch.items;

                n_ret   = items[items.len + FN_RET_BACK]  || n_ret;
                n_body  = items[items.len + FN_BODY_BACK];
            }

            // Builtin?
            if (n_body.kind == "call" && n_body.value == "__native")
                native = true;

            // Return type annot.
            {
                let s_ret = n_ret
                    ? evalTypeAnnot(n_ret)
                    : SolvedNode();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_RET_BACK] = s_ret;
            }

            // Only if actually solving the fn, the fn body.
            if (solve && !native)
            {
                let s_body = solveNode(n_body);
                s_body || fail();

                // MUT DURING SOLVE,
                //  implicit args splice in
                outItems[outItems.len + FN_BODY_BACK] = s_body || fail();
            }
        }
        //////////////////////////

        if (!prep)
        {
            // TODO FIX currently we only hash template names.
            mut name = n_fn.value || fail("TODO anonymous fns");
            if (spec && !native)
            {
                let sig = mangleArguments(out.items[0, out.items.len + FN_BODY_BACK]) || fail();
                let hash = tea::hash62(sig, chars: 4);
                name ~= "_" ~ hash;
            }

            //
            let kind = native ? "__native" : "fn";
            let NO_IMPORTS: i32[];
            let NO_LOCALS: ScopeMemo;
            let template = Template(node: native ? n_body : n_fn, imports: NO_IMPORTS, locals: NO_LOCALS);

            FnDecl_init(out.target, :kind, id: name, :template);
        }

        FnDecl_update(out.out, out.locals_used, out.parent_idx);

        if (solve)
            return createFnDef(out.out);

        return out.out;
    }

    fn createFnDef(fn: SolvedNode): SolvedNode
    {
        return SolvedNode(
            kind:   "fndef",
            type:   fn.type,
            target: fn.target,
            token:  fn.token);
    }


    //

    fn mangleArguments(args: [SolvedNode]): string
    {
        mut mangle = "";
        for (mut i = 0; i < args.len; i++)
        {
            if (i)
                mangle ~= ",";

            mangle ~= serializeType((args[i] || fail()).type);
        }

        return mangle;
    }


    //

    fn trySpecialize(
        overloadIdx: Target, args: SolvedNode[],
        args_mangled: string)
            : Target
    {
        // TODO memoize the whole mangle.
        mut mangle = overloadIdx.modid ~ "#" ~ overloadIdx.index ~ " ";
            mangle ~= args_mangled;

        // TODO FIX THIS MESS -
        //  A. Not recursion capable: use the general prep-vs-solve approach here too.
        //  B. The multiple map taps here are because stuff
        //      moves around while doTrySpecialize does its work -
        //      if maps values didn"t move around we"d be good.
        mut spec = module.out.specs[mangle];

        let SPEC_FAILED = -1;
        if (!spec)
        {
            let SPEC_FAIL = Target(modid: SPEC_FAILED, index: 0);

            ////////////////////////////////////
            let m0 = mangle;
            module.out.specs[m0] = SPEC_FAIL;
            ////////////////////////////////////

            spec = doTrySpecialize(:overloadIdx, :args, :mangle) || SPEC_FAIL;

            ////////////////////////////////////
            module.out.specs[mangle] = spec;
            if (m0 != mangle)
                module.out.specs[m0] = spec;
            ////////////////////////////////////

            // The resolver entry.
            if (spec.modid != SPEC_FAILED)
                _open_templates.push(
                    OpenTemplate(
                        :overloadIdx, :spec, :args, :mangle));
        }

        return spec.modid != SPEC_FAILED && spec;
    }


    // Let's try to run all specs through here for starters.

    fn doTrySpecialize(
        overloadIdx: Target, mut args: SolvedNode[], ref mangle: string, into?: Target)
            : Target
    {
        mut ok = true;
        mut typeParams0: Map(string, Type);

        ////////////////////////////////
        mut current_fn0: CurrentFn;

        SWAP(_current_fn, current_fn0);

        let scope0 = Scope_snap(_scope);
        let scope_skip0 = _scope_skip;
        ////////////////////////////////

        //
        mut typeParams: Map(string, Type);

        //
        let template = GET(overloadIdx).template;

        _scope_skip = _root_scope && ScopeSkip(
            start: template.locals || _root_scope,
              end: scope0);

        _scope_skip.end.items_len >= _scope_skip.start.items_len || fail(
            "doTrySpecialize: will scope_skip backwards.");

        for (mut i = 0; i < template.imports.len; i++)
            Scope_import(template.imports[i]);

        //
        let kind    = template.node.kind;
        let items   = template.node.items;
        let numArgs = kind == "fn" ? items.len + FN_ARGS_BACK
                    : fail("TODO numArgs for template:" ~ kind);

        /////////////////
        // Literal fixup.
        mut retypeIndices: i32[];
        mut remangle = false;

        // First off, solve type params.
        for (   mut pass_retype  = 0;
                    pass_retype == 0 || pass_retype == 1 && retypeIndices;
                    pass_retype++)
        {
        //        /LITFIX
        /////////////////

            for (mut i = 0; i < numArgs; i++)
            {
                if (pass_retype)
                {
                    // TODO fix, .try_shift instead.
                    if (!retypeIndices.has(i))
                        continue;
                }

                let inValue = args.len > i && args[i];
                mut inType  = inValue.type;

                let argNode = items[i] || fail();
                let annot   = argNode.items[LET_TYPE];

                /////////////////
                // Literal fixup.
                if (couldRetype(inValue))
                {
                    let paramType =
                        annot.kind == "typeparam"
                            ? typeParams[annot.value] ||= Type
                            : annot.kind == "call" && !annot.items
                                && Scope_lookupType(annot);

                    // Ignore literals if possible.
                    if (paramType)
                    {
                        let retype = tryRetyping(inValue, paramType);
                        if (retype && retype.canon != inType.canon)
                        {
                            inType   = args[i].type = retype;
                            remangle = true;
                        }
                    }

                    // Defer for second pass.
                    else if (!pass_retype)
                    {
                        retypeIndices.push(i);
                        continue;
                    }
                }
                //        /LITFIX
                /////////////////

                argNode.kind == "let"  || fail();

                if (inType)
                {
                    // All fnargs are referable.
                    inType.lifetime = Lifetime_fromArgIndex(i);

                    //
                    let argName = argNode.value || fail();

                    // Same pattern - grabs a mutref.
                    ref argName_typeParam =
                        typeParams[argName] ||= Type;

                    argName_typeParam && fail(
                        "Type param name collision with argument: `" ~ argName ~ "`.")
                            = inType;

                    //
                    inType.quals |= q_ref;

                    // Type check.
                    if (annot)
                    {
                        let argOk = inType && trySolveTypeParams(
                            annot, inType, typeParams);

                        ok = ok && argOk;
                        if (!ok && !remangle)
                            break;
                    }
                }
            }
        }

        /////////////////
        // Literal fixup.
        if (remangle)
        {
            let start   = mangle.find(' ') + 1 || fail();
                mangle  = mangle.slice(0, start) ~ mangleArguments(args);
        }
        //        /LITFIX
        /////////////////

        // Match pattern arm here.
        mut caseIdx = -1;

        if (ok)
        {
            // Unpack type params in scope.
            {
                mut keys = typeParams.keys;
                for (mut i = 0; i < keys.len; i++)
                {
                    let key = keys[i];
                    Scope_Typedef(_scope, "$" ~ key, typeParams[key], flags: 0);
                }
            }

            //
            let pattern = items[items.len + FN_BODY_BACK] || fail();
            if (pattern.kind == "pattern")
            {
                let branches = pattern.items;
                for (mut i = 0; i < branches.len; i++)
                {
                    let cond = branches[i].items[0] || fail();
                    if (evalTypePattern(cond))
                    {
                        caseIdx = i;
                        break;
                    }
                }

                // All branches mismatch?
                //  Can't return, faking RAII here.
                if (caseIdx < 0)
                    ok = false;
            }
        }

        kind == "fn" || fail("__solveFn spec:true is not expected to fail.");

        let prep = ok && !into && __solveFn(
            template.node, solve: false, spec: true, :caseIdx,
            :into);

        ///////////////////////////////////////////
        // Re-enable recursion.
        if (prep.target)
            module.out.specs[mangle] = prep.target;
        ///////////////////////////////////////////

        let specialized = ok && __solveFn(
            template.node, :prep, solve: true, spec: true, :caseIdx,
            :into);

        ////////////////////////////////
        SWAP(_current_fn, current_fn0);

        Scope_pop(_scope, scope0);
        _scope_skip = scope_skip0;
        ////////////////////////////////

        return specialized.target;
    }


    //

    fn solveTypeCtor(node: Node): SolvedNode
    {
        let tDecl   = TemplateDecl(node);
        mut out     = solved(node, t_void);
        out.target  = tDecl;
        return out;
    }

    fn uPrepStruct(node: Node): SolvedNode
    {
        return __solveStruct(solve: false, :node);
    }

    fn uSolveStruct(node: Node, prep: SolvedNode): SolvedNode
    {
        return __solveStruct(solve: true, :node, :prep);
    }

    fn __solveStruct(solve!: bool, node: Node, prep?!: SolvedNode): SolvedNode
    {
        mut out = prep || solved(node, t_void);
        mut structType: Type;

        mut id = node.value;
        let origId = id;
        if (!origId)
            id = _current_fn.value || "Anon";

        // Add the arity-0 type entry.
        if (!(_current_fn.flags & F_TEMPLATE))
        {
            structType = initStruct(id, node.flags);
            if (!prep && origId)
                out.target = Scope_Typedef(_scope, origId, structType, node.flags);
        }

        if (!solve)
            return out;

        // Struct fields only.
        let members = node.items;
        mut innerScope: ScopeItem[];
        let items = solveStructMembers(:id, :node.flags, :structType, :members, :innerScope);
        out.items = items;

        if (!out.target && origId)
            out.target = Scope_Typedef(_scope, origId, structType, node.flags);

        // Add a default constructor.
        {
            shadow mut members: SolvedNode[];
            mut fields: StructField[];

            shadow let items = out.items;
            for (mut i = 0; i < items.len; i++)
            {
                let item = items[i];
                if (item && item.kind == "let" && (item.flags & F_FIELD))
                {
                    members.push(item);

                    fields.push(
                        StructField(
                            id:   item.value        || fail(),
                            type: item.type.vtype   || fail()));
                }
            }

            //
            structType.quals |= finalizeStruct(structType.canon, fields, innerScope);
            if (out.target)
                GET_mut(out.target).type.quals = structType.quals;

            // Link up the constructor.
            // TODO don't Scope_add when templated.
            let ctor = DefCtor(id, structType, members);
            lookupStruct_mut(structType.canon).ctor = ctor;
        }

        // So we can type x = struct { what };
        out.type = structType;

        return out;
    }

    fn solveStructMembers(
        ref id: string, flags: i32,
        members: Node[], ref structType: Type, ref innerScope: ScopeItem[]): SolvedNode[]
    {
        mut out: SolvedNode[];

        // Pass 0.
        for (mut i = 0; i < members.len; i++)
        {
            let node = members[i];
            if (node.kind == "let")
                out.push(solveField(:node));
            else
                fail("solveStructMembers_1: " ~ node.kind);
        }

        if (!structType)
        {
            let sig     = mangleArguments(out);
            let hash    = tea::hash62(sig, chars: 4);
            id         ~= "_" ~ hash;

            structType  = initStruct(:id, :flags);
        }

        // Pass 1.
        for (mut i = 0; i < out.len; i++)
        {
            let node = out[i];
            if (node.kind == "let")
                solveField(:node, :structType, :innerScope);
            else
                fail("solveStructMembers_2: " ~ node.kind);
        }

        return out;
    }

    fn solveField(node: Node): SolvedNode
    {
        node.items[LET_INIT] &&
        node.items[LET_INIT].kind != "definit" &&
            fail("All structs must be zerofilled by default."
                ~ " Please remove the initializer of struct member `" ~ node.value ~ "`.");

        return solveBinding(node, Lifetime_fromArgIndex(0));
    }

    fn solveField(structType: Type, node: SolvedNode, ref innerScope: ScopeItem[])
    {
        let id = node.value;
        let target = Field(:id, :structType, fieldType: node.type);

        innerScope.push(ScopeItem(:id, :target));

        if (node.flags & F_USING)
            scope_using(target);
    }


    //

    fn solveReturn(node: Node): SolvedNode
    {
        // Solving the stuff below might inject implicit args -
        //  which would shift the retidx back.
        fn retIdx()
            _current_fn.items.len + FN_RET_BACK;

        let prevType = _current_fn.items[retIdx].type;

        node.items.len <= 1 || fail();
        mut out = solved(node, t_void,
            solveNodes(node.items, prevType));

        ref next =
            out.items   ? out.items[0]
                        : out;

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if (next.type.lifetime.killedBy(_current_fn.return_idx.items_len) &&
            next.type.quals & q_ref)                        //
        {                                                   //
            let nrvo = next.kind == "call"                  //
                    && next.items.len == 0                  //
                    && next.target.GET.kind == "var";       //
                                                            //
            next = createMove(next, nrvo);                  //
        }                                                   //
        //////////////////////////////////////////////////////

        if (prevType)
            checkAssignable(host: prevType, next.type,
                "Non-assignable return types");
        else
            _current_fn.items[retIdx] = next || fail();

        if (out.items)
            maybeCopyOrMove(out.items[0],
                prevType || next.type);

        return out;
    }

    fn checkAssignable(
        host: Type, guest: Type, err: string,
        id?: string, sep?: string)
    {
        isAssignable(
            :host   || fail("Bad host type."),
            :guest  || fail("Bad guest type."))
                    || fail(err ~ (id && " `" ~ id ~ "`") ~ ": "
                                ~ host .humanizeType() ~ (sep || " <- ")
                                ~ guest.humanizeType());
    }

    fn solveJump(node: Node): SolvedNode
    {
        return solved(node, t_void);
    }


    //

    fn solveBinding(node: Node, lifetime: Lifetime): SolvedNode
    {
        let n_annot     = node.items[LET_TYPE];
        let n_init      = node.items[LET_INIT];

        mut annot       = n_annot && evalTypeAnnot(n_annot);
        if (annot.type && node.flags & F_REF)
            annot.type = add_mutref(annot.type, lifetime);

        mut init        = n_init && solveNode(n_init, annot.type);

        annot.type || init.type || fail(
            "Variable declarations without type annotations must be initialized.");

        let t_let       = annot.type
                            ? node.flags & F_ARG && !(node.flags & F_MUT)
                                ? add_ref(annot.type, lifetime)
                                : annot.type
                        : init.type.quals & q_mutref || node.flags & F_MUT
                            ? node.flags & F_REF
                                ? init.type
                                : clear_refs(init.type)
                            : node.flags & F_ARG && !(node.flags & F_MUT)
                                ? add_ref(init.type, lifetime)
                                : init.type;

        if (annot.type && init.type)
            checkAssignable(host: annot.type, init.type,
                "Type annotation does not match init expression",
                    node.value, "=");

        if (node.flags & F_REF)
            init.type.quals & q_mutref || !init && node.flags & F_ARG || fail(
                "`ref` variables must be initialized to a mutable reference.");

        if (init)
            maybeCopyOrMove(init, t_let);

        //
        mut out = solved(node, t_let, [annot || init, init]);

        if !(_current_fn || node.flags & F_FIELD)
        {
            if (out.flags & F_MUT || out.type.quals & q_mutref)
                fail("Mutable statics are not currently allowed.");

            out.kind = "global";
        }

        return out;
    }

    fn solveTypedef(node: Node): SolvedNode
    {
        let annot = evalTypeAnnot(node.items.only);
        Scope_Typedef(_scope, node.value, annot.type, node.flags);
        return createEmpty();
    }

    fn solveLet(node: Node, mut lifetime: Lifetime): SolvedNode
    {
        mut out         = solveBinding(node, lifetime);
        let global      = out.kind == "global";

        //////////////////////////////////////////////////////
        //                                                  //
        // TODO LIFETIMES   this doesn't work               //
        //                  for deeply referential types.   //
                                                            //
        if !(out.type.quals & q_ref)                        //
            lifetime = Lifetime_next();                     //
                                                            //
        //////////////////////////////////////////////////////

        let kind = global                   ? "global"
                 : node.flags & F_ARG       ? "arg"
                 : out.type.quals & q_ref   ? "ref"
                                            : "var";

        let id = out.value;

        //
        if (!addroffn::X_unpackAddrOfFnBinding(_scope.items, id, out.type))
        {
            let overload = out.target = Binding(
                :id, :kind, :node.flags,

                node.flags & F_MUT
                    ? add_mutref(out.type, lifetime)
                    : add_ref(out.type, lifetime));

            if (_root_scope)
            {
                mut any = 0;
                mut same = 0;
                /*
                for (mut i = 0; i < _scope.items.len - 1; i++)
                {
                    if (i == _scope_skip.start.items_len)
                        i  = _scope_skip.end  .items_len;
                /*/
                let start = _scope_skip.end.items_len || _root_scope.items_len;
                for (mut i = start; i < _scope.items.len - 1; i++)
                {
                // */
                    if (_scope.items[i].id == id)
                    {
                        any++;
                        let o = GET(_scope.items[i].target);
                        if (o.kind == "arg" || o.kind == "ref" || o.kind == "var")
                            same++;
                    }
                }

                if (same)
                    GET_mut(overload).name ~= "_" ~ same;

                // LEAKY TEMPLATES, part 1:
                //  All locals are F_SHADOW - this is a usability thing really,
                //   otherwise you'd simply have to `shadow` everything manually.
                //
                // Actually turning this on for everything -
                //  it might optimize scope lookups all over the place.
                //
                if (!global && !any) // && _current_fn.flags & F_INLINE
                    out.flags |= F_SHADOW;
            }

            if (global)
                GET_mut(overload).solved = out;

            if (out.flags & F_USING)
                scope_using(overload);
        }

        return out;
    }

    fn solveCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        let var_ok = solveNode(node.items[0]);

        ////////////////////////////////
        let scope0 = Scope_snap(_scope);
        defer Scope_pop(_scope, scope0);
        ////////////////////////////////

        let var_err = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        var_err.kind == "let" && isAssignableAsArgument(
            var_err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, var_ok.type,
            [ var_ok, var_err, catch ]);
    }

    fn solveTryCatch(node: Node): SolvedNode
    {
        node.items.len == 3 || fail();

        /////////////////////////////////
        let scope0  = Scope_snap(_scope);
        /////////////////////////////////

        let try     = solveNode(node.items[0]);

        ///////////////////////////////////////
        Scope_pop(_scope, scope0);
        shadow let scope0 = Scope_snap(_scope);
        ///////////////////////////////////////

        let err     = solveNode(node.items[1]);
        let catch   = solveNode(node.items[2]);

        //////////////////////////
        Scope_pop(_scope, scope0);
        //////////////////////////

        err.kind == "let" && isAssignableAsArgument(
            host: err.type, t_string) || fail(
                "catch: exceptions are strings,"
                    ~ " consider dropping the annotation.");

        return solved(node, t_void, [ try, err, catch ]);
    }

    fn findModule(fuzimport: string): &Module
    {
        let fname = resolveFile_x(fuzimport);

        let modules = ctx.modules;
        for (mut i = 1; i < modules.len; i++)
        {
            let m = modules[i];
            if (m.fname == fname)
                return m;
        }

        fail("Cannot locate: " ~ fname);
    }

    fn solveImport(node: Node): SolvedNode
    {
        let m = findModule(fuzimport: node.value);
        Scope_import(m.modid);

        //
        return createEmpty();
    }

    fn solveDefer(node: Node): SolvedNode
    {
        let item = solveNode(node.items.only);
        return solved(node, t_void, [ item ]);
    }


    //

    fn Scope_lookupType(mut id: string, flags: i32 = 0): Type
    {
        mut scope_iterator: i32;
        mut overloadIdx: Target;

        let qualified = flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        while (overloadIdx =
            scope.search(id, scope_iterator,
                scope_skip: !qualified && _scope_skip))
        {
            let maybe = GET(overloadIdx);
            if (maybe.kind == "type")
                return maybe.type || fail();
        }

        return fail("No type `" ~ id ~ "` in scope.");
    }

    fn Scope_lookupType(annot: Node): Type
    {
        return Scope_lookupType(annot.value, :annot.flags);
    }


    //

    fn evalTypeParam(id: string): Type
    {
        return Scope_lookupType(
            "$" ~ (id   || fail("Falsy type param id.")))
                        || fail("No type param `$" ~ id ~ "` in scope.");
    }

    fn solveTypeParam(node: Node): SolvedNode
    {
        return solved(node, evalTypeParam(node.value));
    }

    fn solveAddrOfFn(node: Node): SolvedNode
    {
        let id = node.value;
        let type = addroffn::X_solveAddrOfFn(_scope, :id, _scope_skip);
        return createEmpty(:type);
    }


    //

    fn evalTypeAnnot(node: Node): SolvedNode
    {
        fn T(i: i32 = 0) evalTypeAnnot(node.items[i]).type;

        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len == 1)
            {
                if (node.value == "&")
                    return solved(node, add_ref(T, Lifetime_static));

                if (node.value == "&mut")
                    return solved(node, add_mutref(T, Lifetime_static));

                if (node.value == "[]")
                    return solved(node, createArray(T));
            }
            else if (items.len == 2)
            {
                if (node.value == "Map")
                    return solved(node, createMap(T(0), T(1)));
            }

            return solveCall(node);
        }
        else if (node.kind == "typeparam")
        {
            return solved(node, evalTypeParam(node.value));
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            return solved(node, createSlice(T));
        }

        return fail("TODO evalTypeAnnot");
    }

    fn trySolveTypeParams(
        node: Node, mut type: Type, ref typeParams: Map(string, Type)): bool
    {
        if (node.kind == "call")
        {
            let items = node.items;
            if (items.len)
            {
                if (items.len == 1)
                {
                    mut t   = node.value == "&"    ? tryClear_ref(type)
                            : node.value == "&mut" ? tryClear_mutref(type)
                            : node.value == "[]"   ? tryClear_array(type)
                            : fail("TODO trySolveTypeParams unary call");

                    if (!t)
                        return false;

                    // HACK TODO FIX!
                    //  keep the ref around for clear-slice to work.
                    if (node.value == "&mut" && items[0].kind == "arrlit" && items[0].items.len == 1)
                        t.quals |= q_ref;

                    return trySolveTypeParams(
                        items[0] || fail(), t, typeParams);
                }
                else if (items.len == 2)
                {
                    if (node.value == "Map")
                    {
                        let kv = tryClear_map(type);
                        if (!kv)
                            return false;

                        return trySolveTypeParams(items[0] || fail(), kv.key  , typeParams)
                            && trySolveTypeParams(items[1] || fail(), kv.value, typeParams);
                    }
                }
            }
            else
            {
                return isAssignable(
                    Scope_lookupType(node),
                        type);
            }
        }
        else if (node.kind == "typeparam")
        {
            let id = node.value || fail();

            // What is happening here?
            // This is crazy, no?
            ref _param = (typeParams[id] ||= Type);
            if (_param)
            {
                let inter = type_tryInter(_param, type);
                if (!inter)
                    return false;

                type = inter;
            }

            // TODO not here:
            //  we want to clear everything non-canonical from
            //   type params AFTER we solve & match the args,
            //    during the matching it shouldn't be necessary.
            //
            // After the match we need this to e.g. lift `non_zero`
            //  from integral results, etc.
            //
            _param = clear_refs(type);

            return true;
        }
        else if (node.kind == "arrlit" && node.items.len == 1)
        {
            // Slice.
            let t = tryClear_slice(type);
            return t && trySolveTypeParams(
                node.items[0] || fail(), t, typeParams);
        }

        return fail("TODO trySolveTypeParams fallthrough");
    }

    fn evalTypePattern(node: Node): bool
    {
        if (node.kind == "and")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (!evalTypePattern(node.items[i]))
                    return false;

            return true;
        }
        else if (node.kind == "or")
        {
            for (mut i = 0; i < node.items.len; i++)
                if (evalTypePattern(node.items[i]))
                    return true;

            return false;
        }
        else if (node.kind == "typeassert")
        {
            let left  = node.items[0] || fail();
            let right = node.items[1] || fail();

            // We'll have to figure out the type tag nonsense at some point.
            //  Perhaps when we have an `any` type,
            //   we could subtype it with the desired quals.
            if (left.kind  == "typeparam" && right.kind == "typetag")
                return type_has(
                    evalTypeParam(left.value),
                    right.value || fail("Falsy type tag."));
            else
                return isAssignable(
                    host: evalTypeAnnot(right).type,
                          evalTypeAnnot(left ).type);
        }

        return fail("TODO evalTypePattern fallthrough: "
                    ~ node.kind ~ "(" ~ node.items.len ~ ")");
    }


    //

    fn createRead(id: string): Node
    {
        return Node(
            kind:   "call",
            value:  id,
            token:  (_here || fail()));
    }

    fn dequalify_andGetScope(ref id: string): &Scope
    {
        let split = id.find('\t');
            split >= 0 || fail();

        let fname = id.slice(0, split);
            id    = id.slice(split + 1);

        let other = findModule(fuzimport: fname);
        if (other.modid != module.modid)
            return other.out.solve.scope;

        return _scope;
    }

    fn solveCall(node: Node, target?!: Target): SolvedNode
    {
        mut id = node.value;
        if (!id) target || fail();

        // Qualified?
        let qualified = node.flags & F_QUALIFIED;
        let scope = qualified
            ? dequalify_andGetScope(id)
            : _scope;

        mut args = solveNodes(node.items);

        //
        mut callTargIdx = match__mutargs(
            scope, !qualified && _scope_skip,
            id, args, node.flags, :target);

        mut callTarg = GET(callTargIdx);

        // `using` codegen.
        while (callTarg.partial)
        {
            let unshift     = callTarg.kind == "p-unshift";

            let partial     = callTarg.partial  || fail();
            let viaIdx      = partial.via       || fail();
            callTargIdx     = partial.target    || fail();

            let via         = GET(viaIdx);
            callTarg        = GET(callTargIdx);

            // There's two things we can do here -
            //  -   either we're injecting an implicitly used local,
            //          e.g. the this pointer, or another `using` variable,
            //  -   or we're wrapping the head argument
            //          with another derefence or method call or whatever.

            // And that's all there is to `using`.
            mut innerArgs: SolvedNode[];
            if (!unshift)
                innerArgs = [ args[0] || fail() ];

            let argNode     = CallerNode(
                createRead("__partial"),
                via.type || fail(),
                viaIdx,
                innerArgs);

            //
            if (unshift)
                args.unshift(argNode);
            else
                args[0] = argNode;
        }

        //
        return CallerNode(
            node,
            callTarg.type || fail(),
            callTargIdx,
            args);
    }


    // I feel this should be a fncall instead of this here.
    //  It's varargs - so is it a template or what?

    fn solveArrayLiteral(node: Node, type: Type): SolvedNode
    {
        mut itemType = type && tryClear_array(type);

        // Default constructor calls.
        if (!itemType && type.isStruct)
            return solveCall(node,
                target: lookupStruct(type).ctor);

        // Nope, it's an array literal.
        let items   = solveNodes(node.items, itemType);
        mut startAt = 0;

        if (!itemType && items.len)
        {
            let head = items[startAt++] || fail();
            itemType = clear_refs(head.type);
        }

        if (!itemType)
            return fail("Cannot infer empty arraylit.");

        for (mut i = startAt; i < items.len; i++)
        {
            itemType = type_tryInter(
                itemType, (items[i] || fail()).type);

            itemType || fail(
                "[array literal] No common supertype.");
        }

        return solved(node, createArray(itemType), items);
    }


    //

    fn createLet(target: Target, flags: i32 = 0): SolvedNode
    {
        let overload = GET(target);

        return SolvedNode(
            kind: "let", :flags, token: _here || fail(),
            value: overload.name, :overload.type, :target);
    }

    fn injectImplicitArg(id: string, type: Type, becauseOf!: Target): Target
    {
        ref fnNode = _current_fn.out || fail(
            "No implicit `" ~ id ~ "` in scope, needed to call `" ~ GET(becauseOf).name ~ "`.");

        ///////////////////////////////////////////
        // TODO obtain or persist this in the original scope.
        let scope0  = Scope_snap(_scope);
        let ret     = Binding(id, type, flags: F_IMPLICIT);
        Scope_pop(_scope, scope0);
        ///////////////////////////////////////////

        // Reuse existing or add new argnode.
        {
            let n = fnNode.items.len;
            for (mut i = 0; i < n; i++)
            {
                ref arg = fnNode.items[i];
                if (arg.value == id)
                {
                    checkAssignable(host: type, arg.type,
                        "Implicit arg collision", id);

                    return ret;
                }
            }

            let newArgIdx   = fnNode.items.len + FN_RET_BACK;
            let newArgNode  = createLet(ret, F_IMPLICIT);

            fnNode.items.insert(newArgIdx, newArgNode);
        }

        return ret;
    }

    fn bindImplicitArg(name: string, type: Type, becauseOf!: Target): SolvedNode
    {
        let id = name;
        mut args: SolvedNode[];

        let target = tryMatch__mutargs(_scope, _scope_skip, :id, :args, retType: type)
            || injectImplicitArg(:id, :type, :becauseOf)
            || fail();

        GET(target).flags & F_IMPLICIT || fail(
            "Matching a non-implicit item in scope: `" ~ name ~ "`, binds to call to `" ~ GET(becauseOf).name ~ "`.");

        return CallerNode(
            createRead("__implicit"), :type, :target);
    }


    //

    fn solveIf(node: Node, mut type: Type): SolvedNode
    {
        let n0      = node.items[0];
        let n1      = node.items[1];
        let n2      = node.items[2];

        let cond    = solveNode(n0, t_bool);
        mut cons    = n1 && solveNode(n1, type);
        mut alt     = n2 && solveNode(n2, cons.type || type);

        let priExpr = cons || alt || fail();
        let secExpr = cons && alt || cons;

        let priType = priExpr.type;
        let secType = secExpr.type;

        if (!type.is_void && !type.is_bool)
        {
            type = !secType ? priType
                            : type_tryInter(priType, secType);

            type || fail("[if] No common supertype: `" ~ serializeType(priType) ~ " : " ~ serializeType(secType) ~ "`.");

            if (cons)
                maybeCopyOrMove(cons, type);
            if (alt)
                maybeCopyOrMove(alt, type);
        }

        return solved(node, type || fail(), [ cond, cons, alt ]);
    }


    //////////////////////////////////////////////////
    // Logic                  .                     //
    //////////////////////////////////////////////////

    fn solveNot(node: Node): SolvedNode
    {
        return solved(
            node, t_bool,
                [ solveNode(node.items[0], t_bool) ]);
    }

    fn solveOr(node: Node, mut type: Type): SolvedNode
    {
        mut items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;
            mut hasNever = false;

            // Sum types, ignoring never.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                {
                    hasNever = true;
                    continue;
                }

                // a && b || never: b can be mutref!
                let andLast = hasNever && item.kind == "and" && item.items && item.items[item.items.len - 1];
                let itemType = andLast && !andLast.type.is_never
                    ? andLast.type
                    : item.type;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, itemType);
                    if (!sumType)
                        break;
                }
                else
                {
                    sumType = itemType;
                }
            }

            if (sumType)
            {
                // If we do have an intersection,
                //  and if the sum type is not a reference,
                //   some shit may need copying here.
                for (mut i = 0; i < items.len; i++)
                    maybeCopyOrMove(
                        items[i], sumType);

                type = sumType;
            }
            else
            {
                type = t_bool;
            }
        }

        return solved(node, type, items);
    }

    fn solveAnd(node: Node, mut type: Type): SolvedNode
    {
        let items = solveNodes(node.items, type);

        // Statement mode.
        if (type.is_void)
            type = t_bool;

        // Unless this is an explicit bool context:
        if (!type.is_bool)
        {
            mut sumType: Type;

            // Last item type wins -
            //  unless it's never, which we can safely ignore.
            for (mut i = items.len; i --> 0; )
            {
                let item = items[i];
                if (item.type.is_never)
                    continue;

                if (sumType)
                {
                    sumType = type_tryInter(sumType, item.type);
                    if (!sumType)
                        break;
                }
                else
                {
                    type    = item.type;
                    sumType = item.type;
                }
            }

            if (sumType)
            {
                // All the types sum up -
                //  so this is an ok way to get a mutref:
                //   e.g. `mut &x = mut_expectFalsy && throw("someone already set this");`
                type = sumType;
            }
            else
            {
                // Nope, that didn't work.
                //  We can generate falsy values and refs,
                //   but not mutrefs - can't allocate
                //    a static mut and expect it to remain falsy.
                type = clear_mutref(type);
            }
        }

        // Because values remain values and refs remain refs,
        //  there's no copying/moving involved in an && chain.
        return solved(node, type, items);
    }


    //

    fn solved(
        node: Node, type: Type, items: SolvedNode[] = [])
            : SolvedNode
    {
        return SolvedNode(
            kind:  node.kind ,
            flags: node.flags,
            value: node.value,
            token: node.token,

            :items, :type);
    }

    fn CallerNode(
        node: Node, mut type: Type, target: Target, mut args: SolvedNode[] = [])
            : SolvedNode
    {
        let overload = GET(target);

        // HACK -
        //  TBD how we make this stuff work in real life.
        //   OR alternatively, do this for arrays too.
        if (overload.kind == "field")
        {
            let head = args.len == 1 && args[0] || fail();
            let headType = head.type || fail();

            type = add_refs(from: headType, to: type);
        }

        // Tag copies and moves.
        else if (args)
        {
            let host_args = overload.args || fail("CallerNode: no host args.");
            for (mut i = 0; i < args.len; i++)
                maybeCopyOrMove(
                    args[i] || fail(), host_args[i].type,
                    isArgument: true);

            type.lifetime = Lifetime_fromCallArgs(
                type.lifetime, args);
        }

        // Track deps.
        if (target.modid == module.modid)
        {
            if (overload.kind == "fn")
            {
                // Tracking call graph.
                GET_mut(target).used_by.set::add(
                    _current_fn.target.index);
            }

            if (_current_fn)
            {
                // Robust closure tracking.
                let o = GET(target);
                if (o.flags & F_LOCAL)
                    _current_fn.locals_used.set::add(target.index);

                _current_fn.locals_used.set::add_set(o.closes_over);
            }
        }

        //
        mut out = solved(node, type, args);
        out.target = target;
        return out;
    }

    fn maybeCopyOrMove(ref node: SolvedNode, slot: Type,
        isArgument = false): void
    {
        let q = slot.quals;

        // Clear mutrefs unless needed.
        if !(q & q_mutref)
            node.type.quals &= ~q_mutref;

        // No copy needed when the slot is a reference.
        if (q & q_ref)
        {
            // Except if we're talking a fnarg,
            //  in which case we're better off binding a temporary,
            //   else we risk cache missing on the useless global defval.
            if (node.kind == "definit" && isArgument)
                node.type.quals &= ~q_ref;

            return;
        }

        // Also, no copy needed when the expression is a value.
        if !(node.type.quals & q_ref)
            return;

        // Definits can just as well emit values.
        if (node.kind == "definit")
        {
            node.type.quals &= ~q_ref;
            return;
        }

        if !(q & q_rx_copy)
            fail("Needs an explicit STEAL or CLONE.");

        if (WARN_ON_IMPLICIT_COPY)
        {
            // if !(node.type.quals & q_trivial)
            //     println("WARN ", _here.line, ":", _here.col, ":\timplicit copy ", node.type.canon);
        }

        // Here we go.
        node = createCopy(node);
    }

    fn createCopy(node: SolvedNode): SolvedNode
        SolvedNode(
            kind:   "copy",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));

    fn createMove(node: SolvedNode, nrvo = false): SolvedNode
        SolvedNode(
            kind:   nrvo ? "nrvo" : "move",
            items:  [ node ],
            token:  node.token,
            type:   clear_refs(node.type));


    //

    fn solveNodes(
        nodes: Node[],
        type_all?: Type, type_last?!: Type,
        use_type_last?!: bool,
        TEMP_open_templates?!: bool): SolvedNode[]
    {
        mut result: SolvedNode[];

        //////////////////
        let here0 = _here;
        //////////////////

        result.resize(nodes.len);

        for (mut i = 0; i < nodes.len; i++)
        {
            let node = nodes[i];
            if (!node)
                continue;

            // Regular solve.
            if (!isUnordered(node.kind))
            {
                _here       = node.token || _here;
                result[i]   = solveNode(:node, type:
                    i == nodes.len - 1 && use_type_last
                        ? type_last : type_all);

                continue;
            }

            // Unordered solve -
            //  batches multiple potentially recursive declarations,
            //   so we can expose them all in scope prior to solving types.

            // This allows us to have groups of mutually recursive types & functions,
            //  without risking stuff depending on constants & variables
            //   introduced halfway through.
            let i0 = i;
            mut i1 = nodes.len;

            ////////////////////////////
            mut resolve0 = SLOW_resolve;
            ////////////////////////////

            // First pass, expose stuff in scope
            //  without doing type checking when possible.
            for (shadow mut i = i0; i < nodes.len; i++)
            {
                shadow let node = nodes[i];
                if (!node)
                    continue;

                if (!isUnordered(node.kind))
                {
                    i1 = i;
                    break;
                }

                _here       = node.token || _here;

                if (node.kind != "fn")
                    result[i] = unorderedPrep(node);
            }

            // Later we'll continue from group end.
            i1 > i0 || fail();
            i = i1 - 1; // <- loop++

            // TODO fix this shit
            {
                // Second pass - solve types.
                for (shadow mut i = i0; i < i1; i++)
                {
                    shadow let node = nodes[i];
                    if (node && node.kind != "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedSolve(node, result[i]);
                    }
                }

                // Third pass - prep fns.
                for (shadow mut i = i0; i < i1; i++)
                {
                    shadow let node = nodes[i];
                    if (node.kind == "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedPrep(node);
                    }
                }

                // Finally - solve fns.
                for (shadow mut i = i0; i < i1; i++)
                {
                    shadow let node = nodes[i];
                    if (node.kind == "fn")
                    {
                        _here       = node.token || _here;
                        result[i]   = unorderedSolve(node, result[i]);
                    }
                }
            }

            // Exhaust the resolve queue here.
            {
                mut some = SLOW_resolve != resolve0
                        && SLOW_resolve != resolve_done;

                while (some)
                {
                    some = false;

                    ////////////////////////
                    resolve0 = SLOW_resolve;
                    ////////////////////////

                    for (shadow mut i = i0; i < i1; i++)
                    {
                        let r = result[i];
                        if (r.kind != "fndef" || !resolveIfNeeded_nonTemplateFn(r.target))
                            continue;

                        some = SLOW_resolve != resolve0
                            && SLOW_resolve != resolve_done;
                    }

                    if (TEMP_open_templates)
                    {
                        for (shadow mut i = 0; i < _open_templates.len; i++)
                        {
                            let r = _open_templates[i];
                            if (!resolveIfNeeded_templateSpec(r))
                                continue;

                            some = SLOW_resolve != resolve0
                                && SLOW_resolve != resolve_done;
                        }
                    }
                }
            }

            // Lock things down.
            for (shadow mut i = i0; i < i1; i++)
            {
                let r = result[i];
                if (r.kind == "fndef")
                {
                    ref o = GET_mut(r.target);
                    o.status |= SS_FINALIZED;
                }
            }

            // Also freeze templates.
            if (TEMP_open_templates)
            {
                for (shadow mut i = 0; i < _open_templates.len; i++)
                {
                    let r = _open_templates[i];
                    ref o = GET_mut(r.spec);
                    if (o.kind == "fn")
                        o.status |= SS_FINALIZED;
                }

                _open_templates.clear();
            }
        }

        result.len == nodes.len || fail("solveNodes: result.len != nodes.len");

        //////////////
        _here = here0;
        //////////////

        return result;
    }

    fn resolveIfNeeded_nonTemplateFn(target: Target): bool
    {
        let overload = GET(target);
        if !(overload.status & SS_DIRTY)
            return false;

        GET_mut(target).status &= ~SS_DIRTY;
        resolve_done++;

        //////////////////
        let here0 = _here;
        _here = overload.template.node.token;
        //////////////////

        unorderedSolve(
            overload.template.node,
            overload.solved);

        //////////////
        _here = here0;
        //////////////

        return true;
    }

    fn resolveIfNeeded_templateSpec(ot: OpenTemplate): bool
    {
        let overload = GET(ot.spec);
        if !(overload.status & SS_DIRTY)
            return false;

        GET_mut(ot.spec).status &= ~SS_DIRTY;
        resolve_done++;

        //////////////////
        let here0 = _here;
        _here = overload.template.node.token;
        //////////////////

        mut mangle = ot.mangle;

        doTrySpecialize(
            :ot.overloadIdx, :ot.args, :mangle,
            into: ot.spec);

        //////////////
        _here = here0;
        //////////////

        return true;
    }


    // SOLVE END

    // Import prelude / inject builtins.
    if (module.modid)
    {
        // Ensure can't reimport self.
        _scope.imports ~= module.modid;

        // Load prelude.
        _Scope_import__forceCopy(0);
    }
    else
    {
        // Pre-populate prelude with primitive types and such.
        _scope = listGlobals();
    }

    // Solve.
    {
        let root  = solveNode(parse);
        let scope = Scope_exports(_scope, :module.modid);

        _current_fn && fail("non-empty _current_fn.");
        SLOW_resolve == resolve_done || fail("Some overload was left dirty.");

        // Run the thing.
        return SolverOutput(:root, :scope,
            :SLOW_resolve);
    }
}
